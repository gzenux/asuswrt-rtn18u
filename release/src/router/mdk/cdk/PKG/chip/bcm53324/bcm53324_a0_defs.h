#ifndef __BCM53324_A0_DEFS_H__
#define __BCM53324_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM53324_A0.
 * This file provides all basic definitions required to program the BCM53324_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/xgs_reg.h>
#include <cdk/arch/xgs_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CMIC physical block/port */
#define BCM53324_A0_CMIC_BLOCK          0
#define BCM53324_A0_CMIC_PORT           0

/* Additional block types */
#define BCM53324_A0_BLKTYPE_CMIC        0
#define BCM53324_A0_BLKTYPE_EPIPE       1
#define BCM53324_A0_BLKTYPE_EPIPE_HI    2
#define BCM53324_A0_BLKTYPE_GPORT       3
#define BCM53324_A0_BLKTYPE_IPIPE       4
#define BCM53324_A0_BLKTYPE_IPIPE_HI    5
#define BCM53324_A0_BLKTYPE_MMU         6

#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_BLOCK                      BCM53324_A0_CMIC_BLOCK
#define CMIC_PORT                       BCM53324_A0_CMIC_PORT

#define BLKTYPE_CMIC                    BCM53324_A0_BLKTYPE_CMIC
#define BLKTYPE_EPIPE                   BCM53324_A0_BLKTYPE_EPIPE
#define BLKTYPE_EPIPE_HI                BCM53324_A0_BLKTYPE_EPIPE_HI
#define BLKTYPE_GPORT                   BCM53324_A0_BLKTYPE_GPORT
#define BLKTYPE_IPIPE                   BCM53324_A0_BLKTYPE_IPIPE
#define BLKTYPE_IPIPE_HI                BCM53324_A0_BLKTYPE_IPIPE_HI
#define BLKTYPE_MMU                     BCM53324_A0_BLKTYPE_MMU

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  AGINGCTRMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm 
 *     WW               Weak Write 
 *
 ******************************************************************************/
#define BCM53324_A0_AGINGCTRMEMDEBUGr 0x00680032

#define BCM53324_A0_AGINGCTRMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program AGINGCTRMEMDEBUG.
 *
 */
typedef union BCM53324_A0_AGINGCTRMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t agingctrmemdebug[1];
	uint32_t _agingctrmemdebug;
} BCM53324_A0_AGINGCTRMEMDEBUGr_t;

#define BCM53324_A0_AGINGCTRMEMDEBUGr_CLR(r) (r).agingctrmemdebug[0] = 0
#define BCM53324_A0_AGINGCTRMEMDEBUGr_SET(r,d) (r).agingctrmemdebug[0] = d
#define BCM53324_A0_AGINGCTRMEMDEBUGr_GET(r) (r).agingctrmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_AGINGCTRMEMDEBUGr_TMf_GET(r) (((r).agingctrmemdebug[0]) & 0xff)
#define BCM53324_A0_AGINGCTRMEMDEBUGr_TMf_SET(r,f) (r).agingctrmemdebug[0]=(((r).agingctrmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_AGINGCTRMEMDEBUGr_WWf_GET(r) ((((r).agingctrmemdebug[0]) >> 8) & 0x1)
#define BCM53324_A0_AGINGCTRMEMDEBUGr_WWf_SET(r,f) (r).agingctrmemdebug[0]=(((r).agingctrmemdebug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access AGINGCTRMEMDEBUG.
 *
 */
#define BCM53324_A0_READ_AGINGCTRMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_AGINGCTRMEMDEBUGr,(r._agingctrmemdebug))
#define BCM53324_A0_WRITE_AGINGCTRMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_AGINGCTRMEMDEBUGr,&(r._agingctrmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AGINGCTRMEMDEBUGr BCM53324_A0_AGINGCTRMEMDEBUGr
#define AGINGCTRMEMDEBUGr_SIZE BCM53324_A0_AGINGCTRMEMDEBUGr_SIZE
typedef BCM53324_A0_AGINGCTRMEMDEBUGr_t AGINGCTRMEMDEBUGr_t;
#define AGINGCTRMEMDEBUGr_CLR BCM53324_A0_AGINGCTRMEMDEBUGr_CLR
#define AGINGCTRMEMDEBUGr_SET BCM53324_A0_AGINGCTRMEMDEBUGr_SET
#define AGINGCTRMEMDEBUGr_GET BCM53324_A0_AGINGCTRMEMDEBUGr_GET
#define AGINGCTRMEMDEBUGr_TMf_GET BCM53324_A0_AGINGCTRMEMDEBUGr_TMf_GET
#define AGINGCTRMEMDEBUGr_TMf_SET BCM53324_A0_AGINGCTRMEMDEBUGr_TMf_SET
#define AGINGCTRMEMDEBUGr_WWf_GET BCM53324_A0_AGINGCTRMEMDEBUGr_WWf_GET
#define AGINGCTRMEMDEBUGr_WWf_SET BCM53324_A0_AGINGCTRMEMDEBUGr_WWf_SET
#define READ_AGINGCTRMEMDEBUGr BCM53324_A0_READ_AGINGCTRMEMDEBUGr
#define WRITE_AGINGCTRMEMDEBUGr BCM53324_A0_WRITE_AGINGCTRMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_AGINGCTRMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  AUTOVOIP_OUI_1
 * BLOCKS:   IPIPE
 * DESC:     Holds first of the total six OUI's to be compared against frame's MAC_DA.OUI or MAC_SA.OUI for a possible match in case when UM_AUTO_VOIP_CONTROL.OUI_BASED_QUEUE_ENABLE bit is set to 1
 * SIZE:     32
 * FIELDS:
 *     OUI              first of the total six OUI's to be compared. Corresponds to CISCO
 *
 ******************************************************************************/
#define BCM53324_A0_AUTOVOIP_OUI_1r 0x02780011

#define BCM53324_A0_AUTOVOIP_OUI_1r_SIZE 4

/*
 * This structure should be used to declare and program AUTOVOIP_OUI_1.
 *
 */
typedef union BCM53324_A0_AUTOVOIP_OUI_1r_s {
	uint32_t v[1];
	uint32_t autovoip_oui_1[1];
	uint32_t _autovoip_oui_1;
} BCM53324_A0_AUTOVOIP_OUI_1r_t;

#define BCM53324_A0_AUTOVOIP_OUI_1r_CLR(r) (r).autovoip_oui_1[0] = 0
#define BCM53324_A0_AUTOVOIP_OUI_1r_SET(r,d) (r).autovoip_oui_1[0] = d
#define BCM53324_A0_AUTOVOIP_OUI_1r_GET(r) (r).autovoip_oui_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_AUTOVOIP_OUI_1r_OUIf_GET(r) (((r).autovoip_oui_1[0]) & 0xffffff)
#define BCM53324_A0_AUTOVOIP_OUI_1r_OUIf_SET(r,f) (r).autovoip_oui_1[0]=(((r).autovoip_oui_1[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access AUTOVOIP_OUI_1.
 *
 */
#define BCM53324_A0_READ_AUTOVOIP_OUI_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_AUTOVOIP_OUI_1r,(r._autovoip_oui_1))
#define BCM53324_A0_WRITE_AUTOVOIP_OUI_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_AUTOVOIP_OUI_1r,&(r._autovoip_oui_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUTOVOIP_OUI_1r BCM53324_A0_AUTOVOIP_OUI_1r
#define AUTOVOIP_OUI_1r_SIZE BCM53324_A0_AUTOVOIP_OUI_1r_SIZE
typedef BCM53324_A0_AUTOVOIP_OUI_1r_t AUTOVOIP_OUI_1r_t;
#define AUTOVOIP_OUI_1r_CLR BCM53324_A0_AUTOVOIP_OUI_1r_CLR
#define AUTOVOIP_OUI_1r_SET BCM53324_A0_AUTOVOIP_OUI_1r_SET
#define AUTOVOIP_OUI_1r_GET BCM53324_A0_AUTOVOIP_OUI_1r_GET
#define AUTOVOIP_OUI_1r_OUIf_GET BCM53324_A0_AUTOVOIP_OUI_1r_OUIf_GET
#define AUTOVOIP_OUI_1r_OUIf_SET BCM53324_A0_AUTOVOIP_OUI_1r_OUIf_SET
#define READ_AUTOVOIP_OUI_1r BCM53324_A0_READ_AUTOVOIP_OUI_1r
#define WRITE_AUTOVOIP_OUI_1r BCM53324_A0_WRITE_AUTOVOIP_OUI_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_AUTOVOIP_OUI_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  AUTOVOIP_OUI_2
 * BLOCKS:   IPIPE
 * DESC:     Holds first of the total six OUI's to be compared against frame's MAC_DA.OUI or MAC_SA.OUI for a possible match in case when UM_AUTO_VOIP_CONTROL.OUI_BASED_QUEUE_ENABLE bit is set to 1
 * SIZE:     32
 * FIELDS:
 *     OUI              Second of the total six OUI's to be compared. Corresponds to AVAYA
 *
 ******************************************************************************/
#define BCM53324_A0_AUTOVOIP_OUI_2r 0x02780012

#define BCM53324_A0_AUTOVOIP_OUI_2r_SIZE 4

/*
 * This structure should be used to declare and program AUTOVOIP_OUI_2.
 *
 */
typedef union BCM53324_A0_AUTOVOIP_OUI_2r_s {
	uint32_t v[1];
	uint32_t autovoip_oui_2[1];
	uint32_t _autovoip_oui_2;
} BCM53324_A0_AUTOVOIP_OUI_2r_t;

#define BCM53324_A0_AUTOVOIP_OUI_2r_CLR(r) (r).autovoip_oui_2[0] = 0
#define BCM53324_A0_AUTOVOIP_OUI_2r_SET(r,d) (r).autovoip_oui_2[0] = d
#define BCM53324_A0_AUTOVOIP_OUI_2r_GET(r) (r).autovoip_oui_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_AUTOVOIP_OUI_2r_OUIf_GET(r) (((r).autovoip_oui_2[0]) & 0xffffff)
#define BCM53324_A0_AUTOVOIP_OUI_2r_OUIf_SET(r,f) (r).autovoip_oui_2[0]=(((r).autovoip_oui_2[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access AUTOVOIP_OUI_2.
 *
 */
#define BCM53324_A0_READ_AUTOVOIP_OUI_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_AUTOVOIP_OUI_2r,(r._autovoip_oui_2))
#define BCM53324_A0_WRITE_AUTOVOIP_OUI_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_AUTOVOIP_OUI_2r,&(r._autovoip_oui_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUTOVOIP_OUI_2r BCM53324_A0_AUTOVOIP_OUI_2r
#define AUTOVOIP_OUI_2r_SIZE BCM53324_A0_AUTOVOIP_OUI_2r_SIZE
typedef BCM53324_A0_AUTOVOIP_OUI_2r_t AUTOVOIP_OUI_2r_t;
#define AUTOVOIP_OUI_2r_CLR BCM53324_A0_AUTOVOIP_OUI_2r_CLR
#define AUTOVOIP_OUI_2r_SET BCM53324_A0_AUTOVOIP_OUI_2r_SET
#define AUTOVOIP_OUI_2r_GET BCM53324_A0_AUTOVOIP_OUI_2r_GET
#define AUTOVOIP_OUI_2r_OUIf_GET BCM53324_A0_AUTOVOIP_OUI_2r_OUIf_GET
#define AUTOVOIP_OUI_2r_OUIf_SET BCM53324_A0_AUTOVOIP_OUI_2r_OUIf_SET
#define READ_AUTOVOIP_OUI_2r BCM53324_A0_READ_AUTOVOIP_OUI_2r
#define WRITE_AUTOVOIP_OUI_2r BCM53324_A0_WRITE_AUTOVOIP_OUI_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_AUTOVOIP_OUI_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  AUTOVOIP_OUI_3
 * BLOCKS:   IPIPE
 * DESC:     Holds first of the total six OUI's to be compared against frame's MAC_DA.OUI or MAC_SA.OUI for a possible match in case when UM_AUTO_VOIP_CONTROL.OUI_BASED_QUEUE_ENABLE bit is set to 1
 * SIZE:     32
 * FIELDS:
 *     OUI              Third of the total six OUI's to be compared. Corresponds to 3COM
 *
 ******************************************************************************/
#define BCM53324_A0_AUTOVOIP_OUI_3r 0x02780013

#define BCM53324_A0_AUTOVOIP_OUI_3r_SIZE 4

/*
 * This structure should be used to declare and program AUTOVOIP_OUI_3.
 *
 */
typedef union BCM53324_A0_AUTOVOIP_OUI_3r_s {
	uint32_t v[1];
	uint32_t autovoip_oui_3[1];
	uint32_t _autovoip_oui_3;
} BCM53324_A0_AUTOVOIP_OUI_3r_t;

#define BCM53324_A0_AUTOVOIP_OUI_3r_CLR(r) (r).autovoip_oui_3[0] = 0
#define BCM53324_A0_AUTOVOIP_OUI_3r_SET(r,d) (r).autovoip_oui_3[0] = d
#define BCM53324_A0_AUTOVOIP_OUI_3r_GET(r) (r).autovoip_oui_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_AUTOVOIP_OUI_3r_OUIf_GET(r) (((r).autovoip_oui_3[0]) & 0xffffff)
#define BCM53324_A0_AUTOVOIP_OUI_3r_OUIf_SET(r,f) (r).autovoip_oui_3[0]=(((r).autovoip_oui_3[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access AUTOVOIP_OUI_3.
 *
 */
#define BCM53324_A0_READ_AUTOVOIP_OUI_3r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_AUTOVOIP_OUI_3r,(r._autovoip_oui_3))
#define BCM53324_A0_WRITE_AUTOVOIP_OUI_3r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_AUTOVOIP_OUI_3r,&(r._autovoip_oui_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUTOVOIP_OUI_3r BCM53324_A0_AUTOVOIP_OUI_3r
#define AUTOVOIP_OUI_3r_SIZE BCM53324_A0_AUTOVOIP_OUI_3r_SIZE
typedef BCM53324_A0_AUTOVOIP_OUI_3r_t AUTOVOIP_OUI_3r_t;
#define AUTOVOIP_OUI_3r_CLR BCM53324_A0_AUTOVOIP_OUI_3r_CLR
#define AUTOVOIP_OUI_3r_SET BCM53324_A0_AUTOVOIP_OUI_3r_SET
#define AUTOVOIP_OUI_3r_GET BCM53324_A0_AUTOVOIP_OUI_3r_GET
#define AUTOVOIP_OUI_3r_OUIf_GET BCM53324_A0_AUTOVOIP_OUI_3r_OUIf_GET
#define AUTOVOIP_OUI_3r_OUIf_SET BCM53324_A0_AUTOVOIP_OUI_3r_OUIf_SET
#define READ_AUTOVOIP_OUI_3r BCM53324_A0_READ_AUTOVOIP_OUI_3r
#define WRITE_AUTOVOIP_OUI_3r BCM53324_A0_WRITE_AUTOVOIP_OUI_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_AUTOVOIP_OUI_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  AUTOVOIP_OUI_4
 * BLOCKS:   IPIPE
 * DESC:     Holds first of the total six OUI's to be compared against frame's MAC_DA.OUI or MAC_SA.OUI for a possible match in case when UM_AUTO_VOIP_CONTROL.OUI_BASED_QUEUE_ENABLE bit is set to 1
 * SIZE:     32
 * FIELDS:
 *     OUI              Fourth of the total six OUI's to be compared. Corresponds to POLYCOM
 *
 ******************************************************************************/
#define BCM53324_A0_AUTOVOIP_OUI_4r 0x02780014

#define BCM53324_A0_AUTOVOIP_OUI_4r_SIZE 4

/*
 * This structure should be used to declare and program AUTOVOIP_OUI_4.
 *
 */
typedef union BCM53324_A0_AUTOVOIP_OUI_4r_s {
	uint32_t v[1];
	uint32_t autovoip_oui_4[1];
	uint32_t _autovoip_oui_4;
} BCM53324_A0_AUTOVOIP_OUI_4r_t;

#define BCM53324_A0_AUTOVOIP_OUI_4r_CLR(r) (r).autovoip_oui_4[0] = 0
#define BCM53324_A0_AUTOVOIP_OUI_4r_SET(r,d) (r).autovoip_oui_4[0] = d
#define BCM53324_A0_AUTOVOIP_OUI_4r_GET(r) (r).autovoip_oui_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_AUTOVOIP_OUI_4r_OUIf_GET(r) (((r).autovoip_oui_4[0]) & 0xffffff)
#define BCM53324_A0_AUTOVOIP_OUI_4r_OUIf_SET(r,f) (r).autovoip_oui_4[0]=(((r).autovoip_oui_4[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access AUTOVOIP_OUI_4.
 *
 */
#define BCM53324_A0_READ_AUTOVOIP_OUI_4r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_AUTOVOIP_OUI_4r,(r._autovoip_oui_4))
#define BCM53324_A0_WRITE_AUTOVOIP_OUI_4r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_AUTOVOIP_OUI_4r,&(r._autovoip_oui_4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUTOVOIP_OUI_4r BCM53324_A0_AUTOVOIP_OUI_4r
#define AUTOVOIP_OUI_4r_SIZE BCM53324_A0_AUTOVOIP_OUI_4r_SIZE
typedef BCM53324_A0_AUTOVOIP_OUI_4r_t AUTOVOIP_OUI_4r_t;
#define AUTOVOIP_OUI_4r_CLR BCM53324_A0_AUTOVOIP_OUI_4r_CLR
#define AUTOVOIP_OUI_4r_SET BCM53324_A0_AUTOVOIP_OUI_4r_SET
#define AUTOVOIP_OUI_4r_GET BCM53324_A0_AUTOVOIP_OUI_4r_GET
#define AUTOVOIP_OUI_4r_OUIf_GET BCM53324_A0_AUTOVOIP_OUI_4r_OUIf_GET
#define AUTOVOIP_OUI_4r_OUIf_SET BCM53324_A0_AUTOVOIP_OUI_4r_OUIf_SET
#define READ_AUTOVOIP_OUI_4r BCM53324_A0_READ_AUTOVOIP_OUI_4r
#define WRITE_AUTOVOIP_OUI_4r BCM53324_A0_WRITE_AUTOVOIP_OUI_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_AUTOVOIP_OUI_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  AUTOVOIP_OUI_5
 * BLOCKS:   IPIPE
 * DESC:     Holds first of the total six OUI's to be compared against frame's MAC_DA.OUI or MAC_SA.OUI for a possible match in case when UM_AUTO_VOIP_CONTROL.OUI_BASED_QUEUE_ENABLE bit is set to 1
 * SIZE:     32
 * FIELDS:
 *     OUI              Fifth of the total six OUI's to be compared. Corresponds to H3C
 *
 ******************************************************************************/
#define BCM53324_A0_AUTOVOIP_OUI_5r 0x02780015

#define BCM53324_A0_AUTOVOIP_OUI_5r_SIZE 4

/*
 * This structure should be used to declare and program AUTOVOIP_OUI_5.
 *
 */
typedef union BCM53324_A0_AUTOVOIP_OUI_5r_s {
	uint32_t v[1];
	uint32_t autovoip_oui_5[1];
	uint32_t _autovoip_oui_5;
} BCM53324_A0_AUTOVOIP_OUI_5r_t;

#define BCM53324_A0_AUTOVOIP_OUI_5r_CLR(r) (r).autovoip_oui_5[0] = 0
#define BCM53324_A0_AUTOVOIP_OUI_5r_SET(r,d) (r).autovoip_oui_5[0] = d
#define BCM53324_A0_AUTOVOIP_OUI_5r_GET(r) (r).autovoip_oui_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_AUTOVOIP_OUI_5r_OUIf_GET(r) (((r).autovoip_oui_5[0]) & 0xffffff)
#define BCM53324_A0_AUTOVOIP_OUI_5r_OUIf_SET(r,f) (r).autovoip_oui_5[0]=(((r).autovoip_oui_5[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access AUTOVOIP_OUI_5.
 *
 */
#define BCM53324_A0_READ_AUTOVOIP_OUI_5r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_AUTOVOIP_OUI_5r,(r._autovoip_oui_5))
#define BCM53324_A0_WRITE_AUTOVOIP_OUI_5r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_AUTOVOIP_OUI_5r,&(r._autovoip_oui_5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUTOVOIP_OUI_5r BCM53324_A0_AUTOVOIP_OUI_5r
#define AUTOVOIP_OUI_5r_SIZE BCM53324_A0_AUTOVOIP_OUI_5r_SIZE
typedef BCM53324_A0_AUTOVOIP_OUI_5r_t AUTOVOIP_OUI_5r_t;
#define AUTOVOIP_OUI_5r_CLR BCM53324_A0_AUTOVOIP_OUI_5r_CLR
#define AUTOVOIP_OUI_5r_SET BCM53324_A0_AUTOVOIP_OUI_5r_SET
#define AUTOVOIP_OUI_5r_GET BCM53324_A0_AUTOVOIP_OUI_5r_GET
#define AUTOVOIP_OUI_5r_OUIf_GET BCM53324_A0_AUTOVOIP_OUI_5r_OUIf_GET
#define AUTOVOIP_OUI_5r_OUIf_SET BCM53324_A0_AUTOVOIP_OUI_5r_OUIf_SET
#define READ_AUTOVOIP_OUI_5r BCM53324_A0_READ_AUTOVOIP_OUI_5r
#define WRITE_AUTOVOIP_OUI_5r BCM53324_A0_WRITE_AUTOVOIP_OUI_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_AUTOVOIP_OUI_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  AUTOVOIP_OUI_6
 * BLOCKS:   IPIPE
 * DESC:     Holds first of the total six OUI's to be compared against frame's MAC_DA.OUI or MAC_SA.OUI for a possible match in case when UM_AUTO_VOIP_CONTROL.OUI_BASED_QUEUE_ENABLE bit is set to 1
 * SIZE:     32
 * FIELDS:
 *     OUI              Sixth of the total six OUI's to be compared. Corresponds to NEC
 *
 ******************************************************************************/
#define BCM53324_A0_AUTOVOIP_OUI_6r 0x02780016

#define BCM53324_A0_AUTOVOIP_OUI_6r_SIZE 4

/*
 * This structure should be used to declare and program AUTOVOIP_OUI_6.
 *
 */
typedef union BCM53324_A0_AUTOVOIP_OUI_6r_s {
	uint32_t v[1];
	uint32_t autovoip_oui_6[1];
	uint32_t _autovoip_oui_6;
} BCM53324_A0_AUTOVOIP_OUI_6r_t;

#define BCM53324_A0_AUTOVOIP_OUI_6r_CLR(r) (r).autovoip_oui_6[0] = 0
#define BCM53324_A0_AUTOVOIP_OUI_6r_SET(r,d) (r).autovoip_oui_6[0] = d
#define BCM53324_A0_AUTOVOIP_OUI_6r_GET(r) (r).autovoip_oui_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_AUTOVOIP_OUI_6r_OUIf_GET(r) (((r).autovoip_oui_6[0]) & 0xffffff)
#define BCM53324_A0_AUTOVOIP_OUI_6r_OUIf_SET(r,f) (r).autovoip_oui_6[0]=(((r).autovoip_oui_6[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access AUTOVOIP_OUI_6.
 *
 */
#define BCM53324_A0_READ_AUTOVOIP_OUI_6r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_AUTOVOIP_OUI_6r,(r._autovoip_oui_6))
#define BCM53324_A0_WRITE_AUTOVOIP_OUI_6r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_AUTOVOIP_OUI_6r,&(r._autovoip_oui_6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUTOVOIP_OUI_6r BCM53324_A0_AUTOVOIP_OUI_6r
#define AUTOVOIP_OUI_6r_SIZE BCM53324_A0_AUTOVOIP_OUI_6r_SIZE
typedef BCM53324_A0_AUTOVOIP_OUI_6r_t AUTOVOIP_OUI_6r_t;
#define AUTOVOIP_OUI_6r_CLR BCM53324_A0_AUTOVOIP_OUI_6r_CLR
#define AUTOVOIP_OUI_6r_SET BCM53324_A0_AUTOVOIP_OUI_6r_SET
#define AUTOVOIP_OUI_6r_GET BCM53324_A0_AUTOVOIP_OUI_6r_GET
#define AUTOVOIP_OUI_6r_OUIf_GET BCM53324_A0_AUTOVOIP_OUI_6r_OUIf_GET
#define AUTOVOIP_OUI_6r_OUIf_SET BCM53324_A0_AUTOVOIP_OUI_6r_OUIf_SET
#define READ_AUTOVOIP_OUI_6r BCM53324_A0_READ_AUTOVOIP_OUI_6r
#define WRITE_AUTOVOIP_OUI_6r BCM53324_A0_WRITE_AUTOVOIP_OUI_6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_AUTOVOIP_OUI_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  AUX_ARB_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register
 * SIZE:     32
 * FIELDS:
 *     L2_MOD_FIFO_LOCK Set to 1 to lock the L2_MOD_FIFO, clearing empties the L2_MOD_FIFO
 *     L2_MOD_FIFO_ENABLE Enables tracking the L2_MOD_FIFO, this cause learns/ages to get blocked when full
 *     FP_REFRESH_ENABLE Enables sending FP refreshes down the pipeline
 *     CLK_GRAN         clock granularity for ages (speed up for simulation use only)
 *
 ******************************************************************************/
#define BCM53324_A0_AUX_ARB_CONTROLr 0x00780000

#define BCM53324_A0_AUX_ARB_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL.
 *
 */
typedef union BCM53324_A0_AUX_ARB_CONTROLr_s {
	uint32_t v[1];
	uint32_t aux_arb_control[1];
	uint32_t _aux_arb_control;
} BCM53324_A0_AUX_ARB_CONTROLr_t;

#define BCM53324_A0_AUX_ARB_CONTROLr_CLR(r) (r).aux_arb_control[0] = 0
#define BCM53324_A0_AUX_ARB_CONTROLr_SET(r,d) (r).aux_arb_control[0] = d
#define BCM53324_A0_AUX_ARB_CONTROLr_GET(r) (r).aux_arb_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET(r) (((r).aux_arb_control[0]) & 0x1)
#define BCM53324_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET(r) ((((r).aux_arb_control[0]) >> 1) & 0x1)
#define BCM53324_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET(r) ((((r).aux_arb_control[0]) >> 2) & 0x1)
#define BCM53324_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_AUX_ARB_CONTROLr_CLK_GRANf_GET(r) ((((r).aux_arb_control[0]) >> 3) & 0x3)
#define BCM53324_A0_AUX_ARB_CONTROLr_CLK_GRANf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))

/*
 * These macros can be used to access AUX_ARB_CONTROL.
 *
 */
#define BCM53324_A0_READ_AUX_ARB_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_AUX_ARB_CONTROLr,(r._aux_arb_control))
#define BCM53324_A0_WRITE_AUX_ARB_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_AUX_ARB_CONTROLr,&(r._aux_arb_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_ARB_CONTROLr BCM53324_A0_AUX_ARB_CONTROLr
#define AUX_ARB_CONTROLr_SIZE BCM53324_A0_AUX_ARB_CONTROLr_SIZE
typedef BCM53324_A0_AUX_ARB_CONTROLr_t AUX_ARB_CONTROLr_t;
#define AUX_ARB_CONTROLr_CLR BCM53324_A0_AUX_ARB_CONTROLr_CLR
#define AUX_ARB_CONTROLr_SET BCM53324_A0_AUX_ARB_CONTROLr_SET
#define AUX_ARB_CONTROLr_GET BCM53324_A0_AUX_ARB_CONTROLr_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET BCM53324_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET BCM53324_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET BCM53324_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET BCM53324_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET
#define AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET BCM53324_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_GET
#define AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET BCM53324_A0_AUX_ARB_CONTROLr_FP_REFRESH_ENABLEf_SET
#define AUX_ARB_CONTROLr_CLK_GRANf_GET BCM53324_A0_AUX_ARB_CONTROLr_CLK_GRANf_GET
#define AUX_ARB_CONTROLr_CLK_GRANf_SET BCM53324_A0_AUX_ARB_CONTROLr_CLK_GRANf_SET
#define READ_AUX_ARB_CONTROLr BCM53324_A0_READ_AUX_ARB_CONTROLr
#define WRITE_AUX_ARB_CONTROLr BCM53324_A0_WRITE_AUX_ARB_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_AUX_ARB_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  BCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Broadcast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM53324_A0_BCAST_BLOCK_MASKr 0x0f700104

#define BCM53324_A0_BCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_BLOCK_MASK.
 *
 */
typedef union BCM53324_A0_BCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t bcast_block_mask[1];
	uint32_t _bcast_block_mask;
} BCM53324_A0_BCAST_BLOCK_MASKr_t;

#define BCM53324_A0_BCAST_BLOCK_MASKr_CLR(r) (r).bcast_block_mask[0] = 0
#define BCM53324_A0_BCAST_BLOCK_MASKr_SET(r,d) (r).bcast_block_mask[0] = d
#define BCM53324_A0_BCAST_BLOCK_MASKr_GET(r) (r).bcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).bcast_block_mask[0]) & 0x1ffffff)
#define BCM53324_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).bcast_block_mask[0]=(((r).bcast_block_mask[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access BCAST_BLOCK_MASK.
 *
 */
#define BCM53324_A0_READ_BCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_BCAST_BLOCK_MASKr,(r._bcast_block_mask))
#define BCM53324_A0_WRITE_BCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_BCAST_BLOCK_MASKr,&(r._bcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_BLOCK_MASKr BCM53324_A0_BCAST_BLOCK_MASKr
#define BCAST_BLOCK_MASKr_SIZE BCM53324_A0_BCAST_BLOCK_MASKr_SIZE
typedef BCM53324_A0_BCAST_BLOCK_MASKr_t BCAST_BLOCK_MASKr_t;
#define BCAST_BLOCK_MASKr_CLR BCM53324_A0_BCAST_BLOCK_MASKr_CLR
#define BCAST_BLOCK_MASKr_SET BCM53324_A0_BCAST_BLOCK_MASKr_SET
#define BCAST_BLOCK_MASKr_GET BCM53324_A0_BCAST_BLOCK_MASKr_GET
#define BCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM53324_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define BCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM53324_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_BCAST_BLOCK_MASKr BCM53324_A0_READ_BCAST_BLOCK_MASKr
#define WRITE_BCAST_BLOCK_MASKr BCM53324_A0_WRITE_BCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_BCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  BCAST_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Broadcast Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           Broadcast rate control enable
 *
 ******************************************************************************/
#define BCM53324_A0_BCAST_STORM_CONTROLr 0x0c700001

#define BCM53324_A0_BCAST_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_STORM_CONTROL.
 *
 */
typedef union BCM53324_A0_BCAST_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t bcast_storm_control[1];
	uint32_t _bcast_storm_control;
} BCM53324_A0_BCAST_STORM_CONTROLr_t;

#define BCM53324_A0_BCAST_STORM_CONTROLr_CLR(r) (r).bcast_storm_control[0] = 0
#define BCM53324_A0_BCAST_STORM_CONTROLr_SET(r,d) (r).bcast_storm_control[0] = d
#define BCM53324_A0_BCAST_STORM_CONTROLr_GET(r) (r).bcast_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_BCAST_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).bcast_storm_control[0]) & 0x1ffffff)
#define BCM53324_A0_BCAST_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).bcast_storm_control[0]=(((r).bcast_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_BCAST_STORM_CONTROLr_ENABLEf_GET(r) ((((r).bcast_storm_control[0]) >> 25) & 0x1)
#define BCM53324_A0_BCAST_STORM_CONTROLr_ENABLEf_SET(r,f) (r).bcast_storm_control[0]=(((r).bcast_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access BCAST_STORM_CONTROL.
 *
 */
#define BCM53324_A0_READ_BCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_BCAST_STORM_CONTROLr,(r._bcast_storm_control))
#define BCM53324_A0_WRITE_BCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_BCAST_STORM_CONTROLr,&(r._bcast_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_STORM_CONTROLr BCM53324_A0_BCAST_STORM_CONTROLr
#define BCAST_STORM_CONTROLr_SIZE BCM53324_A0_BCAST_STORM_CONTROLr_SIZE
typedef BCM53324_A0_BCAST_STORM_CONTROLr_t BCAST_STORM_CONTROLr_t;
#define BCAST_STORM_CONTROLr_CLR BCM53324_A0_BCAST_STORM_CONTROLr_CLR
#define BCAST_STORM_CONTROLr_SET BCM53324_A0_BCAST_STORM_CONTROLr_SET
#define BCAST_STORM_CONTROLr_GET BCM53324_A0_BCAST_STORM_CONTROLr_GET
#define BCAST_STORM_CONTROLr_THRESHOLDf_GET BCM53324_A0_BCAST_STORM_CONTROLr_THRESHOLDf_GET
#define BCAST_STORM_CONTROLr_THRESHOLDf_SET BCM53324_A0_BCAST_STORM_CONTROLr_THRESHOLDf_SET
#define BCAST_STORM_CONTROLr_ENABLEf_GET BCM53324_A0_BCAST_STORM_CONTROLr_ENABLEf_GET
#define BCAST_STORM_CONTROLr_ENABLEf_SET BCM53324_A0_BCAST_STORM_CONTROLr_ENABLEf_SET
#define READ_BCAST_STORM_CONTROLr BCM53324_A0_READ_BCAST_STORM_CONTROLr
#define WRITE_BCAST_STORM_CONTROLr BCM53324_A0_WRITE_BCAST_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_BCAST_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  BKPMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET_COUNT     Pause Metering\'s Bucket Count for each ingress port
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of Back Pressure Metering bucket1: out of profile0: In profile
 *
 ******************************************************************************/
#define BCM53324_A0_BKPMETERINGBUCKETr 0x00600006

#define BCM53324_A0_BKPMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGBUCKET.
 *
 */
typedef union BCM53324_A0_BKPMETERINGBUCKETr_s {
	uint32_t v[1];
	uint32_t bkpmeteringbucket[1];
	uint32_t _bkpmeteringbucket;
} BCM53324_A0_BKPMETERINGBUCKETr_t;

#define BCM53324_A0_BKPMETERINGBUCKETr_CLR(r) (r).bkpmeteringbucket[0] = 0
#define BCM53324_A0_BKPMETERINGBUCKETr_SET(r,d) (r).bkpmeteringbucket[0] = d
#define BCM53324_A0_BKPMETERINGBUCKETr_GET(r) (r).bkpmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_GET(r) (((r).bkpmeteringbucket[0]) & 0x1fffffff)
#define BCM53324_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_SET(r,f) (r).bkpmeteringbucket[0]=(((r).bkpmeteringbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53324_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).bkpmeteringbucket[0]) >> 29) & 0x1)
#define BCM53324_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).bkpmeteringbucket[0]=(((r).bkpmeteringbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access BKPMETERINGBUCKET.
 *
 */
#define BCM53324_A0_READ_BKPMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_BKPMETERINGBUCKETr,(r._bkpmeteringbucket))
#define BCM53324_A0_WRITE_BKPMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_BKPMETERINGBUCKETr,&(r._bkpmeteringbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGBUCKETr BCM53324_A0_BKPMETERINGBUCKETr
#define BKPMETERINGBUCKETr_SIZE BCM53324_A0_BKPMETERINGBUCKETr_SIZE
typedef BCM53324_A0_BKPMETERINGBUCKETr_t BKPMETERINGBUCKETr_t;
#define BKPMETERINGBUCKETr_CLR BCM53324_A0_BKPMETERINGBUCKETr_CLR
#define BKPMETERINGBUCKETr_SET BCM53324_A0_BKPMETERINGBUCKETr_SET
#define BKPMETERINGBUCKETr_GET BCM53324_A0_BKPMETERINGBUCKETr_GET
#define BKPMETERINGBUCKETr_BUCKET_COUNTf_GET BCM53324_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_GET
#define BKPMETERINGBUCKETr_BUCKET_COUNTf_SET BCM53324_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_SET
#define BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET BCM53324_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_GET
#define BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET BCM53324_A0_BKPMETERINGBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_BKPMETERINGBUCKETr BCM53324_A0_READ_BKPMETERINGBUCKETr
#define WRITE_BKPMETERINGBUCKETr BCM53324_A0_WRITE_BKPMETERINGBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_BKPMETERINGBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  BKPMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PAUSE_THD        Threshold determines the size of BKP Metering Bucket. This Threshold setting is not related to actual bandwidth rate number.The Bucket size is range from 4k Bytes to 16M Bytes with 4k Bytes incrementThe Bucket size is determined by the formula,BucketSize = PAUSE_THD * 4KBytesBKP Metering Bucket function is disable when bucket size is 0.
 *     REFRESHCOUNT     Refresh count for Back Pressure Metering bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set REFRESHCOUNT = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set REFRESHCOUNT = 15624.
 *
 ******************************************************************************/
#define BCM53324_A0_BKPMETERINGCONFIGr 0x00600005

#define BCM53324_A0_BKPMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGCONFIG.
 *
 */
typedef union BCM53324_A0_BKPMETERINGCONFIGr_s {
	uint32_t v[1];
	uint32_t bkpmeteringconfig[1];
	uint32_t _bkpmeteringconfig;
} BCM53324_A0_BKPMETERINGCONFIGr_t;

#define BCM53324_A0_BKPMETERINGCONFIGr_CLR(r) (r).bkpmeteringconfig[0] = 0
#define BCM53324_A0_BKPMETERINGCONFIGr_SET(r,d) (r).bkpmeteringconfig[0] = d
#define BCM53324_A0_BKPMETERINGCONFIGr_GET(r) (r).bkpmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_BKPMETERINGCONFIGr_PAUSE_THDf_GET(r) (((r).bkpmeteringconfig[0]) & 0xfff)
#define BCM53324_A0_BKPMETERINGCONFIGr_PAUSE_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_GET(r) ((((r).bkpmeteringconfig[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access BKPMETERINGCONFIG.
 *
 */
#define BCM53324_A0_READ_BKPMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_BKPMETERINGCONFIGr,(r._bkpmeteringconfig))
#define BCM53324_A0_WRITE_BKPMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_BKPMETERINGCONFIGr,&(r._bkpmeteringconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGCONFIGr BCM53324_A0_BKPMETERINGCONFIGr
#define BKPMETERINGCONFIGr_SIZE BCM53324_A0_BKPMETERINGCONFIGr_SIZE
typedef BCM53324_A0_BKPMETERINGCONFIGr_t BKPMETERINGCONFIGr_t;
#define BKPMETERINGCONFIGr_CLR BCM53324_A0_BKPMETERINGCONFIGr_CLR
#define BKPMETERINGCONFIGr_SET BCM53324_A0_BKPMETERINGCONFIGr_SET
#define BKPMETERINGCONFIGr_GET BCM53324_A0_BKPMETERINGCONFIGr_GET
#define BKPMETERINGCONFIGr_PAUSE_THDf_GET BCM53324_A0_BKPMETERINGCONFIGr_PAUSE_THDf_GET
#define BKPMETERINGCONFIGr_PAUSE_THDf_SET BCM53324_A0_BKPMETERINGCONFIGr_PAUSE_THDf_SET
#define BKPMETERINGCONFIGr_REFRESHCOUNTf_GET BCM53324_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_GET
#define BKPMETERINGCONFIGr_REFRESHCOUNTf_SET BCM53324_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_SET
#define READ_BKPMETERINGCONFIGr BCM53324_A0_READ_BKPMETERINGCONFIGr
#define WRITE_BKPMETERINGCONFIGr BCM53324_A0_WRITE_BKPMETERINGCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_BKPMETERINGCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  BKPMETERINGCONFIG_EXT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     RESUME_THD       Resume Threshold for resume reception on pause metering of an ingress port:When Bucket Count reqain above Resume Threshold, it sends out Back PressureWarning Status Clearing Message. 0:  75% of PAUSE_THD.1:  50% of PAUSE_THD.2:  25% of PAUSE_THD.3:  12.5% of PAUSE_THD.
 *     DISCARD_THD      Discard Threshold for discarding packet on Back Pressure Metering bucket of an ingress port:When Bucket Count reqain above Resume Threshold, it sends out Back PressureWarning Status Clearing Message. This Threshold must not over the size of Bucket Count. (256 Mbits)0:  75% of PAUSE_THD above PAUSE_THD.1:  50% of PAUSE_THD above PAUSE_THD.2:  25% of PAUSE_THD above PAUSE_THD.3:  12.5% of PAUSE_THD above PAUSE_THD.
 *     BKPDISCARD_EN    Back Pressure Metering Discard Message Enable:Enable Back Pressure Warning Message to discard packet formthis ingress port when Back Pressure Metering bucket count is above Discard Threshold.   
 *     BKPDISCARD_ACCT_EN Back Pressure Metering Discard Accounting Enable:Enable to account for incoming packet length when a port'sBack Pressure Metering bucket is above its Discard Threshold.   
 *     IFG_ACCT_SEL     Inter Frame Gap Accounting bytes added at SOP cell when packet arrived.0: No extra Inter Frame Gap bytes added.
 *
 ******************************************************************************/
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr 0x006000a4

#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGCONFIG_EXT.
 *
 */
typedef union BCM53324_A0_BKPMETERINGCONFIG_EXTr_s {
	uint32_t v[1];
	uint32_t bkpmeteringconfig_ext[1];
	uint32_t _bkpmeteringconfig_ext;
} BCM53324_A0_BKPMETERINGCONFIG_EXTr_t;

#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_CLR(r) (r).bkpmeteringconfig_ext[0] = 0
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_SET(r,d) (r).bkpmeteringconfig_ext[0] = d
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_GET(r) (r).bkpmeteringconfig_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_RESUME_THDf_GET(r) (((r).bkpmeteringconfig_ext[0]) & 0x3)
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_RESUME_THDf_SET(r,f) (r).bkpmeteringconfig_ext[0]=(((r).bkpmeteringconfig_ext[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_DISCARD_THDf_GET(r) ((((r).bkpmeteringconfig_ext[0]) >> 2) & 0x3)
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_DISCARD_THDf_SET(r,f) (r).bkpmeteringconfig_ext[0]=(((r).bkpmeteringconfig_ext[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_BKPDISCARD_ENf_GET(r) ((((r).bkpmeteringconfig_ext[0]) >> 4) & 0x1)
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_BKPDISCARD_ENf_SET(r,f) (r).bkpmeteringconfig_ext[0]=(((r).bkpmeteringconfig_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_BKPDISCARD_ACCT_ENf_GET(r) ((((r).bkpmeteringconfig_ext[0]) >> 5) & 0x1)
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_BKPDISCARD_ACCT_ENf_SET(r,f) (r).bkpmeteringconfig_ext[0]=(((r).bkpmeteringconfig_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_IFG_ACCT_SELf_GET(r) ((((r).bkpmeteringconfig_ext[0]) >> 6) & 0x3f)
#define BCM53324_A0_BKPMETERINGCONFIG_EXTr_IFG_ACCT_SELf_SET(r,f) (r).bkpmeteringconfig_ext[0]=(((r).bkpmeteringconfig_ext[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))

/*
 * These macros can be used to access BKPMETERINGCONFIG_EXT.
 *
 */
#define BCM53324_A0_READ_BKPMETERINGCONFIG_EXTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_BKPMETERINGCONFIG_EXTr,(r._bkpmeteringconfig_ext))
#define BCM53324_A0_WRITE_BKPMETERINGCONFIG_EXTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_BKPMETERINGCONFIG_EXTr,&(r._bkpmeteringconfig_ext))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGCONFIG_EXTr BCM53324_A0_BKPMETERINGCONFIG_EXTr
#define BKPMETERINGCONFIG_EXTr_SIZE BCM53324_A0_BKPMETERINGCONFIG_EXTr_SIZE
typedef BCM53324_A0_BKPMETERINGCONFIG_EXTr_t BKPMETERINGCONFIG_EXTr_t;
#define BKPMETERINGCONFIG_EXTr_CLR BCM53324_A0_BKPMETERINGCONFIG_EXTr_CLR
#define BKPMETERINGCONFIG_EXTr_SET BCM53324_A0_BKPMETERINGCONFIG_EXTr_SET
#define BKPMETERINGCONFIG_EXTr_GET BCM53324_A0_BKPMETERINGCONFIG_EXTr_GET
#define BKPMETERINGCONFIG_EXTr_RESUME_THDf_GET BCM53324_A0_BKPMETERINGCONFIG_EXTr_RESUME_THDf_GET
#define BKPMETERINGCONFIG_EXTr_RESUME_THDf_SET BCM53324_A0_BKPMETERINGCONFIG_EXTr_RESUME_THDf_SET
#define BKPMETERINGCONFIG_EXTr_DISCARD_THDf_GET BCM53324_A0_BKPMETERINGCONFIG_EXTr_DISCARD_THDf_GET
#define BKPMETERINGCONFIG_EXTr_DISCARD_THDf_SET BCM53324_A0_BKPMETERINGCONFIG_EXTr_DISCARD_THDf_SET
#define BKPMETERINGCONFIG_EXTr_BKPDISCARD_ENf_GET BCM53324_A0_BKPMETERINGCONFIG_EXTr_BKPDISCARD_ENf_GET
#define BKPMETERINGCONFIG_EXTr_BKPDISCARD_ENf_SET BCM53324_A0_BKPMETERINGCONFIG_EXTr_BKPDISCARD_ENf_SET
#define BKPMETERINGCONFIG_EXTr_BKPDISCARD_ACCT_ENf_GET BCM53324_A0_BKPMETERINGCONFIG_EXTr_BKPDISCARD_ACCT_ENf_GET
#define BKPMETERINGCONFIG_EXTr_BKPDISCARD_ACCT_ENf_SET BCM53324_A0_BKPMETERINGCONFIG_EXTr_BKPDISCARD_ACCT_ENf_SET
#define BKPMETERINGCONFIG_EXTr_IFG_ACCT_SELf_GET BCM53324_A0_BKPMETERINGCONFIG_EXTr_IFG_ACCT_SELf_GET
#define BKPMETERINGCONFIG_EXTr_IFG_ACCT_SELf_SET BCM53324_A0_BKPMETERINGCONFIG_EXTr_IFG_ACCT_SELf_SET
#define READ_BKPMETERINGCONFIG_EXTr BCM53324_A0_READ_BKPMETERINGCONFIG_EXTr
#define WRITE_BKPMETERINGCONFIG_EXTr BCM53324_A0_WRITE_BKPMETERINGCONFIG_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_BKPMETERINGCONFIG_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  BKPMETERINGDISCSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering discard status
 *
 ******************************************************************************/
#define BCM53324_A0_BKPMETERINGDISCSTATUSr 0x00680004

#define BCM53324_A0_BKPMETERINGDISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGDISCSTATUS.
 *
 */
typedef union BCM53324_A0_BKPMETERINGDISCSTATUSr_s {
	uint32_t v[1];
	uint32_t bkpmeteringdiscstatus[1];
	uint32_t _bkpmeteringdiscstatus;
} BCM53324_A0_BKPMETERINGDISCSTATUSr_t;

#define BCM53324_A0_BKPMETERINGDISCSTATUSr_CLR(r) (r).bkpmeteringdiscstatus[0] = 0
#define BCM53324_A0_BKPMETERINGDISCSTATUSr_SET(r,d) (r).bkpmeteringdiscstatus[0] = d
#define BCM53324_A0_BKPMETERINGDISCSTATUSr_GET(r) (r).bkpmeteringdiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET(r) (((r).bkpmeteringdiscstatus[0]) & 0x1ffffff)
#define BCM53324_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringdiscstatus[0]=(((r).bkpmeteringdiscstatus[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access BKPMETERINGDISCSTATUS.
 *
 */
#define BCM53324_A0_READ_BKPMETERINGDISCSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_BKPMETERINGDISCSTATUSr,(r._bkpmeteringdiscstatus))
#define BCM53324_A0_WRITE_BKPMETERINGDISCSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_BKPMETERINGDISCSTATUSr,&(r._bkpmeteringdiscstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGDISCSTATUSr BCM53324_A0_BKPMETERINGDISCSTATUSr
#define BKPMETERINGDISCSTATUSr_SIZE BCM53324_A0_BKPMETERINGDISCSTATUSr_SIZE
typedef BCM53324_A0_BKPMETERINGDISCSTATUSr_t BKPMETERINGDISCSTATUSr_t;
#define BKPMETERINGDISCSTATUSr_CLR BCM53324_A0_BKPMETERINGDISCSTATUSr_CLR
#define BKPMETERINGDISCSTATUSr_SET BCM53324_A0_BKPMETERINGDISCSTATUSr_SET
#define BKPMETERINGDISCSTATUSr_GET BCM53324_A0_BKPMETERINGDISCSTATUSr_GET
#define BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET BCM53324_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET
#define BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET BCM53324_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET
#define READ_BKPMETERINGDISCSTATUSr BCM53324_A0_READ_BKPMETERINGDISCSTATUSr
#define WRITE_BKPMETERINGDISCSTATUSr BCM53324_A0_WRITE_BKPMETERINGDISCSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_BKPMETERINGDISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  BKPMETERINGSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering status
 *
 ******************************************************************************/
#define BCM53324_A0_BKPMETERINGSTATUSr 0x00680002

#define BCM53324_A0_BKPMETERINGSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGSTATUS.
 *
 */
typedef union BCM53324_A0_BKPMETERINGSTATUSr_s {
	uint32_t v[1];
	uint32_t bkpmeteringstatus[1];
	uint32_t _bkpmeteringstatus;
} BCM53324_A0_BKPMETERINGSTATUSr_t;

#define BCM53324_A0_BKPMETERINGSTATUSr_CLR(r) (r).bkpmeteringstatus[0] = 0
#define BCM53324_A0_BKPMETERINGSTATUSr_SET(r,d) (r).bkpmeteringstatus[0] = d
#define BCM53324_A0_BKPMETERINGSTATUSr_GET(r) (r).bkpmeteringstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_GET(r) (((r).bkpmeteringstatus[0]) & 0x1ffffff)
#define BCM53324_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringstatus[0]=(((r).bkpmeteringstatus[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access BKPMETERINGSTATUS.
 *
 */
#define BCM53324_A0_READ_BKPMETERINGSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_BKPMETERINGSTATUSr,(r._bkpmeteringstatus))
#define BCM53324_A0_WRITE_BKPMETERINGSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_BKPMETERINGSTATUSr,&(r._bkpmeteringstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGSTATUSr BCM53324_A0_BKPMETERINGSTATUSr
#define BKPMETERINGSTATUSr_SIZE BCM53324_A0_BKPMETERINGSTATUSr_SIZE
typedef BCM53324_A0_BKPMETERINGSTATUSr_t BKPMETERINGSTATUSr_t;
#define BKPMETERINGSTATUSr_CLR BCM53324_A0_BKPMETERINGSTATUSr_CLR
#define BKPMETERINGSTATUSr_SET BCM53324_A0_BKPMETERINGSTATUSr_SET
#define BKPMETERINGSTATUSr_GET BCM53324_A0_BKPMETERINGSTATUSr_GET
#define BKPMETERINGSTATUSr_PORT_BITMAPf_GET BCM53324_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_GET
#define BKPMETERINGSTATUSr_PORT_BITMAPf_SET BCM53324_A0_BKPMETERINGSTATUSr_PORT_BITMAPf_SET
#define READ_BKPMETERINGSTATUSr BCM53324_A0_READ_BKPMETERINGSTATUSr
#define WRITE_BKPMETERINGSTATUSr BCM53324_A0_WRITE_BKPMETERINGSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_BKPMETERINGSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  BKP_DISC_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Back Pressure Discard Register - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Back Pressure Discard Bitmap 
 *
 ******************************************************************************/
#define BCM53324_A0_BKP_DISC_BMAPr 0x0f780112

#define BCM53324_A0_BKP_DISC_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program BKP_DISC_BMAP.
 *
 */
typedef union BCM53324_A0_BKP_DISC_BMAPr_s {
	uint32_t v[1];
	uint32_t bkp_disc_bmap[1];
	uint32_t _bkp_disc_bmap;
} BCM53324_A0_BKP_DISC_BMAPr_t;

#define BCM53324_A0_BKP_DISC_BMAPr_CLR(r) (r).bkp_disc_bmap[0] = 0
#define BCM53324_A0_BKP_DISC_BMAPr_SET(r,d) (r).bkp_disc_bmap[0] = d
#define BCM53324_A0_BKP_DISC_BMAPr_GET(r) (r).bkp_disc_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_BKP_DISC_BMAPr_PORT_BITMAPf_GET(r) (((r).bkp_disc_bmap[0]) & 0x1ffffff)
#define BCM53324_A0_BKP_DISC_BMAPr_PORT_BITMAPf_SET(r,f) (r).bkp_disc_bmap[0]=(((r).bkp_disc_bmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access BKP_DISC_BMAP.
 *
 */
#define BCM53324_A0_READ_BKP_DISC_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_BKP_DISC_BMAPr,(r._bkp_disc_bmap))
#define BCM53324_A0_WRITE_BKP_DISC_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_BKP_DISC_BMAPr,&(r._bkp_disc_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKP_DISC_BMAPr BCM53324_A0_BKP_DISC_BMAPr
#define BKP_DISC_BMAPr_SIZE BCM53324_A0_BKP_DISC_BMAPr_SIZE
typedef BCM53324_A0_BKP_DISC_BMAPr_t BKP_DISC_BMAPr_t;
#define BKP_DISC_BMAPr_CLR BCM53324_A0_BKP_DISC_BMAPr_CLR
#define BKP_DISC_BMAPr_SET BCM53324_A0_BKP_DISC_BMAPr_SET
#define BKP_DISC_BMAPr_GET BCM53324_A0_BKP_DISC_BMAPr_GET
#define BKP_DISC_BMAPr_PORT_BITMAPf_GET BCM53324_A0_BKP_DISC_BMAPr_PORT_BITMAPf_GET
#define BKP_DISC_BMAPr_PORT_BITMAPf_SET BCM53324_A0_BKP_DISC_BMAPr_PORT_BITMAPf_SET
#define READ_BKP_DISC_BMAPr BCM53324_A0_READ_BKP_DISC_BMAPr
#define WRITE_BKP_DISC_BMAPr BCM53324_A0_WRITE_BKP_DISC_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_BKP_DISC_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CBPCELLCRCERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Cell Data Memory cell CRC error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM53324_A0_CBPCELLCRCERRPTRr 0x00680029

#define BCM53324_A0_CBPCELLCRCERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLCRCERRPTR.
 *
 */
typedef union BCM53324_A0_CBPCELLCRCERRPTRr_s {
	uint32_t v[1];
	uint32_t cbpcellcrcerrptr[1];
	uint32_t _cbpcellcrcerrptr;
} BCM53324_A0_CBPCELLCRCERRPTRr_t;

#define BCM53324_A0_CBPCELLCRCERRPTRr_CLR(r) (r).cbpcellcrcerrptr[0] = 0
#define BCM53324_A0_CBPCELLCRCERRPTRr_SET(r,d) (r).cbpcellcrcerrptr[0] = d
#define BCM53324_A0_CBPCELLCRCERRPTRr_GET(r) (r).cbpcellcrcerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_GET(r) (((r).cbpcellcrcerrptr[0]) & 0xfff)
#define BCM53324_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbpcellcrcerrptr[0]=(((r).cbpcellcrcerrptr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access CBPCELLCRCERRPTR.
 *
 */
#define BCM53324_A0_READ_CBPCELLCRCERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CBPCELLCRCERRPTRr,(r._cbpcellcrcerrptr))
#define BCM53324_A0_WRITE_CBPCELLCRCERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CBPCELLCRCERRPTRr,&(r._cbpcellcrcerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLCRCERRPTRr BCM53324_A0_CBPCELLCRCERRPTRr
#define CBPCELLCRCERRPTRr_SIZE BCM53324_A0_CBPCELLCRCERRPTRr_SIZE
typedef BCM53324_A0_CBPCELLCRCERRPTRr_t CBPCELLCRCERRPTRr_t;
#define CBPCELLCRCERRPTRr_CLR BCM53324_A0_CBPCELLCRCERRPTRr_CLR
#define CBPCELLCRCERRPTRr_SET BCM53324_A0_CBPCELLCRCERRPTRr_SET
#define CBPCELLCRCERRPTRr_GET BCM53324_A0_CBPCELLCRCERRPTRr_GET
#define CBPCELLCRCERRPTRr_ERRORPOINTERf_GET BCM53324_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_GET
#define CBPCELLCRCERRPTRr_ERRORPOINTERf_SET BCM53324_A0_CBPCELLCRCERRPTRr_ERRORPOINTERf_SET
#define READ_CBPCELLCRCERRPTRr BCM53324_A0_READ_CBPCELLCRCERRPTRr
#define WRITE_CBPCELLCRCERRPTRr BCM53324_A0_WRITE_CBPCELLCRCERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CBPCELLCRCERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CBPCELLHDRMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm 
 *     WW               Weak Write 
 *
 ******************************************************************************/
#define BCM53324_A0_CBPCELLHDRMEMDEBUGr 0x0068003e

#define BCM53324_A0_CBPCELLHDRMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLHDRMEMDEBUG.
 *
 */
typedef union BCM53324_A0_CBPCELLHDRMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbpcellhdrmemdebug[1];
	uint32_t _cbpcellhdrmemdebug;
} BCM53324_A0_CBPCELLHDRMEMDEBUGr_t;

#define BCM53324_A0_CBPCELLHDRMEMDEBUGr_CLR(r) (r).cbpcellhdrmemdebug[0] = 0
#define BCM53324_A0_CBPCELLHDRMEMDEBUGr_SET(r,d) (r).cbpcellhdrmemdebug[0] = d
#define BCM53324_A0_CBPCELLHDRMEMDEBUGr_GET(r) (r).cbpcellhdrmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CBPCELLHDRMEMDEBUGr_TMf_GET(r) (((r).cbpcellhdrmemdebug[0]) & 0xff)
#define BCM53324_A0_CBPCELLHDRMEMDEBUGr_TMf_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CBPCELLHDRMEMDEBUGr_WWf_GET(r) ((((r).cbpcellhdrmemdebug[0]) >> 8) & 0x1)
#define BCM53324_A0_CBPCELLHDRMEMDEBUGr_WWf_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CBPCELLHDRMEMDEBUG.
 *
 */
#define BCM53324_A0_READ_CBPCELLHDRMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CBPCELLHDRMEMDEBUGr,(r._cbpcellhdrmemdebug))
#define BCM53324_A0_WRITE_CBPCELLHDRMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CBPCELLHDRMEMDEBUGr,&(r._cbpcellhdrmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLHDRMEMDEBUGr BCM53324_A0_CBPCELLHDRMEMDEBUGr
#define CBPCELLHDRMEMDEBUGr_SIZE BCM53324_A0_CBPCELLHDRMEMDEBUGr_SIZE
typedef BCM53324_A0_CBPCELLHDRMEMDEBUGr_t CBPCELLHDRMEMDEBUGr_t;
#define CBPCELLHDRMEMDEBUGr_CLR BCM53324_A0_CBPCELLHDRMEMDEBUGr_CLR
#define CBPCELLHDRMEMDEBUGr_SET BCM53324_A0_CBPCELLHDRMEMDEBUGr_SET
#define CBPCELLHDRMEMDEBUGr_GET BCM53324_A0_CBPCELLHDRMEMDEBUGr_GET
#define CBPCELLHDRMEMDEBUGr_TMf_GET BCM53324_A0_CBPCELLHDRMEMDEBUGr_TMf_GET
#define CBPCELLHDRMEMDEBUGr_TMf_SET BCM53324_A0_CBPCELLHDRMEMDEBUGr_TMf_SET
#define CBPCELLHDRMEMDEBUGr_WWf_GET BCM53324_A0_CBPCELLHDRMEMDEBUGr_WWf_GET
#define CBPCELLHDRMEMDEBUGr_WWf_SET BCM53324_A0_CBPCELLHDRMEMDEBUGr_WWf_SET
#define READ_CBPCELLHDRMEMDEBUGr BCM53324_A0_READ_CBPCELLHDRMEMDEBUGr
#define WRITE_CBPCELLHDRMEMDEBUGr BCM53324_A0_WRITE_CBPCELLHDRMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CBPCELLHDRMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CBPCELLHDRPARITYERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Cell Header Memory parity error pointer is the errored cell header pointer.
 *     ERROREDNEXTCELLPOINTER CBP Cell Header Memory parity error next cell pointer is the abandoned next cellpointer.
 *
 ******************************************************************************/
#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr 0x0068002a

#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLHDRPARITYERRPTR.
 *
 */
typedef union BCM53324_A0_CBPCELLHDRPARITYERRPTRr_s {
	uint32_t v[1];
	uint32_t cbpcellhdrparityerrptr[1];
	uint32_t _cbpcellhdrparityerrptr;
} BCM53324_A0_CBPCELLHDRPARITYERRPTRr_t;

#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr_CLR(r) (r).cbpcellhdrparityerrptr[0] = 0
#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr_SET(r,d) (r).cbpcellhdrparityerrptr[0] = d
#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr_GET(r) (r).cbpcellhdrparityerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET(r) (((r).cbpcellhdrparityerrptr[0]) & 0xfff)
#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbpcellhdrparityerrptr[0]=(((r).cbpcellhdrparityerrptr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET(r) ((((r).cbpcellhdrparityerrptr[0]) >> 12) & 0xfff)
#define BCM53324_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET(r,f) (r).cbpcellhdrparityerrptr[0]=(((r).cbpcellhdrparityerrptr[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access CBPCELLHDRPARITYERRPTR.
 *
 */
#define BCM53324_A0_READ_CBPCELLHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CBPCELLHDRPARITYERRPTRr,(r._cbpcellhdrparityerrptr))
#define BCM53324_A0_WRITE_CBPCELLHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CBPCELLHDRPARITYERRPTRr,&(r._cbpcellhdrparityerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLHDRPARITYERRPTRr BCM53324_A0_CBPCELLHDRPARITYERRPTRr
#define CBPCELLHDRPARITYERRPTRr_SIZE BCM53324_A0_CBPCELLHDRPARITYERRPTRr_SIZE
typedef BCM53324_A0_CBPCELLHDRPARITYERRPTRr_t CBPCELLHDRPARITYERRPTRr_t;
#define CBPCELLHDRPARITYERRPTRr_CLR BCM53324_A0_CBPCELLHDRPARITYERRPTRr_CLR
#define CBPCELLHDRPARITYERRPTRr_SET BCM53324_A0_CBPCELLHDRPARITYERRPTRr_SET
#define CBPCELLHDRPARITYERRPTRr_GET BCM53324_A0_CBPCELLHDRPARITYERRPTRr_GET
#define CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET BCM53324_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_GET
#define CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET BCM53324_A0_CBPCELLHDRPARITYERRPTRr_ERRORPOINTERf_SET
#define CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET BCM53324_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_GET
#define CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET BCM53324_A0_CBPCELLHDRPARITYERRPTRr_ERROREDNEXTCELLPOINTERf_SET
#define READ_CBPCELLHDRPARITYERRPTRr BCM53324_A0_READ_CBPCELLHDRPARITYERRPTRr
#define WRITE_CBPCELLHDRPARITYERRPTRr BCM53324_A0_WRITE_CBPCELLHDRPARITYERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CBPCELLHDRPARITYERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CBPDATAMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               sam registers.
 *     WW               Weak Write 
 *
 ******************************************************************************/
#define BCM53324_A0_CBPDATAMEMDEBUGr 0x00680034

#define BCM53324_A0_CBPDATAMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEMDEBUG.
 *
 */
typedef union BCM53324_A0_CBPDATAMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamemdebug[1];
	uint32_t _cbpdatamemdebug;
} BCM53324_A0_CBPDATAMEMDEBUGr_t;

#define BCM53324_A0_CBPDATAMEMDEBUGr_CLR(r) (r).cbpdatamemdebug[0] = 0
#define BCM53324_A0_CBPDATAMEMDEBUGr_SET(r,d) (r).cbpdatamemdebug[0] = d
#define BCM53324_A0_CBPDATAMEMDEBUGr_GET(r) (r).cbpdatamemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CBPDATAMEMDEBUGr_TMf_GET(r) (((r).cbpdatamemdebug[0]) & 0xff)
#define BCM53324_A0_CBPDATAMEMDEBUGr_TMf_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CBPDATAMEMDEBUGr_WWf_GET(r) ((((r).cbpdatamemdebug[0]) >> 8) & 0x1)
#define BCM53324_A0_CBPDATAMEMDEBUGr_WWf_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CBPDATAMEMDEBUG.
 *
 */
#define BCM53324_A0_READ_CBPDATAMEMDEBUGr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_CBPDATAMEMDEBUGr+(i),(r._cbpdatamemdebug))
#define BCM53324_A0_WRITE_CBPDATAMEMDEBUGr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_CBPDATAMEMDEBUGr+(i),&(r._cbpdatamemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEMDEBUGr BCM53324_A0_CBPDATAMEMDEBUGr
#define CBPDATAMEMDEBUGr_SIZE BCM53324_A0_CBPDATAMEMDEBUGr_SIZE
typedef BCM53324_A0_CBPDATAMEMDEBUGr_t CBPDATAMEMDEBUGr_t;
#define CBPDATAMEMDEBUGr_CLR BCM53324_A0_CBPDATAMEMDEBUGr_CLR
#define CBPDATAMEMDEBUGr_SET BCM53324_A0_CBPDATAMEMDEBUGr_SET
#define CBPDATAMEMDEBUGr_GET BCM53324_A0_CBPDATAMEMDEBUGr_GET
#define CBPDATAMEMDEBUGr_TMf_GET BCM53324_A0_CBPDATAMEMDEBUGr_TMf_GET
#define CBPDATAMEMDEBUGr_TMf_SET BCM53324_A0_CBPDATAMEMDEBUGr_TMf_SET
#define CBPDATAMEMDEBUGr_WWf_GET BCM53324_A0_CBPDATAMEMDEBUGr_WWf_GET
#define CBPDATAMEMDEBUGr_WWf_SET BCM53324_A0_CBPDATAMEMDEBUGr_WWf_SET
#define READ_CBPDATAMEMDEBUGr BCM53324_A0_READ_CBPDATAMEMDEBUGr
#define WRITE_CBPDATAMEMDEBUGr BCM53324_A0_WRITE_CBPDATAMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CBPDATAMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CBPPKTHDRMEM0DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               sam registers.
 *     WW               Weak Write 
 *
 ******************************************************************************/
#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr 0x0068003c

#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRMEM0DEBUG.
 *
 */
typedef union BCM53324_A0_CBPPKTHDRMEM0DEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdrmem0debug[1];
	uint32_t _cbppkthdrmem0debug;
} BCM53324_A0_CBPPKTHDRMEM0DEBUGr_t;

#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr_CLR(r) (r).cbppkthdrmem0debug[0] = 0
#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr_SET(r,d) (r).cbppkthdrmem0debug[0] = d
#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr_GET(r) (r).cbppkthdrmem0debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr_TMf_GET(r) (((r).cbppkthdrmem0debug[0]) & 0xff)
#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr_TMf_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr_WWf_GET(r) ((((r).cbppkthdrmem0debug[0]) >> 8) & 0x1)
#define BCM53324_A0_CBPPKTHDRMEM0DEBUGr_WWf_SET(r,f) (r).cbppkthdrmem0debug[0]=(((r).cbppkthdrmem0debug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CBPPKTHDRMEM0DEBUG.
 *
 */
#define BCM53324_A0_READ_CBPPKTHDRMEM0DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CBPPKTHDRMEM0DEBUGr,(r._cbppkthdrmem0debug))
#define BCM53324_A0_WRITE_CBPPKTHDRMEM0DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CBPPKTHDRMEM0DEBUGr,&(r._cbppkthdrmem0debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRMEM0DEBUGr BCM53324_A0_CBPPKTHDRMEM0DEBUGr
#define CBPPKTHDRMEM0DEBUGr_SIZE BCM53324_A0_CBPPKTHDRMEM0DEBUGr_SIZE
typedef BCM53324_A0_CBPPKTHDRMEM0DEBUGr_t CBPPKTHDRMEM0DEBUGr_t;
#define CBPPKTHDRMEM0DEBUGr_CLR BCM53324_A0_CBPPKTHDRMEM0DEBUGr_CLR
#define CBPPKTHDRMEM0DEBUGr_SET BCM53324_A0_CBPPKTHDRMEM0DEBUGr_SET
#define CBPPKTHDRMEM0DEBUGr_GET BCM53324_A0_CBPPKTHDRMEM0DEBUGr_GET
#define CBPPKTHDRMEM0DEBUGr_TMf_GET BCM53324_A0_CBPPKTHDRMEM0DEBUGr_TMf_GET
#define CBPPKTHDRMEM0DEBUGr_TMf_SET BCM53324_A0_CBPPKTHDRMEM0DEBUGr_TMf_SET
#define CBPPKTHDRMEM0DEBUGr_WWf_GET BCM53324_A0_CBPPKTHDRMEM0DEBUGr_WWf_GET
#define CBPPKTHDRMEM0DEBUGr_WWf_SET BCM53324_A0_CBPPKTHDRMEM0DEBUGr_WWf_SET
#define READ_CBPPKTHDRMEM0DEBUGr BCM53324_A0_READ_CBPPKTHDRMEM0DEBUGr
#define WRITE_CBPPKTHDRMEM0DEBUGr BCM53324_A0_WRITE_CBPPKTHDRMEM0DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CBPPKTHDRMEM0DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CBPPKTHDRMEM1DEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               sam registers.
 *     WW               Weak Write 
 *
 ******************************************************************************/
#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr 0x0068003d

#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRMEM1DEBUG.
 *
 */
typedef union BCM53324_A0_CBPPKTHDRMEM1DEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdrmem1debug[1];
	uint32_t _cbppkthdrmem1debug;
} BCM53324_A0_CBPPKTHDRMEM1DEBUGr_t;

#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr_CLR(r) (r).cbppkthdrmem1debug[0] = 0
#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr_SET(r,d) (r).cbppkthdrmem1debug[0] = d
#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr_GET(r) (r).cbppkthdrmem1debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr_TMf_GET(r) (((r).cbppkthdrmem1debug[0]) & 0xff)
#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr_TMf_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr_WWf_GET(r) ((((r).cbppkthdrmem1debug[0]) >> 8) & 0x1)
#define BCM53324_A0_CBPPKTHDRMEM1DEBUGr_WWf_SET(r,f) (r).cbppkthdrmem1debug[0]=(((r).cbppkthdrmem1debug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CBPPKTHDRMEM1DEBUG.
 *
 */
#define BCM53324_A0_READ_CBPPKTHDRMEM1DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CBPPKTHDRMEM1DEBUGr,(r._cbppkthdrmem1debug))
#define BCM53324_A0_WRITE_CBPPKTHDRMEM1DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CBPPKTHDRMEM1DEBUGr,&(r._cbppkthdrmem1debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRMEM1DEBUGr BCM53324_A0_CBPPKTHDRMEM1DEBUGr
#define CBPPKTHDRMEM1DEBUGr_SIZE BCM53324_A0_CBPPKTHDRMEM1DEBUGr_SIZE
typedef BCM53324_A0_CBPPKTHDRMEM1DEBUGr_t CBPPKTHDRMEM1DEBUGr_t;
#define CBPPKTHDRMEM1DEBUGr_CLR BCM53324_A0_CBPPKTHDRMEM1DEBUGr_CLR
#define CBPPKTHDRMEM1DEBUGr_SET BCM53324_A0_CBPPKTHDRMEM1DEBUGr_SET
#define CBPPKTHDRMEM1DEBUGr_GET BCM53324_A0_CBPPKTHDRMEM1DEBUGr_GET
#define CBPPKTHDRMEM1DEBUGr_TMf_GET BCM53324_A0_CBPPKTHDRMEM1DEBUGr_TMf_GET
#define CBPPKTHDRMEM1DEBUGr_TMf_SET BCM53324_A0_CBPPKTHDRMEM1DEBUGr_TMf_SET
#define CBPPKTHDRMEM1DEBUGr_WWf_GET BCM53324_A0_CBPPKTHDRMEM1DEBUGr_WWf_GET
#define CBPPKTHDRMEM1DEBUGr_WWf_SET BCM53324_A0_CBPPKTHDRMEM1DEBUGr_WWf_SET
#define READ_CBPPKTHDRMEM1DEBUGr BCM53324_A0_READ_CBPPKTHDRMEM1DEBUGr
#define WRITE_CBPPKTHDRMEM1DEBUGr BCM53324_A0_WRITE_CBPPKTHDRMEM1DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CBPPKTHDRMEM1DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CBPPKTHDRPARITYERRPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ERRORPOINTER     CBP Packet Header Memory parity error pointer is the errored cell header pointer.
 *
 ******************************************************************************/
#define BCM53324_A0_CBPPKTHDRPARITYERRPTRr 0x0068002b

#define BCM53324_A0_CBPPKTHDRPARITYERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRPARITYERRPTR.
 *
 */
typedef union BCM53324_A0_CBPPKTHDRPARITYERRPTRr_s {
	uint32_t v[1];
	uint32_t cbppkthdrparityerrptr[1];
	uint32_t _cbppkthdrparityerrptr;
} BCM53324_A0_CBPPKTHDRPARITYERRPTRr_t;

#define BCM53324_A0_CBPPKTHDRPARITYERRPTRr_CLR(r) (r).cbppkthdrparityerrptr[0] = 0
#define BCM53324_A0_CBPPKTHDRPARITYERRPTRr_SET(r,d) (r).cbppkthdrparityerrptr[0] = d
#define BCM53324_A0_CBPPKTHDRPARITYERRPTRr_GET(r) (r).cbppkthdrparityerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET(r) (((r).cbppkthdrparityerrptr[0]) & 0xfff)
#define BCM53324_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET(r,f) (r).cbppkthdrparityerrptr[0]=(((r).cbppkthdrparityerrptr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access CBPPKTHDRPARITYERRPTR.
 *
 */
#define BCM53324_A0_READ_CBPPKTHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CBPPKTHDRPARITYERRPTRr,(r._cbppkthdrparityerrptr))
#define BCM53324_A0_WRITE_CBPPKTHDRPARITYERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CBPPKTHDRPARITYERRPTRr,&(r._cbppkthdrparityerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRPARITYERRPTRr BCM53324_A0_CBPPKTHDRPARITYERRPTRr
#define CBPPKTHDRPARITYERRPTRr_SIZE BCM53324_A0_CBPPKTHDRPARITYERRPTRr_SIZE
typedef BCM53324_A0_CBPPKTHDRPARITYERRPTRr_t CBPPKTHDRPARITYERRPTRr_t;
#define CBPPKTHDRPARITYERRPTRr_CLR BCM53324_A0_CBPPKTHDRPARITYERRPTRr_CLR
#define CBPPKTHDRPARITYERRPTRr_SET BCM53324_A0_CBPPKTHDRPARITYERRPTRr_SET
#define CBPPKTHDRPARITYERRPTRr_GET BCM53324_A0_CBPPKTHDRPARITYERRPTRr_GET
#define CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET BCM53324_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_GET
#define CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET BCM53324_A0_CBPPKTHDRPARITYERRPTRr_ERRORPOINTERf_SET
#define READ_CBPPKTHDRPARITYERRPTRr BCM53324_A0_READ_CBPPKTHDRPARITYERRPTRr
#define WRITE_CBPPKTHDRPARITYERRPTRr BCM53324_A0_WRITE_CBPPKTHDRPARITYERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CBPPKTHDRPARITYERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CCPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm 
 *     WW               Weak Write 
 *
 ******************************************************************************/
#define BCM53324_A0_CCPMEMDEBUGr 0x00680030

#define BCM53324_A0_CCPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CCPMEMDEBUG.
 *
 */
typedef union BCM53324_A0_CCPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t ccpmemdebug[1];
	uint32_t _ccpmemdebug;
} BCM53324_A0_CCPMEMDEBUGr_t;

#define BCM53324_A0_CCPMEMDEBUGr_CLR(r) (r).ccpmemdebug[0] = 0
#define BCM53324_A0_CCPMEMDEBUGr_SET(r,d) (r).ccpmemdebug[0] = d
#define BCM53324_A0_CCPMEMDEBUGr_GET(r) (r).ccpmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CCPMEMDEBUGr_TMf_GET(r) (((r).ccpmemdebug[0]) & 0xff)
#define BCM53324_A0_CCPMEMDEBUGr_TMf_SET(r,f) (r).ccpmemdebug[0]=(((r).ccpmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CCPMEMDEBUGr_WWf_GET(r) ((((r).ccpmemdebug[0]) >> 8) & 0x1)
#define BCM53324_A0_CCPMEMDEBUGr_WWf_SET(r,f) (r).ccpmemdebug[0]=(((r).ccpmemdebug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CCPMEMDEBUG.
 *
 */
#define BCM53324_A0_READ_CCPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CCPMEMDEBUGr,(r._ccpmemdebug))
#define BCM53324_A0_WRITE_CCPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CCPMEMDEBUGr,&(r._ccpmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CCPMEMDEBUGr BCM53324_A0_CCPMEMDEBUGr
#define CCPMEMDEBUGr_SIZE BCM53324_A0_CCPMEMDEBUGr_SIZE
typedef BCM53324_A0_CCPMEMDEBUGr_t CCPMEMDEBUGr_t;
#define CCPMEMDEBUGr_CLR BCM53324_A0_CCPMEMDEBUGr_CLR
#define CCPMEMDEBUGr_SET BCM53324_A0_CCPMEMDEBUGr_SET
#define CCPMEMDEBUGr_GET BCM53324_A0_CCPMEMDEBUGr_GET
#define CCPMEMDEBUGr_TMf_GET BCM53324_A0_CCPMEMDEBUGr_TMf_GET
#define CCPMEMDEBUGr_TMf_SET BCM53324_A0_CCPMEMDEBUGr_TMf_SET
#define CCPMEMDEBUGr_WWf_GET BCM53324_A0_CCPMEMDEBUGr_WWf_GET
#define CCPMEMDEBUGr_WWf_SET BCM53324_A0_CCPMEMDEBUGr_WWf_SET
#define READ_CCPMEMDEBUGr BCM53324_A0_READ_CCPMEMDEBUGr
#define WRITE_CCPMEMDEBUGr BCM53324_A0_WRITE_CCPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CCPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CCPPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CCPPARITYERRORPTR MMU CCP memory parity error pointer indicats.this register only keeps the most current ccp parity error pointer.
 *
 ******************************************************************************/
#define BCM53324_A0_CCPPARITYERRORPTRr 0x0068002f

#define BCM53324_A0_CCPPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program CCPPARITYERRORPTR.
 *
 */
typedef union BCM53324_A0_CCPPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t ccpparityerrorptr[1];
	uint32_t _ccpparityerrorptr;
} BCM53324_A0_CCPPARITYERRORPTRr_t;

#define BCM53324_A0_CCPPARITYERRORPTRr_CLR(r) (r).ccpparityerrorptr[0] = 0
#define BCM53324_A0_CCPPARITYERRORPTRr_SET(r,d) (r).ccpparityerrorptr[0] = d
#define BCM53324_A0_CCPPARITYERRORPTRr_GET(r) (r).ccpparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET(r) (((r).ccpparityerrorptr[0]) & 0xfff)
#define BCM53324_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET(r,f) (r).ccpparityerrorptr[0]=(((r).ccpparityerrorptr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access CCPPARITYERRORPTR.
 *
 */
#define BCM53324_A0_READ_CCPPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CCPPARITYERRORPTRr,(r._ccpparityerrorptr))
#define BCM53324_A0_WRITE_CCPPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CCPPARITYERRORPTRr,&(r._ccpparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CCPPARITYERRORPTRr BCM53324_A0_CCPPARITYERRORPTRr
#define CCPPARITYERRORPTRr_SIZE BCM53324_A0_CCPPARITYERRORPTRr_SIZE
typedef BCM53324_A0_CCPPARITYERRORPTRr_t CCPPARITYERRORPTRr_t;
#define CCPPARITYERRORPTRr_CLR BCM53324_A0_CCPPARITYERRORPTRr_CLR
#define CCPPARITYERRORPTRr_SET BCM53324_A0_CCPPARITYERRORPTRr_SET
#define CCPPARITYERRORPTRr_GET BCM53324_A0_CCPPARITYERRORPTRr_GET
#define CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET BCM53324_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET
#define CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET BCM53324_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET
#define READ_CCPPARITYERRORPTRr BCM53324_A0_READ_CCPPARITYERRORPTRr
#define WRITE_CCPPARITYERRORPTRr BCM53324_A0_WRITE_CCPPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CCPPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CFAPCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls the CFAP behavior
 * SIZE:     32
 * FIELDS:
 *     CFAPPOOLSIZE     Maximum number of cell pointers of CBP memory. Number of cells are supported 8KDo NOT set this above the RESET VALUE. It will cause unexpected behavior of MMU. 
 *     CFAPINIT         Re-Initialize CFAP Memory.When write 1 to Set this bit mmu will re-initialize CFAP pointer pre-fetchprocess after user had rearranged CFAP memory. this bit is also used for XQ prefetching also. 
 *
 ******************************************************************************/
#define BCM53324_A0_CFAPCONFIGr 0x0068000d

#define BCM53324_A0_CFAPCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPCONFIG.
 *
 */
typedef union BCM53324_A0_CFAPCONFIGr_s {
	uint32_t v[1];
	uint32_t cfapconfig[1];
	uint32_t _cfapconfig;
} BCM53324_A0_CFAPCONFIGr_t;

#define BCM53324_A0_CFAPCONFIGr_CLR(r) (r).cfapconfig[0] = 0
#define BCM53324_A0_CFAPCONFIGr_SET(r,d) (r).cfapconfig[0] = d
#define BCM53324_A0_CFAPCONFIGr_GET(r) (r).cfapconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CFAPCONFIGr_CFAPPOOLSIZEf_GET(r) (((r).cfapconfig[0]) & 0xfff)
#define BCM53324_A0_CFAPCONFIGr_CFAPPOOLSIZEf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_CFAPCONFIGr_CFAPINITf_GET(r) ((((r).cfapconfig[0]) >> 12) & 0x1)
#define BCM53324_A0_CFAPCONFIGr_CFAPINITf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access CFAPCONFIG.
 *
 */
#define BCM53324_A0_READ_CFAPCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CFAPCONFIGr,(r._cfapconfig))
#define BCM53324_A0_WRITE_CFAPCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CFAPCONFIGr,&(r._cfapconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPCONFIGr BCM53324_A0_CFAPCONFIGr
#define CFAPCONFIGr_SIZE BCM53324_A0_CFAPCONFIGr_SIZE
typedef BCM53324_A0_CFAPCONFIGr_t CFAPCONFIGr_t;
#define CFAPCONFIGr_CLR BCM53324_A0_CFAPCONFIGr_CLR
#define CFAPCONFIGr_SET BCM53324_A0_CFAPCONFIGr_SET
#define CFAPCONFIGr_GET BCM53324_A0_CFAPCONFIGr_GET
#define CFAPCONFIGr_CFAPPOOLSIZEf_GET BCM53324_A0_CFAPCONFIGr_CFAPPOOLSIZEf_GET
#define CFAPCONFIGr_CFAPPOOLSIZEf_SET BCM53324_A0_CFAPCONFIGr_CFAPPOOLSIZEf_SET
#define CFAPCONFIGr_CFAPINITf_GET BCM53324_A0_CFAPCONFIGr_CFAPINITf_GET
#define CFAPCONFIGr_CFAPINITf_SET BCM53324_A0_CFAPCONFIGr_CFAPINITf_SET
#define READ_CFAPCONFIGr BCM53324_A0_READ_CFAPCONFIGr
#define WRITE_CFAPCONFIGr BCM53324_A0_WRITE_CFAPCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CFAPCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CFAPFULLTHRESHOLD
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFULLSETPOINT CFAP FULL Set Point define the threshold of entering CFAP FULL condition. CFAP is full when CFAP Read Pointer is above this limit.
 *     CFAPFULLRESETPOINT CFAP FULL Reset Point define the threshold of exiting CFAP FULL condition. CFAP is not full when CFAP Read Pointeris below this limit.
 *
 ******************************************************************************/
#define BCM53324_A0_CFAPFULLTHRESHOLDr 0x0068000f

#define BCM53324_A0_CFAPFULLTHRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program CFAPFULLTHRESHOLD.
 *
 */
typedef union BCM53324_A0_CFAPFULLTHRESHOLDr_s {
	uint32_t v[1];
	uint32_t cfapfullthreshold[1];
	uint32_t _cfapfullthreshold;
} BCM53324_A0_CFAPFULLTHRESHOLDr_t;

#define BCM53324_A0_CFAPFULLTHRESHOLDr_CLR(r) (r).cfapfullthreshold[0] = 0
#define BCM53324_A0_CFAPFULLTHRESHOLDr_SET(r,d) (r).cfapfullthreshold[0] = d
#define BCM53324_A0_CFAPFULLTHRESHOLDr_GET(r) (r).cfapfullthreshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET(r) (((r).cfapfullthreshold[0]) & 0xfff)
#define BCM53324_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET(r) ((((r).cfapfullthreshold[0]) >> 12) & 0xfff)
#define BCM53324_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access CFAPFULLTHRESHOLD.
 *
 */
#define BCM53324_A0_READ_CFAPFULLTHRESHOLDr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CFAPFULLTHRESHOLDr,(r._cfapfullthreshold))
#define BCM53324_A0_WRITE_CFAPFULLTHRESHOLDr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CFAPFULLTHRESHOLDr,&(r._cfapfullthreshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPFULLTHRESHOLDr BCM53324_A0_CFAPFULLTHRESHOLDr
#define CFAPFULLTHRESHOLDr_SIZE BCM53324_A0_CFAPFULLTHRESHOLDr_SIZE
typedef BCM53324_A0_CFAPFULLTHRESHOLDr_t CFAPFULLTHRESHOLDr_t;
#define CFAPFULLTHRESHOLDr_CLR BCM53324_A0_CFAPFULLTHRESHOLDr_CLR
#define CFAPFULLTHRESHOLDr_SET BCM53324_A0_CFAPFULLTHRESHOLDr_SET
#define CFAPFULLTHRESHOLDr_GET BCM53324_A0_CFAPFULLTHRESHOLDr_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET BCM53324_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET BCM53324_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET BCM53324_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET BCM53324_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET
#define READ_CFAPFULLTHRESHOLDr BCM53324_A0_READ_CFAPFULLTHRESHOLDr
#define WRITE_CFAPFULLTHRESHOLDr BCM53324_A0_WRITE_CFAPFULLTHRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CFAPFULLTHRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CFAPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm 
 *     WW               Weak Write 
 *
 ******************************************************************************/
#define BCM53324_A0_CFAPMEMDEBUGr 0x00680031

#define BCM53324_A0_CFAPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPMEMDEBUG.
 *
 */
typedef union BCM53324_A0_CFAPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cfapmemdebug[1];
	uint32_t _cfapmemdebug;
} BCM53324_A0_CFAPMEMDEBUGr_t;

#define BCM53324_A0_CFAPMEMDEBUGr_CLR(r) (r).cfapmemdebug[0] = 0
#define BCM53324_A0_CFAPMEMDEBUGr_SET(r,d) (r).cfapmemdebug[0] = d
#define BCM53324_A0_CFAPMEMDEBUGr_GET(r) (r).cfapmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CFAPMEMDEBUGr_TMf_GET(r) (((r).cfapmemdebug[0]) & 0xff)
#define BCM53324_A0_CFAPMEMDEBUGr_TMf_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CFAPMEMDEBUGr_WWf_GET(r) ((((r).cfapmemdebug[0]) >> 8) & 0x1)
#define BCM53324_A0_CFAPMEMDEBUGr_WWf_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access CFAPMEMDEBUG.
 *
 */
#define BCM53324_A0_READ_CFAPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CFAPMEMDEBUGr,(r._cfapmemdebug))
#define BCM53324_A0_WRITE_CFAPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CFAPMEMDEBUGr,&(r._cfapmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPMEMDEBUGr BCM53324_A0_CFAPMEMDEBUGr
#define CFAPMEMDEBUGr_SIZE BCM53324_A0_CFAPMEMDEBUGr_SIZE
typedef BCM53324_A0_CFAPMEMDEBUGr_t CFAPMEMDEBUGr_t;
#define CFAPMEMDEBUGr_CLR BCM53324_A0_CFAPMEMDEBUGr_CLR
#define CFAPMEMDEBUGr_SET BCM53324_A0_CFAPMEMDEBUGr_SET
#define CFAPMEMDEBUGr_GET BCM53324_A0_CFAPMEMDEBUGr_GET
#define CFAPMEMDEBUGr_TMf_GET BCM53324_A0_CFAPMEMDEBUGr_TMf_GET
#define CFAPMEMDEBUGr_TMf_SET BCM53324_A0_CFAPMEMDEBUGr_TMf_SET
#define CFAPMEMDEBUGr_WWf_GET BCM53324_A0_CFAPMEMDEBUGr_WWf_GET
#define CFAPMEMDEBUGr_WWf_SET BCM53324_A0_CFAPMEMDEBUGr_WWf_SET
#define READ_CFAPMEMDEBUGr BCM53324_A0_READ_CFAPMEMDEBUGr
#define WRITE_CFAPMEMDEBUGr BCM53324_A0_WRITE_CFAPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CFAPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CFAPPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPPARITYERRORPTR MMU CFAP memory parity error pointer indicats.this register only keeps the most current cfap parity error pointer.
 *
 ******************************************************************************/
#define BCM53324_A0_CFAPPARITYERRORPTRr 0x0068002e

#define BCM53324_A0_CFAPPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program CFAPPARITYERRORPTR.
 *
 */
typedef union BCM53324_A0_CFAPPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t cfapparityerrorptr[1];
	uint32_t _cfapparityerrorptr;
} BCM53324_A0_CFAPPARITYERRORPTRr_t;

#define BCM53324_A0_CFAPPARITYERRORPTRr_CLR(r) (r).cfapparityerrorptr[0] = 0
#define BCM53324_A0_CFAPPARITYERRORPTRr_SET(r,d) (r).cfapparityerrorptr[0] = d
#define BCM53324_A0_CFAPPARITYERRORPTRr_GET(r) (r).cfapparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET(r) (((r).cfapparityerrorptr[0]) & 0xfff)
#define BCM53324_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET(r,f) (r).cfapparityerrorptr[0]=(((r).cfapparityerrorptr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access CFAPPARITYERRORPTR.
 *
 */
#define BCM53324_A0_READ_CFAPPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CFAPPARITYERRORPTRr,(r._cfapparityerrorptr))
#define BCM53324_A0_WRITE_CFAPPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CFAPPARITYERRORPTRr,&(r._cfapparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPPARITYERRORPTRr BCM53324_A0_CFAPPARITYERRORPTRr
#define CFAPPARITYERRORPTRr_SIZE BCM53324_A0_CFAPPARITYERRORPTRr_SIZE
typedef BCM53324_A0_CFAPPARITYERRORPTRr_t CFAPPARITYERRORPTRr_t;
#define CFAPPARITYERRORPTRr_CLR BCM53324_A0_CFAPPARITYERRORPTRr_CLR
#define CFAPPARITYERRORPTRr_SET BCM53324_A0_CFAPPARITYERRORPTRr_SET
#define CFAPPARITYERRORPTRr_GET BCM53324_A0_CFAPPARITYERRORPTRr_GET
#define CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET BCM53324_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET
#define CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET BCM53324_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET
#define READ_CFAPPARITYERRORPTRr BCM53324_A0_READ_CFAPPARITYERRORPTRr
#define WRITE_CFAPPARITYERRORPTRr BCM53324_A0_WRITE_CFAPPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CFAPPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CFAPREADPOINTER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPREADPOINTER  The current number of cells that are outstanding in the CBP memory.
 *     CBPFULLSTATUS    Current CBP FULL Status
 *
 ******************************************************************************/
#define BCM53324_A0_CFAPREADPOINTERr 0x0068000e

#define BCM53324_A0_CFAPREADPOINTERr_SIZE 4

/*
 * This structure should be used to declare and program CFAPREADPOINTER.
 *
 */
typedef union BCM53324_A0_CFAPREADPOINTERr_s {
	uint32_t v[1];
	uint32_t cfapreadpointer[1];
	uint32_t _cfapreadpointer;
} BCM53324_A0_CFAPREADPOINTERr_t;

#define BCM53324_A0_CFAPREADPOINTERr_CLR(r) (r).cfapreadpointer[0] = 0
#define BCM53324_A0_CFAPREADPOINTERr_SET(r,d) (r).cfapreadpointer[0] = d
#define BCM53324_A0_CFAPREADPOINTERr_GET(r) (r).cfapreadpointer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_GET(r) (((r).cfapreadpointer[0]) & 0xfff)
#define BCM53324_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_SET(r,f) (r).cfapreadpointer[0]=(((r).cfapreadpointer[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_GET(r) ((((r).cfapreadpointer[0]) >> 12) & 0x1)
#define BCM53324_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_SET(r,f) (r).cfapreadpointer[0]=(((r).cfapreadpointer[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access CFAPREADPOINTER.
 *
 */
#define BCM53324_A0_READ_CFAPREADPOINTERr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CFAPREADPOINTERr,(r._cfapreadpointer))
#define BCM53324_A0_WRITE_CFAPREADPOINTERr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CFAPREADPOINTERr,&(r._cfapreadpointer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPREADPOINTERr BCM53324_A0_CFAPREADPOINTERr
#define CFAPREADPOINTERr_SIZE BCM53324_A0_CFAPREADPOINTERr_SIZE
typedef BCM53324_A0_CFAPREADPOINTERr_t CFAPREADPOINTERr_t;
#define CFAPREADPOINTERr_CLR BCM53324_A0_CFAPREADPOINTERr_CLR
#define CFAPREADPOINTERr_SET BCM53324_A0_CFAPREADPOINTERr_SET
#define CFAPREADPOINTERr_GET BCM53324_A0_CFAPREADPOINTERr_GET
#define CFAPREADPOINTERr_CFAPREADPOINTERf_GET BCM53324_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_GET
#define CFAPREADPOINTERr_CFAPREADPOINTERf_SET BCM53324_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_SET
#define CFAPREADPOINTERr_CBPFULLSTATUSf_GET BCM53324_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_GET
#define CFAPREADPOINTERr_CBPFULLSTATUSf_SET BCM53324_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_SET
#define READ_CFAPREADPOINTERr BCM53324_A0_READ_CFAPREADPOINTERr
#define WRITE_CFAPREADPOINTERr BCM53324_A0_WRITE_CFAPREADPOINTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CFAPREADPOINTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMICTXCOSMASK
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CMICTXCOSMASK    COS Mask sends from CMIC to MMU in order to control which COS packets cpu wants to receive.
 *
 ******************************************************************************/
#define BCM53324_A0_CMICTXCOSMASKr 0x00680015

#define BCM53324_A0_CMICTXCOSMASKr_SIZE 4

/*
 * This structure should be used to declare and program CMICTXCOSMASK.
 *
 */
typedef union BCM53324_A0_CMICTXCOSMASKr_s {
	uint32_t v[1];
	uint32_t cmictxcosmask[1];
	uint32_t _cmictxcosmask;
} BCM53324_A0_CMICTXCOSMASKr_t;

#define BCM53324_A0_CMICTXCOSMASKr_CLR(r) (r).cmictxcosmask[0] = 0
#define BCM53324_A0_CMICTXCOSMASKr_SET(r,d) (r).cmictxcosmask[0] = d
#define BCM53324_A0_CMICTXCOSMASKr_GET(r) (r).cmictxcosmask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_GET(r) (((r).cmictxcosmask[0]) & 0xf)
#define BCM53324_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_SET(r,f) (r).cmictxcosmask[0]=(((r).cmictxcosmask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CMICTXCOSMASK.
 *
 */
#define BCM53324_A0_READ_CMICTXCOSMASKr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CMICTXCOSMASKr,(r._cmictxcosmask))
#define BCM53324_A0_WRITE_CMICTXCOSMASKr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CMICTXCOSMASKr,&(r._cmictxcosmask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMICTXCOSMASKr BCM53324_A0_CMICTXCOSMASKr
#define CMICTXCOSMASKr_SIZE BCM53324_A0_CMICTXCOSMASKr_SIZE
typedef BCM53324_A0_CMICTXCOSMASKr_t CMICTXCOSMASKr_t;
#define CMICTXCOSMASKr_CLR BCM53324_A0_CMICTXCOSMASKr_CLR
#define CMICTXCOSMASKr_SET BCM53324_A0_CMICTXCOSMASKr_SET
#define CMICTXCOSMASKr_GET BCM53324_A0_CMICTXCOSMASKr_GET
#define CMICTXCOSMASKr_CMICTXCOSMASKf_GET BCM53324_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_GET
#define CMICTXCOSMASKr_CMICTXCOSMASKf_SET BCM53324_A0_CMICTXCOSMASKr_CMICTXCOSMASKf_SET
#define READ_CMICTXCOSMASKr BCM53324_A0_READ_CMICTXCOSMASKr
#define WRITE_CMICTXCOSMASKr BCM53324_A0_WRITE_CMICTXCOSMASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMICTXCOSMASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_CHIP_MODE_CONTROL
 * BLOCKS:   CMIC
 * DESC:     Chip Mode Control Register
 * SIZE:     32
 * FIELDS:
 *     UNMANAGED_MODE   0: Managed Mode 1: Unmanaged Mode
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr 0x00000198

#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CHIP_MODE_CONTROL.
 *
 */
typedef union BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_chip_mode_control[1];
	uint32_t _cmic_chip_mode_control;
} BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_t;

#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_CLR(r) (r).cmic_chip_mode_control[0] = 0
#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_SET(r,d) (r).cmic_chip_mode_control[0] = d
#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_GET(r) (r).cmic_chip_mode_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_UNMANAGED_MODEf_GET(r) (((r).cmic_chip_mode_control[0]) & 0x1)
#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_UNMANAGED_MODEf_SET(r,f) (r).cmic_chip_mode_control[0]=(((r).cmic_chip_mode_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_RESERVEDf_GET(r) ((((r).cmic_chip_mode_control[0]) >> 1) & 0x7fffffff)
#define BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_RESERVEDf_SET(r,f) (r).cmic_chip_mode_control[0]=(((r).cmic_chip_mode_control[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access CMIC_CHIP_MODE_CONTROL.
 *
 */
#define BCM53324_A0_READ_CMIC_CHIP_MODE_CONTROLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_CHIP_MODE_CONTROLr,r._cmic_chip_mode_control)
#define BCM53324_A0_WRITE_CMIC_CHIP_MODE_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_CHIP_MODE_CONTROLr,r._cmic_chip_mode_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_CHIP_MODE_CONTROLr BCM53324_A0_CMIC_CHIP_MODE_CONTROLr
#define CMIC_CHIP_MODE_CONTROLr_SIZE BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_SIZE
typedef BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_t CMIC_CHIP_MODE_CONTROLr_t;
#define CMIC_CHIP_MODE_CONTROLr_CLR BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_CLR
#define CMIC_CHIP_MODE_CONTROLr_SET BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_SET
#define CMIC_CHIP_MODE_CONTROLr_GET BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_GET
#define CMIC_CHIP_MODE_CONTROLr_UNMANAGED_MODEf_GET BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_UNMANAGED_MODEf_GET
#define CMIC_CHIP_MODE_CONTROLr_UNMANAGED_MODEf_SET BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_UNMANAGED_MODEf_SET
#define CMIC_CHIP_MODE_CONTROLr_RESERVEDf_GET BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_RESERVEDf_GET
#define CMIC_CHIP_MODE_CONTROLr_RESERVEDf_SET BCM53324_A0_CMIC_CHIP_MODE_CONTROLr_RESERVEDf_SET
#define READ_CMIC_CHIP_MODE_CONTROLr BCM53324_A0_READ_CMIC_CHIP_MODE_CONTROLr
#define WRITE_CMIC_CHIP_MODE_CONTROLr BCM53324_A0_WRITE_CMIC_CHIP_MODE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_CHIP_MODE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_CONFIG
 * BLOCKS:   CMIC
 * DESC:     Configuration Register
 * SIZE:     32
 * FIELDS:
 *     RD_BRST_EN       When set (1), CMIC supports PIO Read Bursts
 *     WR_BRST_EN       When set (1), CMIC supports PIO Write Bursts
 *     BE_CHECK_EN      When set (1), CMIC Does BE Check (32-bit) on PCI writes
 *     MSTR_Q_MAX_EN    When set (1), CMIC can queue up to 4 PCI master requests
 *     IGNORE_MMU_BKP_TXDMA_PKT If set, CMIC will not honour MMU backpressure signal for TxDMA packets.
 *     RESET_CPS        When set CMIC drives CPS-Channel reset
 *     ACT_LOW_INT      When set CMIC drives INTR pin as Active LOW (0) - Default is Active low
 *     SCHAN_ABORT      When set CMIC aborts any pending SCH operation
 *     UNTAG_ALL_RCV_EN When set CMIC removes the TAG field from all received Packets
 *     UNTAG_EN         When set CMIC can remove the TAG field
 *     LE_DMA_EN        When set CMIC the DMA data transfer will be done in Little Endian format
 *     I2C_EN           When set CMIC PCI access to I2C interface is Enabled
 *     IGNORE_MMU_BKP_REMOTE_PKT If set, CMIC will not honour MMU backpressure signal for remote packets.
 *     IGNORE_ADR_ALIGN_EN When set, allow DMA (PCI->SOC) to be aligned to any address boundary.
 *     RESERVED_3       Reserved
 *     DMA_GARBAGE_COLLECT_EN When set CMIC collects packets with Purge bit set
 *     RESET_PCI_EN     If set, CPS reset will also  reset the internal CMIC PCI interface.
 *     TIME_STAMP_UPD_DIS Disable packet time stamp update operation.  DEBUG ONLY.
 *     SG_ENABLE        Enable scatter/gather operation.
 *     SG_RELOAD_ENABLE Enable scatter/gather reload operation.
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     STOP_LS_ON_CHANGE When set, on link change detection, stop link scanning
 *     ABORT_STAT_DMA   Abort the current stat DMA operation.  Not for normal operation.
 *     RESERVED_4       Reserved
 *     COS_RX_EN        When set, packet DMA is based on received COS.  Multiple write channels can be active. 
 *     RESERVED_5       Reserved
 *     OVER_RIDE_EXT_MDIO_MSTR_CNTRL When set, external MDIO master access is disabled,and CMIC becomes the MDIO master, allowing hardware link scan. MUST BE 1 FOR NORMAL OPERATION. Set to 0x0 by default to allow ATE tests to access XAUI/SERDES cores.
 *     MIIM_ADDR_MAP_ENABLE When set, use the MDIO Address Map Table to get the Phy IDfrom the port number for both Wr/Rd and link scan.Else, use the Phy ID as-is.
 *     RESERVED_6       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_CONFIGr 0x0000010c

#define BCM53324_A0_CMIC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CONFIG.
 *
 */
typedef union BCM53324_A0_CMIC_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_config[1];
	uint32_t _cmic_config;
} BCM53324_A0_CMIC_CONFIGr_t;

#define BCM53324_A0_CMIC_CONFIGr_CLR(r) (r).cmic_config[0] = 0
#define BCM53324_A0_CMIC_CONFIGr_SET(r,d) (r).cmic_config[0] = d
#define BCM53324_A0_CMIC_CONFIGr_GET(r) (r).cmic_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_CONFIGr_RD_BRST_ENf_GET(r) (((r).cmic_config[0]) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_RD_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_CONFIGr_WR_BRST_ENf_GET(r) ((((r).cmic_config[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_WR_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_CONFIGr_BE_CHECK_ENf_GET(r) ((((r).cmic_config[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_BE_CHECK_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET(r) ((((r).cmic_config[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_GET(r) ((((r).cmic_config[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_CONFIGr_RESET_CPSf_GET(r) ((((r).cmic_config[0]) >> 5) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_RESET_CPSf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CMIC_CONFIGr_ACT_LOW_INTf_GET(r) ((((r).cmic_config[0]) >> 6) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_ACT_LOW_INTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CMIC_CONFIGr_SCHAN_ABORTf_GET(r) ((((r).cmic_config[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_SCHAN_ABORTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET(r) ((((r).cmic_config[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_CONFIGr_UNTAG_ENf_GET(r) ((((r).cmic_config[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_UNTAG_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_CONFIGr_LE_DMA_ENf_GET(r) ((((r).cmic_config[0]) >> 10) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_LE_DMA_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CMIC_CONFIGr_I2C_ENf_GET(r) ((((r).cmic_config[0]) >> 11) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_I2C_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_GET(r) ((((r).cmic_config[0]) >> 12) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET(r) ((((r).cmic_config[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_CONFIGr_RESERVED_3f_GET(r) ((((r).cmic_config[0]) >> 14) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_RESERVED_3f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET(r) ((((r).cmic_config[0]) >> 15) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_CMIC_CONFIGr_RESET_PCI_ENf_GET(r) ((((r).cmic_config[0]) >> 16) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_RESET_PCI_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 17) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_CMIC_CONFIGr_SG_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 18) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_SG_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 19) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 20) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET(r) ((((r).cmic_config[0]) >> 21) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_GET(r) ((((r).cmic_config[0]) >> 22) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_CMIC_CONFIGr_RESERVED_4f_GET(r) ((((r).cmic_config[0]) >> 23) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_RESERVED_4f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_CMIC_CONFIGr_COS_RX_ENf_GET(r) ((((r).cmic_config[0]) >> 24) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_COS_RX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_CMIC_CONFIGr_RESERVED_5f_GET(r) ((((r).cmic_config[0]) >> 25) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_RESERVED_5f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET(r) ((((r).cmic_config[0]) >> 26) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 27) & 0x1)
#define BCM53324_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_CMIC_CONFIGr_RESERVED_6f_GET(r) ((((r).cmic_config[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_CONFIGr_RESERVED_6f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_CONFIG.
 *
 */
#define BCM53324_A0_READ_CMIC_CONFIGr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_CONFIGr,r._cmic_config)
#define BCM53324_A0_WRITE_CMIC_CONFIGr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_CONFIGr,r._cmic_config)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_CONFIGr BCM53324_A0_CMIC_CONFIGr
#define CMIC_CONFIGr_SIZE BCM53324_A0_CMIC_CONFIGr_SIZE
typedef BCM53324_A0_CMIC_CONFIGr_t CMIC_CONFIGr_t;
#define CMIC_CONFIGr_CLR BCM53324_A0_CMIC_CONFIGr_CLR
#define CMIC_CONFIGr_SET BCM53324_A0_CMIC_CONFIGr_SET
#define CMIC_CONFIGr_GET BCM53324_A0_CMIC_CONFIGr_GET
#define CMIC_CONFIGr_RD_BRST_ENf_GET BCM53324_A0_CMIC_CONFIGr_RD_BRST_ENf_GET
#define CMIC_CONFIGr_RD_BRST_ENf_SET BCM53324_A0_CMIC_CONFIGr_RD_BRST_ENf_SET
#define CMIC_CONFIGr_WR_BRST_ENf_GET BCM53324_A0_CMIC_CONFIGr_WR_BRST_ENf_GET
#define CMIC_CONFIGr_WR_BRST_ENf_SET BCM53324_A0_CMIC_CONFIGr_WR_BRST_ENf_SET
#define CMIC_CONFIGr_BE_CHECK_ENf_GET BCM53324_A0_CMIC_CONFIGr_BE_CHECK_ENf_GET
#define CMIC_CONFIGr_BE_CHECK_ENf_SET BCM53324_A0_CMIC_CONFIGr_BE_CHECK_ENf_SET
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET BCM53324_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET BCM53324_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET
#define CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_GET BCM53324_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_GET
#define CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_SET BCM53324_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_TXDMA_PKTf_SET
#define CMIC_CONFIGr_RESET_CPSf_GET BCM53324_A0_CMIC_CONFIGr_RESET_CPSf_GET
#define CMIC_CONFIGr_RESET_CPSf_SET BCM53324_A0_CMIC_CONFIGr_RESET_CPSf_SET
#define CMIC_CONFIGr_ACT_LOW_INTf_GET BCM53324_A0_CMIC_CONFIGr_ACT_LOW_INTf_GET
#define CMIC_CONFIGr_ACT_LOW_INTf_SET BCM53324_A0_CMIC_CONFIGr_ACT_LOW_INTf_SET
#define CMIC_CONFIGr_SCHAN_ABORTf_GET BCM53324_A0_CMIC_CONFIGr_SCHAN_ABORTf_GET
#define CMIC_CONFIGr_SCHAN_ABORTf_SET BCM53324_A0_CMIC_CONFIGr_SCHAN_ABORTf_SET
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET BCM53324_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET BCM53324_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET
#define CMIC_CONFIGr_UNTAG_ENf_GET BCM53324_A0_CMIC_CONFIGr_UNTAG_ENf_GET
#define CMIC_CONFIGr_UNTAG_ENf_SET BCM53324_A0_CMIC_CONFIGr_UNTAG_ENf_SET
#define CMIC_CONFIGr_LE_DMA_ENf_GET BCM53324_A0_CMIC_CONFIGr_LE_DMA_ENf_GET
#define CMIC_CONFIGr_LE_DMA_ENf_SET BCM53324_A0_CMIC_CONFIGr_LE_DMA_ENf_SET
#define CMIC_CONFIGr_I2C_ENf_GET BCM53324_A0_CMIC_CONFIGr_I2C_ENf_GET
#define CMIC_CONFIGr_I2C_ENf_SET BCM53324_A0_CMIC_CONFIGr_I2C_ENf_SET
#define CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_GET BCM53324_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_GET
#define CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_SET BCM53324_A0_CMIC_CONFIGr_IGNORE_MMU_BKP_REMOTE_PKTf_SET
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET BCM53324_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET BCM53324_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET
#define CMIC_CONFIGr_RESERVED_3f_GET BCM53324_A0_CMIC_CONFIGr_RESERVED_3f_GET
#define CMIC_CONFIGr_RESERVED_3f_SET BCM53324_A0_CMIC_CONFIGr_RESERVED_3f_SET
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET BCM53324_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET BCM53324_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET
#define CMIC_CONFIGr_RESET_PCI_ENf_GET BCM53324_A0_CMIC_CONFIGr_RESET_PCI_ENf_GET
#define CMIC_CONFIGr_RESET_PCI_ENf_SET BCM53324_A0_CMIC_CONFIGr_RESET_PCI_ENf_SET
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET BCM53324_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET BCM53324_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET
#define CMIC_CONFIGr_SG_ENABLEf_GET BCM53324_A0_CMIC_CONFIGr_SG_ENABLEf_GET
#define CMIC_CONFIGr_SG_ENABLEf_SET BCM53324_A0_CMIC_CONFIGr_SG_ENABLEf_SET
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET BCM53324_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET BCM53324_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_GET BCM53324_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_GET
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_SET BCM53324_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_SET
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET BCM53324_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET BCM53324_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET
#define CMIC_CONFIGr_ABORT_STAT_DMAf_GET BCM53324_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_GET
#define CMIC_CONFIGr_ABORT_STAT_DMAf_SET BCM53324_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_SET
#define CMIC_CONFIGr_RESERVED_4f_GET BCM53324_A0_CMIC_CONFIGr_RESERVED_4f_GET
#define CMIC_CONFIGr_RESERVED_4f_SET BCM53324_A0_CMIC_CONFIGr_RESERVED_4f_SET
#define CMIC_CONFIGr_COS_RX_ENf_GET BCM53324_A0_CMIC_CONFIGr_COS_RX_ENf_GET
#define CMIC_CONFIGr_COS_RX_ENf_SET BCM53324_A0_CMIC_CONFIGr_COS_RX_ENf_SET
#define CMIC_CONFIGr_RESERVED_5f_GET BCM53324_A0_CMIC_CONFIGr_RESERVED_5f_GET
#define CMIC_CONFIGr_RESERVED_5f_SET BCM53324_A0_CMIC_CONFIGr_RESERVED_5f_SET
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET BCM53324_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET BCM53324_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET BCM53324_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET BCM53324_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET
#define CMIC_CONFIGr_RESERVED_6f_GET BCM53324_A0_CMIC_CONFIGr_RESERVED_6f_GET
#define CMIC_CONFIGr_RESERVED_6f_SET BCM53324_A0_CMIC_CONFIGr_RESERVED_6f_SET
#define READ_CMIC_CONFIGr BCM53324_A0_READ_CMIC_CONFIGr
#define WRITE_CMIC_CONFIGr BCM53324_A0_WRITE_CMIC_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_COS_CTRL_RX
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel 

 * SIZE:     32
 * FIELDS:
 *     CH0_COS_BMP      Channel 0 COS bitmap
 *     CH1_COS_BMP      Channel 1 COS bitmap
 *     CH2_COS_BMP      Channel 2 COS bitmap
 *     CH3_COS_BMP      Channel 3 COS bitmap
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_COS_CTRL_RXr 0x00000180

#define BCM53324_A0_CMIC_COS_CTRL_RXr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COS_CTRL_RX.
 *
 */
typedef union BCM53324_A0_CMIC_COS_CTRL_RXr_s {
	uint32_t v[1];
	uint32_t cmic_cos_ctrl_rx[1];
	uint32_t _cmic_cos_ctrl_rx;
} BCM53324_A0_CMIC_COS_CTRL_RXr_t;

#define BCM53324_A0_CMIC_COS_CTRL_RXr_CLR(r) (r).cmic_cos_ctrl_rx[0] = 0
#define BCM53324_A0_CMIC_COS_CTRL_RXr_SET(r,d) (r).cmic_cos_ctrl_rx[0] = d
#define BCM53324_A0_CMIC_COS_CTRL_RXr_GET(r) (r).cmic_cos_ctrl_rx[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET(r) (((r).cmic_cos_ctrl_rx[0]) & 0xff)
#define BCM53324_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 8) & 0xff)
#define BCM53324_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53324_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 16) & 0xff)
#define BCM53324_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53324_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 24) & 0xff)
#define BCM53324_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_COS_CTRL_RX.
 *
 */
#define BCM53324_A0_READ_CMIC_COS_CTRL_RXr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_COS_CTRL_RXr,r._cmic_cos_ctrl_rx)
#define BCM53324_A0_WRITE_CMIC_COS_CTRL_RXr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_COS_CTRL_RXr,r._cmic_cos_ctrl_rx)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_COS_CTRL_RXr BCM53324_A0_CMIC_COS_CTRL_RXr
#define CMIC_COS_CTRL_RXr_SIZE BCM53324_A0_CMIC_COS_CTRL_RXr_SIZE
typedef BCM53324_A0_CMIC_COS_CTRL_RXr_t CMIC_COS_CTRL_RXr_t;
#define CMIC_COS_CTRL_RXr_CLR BCM53324_A0_CMIC_COS_CTRL_RXr_CLR
#define CMIC_COS_CTRL_RXr_SET BCM53324_A0_CMIC_COS_CTRL_RXr_SET
#define CMIC_COS_CTRL_RXr_GET BCM53324_A0_CMIC_COS_CTRL_RXr_GET
#define CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET BCM53324_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET BCM53324_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET BCM53324_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET BCM53324_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET BCM53324_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET BCM53324_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET BCM53324_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET BCM53324_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET
#define READ_CMIC_COS_CTRL_RXr BCM53324_A0_READ_CMIC_COS_CTRL_RXr
#define WRITE_CMIC_COS_CTRL_RXr BCM53324_A0_WRITE_CMIC_COS_CTRL_RXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_COS_CTRL_RXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_COS_CTRL_RX_HI
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel 

 * SIZE:     32
 * FIELDS:
 *     CH0_COS_BMP      Channel 0 COS bitmap upper byte
 *     CH1_COS_BMP      Channel 1 COS bitmap upper byte
 *     CH2_COS_BMP      Channel 2 COS bitmap upper byte
 *     CH3_COS_BMP      Channel 3 COS bitmap upper byte
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr 0x00000184

#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COS_CTRL_RX_HI.
 *
 */
typedef union BCM53324_A0_CMIC_COS_CTRL_RX_HIr_s {
	uint32_t v[1];
	uint32_t cmic_cos_ctrl_rx_hi[1];
	uint32_t _cmic_cos_ctrl_rx_hi;
} BCM53324_A0_CMIC_COS_CTRL_RX_HIr_t;

#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CLR(r) (r).cmic_cos_ctrl_rx_hi[0] = 0
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_SET(r,d) (r).cmic_cos_ctrl_rx_hi[0] = d
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_GET(r) (r).cmic_cos_ctrl_rx_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_GET(r) (((r).cmic_cos_ctrl_rx_hi[0]) & 0xff)
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 8) & 0xff)
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 16) & 0xff)
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 24) & 0xff)
#define BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_COS_CTRL_RX_HI.
 *
 */
#define BCM53324_A0_READ_CMIC_COS_CTRL_RX_HIr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_COS_CTRL_RX_HIr,r._cmic_cos_ctrl_rx_hi)
#define BCM53324_A0_WRITE_CMIC_COS_CTRL_RX_HIr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_COS_CTRL_RX_HIr,r._cmic_cos_ctrl_rx_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_COS_CTRL_RX_HIr BCM53324_A0_CMIC_COS_CTRL_RX_HIr
#define CMIC_COS_CTRL_RX_HIr_SIZE BCM53324_A0_CMIC_COS_CTRL_RX_HIr_SIZE
typedef BCM53324_A0_CMIC_COS_CTRL_RX_HIr_t CMIC_COS_CTRL_RX_HIr_t;
#define CMIC_COS_CTRL_RX_HIr_CLR BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CLR
#define CMIC_COS_CTRL_RX_HIr_SET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_SET
#define CMIC_COS_CTRL_RX_HIr_GET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_GET
#define CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_GET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_GET
#define CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_SET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMPf_SET
#define CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_GET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_GET
#define CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_SET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMPf_SET
#define CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_GET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_GET
#define CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_SET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMPf_SET
#define CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_GET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_GET
#define CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_SET BCM53324_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMPf_SET
#define READ_CMIC_COS_CTRL_RX_HIr BCM53324_A0_READ_CMIC_COS_CTRL_RX_HIr
#define WRITE_CMIC_COS_CTRL_RX_HIr BCM53324_A0_WRITE_CMIC_COS_CTRL_RX_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_COS_CTRL_RX_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_DEV_REV_ID
 * BLOCKS:   CMIC
 * DESC:     Device/revision ID
 * SIZE:     32
 * FIELDS:
 *     DEV_ID           Device ID
 *     REV_ID           Revision ID
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_DEV_REV_IDr 0x00000178

#define BCM53324_A0_CMIC_DEV_REV_IDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DEV_REV_ID.
 *
 */
typedef union BCM53324_A0_CMIC_DEV_REV_IDr_s {
	uint32_t v[1];
	uint32_t cmic_dev_rev_id[1];
	uint32_t _cmic_dev_rev_id;
} BCM53324_A0_CMIC_DEV_REV_IDr_t;

#define BCM53324_A0_CMIC_DEV_REV_IDr_CLR(r) (r).cmic_dev_rev_id[0] = 0
#define BCM53324_A0_CMIC_DEV_REV_IDr_SET(r,d) (r).cmic_dev_rev_id[0] = d
#define BCM53324_A0_CMIC_DEV_REV_IDr_GET(r) (r).cmic_dev_rev_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_DEV_REV_IDr_DEV_IDf_GET(r) (((r).cmic_dev_rev_id[0]) & 0xffff)
#define BCM53324_A0_CMIC_DEV_REV_IDr_DEV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_DEV_REV_IDr_REV_IDf_GET(r) ((((r).cmic_dev_rev_id[0]) >> 16) & 0xff)
#define BCM53324_A0_CMIC_DEV_REV_IDr_REV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53324_A0_CMIC_DEV_REV_IDr_RESERVED_1f_GET(r) ((((r).cmic_dev_rev_id[0]) >> 24) & 0xff)
#define BCM53324_A0_CMIC_DEV_REV_IDr_RESERVED_1f_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_DEV_REV_ID.
 *
 */
#define BCM53324_A0_READ_CMIC_DEV_REV_IDr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_DEV_REV_IDr,r._cmic_dev_rev_id)
#define BCM53324_A0_WRITE_CMIC_DEV_REV_IDr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_DEV_REV_IDr,r._cmic_dev_rev_id)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DEV_REV_IDr BCM53324_A0_CMIC_DEV_REV_IDr
#define CMIC_DEV_REV_IDr_SIZE BCM53324_A0_CMIC_DEV_REV_IDr_SIZE
typedef BCM53324_A0_CMIC_DEV_REV_IDr_t CMIC_DEV_REV_IDr_t;
#define CMIC_DEV_REV_IDr_CLR BCM53324_A0_CMIC_DEV_REV_IDr_CLR
#define CMIC_DEV_REV_IDr_SET BCM53324_A0_CMIC_DEV_REV_IDr_SET
#define CMIC_DEV_REV_IDr_GET BCM53324_A0_CMIC_DEV_REV_IDr_GET
#define CMIC_DEV_REV_IDr_DEV_IDf_GET BCM53324_A0_CMIC_DEV_REV_IDr_DEV_IDf_GET
#define CMIC_DEV_REV_IDr_DEV_IDf_SET BCM53324_A0_CMIC_DEV_REV_IDr_DEV_IDf_SET
#define CMIC_DEV_REV_IDr_REV_IDf_GET BCM53324_A0_CMIC_DEV_REV_IDr_REV_IDf_GET
#define CMIC_DEV_REV_IDr_REV_IDf_SET BCM53324_A0_CMIC_DEV_REV_IDr_REV_IDf_SET
#define CMIC_DEV_REV_IDr_RESERVED_1f_GET BCM53324_A0_CMIC_DEV_REV_IDr_RESERVED_1f_GET
#define CMIC_DEV_REV_IDr_RESERVED_1f_SET BCM53324_A0_CMIC_DEV_REV_IDr_RESERVED_1f_SET
#define READ_CMIC_DEV_REV_IDr BCM53324_A0_READ_CMIC_DEV_REV_IDr
#define WRITE_CMIC_DEV_REV_IDr BCM53324_A0_WRITE_CMIC_DEV_REV_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_DEV_REV_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_DIRECTION    DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH0   Reserved
 *     CH0_ABORT_DMA    DMA channel 0 abort
 *     CH0_SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH0   Reserved
 *     RESERVED_3_CH0   Reserved
 *     CH0_DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH1_DIRECTION    DMA channel 1 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH1   Reserved
 *     CH1_ABORT_DMA    DMA channel 1 abort
 *     CH1_SEL_INTR_ON_DESC_OR_PKT DMA channel 1 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH1   Reserved
 *     RESERVED_3_CH1   Reserved
 *     CH1_DROP_RX_PKT_ON_CHAIN_END DMA channel 1 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH2_DIRECTION    DMA channel 2 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH2   Reserved
 *     CH2_ABORT_DMA    DMA channel 2 abort
 *     CH2_SEL_INTR_ON_DESC_OR_PKT DMA channel 2 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH2   Reserved
 *     RESERVED_3_CH2   Reserved
 *     CH2_DROP_RX_PKT_ON_CHAIN_END DMA channel 2 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH3_DIRECTION    DMA channel 3 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH3   Reserved
 *     CH3_ABORT_DMA    DMA channel 3 abort
 *     CH3_SEL_INTR_ON_DESC_OR_PKT DMA channel 3 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH3   Reserved
 *     RESERVED_3_CH3   Reserved
 *     CH3_DROP_RX_PKT_ON_CHAIN_END DMA channel 3 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_DMA_CTRLr 0x00000100

#define BCM53324_A0_CMIC_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_CTRL.
 *
 */
typedef union BCM53324_A0_CMIC_DMA_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_dma_ctrl[1];
	uint32_t _cmic_dma_ctrl;
} BCM53324_A0_CMIC_DMA_CTRLr_t;

#define BCM53324_A0_CMIC_DMA_CTRLr_CLR(r) (r).cmic_dma_ctrl[0] = 0
#define BCM53324_A0_CMIC_DMA_CTRLr_SET(r,d) (r).cmic_dma_ctrl[0] = d
#define BCM53324_A0_CMIC_DMA_CTRLr_GET(r) (r).cmic_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET(r) (((r).cmic_dma_ctrl[0]) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 5) & 0x3)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 10) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 11) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 12) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 13) & 0x3)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 15) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 16) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 17) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 18) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 19) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 20) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 21) & 0x3)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 23) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 24) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 25) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 26) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 27) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 28) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 29) & 0x3)
#define BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53324_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 31) & 0x1)
#define BCM53324_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_DMA_CTRL.
 *
 */
#define BCM53324_A0_READ_CMIC_DMA_CTRLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_DMA_CTRLr,r._cmic_dma_ctrl)
#define BCM53324_A0_WRITE_CMIC_DMA_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_DMA_CTRLr,r._cmic_dma_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_CTRLr BCM53324_A0_CMIC_DMA_CTRLr
#define CMIC_DMA_CTRLr_SIZE BCM53324_A0_CMIC_DMA_CTRLr_SIZE
typedef BCM53324_A0_CMIC_DMA_CTRLr_t CMIC_DMA_CTRLr_t;
#define CMIC_DMA_CTRLr_CLR BCM53324_A0_CMIC_DMA_CTRLr_CLR
#define CMIC_DMA_CTRLr_SET BCM53324_A0_CMIC_DMA_CTRLr_SET
#define CMIC_DMA_CTRLr_GET BCM53324_A0_CMIC_DMA_CTRLr_GET
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET BCM53324_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM53324_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM53324_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define READ_CMIC_DMA_CTRLr BCM53324_A0_READ_CMIC_DMA_CTRLr
#define WRITE_CMIC_DMA_CTRLr BCM53324_A0_WRITE_CMIC_DMA_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_DMA_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_DMA_DESC0
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 0 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH0 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_DMA_DESC0r 0x00000110

#define BCM53324_A0_CMIC_DMA_DESC0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC0.
 *
 */
typedef union BCM53324_A0_CMIC_DMA_DESC0r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc0[1];
	uint32_t _cmic_dma_desc0;
} BCM53324_A0_CMIC_DMA_DESC0r_t;

#define BCM53324_A0_CMIC_DMA_DESC0r_CLR(r) (r).cmic_dma_desc0[0] = 0
#define BCM53324_A0_CMIC_DMA_DESC0r_SET(r,d) (r).cmic_dma_desc0[0] = d
#define BCM53324_A0_CMIC_DMA_DESC0r_GET(r) (r).cmic_dma_desc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_DMA_DESC0r_ADDRf_GET(r) ((r).cmic_dma_desc0[0])
#define BCM53324_A0_CMIC_DMA_DESC0r_ADDRf_SET(r,f) (r).cmic_dma_desc0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC0.
 *
 */
#define BCM53324_A0_READ_CMIC_DMA_DESC0r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_DMA_DESC0r,r._cmic_dma_desc0)
#define BCM53324_A0_WRITE_CMIC_DMA_DESC0r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_DMA_DESC0r,r._cmic_dma_desc0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC0r BCM53324_A0_CMIC_DMA_DESC0r
#define CMIC_DMA_DESC0r_SIZE BCM53324_A0_CMIC_DMA_DESC0r_SIZE
typedef BCM53324_A0_CMIC_DMA_DESC0r_t CMIC_DMA_DESC0r_t;
#define CMIC_DMA_DESC0r_CLR BCM53324_A0_CMIC_DMA_DESC0r_CLR
#define CMIC_DMA_DESC0r_SET BCM53324_A0_CMIC_DMA_DESC0r_SET
#define CMIC_DMA_DESC0r_GET BCM53324_A0_CMIC_DMA_DESC0r_GET
#define CMIC_DMA_DESC0r_ADDRf_GET BCM53324_A0_CMIC_DMA_DESC0r_ADDRf_GET
#define CMIC_DMA_DESC0r_ADDRf_SET BCM53324_A0_CMIC_DMA_DESC0r_ADDRf_SET
#define READ_CMIC_DMA_DESC0r BCM53324_A0_READ_CMIC_DMA_DESC0r
#define WRITE_CMIC_DMA_DESC0r BCM53324_A0_WRITE_CMIC_DMA_DESC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_DMA_DESC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_DMA_DESC1
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 1 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH1 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_DMA_DESC1r 0x00000114

#define BCM53324_A0_CMIC_DMA_DESC1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC1.
 *
 */
typedef union BCM53324_A0_CMIC_DMA_DESC1r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc1[1];
	uint32_t _cmic_dma_desc1;
} BCM53324_A0_CMIC_DMA_DESC1r_t;

#define BCM53324_A0_CMIC_DMA_DESC1r_CLR(r) (r).cmic_dma_desc1[0] = 0
#define BCM53324_A0_CMIC_DMA_DESC1r_SET(r,d) (r).cmic_dma_desc1[0] = d
#define BCM53324_A0_CMIC_DMA_DESC1r_GET(r) (r).cmic_dma_desc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_DMA_DESC1r_ADDRf_GET(r) ((r).cmic_dma_desc1[0])
#define BCM53324_A0_CMIC_DMA_DESC1r_ADDRf_SET(r,f) (r).cmic_dma_desc1[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC1.
 *
 */
#define BCM53324_A0_READ_CMIC_DMA_DESC1r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_DMA_DESC1r,r._cmic_dma_desc1)
#define BCM53324_A0_WRITE_CMIC_DMA_DESC1r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_DMA_DESC1r,r._cmic_dma_desc1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC1r BCM53324_A0_CMIC_DMA_DESC1r
#define CMIC_DMA_DESC1r_SIZE BCM53324_A0_CMIC_DMA_DESC1r_SIZE
typedef BCM53324_A0_CMIC_DMA_DESC1r_t CMIC_DMA_DESC1r_t;
#define CMIC_DMA_DESC1r_CLR BCM53324_A0_CMIC_DMA_DESC1r_CLR
#define CMIC_DMA_DESC1r_SET BCM53324_A0_CMIC_DMA_DESC1r_SET
#define CMIC_DMA_DESC1r_GET BCM53324_A0_CMIC_DMA_DESC1r_GET
#define CMIC_DMA_DESC1r_ADDRf_GET BCM53324_A0_CMIC_DMA_DESC1r_ADDRf_GET
#define CMIC_DMA_DESC1r_ADDRf_SET BCM53324_A0_CMIC_DMA_DESC1r_ADDRf_SET
#define READ_CMIC_DMA_DESC1r BCM53324_A0_READ_CMIC_DMA_DESC1r
#define WRITE_CMIC_DMA_DESC1r BCM53324_A0_WRITE_CMIC_DMA_DESC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_DMA_DESC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_DMA_DESC2
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 2 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH2 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_DMA_DESC2r 0x00000118

#define BCM53324_A0_CMIC_DMA_DESC2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC2.
 *
 */
typedef union BCM53324_A0_CMIC_DMA_DESC2r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc2[1];
	uint32_t _cmic_dma_desc2;
} BCM53324_A0_CMIC_DMA_DESC2r_t;

#define BCM53324_A0_CMIC_DMA_DESC2r_CLR(r) (r).cmic_dma_desc2[0] = 0
#define BCM53324_A0_CMIC_DMA_DESC2r_SET(r,d) (r).cmic_dma_desc2[0] = d
#define BCM53324_A0_CMIC_DMA_DESC2r_GET(r) (r).cmic_dma_desc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_DMA_DESC2r_ADDRf_GET(r) ((r).cmic_dma_desc2[0])
#define BCM53324_A0_CMIC_DMA_DESC2r_ADDRf_SET(r,f) (r).cmic_dma_desc2[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC2.
 *
 */
#define BCM53324_A0_READ_CMIC_DMA_DESC2r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_DMA_DESC2r,r._cmic_dma_desc2)
#define BCM53324_A0_WRITE_CMIC_DMA_DESC2r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_DMA_DESC2r,r._cmic_dma_desc2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC2r BCM53324_A0_CMIC_DMA_DESC2r
#define CMIC_DMA_DESC2r_SIZE BCM53324_A0_CMIC_DMA_DESC2r_SIZE
typedef BCM53324_A0_CMIC_DMA_DESC2r_t CMIC_DMA_DESC2r_t;
#define CMIC_DMA_DESC2r_CLR BCM53324_A0_CMIC_DMA_DESC2r_CLR
#define CMIC_DMA_DESC2r_SET BCM53324_A0_CMIC_DMA_DESC2r_SET
#define CMIC_DMA_DESC2r_GET BCM53324_A0_CMIC_DMA_DESC2r_GET
#define CMIC_DMA_DESC2r_ADDRf_GET BCM53324_A0_CMIC_DMA_DESC2r_ADDRf_GET
#define CMIC_DMA_DESC2r_ADDRf_SET BCM53324_A0_CMIC_DMA_DESC2r_ADDRf_SET
#define READ_CMIC_DMA_DESC2r BCM53324_A0_READ_CMIC_DMA_DESC2r
#define WRITE_CMIC_DMA_DESC2r BCM53324_A0_WRITE_CMIC_DMA_DESC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_DMA_DESC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_DMA_DESC3
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 3 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH3 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_DMA_DESC3r 0x0000011c

#define BCM53324_A0_CMIC_DMA_DESC3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC3.
 *
 */
typedef union BCM53324_A0_CMIC_DMA_DESC3r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc3[1];
	uint32_t _cmic_dma_desc3;
} BCM53324_A0_CMIC_DMA_DESC3r_t;

#define BCM53324_A0_CMIC_DMA_DESC3r_CLR(r) (r).cmic_dma_desc3[0] = 0
#define BCM53324_A0_CMIC_DMA_DESC3r_SET(r,d) (r).cmic_dma_desc3[0] = d
#define BCM53324_A0_CMIC_DMA_DESC3r_GET(r) (r).cmic_dma_desc3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_DMA_DESC3r_ADDRf_GET(r) ((r).cmic_dma_desc3[0])
#define BCM53324_A0_CMIC_DMA_DESC3r_ADDRf_SET(r,f) (r).cmic_dma_desc3[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC3.
 *
 */
#define BCM53324_A0_READ_CMIC_DMA_DESC3r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_DMA_DESC3r,r._cmic_dma_desc3)
#define BCM53324_A0_WRITE_CMIC_DMA_DESC3r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_DMA_DESC3r,r._cmic_dma_desc3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC3r BCM53324_A0_CMIC_DMA_DESC3r
#define CMIC_DMA_DESC3r_SIZE BCM53324_A0_CMIC_DMA_DESC3r_SIZE
typedef BCM53324_A0_CMIC_DMA_DESC3r_t CMIC_DMA_DESC3r_t;
#define CMIC_DMA_DESC3r_CLR BCM53324_A0_CMIC_DMA_DESC3r_CLR
#define CMIC_DMA_DESC3r_SET BCM53324_A0_CMIC_DMA_DESC3r_SET
#define CMIC_DMA_DESC3r_GET BCM53324_A0_CMIC_DMA_DESC3r_GET
#define CMIC_DMA_DESC3r_ADDRf_GET BCM53324_A0_CMIC_DMA_DESC3r_ADDRf_GET
#define CMIC_DMA_DESC3r_ADDRf_SET BCM53324_A0_CMIC_DMA_DESC3r_ADDRf_SET
#define READ_CMIC_DMA_DESC3r BCM53324_A0_READ_CMIC_DMA_DESC3r
#define WRITE_CMIC_DMA_DESC3r BCM53324_A0_WRITE_CMIC_DMA_DESC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_DMA_DESC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     DMA Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     CH0_DMA_EN       Set by CPU to start a DMA on CH0 
 *     CH1_DMA_EN       Set by CPU to start a DMA on CH1 
 *     CH2_DMA_EN       Set by CPU to start a DMA on CH2 
 *     CH3_DMA_EN       Set by CPU to start a DMA on CH3 
 *     CH0_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH1_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH2_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *     CH3_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH0_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH1_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH2_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH3_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     DMA_RESET        Set by CPU to reset DMA Controller
 *     STATS_DMA_OPN_COMPLETE Set by CPU to indicate Stats DMA operation complete
 *     STATS_DMA_ITER_DONE Set by CPU to indicate Stats DMA iteration done
 *     TX_DMA_ABORT_NEEDS_CLEANUP Set by CPU to indicate that the previous TX DMA was aborted inthe middle of a packet (i.e., not at packet boundary). The CPU needs to clean up by forcing an eop packet with purge bit set.
 *     STATS_DMA_ERROR  Set by CPU to indicate Stats DMA resulted in an error
 *     STATS_DMA_ACTIVE Set by CPU to indicate Stats DMA currently active
 *     CH0_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH1_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH2_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH3_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     PCI_PARITY_ERR   Set by CMIC to indicate DMA Resulting in PCI Parity Error
 *     PCI_FATAL_ERR    Set by CMIC to indicate DMA Resulting in PCI Fatal Error
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_DMA_STATr 0x00000104

#define BCM53324_A0_CMIC_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_STAT.
 *
 */
typedef union BCM53324_A0_CMIC_DMA_STATr_s {
	uint32_t v[1];
	uint32_t cmic_dma_stat[1];
	uint32_t _cmic_dma_stat;
} BCM53324_A0_CMIC_DMA_STATr_t;

#define BCM53324_A0_CMIC_DMA_STATr_CLR(r) (r).cmic_dma_stat[0] = 0
#define BCM53324_A0_CMIC_DMA_STATr_SET(r,d) (r).cmic_dma_stat[0] = d
#define BCM53324_A0_CMIC_DMA_STATr_GET(r) (r).cmic_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_DMA_STATr_BIT_POSf_GET(r) (((r).cmic_dma_stat[0]) & 0x1f)
#define BCM53324_A0_CMIC_DMA_STATr_BIT_POSf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_DMA_STATr_CH0_DMA_ENf_GET(r) (((r).cmic_dma_stat[0]) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH0_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_DMA_STATr_CH1_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH1_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_DMA_STATr_CH2_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH2_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_DMA_STATr_CH3_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH3_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 5) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 6) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CMIC_DMA_STATr_BIT_VALf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_BIT_VALf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 10) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 11) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CMIC_DMA_STATr_DMA_RESETf_GET(r) ((((r).cmic_dma_stat[0]) >> 12) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_DMA_RESETf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET(r) ((((r).cmic_dma_stat[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 14) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET(r) ((((r).cmic_dma_stat[0]) >> 15) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_GET(r) ((((r).cmic_dma_stat[0]) >> 16) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 17) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 18) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 19) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 20) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 21) & 0x1)
#define BCM53324_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 22) & 0x1f)
#define BCM53324_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM53324_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 27) & 0x1f)
#define BCM53324_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access CMIC_DMA_STAT.
 *
 */
#define BCM53324_A0_READ_CMIC_DMA_STATr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_DMA_STATr,r._cmic_dma_stat)
#define BCM53324_A0_WRITE_CMIC_DMA_STATr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_DMA_STATr,r._cmic_dma_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_STATr BCM53324_A0_CMIC_DMA_STATr
#define CMIC_DMA_STATr_SIZE BCM53324_A0_CMIC_DMA_STATr_SIZE
typedef BCM53324_A0_CMIC_DMA_STATr_t CMIC_DMA_STATr_t;
#define CMIC_DMA_STATr_CLR BCM53324_A0_CMIC_DMA_STATr_CLR
#define CMIC_DMA_STATr_SET BCM53324_A0_CMIC_DMA_STATr_SET
#define CMIC_DMA_STATr_GET BCM53324_A0_CMIC_DMA_STATr_GET
#define CMIC_DMA_STATr_BIT_POSf_GET BCM53324_A0_CMIC_DMA_STATr_BIT_POSf_GET
#define CMIC_DMA_STATr_BIT_POSf_SET BCM53324_A0_CMIC_DMA_STATr_BIT_POSf_SET
#define CMIC_DMA_STATr_CH0_DMA_ENf_GET BCM53324_A0_CMIC_DMA_STATr_CH0_DMA_ENf_GET
#define CMIC_DMA_STATr_CH0_DMA_ENf_SET BCM53324_A0_CMIC_DMA_STATr_CH0_DMA_ENf_SET
#define CMIC_DMA_STATr_CH1_DMA_ENf_GET BCM53324_A0_CMIC_DMA_STATr_CH1_DMA_ENf_GET
#define CMIC_DMA_STATr_CH1_DMA_ENf_SET BCM53324_A0_CMIC_DMA_STATr_CH1_DMA_ENf_SET
#define CMIC_DMA_STATr_CH2_DMA_ENf_GET BCM53324_A0_CMIC_DMA_STATr_CH2_DMA_ENf_GET
#define CMIC_DMA_STATr_CH2_DMA_ENf_SET BCM53324_A0_CMIC_DMA_STATr_CH2_DMA_ENf_SET
#define CMIC_DMA_STATr_CH3_DMA_ENf_GET BCM53324_A0_CMIC_DMA_STATr_CH3_DMA_ENf_GET
#define CMIC_DMA_STATr_CH3_DMA_ENf_SET BCM53324_A0_CMIC_DMA_STATr_CH3_DMA_ENf_SET
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_BIT_VALf_GET BCM53324_A0_CMIC_DMA_STATr_BIT_VALf_GET
#define CMIC_DMA_STATr_BIT_VALf_SET BCM53324_A0_CMIC_DMA_STATr_BIT_VALf_SET
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH0_DESC_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH0_DESC_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH1_DESC_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH1_DESC_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH2_DESC_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH2_DESC_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH3_DESC_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH3_DESC_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_SET
#define CMIC_DMA_STATr_DMA_RESETf_GET BCM53324_A0_CMIC_DMA_STATr_DMA_RESETf_GET
#define CMIC_DMA_STATr_DMA_RESETf_SET BCM53324_A0_CMIC_DMA_STATr_DMA_RESETf_SET
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET BCM53324_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET BCM53324_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_GET BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_GET
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_SET BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_SET
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET BCM53324_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET BCM53324_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET BCM53324_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET BCM53324_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET BCM53324_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET BCM53324_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET BCM53324_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET BCM53324_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET BCM53324_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_GET BCM53324_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_GET
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_SET BCM53324_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_SET
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_GET BCM53324_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_GET
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_SET BCM53324_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_SET
#define READ_CMIC_DMA_STATr BCM53324_A0_READ_CMIC_DMA_STATr
#define WRITE_CMIC_DMA_STATr BCM53324_A0_WRITE_CMIC_DMA_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_DMA_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_ENDIANESS_SEL
 * BLOCKS:   CMIC
 * DESC:     Endianness selection register (for various CMIC operations)

 * SIZE:     32
 * FIELDS:
 *     BYTELANE0        Each byte lane must carry the same data value,especially the MSB byte and the LSB byte.The various bits in the byte are interpretedas explained below:
 *     BYTELANE1        Byte Lane 1 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE2        Byte Lane 2 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE3        Byte Lane 3 (see BYTELANE0)Each byte lane must carry the same data value.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_ENDIANESS_SELr 0x00000174

#define BCM53324_A0_CMIC_ENDIANESS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_ENDIANESS_SEL.
 *
 */
typedef union BCM53324_A0_CMIC_ENDIANESS_SELr_s {
	uint32_t v[1];
	uint32_t cmic_endianess_sel[1];
	uint32_t _cmic_endianess_sel;
} BCM53324_A0_CMIC_ENDIANESS_SELr_t;

#define BCM53324_A0_CMIC_ENDIANESS_SELr_CLR(r) (r).cmic_endianess_sel[0] = 0
#define BCM53324_A0_CMIC_ENDIANESS_SELr_SET(r,d) (r).cmic_endianess_sel[0] = d
#define BCM53324_A0_CMIC_ENDIANESS_SELr_GET(r) (r).cmic_endianess_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_GET(r) (((r).cmic_endianess_sel[0]) & 0xff)
#define BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_GET(r) ((((r).cmic_endianess_sel[0]) >> 8) & 0xff)
#define BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_GET(r) ((((r).cmic_endianess_sel[0]) >> 16) & 0xff)
#define BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_GET(r) ((((r).cmic_endianess_sel[0]) >> 24) & 0xff)
#define BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_ENDIANESS_SEL.
 *
 */
#define BCM53324_A0_READ_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)
#define BCM53324_A0_WRITE_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_ENDIANESS_SELr BCM53324_A0_CMIC_ENDIANESS_SELr
#define CMIC_ENDIANESS_SELr_SIZE BCM53324_A0_CMIC_ENDIANESS_SELr_SIZE
typedef BCM53324_A0_CMIC_ENDIANESS_SELr_t CMIC_ENDIANESS_SELr_t;
#define CMIC_ENDIANESS_SELr_CLR BCM53324_A0_CMIC_ENDIANESS_SELr_CLR
#define CMIC_ENDIANESS_SELr_SET BCM53324_A0_CMIC_ENDIANESS_SELr_SET
#define CMIC_ENDIANESS_SELr_GET BCM53324_A0_CMIC_ENDIANESS_SELr_GET
#define CMIC_ENDIANESS_SELr_BYTELANE0f_GET BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE0f_SET BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE1f_GET BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE1f_SET BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE2f_GET BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE2f_SET BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE3f_GET BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE3f_SET BCM53324_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_SET
#define READ_CMIC_ENDIANESS_SELr BCM53324_A0_READ_CMIC_ENDIANESS_SELr
#define WRITE_CMIC_ENDIANESS_SELr BCM53324_A0_WRITE_CMIC_ENDIANESS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_ENDIANESS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_I2C_CTRL
 * BLOCKS:   CMIC
 * DESC:     I2C Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     AAAK             When set (1), asserts an ACKNOWLEDGE clock pulse (SDA LOW) on the I2C bus 
 *     INT_FLAG         When set, indicates an interrupt has occurred due to one of the status conditions 
 *     MM_STP           When set, controls entering the Master mode and send a STOP condition on the bus, when it is free. This bit is automatically cleared after the STOP condition has been sent. 
 *     MM_STRT          When set, controls entering the Master mode and send a START condition on the bus, when it is free. This bit is automatically cleared after the START condition has been sent. 
 *     BUS_EN           When set, Enable I2C bus and respond to calls to the slave address and the General Call Address ability. 
 *     INT_EN           When set, enables generation of interrupts.
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_I2C_CTRLr 0x00000128

#define BCM53324_A0_CMIC_I2C_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_CTRL.
 *
 */
typedef union BCM53324_A0_CMIC_I2C_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_ctrl[1];
	uint32_t _cmic_i2c_ctrl;
} BCM53324_A0_CMIC_I2C_CTRLr_t;

#define BCM53324_A0_CMIC_I2C_CTRLr_CLR(r) (r).cmic_i2c_ctrl[0] = 0
#define BCM53324_A0_CMIC_I2C_CTRLr_SET(r,d) (r).cmic_i2c_ctrl[0] = d
#define BCM53324_A0_CMIC_I2C_CTRLr_GET(r) (r).cmic_i2c_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_I2C_CTRLr_RESERVED_1f_GET(r) (((r).cmic_i2c_ctrl[0]) & 0x3)
#define BCM53324_A0_CMIC_I2C_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_CMIC_I2C_CTRLr_AAAKf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_I2C_CTRLr_AAAKf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_I2C_CTRLr_INT_FLAGf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_I2C_CTRLr_INT_FLAGf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_I2C_CTRLr_MM_STPf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_I2C_CTRLr_MM_STPf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_I2C_CTRLr_MM_STRTf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 5) & 0x1)
#define BCM53324_A0_CMIC_I2C_CTRLr_MM_STRTf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CMIC_I2C_CTRLr_BUS_ENf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 6) & 0x1)
#define BCM53324_A0_CMIC_I2C_CTRLr_BUS_ENf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CMIC_I2C_CTRLr_INT_ENf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_I2C_CTRLr_INT_ENf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_I2C_CTRLr_RESERVED_2f_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 8) & 0xffffff)
#define BCM53324_A0_CMIC_I2C_CTRLr_RESERVED_2f_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_CTRL.
 *
 */
#define BCM53324_A0_READ_CMIC_I2C_CTRLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_I2C_CTRLr,r._cmic_i2c_ctrl)
#define BCM53324_A0_WRITE_CMIC_I2C_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_I2C_CTRLr,r._cmic_i2c_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_CTRLr BCM53324_A0_CMIC_I2C_CTRLr
#define CMIC_I2C_CTRLr_SIZE BCM53324_A0_CMIC_I2C_CTRLr_SIZE
typedef BCM53324_A0_CMIC_I2C_CTRLr_t CMIC_I2C_CTRLr_t;
#define CMIC_I2C_CTRLr_CLR BCM53324_A0_CMIC_I2C_CTRLr_CLR
#define CMIC_I2C_CTRLr_SET BCM53324_A0_CMIC_I2C_CTRLr_SET
#define CMIC_I2C_CTRLr_GET BCM53324_A0_CMIC_I2C_CTRLr_GET
#define CMIC_I2C_CTRLr_RESERVED_1f_GET BCM53324_A0_CMIC_I2C_CTRLr_RESERVED_1f_GET
#define CMIC_I2C_CTRLr_RESERVED_1f_SET BCM53324_A0_CMIC_I2C_CTRLr_RESERVED_1f_SET
#define CMIC_I2C_CTRLr_AAAKf_GET BCM53324_A0_CMIC_I2C_CTRLr_AAAKf_GET
#define CMIC_I2C_CTRLr_AAAKf_SET BCM53324_A0_CMIC_I2C_CTRLr_AAAKf_SET
#define CMIC_I2C_CTRLr_INT_FLAGf_GET BCM53324_A0_CMIC_I2C_CTRLr_INT_FLAGf_GET
#define CMIC_I2C_CTRLr_INT_FLAGf_SET BCM53324_A0_CMIC_I2C_CTRLr_INT_FLAGf_SET
#define CMIC_I2C_CTRLr_MM_STPf_GET BCM53324_A0_CMIC_I2C_CTRLr_MM_STPf_GET
#define CMIC_I2C_CTRLr_MM_STPf_SET BCM53324_A0_CMIC_I2C_CTRLr_MM_STPf_SET
#define CMIC_I2C_CTRLr_MM_STRTf_GET BCM53324_A0_CMIC_I2C_CTRLr_MM_STRTf_GET
#define CMIC_I2C_CTRLr_MM_STRTf_SET BCM53324_A0_CMIC_I2C_CTRLr_MM_STRTf_SET
#define CMIC_I2C_CTRLr_BUS_ENf_GET BCM53324_A0_CMIC_I2C_CTRLr_BUS_ENf_GET
#define CMIC_I2C_CTRLr_BUS_ENf_SET BCM53324_A0_CMIC_I2C_CTRLr_BUS_ENf_SET
#define CMIC_I2C_CTRLr_INT_ENf_GET BCM53324_A0_CMIC_I2C_CTRLr_INT_ENf_GET
#define CMIC_I2C_CTRLr_INT_ENf_SET BCM53324_A0_CMIC_I2C_CTRLr_INT_ENf_SET
#define CMIC_I2C_CTRLr_RESERVED_2f_GET BCM53324_A0_CMIC_I2C_CTRLr_RESERVED_2f_GET
#define CMIC_I2C_CTRLr_RESERVED_2f_SET BCM53324_A0_CMIC_I2C_CTRLr_RESERVED_2f_SET
#define READ_CMIC_I2C_CTRLr BCM53324_A0_READ_CMIC_I2C_CTRLr
#define WRITE_CMIC_I2C_CTRLr BCM53324_A0_WRITE_CMIC_I2C_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_I2C_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_I2C_DATA
 * BLOCKS:   CMIC
 * DESC:     I2C Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             Data that is read from or written to the I2C interface.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_I2C_DATAr 0x00000124

#define BCM53324_A0_CMIC_I2C_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_DATA.
 *
 */
typedef union BCM53324_A0_CMIC_I2C_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_data[1];
	uint32_t _cmic_i2c_data;
} BCM53324_A0_CMIC_I2C_DATAr_t;

#define BCM53324_A0_CMIC_I2C_DATAr_CLR(r) (r).cmic_i2c_data[0] = 0
#define BCM53324_A0_CMIC_I2C_DATAr_SET(r,d) (r).cmic_i2c_data[0] = d
#define BCM53324_A0_CMIC_I2C_DATAr_GET(r) (r).cmic_i2c_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_I2C_DATAr_DATAf_GET(r) (((r).cmic_i2c_data[0]) & 0xff)
#define BCM53324_A0_CMIC_I2C_DATAr_DATAf_SET(r,f) (r).cmic_i2c_data[0]=(((r).cmic_i2c_data[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_I2C_DATAr_RESERVED_1f_GET(r) ((((r).cmic_i2c_data[0]) >> 8) & 0xffffff)
#define BCM53324_A0_CMIC_I2C_DATAr_RESERVED_1f_SET(r,f) (r).cmic_i2c_data[0]=(((r).cmic_i2c_data[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_DATA.
 *
 */
#define BCM53324_A0_READ_CMIC_I2C_DATAr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_I2C_DATAr,r._cmic_i2c_data)
#define BCM53324_A0_WRITE_CMIC_I2C_DATAr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_I2C_DATAr,r._cmic_i2c_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_DATAr BCM53324_A0_CMIC_I2C_DATAr
#define CMIC_I2C_DATAr_SIZE BCM53324_A0_CMIC_I2C_DATAr_SIZE
typedef BCM53324_A0_CMIC_I2C_DATAr_t CMIC_I2C_DATAr_t;
#define CMIC_I2C_DATAr_CLR BCM53324_A0_CMIC_I2C_DATAr_CLR
#define CMIC_I2C_DATAr_SET BCM53324_A0_CMIC_I2C_DATAr_SET
#define CMIC_I2C_DATAr_GET BCM53324_A0_CMIC_I2C_DATAr_GET
#define CMIC_I2C_DATAr_DATAf_GET BCM53324_A0_CMIC_I2C_DATAr_DATAf_GET
#define CMIC_I2C_DATAr_DATAf_SET BCM53324_A0_CMIC_I2C_DATAr_DATAf_SET
#define CMIC_I2C_DATAr_RESERVED_1f_GET BCM53324_A0_CMIC_I2C_DATAr_RESERVED_1f_GET
#define CMIC_I2C_DATAr_RESERVED_1f_SET BCM53324_A0_CMIC_I2C_DATAr_RESERVED_1f_SET
#define READ_CMIC_I2C_DATAr BCM53324_A0_READ_CMIC_I2C_DATAr
#define WRITE_CMIC_I2C_DATAr BCM53324_A0_WRITE_CMIC_I2C_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_I2C_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_I2C_RESET
 * BLOCKS:   CMIC
 * DESC:     I2C Soft Reset Register
 * SIZE:     32
 * FIELDS:
 *     RESET            A write operation to this register with any data will perform a soft reset to the I2C interface.  The bus is set to idle state and the MM_STOP, MM_STRT and INT_FLAG in the I2C Status and Control Register are set to 0. 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_I2C_RESETr 0x0000013c

#define BCM53324_A0_CMIC_I2C_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_RESET.
 *
 */
typedef union BCM53324_A0_CMIC_I2C_RESETr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_reset[1];
	uint32_t _cmic_i2c_reset;
} BCM53324_A0_CMIC_I2C_RESETr_t;

#define BCM53324_A0_CMIC_I2C_RESETr_CLR(r) (r).cmic_i2c_reset[0] = 0
#define BCM53324_A0_CMIC_I2C_RESETr_SET(r,d) (r).cmic_i2c_reset[0] = d
#define BCM53324_A0_CMIC_I2C_RESETr_GET(r) (r).cmic_i2c_reset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_I2C_RESETr_RESETf_GET(r) (((r).cmic_i2c_reset[0]) & 0xff)
#define BCM53324_A0_CMIC_I2C_RESETr_RESETf_SET(r,f) (r).cmic_i2c_reset[0]=(((r).cmic_i2c_reset[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_I2C_RESETr_RESERVED_1f_GET(r) ((((r).cmic_i2c_reset[0]) >> 8) & 0xffffff)
#define BCM53324_A0_CMIC_I2C_RESETr_RESERVED_1f_SET(r,f) (r).cmic_i2c_reset[0]=(((r).cmic_i2c_reset[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_RESET.
 *
 */
#define BCM53324_A0_READ_CMIC_I2C_RESETr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_I2C_RESETr,r._cmic_i2c_reset)
#define BCM53324_A0_WRITE_CMIC_I2C_RESETr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_I2C_RESETr,r._cmic_i2c_reset)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_RESETr BCM53324_A0_CMIC_I2C_RESETr
#define CMIC_I2C_RESETr_SIZE BCM53324_A0_CMIC_I2C_RESETr_SIZE
typedef BCM53324_A0_CMIC_I2C_RESETr_t CMIC_I2C_RESETr_t;
#define CMIC_I2C_RESETr_CLR BCM53324_A0_CMIC_I2C_RESETr_CLR
#define CMIC_I2C_RESETr_SET BCM53324_A0_CMIC_I2C_RESETr_SET
#define CMIC_I2C_RESETr_GET BCM53324_A0_CMIC_I2C_RESETr_GET
#define CMIC_I2C_RESETr_RESETf_GET BCM53324_A0_CMIC_I2C_RESETr_RESETf_GET
#define CMIC_I2C_RESETr_RESETf_SET BCM53324_A0_CMIC_I2C_RESETr_RESETf_SET
#define CMIC_I2C_RESETr_RESERVED_1f_GET BCM53324_A0_CMIC_I2C_RESETr_RESERVED_1f_GET
#define CMIC_I2C_RESETr_RESERVED_1f_SET BCM53324_A0_CMIC_I2C_RESETr_RESERVED_1f_SET
#define READ_CMIC_I2C_RESETr BCM53324_A0_READ_CMIC_I2C_RESETr
#define WRITE_CMIC_I2C_RESETr BCM53324_A0_WRITE_CMIC_I2C_RESETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_I2C_RESETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_I2C_SLAVE_ADDR
 * BLOCKS:   CMIC
 * DESC:     I2C Slave Address Register
 * SIZE:     32
 * FIELDS:
 *     GEN_CALL_EN      Controls recognition of the General Call Address of 00H.0 = Disable General Call Address recognition1 = Enable General Call Address recognition
 *     ADDR             I2C SLAVE Address 6:0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr 0x00000120

#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_SLAVE_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_slave_addr[1];
	uint32_t _cmic_i2c_slave_addr;
} BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_t;

#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_CLR(r) (r).cmic_i2c_slave_addr[0] = 0
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_SET(r,d) (r).cmic_i2c_slave_addr[0] = d
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_GET(r) (r).cmic_i2c_slave_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET(r) (((r).cmic_i2c_slave_addr[0]) & 0x1)
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_GET(r) ((((r).cmic_i2c_slave_addr[0]) >> 1) & 0x7f)
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET(r) ((((r).cmic_i2c_slave_addr[0]) >> 8) & 0xffffff)
#define BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_SLAVE_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_I2C_SLAVE_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_I2C_SLAVE_ADDRr,r._cmic_i2c_slave_addr)
#define BCM53324_A0_WRITE_CMIC_I2C_SLAVE_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_I2C_SLAVE_ADDRr,r._cmic_i2c_slave_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_SLAVE_ADDRr BCM53324_A0_CMIC_I2C_SLAVE_ADDRr
#define CMIC_I2C_SLAVE_ADDRr_SIZE BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_SIZE
typedef BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_t CMIC_I2C_SLAVE_ADDRr_t;
#define CMIC_I2C_SLAVE_ADDRr_CLR BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_CLR
#define CMIC_I2C_SLAVE_ADDRr_SET BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_SET
#define CMIC_I2C_SLAVE_ADDRr_GET BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_GET
#define CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET
#define CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET
#define CMIC_I2C_SLAVE_ADDRr_ADDRf_GET BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_GET
#define CMIC_I2C_SLAVE_ADDRr_ADDRf_SET BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_SET
#define CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET
#define CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET BCM53324_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET
#define READ_CMIC_I2C_SLAVE_ADDRr BCM53324_A0_READ_CMIC_I2C_SLAVE_ADDRr
#define WRITE_CMIC_I2C_SLAVE_ADDRr BCM53324_A0_WRITE_CMIC_I2C_SLAVE_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_I2C_SLAVE_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_I2C_SLAVE_XADDR
 * BLOCKS:   CMIC
 * DESC:     I2C Slave Extended Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Slave address 7-0 for the extended slave addressing mode.  When the address received starts with F7-F0H, the two LSBs are recognized as slave address 9-8 and the content of this register are used as address 7-0 to form the 10-bit address used in extended addressing mode. 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr 0x00000130

#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_SLAVE_XADDR.
 *
 */
typedef union BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_slave_xaddr[1];
	uint32_t _cmic_i2c_slave_xaddr;
} BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_t;

#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_CLR(r) (r).cmic_i2c_slave_xaddr[0] = 0
#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_SET(r,d) (r).cmic_i2c_slave_xaddr[0] = d
#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_GET(r) (r).cmic_i2c_slave_xaddr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_GET(r) (((r).cmic_i2c_slave_xaddr[0]) & 0xff)
#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_SET(r,f) (r).cmic_i2c_slave_xaddr[0]=(((r).cmic_i2c_slave_xaddr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET(r) ((((r).cmic_i2c_slave_xaddr[0]) >> 8) & 0xffffff)
#define BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET(r,f) (r).cmic_i2c_slave_xaddr[0]=(((r).cmic_i2c_slave_xaddr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_SLAVE_XADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_I2C_SLAVE_XADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_I2C_SLAVE_XADDRr,r._cmic_i2c_slave_xaddr)
#define BCM53324_A0_WRITE_CMIC_I2C_SLAVE_XADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_I2C_SLAVE_XADDRr,r._cmic_i2c_slave_xaddr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_SLAVE_XADDRr BCM53324_A0_CMIC_I2C_SLAVE_XADDRr
#define CMIC_I2C_SLAVE_XADDRr_SIZE BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_SIZE
typedef BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_t CMIC_I2C_SLAVE_XADDRr_t;
#define CMIC_I2C_SLAVE_XADDRr_CLR BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_CLR
#define CMIC_I2C_SLAVE_XADDRr_SET BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_SET
#define CMIC_I2C_SLAVE_XADDRr_GET BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_GET
#define CMIC_I2C_SLAVE_XADDRr_ADDRf_GET BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_GET
#define CMIC_I2C_SLAVE_XADDRr_ADDRf_SET BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_SET
#define CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET
#define CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET BCM53324_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET
#define READ_CMIC_I2C_SLAVE_XADDRr BCM53324_A0_READ_CMIC_I2C_SLAVE_XADDRr
#define WRITE_CMIC_I2C_SLAVE_XADDRr BCM53324_A0_WRITE_CMIC_I2C_SLAVE_XADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_I2C_SLAVE_XADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_I2C_STAT
 * BLOCKS:   CMIC
 * DESC:     I2C Condition Status Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     COND             Five bit condition codes defined as follows: I2C Status Register
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_I2C_STATr 0x0000012c

#define BCM53324_A0_CMIC_I2C_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_STAT.
 *
 */
typedef union BCM53324_A0_CMIC_I2C_STATr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_stat[1];
	uint32_t _cmic_i2c_stat;
} BCM53324_A0_CMIC_I2C_STATr_t;

#define BCM53324_A0_CMIC_I2C_STATr_CLR(r) (r).cmic_i2c_stat[0] = 0
#define BCM53324_A0_CMIC_I2C_STATr_SET(r,d) (r).cmic_i2c_stat[0] = d
#define BCM53324_A0_CMIC_I2C_STATr_GET(r) (r).cmic_i2c_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_I2C_STATr_RESERVED_1f_GET(r) (((r).cmic_i2c_stat[0]) & 0x7)
#define BCM53324_A0_CMIC_I2C_STATr_RESERVED_1f_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_CMIC_I2C_STATr_CONDf_GET(r) ((((r).cmic_i2c_stat[0]) >> 3) & 0x1f)
#define BCM53324_A0_CMIC_I2C_STATr_CONDf_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM53324_A0_CMIC_I2C_STATr_RESERVED_2f_GET(r) ((((r).cmic_i2c_stat[0]) >> 8) & 0xffffff)
#define BCM53324_A0_CMIC_I2C_STATr_RESERVED_2f_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_STAT.
 *
 */
#define BCM53324_A0_READ_CMIC_I2C_STATr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_I2C_STATr,r._cmic_i2c_stat)
#define BCM53324_A0_WRITE_CMIC_I2C_STATr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_I2C_STATr,r._cmic_i2c_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_STATr BCM53324_A0_CMIC_I2C_STATr
#define CMIC_I2C_STATr_SIZE BCM53324_A0_CMIC_I2C_STATr_SIZE
typedef BCM53324_A0_CMIC_I2C_STATr_t CMIC_I2C_STATr_t;
#define CMIC_I2C_STATr_CLR BCM53324_A0_CMIC_I2C_STATr_CLR
#define CMIC_I2C_STATr_SET BCM53324_A0_CMIC_I2C_STATr_SET
#define CMIC_I2C_STATr_GET BCM53324_A0_CMIC_I2C_STATr_GET
#define CMIC_I2C_STATr_RESERVED_1f_GET BCM53324_A0_CMIC_I2C_STATr_RESERVED_1f_GET
#define CMIC_I2C_STATr_RESERVED_1f_SET BCM53324_A0_CMIC_I2C_STATr_RESERVED_1f_SET
#define CMIC_I2C_STATr_CONDf_GET BCM53324_A0_CMIC_I2C_STATr_CONDf_GET
#define CMIC_I2C_STATr_CONDf_SET BCM53324_A0_CMIC_I2C_STATr_CONDf_SET
#define CMIC_I2C_STATr_RESERVED_2f_GET BCM53324_A0_CMIC_I2C_STATr_RESERVED_2f_GET
#define CMIC_I2C_STATr_RESERVED_2f_SET BCM53324_A0_CMIC_I2C_STATr_RESERVED_2f_SET
#define READ_CMIC_I2C_STATr BCM53324_A0_READ_CMIC_I2C_STATr
#define WRITE_CMIC_I2C_STATr BCM53324_A0_WRITE_CMIC_I2C_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_I2C_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_INTR_WAIT_CYCLES
 * BLOCKS:   CMIC
 * DESC:     CMIC INTR WAIT CYCLES
 * SIZE:     32
 * FIELDS:
 *     INTR_WAIT_CYCLES When ever fatal interruptis detected, CMIC will wait for number of clocks mentioned in this register and will set cmic_to_top_fatal_intr port. rst_fsm may reboot again once this port is active. cmic_to_top_fatal_intr will never be active If this register value is 0. 
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_INTR_WAIT_CYCLESr 0x00000d48

#define BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_INTR_WAIT_CYCLES.
 *
 */
typedef union BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_s {
	uint32_t v[1];
	uint32_t cmic_intr_wait_cycles[1];
	uint32_t _cmic_intr_wait_cycles;
} BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_t;

#define BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_CLR(r) (r).cmic_intr_wait_cycles[0] = 0
#define BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_SET(r,d) (r).cmic_intr_wait_cycles[0] = d
#define BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_GET(r) (r).cmic_intr_wait_cycles[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_INTR_WAIT_CYCLESf_GET(r) ((r).cmic_intr_wait_cycles[0])
#define BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_INTR_WAIT_CYCLESf_SET(r,f) (r).cmic_intr_wait_cycles[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_INTR_WAIT_CYCLES.
 *
 */
#define BCM53324_A0_READ_CMIC_INTR_WAIT_CYCLESr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_INTR_WAIT_CYCLESr,r._cmic_intr_wait_cycles)
#define BCM53324_A0_WRITE_CMIC_INTR_WAIT_CYCLESr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_INTR_WAIT_CYCLESr,r._cmic_intr_wait_cycles)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_INTR_WAIT_CYCLESr BCM53324_A0_CMIC_INTR_WAIT_CYCLESr
#define CMIC_INTR_WAIT_CYCLESr_SIZE BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_SIZE
typedef BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_t CMIC_INTR_WAIT_CYCLESr_t;
#define CMIC_INTR_WAIT_CYCLESr_CLR BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_CLR
#define CMIC_INTR_WAIT_CYCLESr_SET BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_SET
#define CMIC_INTR_WAIT_CYCLESr_GET BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_GET
#define CMIC_INTR_WAIT_CYCLESr_INTR_WAIT_CYCLESf_GET BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_INTR_WAIT_CYCLESf_GET
#define CMIC_INTR_WAIT_CYCLESr_INTR_WAIT_CYCLESf_SET BCM53324_A0_CMIC_INTR_WAIT_CYCLESr_INTR_WAIT_CYCLESf_SET
#define READ_CMIC_INTR_WAIT_CYCLESr BCM53324_A0_READ_CMIC_INTR_WAIT_CYCLESr
#define WRITE_CMIC_INTR_WAIT_CYCLESr BCM53324_A0_WRITE_CMIC_INTR_WAIT_CYCLESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_INTR_WAIT_CYCLESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_IRQ_MASK
 * BLOCKS:   CMIC
 * DESC:     Interrupt Mask Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Mask
 *     RESERVED_1       Reserved
 *     RX_PAUSE_STAT_MOD tx PAUSE Status Change Mask
 *     TX_PAUSE_STAT_MOD tx PAUSE Status Change Mask
 *     LINK_STAT_MOD    Link Status Change Mask
 *     L2_MOD_FIFO_NOT_EMPTY L2 MOD Fifo is full
 *     EP_TO_CMIC_INTR  EP_TO_CMIC_INTR
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Mask
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Mask
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Mask
 *     CH1_CHAIN_DONE   DMA CH1 ENd Of Chain Mask
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Mask
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Mask
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Mask
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Mask
 *     PCI_PARITY_ERR   PCI Bus Parity Error Mask
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Mask
 *     SCHAN_ERR        SCH Bus Error Mask
 *     I2C_INTR         I2C Mask
 *     MIIM_OP_DONE     MIIM Operation Complete Mask
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Mask
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed
 *     TABLE_DMA_COMPLETE Table DMA operation complete Mask
 *     SLAM_DMA_COMPLETE Slam DMA operation complete Mask
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_IRQ_MASKr 0x00000148

#define BCM53324_A0_CMIC_IRQ_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_MASK.
 *
 */
typedef union BCM53324_A0_CMIC_IRQ_MASKr_s {
	uint32_t v[1];
	uint32_t cmic_irq_mask[1];
	uint32_t _cmic_irq_mask;
} BCM53324_A0_CMIC_IRQ_MASKr_t;

#define BCM53324_A0_CMIC_IRQ_MASKr_CLR(r) (r).cmic_irq_mask[0] = 0
#define BCM53324_A0_CMIC_IRQ_MASKr_SET(r,d) (r).cmic_irq_mask[0] = d
#define BCM53324_A0_CMIC_IRQ_MASKr_GET(r) (r).cmic_irq_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_mask[0]) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_IRQ_MASKr_RESERVED_1f_GET(r) ((((r).cmic_irq_mask[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_RESERVED_1f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_IRQ_MASKr_RX_PAUSE_STAT_MODf_GET(r) ((((r).cmic_irq_mask[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_RX_PAUSE_STAT_MODf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_IRQ_MASKr_TX_PAUSE_STAT_MODf_GET(r) ((((r).cmic_irq_mask[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_TX_PAUSE_STAT_MODf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_mask[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET(r) ((((r).cmic_irq_mask[0]) >> 5) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CMIC_IRQ_MASKr_EP_TO_CMIC_INTRf_GET(r) ((((r).cmic_irq_mask[0]) >> 6) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_EP_TO_CMIC_INTRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 10) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 11) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 12) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 14) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 15) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 16) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 17) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_CMIC_IRQ_MASKr_I2C_INTRf_GET(r) ((((r).cmic_irq_mask[0]) >> 18) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_I2C_INTRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 19) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 20) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_CMIC_IRQ_MASKr_RESERVED_3f_GET(r) ((((r).cmic_irq_mask[0]) >> 21) & 0xf)
#define BCM53324_A0_CMIC_IRQ_MASKr_RESERVED_3f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM53324_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 25) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 26) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 27) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_CMIC_IRQ_MASKr_MEM_FAILf_GET(r) ((((r).cmic_irq_mask[0]) >> 28) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_MEM_FAILf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53324_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 29) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 30) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 31) & 0x1)
#define BCM53324_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_MASK.
 *
 */
#define BCM53324_A0_READ_CMIC_IRQ_MASKr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_IRQ_MASKr,r._cmic_irq_mask)
#define BCM53324_A0_WRITE_CMIC_IRQ_MASKr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_IRQ_MASKr,r._cmic_irq_mask)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_IRQ_MASKr BCM53324_A0_CMIC_IRQ_MASKr
#define CMIC_IRQ_MASKr_SIZE BCM53324_A0_CMIC_IRQ_MASKr_SIZE
typedef BCM53324_A0_CMIC_IRQ_MASKr_t CMIC_IRQ_MASKr_t;
#define CMIC_IRQ_MASKr_CLR BCM53324_A0_CMIC_IRQ_MASKr_CLR
#define CMIC_IRQ_MASKr_SET BCM53324_A0_CMIC_IRQ_MASKr_SET
#define CMIC_IRQ_MASKr_GET BCM53324_A0_CMIC_IRQ_MASKr_GET
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET
#define CMIC_IRQ_MASKr_RESERVED_1f_GET BCM53324_A0_CMIC_IRQ_MASKr_RESERVED_1f_GET
#define CMIC_IRQ_MASKr_RESERVED_1f_SET BCM53324_A0_CMIC_IRQ_MASKr_RESERVED_1f_SET
#define CMIC_IRQ_MASKr_RX_PAUSE_STAT_MODf_GET BCM53324_A0_CMIC_IRQ_MASKr_RX_PAUSE_STAT_MODf_GET
#define CMIC_IRQ_MASKr_RX_PAUSE_STAT_MODf_SET BCM53324_A0_CMIC_IRQ_MASKr_RX_PAUSE_STAT_MODf_SET
#define CMIC_IRQ_MASKr_TX_PAUSE_STAT_MODf_GET BCM53324_A0_CMIC_IRQ_MASKr_TX_PAUSE_STAT_MODf_GET
#define CMIC_IRQ_MASKr_TX_PAUSE_STAT_MODf_SET BCM53324_A0_CMIC_IRQ_MASKr_TX_PAUSE_STAT_MODf_SET
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_GET BCM53324_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_GET
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_SET BCM53324_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_SET
#define CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET BCM53324_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_GET
#define CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET BCM53324_A0_CMIC_IRQ_MASKr_L2_MOD_FIFO_NOT_EMPTYf_SET
#define CMIC_IRQ_MASKr_EP_TO_CMIC_INTRf_GET BCM53324_A0_CMIC_IRQ_MASKr_EP_TO_CMIC_INTRf_GET
#define CMIC_IRQ_MASKr_EP_TO_CMIC_INTRf_SET BCM53324_A0_CMIC_IRQ_MASKr_EP_TO_CMIC_INTRf_SET
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET BCM53324_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET BCM53324_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET BCM53324_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET BCM53324_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET
#define CMIC_IRQ_MASKr_SCHAN_ERRf_GET BCM53324_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_GET
#define CMIC_IRQ_MASKr_SCHAN_ERRf_SET BCM53324_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_SET
#define CMIC_IRQ_MASKr_I2C_INTRf_GET BCM53324_A0_CMIC_IRQ_MASKr_I2C_INTRf_GET
#define CMIC_IRQ_MASKr_I2C_INTRf_SET BCM53324_A0_CMIC_IRQ_MASKr_I2C_INTRf_SET
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET
#define CMIC_IRQ_MASKr_RESERVED_3f_GET BCM53324_A0_CMIC_IRQ_MASKr_RESERVED_3f_GET
#define CMIC_IRQ_MASKr_RESERVED_3f_SET BCM53324_A0_CMIC_IRQ_MASKr_RESERVED_3f_SET
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_MEM_FAILf_GET BCM53324_A0_CMIC_IRQ_MASKr_MEM_FAILf_GET
#define CMIC_IRQ_MASKr_MEM_FAILf_SET BCM53324_A0_CMIC_IRQ_MASKr_MEM_FAILf_SET
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET BCM53324_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET BCM53324_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET BCM53324_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET BCM53324_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET BCM53324_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET BCM53324_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET
#define READ_CMIC_IRQ_MASKr BCM53324_A0_READ_CMIC_IRQ_MASKr
#define WRITE_CMIC_IRQ_MASKr BCM53324_A0_WRITE_CMIC_IRQ_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_IRQ_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_IRQ_STAT
 * BLOCKS:   CMIC
 * DESC:     Interrupt Status Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Interrupt
 *     RESERVED_1       Reserved
 *     RX_PAUSE_STAT_MOD RX_PAUSE Status Change Interrupt
 *     TX_PAUSE_STAT_MOD tx_PAUSE Status Change Interrupt
 *     LINK_STAT_MOD    Link Status Change Interrupt
 *     L2_MOD_FIFO_NOT_EMPTY L2 MOD Fifo is full
 *     RESERVED_2       Reserved
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Interrupt
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Interrupt
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Interrupt
 *     CH1_CHAIN_DONE   DMA CH1 End Of Chain Interrupt
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Interrupt
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Interrupt
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Interrupt
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Interrupt
 *     PCI_PARITY_ERR   PCI Bus Parity Error Interrupt
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Interrupt
 *     SCHAN_ERR        SCH Bus Error Interrupt
 *     I2C_INTR         I2C Interrupt
 *     MIIM_OP_DONE     MIIM Operation Complete Interrupt
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Interrupt
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed or a parity error was seen in an Ingress Pipe table.
 *     TABLE_DMA_COMPLETE Table DMA operation complete
 *     SLAM_DMA_COMPLETE Slam DMA operation complete
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_IRQ_STATr 0x00000144

#define BCM53324_A0_CMIC_IRQ_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_STAT.
 *
 */
typedef union BCM53324_A0_CMIC_IRQ_STATr_s {
	uint32_t v[1];
	uint32_t cmic_irq_stat[1];
	uint32_t _cmic_irq_stat;
} BCM53324_A0_CMIC_IRQ_STATr_t;

#define BCM53324_A0_CMIC_IRQ_STATr_CLR(r) (r).cmic_irq_stat[0] = 0
#define BCM53324_A0_CMIC_IRQ_STATr_SET(r,d) (r).cmic_irq_stat[0] = d
#define BCM53324_A0_CMIC_IRQ_STATr_GET(r) (r).cmic_irq_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_stat[0]) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_IRQ_STATr_RESERVED_1f_GET(r) ((((r).cmic_irq_stat[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_RESERVED_1f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_IRQ_STATr_RX_PAUSE_STAT_MODf_GET(r) ((((r).cmic_irq_stat[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_RX_PAUSE_STAT_MODf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_IRQ_STATr_TX_PAUSE_STAT_MODf_GET(r) ((((r).cmic_irq_stat[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_TX_PAUSE_STAT_MODf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_stat[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET(r) ((((r).cmic_irq_stat[0]) >> 5) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CMIC_IRQ_STATr_RESERVED_2f_GET(r) ((((r).cmic_irq_stat[0]) >> 6) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_RESERVED_2f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 10) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 11) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 12) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 14) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 15) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 16) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_CMIC_IRQ_STATr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 17) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_CMIC_IRQ_STATr_I2C_INTRf_GET(r) ((((r).cmic_irq_stat[0]) >> 18) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_I2C_INTRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 19) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 20) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_CMIC_IRQ_STATr_RESERVED_3f_GET(r) ((((r).cmic_irq_stat[0]) >> 21) & 0xf)
#define BCM53324_A0_CMIC_IRQ_STATr_RESERVED_3f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM53324_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 25) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 26) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 27) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_CMIC_IRQ_STATr_MEM_FAILf_GET(r) ((((r).cmic_irq_stat[0]) >> 28) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_MEM_FAILf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53324_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 29) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 30) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 31) & 0x1)
#define BCM53324_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_STAT.
 *
 */
#define BCM53324_A0_READ_CMIC_IRQ_STATr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_IRQ_STATr,r._cmic_irq_stat)
#define BCM53324_A0_WRITE_CMIC_IRQ_STATr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_IRQ_STATr,r._cmic_irq_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_IRQ_STATr BCM53324_A0_CMIC_IRQ_STATr
#define CMIC_IRQ_STATr_SIZE BCM53324_A0_CMIC_IRQ_STATr_SIZE
typedef BCM53324_A0_CMIC_IRQ_STATr_t CMIC_IRQ_STATr_t;
#define CMIC_IRQ_STATr_CLR BCM53324_A0_CMIC_IRQ_STATr_CLR
#define CMIC_IRQ_STATr_SET BCM53324_A0_CMIC_IRQ_STATr_SET
#define CMIC_IRQ_STATr_GET BCM53324_A0_CMIC_IRQ_STATr_GET
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_GET
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_SET
#define CMIC_IRQ_STATr_RESERVED_1f_GET BCM53324_A0_CMIC_IRQ_STATr_RESERVED_1f_GET
#define CMIC_IRQ_STATr_RESERVED_1f_SET BCM53324_A0_CMIC_IRQ_STATr_RESERVED_1f_SET
#define CMIC_IRQ_STATr_RX_PAUSE_STAT_MODf_GET BCM53324_A0_CMIC_IRQ_STATr_RX_PAUSE_STAT_MODf_GET
#define CMIC_IRQ_STATr_RX_PAUSE_STAT_MODf_SET BCM53324_A0_CMIC_IRQ_STATr_RX_PAUSE_STAT_MODf_SET
#define CMIC_IRQ_STATr_TX_PAUSE_STAT_MODf_GET BCM53324_A0_CMIC_IRQ_STATr_TX_PAUSE_STAT_MODf_GET
#define CMIC_IRQ_STATr_TX_PAUSE_STAT_MODf_SET BCM53324_A0_CMIC_IRQ_STATr_TX_PAUSE_STAT_MODf_SET
#define CMIC_IRQ_STATr_LINK_STAT_MODf_GET BCM53324_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_GET
#define CMIC_IRQ_STATr_LINK_STAT_MODf_SET BCM53324_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_SET
#define CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET BCM53324_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_GET
#define CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET BCM53324_A0_CMIC_IRQ_STATr_L2_MOD_FIFO_NOT_EMPTYf_SET
#define CMIC_IRQ_STATr_RESERVED_2f_GET BCM53324_A0_CMIC_IRQ_STATr_RESERVED_2f_GET
#define CMIC_IRQ_STATr_RESERVED_2f_SET BCM53324_A0_CMIC_IRQ_STATr_RESERVED_2f_SET
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET BCM53324_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET BCM53324_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET BCM53324_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET BCM53324_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET
#define CMIC_IRQ_STATr_SCHAN_ERRf_GET BCM53324_A0_CMIC_IRQ_STATr_SCHAN_ERRf_GET
#define CMIC_IRQ_STATr_SCHAN_ERRf_SET BCM53324_A0_CMIC_IRQ_STATr_SCHAN_ERRf_SET
#define CMIC_IRQ_STATr_I2C_INTRf_GET BCM53324_A0_CMIC_IRQ_STATr_I2C_INTRf_GET
#define CMIC_IRQ_STATr_I2C_INTRf_SET BCM53324_A0_CMIC_IRQ_STATr_I2C_INTRf_SET
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_GET
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_SET
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_GET
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_SET
#define CMIC_IRQ_STATr_RESERVED_3f_GET BCM53324_A0_CMIC_IRQ_STATr_RESERVED_3f_GET
#define CMIC_IRQ_STATr_RESERVED_3f_SET BCM53324_A0_CMIC_IRQ_STATr_RESERVED_3f_SET
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_MEM_FAILf_GET BCM53324_A0_CMIC_IRQ_STATr_MEM_FAILf_GET
#define CMIC_IRQ_STATr_MEM_FAILf_SET BCM53324_A0_CMIC_IRQ_STATr_MEM_FAILf_SET
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET BCM53324_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET BCM53324_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET BCM53324_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET BCM53324_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET BCM53324_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET BCM53324_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET
#define READ_CMIC_IRQ_STATr BCM53324_A0_READ_CMIC_IRQ_STATr
#define WRITE_CMIC_IRQ_STATr BCM53324_A0_WRITE_CMIC_IRQ_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_IRQ_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LEDUP_CTRL
 * BLOCKS:   CMIC
 * DESC:     LEDUP Control
 * SIZE:     32
 * FIELDS:
 *     LEDUP_EN         LEDUP Enable.
 *     LEDUP_SCAN_INTRA_PORT_DELAY Delay between the scan-in data for two consecutive ports (in core clock cycles)
 *     LEDUP_SCAN_START_DELAY Delay between the scan-in data for the time refresh starts to the first bit of scan-in data
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LEDUP_CTRLr 0x00001000

#define BCM53324_A0_CMIC_LEDUP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_CTRL.
 *
 */
typedef union BCM53324_A0_CMIC_LEDUP_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_ctrl[1];
	uint32_t _cmic_ledup_ctrl;
} BCM53324_A0_CMIC_LEDUP_CTRLr_t;

#define BCM53324_A0_CMIC_LEDUP_CTRLr_CLR(r) (r).cmic_ledup_ctrl[0] = 0
#define BCM53324_A0_CMIC_LEDUP_CTRLr_SET(r,d) (r).cmic_ledup_ctrl[0] = d
#define BCM53324_A0_CMIC_LEDUP_CTRLr_GET(r) (r).cmic_ledup_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_GET(r) (((r).cmic_ledup_ctrl[0]) & 0x1)
#define BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_SCAN_INTRA_PORT_DELAYf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 1) & 0x7)
#define BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_SCAN_INTRA_PORT_DELAYf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_SCAN_START_DELAYf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_SCAN_START_DELAYf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access CMIC_LEDUP_CTRL.
 *
 */
#define BCM53324_A0_READ_CMIC_LEDUP_CTRLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LEDUP_CTRLr,r._cmic_ledup_ctrl)
#define BCM53324_A0_WRITE_CMIC_LEDUP_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LEDUP_CTRLr,r._cmic_ledup_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_CTRLr BCM53324_A0_CMIC_LEDUP_CTRLr
#define CMIC_LEDUP_CTRLr_SIZE BCM53324_A0_CMIC_LEDUP_CTRLr_SIZE
typedef BCM53324_A0_CMIC_LEDUP_CTRLr_t CMIC_LEDUP_CTRLr_t;
#define CMIC_LEDUP_CTRLr_CLR BCM53324_A0_CMIC_LEDUP_CTRLr_CLR
#define CMIC_LEDUP_CTRLr_SET BCM53324_A0_CMIC_LEDUP_CTRLr_SET
#define CMIC_LEDUP_CTRLr_GET BCM53324_A0_CMIC_LEDUP_CTRLr_GET
#define CMIC_LEDUP_CTRLr_LEDUP_ENf_GET BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_ENf_SET BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SCAN_INTRA_PORT_DELAYf_GET BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_SCAN_INTRA_PORT_DELAYf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SCAN_INTRA_PORT_DELAYf_SET BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_SCAN_INTRA_PORT_DELAYf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SCAN_START_DELAYf_GET BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_SCAN_START_DELAYf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SCAN_START_DELAYf_SET BCM53324_A0_CMIC_LEDUP_CTRLr_LEDUP_SCAN_START_DELAYf_SET
#define READ_CMIC_LEDUP_CTRLr BCM53324_A0_READ_CMIC_LEDUP_CTRLr
#define WRITE_CMIC_LEDUP_CTRLr BCM53324_A0_WRITE_CMIC_LEDUP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LEDUP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LEDUP_DATA_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP Data RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP DATA RAM data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LEDUP_DATA_RAMr 0x00001c00

#define BCM53324_A0_CMIC_LEDUP_DATA_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_DATA_RAM.
 *
 */
typedef union BCM53324_A0_CMIC_LEDUP_DATA_RAMr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_data_ram[1];
	uint32_t _cmic_ledup_data_ram;
} BCM53324_A0_CMIC_LEDUP_DATA_RAMr_t;

#define BCM53324_A0_CMIC_LEDUP_DATA_RAMr_CLR(r) (r).cmic_ledup_data_ram[0] = 0
#define BCM53324_A0_CMIC_LEDUP_DATA_RAMr_SET(r,d) (r).cmic_ledup_data_ram[0] = d
#define BCM53324_A0_CMIC_LEDUP_DATA_RAMr_GET(r) (r).cmic_ledup_data_ram[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LEDUP_DATA_RAMr_DATAf_GET(r) (((r).cmic_ledup_data_ram[0]) & 0xff)
#define BCM53324_A0_CMIC_LEDUP_DATA_RAMr_DATAf_SET(r,f) (r).cmic_ledup_data_ram[0]=(((r).cmic_ledup_data_ram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP_DATA_RAM.
 *
 */
#define BCM53324_A0_READ_CMIC_LEDUP_DATA_RAMr(u,i,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LEDUP_DATA_RAMr+(4*(i)),r._cmic_ledup_data_ram)
#define BCM53324_A0_WRITE_CMIC_LEDUP_DATA_RAMr(u,i,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LEDUP_DATA_RAMr+(4*(i)),r._cmic_ledup_data_ram)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_DATA_RAMr BCM53324_A0_CMIC_LEDUP_DATA_RAMr
#define CMIC_LEDUP_DATA_RAMr_SIZE BCM53324_A0_CMIC_LEDUP_DATA_RAMr_SIZE
typedef BCM53324_A0_CMIC_LEDUP_DATA_RAMr_t CMIC_LEDUP_DATA_RAMr_t;
#define CMIC_LEDUP_DATA_RAMr_CLR BCM53324_A0_CMIC_LEDUP_DATA_RAMr_CLR
#define CMIC_LEDUP_DATA_RAMr_SET BCM53324_A0_CMIC_LEDUP_DATA_RAMr_SET
#define CMIC_LEDUP_DATA_RAMr_GET BCM53324_A0_CMIC_LEDUP_DATA_RAMr_GET
#define CMIC_LEDUP_DATA_RAMr_DATAf_GET BCM53324_A0_CMIC_LEDUP_DATA_RAMr_DATAf_GET
#define CMIC_LEDUP_DATA_RAMr_DATAf_SET BCM53324_A0_CMIC_LEDUP_DATA_RAMr_DATAf_SET
#define READ_CMIC_LEDUP_DATA_RAMr BCM53324_A0_READ_CMIC_LEDUP_DATA_RAMr
#define WRITE_CMIC_LEDUP_DATA_RAMr BCM53324_A0_WRITE_CMIC_LEDUP_DATA_RAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LEDUP_DATA_RAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LEDUP_PROGRAM_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP Program RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP PROGRAM RAM data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr 0x00001800

#define BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_PROGRAM_RAM.
 *
 */
typedef union BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_program_ram[1];
	uint32_t _cmic_ledup_program_ram;
} BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_t;

#define BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_CLR(r) (r).cmic_ledup_program_ram[0] = 0
#define BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_SET(r,d) (r).cmic_ledup_program_ram[0] = d
#define BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_GET(r) (r).cmic_ledup_program_ram[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET(r) (((r).cmic_ledup_program_ram[0]) & 0xff)
#define BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET(r,f) (r).cmic_ledup_program_ram[0]=(((r).cmic_ledup_program_ram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP_PROGRAM_RAM.
 *
 */
#define BCM53324_A0_READ_CMIC_LEDUP_PROGRAM_RAMr(u,i,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr+(4*(i)),r._cmic_ledup_program_ram)
#define BCM53324_A0_WRITE_CMIC_LEDUP_PROGRAM_RAMr(u,i,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr+(4*(i)),r._cmic_ledup_program_ram)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_PROGRAM_RAMr BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr
#define CMIC_LEDUP_PROGRAM_RAMr_SIZE BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_SIZE
typedef BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_t CMIC_LEDUP_PROGRAM_RAMr_t;
#define CMIC_LEDUP_PROGRAM_RAMr_CLR BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_CLR
#define CMIC_LEDUP_PROGRAM_RAMr_SET BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_SET
#define CMIC_LEDUP_PROGRAM_RAMr_GET BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_GET
#define CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET
#define CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET
#define READ_CMIC_LEDUP_PROGRAM_RAMr BCM53324_A0_READ_CMIC_LEDUP_PROGRAM_RAMr
#define WRITE_CMIC_LEDUP_PROGRAM_RAMr BCM53324_A0_WRITE_CMIC_LEDUP_PROGRAM_RAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LEDUP_PROGRAM_RAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LEDUP_STATUS
 * BLOCKS:   CMIC
 * DESC:     LEDUP Status
 * SIZE:     32
 * FIELDS:
 *     PROGRAM_COUNTER  LEDUP Program Counter
 *     LEDUP_RUNNING    LEDUP Running
 *     LEDUP_INITIALISING LEDUP Initialising
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LEDUP_STATUSr 0x00001004

#define BCM53324_A0_CMIC_LEDUP_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_STATUS.
 *
 */
typedef union BCM53324_A0_CMIC_LEDUP_STATUSr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_status[1];
	uint32_t _cmic_ledup_status;
} BCM53324_A0_CMIC_LEDUP_STATUSr_t;

#define BCM53324_A0_CMIC_LEDUP_STATUSr_CLR(r) (r).cmic_ledup_status[0] = 0
#define BCM53324_A0_CMIC_LEDUP_STATUSr_SET(r,d) (r).cmic_ledup_status[0] = d
#define BCM53324_A0_CMIC_LEDUP_STATUSr_GET(r) (r).cmic_ledup_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET(r) (((r).cmic_ledup_status[0]) & 0xff)
#define BCM53324_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET(r) ((((r).cmic_ledup_status[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET(r) ((((r).cmic_ledup_status[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_LEDUP_STATUS.
 *
 */
#define BCM53324_A0_READ_CMIC_LEDUP_STATUSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LEDUP_STATUSr,r._cmic_ledup_status)
#define BCM53324_A0_WRITE_CMIC_LEDUP_STATUSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LEDUP_STATUSr,r._cmic_ledup_status)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_STATUSr BCM53324_A0_CMIC_LEDUP_STATUSr
#define CMIC_LEDUP_STATUSr_SIZE BCM53324_A0_CMIC_LEDUP_STATUSr_SIZE
typedef BCM53324_A0_CMIC_LEDUP_STATUSr_t CMIC_LEDUP_STATUSr_t;
#define CMIC_LEDUP_STATUSr_CLR BCM53324_A0_CMIC_LEDUP_STATUSr_CLR
#define CMIC_LEDUP_STATUSr_SET BCM53324_A0_CMIC_LEDUP_STATUSr_SET
#define CMIC_LEDUP_STATUSr_GET BCM53324_A0_CMIC_LEDUP_STATUSr_GET
#define CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET BCM53324_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET
#define CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET BCM53324_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET
#define CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET BCM53324_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET
#define CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET BCM53324_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET
#define CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET BCM53324_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET
#define CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET BCM53324_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET
#define READ_CMIC_LEDUP_STATUSr BCM53324_A0_READ_CMIC_LEDUP_STATUSr
#define WRITE_CMIC_LEDUP_STATUSr BCM53324_A0_WRITE_CMIC_LEDUP_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LEDUP_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_0_4
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 0-4
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_0     Remapping for Port 0
 *     REMAP_PORT_1     Remapping for Port 1
 *     REMAP_PORT_2     Remapping for Port 2
 *     REMAP_PORT_3     Remapping for Port 3
 *     REMAP_PORT_4     Remapping for Port 4
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r 0x00000d00

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_0_4.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_0_4[1];
	uint32_t _cmic_led_port_order_remap_0_4;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_CLR(r) (r).cmic_led_port_order_remap_0_4[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_SET(r,d) (r).cmic_led_port_order_remap_0_4[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_GET(r) (r).cmic_led_port_order_remap_0_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_GET(r) (((r).cmic_led_port_order_remap_0_4[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_0_4[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_0_4[0]=(((r).cmic_led_port_order_remap_0_4[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_0_4.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_0_4r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r,r._cmic_led_port_order_remap_0_4)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_0_4r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r,r._cmic_led_port_order_remap_0_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_0_4r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_t CMIC_LED_PORT_ORDER_REMAP_0_4r_t;
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_0f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_1f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_2f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_3f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_REMAP_PORT_4f_SET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_0_4r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_0_4r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_0_4r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_0_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_0_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_10_14
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 10-14
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_10    Remapping for Port 10
 *     REMAP_PORT_11    Remapping for Port 11
 *     REMAP_PORT_12    Remapping for Port 12
 *     REMAP_PORT_13    Remapping for Port 13
 *     REMAP_PORT_14    Remapping for Port 14
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r 0x00000d08

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_10_14.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_10_14[1];
	uint32_t _cmic_led_port_order_remap_10_14;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_CLR(r) (r).cmic_led_port_order_remap_10_14[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_SET(r,d) (r).cmic_led_port_order_remap_10_14[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_GET(r) (r).cmic_led_port_order_remap_10_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_GET(r) (((r).cmic_led_port_order_remap_10_14[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_10_14[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_10_14[0]=(((r).cmic_led_port_order_remap_10_14[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_10_14.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_10_14r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r,r._cmic_led_port_order_remap_10_14)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_10_14r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r,r._cmic_led_port_order_remap_10_14)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_10_14r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_t CMIC_LED_PORT_ORDER_REMAP_10_14r_t;
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_10f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_11f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_12f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_13f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_REMAP_PORT_14f_SET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_10_14r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_10_14r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_10_14r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_10_14r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_10_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_15_19
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 15-19
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_15    Remapping for Port 15
 *     REMAP_PORT_16    Remapping for Port 16
 *     REMAP_PORT_17    Remapping for Port 17
 *     REMAP_PORT_18    Remapping for Port 18
 *     REMAP_PORT_19    Remapping for Port 19
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r 0x00000d0c

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_15_19.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_15_19[1];
	uint32_t _cmic_led_port_order_remap_15_19;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_CLR(r) (r).cmic_led_port_order_remap_15_19[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_SET(r,d) (r).cmic_led_port_order_remap_15_19[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_GET(r) (r).cmic_led_port_order_remap_15_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_GET(r) (((r).cmic_led_port_order_remap_15_19[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_15_19[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_15_19[0]=(((r).cmic_led_port_order_remap_15_19[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_15_19.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_15_19r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r,r._cmic_led_port_order_remap_15_19)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_15_19r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r,r._cmic_led_port_order_remap_15_19)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_15_19r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_t CMIC_LED_PORT_ORDER_REMAP_15_19r_t;
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_15f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_16f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_17f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_18f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_REMAP_PORT_19f_SET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_15_19r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_15_19r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_15_19r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_15_19r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_15_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_20_24
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 20-24
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_20    Remapping for Port 20
 *     REMAP_PORT_21    Remapping for Port 21
 *     REMAP_PORT_22    Remapping for Port 22
 *     REMAP_PORT_23    Remapping for Port 23
 *     REMAP_PORT_24    Remapping for Port 24
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r 0x00000d10

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_20_24.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_20_24[1];
	uint32_t _cmic_led_port_order_remap_20_24;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_CLR(r) (r).cmic_led_port_order_remap_20_24[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_SET(r,d) (r).cmic_led_port_order_remap_20_24[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_GET(r) (r).cmic_led_port_order_remap_20_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_GET(r) (((r).cmic_led_port_order_remap_20_24[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_20_24[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_20_24[0]=(((r).cmic_led_port_order_remap_20_24[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_20_24.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_20_24r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r,r._cmic_led_port_order_remap_20_24)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_20_24r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r,r._cmic_led_port_order_remap_20_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_20_24r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_t CMIC_LED_PORT_ORDER_REMAP_20_24r_t;
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_20f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_21f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_22f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_23f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_REMAP_PORT_24f_SET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_20_24r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_20_24r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_20_24r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_20_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_20_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_25_29
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 25-29
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_25    Remapping for Port 25
 *     REMAP_PORT_26    Remapping for Port 26
 *     REMAP_PORT_27    Remapping for Port 27
 *     REMAP_PORT_28    Remapping for Port 28
 *     REMAP_PORT_29    Remapping for Port 29
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r 0x00000d14

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_25_29.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_25_29[1];
	uint32_t _cmic_led_port_order_remap_25_29;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_CLR(r) (r).cmic_led_port_order_remap_25_29[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_SET(r,d) (r).cmic_led_port_order_remap_25_29[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_GET(r) (r).cmic_led_port_order_remap_25_29[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_GET(r) (((r).cmic_led_port_order_remap_25_29[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_25_29[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_25_29[0]=(((r).cmic_led_port_order_remap_25_29[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_25_29.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_25_29r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r,r._cmic_led_port_order_remap_25_29)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_25_29r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r,r._cmic_led_port_order_remap_25_29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_25_29r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_t CMIC_LED_PORT_ORDER_REMAP_25_29r_t;
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_25f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_26f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_27f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_28f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_REMAP_PORT_29f_SET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_25_29r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_25_29r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_25_29r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_25_29r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_25_29r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_30_34
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 30-34
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_30    Remapping for Port 30
 *     REMAP_PORT_31    Remapping for Port 31
 *     REMAP_PORT_32    Remapping for Port 32
 *     REMAP_PORT_33    Remapping for Port 33
 *     REMAP_PORT_34    Remapping for Port 34
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r 0x00000d18

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_30_34.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_30_34[1];
	uint32_t _cmic_led_port_order_remap_30_34;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_CLR(r) (r).cmic_led_port_order_remap_30_34[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_SET(r,d) (r).cmic_led_port_order_remap_30_34[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_GET(r) (r).cmic_led_port_order_remap_30_34[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_GET(r) (((r).cmic_led_port_order_remap_30_34[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_30_34[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_30_34[0]=(((r).cmic_led_port_order_remap_30_34[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_30_34.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_30_34r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r,r._cmic_led_port_order_remap_30_34)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_30_34r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r,r._cmic_led_port_order_remap_30_34)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_30_34r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_t CMIC_LED_PORT_ORDER_REMAP_30_34r_t;
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_30f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_31f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_32f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_33f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_REMAP_PORT_34f_SET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_30_34r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_30_34r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_30_34r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_30_34r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_30_34r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_35_39
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 35-39
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_35    Remapping for Port 35
 *     REMAP_PORT_36    Remapping for Port 36
 *     REMAP_PORT_37    Remapping for Port 37
 *     REMAP_PORT_38    Remapping for Port 38
 *     REMAP_PORT_39    Remapping for Port 39
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r 0x00000d1c

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_35_39.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_35_39[1];
	uint32_t _cmic_led_port_order_remap_35_39;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_CLR(r) (r).cmic_led_port_order_remap_35_39[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_SET(r,d) (r).cmic_led_port_order_remap_35_39[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_GET(r) (r).cmic_led_port_order_remap_35_39[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_GET(r) (((r).cmic_led_port_order_remap_35_39[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_35_39[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_35_39[0]=(((r).cmic_led_port_order_remap_35_39[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_35_39.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_35_39r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r,r._cmic_led_port_order_remap_35_39)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_35_39r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r,r._cmic_led_port_order_remap_35_39)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_35_39r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_t CMIC_LED_PORT_ORDER_REMAP_35_39r_t;
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_35f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_36f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_37f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_38f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_REMAP_PORT_39f_SET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_35_39r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_35_39r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_35_39r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_35_39r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_35_39r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_40_44
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 40-44
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_40    Remapping for Port 40
 *     REMAP_PORT_41    Remapping for Port 41
 *     REMAP_PORT_42    Remapping for Port 42
 *     REMAP_PORT_43    Remapping for Port 43
 *     REMAP_PORT_44    Remapping for Port 44
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r 0x00000d20

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_40_44.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_40_44[1];
	uint32_t _cmic_led_port_order_remap_40_44;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_CLR(r) (r).cmic_led_port_order_remap_40_44[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_SET(r,d) (r).cmic_led_port_order_remap_40_44[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_GET(r) (r).cmic_led_port_order_remap_40_44[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_GET(r) (((r).cmic_led_port_order_remap_40_44[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_40_44[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_40_44[0]=(((r).cmic_led_port_order_remap_40_44[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_40_44.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_40_44r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r,r._cmic_led_port_order_remap_40_44)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_40_44r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r,r._cmic_led_port_order_remap_40_44)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_40_44r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_t CMIC_LED_PORT_ORDER_REMAP_40_44r_t;
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_40f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_41f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_42f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_43f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_REMAP_PORT_44f_SET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_40_44r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_40_44r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_40_44r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_40_44r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_40_44r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_45_49
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 45-49
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_45    Remapping for Port 45
 *     REMAP_PORT_46    Remapping for Port 46
 *     REMAP_PORT_47    Remapping for Port 47
 *     REMAP_PORT_48    Remapping for Port 48
 *     REMAP_PORT_49    Remapping for Port 49
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r 0x00000d24

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_45_49.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_45_49[1];
	uint32_t _cmic_led_port_order_remap_45_49;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_CLR(r) (r).cmic_led_port_order_remap_45_49[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_SET(r,d) (r).cmic_led_port_order_remap_45_49[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_GET(r) (r).cmic_led_port_order_remap_45_49[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_GET(r) (((r).cmic_led_port_order_remap_45_49[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_45_49[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_45_49[0]=(((r).cmic_led_port_order_remap_45_49[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_45_49.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_45_49r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r,r._cmic_led_port_order_remap_45_49)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_45_49r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r,r._cmic_led_port_order_remap_45_49)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_45_49r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_t CMIC_LED_PORT_ORDER_REMAP_45_49r_t;
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_45f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_46f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_47f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_48f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_REMAP_PORT_49f_SET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_45_49r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_45_49r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_45_49r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_45_49r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_45_49r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_50_54
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 50-54
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_50    Remapping for Port 50
 *     REMAP_PORT_51    Remapping for Port 51
 *     REMAP_PORT_52    Remapping for Port 52
 *     REMAP_PORT_53    Remapping for Port 53
 *     REMAP_PORT_54    Remapping for Port 54
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r 0x00000d28

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_50_54.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_50_54[1];
	uint32_t _cmic_led_port_order_remap_50_54;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_CLR(r) (r).cmic_led_port_order_remap_50_54[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_SET(r,d) (r).cmic_led_port_order_remap_50_54[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_GET(r) (r).cmic_led_port_order_remap_50_54[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_GET(r) (((r).cmic_led_port_order_remap_50_54[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_50_54[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_50_54[0]=(((r).cmic_led_port_order_remap_50_54[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_50_54.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_50_54r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r,r._cmic_led_port_order_remap_50_54)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_50_54r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r,r._cmic_led_port_order_remap_50_54)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_50_54r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_t CMIC_LED_PORT_ORDER_REMAP_50_54r_t;
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_50f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_51f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_52f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_53f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_REMAP_PORT_54f_SET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_50_54r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_50_54r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_50_54r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_50_54r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_50_54r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LED_PORT_ORDER_REMAP_5_9
 * BLOCKS:   CMIC
 * DESC:     LEDUP SCan Data Remap register for ports 5-9
 * SIZE:     32
 * FIELDS:
 *     REMAP_PORT_5     Remapping for Port 5
 *     REMAP_PORT_6     Remapping for Port 6
 *     REMAP_PORT_7     Remapping for Port 7
 *     REMAP_PORT_8     Remapping for Port 8
 *     REMAP_PORT_9     Remapping for Port 9
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r 0x00000d04

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LED_PORT_ORDER_REMAP_5_9.
 *
 */
typedef union BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_s {
	uint32_t v[1];
	uint32_t cmic_led_port_order_remap_5_9[1];
	uint32_t _cmic_led_port_order_remap_5_9;
} BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_t;

#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_CLR(r) (r).cmic_led_port_order_remap_5_9[0] = 0
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_SET(r,d) (r).cmic_led_port_order_remap_5_9[0] = d
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_GET(r) (r).cmic_led_port_order_remap_5_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_GET(r) (((r).cmic_led_port_order_remap_5_9[0]) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 6) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 12) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f << 12)) | ((((uint32_t)f) & 0x3f) << 12))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 18) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_GET(r) ((((r).cmic_led_port_order_remap_5_9[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_SET(r,f) (r).cmic_led_port_order_remap_5_9[0]=(((r).cmic_led_port_order_remap_5_9[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_LED_PORT_ORDER_REMAP_5_9.
 *
 */
#define BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_5_9r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r,r._cmic_led_port_order_remap_5_9)
#define BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_5_9r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r,r._cmic_led_port_order_remap_5_9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LED_PORT_ORDER_REMAP_5_9r BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_SIZE BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_SIZE
typedef BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_t CMIC_LED_PORT_ORDER_REMAP_5_9r_t;
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_CLR BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_CLR
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_5f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_6f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_7f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_8f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_REMAP_PORT_9f_SET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_GET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_GET
#define CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_SET BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r_RESERVED_0f_SET
#define READ_CMIC_LED_PORT_ORDER_REMAP_5_9r BCM53324_A0_READ_CMIC_LED_PORT_ORDER_REMAP_5_9r
#define WRITE_CMIC_LED_PORT_ORDER_REMAP_5_9r BCM53324_A0_WRITE_CMIC_LED_PORT_ORDER_REMAP_5_9r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LED_PORT_ORDER_REMAP_5_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LINK_STAT
 * BLOCKS:   CMIC
 * DESC:     Link Status Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link Up / Down Register
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LINK_STATr 0x00000140

#define BCM53324_A0_CMIC_LINK_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LINK_STAT.
 *
 */
typedef union BCM53324_A0_CMIC_LINK_STATr_s {
	uint32_t v[1];
	uint32_t cmic_link_stat[1];
	uint32_t _cmic_link_stat;
} BCM53324_A0_CMIC_LINK_STATr_t;

#define BCM53324_A0_CMIC_LINK_STATr_CLR(r) (r).cmic_link_stat[0] = 0
#define BCM53324_A0_CMIC_LINK_STATr_SET(r,d) (r).cmic_link_stat[0] = d
#define BCM53324_A0_CMIC_LINK_STATr_GET(r) (r).cmic_link_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LINK_STATr_PORT_BITMAPf_GET(r) ((r).cmic_link_stat[0])
#define BCM53324_A0_CMIC_LINK_STATr_PORT_BITMAPf_SET(r,f) (r).cmic_link_stat[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_LINK_STAT.
 *
 */
#define BCM53324_A0_READ_CMIC_LINK_STATr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LINK_STATr,r._cmic_link_stat)
#define BCM53324_A0_WRITE_CMIC_LINK_STATr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LINK_STATr,r._cmic_link_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LINK_STATr BCM53324_A0_CMIC_LINK_STATr
#define CMIC_LINK_STATr_SIZE BCM53324_A0_CMIC_LINK_STATr_SIZE
typedef BCM53324_A0_CMIC_LINK_STATr_t CMIC_LINK_STATr_t;
#define CMIC_LINK_STATr_CLR BCM53324_A0_CMIC_LINK_STATr_CLR
#define CMIC_LINK_STATr_SET BCM53324_A0_CMIC_LINK_STATr_SET
#define CMIC_LINK_STATr_GET BCM53324_A0_CMIC_LINK_STATr_GET
#define CMIC_LINK_STATr_PORT_BITMAPf_GET BCM53324_A0_CMIC_LINK_STATr_PORT_BITMAPf_GET
#define CMIC_LINK_STATr_PORT_BITMAPf_SET BCM53324_A0_CMIC_LINK_STATr_PORT_BITMAPf_SET
#define READ_CMIC_LINK_STATr BCM53324_A0_READ_CMIC_LINK_STATr
#define WRITE_CMIC_LINK_STATr BCM53324_A0_WRITE_CMIC_LINK_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LINK_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_LINK_STATUS_CHANGE_STICKY
 * BLOCKS:   CMIC
 * DESC:     CMIC_LINK_STATUS_CHANGE_STICKY
 * SIZE:     32
 * FIELDS:
 *     CMIC_LINK_STATUS_CHANGE_STICKY CMIC_LINK_STATUS_CHANGE_STICKY
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr 0x00000d54

#define BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LINK_STATUS_CHANGE_STICKY.
 *
 */
typedef union BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_s {
	uint32_t v[1];
	uint32_t cmic_link_status_change_sticky[1];
	uint32_t _cmic_link_status_change_sticky;
} BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_t;

#define BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_CLR(r) (r).cmic_link_status_change_sticky[0] = 0
#define BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_SET(r,d) (r).cmic_link_status_change_sticky[0] = d
#define BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_GET(r) (r).cmic_link_status_change_sticky[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_CMIC_LINK_STATUS_CHANGE_STICKYf_GET(r) ((r).cmic_link_status_change_sticky[0])
#define BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_CMIC_LINK_STATUS_CHANGE_STICKYf_SET(r,f) (r).cmic_link_status_change_sticky[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_LINK_STATUS_CHANGE_STICKY.
 *
 */
#define BCM53324_A0_READ_CMIC_LINK_STATUS_CHANGE_STICKYr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr,r._cmic_link_status_change_sticky)
#define BCM53324_A0_WRITE_CMIC_LINK_STATUS_CHANGE_STICKYr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr,r._cmic_link_status_change_sticky)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LINK_STATUS_CHANGE_STICKYr BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr
#define CMIC_LINK_STATUS_CHANGE_STICKYr_SIZE BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_SIZE
typedef BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_t CMIC_LINK_STATUS_CHANGE_STICKYr_t;
#define CMIC_LINK_STATUS_CHANGE_STICKYr_CLR BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_CLR
#define CMIC_LINK_STATUS_CHANGE_STICKYr_SET BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_SET
#define CMIC_LINK_STATUS_CHANGE_STICKYr_GET BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_GET
#define CMIC_LINK_STATUS_CHANGE_STICKYr_CMIC_LINK_STATUS_CHANGE_STICKYf_GET BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_CMIC_LINK_STATUS_CHANGE_STICKYf_GET
#define CMIC_LINK_STATUS_CHANGE_STICKYr_CMIC_LINK_STATUS_CHANGE_STICKYf_SET BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr_CMIC_LINK_STATUS_CHANGE_STICKYf_SET
#define READ_CMIC_LINK_STATUS_CHANGE_STICKYr BCM53324_A0_READ_CMIC_LINK_STATUS_CHANGE_STICKYr
#define WRITE_CMIC_LINK_STATUS_CHANGE_STICKYr BCM53324_A0_WRITE_CMIC_LINK_STATUS_CHANGE_STICKYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_LINK_STATUS_CHANGE_STICKYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     Supplies the register address of MIIM reads and writes.
For clause 22 devices, bits [4:0] supply the REGAD.
For clause 45 devices, bits [20:16] supply the DTYPE,
                   and bits [15: 0] supply the reg address

 * SIZE:     32
 * FIELDS:
 *     CLAUSE_45_REGADR Register address for associated read or write
 *     CLAUSE_22_REGADR Register address for associated read or write
 *     CLAUSE_45_DTYPE  Block-within-PHY address for associated read or write
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_ADDRESSr 0x000004a0

#define BCM53324_A0_CMIC_MIIM_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_ADDRESS.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_ADDRESSr_s {
	uint32_t v[1];
	uint32_t cmic_miim_address[1];
	uint32_t _cmic_miim_address;
} BCM53324_A0_CMIC_MIIM_ADDRESSr_t;

#define BCM53324_A0_CMIC_MIIM_ADDRESSr_CLR(r) (r).cmic_miim_address[0] = 0
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_SET(r,d) (r).cmic_miim_address[0] = d
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_GET(r) (r).cmic_miim_address[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET(r) (((r).cmic_miim_address[0]) & 0xffff)
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET(r) (((r).cmic_miim_address[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET(r) ((((r).cmic_miim_address[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_GET(r) ((((r).cmic_miim_address[0]) >> 21) & 0x7ff)
#define BCM53324_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access CMIC_MIIM_ADDRESS.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_ADDRESSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_ADDRESSr,r._cmic_miim_address)
#define BCM53324_A0_WRITE_CMIC_MIIM_ADDRESSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_ADDRESSr,r._cmic_miim_address)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_ADDRESSr BCM53324_A0_CMIC_MIIM_ADDRESSr
#define CMIC_MIIM_ADDRESSr_SIZE BCM53324_A0_CMIC_MIIM_ADDRESSr_SIZE
typedef BCM53324_A0_CMIC_MIIM_ADDRESSr_t CMIC_MIIM_ADDRESSr_t;
#define CMIC_MIIM_ADDRESSr_CLR BCM53324_A0_CMIC_MIIM_ADDRESSr_CLR
#define CMIC_MIIM_ADDRESSr_SET BCM53324_A0_CMIC_MIIM_ADDRESSr_SET
#define CMIC_MIIM_ADDRESSr_GET BCM53324_A0_CMIC_MIIM_ADDRESSr_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET
#define CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET BCM53324_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET
#define CMIC_MIIM_ADDRESSr_RESERVED_1f_GET BCM53324_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_GET
#define CMIC_MIIM_ADDRESSr_RESERVED_1f_SET BCM53324_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_SET
#define READ_CMIC_MIIM_ADDRESSr BCM53324_A0_READ_CMIC_MIIM_ADDRESSr
#define WRITE_CMIC_MIIM_ADDRESSr BCM53324_A0_WRITE_CMIC_MIIM_ADDRESSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_ADDRESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_AUTO_SCAN_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     CMIC_MIIM_AUTO_SCAN_ADDRESS
 * SIZE:     32
 * FIELDS:
 *     MIIM_DEVICE_ADDRESS 21-bit MIIM device address used for hardware auto scan.
 *     MIIM_DEVICE_ADDRESS_ENABLE Enable use of the complete 21-bit address for hardware auto scan.
 *     MIIM_LINK_STATUS_BIT_POSITION Position of link status bit in the MDIO device register.
 *     MIIM_FLIP_STATUS_BIT If set, will invert the data read to derive link status information.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr 0x00000864

#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_AUTO_SCAN_ADDRESS.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_s {
	uint32_t v[1];
	uint32_t cmic_miim_auto_scan_address[1];
	uint32_t _cmic_miim_auto_scan_address;
} BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_t;

#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_CLR(r) (r).cmic_miim_auto_scan_address[0] = 0
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_SET(r,d) (r).cmic_miim_auto_scan_address[0] = d
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_GET(r) (r).cmic_miim_auto_scan_address[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESSf_GET(r) (((r).cmic_miim_auto_scan_address[0]) & 0x1fffff)
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESSf_SET(r,f) (r).cmic_miim_auto_scan_address[0]=(((r).cmic_miim_auto_scan_address[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESS_ENABLEf_GET(r) ((((r).cmic_miim_auto_scan_address[0]) >> 21) & 0x1)
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESS_ENABLEf_SET(r,f) (r).cmic_miim_auto_scan_address[0]=(((r).cmic_miim_auto_scan_address[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_LINK_STATUS_BIT_POSITIONf_GET(r) ((((r).cmic_miim_auto_scan_address[0]) >> 22) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_LINK_STATUS_BIT_POSITIONf_SET(r,f) (r).cmic_miim_auto_scan_address[0]=(((r).cmic_miim_auto_scan_address[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_FLIP_STATUS_BITf_GET(r) ((((r).cmic_miim_auto_scan_address[0]) >> 27) & 0x1)
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_FLIP_STATUS_BITf_SET(r,f) (r).cmic_miim_auto_scan_address[0]=(((r).cmic_miim_auto_scan_address[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_RESERVED_0f_GET(r) ((((r).cmic_miim_auto_scan_address[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_RESERVED_0f_SET(r,f) (r).cmic_miim_auto_scan_address[0]=(((r).cmic_miim_auto_scan_address[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_MIIM_AUTO_SCAN_ADDRESS.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_AUTO_SCAN_ADDRESSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr,r._cmic_miim_auto_scan_address)
#define BCM53324_A0_WRITE_CMIC_MIIM_AUTO_SCAN_ADDRESSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr,r._cmic_miim_auto_scan_address)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_AUTO_SCAN_ADDRESSr BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_SIZE BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_SIZE
typedef BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_t CMIC_MIIM_AUTO_SCAN_ADDRESSr_t;
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_CLR BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_CLR
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_SET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_SET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_GET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_GET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESSf_GET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESSf_GET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESSf_SET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESSf_SET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESS_ENABLEf_GET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESS_ENABLEf_GET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESS_ENABLEf_SET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_DEVICE_ADDRESS_ENABLEf_SET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_LINK_STATUS_BIT_POSITIONf_GET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_LINK_STATUS_BIT_POSITIONf_GET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_LINK_STATUS_BIT_POSITIONf_SET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_LINK_STATUS_BIT_POSITIONf_SET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_FLIP_STATUS_BITf_GET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_FLIP_STATUS_BITf_GET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_FLIP_STATUS_BITf_SET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_MIIM_FLIP_STATUS_BITf_SET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_RESERVED_0f_GET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_RESERVED_0f_GET
#define CMIC_MIIM_AUTO_SCAN_ADDRESSr_RESERVED_0f_SET BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr_RESERVED_0f_SET
#define READ_CMIC_MIIM_AUTO_SCAN_ADDRESSr BCM53324_A0_READ_CMIC_MIIM_AUTO_SCAN_ADDRESSr
#define WRITE_CMIC_MIIM_AUTO_SCAN_ADDRESSr BCM53324_A0_WRITE_CMIC_MIIM_AUTO_SCAN_ADDRESSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_AUTO_SCAN_ADDRESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 11:8
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_8         Phy ID of external phy for Port 8
 *     PHY_ID_9         Phy ID of external phy for Port 9
 *     PHY_ID_10        Phy ID of external phy for Port 10
 *     PHY_ID_11        Phy ID of external phy for Port 11
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r 0x000004c8

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_11_8[1];
	uint32_t _cmic_miim_ext_phy_addr_map_11_8;
} BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t;

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR(r) (r).cmic_miim_ext_phy_addr_map_11_8[0] = 0
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_11_8[0] = d
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET(r) (r).cmic_miim_ext_phy_addr_map_11_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET(r) (((r).cmic_miim_ext_phy_addr_map_11_8[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r,r._cmic_miim_ext_phy_addr_map_11_8)
#define BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r,r._cmic_miim_ext_phy_addr_map_11_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE
typedef BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 15:12
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_12        Phy ID of external phy for Port 12
 *     PHY_ID_13        Phy ID of external phy for Port 13
 *     PHY_ID_14        Phy ID of external phy for Port 14
 *     PHY_ID_15        Phy ID of external phy for Port 15
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r 0x000004cc

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_15_12[1];
	uint32_t _cmic_miim_ext_phy_addr_map_15_12;
} BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t;

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR(r) (r).cmic_miim_ext_phy_addr_map_15_12[0] = 0
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_15_12[0] = d
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET(r) (r).cmic_miim_ext_phy_addr_map_15_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET(r) (((r).cmic_miim_ext_phy_addr_map_15_12[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r,r._cmic_miim_ext_phy_addr_map_15_12)
#define BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r,r._cmic_miim_ext_phy_addr_map_15_12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE
typedef BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 19:16
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_16        Phy ID of external phy for Port 16
 *     PHY_ID_17        Phy ID of external phy for Port 17
 *     PHY_ID_18        Phy ID of external phy for Port 18
 *     PHY_ID_19        Phy ID of external phy for Port 19
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r 0x000004d0

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_19_16[1];
	uint32_t _cmic_miim_ext_phy_addr_map_19_16;
} BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t;

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR(r) (r).cmic_miim_ext_phy_addr_map_19_16[0] = 0
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_19_16[0] = d
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET(r) (r).cmic_miim_ext_phy_addr_map_19_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET(r) (((r).cmic_miim_ext_phy_addr_map_19_16[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r,r._cmic_miim_ext_phy_addr_map_19_16)
#define BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r,r._cmic_miim_ext_phy_addr_map_19_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE
typedef BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 23:20
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_20        Phy ID of external phy for Port 20
 *     PHY_ID_21        Phy ID of external phy for Port 21
 *     PHY_ID_22        Phy ID of external phy for Port 22
 *     PHY_ID_23        Phy ID of external phy for Port 23
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r 0x000004d4

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_23_20[1];
	uint32_t _cmic_miim_ext_phy_addr_map_23_20;
} BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t;

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR(r) (r).cmic_miim_ext_phy_addr_map_23_20[0] = 0
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_23_20[0] = d
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET(r) (r).cmic_miim_ext_phy_addr_map_23_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET(r) (((r).cmic_miim_ext_phy_addr_map_23_20[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r,r._cmic_miim_ext_phy_addr_map_23_20)
#define BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r,r._cmic_miim_ext_phy_addr_map_23_20)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE
typedef BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 27:24
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_24        Phy ID of external phy for Port 24
 *     PHY_ID_25        Phy ID of external phy for Port 25
 *     PHY_ID_26        Phy ID of external phy for Port 26
 *     PHY_ID_27        Phy ID of external phy for Port 27
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r 0x000004d8

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_27_24[1];
	uint32_t _cmic_miim_ext_phy_addr_map_27_24;
} BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t;

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR(r) (r).cmic_miim_ext_phy_addr_map_27_24[0] = 0
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_27_24[0] = d
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET(r) (r).cmic_miim_ext_phy_addr_map_27_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET(r) (((r).cmic_miim_ext_phy_addr_map_27_24[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r,r._cmic_miim_ext_phy_addr_map_27_24)
#define BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r,r._cmic_miim_ext_phy_addr_map_27_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE
typedef BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 31:28
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_28        Phy ID of external phy for Port 28
 *     PHY_ID_29        Phy ID of external phy for Port 29
 *     PHY_ID_30        Phy ID of external phy for Port 30
 *     PHY_ID_31        Phy ID of external phy for Port 31
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r 0x000004dc

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_31_28[1];
	uint32_t _cmic_miim_ext_phy_addr_map_31_28;
} BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t;

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR(r) (r).cmic_miim_ext_phy_addr_map_31_28[0] = 0
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_31_28[0] = d
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET(r) (r).cmic_miim_ext_phy_addr_map_31_28[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET(r) (((r).cmic_miim_ext_phy_addr_map_31_28[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r,r._cmic_miim_ext_phy_addr_map_31_28)
#define BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r,r._cmic_miim_ext_phy_addr_map_31_28)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE
typedef BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_31f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 3:0
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_0         Phy ID of external phy for Port 0
 *     PHY_ID_1         Phy ID of external phy for Port 1
 *     PHY_ID_2         Phy ID of external phy for Port 2
 *     PHY_ID_3         Phy ID of external phy for Port 3
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r 0x000004c0

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_3_0[1];
	uint32_t _cmic_miim_ext_phy_addr_map_3_0;
} BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t;

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR(r) (r).cmic_miim_ext_phy_addr_map_3_0[0] = 0
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_3_0[0] = d
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET(r) (r).cmic_miim_ext_phy_addr_map_3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET(r) (((r).cmic_miim_ext_phy_addr_map_3_0[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r,r._cmic_miim_ext_phy_addr_map_3_0)
#define BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r,r._cmic_miim_ext_phy_addr_map_3_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE
typedef BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 7:4
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_4         Phy ID of external phy for Port 4
 *     PHY_ID_5         Phy ID of external phy for Port 5
 *     PHY_ID_6         Phy ID of external phy for Port 6
 *     PHY_ID_7         Phy ID of external phy for Port 7
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r 0x000004c4

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_7_4[1];
	uint32_t _cmic_miim_ext_phy_addr_map_7_4;
} BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t;

#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR(r) (r).cmic_miim_ext_phy_addr_map_7_4[0] = 0
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_7_4[0] = d
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET(r) (r).cmic_miim_ext_phy_addr_map_7_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET(r) (((r).cmic_miim_ext_phy_addr_map_7_4[0]) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r,r._cmic_miim_ext_phy_addr_map_7_4)
#define BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r,r._cmic_miim_ext_phy_addr_map_7_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE
typedef BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM53324_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM53324_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_INT_SEL_MAP
 * BLOCKS:   CMIC
 * DESC:     Port bitmap specifying whether scan should be done
from internal or external phy.
0=external phy, 1=internal phy
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      0 bits imply get link status by scanning external phy1 bits imply get link status directly from internal phy
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr 0x000004ac

#define BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_INT_SEL_MAP.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_int_sel_map[1];
	uint32_t _cmic_miim_int_sel_map;
} BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_t;

#define BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_CLR(r) (r).cmic_miim_int_sel_map[0] = 0
#define BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_SET(r,d) (r).cmic_miim_int_sel_map[0] = d
#define BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_GET(r) (r).cmic_miim_int_sel_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET(r) ((r).cmic_miim_int_sel_map[0])
#define BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET(r,f) (r).cmic_miim_int_sel_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_INT_SEL_MAP.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_INT_SEL_MAPr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr,r._cmic_miim_int_sel_map)
#define BCM53324_A0_WRITE_CMIC_MIIM_INT_SEL_MAPr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr,r._cmic_miim_int_sel_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_INT_SEL_MAPr BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr
#define CMIC_MIIM_INT_SEL_MAPr_SIZE BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_SIZE
typedef BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_t CMIC_MIIM_INT_SEL_MAPr_t;
#define CMIC_MIIM_INT_SEL_MAPr_CLR BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_CLR
#define CMIC_MIIM_INT_SEL_MAPr_SET BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_SET
#define CMIC_MIIM_INT_SEL_MAPr_GET BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_GET
#define CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET
#define CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET
#define READ_CMIC_MIIM_INT_SEL_MAPr BCM53324_A0_READ_CMIC_MIIM_INT_SEL_MAPr
#define WRITE_CMIC_MIIM_INT_SEL_MAPr BCM53324_A0_WRITE_CMIC_MIIM_INT_SEL_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_INT_SEL_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_PARAM
 * BLOCKS:   CMIC
 * DESC:     MIIM Parameter Register
 * SIZE:     32
 * FIELDS:
 *     PHY_DATA         PHY register data
 *     PHY_ID           Port number (Phy ID is looked up from port number)
 *     C45_SEL          When set, send MIIM transaction using Clause 45.Otherwise, send as Clause 22 transaction.
 *     HG_SEL           When set, send MIIM transaction on Higig MDIO bus.Otherwise, send on Gig MDIO bus.
 *     INTERNAL_SEL     When set, send MIIM transaction on Internal MDIO bus.Otherwise, send on External MDIO bus.
 *     RESERVED_2       Reserved
 *     MIIM_CYCLE       This field is used to select which type of MIIM cycle to run.Normally, it should just be set to 000.    000: Automatically runs the proper read or write cycle based         on the ports' protocol preference, and whether a read         or write cycle was requested.  If the port is clause 45         enabled, then the read or write will be preceeded by         an address cycle.    001: requests a clause 22 write cycle;         use MIIM_WR_REG_EN control    010: requests a clause 22 read cycle;         use MIIM_RD_REG_EN control    100: requests a clause 45 address cycle;         use MIIM_WR_REG_EN control    101: requests a clause 45 write cycle;         use MIIM_WR_REG_EN control    110: requests a clause 45 read cycle w/addr increment;         use MIIM_RD_REG_EN control    111: requests a clause 45 read cycle;         use MIIM_RD_REG_EN control
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_PARAMr 0x00000158

#define BCM53324_A0_CMIC_MIIM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PARAM.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_PARAMr_s {
	uint32_t v[1];
	uint32_t cmic_miim_param[1];
	uint32_t _cmic_miim_param;
} BCM53324_A0_CMIC_MIIM_PARAMr_t;

#define BCM53324_A0_CMIC_MIIM_PARAMr_CLR(r) (r).cmic_miim_param[0] = 0
#define BCM53324_A0_CMIC_MIIM_PARAMr_SET(r,d) (r).cmic_miim_param[0] = d
#define BCM53324_A0_CMIC_MIIM_PARAMr_GET(r) (r).cmic_miim_param[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_PARAMr_PHY_DATAf_GET(r) (((r).cmic_miim_param[0]) & 0xffff)
#define BCM53324_A0_CMIC_MIIM_PARAMr_PHY_DATAf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_MIIM_PARAMr_PHY_IDf_GET(r) ((((r).cmic_miim_param[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_PARAMr_PHY_IDf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_MIIM_PARAMr_C45_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 21) & 0x1)
#define BCM53324_A0_CMIC_MIIM_PARAMr_C45_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_CMIC_MIIM_PARAMr_HG_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 22) & 0x1)
#define BCM53324_A0_CMIC_MIIM_PARAMr_HG_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 23) & 0x1)
#define BCM53324_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_CMIC_MIIM_PARAMr_RESERVED_2f_GET(r) ((((r).cmic_miim_param[0]) >> 24) & 0x1f)
#define BCM53324_A0_CMIC_MIIM_PARAMr_RESERVED_2f_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM53324_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET(r) ((((r).cmic_miim_param[0]) >> 29) & 0x7)
#define BCM53324_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_PARAM.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_PARAMr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_PARAMr,r._cmic_miim_param)
#define BCM53324_A0_WRITE_CMIC_MIIM_PARAMr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_PARAMr,r._cmic_miim_param)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PARAMr BCM53324_A0_CMIC_MIIM_PARAMr
#define CMIC_MIIM_PARAMr_SIZE BCM53324_A0_CMIC_MIIM_PARAMr_SIZE
typedef BCM53324_A0_CMIC_MIIM_PARAMr_t CMIC_MIIM_PARAMr_t;
#define CMIC_MIIM_PARAMr_CLR BCM53324_A0_CMIC_MIIM_PARAMr_CLR
#define CMIC_MIIM_PARAMr_SET BCM53324_A0_CMIC_MIIM_PARAMr_SET
#define CMIC_MIIM_PARAMr_GET BCM53324_A0_CMIC_MIIM_PARAMr_GET
#define CMIC_MIIM_PARAMr_PHY_DATAf_GET BCM53324_A0_CMIC_MIIM_PARAMr_PHY_DATAf_GET
#define CMIC_MIIM_PARAMr_PHY_DATAf_SET BCM53324_A0_CMIC_MIIM_PARAMr_PHY_DATAf_SET
#define CMIC_MIIM_PARAMr_PHY_IDf_GET BCM53324_A0_CMIC_MIIM_PARAMr_PHY_IDf_GET
#define CMIC_MIIM_PARAMr_PHY_IDf_SET BCM53324_A0_CMIC_MIIM_PARAMr_PHY_IDf_SET
#define CMIC_MIIM_PARAMr_C45_SELf_GET BCM53324_A0_CMIC_MIIM_PARAMr_C45_SELf_GET
#define CMIC_MIIM_PARAMr_C45_SELf_SET BCM53324_A0_CMIC_MIIM_PARAMr_C45_SELf_SET
#define CMIC_MIIM_PARAMr_HG_SELf_GET BCM53324_A0_CMIC_MIIM_PARAMr_HG_SELf_GET
#define CMIC_MIIM_PARAMr_HG_SELf_SET BCM53324_A0_CMIC_MIIM_PARAMr_HG_SELf_SET
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_GET BCM53324_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_GET
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_SET BCM53324_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_SET
#define CMIC_MIIM_PARAMr_RESERVED_2f_GET BCM53324_A0_CMIC_MIIM_PARAMr_RESERVED_2f_GET
#define CMIC_MIIM_PARAMr_RESERVED_2f_SET BCM53324_A0_CMIC_MIIM_PARAMr_RESERVED_2f_SET
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET BCM53324_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET BCM53324_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET
#define READ_CMIC_MIIM_PARAMr BCM53324_A0_READ_CMIC_MIIM_PARAMr
#define WRITE_CMIC_MIIM_PARAMr BCM53324_A0_WRITE_CMIC_MIIM_PARAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_PARAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_PORT_TYPE_MAP
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so access   Gig MIIM interface1 bits are HG/XE ports, so access Higig MIIM interface
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr 0x000004a8

#define BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PORT_TYPE_MAP.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_port_type_map[1];
	uint32_t _cmic_miim_port_type_map;
} BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_t;

#define BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_CLR(r) (r).cmic_miim_port_type_map[0] = 0
#define BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_SET(r,d) (r).cmic_miim_port_type_map[0] = d
#define BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_GET(r) (r).cmic_miim_port_type_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET(r) ((r).cmic_miim_port_type_map[0])
#define BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET(r,f) (r).cmic_miim_port_type_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PORT_TYPE_MAP.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_PORT_TYPE_MAPr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr,r._cmic_miim_port_type_map)
#define BCM53324_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAPr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr,r._cmic_miim_port_type_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PORT_TYPE_MAPr BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr
#define CMIC_MIIM_PORT_TYPE_MAPr_SIZE BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_SIZE
typedef BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_t CMIC_MIIM_PORT_TYPE_MAPr_t;
#define CMIC_MIIM_PORT_TYPE_MAPr_CLR BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_CLR
#define CMIC_MIIM_PORT_TYPE_MAPr_SET BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_SET
#define CMIC_MIIM_PORT_TYPE_MAPr_GET BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_GET
#define CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET
#define CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET
#define READ_CMIC_MIIM_PORT_TYPE_MAPr BCM53324_A0_READ_CMIC_MIIM_PORT_TYPE_MAPr
#define WRITE_CMIC_MIIM_PORT_TYPE_MAPr BCM53324_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_PORT_TYPE_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_PROTOCOL_MAP
 * BLOCKS:   CMIC
 * DESC:     Port bitmap of MIIM protocol: 0=clause 22, 1=clause 45
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are ports that use clause 22;1 bits are ports that use clause 45.Note: This register is shared by external and internal phy's, so it should be programmed appropriately beforelaunching MIIM wr/rd or link scan commands.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr 0x000004a4

#define BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PROTOCOL_MAP.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_protocol_map[1];
	uint32_t _cmic_miim_protocol_map;
} BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_t;

#define BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_CLR(r) (r).cmic_miim_protocol_map[0] = 0
#define BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_SET(r,d) (r).cmic_miim_protocol_map[0] = d
#define BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_GET(r) (r).cmic_miim_protocol_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET(r) ((r).cmic_miim_protocol_map[0])
#define BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET(r,f) (r).cmic_miim_protocol_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PROTOCOL_MAP.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_PROTOCOL_MAPr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr,r._cmic_miim_protocol_map)
#define BCM53324_A0_WRITE_CMIC_MIIM_PROTOCOL_MAPr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr,r._cmic_miim_protocol_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PROTOCOL_MAPr BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr
#define CMIC_MIIM_PROTOCOL_MAPr_SIZE BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_SIZE
typedef BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_t CMIC_MIIM_PROTOCOL_MAPr_t;
#define CMIC_MIIM_PROTOCOL_MAPr_CLR BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_CLR
#define CMIC_MIIM_PROTOCOL_MAPr_SET BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_SET
#define CMIC_MIIM_PROTOCOL_MAPr_GET BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_GET
#define CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET
#define CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET
#define READ_CMIC_MIIM_PROTOCOL_MAPr BCM53324_A0_READ_CMIC_MIIM_PROTOCOL_MAPr
#define WRITE_CMIC_MIIM_PROTOCOL_MAPr BCM53324_A0_WRITE_CMIC_MIIM_PROTOCOL_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_PROTOCOL_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MIIM_READ_DATA
 * BLOCKS:   CMIC
 * DESC:     MIIM Read Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             MIIM Read Data Register
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MIIM_READ_DATAr 0x0000015c

#define BCM53324_A0_CMIC_MIIM_READ_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_READ_DATA.
 *
 */
typedef union BCM53324_A0_CMIC_MIIM_READ_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_miim_read_data[1];
	uint32_t _cmic_miim_read_data;
} BCM53324_A0_CMIC_MIIM_READ_DATAr_t;

#define BCM53324_A0_CMIC_MIIM_READ_DATAr_CLR(r) (r).cmic_miim_read_data[0] = 0
#define BCM53324_A0_CMIC_MIIM_READ_DATAr_SET(r,d) (r).cmic_miim_read_data[0] = d
#define BCM53324_A0_CMIC_MIIM_READ_DATAr_GET(r) (r).cmic_miim_read_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MIIM_READ_DATAr_DATAf_GET(r) (((r).cmic_miim_read_data[0]) & 0xffff)
#define BCM53324_A0_CMIC_MIIM_READ_DATAr_DATAf_SET(r,f) (r).cmic_miim_read_data[0]=(((r).cmic_miim_read_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CMIC_MIIM_READ_DATA.
 *
 */
#define BCM53324_A0_READ_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)
#define BCM53324_A0_WRITE_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_READ_DATAr BCM53324_A0_CMIC_MIIM_READ_DATAr
#define CMIC_MIIM_READ_DATAr_SIZE BCM53324_A0_CMIC_MIIM_READ_DATAr_SIZE
typedef BCM53324_A0_CMIC_MIIM_READ_DATAr_t CMIC_MIIM_READ_DATAr_t;
#define CMIC_MIIM_READ_DATAr_CLR BCM53324_A0_CMIC_MIIM_READ_DATAr_CLR
#define CMIC_MIIM_READ_DATAr_SET BCM53324_A0_CMIC_MIIM_READ_DATAr_SET
#define CMIC_MIIM_READ_DATAr_GET BCM53324_A0_CMIC_MIIM_READ_DATAr_GET
#define CMIC_MIIM_READ_DATAr_DATAf_GET BCM53324_A0_CMIC_MIIM_READ_DATAr_DATAf_GET
#define CMIC_MIIM_READ_DATAr_DATAf_SET BCM53324_A0_CMIC_MIIM_READ_DATAr_DATAf_SET
#define READ_CMIC_MIIM_READ_DATAr BCM53324_A0_READ_CMIC_MIIM_READ_DATAr
#define WRITE_CMIC_MIIM_READ_DATAr BCM53324_A0_WRITE_CMIC_MIIM_READ_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MIIM_READ_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MMU_COSLC_COUNT_ADDR
 * BLOCKS:   CMIC
 * DESC:     When S/W does a read of CMIC_MMU_COSLC_COUNT_DATA register, CMIC returns COSLC_COUNTER value for the port and cos mentioned in this register.
 * SIZE:     32
 * FIELDS:
 *     COS              This is the cos value
 *     PORT_NUM         This indicates the port number for which coslc counter value to be read
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr 0x00000d2c

#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MMU_COSLC_COUNT_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_mmu_coslc_count_addr[1];
	uint32_t _cmic_mmu_coslc_count_addr;
} BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_t;

#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_CLR(r) (r).cmic_mmu_coslc_count_addr[0] = 0
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_SET(r,d) (r).cmic_mmu_coslc_count_addr[0] = d
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_GET(r) (r).cmic_mmu_coslc_count_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_COSf_GET(r) (((r).cmic_mmu_coslc_count_addr[0]) & 0x7)
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_COSf_SET(r,f) (r).cmic_mmu_coslc_count_addr[0]=(((r).cmic_mmu_coslc_count_addr[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_PORT_NUMf_GET(r) ((((r).cmic_mmu_coslc_count_addr[0]) >> 3) & 0x1f)
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_PORT_NUMf_SET(r,f) (r).cmic_mmu_coslc_count_addr[0]=(((r).cmic_mmu_coslc_count_addr[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_RESERVED_0f_GET(r) ((((r).cmic_mmu_coslc_count_addr[0]) >> 8) & 0xffffff)
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_RESERVED_0f_SET(r,f) (r).cmic_mmu_coslc_count_addr[0]=(((r).cmic_mmu_coslc_count_addr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_MMU_COSLC_COUNT_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_MMU_COSLC_COUNT_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr,r._cmic_mmu_coslc_count_addr)
#define BCM53324_A0_WRITE_CMIC_MMU_COSLC_COUNT_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr,r._cmic_mmu_coslc_count_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MMU_COSLC_COUNT_ADDRr BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr
#define CMIC_MMU_COSLC_COUNT_ADDRr_SIZE BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_SIZE
typedef BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_t CMIC_MMU_COSLC_COUNT_ADDRr_t;
#define CMIC_MMU_COSLC_COUNT_ADDRr_CLR BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_CLR
#define CMIC_MMU_COSLC_COUNT_ADDRr_SET BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_SET
#define CMIC_MMU_COSLC_COUNT_ADDRr_GET BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_GET
#define CMIC_MMU_COSLC_COUNT_ADDRr_COSf_GET BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_COSf_GET
#define CMIC_MMU_COSLC_COUNT_ADDRr_COSf_SET BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_COSf_SET
#define CMIC_MMU_COSLC_COUNT_ADDRr_PORT_NUMf_GET BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_PORT_NUMf_GET
#define CMIC_MMU_COSLC_COUNT_ADDRr_PORT_NUMf_SET BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_PORT_NUMf_SET
#define CMIC_MMU_COSLC_COUNT_ADDRr_RESERVED_0f_GET BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_RESERVED_0f_GET
#define CMIC_MMU_COSLC_COUNT_ADDRr_RESERVED_0f_SET BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr_RESERVED_0f_SET
#define READ_CMIC_MMU_COSLC_COUNT_ADDRr BCM53324_A0_READ_CMIC_MMU_COSLC_COUNT_ADDRr
#define WRITE_CMIC_MMU_COSLC_COUNT_ADDRr BCM53324_A0_WRITE_CMIC_MMU_COSLC_COUNT_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MMU_COSLC_COUNT_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_MMU_COSLC_COUNT_DATA
 * BLOCKS:   CMIC
 * DESC:     Every time S/W does a read of this register, CMIC requests MMU for coslc_count of CMIC_MMU_COSLC_COUNT_ADDR.PORT_NUM and  CMIC_MMU_COSLC_COUNT_ADDR.COS over a dedicated interface 
and will hold PCI bus until MMU responds with COSLC_COUNT[11:5]. 
Once MMU response is received, CMIC will release PCI bus and return the received COSLC_COUNT value.


Read to this register will take 4 extra core clocks than regular cmic register reads.

This feature is supported for PCI and EB2 modes.
 * SIZE:     32
 * FIELDS:
 *     COSLC_COUNT      COSLC COUNT
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr 0x00000d30

#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MMU_COSLC_COUNT_DATA.
 *
 */
typedef union BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_mmu_coslc_count_data[1];
	uint32_t _cmic_mmu_coslc_count_data;
} BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_t;

#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_CLR(r) (r).cmic_mmu_coslc_count_data[0] = 0
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_SET(r,d) (r).cmic_mmu_coslc_count_data[0] = d
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_GET(r) (r).cmic_mmu_coslc_count_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_COSLC_COUNTf_GET(r) (((r).cmic_mmu_coslc_count_data[0]) & 0xff)
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_COSLC_COUNTf_SET(r,f) (r).cmic_mmu_coslc_count_data[0]=(((r).cmic_mmu_coslc_count_data[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_RESERVED_0f_GET(r) ((((r).cmic_mmu_coslc_count_data[0]) >> 8) & 0xffffff)
#define BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_RESERVED_0f_SET(r,f) (r).cmic_mmu_coslc_count_data[0]=(((r).cmic_mmu_coslc_count_data[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_MMU_COSLC_COUNT_DATA.
 *
 */
#define BCM53324_A0_READ_CMIC_MMU_COSLC_COUNT_DATAr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr,r._cmic_mmu_coslc_count_data)
#define BCM53324_A0_WRITE_CMIC_MMU_COSLC_COUNT_DATAr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr,r._cmic_mmu_coslc_count_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MMU_COSLC_COUNT_DATAr BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr
#define CMIC_MMU_COSLC_COUNT_DATAr_SIZE BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_SIZE
typedef BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_t CMIC_MMU_COSLC_COUNT_DATAr_t;
#define CMIC_MMU_COSLC_COUNT_DATAr_CLR BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_CLR
#define CMIC_MMU_COSLC_COUNT_DATAr_SET BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_SET
#define CMIC_MMU_COSLC_COUNT_DATAr_GET BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_GET
#define CMIC_MMU_COSLC_COUNT_DATAr_COSLC_COUNTf_GET BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_COSLC_COUNTf_GET
#define CMIC_MMU_COSLC_COUNT_DATAr_COSLC_COUNTf_SET BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_COSLC_COUNTf_SET
#define CMIC_MMU_COSLC_COUNT_DATAr_RESERVED_0f_GET BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_RESERVED_0f_GET
#define CMIC_MMU_COSLC_COUNT_DATAr_RESERVED_0f_SET BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr_RESERVED_0f_SET
#define READ_CMIC_MMU_COSLC_COUNT_DATAr BCM53324_A0_READ_CMIC_MMU_COSLC_COUNT_DATAr
#define WRITE_CMIC_MMU_COSLC_COUNT_DATAr BCM53324_A0_WRITE_CMIC_MMU_COSLC_COUNT_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_MMU_COSLC_COUNT_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PAUSE_MIIM_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     Supplies the register address of MIIM reads and writes.
For clause 22 devices, bits [4:0] supply the REGAD.
For clause 45 devices, bits [20:16] supply the DTYPE,
                   and bits [15: 0] supply the reg address

 * SIZE:     32
 * FIELDS:
 *     CLAUSE_45_REGADR Register address for associated read or write
 *     CLAUSE_22_REGADR Register address for associated read or write
 *     CLAUSE_45_DTYPE  Block-within-PHY address for associated read or write
 *     TX_PAUSE_BIT_POS TX PAUSE BIT POS
 *     RX_PAUSE_BIT_POS RX PAUSE BIT POS
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr 0x00000d44

#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PAUSE_MIIM_ADDRESS.
 *
 */
typedef union BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_s {
	uint32_t v[1];
	uint32_t cmic_pause_miim_address[1];
	uint32_t _cmic_pause_miim_address;
} BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_t;

#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLR(r) (r).cmic_pause_miim_address[0] = 0
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_SET(r,d) (r).cmic_pause_miim_address[0] = d
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_GET(r) (r).cmic_pause_miim_address[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET(r) (((r).cmic_pause_miim_address[0]) & 0xffff)
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET(r,f) (r).cmic_pause_miim_address[0]=(((r).cmic_pause_miim_address[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET(r) (((r).cmic_pause_miim_address[0]) & 0x1f)
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET(r,f) (r).cmic_pause_miim_address[0]=(((r).cmic_pause_miim_address[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET(r) ((((r).cmic_pause_miim_address[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET(r,f) (r).cmic_pause_miim_address[0]=(((r).cmic_pause_miim_address[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_TX_PAUSE_BIT_POSf_GET(r) ((((r).cmic_pause_miim_address[0]) >> 21) & 0x1f)
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_TX_PAUSE_BIT_POSf_SET(r,f) (r).cmic_pause_miim_address[0]=(((r).cmic_pause_miim_address[0] & ~((uint32_t)0x1f << 21)) | ((((uint32_t)f) & 0x1f) << 21))
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_RX_PAUSE_BIT_POSf_GET(r) ((((r).cmic_pause_miim_address[0]) >> 26) & 0x1f)
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_RX_PAUSE_BIT_POSf_SET(r,f) (r).cmic_pause_miim_address[0]=(((r).cmic_pause_miim_address[0] & ~((uint32_t)0x1f << 26)) | ((((uint32_t)f) & 0x1f) << 26))
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_RESERVED_1f_GET(r) ((((r).cmic_pause_miim_address[0]) >> 31) & 0x1)
#define BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_RESERVED_1f_SET(r,f) (r).cmic_pause_miim_address[0]=(((r).cmic_pause_miim_address[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_PAUSE_MIIM_ADDRESS.
 *
 */
#define BCM53324_A0_READ_CMIC_PAUSE_MIIM_ADDRESSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr,r._cmic_pause_miim_address)
#define BCM53324_A0_WRITE_CMIC_PAUSE_MIIM_ADDRESSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr,r._cmic_pause_miim_address)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PAUSE_MIIM_ADDRESSr BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr
#define CMIC_PAUSE_MIIM_ADDRESSr_SIZE BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_SIZE
typedef BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_t CMIC_PAUSE_MIIM_ADDRESSr_t;
#define CMIC_PAUSE_MIIM_ADDRESSr_CLR BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLR
#define CMIC_PAUSE_MIIM_ADDRESSr_SET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_SET
#define CMIC_PAUSE_MIIM_ADDRESSr_GET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_GET
#define CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET
#define CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET
#define CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET
#define CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET
#define CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET
#define CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET
#define CMIC_PAUSE_MIIM_ADDRESSr_TX_PAUSE_BIT_POSf_GET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_TX_PAUSE_BIT_POSf_GET
#define CMIC_PAUSE_MIIM_ADDRESSr_TX_PAUSE_BIT_POSf_SET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_TX_PAUSE_BIT_POSf_SET
#define CMIC_PAUSE_MIIM_ADDRESSr_RX_PAUSE_BIT_POSf_GET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_RX_PAUSE_BIT_POSf_GET
#define CMIC_PAUSE_MIIM_ADDRESSr_RX_PAUSE_BIT_POSf_SET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_RX_PAUSE_BIT_POSf_SET
#define CMIC_PAUSE_MIIM_ADDRESSr_RESERVED_1f_GET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_RESERVED_1f_GET
#define CMIC_PAUSE_MIIM_ADDRESSr_RESERVED_1f_SET BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr_RESERVED_1f_SET
#define READ_CMIC_PAUSE_MIIM_ADDRESSr BCM53324_A0_READ_CMIC_PAUSE_MIIM_ADDRESSr
#define WRITE_CMIC_PAUSE_MIIM_ADDRESSr BCM53324_A0_WRITE_CMIC_PAUSE_MIIM_ADDRESSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PAUSE_MIIM_ADDRESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PAUSE_SCAN_PORTS
 * BLOCKS:   CMIC
 * DESC:     CMIC pause scan ports
 * SIZE:     32
 * FIELDS:
 *     PAUSE_SCAN_PORTS CMIC_PAUSE_SCAN_PORTS.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr 0x00000d38

#define BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PAUSE_SCAN_PORTS.
 *
 */
typedef union BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_pause_scan_ports[1];
	uint32_t _cmic_pause_scan_ports;
} BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_t;

#define BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_CLR(r) (r).cmic_pause_scan_ports[0] = 0
#define BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_SET(r,d) (r).cmic_pause_scan_ports[0] = d
#define BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_GET(r) (r).cmic_pause_scan_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_PAUSE_SCAN_PORTSf_GET(r) ((r).cmic_pause_scan_ports[0])
#define BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_PAUSE_SCAN_PORTSf_SET(r,f) (r).cmic_pause_scan_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PAUSE_SCAN_PORTS.
 *
 */
#define BCM53324_A0_READ_CMIC_PAUSE_SCAN_PORTSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr,r._cmic_pause_scan_ports)
#define BCM53324_A0_WRITE_CMIC_PAUSE_SCAN_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr,r._cmic_pause_scan_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PAUSE_SCAN_PORTSr BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr
#define CMIC_PAUSE_SCAN_PORTSr_SIZE BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_SIZE
typedef BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_t CMIC_PAUSE_SCAN_PORTSr_t;
#define CMIC_PAUSE_SCAN_PORTSr_CLR BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_CLR
#define CMIC_PAUSE_SCAN_PORTSr_SET BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_SET
#define CMIC_PAUSE_SCAN_PORTSr_GET BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_GET
#define CMIC_PAUSE_SCAN_PORTSr_PAUSE_SCAN_PORTSf_GET BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_PAUSE_SCAN_PORTSf_GET
#define CMIC_PAUSE_SCAN_PORTSr_PAUSE_SCAN_PORTSf_SET BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr_PAUSE_SCAN_PORTSf_SET
#define READ_CMIC_PAUSE_SCAN_PORTSr BCM53324_A0_READ_CMIC_PAUSE_SCAN_PORTSr
#define WRITE_CMIC_PAUSE_SCAN_PORTSr BCM53324_A0_WRITE_CMIC_PAUSE_SCAN_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PAUSE_SCAN_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PIO_WAIT_CYCLES
 * BLOCKS:   CMIC
 * DESC:     CMIC PIO WAIT CYCLES
 * SIZE:     32
 * FIELDS:
 *     PIO_WAIT_CYCLES  PIO WAIT CYCLES.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PIO_WAIT_CYCLESr 0x00000d34

#define BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PIO_WAIT_CYCLES.
 *
 */
typedef union BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_s {
	uint32_t v[1];
	uint32_t cmic_pio_wait_cycles[1];
	uint32_t _cmic_pio_wait_cycles;
} BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_t;

#define BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_CLR(r) (r).cmic_pio_wait_cycles[0] = 0
#define BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_SET(r,d) (r).cmic_pio_wait_cycles[0] = d
#define BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_GET(r) (r).cmic_pio_wait_cycles[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_PIO_WAIT_CYCLESf_GET(r) ((r).cmic_pio_wait_cycles[0])
#define BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_PIO_WAIT_CYCLESf_SET(r,f) (r).cmic_pio_wait_cycles[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PIO_WAIT_CYCLES.
 *
 */
#define BCM53324_A0_READ_CMIC_PIO_WAIT_CYCLESr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PIO_WAIT_CYCLESr,r._cmic_pio_wait_cycles)
#define BCM53324_A0_WRITE_CMIC_PIO_WAIT_CYCLESr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PIO_WAIT_CYCLESr,r._cmic_pio_wait_cycles)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PIO_WAIT_CYCLESr BCM53324_A0_CMIC_PIO_WAIT_CYCLESr
#define CMIC_PIO_WAIT_CYCLESr_SIZE BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_SIZE
typedef BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_t CMIC_PIO_WAIT_CYCLESr_t;
#define CMIC_PIO_WAIT_CYCLESr_CLR BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_CLR
#define CMIC_PIO_WAIT_CYCLESr_SET BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_SET
#define CMIC_PIO_WAIT_CYCLESr_GET BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_GET
#define CMIC_PIO_WAIT_CYCLESr_PIO_WAIT_CYCLESf_GET BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_PIO_WAIT_CYCLESf_GET
#define CMIC_PIO_WAIT_CYCLESr_PIO_WAIT_CYCLESf_SET BCM53324_A0_CMIC_PIO_WAIT_CYCLESr_PIO_WAIT_CYCLESf_SET
#define READ_CMIC_PIO_WAIT_CYCLESr BCM53324_A0_READ_CMIC_PIO_WAIT_CYCLESr
#define WRITE_CMIC_PIO_WAIT_CYCLESr BCM53324_A0_WRITE_CMIC_PIO_WAIT_CYCLESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PIO_WAIT_CYCLESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COS
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet COS Bitmap

 * SIZE:     32
 * FIELDS:
 *     COS              COS values of aceptable CMIC packets. Only lower 8 bits are used for Raptor.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COSr 0x00000730

#define BCM53324_A0_CMIC_PKT_COSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COS.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COSr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_cos[1];
	uint32_t _cmic_pkt_cos;
} BCM53324_A0_CMIC_PKT_COSr_t;

#define BCM53324_A0_CMIC_PKT_COSr_CLR(r) (r).cmic_pkt_cos[0] = 0
#define BCM53324_A0_CMIC_PKT_COSr_SET(r,d) (r).cmic_pkt_cos[0] = d
#define BCM53324_A0_CMIC_PKT_COSr_GET(r) (r).cmic_pkt_cos[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COSr_COSf_GET(r) (((r).cmic_pkt_cos[0]) & 0xffff)
#define BCM53324_A0_CMIC_PKT_COSr_COSf_SET(r,f) (r).cmic_pkt_cos[0]=(((r).cmic_pkt_cos[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_PKT_COSr_RESERVEDf_GET(r) ((((r).cmic_pkt_cos[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_PKT_COSr_RESERVEDf_SET(r,f) (r).cmic_pkt_cos[0]=(((r).cmic_pkt_cos[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_COS.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COSr,r._cmic_pkt_cos)
#define BCM53324_A0_WRITE_CMIC_PKT_COSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COSr,r._cmic_pkt_cos)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COSr BCM53324_A0_CMIC_PKT_COSr
#define CMIC_PKT_COSr_SIZE BCM53324_A0_CMIC_PKT_COSr_SIZE
typedef BCM53324_A0_CMIC_PKT_COSr_t CMIC_PKT_COSr_t;
#define CMIC_PKT_COSr_CLR BCM53324_A0_CMIC_PKT_COSr_CLR
#define CMIC_PKT_COSr_SET BCM53324_A0_CMIC_PKT_COSr_SET
#define CMIC_PKT_COSr_GET BCM53324_A0_CMIC_PKT_COSr_GET
#define CMIC_PKT_COSr_COSf_GET BCM53324_A0_CMIC_PKT_COSr_COSf_GET
#define CMIC_PKT_COSr_COSf_SET BCM53324_A0_CMIC_PKT_COSr_COSf_SET
#define CMIC_PKT_COSr_RESERVEDf_GET BCM53324_A0_CMIC_PKT_COSr_RESERVEDf_GET
#define CMIC_PKT_COSr_RESERVEDf_SET BCM53324_A0_CMIC_PKT_COSr_RESERVEDf_SET
#define READ_CMIC_PKT_COSr BCM53324_A0_READ_CMIC_PKT_COSr
#define WRITE_CMIC_PKT_COSr BCM53324_A0_WRITE_CMIC_PKT_COSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_FROMCPU
 * BLOCKS:   CMIC
 * DESC:     Counter: number of FROMCPU_PACKET packets received
        (without module header)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr 0x000001cc

#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_FROMCPU.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_fromcpu[1];
	uint32_t _cmic_pkt_count_fromcpu;
} BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_CLR(r) (r).cmic_pkt_count_fromcpu[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_SET(r,d) (r).cmic_pkt_count_fromcpu[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_GET(r) (r).cmic_pkt_count_fromcpu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_COUNTf_GET(r) ((r).cmic_pkt_count_fromcpu[0])
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_COUNTf_SET(r,f) (r).cmic_pkt_count_fromcpu[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_FROMCPU.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_FROMCPUr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr,r._cmic_pkt_count_fromcpu)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_FROMCPUr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr,r._cmic_pkt_count_fromcpu)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_FROMCPUr BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr
#define CMIC_PKT_COUNT_FROMCPUr_SIZE BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_t CMIC_PKT_COUNT_FROMCPUr_t;
#define CMIC_PKT_COUNT_FROMCPUr_CLR BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_CLR
#define CMIC_PKT_COUNT_FROMCPUr_SET BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_SET
#define CMIC_PKT_COUNT_FROMCPUr_GET BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_GET
#define CMIC_PKT_COUNT_FROMCPUr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_COUNTf_GET
#define CMIC_PKT_COUNT_FROMCPUr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_FROMCPUr BCM53324_A0_READ_CMIC_PKT_COUNT_FROMCPUr
#define WRITE_CMIC_PKT_COUNT_FROMCPUr BCM53324_A0_WRITE_CMIC_PKT_COUNT_FROMCPUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_FROMCPUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_FROMCPU_MH
 * BLOCKS:   CMIC
 * DESC:     Counter: number of FROMCPU_PACKET packets received
        (with module header)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr 0x000001c8

#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_FROMCPU_MH.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_fromcpu_mh[1];
	uint32_t _cmic_pkt_count_fromcpu_mh;
} BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_CLR(r) (r).cmic_pkt_count_fromcpu_mh[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_SET(r,d) (r).cmic_pkt_count_fromcpu_mh[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_GET(r) (r).cmic_pkt_count_fromcpu_mh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_GET(r) ((r).cmic_pkt_count_fromcpu_mh[0])
#define BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_SET(r,f) (r).cmic_pkt_count_fromcpu_mh[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_FROMCPU_MH.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_FROMCPU_MHr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr,r._cmic_pkt_count_fromcpu_mh)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_FROMCPU_MHr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr,r._cmic_pkt_count_fromcpu_mh)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_FROMCPU_MHr BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr
#define CMIC_PKT_COUNT_FROMCPU_MHr_SIZE BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_t CMIC_PKT_COUNT_FROMCPU_MHr_t;
#define CMIC_PKT_COUNT_FROMCPU_MHr_CLR BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_CLR
#define CMIC_PKT_COUNT_FROMCPU_MHr_SET BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_SET
#define CMIC_PKT_COUNT_FROMCPU_MHr_GET BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_GET
#define CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_GET
#define CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_FROMCPU_MHr BCM53324_A0_READ_CMIC_PKT_COUNT_FROMCPU_MHr
#define WRITE_CMIC_PKT_COUNT_FROMCPU_MHr BCM53324_A0_WRITE_CMIC_PKT_COUNT_FROMCPU_MHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_FROMCPU_MHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_SCHAN
 * BLOCKS:   CMIC
 * DESC:     Counter: number of SCHAN_REQUEST packets received

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_SCHANr 0x000001c0

#define BCM53324_A0_CMIC_PKT_COUNT_SCHANr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_SCHAN.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_SCHANr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_schan[1];
	uint32_t _cmic_pkt_count_schan;
} BCM53324_A0_CMIC_PKT_COUNT_SCHANr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_SCHANr_CLR(r) (r).cmic_pkt_count_schan[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_SCHANr_SET(r,d) (r).cmic_pkt_count_schan[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_SCHANr_GET(r) (r).cmic_pkt_count_schan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_SCHANr_COUNTf_GET(r) ((r).cmic_pkt_count_schan[0])
#define BCM53324_A0_CMIC_PKT_COUNT_SCHANr_COUNTf_SET(r,f) (r).cmic_pkt_count_schan[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_SCHAN.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_SCHANr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_SCHANr,r._cmic_pkt_count_schan)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_SCHANr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_SCHANr,r._cmic_pkt_count_schan)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_SCHANr BCM53324_A0_CMIC_PKT_COUNT_SCHANr
#define CMIC_PKT_COUNT_SCHANr_SIZE BCM53324_A0_CMIC_PKT_COUNT_SCHANr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_SCHANr_t CMIC_PKT_COUNT_SCHANr_t;
#define CMIC_PKT_COUNT_SCHANr_CLR BCM53324_A0_CMIC_PKT_COUNT_SCHANr_CLR
#define CMIC_PKT_COUNT_SCHANr_SET BCM53324_A0_CMIC_PKT_COUNT_SCHANr_SET
#define CMIC_PKT_COUNT_SCHANr_GET BCM53324_A0_CMIC_PKT_COUNT_SCHANr_GET
#define CMIC_PKT_COUNT_SCHANr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_SCHANr_COUNTf_GET
#define CMIC_PKT_COUNT_SCHANr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_SCHANr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_SCHANr BCM53324_A0_READ_CMIC_PKT_COUNT_SCHANr
#define WRITE_CMIC_PKT_COUNT_SCHANr BCM53324_A0_WRITE_CMIC_PKT_COUNT_SCHANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_SCHANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_SCHAN_REP
 * BLOCKS:   CMIC
 * DESC:     Counter: number of SCHAN_REPLY packets sent

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr 0x000001c4

#define BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_SCHAN_REP.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_schan_rep[1];
	uint32_t _cmic_pkt_count_schan_rep;
} BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_CLR(r) (r).cmic_pkt_count_schan_rep[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_SET(r,d) (r).cmic_pkt_count_schan_rep[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_GET(r) (r).cmic_pkt_count_schan_rep[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_GET(r) ((r).cmic_pkt_count_schan_rep[0])
#define BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_SET(r,f) (r).cmic_pkt_count_schan_rep[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_SCHAN_REP.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_SCHAN_REPr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr,r._cmic_pkt_count_schan_rep)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_SCHAN_REPr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr,r._cmic_pkt_count_schan_rep)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_SCHAN_REPr BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr
#define CMIC_PKT_COUNT_SCHAN_REPr_SIZE BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_t CMIC_PKT_COUNT_SCHAN_REPr_t;
#define CMIC_PKT_COUNT_SCHAN_REPr_CLR BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_CLR
#define CMIC_PKT_COUNT_SCHAN_REPr_SET BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_SET
#define CMIC_PKT_COUNT_SCHAN_REPr_GET BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_GET
#define CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_GET
#define CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_SCHAN_REPr BCM53324_A0_READ_CMIC_PKT_COUNT_SCHAN_REPr
#define WRITE_CMIC_PKT_COUNT_SCHAN_REPr BCM53324_A0_WRITE_CMIC_PKT_COUNT_SCHAN_REPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_SCHAN_REPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUD
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets sent by means of
        CMIC_PKT_REASON_DIRECT matching (full length)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr 0x000001d4

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUD.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpud[1];
	uint32_t _cmic_pkt_count_tocpud;
} BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_CLR(r) (r).cmic_pkt_count_tocpud[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_SET(r,d) (r).cmic_pkt_count_tocpud[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_GET(r) (r).cmic_pkt_count_tocpud[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpud[0])
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpud[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUD.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUDr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr,r._cmic_pkt_count_tocpud)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUDr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr,r._cmic_pkt_count_tocpud)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUDr BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr
#define CMIC_PKT_COUNT_TOCPUDr_SIZE BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_t CMIC_PKT_COUNT_TOCPUDr_t;
#define CMIC_PKT_COUNT_TOCPUDr_CLR BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_CLR
#define CMIC_PKT_COUNT_TOCPUDr_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_SET
#define CMIC_PKT_COUNT_TOCPUDr_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_GET
#define CMIC_PKT_COUNT_TOCPUDr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUDr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUDr BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUDr
#define WRITE_CMIC_PKT_COUNT_TOCPUDr BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_TOCPUDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUDM
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets sent by means of
        CMIC_PKT_REASON_DIRECT matching (mini length)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr 0x000001d0

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUDM.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpudm[1];
	uint32_t _cmic_pkt_count_tocpudm;
} BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_CLR(r) (r).cmic_pkt_count_tocpudm[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_SET(r,d) (r).cmic_pkt_count_tocpudm[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_GET(r) (r).cmic_pkt_count_tocpudm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpudm[0])
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpudm[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUDM.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUDMr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr,r._cmic_pkt_count_tocpudm)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUDMr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr,r._cmic_pkt_count_tocpudm)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUDMr BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr
#define CMIC_PKT_COUNT_TOCPUDMr_SIZE BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_t CMIC_PKT_COUNT_TOCPUDMr_t;
#define CMIC_PKT_COUNT_TOCPUDMr_CLR BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_CLR
#define CMIC_PKT_COUNT_TOCPUDMr_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_SET
#define CMIC_PKT_COUNT_TOCPUDMr_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_GET
#define CMIC_PKT_COUNT_TOCPUDMr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUDMr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUDMr BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUDMr
#define WRITE_CMIC_PKT_COUNT_TOCPUDMr BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUDMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_TOCPUDMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUE
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets sent by means of
        CMIC_PKT_REASON matching (full length)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr 0x000001dc

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUE.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpue[1];
	uint32_t _cmic_pkt_count_tocpue;
} BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_CLR(r) (r).cmic_pkt_count_tocpue[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_SET(r,d) (r).cmic_pkt_count_tocpue[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_GET(r) (r).cmic_pkt_count_tocpue[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpue[0])
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpue[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUE.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUEr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr,r._cmic_pkt_count_tocpue)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUEr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr,r._cmic_pkt_count_tocpue)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUEr BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr
#define CMIC_PKT_COUNT_TOCPUEr_SIZE BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_t CMIC_PKT_COUNT_TOCPUEr_t;
#define CMIC_PKT_COUNT_TOCPUEr_CLR BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_CLR
#define CMIC_PKT_COUNT_TOCPUEr_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_SET
#define CMIC_PKT_COUNT_TOCPUEr_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_GET
#define CMIC_PKT_COUNT_TOCPUEr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUEr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUEr BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUEr
#define WRITE_CMIC_PKT_COUNT_TOCPUEr BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_TOCPUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUEM
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets sent by means of
        CMIC_PKT_REASON matching (mini length)

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr 0x000001d8

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUEM.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpuem[1];
	uint32_t _cmic_pkt_count_tocpuem;
} BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_CLR(r) (r).cmic_pkt_count_tocpuem[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_SET(r,d) (r).cmic_pkt_count_tocpuem[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_GET(r) (r).cmic_pkt_count_tocpuem[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpuem[0])
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpuem[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUEM.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUEMr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr,r._cmic_pkt_count_tocpuem)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUEMr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr,r._cmic_pkt_count_tocpuem)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUEMr BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr
#define CMIC_PKT_COUNT_TOCPUEMr_SIZE BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_t CMIC_PKT_COUNT_TOCPUEMr_t;
#define CMIC_PKT_COUNT_TOCPUEMr_CLR BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_CLR
#define CMIC_PKT_COUNT_TOCPUEMr_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_SET
#define CMIC_PKT_COUNT_TOCPUEMr_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_GET
#define CMIC_PKT_COUNT_TOCPUEMr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUEMr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUEMr BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUEMr
#define WRITE_CMIC_PKT_COUNT_TOCPUEMr BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUEMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_TOCPUEMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_COUNT_TOCPUN
 * BLOCKS:   CMIC
 * DESC:     Counter: number of packets dropped because they did not match
        CMIC_PKT_REASON* and there was no PCI bus or internal bus
        available.


 * SIZE:     32
 * FIELDS:
 *     COUNT            Count
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr 0x000001e0

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_COUNT_TOCPUN.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_count_tocpun[1];
	uint32_t _cmic_pkt_count_tocpun;
} BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_t;

#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_CLR(r) (r).cmic_pkt_count_tocpun[0] = 0
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_SET(r,d) (r).cmic_pkt_count_tocpun[0] = d
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_GET(r) (r).cmic_pkt_count_tocpun[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_COUNTf_GET(r) ((r).cmic_pkt_count_tocpun[0])
#define BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_COUNTf_SET(r,f) (r).cmic_pkt_count_tocpun[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_COUNT_TOCPUN.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUNr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr,r._cmic_pkt_count_tocpun)
#define BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUNr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr,r._cmic_pkt_count_tocpun)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_COUNT_TOCPUNr BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr
#define CMIC_PKT_COUNT_TOCPUNr_SIZE BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_SIZE
typedef BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_t CMIC_PKT_COUNT_TOCPUNr_t;
#define CMIC_PKT_COUNT_TOCPUNr_CLR BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_CLR
#define CMIC_PKT_COUNT_TOCPUNr_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_SET
#define CMIC_PKT_COUNT_TOCPUNr_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_GET
#define CMIC_PKT_COUNT_TOCPUNr_COUNTf_GET BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_COUNTf_GET
#define CMIC_PKT_COUNT_TOCPUNr_COUNTf_SET BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr_COUNTf_SET
#define READ_CMIC_PKT_COUNT_TOCPUNr BCM53324_A0_READ_CMIC_PKT_COUNT_TOCPUNr
#define WRITE_CMIC_PKT_COUNT_TOCPUNr BCM53324_A0_WRITE_CMIC_PKT_COUNT_TOCPUNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_COUNT_TOCPUNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_CTRL
 * BLOCKS:   CMIC
 * DESC:     CMIC Remote packet Control Register

 * SIZE:     32
 * FIELDS:
 *     ENABLE_SCHAN_REQUEST Enable Remote PIO
 *     ENABLE_FROMCPU_PACKET Enable Remote packets
 *     ENABLE_TOCPU_PACKET Enable reinjection to Remote CPU
 *     VLAN_MATCH       Enable match/check VLAN Tag of CMIC Packet
 *     LMAC0_MATCH      Enable match/check of CMIC Packet MAC Address to Local MAC Address 0
 *     LMAC1_MATCH      Enable match/check of CMIC Packet MAC Address to Local MAC Address 1
 *     MH_SRC_PID_ENABLE Pick up the Module Header SRC_PID value from the PBE bus.
 *     CPU_TC_ENABLE    Add CMIC_PKT_PRI_MAP_TABEL[CPU_COS].CPU_TC to the New L2 Encapsulation Header
 *     MH_TC_MAP_ENABLE Pick up the Module Header Traffic Class value from CMIC_PKT_PRI_MAP_TABEL[CPU_COS].802_1_P. The CPU_COS is the incoming CPU Queueid on the PBE bus.
 *     IEEE_802_1_PRI_MAP_ENABLE Pick up the 802.1p from CMIC_PKT_PRI_MAP_TABEL[CPU_COS].802_1_P. The CPU_COS is the incoming CPU Queueid on the PBE bus.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_CTRLr 0x00000714

#define BCM53324_A0_CMIC_PKT_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_CTRL.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_ctrl[1];
	uint32_t _cmic_pkt_ctrl;
} BCM53324_A0_CMIC_PKT_CTRLr_t;

#define BCM53324_A0_CMIC_PKT_CTRLr_CLR(r) (r).cmic_pkt_ctrl[0] = 0
#define BCM53324_A0_CMIC_PKT_CTRLr_SET(r,d) (r).cmic_pkt_ctrl[0] = d
#define BCM53324_A0_CMIC_PKT_CTRLr_GET(r) (r).cmic_pkt_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_GET(r) (((r).cmic_pkt_ctrl[0]) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_PKT_CTRLr_VLAN_MATCHf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_VLAN_MATCHf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_PKT_CTRLr_LMAC0_MATCHf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_LMAC0_MATCHf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_PKT_CTRLr_LMAC1_MATCHf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 5) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_LMAC1_MATCHf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CMIC_PKT_CTRLr_MH_SRC_PID_ENABLEf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 6) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_MH_SRC_PID_ENABLEf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CMIC_PKT_CTRLr_CPU_TC_ENABLEf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_CPU_TC_ENABLEf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_PKT_CTRLr_MH_TC_MAP_ENABLEf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_MH_TC_MAP_ENABLEf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_PKT_CTRLr_IEEE_802_1_PRI_MAP_ENABLEf_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_PKT_CTRLr_IEEE_802_1_PRI_MAP_ENABLEf_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_PKT_CTRLr_RESERVED_1f_GET(r) ((((r).cmic_pkt_ctrl[0]) >> 10) & 0x3fffff)
#define BCM53324_A0_CMIC_PKT_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_pkt_ctrl[0]=(((r).cmic_pkt_ctrl[0] & ~((uint32_t)0x3fffff << 10)) | ((((uint32_t)f) & 0x3fffff) << 10))

/*
 * These macros can be used to access CMIC_PKT_CTRL.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_CTRLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_CTRLr,r._cmic_pkt_ctrl)
#define BCM53324_A0_WRITE_CMIC_PKT_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_CTRLr,r._cmic_pkt_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_CTRLr BCM53324_A0_CMIC_PKT_CTRLr
#define CMIC_PKT_CTRLr_SIZE BCM53324_A0_CMIC_PKT_CTRLr_SIZE
typedef BCM53324_A0_CMIC_PKT_CTRLr_t CMIC_PKT_CTRLr_t;
#define CMIC_PKT_CTRLr_CLR BCM53324_A0_CMIC_PKT_CTRLr_CLR
#define CMIC_PKT_CTRLr_SET BCM53324_A0_CMIC_PKT_CTRLr_SET
#define CMIC_PKT_CTRLr_GET BCM53324_A0_CMIC_PKT_CTRLr_GET
#define CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_GET BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_GET
#define CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_SET BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_SCHAN_REQUESTf_SET
#define CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_GET BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_GET
#define CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_SET BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_FROMCPU_PACKETf_SET
#define CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_GET BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_GET
#define CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_SET BCM53324_A0_CMIC_PKT_CTRLr_ENABLE_TOCPU_PACKETf_SET
#define CMIC_PKT_CTRLr_VLAN_MATCHf_GET BCM53324_A0_CMIC_PKT_CTRLr_VLAN_MATCHf_GET
#define CMIC_PKT_CTRLr_VLAN_MATCHf_SET BCM53324_A0_CMIC_PKT_CTRLr_VLAN_MATCHf_SET
#define CMIC_PKT_CTRLr_LMAC0_MATCHf_GET BCM53324_A0_CMIC_PKT_CTRLr_LMAC0_MATCHf_GET
#define CMIC_PKT_CTRLr_LMAC0_MATCHf_SET BCM53324_A0_CMIC_PKT_CTRLr_LMAC0_MATCHf_SET
#define CMIC_PKT_CTRLr_LMAC1_MATCHf_GET BCM53324_A0_CMIC_PKT_CTRLr_LMAC1_MATCHf_GET
#define CMIC_PKT_CTRLr_LMAC1_MATCHf_SET BCM53324_A0_CMIC_PKT_CTRLr_LMAC1_MATCHf_SET
#define CMIC_PKT_CTRLr_MH_SRC_PID_ENABLEf_GET BCM53324_A0_CMIC_PKT_CTRLr_MH_SRC_PID_ENABLEf_GET
#define CMIC_PKT_CTRLr_MH_SRC_PID_ENABLEf_SET BCM53324_A0_CMIC_PKT_CTRLr_MH_SRC_PID_ENABLEf_SET
#define CMIC_PKT_CTRLr_CPU_TC_ENABLEf_GET BCM53324_A0_CMIC_PKT_CTRLr_CPU_TC_ENABLEf_GET
#define CMIC_PKT_CTRLr_CPU_TC_ENABLEf_SET BCM53324_A0_CMIC_PKT_CTRLr_CPU_TC_ENABLEf_SET
#define CMIC_PKT_CTRLr_MH_TC_MAP_ENABLEf_GET BCM53324_A0_CMIC_PKT_CTRLr_MH_TC_MAP_ENABLEf_GET
#define CMIC_PKT_CTRLr_MH_TC_MAP_ENABLEf_SET BCM53324_A0_CMIC_PKT_CTRLr_MH_TC_MAP_ENABLEf_SET
#define CMIC_PKT_CTRLr_IEEE_802_1_PRI_MAP_ENABLEf_GET BCM53324_A0_CMIC_PKT_CTRLr_IEEE_802_1_PRI_MAP_ENABLEf_GET
#define CMIC_PKT_CTRLr_IEEE_802_1_PRI_MAP_ENABLEf_SET BCM53324_A0_CMIC_PKT_CTRLr_IEEE_802_1_PRI_MAP_ENABLEf_SET
#define CMIC_PKT_CTRLr_RESERVED_1f_GET BCM53324_A0_CMIC_PKT_CTRLr_RESERVED_1f_GET
#define CMIC_PKT_CTRLr_RESERVED_1f_SET BCM53324_A0_CMIC_PKT_CTRLr_RESERVED_1f_SET
#define READ_CMIC_PKT_CTRLr BCM53324_A0_READ_CMIC_PKT_CTRLr
#define WRITE_CMIC_PKT_CTRLr BCM53324_A0_WRITE_CMIC_PKT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_ETHER_SIG
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet Ethertype and Signature

 * SIZE:     32
 * FIELDS:
 *     SIGNATURE        Signature
 *     ETHERTYPE        Ethertype Value
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_ETHER_SIGr 0x0000072c

#define BCM53324_A0_CMIC_PKT_ETHER_SIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_ETHER_SIG.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_ETHER_SIGr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_ether_sig[1];
	uint32_t _cmic_pkt_ether_sig;
} BCM53324_A0_CMIC_PKT_ETHER_SIGr_t;

#define BCM53324_A0_CMIC_PKT_ETHER_SIGr_CLR(r) (r).cmic_pkt_ether_sig[0] = 0
#define BCM53324_A0_CMIC_PKT_ETHER_SIGr_SET(r,d) (r).cmic_pkt_ether_sig[0] = d
#define BCM53324_A0_CMIC_PKT_ETHER_SIGr_GET(r) (r).cmic_pkt_ether_sig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_ETHER_SIGr_SIGNATUREf_GET(r) (((r).cmic_pkt_ether_sig[0]) & 0xffff)
#define BCM53324_A0_CMIC_PKT_ETHER_SIGr_SIGNATUREf_SET(r,f) (r).cmic_pkt_ether_sig[0]=(((r).cmic_pkt_ether_sig[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_PKT_ETHER_SIGr_ETHERTYPEf_GET(r) ((((r).cmic_pkt_ether_sig[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_PKT_ETHER_SIGr_ETHERTYPEf_SET(r,f) (r).cmic_pkt_ether_sig[0]=(((r).cmic_pkt_ether_sig[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_ETHER_SIG.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_ETHER_SIGr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_ETHER_SIGr,r._cmic_pkt_ether_sig)
#define BCM53324_A0_WRITE_CMIC_PKT_ETHER_SIGr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_ETHER_SIGr,r._cmic_pkt_ether_sig)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_ETHER_SIGr BCM53324_A0_CMIC_PKT_ETHER_SIGr
#define CMIC_PKT_ETHER_SIGr_SIZE BCM53324_A0_CMIC_PKT_ETHER_SIGr_SIZE
typedef BCM53324_A0_CMIC_PKT_ETHER_SIGr_t CMIC_PKT_ETHER_SIGr_t;
#define CMIC_PKT_ETHER_SIGr_CLR BCM53324_A0_CMIC_PKT_ETHER_SIGr_CLR
#define CMIC_PKT_ETHER_SIGr_SET BCM53324_A0_CMIC_PKT_ETHER_SIGr_SET
#define CMIC_PKT_ETHER_SIGr_GET BCM53324_A0_CMIC_PKT_ETHER_SIGr_GET
#define CMIC_PKT_ETHER_SIGr_SIGNATUREf_GET BCM53324_A0_CMIC_PKT_ETHER_SIGr_SIGNATUREf_GET
#define CMIC_PKT_ETHER_SIGr_SIGNATUREf_SET BCM53324_A0_CMIC_PKT_ETHER_SIGr_SIGNATUREf_SET
#define CMIC_PKT_ETHER_SIGr_ETHERTYPEf_GET BCM53324_A0_CMIC_PKT_ETHER_SIGr_ETHERTYPEf_GET
#define CMIC_PKT_ETHER_SIGr_ETHERTYPEf_SET BCM53324_A0_CMIC_PKT_ETHER_SIGr_ETHERTYPEf_SET
#define READ_CMIC_PKT_ETHER_SIGr BCM53324_A0_READ_CMIC_PKT_ETHER_SIGr
#define WRITE_CMIC_PKT_ETHER_SIGr BCM53324_A0_WRITE_CMIC_PKT_ETHER_SIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_ETHER_SIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_LMAC0_HI
 * BLOCKS:   CMIC
 * DESC:     CMIC Local MAC 0 Register Hi

 * SIZE:     32
 * FIELDS:
 *     MAC0_HI          Higher 15 bits of CMIC Local MAC Address 0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_LMAC0_HIr 0x00000718

#define BCM53324_A0_CMIC_PKT_LMAC0_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_LMAC0_HI.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_LMAC0_HIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_lmac0_hi[1];
	uint32_t _cmic_pkt_lmac0_hi;
} BCM53324_A0_CMIC_PKT_LMAC0_HIr_t;

#define BCM53324_A0_CMIC_PKT_LMAC0_HIr_CLR(r) (r).cmic_pkt_lmac0_hi[0] = 0
#define BCM53324_A0_CMIC_PKT_LMAC0_HIr_SET(r,d) (r).cmic_pkt_lmac0_hi[0] = d
#define BCM53324_A0_CMIC_PKT_LMAC0_HIr_GET(r) (r).cmic_pkt_lmac0_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_LMAC0_HIr_MAC0_HIf_GET(r) (((r).cmic_pkt_lmac0_hi[0]) & 0xffff)
#define BCM53324_A0_CMIC_PKT_LMAC0_HIr_MAC0_HIf_SET(r,f) (r).cmic_pkt_lmac0_hi[0]=(((r).cmic_pkt_lmac0_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_PKT_LMAC0_HIr_RESERVEDf_GET(r) ((((r).cmic_pkt_lmac0_hi[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_PKT_LMAC0_HIr_RESERVEDf_SET(r,f) (r).cmic_pkt_lmac0_hi[0]=(((r).cmic_pkt_lmac0_hi[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_LMAC0_HI.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_LMAC0_HIr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_LMAC0_HIr,r._cmic_pkt_lmac0_hi)
#define BCM53324_A0_WRITE_CMIC_PKT_LMAC0_HIr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_LMAC0_HIr,r._cmic_pkt_lmac0_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_LMAC0_HIr BCM53324_A0_CMIC_PKT_LMAC0_HIr
#define CMIC_PKT_LMAC0_HIr_SIZE BCM53324_A0_CMIC_PKT_LMAC0_HIr_SIZE
typedef BCM53324_A0_CMIC_PKT_LMAC0_HIr_t CMIC_PKT_LMAC0_HIr_t;
#define CMIC_PKT_LMAC0_HIr_CLR BCM53324_A0_CMIC_PKT_LMAC0_HIr_CLR
#define CMIC_PKT_LMAC0_HIr_SET BCM53324_A0_CMIC_PKT_LMAC0_HIr_SET
#define CMIC_PKT_LMAC0_HIr_GET BCM53324_A0_CMIC_PKT_LMAC0_HIr_GET
#define CMIC_PKT_LMAC0_HIr_MAC0_HIf_GET BCM53324_A0_CMIC_PKT_LMAC0_HIr_MAC0_HIf_GET
#define CMIC_PKT_LMAC0_HIr_MAC0_HIf_SET BCM53324_A0_CMIC_PKT_LMAC0_HIr_MAC0_HIf_SET
#define CMIC_PKT_LMAC0_HIr_RESERVEDf_GET BCM53324_A0_CMIC_PKT_LMAC0_HIr_RESERVEDf_GET
#define CMIC_PKT_LMAC0_HIr_RESERVEDf_SET BCM53324_A0_CMIC_PKT_LMAC0_HIr_RESERVEDf_SET
#define READ_CMIC_PKT_LMAC0_HIr BCM53324_A0_READ_CMIC_PKT_LMAC0_HIr
#define WRITE_CMIC_PKT_LMAC0_HIr BCM53324_A0_WRITE_CMIC_PKT_LMAC0_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_LMAC0_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_LMAC0_LO
 * BLOCKS:   CMIC
 * DESC:     CMIC Local MAC 0 Register Lo

 * SIZE:     32
 * FIELDS:
 *     MAC0_LO          Lower 32 bits of CMIC Local MAC Address 0
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_LMAC0_LOr 0x0000071c

#define BCM53324_A0_CMIC_PKT_LMAC0_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_LMAC0_LO.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_LMAC0_LOr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_lmac0_lo[1];
	uint32_t _cmic_pkt_lmac0_lo;
} BCM53324_A0_CMIC_PKT_LMAC0_LOr_t;

#define BCM53324_A0_CMIC_PKT_LMAC0_LOr_CLR(r) (r).cmic_pkt_lmac0_lo[0] = 0
#define BCM53324_A0_CMIC_PKT_LMAC0_LOr_SET(r,d) (r).cmic_pkt_lmac0_lo[0] = d
#define BCM53324_A0_CMIC_PKT_LMAC0_LOr_GET(r) (r).cmic_pkt_lmac0_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_LMAC0_LOr_MAC0_LOf_GET(r) ((r).cmic_pkt_lmac0_lo[0])
#define BCM53324_A0_CMIC_PKT_LMAC0_LOr_MAC0_LOf_SET(r,f) (r).cmic_pkt_lmac0_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_LMAC0_LO.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_LMAC0_LOr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_LMAC0_LOr,r._cmic_pkt_lmac0_lo)
#define BCM53324_A0_WRITE_CMIC_PKT_LMAC0_LOr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_LMAC0_LOr,r._cmic_pkt_lmac0_lo)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_LMAC0_LOr BCM53324_A0_CMIC_PKT_LMAC0_LOr
#define CMIC_PKT_LMAC0_LOr_SIZE BCM53324_A0_CMIC_PKT_LMAC0_LOr_SIZE
typedef BCM53324_A0_CMIC_PKT_LMAC0_LOr_t CMIC_PKT_LMAC0_LOr_t;
#define CMIC_PKT_LMAC0_LOr_CLR BCM53324_A0_CMIC_PKT_LMAC0_LOr_CLR
#define CMIC_PKT_LMAC0_LOr_SET BCM53324_A0_CMIC_PKT_LMAC0_LOr_SET
#define CMIC_PKT_LMAC0_LOr_GET BCM53324_A0_CMIC_PKT_LMAC0_LOr_GET
#define CMIC_PKT_LMAC0_LOr_MAC0_LOf_GET BCM53324_A0_CMIC_PKT_LMAC0_LOr_MAC0_LOf_GET
#define CMIC_PKT_LMAC0_LOr_MAC0_LOf_SET BCM53324_A0_CMIC_PKT_LMAC0_LOr_MAC0_LOf_SET
#define READ_CMIC_PKT_LMAC0_LOr BCM53324_A0_READ_CMIC_PKT_LMAC0_LOr
#define WRITE_CMIC_PKT_LMAC0_LOr BCM53324_A0_WRITE_CMIC_PKT_LMAC0_LOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_LMAC0_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_LMAC1_HI
 * BLOCKS:   CMIC
 * DESC:     CMIC Local MAC 0 Register Hi

 * SIZE:     32
 * FIELDS:
 *     MAC1_HI          Higher 15 bits of CMIC Local MAC Address 1
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_LMAC1_HIr 0x00000720

#define BCM53324_A0_CMIC_PKT_LMAC1_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_LMAC1_HI.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_LMAC1_HIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_lmac1_hi[1];
	uint32_t _cmic_pkt_lmac1_hi;
} BCM53324_A0_CMIC_PKT_LMAC1_HIr_t;

#define BCM53324_A0_CMIC_PKT_LMAC1_HIr_CLR(r) (r).cmic_pkt_lmac1_hi[0] = 0
#define BCM53324_A0_CMIC_PKT_LMAC1_HIr_SET(r,d) (r).cmic_pkt_lmac1_hi[0] = d
#define BCM53324_A0_CMIC_PKT_LMAC1_HIr_GET(r) (r).cmic_pkt_lmac1_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_LMAC1_HIr_MAC1_HIf_GET(r) (((r).cmic_pkt_lmac1_hi[0]) & 0xffff)
#define BCM53324_A0_CMIC_PKT_LMAC1_HIr_MAC1_HIf_SET(r,f) (r).cmic_pkt_lmac1_hi[0]=(((r).cmic_pkt_lmac1_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_PKT_LMAC1_HIr_RESERVEDf_GET(r) ((((r).cmic_pkt_lmac1_hi[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_PKT_LMAC1_HIr_RESERVEDf_SET(r,f) (r).cmic_pkt_lmac1_hi[0]=(((r).cmic_pkt_lmac1_hi[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_LMAC1_HI.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_LMAC1_HIr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_LMAC1_HIr,r._cmic_pkt_lmac1_hi)
#define BCM53324_A0_WRITE_CMIC_PKT_LMAC1_HIr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_LMAC1_HIr,r._cmic_pkt_lmac1_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_LMAC1_HIr BCM53324_A0_CMIC_PKT_LMAC1_HIr
#define CMIC_PKT_LMAC1_HIr_SIZE BCM53324_A0_CMIC_PKT_LMAC1_HIr_SIZE
typedef BCM53324_A0_CMIC_PKT_LMAC1_HIr_t CMIC_PKT_LMAC1_HIr_t;
#define CMIC_PKT_LMAC1_HIr_CLR BCM53324_A0_CMIC_PKT_LMAC1_HIr_CLR
#define CMIC_PKT_LMAC1_HIr_SET BCM53324_A0_CMIC_PKT_LMAC1_HIr_SET
#define CMIC_PKT_LMAC1_HIr_GET BCM53324_A0_CMIC_PKT_LMAC1_HIr_GET
#define CMIC_PKT_LMAC1_HIr_MAC1_HIf_GET BCM53324_A0_CMIC_PKT_LMAC1_HIr_MAC1_HIf_GET
#define CMIC_PKT_LMAC1_HIr_MAC1_HIf_SET BCM53324_A0_CMIC_PKT_LMAC1_HIr_MAC1_HIf_SET
#define CMIC_PKT_LMAC1_HIr_RESERVEDf_GET BCM53324_A0_CMIC_PKT_LMAC1_HIr_RESERVEDf_GET
#define CMIC_PKT_LMAC1_HIr_RESERVEDf_SET BCM53324_A0_CMIC_PKT_LMAC1_HIr_RESERVEDf_SET
#define READ_CMIC_PKT_LMAC1_HIr BCM53324_A0_READ_CMIC_PKT_LMAC1_HIr
#define WRITE_CMIC_PKT_LMAC1_HIr BCM53324_A0_WRITE_CMIC_PKT_LMAC1_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_LMAC1_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_LMAC1_LO
 * BLOCKS:   CMIC
 * DESC:     CMIC Local MAC 0 Register Lo

 * SIZE:     32
 * FIELDS:
 *     MAC1_LO          Lower 32 bits of CMIC Local MAC Address 1
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_LMAC1_LOr 0x00000724

#define BCM53324_A0_CMIC_PKT_LMAC1_LOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_LMAC1_LO.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_LMAC1_LOr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_lmac1_lo[1];
	uint32_t _cmic_pkt_lmac1_lo;
} BCM53324_A0_CMIC_PKT_LMAC1_LOr_t;

#define BCM53324_A0_CMIC_PKT_LMAC1_LOr_CLR(r) (r).cmic_pkt_lmac1_lo[0] = 0
#define BCM53324_A0_CMIC_PKT_LMAC1_LOr_SET(r,d) (r).cmic_pkt_lmac1_lo[0] = d
#define BCM53324_A0_CMIC_PKT_LMAC1_LOr_GET(r) (r).cmic_pkt_lmac1_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_LMAC1_LOr_MAC1_LOf_GET(r) ((r).cmic_pkt_lmac1_lo[0])
#define BCM53324_A0_CMIC_PKT_LMAC1_LOr_MAC1_LOf_SET(r,f) (r).cmic_pkt_lmac1_lo[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_LMAC1_LO.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_LMAC1_LOr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_LMAC1_LOr,r._cmic_pkt_lmac1_lo)
#define BCM53324_A0_WRITE_CMIC_PKT_LMAC1_LOr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_LMAC1_LOr,r._cmic_pkt_lmac1_lo)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_LMAC1_LOr BCM53324_A0_CMIC_PKT_LMAC1_LOr
#define CMIC_PKT_LMAC1_LOr_SIZE BCM53324_A0_CMIC_PKT_LMAC1_LOr_SIZE
typedef BCM53324_A0_CMIC_PKT_LMAC1_LOr_t CMIC_PKT_LMAC1_LOr_t;
#define CMIC_PKT_LMAC1_LOr_CLR BCM53324_A0_CMIC_PKT_LMAC1_LOr_CLR
#define CMIC_PKT_LMAC1_LOr_SET BCM53324_A0_CMIC_PKT_LMAC1_LOr_SET
#define CMIC_PKT_LMAC1_LOr_GET BCM53324_A0_CMIC_PKT_LMAC1_LOr_GET
#define CMIC_PKT_LMAC1_LOr_MAC1_LOf_GET BCM53324_A0_CMIC_PKT_LMAC1_LOr_MAC1_LOf_GET
#define CMIC_PKT_LMAC1_LOr_MAC1_LOf_SET BCM53324_A0_CMIC_PKT_LMAC1_LOr_MAC1_LOf_SET
#define READ_CMIC_PKT_LMAC1_LOr BCM53324_A0_READ_CMIC_PKT_LMAC1_LOr
#define WRITE_CMIC_PKT_LMAC1_LOr BCM53324_A0_WRITE_CMIC_PKT_LMAC1_LOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_LMAC1_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_PORTS
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet Port Bitmap Low 32 bits

 * SIZE:     32
 * FIELDS:
 *     PORTS            Lower 32 bits of port bitmap for ports allowed for Remote Packet operations.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_PORTSr 0x00000734

#define BCM53324_A0_CMIC_PKT_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_PORTS.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_ports[1];
	uint32_t _cmic_pkt_ports;
} BCM53324_A0_CMIC_PKT_PORTSr_t;

#define BCM53324_A0_CMIC_PKT_PORTSr_CLR(r) (r).cmic_pkt_ports[0] = 0
#define BCM53324_A0_CMIC_PKT_PORTSr_SET(r,d) (r).cmic_pkt_ports[0] = d
#define BCM53324_A0_CMIC_PKT_PORTSr_GET(r) (r).cmic_pkt_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_PORTSr_PORTSf_GET(r) ((r).cmic_pkt_ports[0])
#define BCM53324_A0_CMIC_PKT_PORTSr_PORTSf_SET(r,f) (r).cmic_pkt_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_PORTS.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_PORTSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_PORTSr,r._cmic_pkt_ports)
#define BCM53324_A0_WRITE_CMIC_PKT_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_PORTSr,r._cmic_pkt_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_PORTSr BCM53324_A0_CMIC_PKT_PORTSr
#define CMIC_PKT_PORTSr_SIZE BCM53324_A0_CMIC_PKT_PORTSr_SIZE
typedef BCM53324_A0_CMIC_PKT_PORTSr_t CMIC_PKT_PORTSr_t;
#define CMIC_PKT_PORTSr_CLR BCM53324_A0_CMIC_PKT_PORTSr_CLR
#define CMIC_PKT_PORTSr_SET BCM53324_A0_CMIC_PKT_PORTSr_SET
#define CMIC_PKT_PORTSr_GET BCM53324_A0_CMIC_PKT_PORTSr_GET
#define CMIC_PKT_PORTSr_PORTSf_GET BCM53324_A0_CMIC_PKT_PORTSr_PORTSf_GET
#define CMIC_PKT_PORTSr_PORTSf_SET BCM53324_A0_CMIC_PKT_PORTSr_PORTSf_SET
#define READ_CMIC_PKT_PORTSr BCM53324_A0_READ_CMIC_PKT_PORTSr
#define WRITE_CMIC_PKT_PORTSr BCM53324_A0_WRITE_CMIC_PKT_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_PORTS_HI
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet Port Bitmap High 32 bits

 * SIZE:     32
 * FIELDS:
 *     PORTS_HI         Higher 32 bits of port bitmap for ports allowed for Remote Packet operations.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_PORTS_HIr 0x00000738

#define BCM53324_A0_CMIC_PKT_PORTS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_PORTS_HI.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_PORTS_HIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_ports_hi[1];
	uint32_t _cmic_pkt_ports_hi;
} BCM53324_A0_CMIC_PKT_PORTS_HIr_t;

#define BCM53324_A0_CMIC_PKT_PORTS_HIr_CLR(r) (r).cmic_pkt_ports_hi[0] = 0
#define BCM53324_A0_CMIC_PKT_PORTS_HIr_SET(r,d) (r).cmic_pkt_ports_hi[0] = d
#define BCM53324_A0_CMIC_PKT_PORTS_HIr_GET(r) (r).cmic_pkt_ports_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_PORTS_HIr_PORTS_HIf_GET(r) ((r).cmic_pkt_ports_hi[0])
#define BCM53324_A0_CMIC_PKT_PORTS_HIr_PORTS_HIf_SET(r,f) (r).cmic_pkt_ports_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_PORTS_HI.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_PORTS_HIr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_PORTS_HIr,r._cmic_pkt_ports_hi)
#define BCM53324_A0_WRITE_CMIC_PKT_PORTS_HIr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_PORTS_HIr,r._cmic_pkt_ports_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_PORTS_HIr BCM53324_A0_CMIC_PKT_PORTS_HIr
#define CMIC_PKT_PORTS_HIr_SIZE BCM53324_A0_CMIC_PKT_PORTS_HIr_SIZE
typedef BCM53324_A0_CMIC_PKT_PORTS_HIr_t CMIC_PKT_PORTS_HIr_t;
#define CMIC_PKT_PORTS_HIr_CLR BCM53324_A0_CMIC_PKT_PORTS_HIr_CLR
#define CMIC_PKT_PORTS_HIr_SET BCM53324_A0_CMIC_PKT_PORTS_HIr_SET
#define CMIC_PKT_PORTS_HIr_GET BCM53324_A0_CMIC_PKT_PORTS_HIr_GET
#define CMIC_PKT_PORTS_HIr_PORTS_HIf_GET BCM53324_A0_CMIC_PKT_PORTS_HIr_PORTS_HIf_GET
#define CMIC_PKT_PORTS_HIr_PORTS_HIf_SET BCM53324_A0_CMIC_PKT_PORTS_HIr_PORTS_HIf_SET
#define READ_CMIC_PKT_PORTS_HIr BCM53324_A0_READ_CMIC_PKT_PORTS_HIr
#define WRITE_CMIC_PKT_PORTS_HIr BCM53324_A0_WRITE_CMIC_PKT_PORTS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_PORTS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_PRI_MAP_TABLE
 * BLOCKS:   CMIC
 * DESC:     802.1p PRI, Traffic Class and CPU Queue ID Map Table (addresses 0x0600 - 0x06fc
 * SIZE:     32
 * FIELDS:
 *     IEEE_802_1_P     802.1p bits to be used when encapsulating the remote CPU packets with L2 header.
 *     MH_TC            Module Header Traffic Class value to be used when encapsulating the remote CPU packets with a Module Header
 *     CPU_TC           The normalized CPU Traffic Class to be added to the remote CPU packet's "StatusHeader". This will be available only when the CPU packet is encapsulated with an L2 header.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr 0x00000600

#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_PRI_MAP_TABLE.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_pri_map_table[1];
	uint32_t _cmic_pkt_pri_map_table;
} BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_t;

#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_CLR(r) (r).cmic_pkt_pri_map_table[0] = 0
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_SET(r,d) (r).cmic_pkt_pri_map_table[0] = d
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_GET(r) (r).cmic_pkt_pri_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_IEEE_802_1_Pf_GET(r) (((r).cmic_pkt_pri_map_table[0]) & 0x7)
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_IEEE_802_1_Pf_SET(r,f) (r).cmic_pkt_pri_map_table[0]=(((r).cmic_pkt_pri_map_table[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_MH_TCf_GET(r) ((((r).cmic_pkt_pri_map_table[0]) >> 3) & 0xf)
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_MH_TCf_SET(r,f) (r).cmic_pkt_pri_map_table[0]=(((r).cmic_pkt_pri_map_table[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_CPU_TCf_GET(r) ((((r).cmic_pkt_pri_map_table[0]) >> 7) & 0xff)
#define BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_CPU_TCf_SET(r,f) (r).cmic_pkt_pri_map_table[0]=(((r).cmic_pkt_pri_map_table[0] & ~((uint32_t)0xff << 7)) | ((((uint32_t)f) & 0xff) << 7))

/*
 * These macros can be used to access CMIC_PKT_PRI_MAP_TABLE.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_PRI_MAP_TABLEr(u,i,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr+(4*(i)),r._cmic_pkt_pri_map_table)
#define BCM53324_A0_WRITE_CMIC_PKT_PRI_MAP_TABLEr(u,i,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr+(4*(i)),r._cmic_pkt_pri_map_table)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_PRI_MAP_TABLEr BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr
#define CMIC_PKT_PRI_MAP_TABLEr_SIZE BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_SIZE
typedef BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_t CMIC_PKT_PRI_MAP_TABLEr_t;
#define CMIC_PKT_PRI_MAP_TABLEr_CLR BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_CLR
#define CMIC_PKT_PRI_MAP_TABLEr_SET BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_SET
#define CMIC_PKT_PRI_MAP_TABLEr_GET BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_GET
#define CMIC_PKT_PRI_MAP_TABLEr_IEEE_802_1_Pf_GET BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_IEEE_802_1_Pf_GET
#define CMIC_PKT_PRI_MAP_TABLEr_IEEE_802_1_Pf_SET BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_IEEE_802_1_Pf_SET
#define CMIC_PKT_PRI_MAP_TABLEr_MH_TCf_GET BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_MH_TCf_GET
#define CMIC_PKT_PRI_MAP_TABLEr_MH_TCf_SET BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_MH_TCf_SET
#define CMIC_PKT_PRI_MAP_TABLEr_CPU_TCf_GET BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_CPU_TCf_GET
#define CMIC_PKT_PRI_MAP_TABLEr_CPU_TCf_SET BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr_CPU_TCf_SET
#define READ_CMIC_PKT_PRI_MAP_TABLEr BCM53324_A0_READ_CMIC_PKT_PRI_MAP_TABLEr
#define WRITE_CMIC_PKT_PRI_MAP_TABLEr BCM53324_A0_WRITE_CMIC_PKT_PRI_MAP_TABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_PRI_MAP_TABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_REASON
 * BLOCKS:   CMIC
 * DESC:     A bitmap of reason codes (sometimes called CPU opcodes) that cause
CMIC to reinject packets.

 * SIZE:     32
 * FIELDS:
 *     REASONS          Reason code bitmap
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_REASONr 0x00000750

#define BCM53324_A0_CMIC_PKT_REASONr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_REASON.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_REASONr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_reason[1];
	uint32_t _cmic_pkt_reason;
} BCM53324_A0_CMIC_PKT_REASONr_t;

#define BCM53324_A0_CMIC_PKT_REASONr_CLR(r) (r).cmic_pkt_reason[0] = 0
#define BCM53324_A0_CMIC_PKT_REASONr_SET(r,d) (r).cmic_pkt_reason[0] = d
#define BCM53324_A0_CMIC_PKT_REASONr_GET(r) (r).cmic_pkt_reason[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_REASONr_REASONSf_GET(r) ((r).cmic_pkt_reason[0])
#define BCM53324_A0_CMIC_PKT_REASONr_REASONSf_SET(r,f) (r).cmic_pkt_reason[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_REASON.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_REASONr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_REASONr,r._cmic_pkt_reason)
#define BCM53324_A0_WRITE_CMIC_PKT_REASONr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_REASONr,r._cmic_pkt_reason)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_REASONr BCM53324_A0_CMIC_PKT_REASONr
#define CMIC_PKT_REASONr_SIZE BCM53324_A0_CMIC_PKT_REASONr_SIZE
typedef BCM53324_A0_CMIC_PKT_REASONr_t CMIC_PKT_REASONr_t;
#define CMIC_PKT_REASONr_CLR BCM53324_A0_CMIC_PKT_REASONr_CLR
#define CMIC_PKT_REASONr_SET BCM53324_A0_CMIC_PKT_REASONr_SET
#define CMIC_PKT_REASONr_GET BCM53324_A0_CMIC_PKT_REASONr_GET
#define CMIC_PKT_REASONr_REASONSf_GET BCM53324_A0_CMIC_PKT_REASONr_REASONSf_GET
#define CMIC_PKT_REASONr_REASONSf_SET BCM53324_A0_CMIC_PKT_REASONr_REASONSf_SET
#define READ_CMIC_PKT_REASONr BCM53324_A0_READ_CMIC_PKT_REASONr
#define WRITE_CMIC_PKT_REASONr BCM53324_A0_WRITE_CMIC_PKT_REASONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_REASONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_REASON_DIRECT
 * BLOCKS:   CMIC
 * DESC:     A bitmap of reason codes (sometimes called CPU opcodes) that cause
CMIC to reinject Higig packets.

 * SIZE:     32
 * FIELDS:
 *     REASONS          Reason code bitmap
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_REASON_DIRECTr 0x00000754

#define BCM53324_A0_CMIC_PKT_REASON_DIRECTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_REASON_DIRECT.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_REASON_DIRECTr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_reason_direct[1];
	uint32_t _cmic_pkt_reason_direct;
} BCM53324_A0_CMIC_PKT_REASON_DIRECTr_t;

#define BCM53324_A0_CMIC_PKT_REASON_DIRECTr_CLR(r) (r).cmic_pkt_reason_direct[0] = 0
#define BCM53324_A0_CMIC_PKT_REASON_DIRECTr_SET(r,d) (r).cmic_pkt_reason_direct[0] = d
#define BCM53324_A0_CMIC_PKT_REASON_DIRECTr_GET(r) (r).cmic_pkt_reason_direct[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_REASON_DIRECTr_REASONSf_GET(r) ((r).cmic_pkt_reason_direct[0])
#define BCM53324_A0_CMIC_PKT_REASON_DIRECTr_REASONSf_SET(r,f) (r).cmic_pkt_reason_direct[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_REASON_DIRECT.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_REASON_DIRECTr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_REASON_DIRECTr,r._cmic_pkt_reason_direct)
#define BCM53324_A0_WRITE_CMIC_PKT_REASON_DIRECTr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_REASON_DIRECTr,r._cmic_pkt_reason_direct)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_REASON_DIRECTr BCM53324_A0_CMIC_PKT_REASON_DIRECTr
#define CMIC_PKT_REASON_DIRECTr_SIZE BCM53324_A0_CMIC_PKT_REASON_DIRECTr_SIZE
typedef BCM53324_A0_CMIC_PKT_REASON_DIRECTr_t CMIC_PKT_REASON_DIRECTr_t;
#define CMIC_PKT_REASON_DIRECTr_CLR BCM53324_A0_CMIC_PKT_REASON_DIRECTr_CLR
#define CMIC_PKT_REASON_DIRECTr_SET BCM53324_A0_CMIC_PKT_REASON_DIRECTr_SET
#define CMIC_PKT_REASON_DIRECTr_GET BCM53324_A0_CMIC_PKT_REASON_DIRECTr_GET
#define CMIC_PKT_REASON_DIRECTr_REASONSf_GET BCM53324_A0_CMIC_PKT_REASON_DIRECTr_REASONSf_GET
#define CMIC_PKT_REASON_DIRECTr_REASONSf_SET BCM53324_A0_CMIC_PKT_REASON_DIRECTr_REASONSf_SET
#define READ_CMIC_PKT_REASON_DIRECTr BCM53324_A0_READ_CMIC_PKT_REASON_DIRECTr
#define WRITE_CMIC_PKT_REASON_DIRECTr BCM53324_A0_WRITE_CMIC_PKT_REASON_DIRECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_REASON_DIRECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_REASON_MINI
 * BLOCKS:   CMIC
 * DESC:     A bitmap of reason codes (sometimes called CPU opcodes) that cause
CMIC to truncate reinjected packets to a size of 128-bytes.

 * SIZE:     32
 * FIELDS:
 *     REASONS          Reason code bitmap
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_REASON_MINIr 0x00000758

#define BCM53324_A0_CMIC_PKT_REASON_MINIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_REASON_MINI.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_REASON_MINIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_reason_mini[1];
	uint32_t _cmic_pkt_reason_mini;
} BCM53324_A0_CMIC_PKT_REASON_MINIr_t;

#define BCM53324_A0_CMIC_PKT_REASON_MINIr_CLR(r) (r).cmic_pkt_reason_mini[0] = 0
#define BCM53324_A0_CMIC_PKT_REASON_MINIr_SET(r,d) (r).cmic_pkt_reason_mini[0] = d
#define BCM53324_A0_CMIC_PKT_REASON_MINIr_GET(r) (r).cmic_pkt_reason_mini[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_REASON_MINIr_REASONSf_GET(r) ((r).cmic_pkt_reason_mini[0])
#define BCM53324_A0_CMIC_PKT_REASON_MINIr_REASONSf_SET(r,f) (r).cmic_pkt_reason_mini[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_REASON_MINI.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_REASON_MINIr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_REASON_MINIr,r._cmic_pkt_reason_mini)
#define BCM53324_A0_WRITE_CMIC_PKT_REASON_MINIr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_REASON_MINIr,r._cmic_pkt_reason_mini)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_REASON_MINIr BCM53324_A0_CMIC_PKT_REASON_MINIr
#define CMIC_PKT_REASON_MINIr_SIZE BCM53324_A0_CMIC_PKT_REASON_MINIr_SIZE
typedef BCM53324_A0_CMIC_PKT_REASON_MINIr_t CMIC_PKT_REASON_MINIr_t;
#define CMIC_PKT_REASON_MINIr_CLR BCM53324_A0_CMIC_PKT_REASON_MINIr_CLR
#define CMIC_PKT_REASON_MINIr_SET BCM53324_A0_CMIC_PKT_REASON_MINIr_SET
#define CMIC_PKT_REASON_MINIr_GET BCM53324_A0_CMIC_PKT_REASON_MINIr_GET
#define CMIC_PKT_REASON_MINIr_REASONSf_GET BCM53324_A0_CMIC_PKT_REASON_MINIr_REASONSf_GET
#define CMIC_PKT_REASON_MINIr_REASONSf_SET BCM53324_A0_CMIC_PKT_REASON_MINIr_REASONSf_SET
#define READ_CMIC_PKT_REASON_MINIr BCM53324_A0_READ_CMIC_PKT_REASON_MINIr
#define WRITE_CMIC_PKT_REASON_MINIr BCM53324_A0_WRITE_CMIC_PKT_REASON_MINIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_REASON_MINIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_RMAC
 * BLOCKS:   CMIC
 * DESC:     Lower 32 bits of the destination MAC address for all packets that the CMIC generates except for Remote
PIO replies.

 * SIZE:     32
 * FIELDS:
 *     MAC_LO           MAC DA bits 31:0.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_RMACr 0x0000073c

#define BCM53324_A0_CMIC_PKT_RMACr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMAC.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_RMACr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmac[1];
	uint32_t _cmic_pkt_rmac;
} BCM53324_A0_CMIC_PKT_RMACr_t;

#define BCM53324_A0_CMIC_PKT_RMACr_CLR(r) (r).cmic_pkt_rmac[0] = 0
#define BCM53324_A0_CMIC_PKT_RMACr_SET(r,d) (r).cmic_pkt_rmac[0] = d
#define BCM53324_A0_CMIC_PKT_RMACr_GET(r) (r).cmic_pkt_rmac[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_RMACr_MAC_LOf_GET(r) ((r).cmic_pkt_rmac[0])
#define BCM53324_A0_CMIC_PKT_RMACr_MAC_LOf_SET(r,f) (r).cmic_pkt_rmac[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMAC.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_RMACr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_RMACr,r._cmic_pkt_rmac)
#define BCM53324_A0_WRITE_CMIC_PKT_RMACr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_RMACr,r._cmic_pkt_rmac)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMACr BCM53324_A0_CMIC_PKT_RMACr
#define CMIC_PKT_RMACr_SIZE BCM53324_A0_CMIC_PKT_RMACr_SIZE
typedef BCM53324_A0_CMIC_PKT_RMACr_t CMIC_PKT_RMACr_t;
#define CMIC_PKT_RMACr_CLR BCM53324_A0_CMIC_PKT_RMACr_CLR
#define CMIC_PKT_RMACr_SET BCM53324_A0_CMIC_PKT_RMACr_SET
#define CMIC_PKT_RMACr_GET BCM53324_A0_CMIC_PKT_RMACr_GET
#define CMIC_PKT_RMACr_MAC_LOf_GET BCM53324_A0_CMIC_PKT_RMACr_MAC_LOf_GET
#define CMIC_PKT_RMACr_MAC_LOf_SET BCM53324_A0_CMIC_PKT_RMACr_MAC_LOf_SET
#define READ_CMIC_PKT_RMACr BCM53324_A0_READ_CMIC_PKT_RMACr
#define WRITE_CMIC_PKT_RMACr BCM53324_A0_WRITE_CMIC_PKT_RMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_RMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_RMAC_HI
 * BLOCKS:   CMIC
 * DESC:     Higher 16 bits of the destination MAC address for all packets that the CMIC generates except for Remote
PIO replies.

 * SIZE:     32
 * FIELDS:
 *     MAC_HI           MAC DA bits 47:32.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_RMAC_HIr 0x00000740

#define BCM53324_A0_CMIC_PKT_RMAC_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMAC_HI.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_RMAC_HIr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmac_hi[1];
	uint32_t _cmic_pkt_rmac_hi;
} BCM53324_A0_CMIC_PKT_RMAC_HIr_t;

#define BCM53324_A0_CMIC_PKT_RMAC_HIr_CLR(r) (r).cmic_pkt_rmac_hi[0] = 0
#define BCM53324_A0_CMIC_PKT_RMAC_HIr_SET(r,d) (r).cmic_pkt_rmac_hi[0] = d
#define BCM53324_A0_CMIC_PKT_RMAC_HIr_GET(r) (r).cmic_pkt_rmac_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_RMAC_HIr_MAC_HIf_GET(r) (((r).cmic_pkt_rmac_hi[0]) & 0xffff)
#define BCM53324_A0_CMIC_PKT_RMAC_HIr_MAC_HIf_SET(r,f) (r).cmic_pkt_rmac_hi[0]=(((r).cmic_pkt_rmac_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_PKT_RMAC_HIr_RESERVEDf_GET(r) ((((r).cmic_pkt_rmac_hi[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_PKT_RMAC_HIr_RESERVEDf_SET(r,f) (r).cmic_pkt_rmac_hi[0]=(((r).cmic_pkt_rmac_hi[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_RMAC_HI.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_RMAC_HIr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_RMAC_HIr,r._cmic_pkt_rmac_hi)
#define BCM53324_A0_WRITE_CMIC_PKT_RMAC_HIr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_RMAC_HIr,r._cmic_pkt_rmac_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMAC_HIr BCM53324_A0_CMIC_PKT_RMAC_HIr
#define CMIC_PKT_RMAC_HIr_SIZE BCM53324_A0_CMIC_PKT_RMAC_HIr_SIZE
typedef BCM53324_A0_CMIC_PKT_RMAC_HIr_t CMIC_PKT_RMAC_HIr_t;
#define CMIC_PKT_RMAC_HIr_CLR BCM53324_A0_CMIC_PKT_RMAC_HIr_CLR
#define CMIC_PKT_RMAC_HIr_SET BCM53324_A0_CMIC_PKT_RMAC_HIr_SET
#define CMIC_PKT_RMAC_HIr_GET BCM53324_A0_CMIC_PKT_RMAC_HIr_GET
#define CMIC_PKT_RMAC_HIr_MAC_HIf_GET BCM53324_A0_CMIC_PKT_RMAC_HIr_MAC_HIf_GET
#define CMIC_PKT_RMAC_HIr_MAC_HIf_SET BCM53324_A0_CMIC_PKT_RMAC_HIr_MAC_HIf_SET
#define CMIC_PKT_RMAC_HIr_RESERVEDf_GET BCM53324_A0_CMIC_PKT_RMAC_HIr_RESERVEDf_GET
#define CMIC_PKT_RMAC_HIr_RESERVEDf_SET BCM53324_A0_CMIC_PKT_RMAC_HIr_RESERVEDf_SET
#define READ_CMIC_PKT_RMAC_HIr BCM53324_A0_READ_CMIC_PKT_RMAC_HIr
#define WRITE_CMIC_PKT_RMAC_HIr BCM53324_A0_WRITE_CMIC_PKT_RMAC_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_RMAC_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_RMH0
 * BLOCKS:   CMIC
 * DESC:     First DWord of the Module Header on an outpoing CMIC packet.

 * SIZE:     32
 * FIELDS:
 *     MH0              Module Header DWord 0
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_RMH0r 0x00000744

#define BCM53324_A0_CMIC_PKT_RMH0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMH0.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_RMH0r_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmh0[1];
	uint32_t _cmic_pkt_rmh0;
} BCM53324_A0_CMIC_PKT_RMH0r_t;

#define BCM53324_A0_CMIC_PKT_RMH0r_CLR(r) (r).cmic_pkt_rmh0[0] = 0
#define BCM53324_A0_CMIC_PKT_RMH0r_SET(r,d) (r).cmic_pkt_rmh0[0] = d
#define BCM53324_A0_CMIC_PKT_RMH0r_GET(r) (r).cmic_pkt_rmh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_RMH0r_MH0f_GET(r) ((r).cmic_pkt_rmh0[0])
#define BCM53324_A0_CMIC_PKT_RMH0r_MH0f_SET(r,f) (r).cmic_pkt_rmh0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMH0.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_RMH0r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_RMH0r,r._cmic_pkt_rmh0)
#define BCM53324_A0_WRITE_CMIC_PKT_RMH0r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_RMH0r,r._cmic_pkt_rmh0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMH0r BCM53324_A0_CMIC_PKT_RMH0r
#define CMIC_PKT_RMH0r_SIZE BCM53324_A0_CMIC_PKT_RMH0r_SIZE
typedef BCM53324_A0_CMIC_PKT_RMH0r_t CMIC_PKT_RMH0r_t;
#define CMIC_PKT_RMH0r_CLR BCM53324_A0_CMIC_PKT_RMH0r_CLR
#define CMIC_PKT_RMH0r_SET BCM53324_A0_CMIC_PKT_RMH0r_SET
#define CMIC_PKT_RMH0r_GET BCM53324_A0_CMIC_PKT_RMH0r_GET
#define CMIC_PKT_RMH0r_MH0f_GET BCM53324_A0_CMIC_PKT_RMH0r_MH0f_GET
#define CMIC_PKT_RMH0r_MH0f_SET BCM53324_A0_CMIC_PKT_RMH0r_MH0f_SET
#define READ_CMIC_PKT_RMH0r BCM53324_A0_READ_CMIC_PKT_RMH0r
#define WRITE_CMIC_PKT_RMH0r BCM53324_A0_WRITE_CMIC_PKT_RMH0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_RMH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_RMH1
 * BLOCKS:   CMIC
 * DESC:     Second DWord of the Module Header on an outpoing CMIC packet.

 * SIZE:     32
 * FIELDS:
 *     MH1              Module Header DWord 1
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_RMH1r 0x00000748

#define BCM53324_A0_CMIC_PKT_RMH1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMH1.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_RMH1r_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmh1[1];
	uint32_t _cmic_pkt_rmh1;
} BCM53324_A0_CMIC_PKT_RMH1r_t;

#define BCM53324_A0_CMIC_PKT_RMH1r_CLR(r) (r).cmic_pkt_rmh1[0] = 0
#define BCM53324_A0_CMIC_PKT_RMH1r_SET(r,d) (r).cmic_pkt_rmh1[0] = d
#define BCM53324_A0_CMIC_PKT_RMH1r_GET(r) (r).cmic_pkt_rmh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_RMH1r_MH1f_GET(r) ((r).cmic_pkt_rmh1[0])
#define BCM53324_A0_CMIC_PKT_RMH1r_MH1f_SET(r,f) (r).cmic_pkt_rmh1[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMH1.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_RMH1r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_RMH1r,r._cmic_pkt_rmh1)
#define BCM53324_A0_WRITE_CMIC_PKT_RMH1r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_RMH1r,r._cmic_pkt_rmh1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMH1r BCM53324_A0_CMIC_PKT_RMH1r
#define CMIC_PKT_RMH1r_SIZE BCM53324_A0_CMIC_PKT_RMH1r_SIZE
typedef BCM53324_A0_CMIC_PKT_RMH1r_t CMIC_PKT_RMH1r_t;
#define CMIC_PKT_RMH1r_CLR BCM53324_A0_CMIC_PKT_RMH1r_CLR
#define CMIC_PKT_RMH1r_SET BCM53324_A0_CMIC_PKT_RMH1r_SET
#define CMIC_PKT_RMH1r_GET BCM53324_A0_CMIC_PKT_RMH1r_GET
#define CMIC_PKT_RMH1r_MH1f_GET BCM53324_A0_CMIC_PKT_RMH1r_MH1f_GET
#define CMIC_PKT_RMH1r_MH1f_SET BCM53324_A0_CMIC_PKT_RMH1r_MH1f_SET
#define READ_CMIC_PKT_RMH1r BCM53324_A0_READ_CMIC_PKT_RMH1r
#define WRITE_CMIC_PKT_RMH1r BCM53324_A0_WRITE_CMIC_PKT_RMH1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_RMH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_RMH2
 * BLOCKS:   CMIC
 * DESC:     Third DWord of the Module Header on an outpoing CMIC packet.

 * SIZE:     32
 * FIELDS:
 *     MH2              Module Header DWord 2
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_RMH2r 0x0000074c

#define BCM53324_A0_CMIC_PKT_RMH2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMH2.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_RMH2r_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmh2[1];
	uint32_t _cmic_pkt_rmh2;
} BCM53324_A0_CMIC_PKT_RMH2r_t;

#define BCM53324_A0_CMIC_PKT_RMH2r_CLR(r) (r).cmic_pkt_rmh2[0] = 0
#define BCM53324_A0_CMIC_PKT_RMH2r_SET(r,d) (r).cmic_pkt_rmh2[0] = d
#define BCM53324_A0_CMIC_PKT_RMH2r_GET(r) (r).cmic_pkt_rmh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_RMH2r_MH2f_GET(r) ((r).cmic_pkt_rmh2[0])
#define BCM53324_A0_CMIC_PKT_RMH2r_MH2f_SET(r,f) (r).cmic_pkt_rmh2[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMH2.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_RMH2r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_RMH2r,r._cmic_pkt_rmh2)
#define BCM53324_A0_WRITE_CMIC_PKT_RMH2r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_RMH2r,r._cmic_pkt_rmh2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMH2r BCM53324_A0_CMIC_PKT_RMH2r
#define CMIC_PKT_RMH2r_SIZE BCM53324_A0_CMIC_PKT_RMH2r_SIZE
typedef BCM53324_A0_CMIC_PKT_RMH2r_t CMIC_PKT_RMH2r_t;
#define CMIC_PKT_RMH2r_CLR BCM53324_A0_CMIC_PKT_RMH2r_CLR
#define CMIC_PKT_RMH2r_SET BCM53324_A0_CMIC_PKT_RMH2r_SET
#define CMIC_PKT_RMH2r_GET BCM53324_A0_CMIC_PKT_RMH2r_GET
#define CMIC_PKT_RMH2r_MH2f_GET BCM53324_A0_CMIC_PKT_RMH2r_MH2f_GET
#define CMIC_PKT_RMH2r_MH2f_SET BCM53324_A0_CMIC_PKT_RMH2r_MH2f_SET
#define READ_CMIC_PKT_RMH2r BCM53324_A0_READ_CMIC_PKT_RMH2r
#define WRITE_CMIC_PKT_RMH2r BCM53324_A0_WRITE_CMIC_PKT_RMH2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_RMH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_RMH3
 * BLOCKS:   CMIC
 * DESC:     Fourth DWord of the Module Header on an outpoing CMIC packet.

 * SIZE:     32
 * FIELDS:
 *     MH2              Module Header DWord 3
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_RMH3r 0x00000788

#define BCM53324_A0_CMIC_PKT_RMH3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_RMH3.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_RMH3r_s {
	uint32_t v[1];
	uint32_t cmic_pkt_rmh3[1];
	uint32_t _cmic_pkt_rmh3;
} BCM53324_A0_CMIC_PKT_RMH3r_t;

#define BCM53324_A0_CMIC_PKT_RMH3r_CLR(r) (r).cmic_pkt_rmh3[0] = 0
#define BCM53324_A0_CMIC_PKT_RMH3r_SET(r,d) (r).cmic_pkt_rmh3[0] = d
#define BCM53324_A0_CMIC_PKT_RMH3r_GET(r) (r).cmic_pkt_rmh3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_RMH3r_MH2f_GET(r) ((r).cmic_pkt_rmh3[0])
#define BCM53324_A0_CMIC_PKT_RMH3r_MH2f_SET(r,f) (r).cmic_pkt_rmh3[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_PKT_RMH3.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_RMH3r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_RMH3r,r._cmic_pkt_rmh3)
#define BCM53324_A0_WRITE_CMIC_PKT_RMH3r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_RMH3r,r._cmic_pkt_rmh3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_RMH3r BCM53324_A0_CMIC_PKT_RMH3r
#define CMIC_PKT_RMH3r_SIZE BCM53324_A0_CMIC_PKT_RMH3r_SIZE
typedef BCM53324_A0_CMIC_PKT_RMH3r_t CMIC_PKT_RMH3r_t;
#define CMIC_PKT_RMH3r_CLR BCM53324_A0_CMIC_PKT_RMH3r_CLR
#define CMIC_PKT_RMH3r_SET BCM53324_A0_CMIC_PKT_RMH3r_SET
#define CMIC_PKT_RMH3r_GET BCM53324_A0_CMIC_PKT_RMH3r_GET
#define CMIC_PKT_RMH3r_MH2f_GET BCM53324_A0_CMIC_PKT_RMH3r_MH2f_GET
#define CMIC_PKT_RMH3r_MH2f_SET BCM53324_A0_CMIC_PKT_RMH3r_MH2f_SET
#define READ_CMIC_PKT_RMH3r BCM53324_A0_READ_CMIC_PKT_RMH3r
#define WRITE_CMIC_PKT_RMH3r BCM53324_A0_WRITE_CMIC_PKT_RMH3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_RMH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_PKT_VLAN
 * BLOCKS:   CMIC
 * DESC:     CMIC Packet TPID and VLAN Tag

 * SIZE:     32
 * FIELDS:
 *     VLAN_ID          VLAN Tag
 *     TPID             TPID Value
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_PKT_VLANr 0x00000728

#define BCM53324_A0_CMIC_PKT_VLANr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_PKT_VLAN.
 *
 */
typedef union BCM53324_A0_CMIC_PKT_VLANr_s {
	uint32_t v[1];
	uint32_t cmic_pkt_vlan[1];
	uint32_t _cmic_pkt_vlan;
} BCM53324_A0_CMIC_PKT_VLANr_t;

#define BCM53324_A0_CMIC_PKT_VLANr_CLR(r) (r).cmic_pkt_vlan[0] = 0
#define BCM53324_A0_CMIC_PKT_VLANr_SET(r,d) (r).cmic_pkt_vlan[0] = d
#define BCM53324_A0_CMIC_PKT_VLANr_GET(r) (r).cmic_pkt_vlan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_PKT_VLANr_VLAN_IDf_GET(r) (((r).cmic_pkt_vlan[0]) & 0xffff)
#define BCM53324_A0_CMIC_PKT_VLANr_VLAN_IDf_SET(r,f) (r).cmic_pkt_vlan[0]=(((r).cmic_pkt_vlan[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_PKT_VLANr_TPIDf_GET(r) ((((r).cmic_pkt_vlan[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_PKT_VLANr_TPIDf_SET(r,f) (r).cmic_pkt_vlan[0]=(((r).cmic_pkt_vlan[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_PKT_VLAN.
 *
 */
#define BCM53324_A0_READ_CMIC_PKT_VLANr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_PKT_VLANr,r._cmic_pkt_vlan)
#define BCM53324_A0_WRITE_CMIC_PKT_VLANr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_PKT_VLANr,r._cmic_pkt_vlan)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_PKT_VLANr BCM53324_A0_CMIC_PKT_VLANr
#define CMIC_PKT_VLANr_SIZE BCM53324_A0_CMIC_PKT_VLANr_SIZE
typedef BCM53324_A0_CMIC_PKT_VLANr_t CMIC_PKT_VLANr_t;
#define CMIC_PKT_VLANr_CLR BCM53324_A0_CMIC_PKT_VLANr_CLR
#define CMIC_PKT_VLANr_SET BCM53324_A0_CMIC_PKT_VLANr_SET
#define CMIC_PKT_VLANr_GET BCM53324_A0_CMIC_PKT_VLANr_GET
#define CMIC_PKT_VLANr_VLAN_IDf_GET BCM53324_A0_CMIC_PKT_VLANr_VLAN_IDf_GET
#define CMIC_PKT_VLANr_VLAN_IDf_SET BCM53324_A0_CMIC_PKT_VLANr_VLAN_IDf_SET
#define CMIC_PKT_VLANr_TPIDf_GET BCM53324_A0_CMIC_PKT_VLANr_TPIDf_GET
#define CMIC_PKT_VLANr_TPIDf_SET BCM53324_A0_CMIC_PKT_VLANr_TPIDf_SET
#define READ_CMIC_PKT_VLANr BCM53324_A0_READ_CMIC_PKT_VLANr
#define WRITE_CMIC_PKT_VLANr BCM53324_A0_WRITE_CMIC_PKT_VLANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_PKT_VLANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_QGPHY_QSGMII_CONTROL
 * BLOCKS:   CMIC
 * DESC:     QGPHY_QSGMII_CONTROL
 * SIZE:     32
 * FIELDS:
 *     SEL_QSGMII_REF_CLK_SRC Selects QSGMII Reference clock source. Default is 0x0 indicatingLCPLL 156.25 MHz is selected as source clock. If set to 0x1,the reference clock is selected from the IO pins
 *     ENABLE_EXT_QGPHY_CLK_OUT Enables the 25 MHz external QGPHY reference clock out. Default is 0x0 indicatingthat the external QGPHY refclks are disabled. If set to 0x1, the outputsare enabled
 *     LINK_STATUS_SEL  Used to select the Link status from QGPHY/QSGMII serdes or from CMIC. Default is 0x0 selectingthe serdes outputs. Setting this bit to 0x1, selects the link status from CMIC
 *     SEL_LEDRAM_SERIAL_DATA When set to 1, the parallel LED interace outputs at chip level are driven from CMIC's serial LED stream rather than from LED status coming from integrated QGPHYs for ports 1 to 8.
 *     SEL_SWAP_LED_LINK_ACT_STATUS By default, uP default code dumps ACT status on [1:0] and Link status on [3:2] which is different from how phy generates status. Using this config bit, they can be swapped.
 *     EXT_QGPHY_CLK_SEL_CLK125 Select 125MHz clock instead of 25MHz clock as reference clock to external QGPHYs.
 *     QGPHY_MODE_SEL_DEF Enable reception of Jumbo Packets. By default, this is not enabled.
 *     QGPHY_EEE_DISABLE EEE feature disable for QGPHY, enabled by default
 *     QGPHY_ENABLE_BIAS_10BTE Enable QGPHY BIAS 10BTE, disabled by default
 *     DISABLE_HW_IDLE_PWRDWN Disable Hardware based idle mode power down, enabled by default
 *     DISABLE_IPEP_IDLE_PWRDWN Disable IP EP block idle mode power down, enabled by default
 *     DISABLE_MMU_IDLE_PWRDWN Disable MMU block idle mode power down, enabled by default
 *     ENABLE_SW_IDLE_PWRDWN Enable Software based idle mode power down, disabled by default
 *     ENABLE_GPORT_IDLE_PWRDWN Enable Gport block idle mode power down, disabled by default
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr 0x0000014c

#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_QGPHY_QSGMII_CONTROL.
 *
 */
typedef union BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_qgphy_qsgmii_control[1];
	uint32_t _cmic_qgphy_qsgmii_control;
} BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_t;

#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_CLR(r) (r).cmic_qgphy_qsgmii_control[0] = 0
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SET(r,d) (r).cmic_qgphy_qsgmii_control[0] = d
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_GET(r) (r).cmic_qgphy_qsgmii_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_QSGMII_REF_CLK_SRCf_GET(r) (((r).cmic_qgphy_qsgmii_control[0]) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_QSGMII_REF_CLK_SRCf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_EXT_QGPHY_CLK_OUTf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_EXT_QGPHY_CLK_OUTf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_LINK_STATUS_SELf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_LINK_STATUS_SELf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_LEDRAM_SERIAL_DATAf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_LEDRAM_SERIAL_DATAf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_SWAP_LED_LINK_ACT_STATUSf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_SWAP_LED_LINK_ACT_STATUSf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_EXT_QGPHY_CLK_SEL_CLK125f_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 5) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_EXT_QGPHY_CLK_SEL_CLK125f_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_MODE_SEL_DEFf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 6) & 0x3)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_MODE_SEL_DEFf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_EEE_DISABLEf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_EEE_DISABLEf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_ENABLE_BIAS_10BTEf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_ENABLE_BIAS_10BTEf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_HW_IDLE_PWRDWNf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 10) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_HW_IDLE_PWRDWNf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_IPEP_IDLE_PWRDWNf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 11) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_IPEP_IDLE_PWRDWNf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_MMU_IDLE_PWRDWNf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 12) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_MMU_IDLE_PWRDWNf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_SW_IDLE_PWRDWNf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_SW_IDLE_PWRDWNf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_GPORT_IDLE_PWRDWNf_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 14) & 0x1)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_GPORT_IDLE_PWRDWNf_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_RESERVED_1f_GET(r) ((((r).cmic_qgphy_qsgmii_control[0]) >> 15) & 0x1ffff)
#define BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_RESERVED_1f_SET(r,f) (r).cmic_qgphy_qsgmii_control[0]=(((r).cmic_qgphy_qsgmii_control[0] & ~((uint32_t)0x1ffff << 15)) | ((((uint32_t)f) & 0x1ffff) << 15))

/*
 * These macros can be used to access CMIC_QGPHY_QSGMII_CONTROL.
 *
 */
#define BCM53324_A0_READ_CMIC_QGPHY_QSGMII_CONTROLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr,r._cmic_qgphy_qsgmii_control)
#define BCM53324_A0_WRITE_CMIC_QGPHY_QSGMII_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr,r._cmic_qgphy_qsgmii_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_QGPHY_QSGMII_CONTROLr BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr
#define CMIC_QGPHY_QSGMII_CONTROLr_SIZE BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SIZE
typedef BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_t CMIC_QGPHY_QSGMII_CONTROLr_t;
#define CMIC_QGPHY_QSGMII_CONTROLr_CLR BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_CLR
#define CMIC_QGPHY_QSGMII_CONTROLr_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_SEL_QSGMII_REF_CLK_SRCf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_QSGMII_REF_CLK_SRCf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_SEL_QSGMII_REF_CLK_SRCf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_QSGMII_REF_CLK_SRCf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_EXT_QGPHY_CLK_OUTf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_EXT_QGPHY_CLK_OUTf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_EXT_QGPHY_CLK_OUTf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_EXT_QGPHY_CLK_OUTf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_LINK_STATUS_SELf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_LINK_STATUS_SELf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_LINK_STATUS_SELf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_LINK_STATUS_SELf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_SEL_LEDRAM_SERIAL_DATAf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_LEDRAM_SERIAL_DATAf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_SEL_LEDRAM_SERIAL_DATAf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_LEDRAM_SERIAL_DATAf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_SEL_SWAP_LED_LINK_ACT_STATUSf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_SWAP_LED_LINK_ACT_STATUSf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_SEL_SWAP_LED_LINK_ACT_STATUSf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_SEL_SWAP_LED_LINK_ACT_STATUSf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_EXT_QGPHY_CLK_SEL_CLK125f_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_EXT_QGPHY_CLK_SEL_CLK125f_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_EXT_QGPHY_CLK_SEL_CLK125f_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_EXT_QGPHY_CLK_SEL_CLK125f_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_MODE_SEL_DEFf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_MODE_SEL_DEFf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_MODE_SEL_DEFf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_MODE_SEL_DEFf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_EEE_DISABLEf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_EEE_DISABLEf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_EEE_DISABLEf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_EEE_DISABLEf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_ENABLE_BIAS_10BTEf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_ENABLE_BIAS_10BTEf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_ENABLE_BIAS_10BTEf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_QGPHY_ENABLE_BIAS_10BTEf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_HW_IDLE_PWRDWNf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_HW_IDLE_PWRDWNf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_HW_IDLE_PWRDWNf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_HW_IDLE_PWRDWNf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_IPEP_IDLE_PWRDWNf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_IPEP_IDLE_PWRDWNf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_IPEP_IDLE_PWRDWNf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_IPEP_IDLE_PWRDWNf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_MMU_IDLE_PWRDWNf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_MMU_IDLE_PWRDWNf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_MMU_IDLE_PWRDWNf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_DISABLE_MMU_IDLE_PWRDWNf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_SW_IDLE_PWRDWNf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_SW_IDLE_PWRDWNf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_SW_IDLE_PWRDWNf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_SW_IDLE_PWRDWNf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_GPORT_IDLE_PWRDWNf_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_GPORT_IDLE_PWRDWNf_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_GPORT_IDLE_PWRDWNf_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_ENABLE_GPORT_IDLE_PWRDWNf_SET
#define CMIC_QGPHY_QSGMII_CONTROLr_RESERVED_1f_GET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_RESERVED_1f_GET
#define CMIC_QGPHY_QSGMII_CONTROLr_RESERVED_1f_SET BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr_RESERVED_1f_SET
#define READ_CMIC_QGPHY_QSGMII_CONTROLr BCM53324_A0_READ_CMIC_QGPHY_QSGMII_CONTROLr
#define WRITE_CMIC_QGPHY_QSGMII_CONTROLr BCM53324_A0_WRITE_CMIC_QGPHY_QSGMII_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_QGPHY_QSGMII_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_RATE_ADJUST
 * BLOCKS:   CMIC
 * DESC:     The clock divider configuration register for External MDIO.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_RATE_ADJUSTr 0x000001b8

#define BCM53324_A0_CMIC_RATE_ADJUSTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST.
 *
 */
typedef union BCM53324_A0_CMIC_RATE_ADJUSTr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust[1];
	uint32_t _cmic_rate_adjust;
} BCM53324_A0_CMIC_RATE_ADJUSTr_t;

#define BCM53324_A0_CMIC_RATE_ADJUSTr_CLR(r) (r).cmic_rate_adjust[0] = 0
#define BCM53324_A0_CMIC_RATE_ADJUSTr_SET(r,d) (r).cmic_rate_adjust[0] = d
#define BCM53324_A0_CMIC_RATE_ADJUSTr_GET(r) (r).cmic_rate_adjust[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_RATE_ADJUSTr_DIVISORf_GET(r) (((r).cmic_rate_adjust[0]) & 0xffff)
#define BCM53324_A0_CMIC_RATE_ADJUSTr_DIVISORf_SET(r,f) (r).cmic_rate_adjust[0]=(((r).cmic_rate_adjust[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust[0]=(((r).cmic_rate_adjust[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST.
 *
 */
#define BCM53324_A0_READ_CMIC_RATE_ADJUSTr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_RATE_ADJUSTr,r._cmic_rate_adjust)
#define BCM53324_A0_WRITE_CMIC_RATE_ADJUSTr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_RATE_ADJUSTr,r._cmic_rate_adjust)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUSTr BCM53324_A0_CMIC_RATE_ADJUSTr
#define CMIC_RATE_ADJUSTr_SIZE BCM53324_A0_CMIC_RATE_ADJUSTr_SIZE
typedef BCM53324_A0_CMIC_RATE_ADJUSTr_t CMIC_RATE_ADJUSTr_t;
#define CMIC_RATE_ADJUSTr_CLR BCM53324_A0_CMIC_RATE_ADJUSTr_CLR
#define CMIC_RATE_ADJUSTr_SET BCM53324_A0_CMIC_RATE_ADJUSTr_SET
#define CMIC_RATE_ADJUSTr_GET BCM53324_A0_CMIC_RATE_ADJUSTr_GET
#define CMIC_RATE_ADJUSTr_DIVISORf_GET BCM53324_A0_CMIC_RATE_ADJUSTr_DIVISORf_GET
#define CMIC_RATE_ADJUSTr_DIVISORf_SET BCM53324_A0_CMIC_RATE_ADJUSTr_DIVISORf_SET
#define CMIC_RATE_ADJUSTr_DIVIDENDf_GET BCM53324_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_GET
#define CMIC_RATE_ADJUSTr_DIVIDENDf_SET BCM53324_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUSTr BCM53324_A0_READ_CMIC_RATE_ADJUSTr
#define WRITE_CMIC_RATE_ADJUSTr BCM53324_A0_WRITE_CMIC_RATE_ADJUSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_RATE_ADJUSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_RATE_ADJUST_I2C
 * BLOCKS:   CMIC
 * DESC:     The clock divider configuration register for I2C.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr 0x000001b4

#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST_I2C.
 *
 */
typedef union BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust_i2c[1];
	uint32_t _cmic_rate_adjust_i2c;
} BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_t;

#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_CLR(r) (r).cmic_rate_adjust_i2c[0] = 0
#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_SET(r,d) (r).cmic_rate_adjust_i2c[0] = d
#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_GET(r) (r).cmic_rate_adjust_i2c[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_DIVISORf_GET(r) (((r).cmic_rate_adjust_i2c[0]) & 0xffff)
#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_DIVISORf_SET(r,f) (r).cmic_rate_adjust_i2c[0]=(((r).cmic_rate_adjust_i2c[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust_i2c[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust_i2c[0]=(((r).cmic_rate_adjust_i2c[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST_I2C.
 *
 */
#define BCM53324_A0_READ_CMIC_RATE_ADJUST_I2Cr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_RATE_ADJUST_I2Cr,r._cmic_rate_adjust_i2c)
#define BCM53324_A0_WRITE_CMIC_RATE_ADJUST_I2Cr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_RATE_ADJUST_I2Cr,r._cmic_rate_adjust_i2c)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUST_I2Cr BCM53324_A0_CMIC_RATE_ADJUST_I2Cr
#define CMIC_RATE_ADJUST_I2Cr_SIZE BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_SIZE
typedef BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_t CMIC_RATE_ADJUST_I2Cr_t;
#define CMIC_RATE_ADJUST_I2Cr_CLR BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_CLR
#define CMIC_RATE_ADJUST_I2Cr_SET BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_SET
#define CMIC_RATE_ADJUST_I2Cr_GET BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_GET
#define CMIC_RATE_ADJUST_I2Cr_DIVISORf_GET BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_DIVISORf_GET
#define CMIC_RATE_ADJUST_I2Cr_DIVISORf_SET BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_DIVISORf_SET
#define CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_GET BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_GET
#define CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_SET BCM53324_A0_CMIC_RATE_ADJUST_I2Cr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUST_I2Cr BCM53324_A0_READ_CMIC_RATE_ADJUST_I2Cr
#define WRITE_CMIC_RATE_ADJUST_I2Cr BCM53324_A0_WRITE_CMIC_RATE_ADJUST_I2Cr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_RATE_ADJUST_I2Cr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_RATE_ADJUST_INT_MDIO
 * BLOCKS:   CMIC
 * DESC:     The clock divider configuration register for Internal MDIO.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr 0x000001bc

#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST_INT_MDIO.
 *
 */
typedef union BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust_int_mdio[1];
	uint32_t _cmic_rate_adjust_int_mdio;
} BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_t;

#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_CLR(r) (r).cmic_rate_adjust_int_mdio[0] = 0
#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_SET(r,d) (r).cmic_rate_adjust_int_mdio[0] = d
#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_GET(r) (r).cmic_rate_adjust_int_mdio[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_GET(r) (((r).cmic_rate_adjust_int_mdio[0]) & 0xffff)
#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_SET(r,f) (r).cmic_rate_adjust_int_mdio[0]=(((r).cmic_rate_adjust_int_mdio[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust_int_mdio[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust_int_mdio[0]=(((r).cmic_rate_adjust_int_mdio[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST_INT_MDIO.
 *
 */
#define BCM53324_A0_READ_CMIC_RATE_ADJUST_INT_MDIOr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr,r._cmic_rate_adjust_int_mdio)
#define BCM53324_A0_WRITE_CMIC_RATE_ADJUST_INT_MDIOr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr,r._cmic_rate_adjust_int_mdio)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUST_INT_MDIOr BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr
#define CMIC_RATE_ADJUST_INT_MDIOr_SIZE BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_SIZE
typedef BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_t CMIC_RATE_ADJUST_INT_MDIOr_t;
#define CMIC_RATE_ADJUST_INT_MDIOr_CLR BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_CLR
#define CMIC_RATE_ADJUST_INT_MDIOr_SET BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_SET
#define CMIC_RATE_ADJUST_INT_MDIOr_GET BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_GET
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_GET BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_GET
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_SET BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVISORf_SET
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_GET BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_GET
#define CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_SET BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUST_INT_MDIOr BCM53324_A0_READ_CMIC_RATE_ADJUST_INT_MDIOr
#define WRITE_CMIC_RATE_ADJUST_INT_MDIOr BCM53324_A0_WRITE_CMIC_RATE_ADJUST_INT_MDIOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_RATE_ADJUST_INT_MDIOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_RATE_ADJUST_STDMA
 * BLOCKS:   CMIC
 * DESC:     
The clock divider configuration register for Stats DMA.

Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr 0x000001b0

#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST_STDMA.
 *
 */
typedef union BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust_stdma[1];
	uint32_t _cmic_rate_adjust_stdma;
} BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_t;

#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_CLR(r) (r).cmic_rate_adjust_stdma[0] = 0
#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_SET(r,d) (r).cmic_rate_adjust_stdma[0] = d
#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_GET(r) (r).cmic_rate_adjust_stdma[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_DIVISORf_GET(r) (((r).cmic_rate_adjust_stdma[0]) & 0xffff)
#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_DIVISORf_SET(r,f) (r).cmic_rate_adjust_stdma[0]=(((r).cmic_rate_adjust_stdma[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust_stdma[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust_stdma[0]=(((r).cmic_rate_adjust_stdma[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST_STDMA.
 *
 */
#define BCM53324_A0_READ_CMIC_RATE_ADJUST_STDMAr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_RATE_ADJUST_STDMAr,r._cmic_rate_adjust_stdma)
#define BCM53324_A0_WRITE_CMIC_RATE_ADJUST_STDMAr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_RATE_ADJUST_STDMAr,r._cmic_rate_adjust_stdma)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUST_STDMAr BCM53324_A0_CMIC_RATE_ADJUST_STDMAr
#define CMIC_RATE_ADJUST_STDMAr_SIZE BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_SIZE
typedef BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_t CMIC_RATE_ADJUST_STDMAr_t;
#define CMIC_RATE_ADJUST_STDMAr_CLR BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_CLR
#define CMIC_RATE_ADJUST_STDMAr_SET BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_SET
#define CMIC_RATE_ADJUST_STDMAr_GET BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_GET
#define CMIC_RATE_ADJUST_STDMAr_DIVISORf_GET BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_DIVISORf_GET
#define CMIC_RATE_ADJUST_STDMAr_DIVISORf_SET BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_DIVISORf_SET
#define CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_GET BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_GET
#define CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_SET BCM53324_A0_CMIC_RATE_ADJUST_STDMAr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUST_STDMAr BCM53324_A0_READ_CMIC_RATE_ADJUST_STDMAr
#define WRITE_CMIC_RATE_ADJUST_STDMAr BCM53324_A0_WRITE_CMIC_RATE_ADJUST_STDMAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_RATE_ADJUST_STDMAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_RX_PAUSE_CAPABILITY
 * BLOCKS:   CMIC
 * DESC:     S/W can use this register to update rx pause capability information instead of using pause scan.S/W can override rx pause scan data with this register value by configuring pause override registers.
 * SIZE:     32
 * FIELDS:
 *     RX_PAUSE_CAPABILITY RX_PAUSE_CAPABILITY programmed by S/W
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr 0x00000d58

#define BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RX_PAUSE_CAPABILITY.
 *
 */
typedef union BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_s {
	uint32_t v[1];
	uint32_t cmic_rx_pause_capability[1];
	uint32_t _cmic_rx_pause_capability;
} BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_t;

#define BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_CLR(r) (r).cmic_rx_pause_capability[0] = 0
#define BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_SET(r,d) (r).cmic_rx_pause_capability[0] = d
#define BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_GET(r) (r).cmic_rx_pause_capability[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_RX_PAUSE_CAPABILITYf_GET(r) ((r).cmic_rx_pause_capability[0])
#define BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_RX_PAUSE_CAPABILITYf_SET(r,f) (r).cmic_rx_pause_capability[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_RX_PAUSE_CAPABILITY.
 *
 */
#define BCM53324_A0_READ_CMIC_RX_PAUSE_CAPABILITYr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr,r._cmic_rx_pause_capability)
#define BCM53324_A0_WRITE_CMIC_RX_PAUSE_CAPABILITYr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr,r._cmic_rx_pause_capability)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RX_PAUSE_CAPABILITYr BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr
#define CMIC_RX_PAUSE_CAPABILITYr_SIZE BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_SIZE
typedef BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_t CMIC_RX_PAUSE_CAPABILITYr_t;
#define CMIC_RX_PAUSE_CAPABILITYr_CLR BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_CLR
#define CMIC_RX_PAUSE_CAPABILITYr_SET BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_SET
#define CMIC_RX_PAUSE_CAPABILITYr_GET BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_GET
#define CMIC_RX_PAUSE_CAPABILITYr_RX_PAUSE_CAPABILITYf_GET BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_RX_PAUSE_CAPABILITYf_GET
#define CMIC_RX_PAUSE_CAPABILITYr_RX_PAUSE_CAPABILITYf_SET BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr_RX_PAUSE_CAPABILITYf_SET
#define READ_CMIC_RX_PAUSE_CAPABILITYr BCM53324_A0_READ_CMIC_RX_PAUSE_CAPABILITYr
#define WRITE_CMIC_RX_PAUSE_CAPABILITYr BCM53324_A0_WRITE_CMIC_RX_PAUSE_CAPABILITYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_RX_PAUSE_CAPABILITYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_RX_PAUSE_OVERRIDE_CONTROL
 * BLOCKS:   CMIC
 * DESC:     If Nth bit is set in this register, Nth port RX pause status will be taken from RX_PAUSE_CAPABILITY register else from rx scan result.
 * SIZE:     32
 * FIELDS:
 *     RX_PAUSE_OVERRIDE_CONTROL RX_PAUSE_OVERRIDE_CONTROL
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr 0x00000d60

#define BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RX_PAUSE_OVERRIDE_CONTROL.
 *
 */
typedef union BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_rx_pause_override_control[1];
	uint32_t _cmic_rx_pause_override_control;
} BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_t;

#define BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_CLR(r) (r).cmic_rx_pause_override_control[0] = 0
#define BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_SET(r,d) (r).cmic_rx_pause_override_control[0] = d
#define BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_GET(r) (r).cmic_rx_pause_override_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_RX_PAUSE_OVERRIDE_CONTROLf_GET(r) ((r).cmic_rx_pause_override_control[0])
#define BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_RX_PAUSE_OVERRIDE_CONTROLf_SET(r,f) (r).cmic_rx_pause_override_control[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_RX_PAUSE_OVERRIDE_CONTROL.
 *
 */
#define BCM53324_A0_READ_CMIC_RX_PAUSE_OVERRIDE_CONTROLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr,r._cmic_rx_pause_override_control)
#define BCM53324_A0_WRITE_CMIC_RX_PAUSE_OVERRIDE_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr,r._cmic_rx_pause_override_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RX_PAUSE_OVERRIDE_CONTROLr BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr
#define CMIC_RX_PAUSE_OVERRIDE_CONTROLr_SIZE BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_SIZE
typedef BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_t CMIC_RX_PAUSE_OVERRIDE_CONTROLr_t;
#define CMIC_RX_PAUSE_OVERRIDE_CONTROLr_CLR BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_CLR
#define CMIC_RX_PAUSE_OVERRIDE_CONTROLr_SET BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_SET
#define CMIC_RX_PAUSE_OVERRIDE_CONTROLr_GET BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_GET
#define CMIC_RX_PAUSE_OVERRIDE_CONTROLr_RX_PAUSE_OVERRIDE_CONTROLf_GET BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_RX_PAUSE_OVERRIDE_CONTROLf_GET
#define CMIC_RX_PAUSE_OVERRIDE_CONTROLr_RX_PAUSE_OVERRIDE_CONTROLf_SET BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr_RX_PAUSE_OVERRIDE_CONTROLf_SET
#define READ_CMIC_RX_PAUSE_OVERRIDE_CONTROLr BCM53324_A0_READ_CMIC_RX_PAUSE_OVERRIDE_CONTROLr
#define WRITE_CMIC_RX_PAUSE_OVERRIDE_CONTROLr BCM53324_A0_WRITE_CMIC_RX_PAUSE_OVERRIDE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_RX_PAUSE_OVERRIDE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_RX_PAUSE_STAT
 * BLOCKS:   CMIC
 * DESC:     CMIC RX pause scan ports
 * SIZE:     32
 * FIELDS:
 *     PAUSE_STAT       If bit n is set, port-n can handle pause frames otherwise it can not handle pause frames
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_RX_PAUSE_STATr 0x00000d40

#define BCM53324_A0_CMIC_RX_PAUSE_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RX_PAUSE_STAT.
 *
 */
typedef union BCM53324_A0_CMIC_RX_PAUSE_STATr_s {
	uint32_t v[1];
	uint32_t cmic_rx_pause_stat[1];
	uint32_t _cmic_rx_pause_stat;
} BCM53324_A0_CMIC_RX_PAUSE_STATr_t;

#define BCM53324_A0_CMIC_RX_PAUSE_STATr_CLR(r) (r).cmic_rx_pause_stat[0] = 0
#define BCM53324_A0_CMIC_RX_PAUSE_STATr_SET(r,d) (r).cmic_rx_pause_stat[0] = d
#define BCM53324_A0_CMIC_RX_PAUSE_STATr_GET(r) (r).cmic_rx_pause_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_RX_PAUSE_STATr_PAUSE_STATf_GET(r) ((r).cmic_rx_pause_stat[0])
#define BCM53324_A0_CMIC_RX_PAUSE_STATr_PAUSE_STATf_SET(r,f) (r).cmic_rx_pause_stat[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_RX_PAUSE_STAT.
 *
 */
#define BCM53324_A0_READ_CMIC_RX_PAUSE_STATr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_RX_PAUSE_STATr,r._cmic_rx_pause_stat)
#define BCM53324_A0_WRITE_CMIC_RX_PAUSE_STATr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_RX_PAUSE_STATr,r._cmic_rx_pause_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RX_PAUSE_STATr BCM53324_A0_CMIC_RX_PAUSE_STATr
#define CMIC_RX_PAUSE_STATr_SIZE BCM53324_A0_CMIC_RX_PAUSE_STATr_SIZE
typedef BCM53324_A0_CMIC_RX_PAUSE_STATr_t CMIC_RX_PAUSE_STATr_t;
#define CMIC_RX_PAUSE_STATr_CLR BCM53324_A0_CMIC_RX_PAUSE_STATr_CLR
#define CMIC_RX_PAUSE_STATr_SET BCM53324_A0_CMIC_RX_PAUSE_STATr_SET
#define CMIC_RX_PAUSE_STATr_GET BCM53324_A0_CMIC_RX_PAUSE_STATr_GET
#define CMIC_RX_PAUSE_STATr_PAUSE_STATf_GET BCM53324_A0_CMIC_RX_PAUSE_STATr_PAUSE_STATf_GET
#define CMIC_RX_PAUSE_STATr_PAUSE_STATf_SET BCM53324_A0_CMIC_RX_PAUSE_STATr_PAUSE_STATf_SET
#define READ_CMIC_RX_PAUSE_STATr BCM53324_A0_READ_CMIC_RX_PAUSE_STATr
#define WRITE_CMIC_RX_PAUSE_STATr BCM53324_A0_WRITE_CMIC_RX_PAUSE_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_RX_PAUSE_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SBUS_RING_MAP
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents on all 3 S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_0 S-bus ring number for agent with S-bus ID  0
 *     RING_NUM_SBUS_ID_1 S-bus ring number for agent with S-bus ID  1
 *     RING_NUM_SBUS_ID_2 S-bus ring number for agent with S-bus ID  2
 *     RING_NUM_SBUS_ID_3 S-bus ring number for agent with S-bus ID  3
 *     RING_NUM_SBUS_ID_4 S-bus ring number for agent with S-bus ID  4
 *     RING_NUM_SBUS_ID_5 S-bus ring number for agent with S-bus ID  5
 *     RING_NUM_SBUS_ID_6 S-bus ring number for agent with S-bus ID  6
 *     RING_NUM_SBUS_ID_7 S-bus ring number for agent with S-bus ID  7
 *     RING_NUM_SBUS_ID_8 S-bus ring number for agent with S-bus ID  8
 *     RING_NUM_SBUS_ID_9 S-bus ring number for agent with S-bus ID  9
 *     RING_NUM_SBUS_ID_10 S-bus ring number for agent with S-bus ID 10
 *     RING_NUM_SBUS_ID_11 S-bus ring number for agent with S-bus ID 11
 *     RING_NUM_SBUS_ID_12 S-bus ring number for agent with S-bus ID 12
 *     RING_NUM_SBUS_ID_13 S-bus ring number for agent with S-bus ID 13
 *     RING_NUM_SBUS_ID_14 S-bus ring number for agent with S-bus ID 14
 *     RING_NUM_SBUS_ID_15 S-bus ring number for agent with S-bus ID 15
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SBUS_RING_MAPr 0x00000400

#define BCM53324_A0_CMIC_SBUS_RING_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP.
 *
 */
typedef union BCM53324_A0_CMIC_SBUS_RING_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_sbus_ring_map[1];
	uint32_t _cmic_sbus_ring_map;
} BCM53324_A0_CMIC_SBUS_RING_MAPr_t;

#define BCM53324_A0_CMIC_SBUS_RING_MAPr_CLR(r) (r).cmic_sbus_ring_map[0] = 0
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_SET(r,d) (r).cmic_sbus_ring_map[0] = d
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_GET(r) (r).cmic_sbus_ring_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET(r) (((r).cmic_sbus_ring_map[0]) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 2) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 4) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 6) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 8) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 10) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 12) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 14) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 16) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 18) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 20) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 22) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 24) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 26) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 28) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP.
 *
 */
#define BCM53324_A0_READ_CMIC_SBUS_RING_MAPr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SBUS_RING_MAPr,r._cmic_sbus_ring_map)
#define BCM53324_A0_WRITE_CMIC_SBUS_RING_MAPr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SBUS_RING_MAPr,r._cmic_sbus_ring_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SBUS_RING_MAPr BCM53324_A0_CMIC_SBUS_RING_MAPr
#define CMIC_SBUS_RING_MAPr_SIZE BCM53324_A0_CMIC_SBUS_RING_MAPr_SIZE
typedef BCM53324_A0_CMIC_SBUS_RING_MAPr_t CMIC_SBUS_RING_MAPr_t;
#define CMIC_SBUS_RING_MAPr_CLR BCM53324_A0_CMIC_SBUS_RING_MAPr_CLR
#define CMIC_SBUS_RING_MAPr_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_SET
#define CMIC_SBUS_RING_MAPr_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET BCM53324_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET
#define READ_CMIC_SBUS_RING_MAPr BCM53324_A0_READ_CMIC_SBUS_RING_MAPr
#define WRITE_CMIC_SBUS_RING_MAPr BCM53324_A0_WRITE_CMIC_SBUS_RING_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SBUS_RING_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SBUS_TIMEOUT
 * BLOCKS:   CMIC
 * DESC:     Secret register that allows software to program the
S-bus operation completion time limit (in terms of 
number of core clocks).
If this limit is exceeded, the CMIC will set the SW PIO
"DONE" bit and the "ERROR" bit to indicate the timeout.

 * SIZE:     32
 * FIELDS:
 *     TIMEOUT_VAL      Timeout value in core clocks
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SBUS_TIMEOUTr 0x00000408

#define BCM53324_A0_CMIC_SBUS_TIMEOUTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_TIMEOUT.
 *
 */
typedef union BCM53324_A0_CMIC_SBUS_TIMEOUTr_s {
	uint32_t v[1];
	uint32_t cmic_sbus_timeout[1];
	uint32_t _cmic_sbus_timeout;
} BCM53324_A0_CMIC_SBUS_TIMEOUTr_t;

#define BCM53324_A0_CMIC_SBUS_TIMEOUTr_CLR(r) (r).cmic_sbus_timeout[0] = 0
#define BCM53324_A0_CMIC_SBUS_TIMEOUTr_SET(r,d) (r).cmic_sbus_timeout[0] = d
#define BCM53324_A0_CMIC_SBUS_TIMEOUTr_GET(r) (r).cmic_sbus_timeout[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET(r) ((r).cmic_sbus_timeout[0])
#define BCM53324_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET(r,f) (r).cmic_sbus_timeout[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SBUS_TIMEOUT.
 *
 */
#define BCM53324_A0_READ_CMIC_SBUS_TIMEOUTr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SBUS_TIMEOUTr,r._cmic_sbus_timeout)
#define BCM53324_A0_WRITE_CMIC_SBUS_TIMEOUTr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SBUS_TIMEOUTr,r._cmic_sbus_timeout)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SBUS_TIMEOUTr BCM53324_A0_CMIC_SBUS_TIMEOUTr
#define CMIC_SBUS_TIMEOUTr_SIZE BCM53324_A0_CMIC_SBUS_TIMEOUTr_SIZE
typedef BCM53324_A0_CMIC_SBUS_TIMEOUTr_t CMIC_SBUS_TIMEOUTr_t;
#define CMIC_SBUS_TIMEOUTr_CLR BCM53324_A0_CMIC_SBUS_TIMEOUTr_CLR
#define CMIC_SBUS_TIMEOUTr_SET BCM53324_A0_CMIC_SBUS_TIMEOUTr_SET
#define CMIC_SBUS_TIMEOUTr_GET BCM53324_A0_CMIC_SBUS_TIMEOUTr_GET
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET BCM53324_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET BCM53324_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET
#define READ_CMIC_SBUS_TIMEOUTr BCM53324_A0_READ_CMIC_SBUS_TIMEOUTr
#define WRITE_CMIC_SBUS_TIMEOUTr BCM53324_A0_WRITE_CMIC_SBUS_TIMEOUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SBUS_TIMEOUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SCAN_PORTS
 * BLOCKS:   CMIC
 * DESC:     Scan Ports Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      SCAN ports Register
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SCAN_PORTSr 0x00000160

#define BCM53324_A0_CMIC_SCAN_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCAN_PORTS.
 *
 */
typedef union BCM53324_A0_CMIC_SCAN_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_scan_ports[1];
	uint32_t _cmic_scan_ports;
} BCM53324_A0_CMIC_SCAN_PORTSr_t;

#define BCM53324_A0_CMIC_SCAN_PORTSr_CLR(r) (r).cmic_scan_ports[0] = 0
#define BCM53324_A0_CMIC_SCAN_PORTSr_SET(r,d) (r).cmic_scan_ports[0] = d
#define BCM53324_A0_CMIC_SCAN_PORTSr_GET(r) (r).cmic_scan_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_GET(r) ((r).cmic_scan_ports[0])
#define BCM53324_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_SET(r,f) (r).cmic_scan_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCAN_PORTS.
 *
 */
#define BCM53324_A0_READ_CMIC_SCAN_PORTSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SCAN_PORTSr,r._cmic_scan_ports)
#define BCM53324_A0_WRITE_CMIC_SCAN_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SCAN_PORTSr,r._cmic_scan_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCAN_PORTSr BCM53324_A0_CMIC_SCAN_PORTSr
#define CMIC_SCAN_PORTSr_SIZE BCM53324_A0_CMIC_SCAN_PORTSr_SIZE
typedef BCM53324_A0_CMIC_SCAN_PORTSr_t CMIC_SCAN_PORTSr_t;
#define CMIC_SCAN_PORTSr_CLR BCM53324_A0_CMIC_SCAN_PORTSr_CLR
#define CMIC_SCAN_PORTSr_SET BCM53324_A0_CMIC_SCAN_PORTSr_SET
#define CMIC_SCAN_PORTSr_GET BCM53324_A0_CMIC_SCAN_PORTSr_GET
#define CMIC_SCAN_PORTSr_PORT_BITMAPf_GET BCM53324_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_GET
#define CMIC_SCAN_PORTSr_PORT_BITMAPf_SET BCM53324_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_SET
#define READ_CMIC_SCAN_PORTSr BCM53324_A0_READ_CMIC_SCAN_PORTSr
#define WRITE_CMIC_SCAN_PORTSr BCM53324_A0_WRITE_CMIC_SCAN_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SCAN_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SCHAN_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     MSG_START        Set by CPU to start an SCH operation
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion
 *     RESERVED_1       Reserved
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *     LINK_STATUS_CHANGE Set by CMIC to indicate Link status changed
 *     PCI_FATAL_ERR    Set by CMIC to indicate a Fatal Error during PCI master Operation
 *     PCI_PARITY_ERR   Set by CMIC to indicate a Parity Error during PCI master Operation
 *     TX_PAUSE_STATUS_CHANGE Set by CMIC to indicate pause status changed
 *     RX_PAUSE_STATUS_CHANGE Set by CMIC to indicate pause status changed
 *     RESERVED_3       Reserved
 *     MIIM_SCAN_BUSY   Set by CMIC indicating that MIIM scan cycle is in progress
 *     RESERVED_4       Reserved
 *     MIIM_RD_START    Set by CPU to start a Read operation on MIIM Interface
 *     MIIM_WR_START    Set by CPU to start a Write operation on MIIM Interface
 *     MIIM_OP_DONE     Set by CMIC to indicate Completion of MIIM Rd/Wr Operation
 *     MIIM_LINK_SCAN_EN Set by CPU to start automatic Link Status scanning
 *     MIIM_PAUSE_SCAN_EN MIIM_LINK_PAUSE_SCAN_EN
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *     RESERVED_6       Reserved
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SCHAN_CTRLr 0x00000050

#define BCM53324_A0_CMIC_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_CTRL.
 *
 */
typedef union BCM53324_A0_CMIC_SCHAN_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_schan_ctrl[1];
	uint32_t _cmic_schan_ctrl;
} BCM53324_A0_CMIC_SCHAN_CTRLr_t;

#define BCM53324_A0_CMIC_SCHAN_CTRLr_CLR(r) (r).cmic_schan_ctrl[0] = 0
#define BCM53324_A0_CMIC_SCHAN_CTRLr_SET(r,d) (r).cmic_schan_ctrl[0] = d
#define BCM53324_A0_CMIC_SCHAN_CTRLr_GET(r) (r).cmic_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SCHAN_CTRLr_BIT_POSf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1f)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_BIT_POSf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 2) & 0x3f)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_BIT_VALf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_BIT_VALf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 10) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_TX_PAUSE_STATUS_CHANGEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 11) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_TX_PAUSE_STATUS_CHANGEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RX_PAUSE_STATUS_CHANGEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 12) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RX_PAUSE_STATUS_CHANGEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 14) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 15) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 16) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 17) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 18) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 19) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_PAUSE_SCAN_ENf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 20) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_PAUSE_SCAN_ENf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 21) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x3ff)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))
#define BCM53324_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access CMIC_SCHAN_CTRL.
 *
 */
#define BCM53324_A0_READ_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)
#define BCM53324_A0_WRITE_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_CTRLr BCM53324_A0_CMIC_SCHAN_CTRLr
#define CMIC_SCHAN_CTRLr_SIZE BCM53324_A0_CMIC_SCHAN_CTRLr_SIZE
typedef BCM53324_A0_CMIC_SCHAN_CTRLr_t CMIC_SCHAN_CTRLr_t;
#define CMIC_SCHAN_CTRLr_CLR BCM53324_A0_CMIC_SCHAN_CTRLr_CLR
#define CMIC_SCHAN_CTRLr_SET BCM53324_A0_CMIC_SCHAN_CTRLr_SET
#define CMIC_SCHAN_CTRLr_GET BCM53324_A0_CMIC_SCHAN_CTRLr_GET
#define CMIC_SCHAN_CTRLr_BIT_POSf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_BIT_POSf_GET
#define CMIC_SCHAN_CTRLr_BIT_POSf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_BIT_POSf_SET
#define CMIC_SCHAN_CTRLr_MSG_STARTf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_GET
#define CMIC_SCHAN_CTRLr_MSG_STARTf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_SET
#define CMIC_SCHAN_CTRLr_MSG_DONEf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_GET
#define CMIC_SCHAN_CTRLr_MSG_DONEf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_1f_GET BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_1f_SET BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_SET
#define CMIC_SCHAN_CTRLr_BIT_VALf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_BIT_VALf_GET
#define CMIC_SCHAN_CTRLr_BIT_VALf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_BIT_VALf_SET
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET
#define CMIC_SCHAN_CTRLr_TX_PAUSE_STATUS_CHANGEf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_TX_PAUSE_STATUS_CHANGEf_GET
#define CMIC_SCHAN_CTRLr_TX_PAUSE_STATUS_CHANGEf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_TX_PAUSE_STATUS_CHANGEf_SET
#define CMIC_SCHAN_CTRLr_RX_PAUSE_STATUS_CHANGEf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_RX_PAUSE_STATUS_CHANGEf_GET
#define CMIC_SCHAN_CTRLr_RX_PAUSE_STATUS_CHANGEf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_RX_PAUSE_STATUS_CHANGEf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_3f_GET BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_3f_SET BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_SET
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_4f_GET BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_4f_SET BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_SET
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET
#define CMIC_SCHAN_CTRLr_MIIM_PAUSE_SCAN_ENf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_PAUSE_SCAN_ENf_GET
#define CMIC_SCHAN_CTRLr_MIIM_PAUSE_SCAN_ENf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_MIIM_PAUSE_SCAN_ENf_SET
#define CMIC_SCHAN_CTRLr_NACKf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_NACKf_GET
#define CMIC_SCHAN_CTRLr_NACKf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_NACKf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_6f_GET BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_6f_SET BCM53324_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_SET
#define CMIC_SCHAN_CTRLr_TIMEOUTf_GET BCM53324_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_GET
#define CMIC_SCHAN_CTRLr_TIMEOUTf_SET BCM53324_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_SET
#define READ_CMIC_SCHAN_CTRLr BCM53324_A0_READ_CMIC_SCHAN_CTRLr
#define WRITE_CMIC_SCHAN_CTRLr BCM53324_A0_WRITE_CMIC_SCHAN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SCHAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SCHAN_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     RESERVED_1       Reserved
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SCHAN_ERRr 0x0000005c

#define BCM53324_A0_CMIC_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_ERR.
 *
 */
typedef union BCM53324_A0_CMIC_SCHAN_ERRr_s {
	uint32_t v[1];
	uint32_t cmic_schan_err[1];
	uint32_t _cmic_schan_err;
} BCM53324_A0_CMIC_SCHAN_ERRr_t;

#define BCM53324_A0_CMIC_SCHAN_ERRr_CLR(r) (r).cmic_schan_err[0] = 0
#define BCM53324_A0_CMIC_SCHAN_ERRr_SET(r,d) (r).cmic_schan_err[0] = d
#define BCM53324_A0_CMIC_SCHAN_ERRr_GET(r) (r).cmic_schan_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_schan_err[0]) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_SCHAN_ERRr_RESERVED_1f_GET(r) ((((r).cmic_schan_err[0]) >> 1) & 0x7)
#define BCM53324_A0_CMIC_SCHAN_ERRr_RESERVED_1f_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53324_A0_CMIC_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 4) & 0x3)
#define BCM53324_A0_CMIC_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_CMIC_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_schan_err[0]) >> 6) & 0x1)
#define BCM53324_A0_CMIC_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CMIC_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_schan_err[0]) >> 7) & 0x7f)
#define BCM53324_A0_CMIC_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCM53324_A0_CMIC_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 14) & 0x3f)
#define BCM53324_A0_CMIC_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM53324_A0_CMIC_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 20) & 0x3f)
#define BCM53324_A0_CMIC_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM53324_A0_CMIC_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 26) & 0x3f)
#define BCM53324_A0_CMIC_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_SCHAN_ERR.
 *
 */
#define BCM53324_A0_READ_CMIC_SCHAN_ERRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SCHAN_ERRr,r._cmic_schan_err)
#define BCM53324_A0_WRITE_CMIC_SCHAN_ERRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SCHAN_ERRr,r._cmic_schan_err)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_ERRr BCM53324_A0_CMIC_SCHAN_ERRr
#define CMIC_SCHAN_ERRr_SIZE BCM53324_A0_CMIC_SCHAN_ERRr_SIZE
typedef BCM53324_A0_CMIC_SCHAN_ERRr_t CMIC_SCHAN_ERRr_t;
#define CMIC_SCHAN_ERRr_CLR BCM53324_A0_CMIC_SCHAN_ERRr_CLR
#define CMIC_SCHAN_ERRr_SET BCM53324_A0_CMIC_SCHAN_ERRr_SET
#define CMIC_SCHAN_ERRr_GET BCM53324_A0_CMIC_SCHAN_ERRr_GET
#define CMIC_SCHAN_ERRr_NACKf_GET BCM53324_A0_CMIC_SCHAN_ERRr_NACKf_GET
#define CMIC_SCHAN_ERRr_NACKf_SET BCM53324_A0_CMIC_SCHAN_ERRr_NACKf_SET
#define CMIC_SCHAN_ERRr_RESERVED_1f_GET BCM53324_A0_CMIC_SCHAN_ERRr_RESERVED_1f_GET
#define CMIC_SCHAN_ERRr_RESERVED_1f_SET BCM53324_A0_CMIC_SCHAN_ERRr_RESERVED_1f_SET
#define CMIC_SCHAN_ERRr_ERR_CODEf_GET BCM53324_A0_CMIC_SCHAN_ERRr_ERR_CODEf_GET
#define CMIC_SCHAN_ERRr_ERR_CODEf_SET BCM53324_A0_CMIC_SCHAN_ERRr_ERR_CODEf_SET
#define CMIC_SCHAN_ERRr_ERRBITf_GET BCM53324_A0_CMIC_SCHAN_ERRr_ERRBITf_GET
#define CMIC_SCHAN_ERRr_ERRBITf_SET BCM53324_A0_CMIC_SCHAN_ERRr_ERRBITf_SET
#define CMIC_SCHAN_ERRr_DATA_LENf_GET BCM53324_A0_CMIC_SCHAN_ERRr_DATA_LENf_GET
#define CMIC_SCHAN_ERRr_DATA_LENf_SET BCM53324_A0_CMIC_SCHAN_ERRr_DATA_LENf_SET
#define CMIC_SCHAN_ERRr_SRC_PORTf_GET BCM53324_A0_CMIC_SCHAN_ERRr_SRC_PORTf_GET
#define CMIC_SCHAN_ERRr_SRC_PORTf_SET BCM53324_A0_CMIC_SCHAN_ERRr_SRC_PORTf_SET
#define CMIC_SCHAN_ERRr_DST_PORTf_GET BCM53324_A0_CMIC_SCHAN_ERRr_DST_PORTf_GET
#define CMIC_SCHAN_ERRr_DST_PORTf_SET BCM53324_A0_CMIC_SCHAN_ERRr_DST_PORTf_SET
#define CMIC_SCHAN_ERRr_OP_CODEf_GET BCM53324_A0_CMIC_SCHAN_ERRr_OP_CODEf_GET
#define CMIC_SCHAN_ERRr_OP_CODEf_SET BCM53324_A0_CMIC_SCHAN_ERRr_OP_CODEf_SET
#define READ_CMIC_SCHAN_ERRr BCM53324_A0_READ_CMIC_SCHAN_ERRr
#define WRITE_CMIC_SCHAN_ERRr BCM53324_A0_WRITE_CMIC_SCHAN_ERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SCHAN_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SCHAN_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SCHAN_MESSAGEr 0x00000000

#define BCM53324_A0_CMIC_SCHAN_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE.
 *
 */
typedef union BCM53324_A0_CMIC_SCHAN_MESSAGEr_s {
	uint32_t v[1];
	uint32_t cmic_schan_message[1];
	uint32_t _cmic_schan_message;
} BCM53324_A0_CMIC_SCHAN_MESSAGEr_t;

#define BCM53324_A0_CMIC_SCHAN_MESSAGEr_CLR(r) (r).cmic_schan_message[0] = 0
#define BCM53324_A0_CMIC_SCHAN_MESSAGEr_SET(r,d) (r).cmic_schan_message[0] = d
#define BCM53324_A0_CMIC_SCHAN_MESSAGEr_GET(r) (r).cmic_schan_message[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SCHAN_MESSAGEr_DATAf_GET(r) ((r).cmic_schan_message[0])
#define BCM53324_A0_CMIC_SCHAN_MESSAGEr_DATAf_SET(r,f) (r).cmic_schan_message[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE.
 *
 */
#define BCM53324_A0_READ_CMIC_SCHAN_MESSAGEr(u,i,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SCHAN_MESSAGEr+(4*(i)),r._cmic_schan_message)
#define BCM53324_A0_WRITE_CMIC_SCHAN_MESSAGEr(u,i,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SCHAN_MESSAGEr+(4*(i)),r._cmic_schan_message)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_MESSAGEr BCM53324_A0_CMIC_SCHAN_MESSAGEr
#define CMIC_SCHAN_MESSAGEr_SIZE BCM53324_A0_CMIC_SCHAN_MESSAGEr_SIZE
typedef BCM53324_A0_CMIC_SCHAN_MESSAGEr_t CMIC_SCHAN_MESSAGEr_t;
#define CMIC_SCHAN_MESSAGEr_CLR BCM53324_A0_CMIC_SCHAN_MESSAGEr_CLR
#define CMIC_SCHAN_MESSAGEr_SET BCM53324_A0_CMIC_SCHAN_MESSAGEr_SET
#define CMIC_SCHAN_MESSAGEr_GET BCM53324_A0_CMIC_SCHAN_MESSAGEr_GET
#define CMIC_SCHAN_MESSAGEr_DATAf_GET BCM53324_A0_CMIC_SCHAN_MESSAGEr_DATAf_GET
#define CMIC_SCHAN_MESSAGEr_DATAf_SET BCM53324_A0_CMIC_SCHAN_MESSAGEr_DATAf_SET
#define READ_CMIC_SCHAN_MESSAGEr BCM53324_A0_READ_CMIC_SCHAN_MESSAGEr
#define WRITE_CMIC_SCHAN_MESSAGEr BCM53324_A0_WRITE_CMIC_SCHAN_MESSAGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SCHAN_MESSAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SCHAN_MESSAGE_EXT
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set (extended)
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr 0x00000800

#define BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE_EXT.
 *
 */
typedef union BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_s {
	uint32_t v[1];
	uint32_t cmic_schan_message_ext[1];
	uint32_t _cmic_schan_message_ext;
} BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_t;

#define BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_CLR(r) (r).cmic_schan_message_ext[0] = 0
#define BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_SET(r,d) (r).cmic_schan_message_ext[0] = d
#define BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_GET(r) (r).cmic_schan_message_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET(r) ((r).cmic_schan_message_ext[0])
#define BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET(r,f) (r).cmic_schan_message_ext[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE_EXT.
 *
 */
#define BCM53324_A0_READ_CMIC_SCHAN_MESSAGE_EXTr(u,i,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr+(4*(i)),r._cmic_schan_message_ext)
#define BCM53324_A0_WRITE_CMIC_SCHAN_MESSAGE_EXTr(u,i,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr+(4*(i)),r._cmic_schan_message_ext)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_MESSAGE_EXTr BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr
#define CMIC_SCHAN_MESSAGE_EXTr_SIZE BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_SIZE
typedef BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_t CMIC_SCHAN_MESSAGE_EXTr_t;
#define CMIC_SCHAN_MESSAGE_EXTr_CLR BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_CLR
#define CMIC_SCHAN_MESSAGE_EXTr_SET BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_SET
#define CMIC_SCHAN_MESSAGE_EXTr_GET BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_GET
#define CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET
#define CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET
#define READ_CMIC_SCHAN_MESSAGE_EXTr BCM53324_A0_READ_CMIC_SCHAN_MESSAGE_EXTr
#define WRITE_CMIC_SCHAN_MESSAGE_EXTr BCM53324_A0_WRITE_CMIC_SCHAN_MESSAGE_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SCHAN_MESSAGE_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SCHAN_RCPU_RPIO_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus Remote PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr 0x00000900

#define BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_RCPU_RPIO_MESSAGE.
 *
 */
typedef union BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_s {
	uint32_t v[1];
	uint32_t cmic_schan_rcpu_rpio_message[1];
	uint32_t _cmic_schan_rcpu_rpio_message;
} BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_t;

#define BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_CLR(r) (r).cmic_schan_rcpu_rpio_message[0] = 0
#define BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SET(r,d) (r).cmic_schan_rcpu_rpio_message[0] = d
#define BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_GET(r) (r).cmic_schan_rcpu_rpio_message[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_GET(r) ((r).cmic_schan_rcpu_rpio_message[0])
#define BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_SET(r,f) (r).cmic_schan_rcpu_rpio_message[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_RCPU_RPIO_MESSAGE.
 *
 */
#define BCM53324_A0_READ_CMIC_SCHAN_RCPU_RPIO_MESSAGEr(u,i,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr+(4*(i)),r._cmic_schan_rcpu_rpio_message)
#define BCM53324_A0_WRITE_CMIC_SCHAN_RCPU_RPIO_MESSAGEr(u,i,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr+(4*(i)),r._cmic_schan_rcpu_rpio_message)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SIZE BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SIZE
typedef BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_t CMIC_SCHAN_RCPU_RPIO_MESSAGEr_t;
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_CLR BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_CLR
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SET BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_SET
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_GET BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_GET
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_GET BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_GET
#define CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_SET BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr_DATAf_SET
#define READ_CMIC_SCHAN_RCPU_RPIO_MESSAGEr BCM53324_A0_READ_CMIC_SCHAN_RCPU_RPIO_MESSAGEr
#define WRITE_CMIC_SCHAN_RCPU_RPIO_MESSAGEr BCM53324_A0_WRITE_CMIC_SCHAN_RCPU_RPIO_MESSAGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SCHAN_RCPU_RPIO_MESSAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SLAM_DMA_CFG
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Config Register
 * SIZE:     32
 * FIELDS:
 *     EN               Set by CPU to Enable Slam DMA Transfer
 *     ABORT            Set by CPU to Abort Slam DMA Transfer
 *     DONE             Set by CMIC to indicate Slam DMA Transfer CompletionCan be cleared (but not set) by CPU.
 *     ERROR            Set by CMIC to indicate Slam DMA Transfer wasaborted due to an error (most probably due to a NACK).Can be cleared (but not set) by CPU.
 *     RESERVED_1       Reserved
 *     BEATS            Written by CPU indicating number of data beats.For Slam DMA purposes, each table entry is 32-bit aligned.The widest S-bus table wr/rd supported is 640 bits.So, the valid values for this field are 1-20 (beats).
 *     ORDER            Set by CPU to specify Slam DMA order:'0' =>  forward (used for DELETE operations)'1' => backward (used for INSERT operations)
 *     REV_MODULO_COUNT Set by CPU to specify 'Entry count for the first iteration ofa Reverse Slam DMA operation'. The formula for this value is:( CMIC_SLAM_DMA_ENTRY_COUNT[23:0] % ( 64 / BEATS[4:0] ) )
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr 0x0000044c

#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_CFG.
 *
 */
typedef union BCM53324_A0_CMIC_SLAM_DMA_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_cfg[1];
	uint32_t _cmic_slam_dma_cfg;
} BCM53324_A0_CMIC_SLAM_DMA_CFGr_t;

#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_CLR(r) (r).cmic_slam_dma_cfg[0] = 0
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_SET(r,d) (r).cmic_slam_dma_cfg[0] = d
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_GET(r) (r).cmic_slam_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_ENf_GET(r) (((r).cmic_slam_dma_cfg[0]) & 0x1)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_ENf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_DONEf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_DONEf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_ERRORf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_ERRORf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 4) & 0xfff)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_BEATSf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_BEATSf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_ORDERf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 21) & 0x1)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_ORDERf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 22) & 0x3f)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x3f << 22)) | ((((uint32_t)f) & 0x3f) << 22))
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SLAM_DMA_CFG.
 *
 */
#define BCM53324_A0_READ_CMIC_SLAM_DMA_CFGr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SLAM_DMA_CFGr,r._cmic_slam_dma_cfg)
#define BCM53324_A0_WRITE_CMIC_SLAM_DMA_CFGr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SLAM_DMA_CFGr,r._cmic_slam_dma_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_CFGr BCM53324_A0_CMIC_SLAM_DMA_CFGr
#define CMIC_SLAM_DMA_CFGr_SIZE BCM53324_A0_CMIC_SLAM_DMA_CFGr_SIZE
typedef BCM53324_A0_CMIC_SLAM_DMA_CFGr_t CMIC_SLAM_DMA_CFGr_t;
#define CMIC_SLAM_DMA_CFGr_CLR BCM53324_A0_CMIC_SLAM_DMA_CFGr_CLR
#define CMIC_SLAM_DMA_CFGr_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_SET
#define CMIC_SLAM_DMA_CFGr_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_GET
#define CMIC_SLAM_DMA_CFGr_ENf_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_ENf_GET
#define CMIC_SLAM_DMA_CFGr_ENf_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_ENf_SET
#define CMIC_SLAM_DMA_CFGr_ABORTf_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_ABORTf_GET
#define CMIC_SLAM_DMA_CFGr_ABORTf_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_ABORTf_SET
#define CMIC_SLAM_DMA_CFGr_DONEf_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_DONEf_GET
#define CMIC_SLAM_DMA_CFGr_DONEf_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_DONEf_SET
#define CMIC_SLAM_DMA_CFGr_ERRORf_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_ERRORf_GET
#define CMIC_SLAM_DMA_CFGr_ERRORf_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_ERRORf_SET
#define CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET
#define CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET
#define CMIC_SLAM_DMA_CFGr_BEATSf_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_BEATSf_GET
#define CMIC_SLAM_DMA_CFGr_BEATSf_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_BEATSf_SET
#define CMIC_SLAM_DMA_CFGr_ORDERf_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_ORDERf_GET
#define CMIC_SLAM_DMA_CFGr_ORDERf_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_ORDERf_SET
#define CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET
#define CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET
#define CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET BCM53324_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET
#define CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET BCM53324_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET
#define READ_CMIC_SLAM_DMA_CFGr BCM53324_A0_READ_CMIC_SLAM_DMA_CFGr
#define WRITE_CMIC_SLAM_DMA_CFGr BCM53324_A0_WRITE_CMIC_SLAM_DMA_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SLAM_DMA_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Current Entry S-bus Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CMIC indicating S-bus address of the Table Entrycurrently being processed
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr 0x00000454

#define BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_cur_entry_sbus_addr[1];
	uint32_t _cmic_slam_dma_cur_entry_sbus_addr;
} BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t;

#define BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR(r) (r).cmic_slam_dma_cur_entry_sbus_addr[0] = 0
#define BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET(r,d) (r).cmic_slam_dma_cur_entry_sbus_addr[0] = d
#define BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET(r) (r).cmic_slam_dma_cur_entry_sbus_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_cur_entry_sbus_addr[0])
#define BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_cur_entry_sbus_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_slam_dma_cur_entry_sbus_addr)
#define BCM53324_A0_WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_slam_dma_cur_entry_sbus_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE
typedef BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t;
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM53324_A0_READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr
#define WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM53324_A0_WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SLAM_DMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Entry Count Register
 * SIZE:     32
 * FIELDS:
 *     COUNT            Written by CPU indicating number of Slam entries for Slam DMA.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr 0x00000448

#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_ENTRY_COUNT.
 *
 */
typedef union BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_entry_count[1];
	uint32_t _cmic_slam_dma_entry_count;
} BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_t;

#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_CLR(r) (r).cmic_slam_dma_entry_count[0] = 0
#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SET(r,d) (r).cmic_slam_dma_entry_count[0] = d
#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_GET(r) (r).cmic_slam_dma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_slam_dma_entry_count[0]) & 0xffffff)
#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_slam_dma_entry_count[0]=(((r).cmic_slam_dma_entry_count[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET(r) ((((r).cmic_slam_dma_entry_count[0]) >> 24) & 0xff)
#define BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET(r,f) (r).cmic_slam_dma_entry_count[0]=(((r).cmic_slam_dma_entry_count[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_SLAM_DMA_ENTRY_COUNT.
 *
 */
#define BCM53324_A0_READ_CMIC_SLAM_DMA_ENTRY_COUNTr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr,r._cmic_slam_dma_entry_count)
#define BCM53324_A0_WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr,r._cmic_slam_dma_entry_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_ENTRY_COUNTr BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr
#define CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE
typedef BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_t CMIC_SLAM_DMA_ENTRY_COUNTr_t;
#define CMIC_SLAM_DMA_ENTRY_COUNTr_CLR BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_CLR
#define CMIC_SLAM_DMA_ENTRY_COUNTr_SET BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_GET BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET
#define READ_CMIC_SLAM_DMA_ENTRY_COUNTr BCM53324_A0_READ_CMIC_SLAM_DMA_ENTRY_COUNTr
#define WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr BCM53324_A0_WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SLAM_DMA_ENTRY_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SLAM_DMA_PCIMEM_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA PCI Memory Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Slam DMA Physical (PCI) Memory Start Address
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr 0x00000440

#define BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_PCIMEM_START_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_pcimem_start_addr[1];
	uint32_t _cmic_slam_dma_pcimem_start_addr;
} BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t;

#define BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR(r) (r).cmic_slam_dma_pcimem_start_addr[0] = 0
#define BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET(r,d) (r).cmic_slam_dma_pcimem_start_addr[0] = d
#define BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET(r) (r).cmic_slam_dma_pcimem_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_pcimem_start_addr[0])
#define BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_pcimem_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_PCIMEM_START_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr,r._cmic_slam_dma_pcimem_start_addr)
#define BCM53324_A0_WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr,r._cmic_slam_dma_pcimem_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE
typedef BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t;
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM53324_A0_READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr
#define WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM53324_A0_WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SLAM_DMA_SBUS_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA S-bus Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Slam DMA Logical (S-bus) Memory Start Address. This address has the followingfields: table (6b), block (4b) and region+index (20b)
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr 0x00000444

#define BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_SBUS_START_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_sbus_start_addr[1];
	uint32_t _cmic_slam_dma_sbus_start_addr;
} BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_t;

#define BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR(r) (r).cmic_slam_dma_sbus_start_addr[0] = 0
#define BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SET(r,d) (r).cmic_slam_dma_sbus_start_addr[0] = d
#define BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_GET(r) (r).cmic_slam_dma_sbus_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_sbus_start_addr[0])
#define BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_sbus_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_SBUS_START_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_SLAM_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr,r._cmic_slam_dma_sbus_start_addr)
#define BCM53324_A0_WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr,r._cmic_slam_dma_sbus_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_SBUS_START_ADDRr BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE
typedef BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_t CMIC_SLAM_DMA_SBUS_START_ADDRr_t;
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_SET BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_GET BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_GET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_SBUS_START_ADDRr BCM53324_A0_READ_CMIC_SLAM_DMA_SBUS_START_ADDRr
#define WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr BCM53324_A0_WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SOFT_RESET_REG
 * BLOCKS:   CMIC
 * DESC:     CMIC Soft Reset register
 * SIZE:     32
 * FIELDS:
 *     CMIC_GP_RST_L    Gport Reset (active low)
 *     CMIC_FP_RST_L    Reserved, left here for SW
 *     CMIC_GX12_RST_L  Reserved, left here for SW
 *     RESERVED_0       Reserved
 *     CMIC_G2P50_RST_L Reserved, left here for SW
 *     CMIC_G2P51_RST_L Reserved, left here for SW
 *     CMIC_MMU_RST_L   MMU Reset (active low)
 *     CMIC_IP_RST_L    IP Reset (active low)
 *     CMIC_EP_RST_L    EP Reset (active low)
 *     CMIC_XG_PLL_RST_L XG PLL Reset (active low), Minimum assertion time is 10us as per LCPLL spec
 *     CMIC_BSAFE_RST_L Reserved, left here for SW
 *     CMIC_G2P52_RST_L Reserved, left here for SW
 *     CMIC_G2P53_RST_L Reserved, left here for SW
 *     CMIC_QGPHY1_RST_L Reserved, left here for SW
 *     CMIC_QGPHY0_RST_L Reserved, left here for SW
 *     CMIC_QSGMII2X1_RST_L Reserved, left here for SW
 *     CMIC_QSGMII2X0_RST_L Reserved, left here for SW
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SOFT_RESET_REGr 0x00000580

#define BCM53324_A0_CMIC_SOFT_RESET_REGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SOFT_RESET_REG.
 *
 */
typedef union BCM53324_A0_CMIC_SOFT_RESET_REGr_s {
	uint32_t v[1];
	uint32_t cmic_soft_reset_reg[1];
	uint32_t _cmic_soft_reset_reg;
} BCM53324_A0_CMIC_SOFT_RESET_REGr_t;

#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CLR(r) (r).cmic_soft_reset_reg[0] = 0
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_SET(r,d) (r).cmic_soft_reset_reg[0] = d
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_GET(r) (r).cmic_soft_reset_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET(r) (((r).cmic_soft_reset_reg[0]) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 5) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 6) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 7) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 8) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 9) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 10) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P52_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 11) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P52_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P53_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 12) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P53_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QGPHY1_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QGPHY1_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QGPHY0_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 14) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QGPHY0_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X1_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 15) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X1_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X0_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 16) & 0x1)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X0_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 17) & 0x7fff)
#define BCM53324_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access CMIC_SOFT_RESET_REG.
 *
 */
#define BCM53324_A0_READ_CMIC_SOFT_RESET_REGr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SOFT_RESET_REGr,r._cmic_soft_reset_reg)
#define BCM53324_A0_WRITE_CMIC_SOFT_RESET_REGr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SOFT_RESET_REGr,r._cmic_soft_reset_reg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SOFT_RESET_REGr BCM53324_A0_CMIC_SOFT_RESET_REGr
#define CMIC_SOFT_RESET_REGr_SIZE BCM53324_A0_CMIC_SOFT_RESET_REGr_SIZE
typedef BCM53324_A0_CMIC_SOFT_RESET_REGr_t CMIC_SOFT_RESET_REGr_t;
#define CMIC_SOFT_RESET_REGr_CLR BCM53324_A0_CMIC_SOFT_RESET_REGr_CLR
#define CMIC_SOFT_RESET_REGr_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_SET
#define CMIC_SOFT_RESET_REGr_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_FP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_GX12_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_0f_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_0f_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P50_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P51_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P52_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P52_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P52_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P52_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P53_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P53_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_G2P53_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_G2P53_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_QGPHY1_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QGPHY1_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_QGPHY1_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QGPHY1_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_QGPHY0_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QGPHY0_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_QGPHY0_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QGPHY0_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X1_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X1_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X1_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X1_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X0_RST_Lf_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X0_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X0_RST_Lf_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_CMIC_QSGMII2X0_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_1f_GET BCM53324_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_1f_SET BCM53324_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_SET
#define READ_CMIC_SOFT_RESET_REGr BCM53324_A0_READ_CMIC_SOFT_RESET_REGr
#define WRITE_CMIC_SOFT_RESET_REGr BCM53324_A0_WRITE_CMIC_SOFT_RESET_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SOFT_RESET_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_ADDR
 * BLOCKS:   CMIC
 * DESC:     Stats memory start address

 * SIZE:     32
 * FIELDS:
 *     ADDR             Start memory address where the stats counters willbe written to
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_ADDRr 0x00000164

#define BCM53324_A0_CMIC_STAT_DMA_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_addr[1];
	uint32_t _cmic_stat_dma_addr;
} BCM53324_A0_CMIC_STAT_DMA_ADDRr_t;

#define BCM53324_A0_CMIC_STAT_DMA_ADDRr_CLR(r) (r).cmic_stat_dma_addr[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_ADDRr_SET(r,d) (r).cmic_stat_dma_addr[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_ADDRr_GET(r) (r).cmic_stat_dma_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_ADDRr_ADDRf_GET(r) ((r).cmic_stat_dma_addr[0])
#define BCM53324_A0_CMIC_STAT_DMA_ADDRr_ADDRf_SET(r,f) (r).cmic_stat_dma_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_ADDRr,r._cmic_stat_dma_addr)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_ADDRr,r._cmic_stat_dma_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_ADDRr BCM53324_A0_CMIC_STAT_DMA_ADDRr
#define CMIC_STAT_DMA_ADDRr_SIZE BCM53324_A0_CMIC_STAT_DMA_ADDRr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_ADDRr_t CMIC_STAT_DMA_ADDRr_t;
#define CMIC_STAT_DMA_ADDRr_CLR BCM53324_A0_CMIC_STAT_DMA_ADDRr_CLR
#define CMIC_STAT_DMA_ADDRr_SET BCM53324_A0_CMIC_STAT_DMA_ADDRr_SET
#define CMIC_STAT_DMA_ADDRr_GET BCM53324_A0_CMIC_STAT_DMA_ADDRr_GET
#define CMIC_STAT_DMA_ADDRr_ADDRf_GET BCM53324_A0_CMIC_STAT_DMA_ADDRr_ADDRf_GET
#define CMIC_STAT_DMA_ADDRr_ADDRf_SET BCM53324_A0_CMIC_STAT_DMA_ADDRr_ADDRf_SET
#define READ_CMIC_STAT_DMA_ADDRr BCM53324_A0_READ_CMIC_STAT_DMA_ADDRr
#define WRITE_CMIC_STAT_DMA_ADDRr BCM53324_A0_WRITE_CMIC_STAT_DMA_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_15_8
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 15 to 8

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_8    S-bus block number for port  8
 *     SBUS_BLKNUM_9    S-bus block number for port  9
 *     SBUS_BLKNUM_10   S-bus block number for port 10
 *     SBUS_BLKNUM_11   S-bus block number for port 11
 *     SBUS_BLKNUM_12   S-bus block number for port 12
 *     SBUS_BLKNUM_13   S-bus block number for port 13
 *     SBUS_BLKNUM_14   S-bus block number for port 14
 *     SBUS_BLKNUM_15   S-bus block number for port 15
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r 0x00000484

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_15_8.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_15_8[1];
	uint32_t _cmic_stat_dma_blknum_map_15_8;
} BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t;

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR(r) (r).cmic_stat_dma_blknum_map_15_8[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET(r,d) (r).cmic_stat_dma_blknum_map_15_8[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET(r) (r).cmic_stat_dma_blknum_map_15_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET(r) (((r).cmic_stat_dma_blknum_map_15_8[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 8) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 12) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 16) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 20) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 24) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_15_8.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r,r._cmic_stat_dma_blknum_map_15_8)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r,r._cmic_stat_dma_blknum_map_15_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_23_16
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 23 to 16

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_16   S-bus block number for port 16
 *     SBUS_BLKNUM_17   S-bus block number for port 17
 *     SBUS_BLKNUM_18   S-bus block number for port 18
 *     SBUS_BLKNUM_19   S-bus block number for port 19
 *     SBUS_BLKNUM_20   S-bus block number for port 20
 *     SBUS_BLKNUM_21   S-bus block number for port 21
 *     SBUS_BLKNUM_22   S-bus block number for port 22
 *     SBUS_BLKNUM_23   S-bus block number for port 23
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r 0x00000488

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_23_16.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_23_16[1];
	uint32_t _cmic_stat_dma_blknum_map_23_16;
} BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t;

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR(r) (r).cmic_stat_dma_blknum_map_23_16[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET(r,d) (r).cmic_stat_dma_blknum_map_23_16[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET(r) (r).cmic_stat_dma_blknum_map_23_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET(r) (((r).cmic_stat_dma_blknum_map_23_16[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 8) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 12) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 16) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 20) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 24) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_23_16.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r,r._cmic_stat_dma_blknum_map_23_16)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r,r._cmic_stat_dma_blknum_map_23_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_31_24
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 31 to 24

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_24   S-bus block number for port 24
 *     SBUS_BLKNUM_25   S-bus block number for port 25
 *     SBUS_BLKNUM_26   S-bus block number for port 26
 *     SBUS_BLKNUM_27   S-bus block number for port 27
 *     SBUS_BLKNUM_28   S-bus block number for port 28
 *     SBUS_BLKNUM_29   S-bus block number for port 29
 *     SBUS_BLKNUM_30   S-bus block number for port 30
 *     SBUS_BLKNUM_31   S-bus block number for port 31
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r 0x0000048c

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_31_24.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_31_24[1];
	uint32_t _cmic_stat_dma_blknum_map_31_24;
} BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t;

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR(r) (r).cmic_stat_dma_blknum_map_31_24[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET(r,d) (r).cmic_stat_dma_blknum_map_31_24[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET(r) (r).cmic_stat_dma_blknum_map_31_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET(r) (((r).cmic_stat_dma_blknum_map_31_24[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 8) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 12) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 16) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 20) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 24) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_31_24.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r,r._cmic_stat_dma_blknum_map_31_24)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r,r._cmic_stat_dma_blknum_map_31_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_39_32
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 39 to 32

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_32   S-bus block number for port 32
 *     SBUS_BLKNUM_33   S-bus block number for port 33
 *     SBUS_BLKNUM_34   S-bus block number for port 34
 *     SBUS_BLKNUM_35   S-bus block number for port 35
 *     SBUS_BLKNUM_36   S-bus block number for port 36
 *     SBUS_BLKNUM_37   S-bus block number for port 37
 *     SBUS_BLKNUM_38   S-bus block number for port 38
 *     SBUS_BLKNUM_39   S-bus block number for port 39
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r 0x00000490

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_39_32.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_39_32[1];
	uint32_t _cmic_stat_dma_blknum_map_39_32;
} BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_t;

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_CLR(r) (r).cmic_stat_dma_blknum_map_39_32[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SET(r,d) (r).cmic_stat_dma_blknum_map_39_32[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_GET(r) (r).cmic_stat_dma_blknum_map_39_32[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_GET(r) (((r).cmic_stat_dma_blknum_map_39_32[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 8) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 12) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 16) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 20) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 24) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_GET(r) ((((r).cmic_stat_dma_blknum_map_39_32[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_SET(r,f) (r).cmic_stat_dma_blknum_map_39_32[0]=(((r).cmic_stat_dma_blknum_map_39_32[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_39_32.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_39_32r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r,r._cmic_stat_dma_blknum_map_39_32)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_39_32r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r,r._cmic_stat_dma_blknum_map_39_32)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SIZE BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_t CMIC_STAT_DMA_BLKNUM_MAP_39_32r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_CLR BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_32f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_33f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_34f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_35f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_36f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_37f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_38f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r_SBUS_BLKNUM_39f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_39_32r BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_39_32r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_39_32r BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_39_32r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_39_32r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_47_40
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 47 to 40

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_40   S-bus block number for port 40
 *     SBUS_BLKNUM_41   S-bus block number for port 41
 *     SBUS_BLKNUM_42   S-bus block number for port 42
 *     SBUS_BLKNUM_43   S-bus block number for port 43
 *     SBUS_BLKNUM_44   S-bus block number for port 44
 *     SBUS_BLKNUM_45   S-bus block number for port 45
 *     SBUS_BLKNUM_46   S-bus block number for port 46
 *     SBUS_BLKNUM_47   S-bus block number for port 47
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r 0x00000494

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_47_40.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_47_40[1];
	uint32_t _cmic_stat_dma_blknum_map_47_40;
} BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_t;

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_CLR(r) (r).cmic_stat_dma_blknum_map_47_40[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SET(r,d) (r).cmic_stat_dma_blknum_map_47_40[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_GET(r) (r).cmic_stat_dma_blknum_map_47_40[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_GET(r) (((r).cmic_stat_dma_blknum_map_47_40[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 8) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 12) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 16) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 20) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 24) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_GET(r) ((((r).cmic_stat_dma_blknum_map_47_40[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_SET(r,f) (r).cmic_stat_dma_blknum_map_47_40[0]=(((r).cmic_stat_dma_blknum_map_47_40[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_47_40.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_47_40r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r,r._cmic_stat_dma_blknum_map_47_40)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_47_40r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r,r._cmic_stat_dma_blknum_map_47_40)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SIZE BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_t CMIC_STAT_DMA_BLKNUM_MAP_47_40r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_CLR BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_40f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_41f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_42f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_43f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_44f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_45f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_46f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r_SBUS_BLKNUM_47f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_47_40r BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_47_40r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_47_40r BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_47_40r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_47_40r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_55_48
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 55 to 48

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_48   S-bus block number for port 48
 *     SBUS_BLKNUM_49   S-bus block number for port 49
 *     SBUS_BLKNUM_50   S-bus block number for port 50
 *     SBUS_BLKNUM_51   S-bus block number for port 51
 *     SBUS_BLKNUM_52   S-bus block number for port 52
 *     SBUS_BLKNUM_53   S-bus block number for port 53
 *     SBUS_BLKNUM_54   S-bus block number for port 54
 *     SBUS_BLKNUM_55   S-bus block number for port 55
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r 0x00000498

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_55_48.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_55_48[1];
	uint32_t _cmic_stat_dma_blknum_map_55_48;
} BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_t;

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_CLR(r) (r).cmic_stat_dma_blknum_map_55_48[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SET(r,d) (r).cmic_stat_dma_blknum_map_55_48[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_GET(r) (r).cmic_stat_dma_blknum_map_55_48[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_GET(r) (((r).cmic_stat_dma_blknum_map_55_48[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 8) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 12) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 16) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 20) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 24) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_GET(r) ((((r).cmic_stat_dma_blknum_map_55_48[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_SET(r,f) (r).cmic_stat_dma_blknum_map_55_48[0]=(((r).cmic_stat_dma_blknum_map_55_48[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_55_48.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_55_48r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r,r._cmic_stat_dma_blknum_map_55_48)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_55_48r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r,r._cmic_stat_dma_blknum_map_55_48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SIZE BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_t CMIC_STAT_DMA_BLKNUM_MAP_55_48r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_CLR BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_48f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_49f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_50f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_51f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_52f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_53f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_54f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r_SBUS_BLKNUM_55f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_55_48r BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_55_48r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_55_48r BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_55_48r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_55_48r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_63_56
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 63 to 56

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_56   S-bus block number for port 56
 *     SBUS_BLKNUM_57   S-bus block number for port 57
 *     SBUS_BLKNUM_58   S-bus block number for port 58
 *     SBUS_BLKNUM_59   S-bus block number for port 59
 *     SBUS_BLKNUM_60   S-bus block number for port 60
 *     SBUS_BLKNUM_61   S-bus block number for port 61
 *     SBUS_BLKNUM_62   S-bus block number for port 62
 *     SBUS_BLKNUM_63   S-bus block number for port 63
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r 0x0000049c

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_63_56.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_63_56[1];
	uint32_t _cmic_stat_dma_blknum_map_63_56;
} BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_t;

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_CLR(r) (r).cmic_stat_dma_blknum_map_63_56[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SET(r,d) (r).cmic_stat_dma_blknum_map_63_56[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_GET(r) (r).cmic_stat_dma_blknum_map_63_56[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_GET(r) (((r).cmic_stat_dma_blknum_map_63_56[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 8) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 12) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 16) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 20) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 24) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_GET(r) ((((r).cmic_stat_dma_blknum_map_63_56[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_SET(r,f) (r).cmic_stat_dma_blknum_map_63_56[0]=(((r).cmic_stat_dma_blknum_map_63_56[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_63_56.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_63_56r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r,r._cmic_stat_dma_blknum_map_63_56)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_63_56r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r,r._cmic_stat_dma_blknum_map_63_56)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SIZE BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_t CMIC_STAT_DMA_BLKNUM_MAP_63_56r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_CLR BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_56f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_57f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_58f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_59f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_60f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_61f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_62f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r_SBUS_BLKNUM_63f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_63_56r BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_63_56r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_63_56r BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_63_56r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_63_56r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_7_0
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 7 to 0

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_0    S-bus block number for port 0
 *     SBUS_BLKNUM_1    S-bus block number for port 1
 *     SBUS_BLKNUM_2    S-bus block number for port 2
 *     SBUS_BLKNUM_3    S-bus block number for port 3
 *     SBUS_BLKNUM_4    S-bus block number for port 4
 *     SBUS_BLKNUM_5    S-bus block number for port 5
 *     SBUS_BLKNUM_6    S-bus block number for port 6
 *     SBUS_BLKNUM_7    S-bus block number for port 7
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r 0x00000480

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_7_0.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_7_0[1];
	uint32_t _cmic_stat_dma_blknum_map_7_0;
} BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t;

#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR(r) (r).cmic_stat_dma_blknum_map_7_0[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET(r,d) (r).cmic_stat_dma_blknum_map_7_0[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET(r) (r).cmic_stat_dma_blknum_map_7_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET(r) (((r).cmic_stat_dma_blknum_map_7_0[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 8) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 12) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 16) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 20) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 24) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 28) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_7_0.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r,r._cmic_stat_dma_blknum_map_7_0)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r,r._cmic_stat_dma_blknum_map_7_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM53324_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM53324_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_CURRENT
 * BLOCKS:   CMIC
 * DESC:     Current Stat Counter Value Register
 * SIZE:     32
 * FIELDS:
 *     DATA             Address of Stat counter currently being processed bythe Stats DMA engine
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_CURRENTr 0x00000170

#define BCM53324_A0_CMIC_STAT_DMA_CURRENTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_CURRENT.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_CURRENTr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_current[1];
	uint32_t _cmic_stat_dma_current;
} BCM53324_A0_CMIC_STAT_DMA_CURRENTr_t;

#define BCM53324_A0_CMIC_STAT_DMA_CURRENTr_CLR(r) (r).cmic_stat_dma_current[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_CURRENTr_SET(r,d) (r).cmic_stat_dma_current[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_CURRENTr_GET(r) (r).cmic_stat_dma_current[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_CURRENTr_DATAf_GET(r) ((r).cmic_stat_dma_current[0])
#define BCM53324_A0_CMIC_STAT_DMA_CURRENTr_DATAf_SET(r,f) (r).cmic_stat_dma_current[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_CURRENT.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_CURRENTr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_CURRENTr,r._cmic_stat_dma_current)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_CURRENTr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_CURRENTr,r._cmic_stat_dma_current)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_CURRENTr BCM53324_A0_CMIC_STAT_DMA_CURRENTr
#define CMIC_STAT_DMA_CURRENTr_SIZE BCM53324_A0_CMIC_STAT_DMA_CURRENTr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_CURRENTr_t CMIC_STAT_DMA_CURRENTr_t;
#define CMIC_STAT_DMA_CURRENTr_CLR BCM53324_A0_CMIC_STAT_DMA_CURRENTr_CLR
#define CMIC_STAT_DMA_CURRENTr_SET BCM53324_A0_CMIC_STAT_DMA_CURRENTr_SET
#define CMIC_STAT_DMA_CURRENTr_GET BCM53324_A0_CMIC_STAT_DMA_CURRENTr_GET
#define CMIC_STAT_DMA_CURRENTr_DATAf_GET BCM53324_A0_CMIC_STAT_DMA_CURRENTr_DATAf_GET
#define CMIC_STAT_DMA_CURRENTr_DATAf_SET BCM53324_A0_CMIC_STAT_DMA_CURRENTr_DATAf_SET
#define READ_CMIC_STAT_DMA_CURRENTr BCM53324_A0_READ_CMIC_STAT_DMA_CURRENTr
#define WRITE_CMIC_STAT_DMA_CURRENTr BCM53324_A0_WRITE_CMIC_STAT_DMA_CURRENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_CURRENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_EGR_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA Egress stats config register
 * SIZE:     32
 * FIELDS:
 *     EGR_ETH_BLK_NUM  S-bus block number of Egress for stats counters
 *     RESERVED_1       Reserved
 *     EGR_STAT_COUNTERS_NUM Number of Egress Stats counters per port
 *     RESERVED_2       Reserved
 *     EGR_STATS_PIPELINE_STAGE_NUM Egress pipeline stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr 0x00000464

#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_EGR_STATS_CFG.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_egr_stats_cfg[1];
	uint32_t _cmic_stat_dma_egr_stats_cfg;
} BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_t;

#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_CLR(r) (r).cmic_stat_dma_egr_stats_cfg[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_egr_stats_cfg[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_GET(r) (r).cmic_stat_dma_egr_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET(r) (((r).cmic_stat_dma_egr_stats_cfg[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 14) & 0x3)
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 22) & 0x3ff)
#define BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_STAT_DMA_EGR_STATS_CFG.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_EGR_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr,r._cmic_stat_dma_egr_stats_cfg)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr,r._cmic_stat_dma_egr_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_EGR_STATS_CFGr BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr
#define CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_t CMIC_STAT_DMA_EGR_STATS_CFGr_t;
#define CMIC_STAT_DMA_EGR_STATS_CFGr_CLR BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_CLR
#define CMIC_STAT_DMA_EGR_STATS_CFGr_SET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_GET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET
#define READ_CMIC_STAT_DMA_EGR_STATS_CFGr BCM53324_A0_READ_CMIC_STAT_DMA_EGR_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr BCM53324_A0_WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_EGR_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_ING_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA Ingress stats config register
 * SIZE:     32
 * FIELDS:
 *     ING_ETH_BLK_NUM  S-bus block number of Ingress for stats counters
 *     RESERVED_1       Reserved
 *     ING_STAT_COUNTERS_NUM Number of Ingress Stats counters per port
 *     RESERVED_2       Reserved
 *     ING_STATS_PIPELINE_STAGE_NUM Ingress pipeline stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr 0x00000460

#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_ING_STATS_CFG.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ing_stats_cfg[1];
	uint32_t _cmic_stat_dma_ing_stats_cfg;
} BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_t;

#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_CLR(r) (r).cmic_stat_dma_ing_stats_cfg[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_ing_stats_cfg[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_GET(r) (r).cmic_stat_dma_ing_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET(r) (((r).cmic_stat_dma_ing_stats_cfg[0]) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 4) & 0xf)
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 14) & 0x3)
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 22) & 0x3ff)
#define BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_STAT_DMA_ING_STATS_CFG.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_ING_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr,r._cmic_stat_dma_ing_stats_cfg)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_ING_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr,r._cmic_stat_dma_ing_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_ING_STATS_CFGr BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr
#define CMIC_STAT_DMA_ING_STATS_CFGr_SIZE BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_t CMIC_STAT_DMA_ING_STATS_CFGr_t;
#define CMIC_STAT_DMA_ING_STATS_CFGr_CLR BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_CLR
#define CMIC_STAT_DMA_ING_STATS_CFGr_SET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_GET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET
#define READ_CMIC_STAT_DMA_ING_STATS_CFGr BCM53324_A0_READ_CMIC_STAT_DMA_ING_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_ING_STATS_CFGr BCM53324_A0_WRITE_CMIC_STAT_DMA_ING_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_ING_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_MAC_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA MAC stats config register
 * SIZE:     32
 * FIELDS:
 *     MAC_G_STAT_COUNTERS_NUM Number of MAC GPORT Stats counters per port
 *     MAC_X_STAT_COUNTERS_NUM Number of MAC XPORT Stats counters per port
 *     MAC_STATS_PIPELINE_STAGE_NUM MAC stats counter stage number (if any), 
 *     RESERVED_1       Reserved
 *     CPU_STATS_PORT_NUM CPU Port number (for Stats DMA purposes), 
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr 0x00000468

#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_MAC_STATS_CFG.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_mac_stats_cfg[1];
	uint32_t _cmic_stat_dma_mac_stats_cfg;
} BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_t;

#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CLR(r) (r).cmic_stat_dma_mac_stats_cfg[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_mac_stats_cfg[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_GET(r) (r).cmic_stat_dma_mac_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET(r) (((r).cmic_stat_dma_mac_stats_cfg[0]) & 0xff)
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 8) & 0xff)
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 22) & 0x3)
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 30) & 0x3)
#define BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_STAT_DMA_MAC_STATS_CFG.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_MAC_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr,r._cmic_stat_dma_mac_stats_cfg)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr,r._cmic_stat_dma_mac_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_MAC_STATS_CFGr BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr
#define CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_t CMIC_STAT_DMA_MAC_STATS_CFGr_t;
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CLR BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CLR
#define CMIC_STAT_DMA_MAC_STATS_CFGr_SET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_GET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_GET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_SET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_GET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_SET BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_2f_SET
#define READ_CMIC_STAT_DMA_MAC_STATS_CFGr BCM53324_A0_READ_CMIC_STAT_DMA_MAC_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr BCM53324_A0_WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_MAC_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_11_8
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 11_8

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_8   S-bus port number for port 8
 *     SBUS_PORTNUM_9   S-bus port number for port 9
 *     SBUS_PORTNUM_10  S-bus port number for port 10
 *     SBUS_PORTNUM_11  S-bus port number for port 11
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r 0x000005c8

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_11_8.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_11_8[1];
	uint32_t _cmic_stat_dma_portnum_map_11_8;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_CLR(r) (r).cmic_stat_dma_portnum_map_11_8[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SET(r,d) (r).cmic_stat_dma_portnum_map_11_8[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_GET(r) (r).cmic_stat_dma_portnum_map_11_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_GET(r) (((r).cmic_stat_dma_portnum_map_11_8[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_8[0]=(((r).cmic_stat_dma_portnum_map_11_8[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_8[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_8[0]=(((r).cmic_stat_dma_portnum_map_11_8[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_8[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_8[0]=(((r).cmic_stat_dma_portnum_map_11_8[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_8[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_8[0]=(((r).cmic_stat_dma_portnum_map_11_8[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_11_8.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_11_8r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r,r._cmic_stat_dma_portnum_map_11_8)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_8r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r,r._cmic_stat_dma_portnum_map_11_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_t CMIC_STAT_DMA_PORTNUM_MAP_11_8r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_8f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_9f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_10f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r_SBUS_PORTNUM_11f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_11_8r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_11_8r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_8r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_15_12
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 15_12

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_12  S-bus port number for port 12
 *     SBUS_PORTNUM_13  S-bus port number for port 13
 *     SBUS_PORTNUM_14  S-bus port number for port 14
 *     SBUS_PORTNUM_15  S-bus port number for port 15
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r 0x000005cc

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_15_12.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_15_12[1];
	uint32_t _cmic_stat_dma_portnum_map_15_12;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_CLR(r) (r).cmic_stat_dma_portnum_map_15_12[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SET(r,d) (r).cmic_stat_dma_portnum_map_15_12[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_GET(r) (r).cmic_stat_dma_portnum_map_15_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_GET(r) (((r).cmic_stat_dma_portnum_map_15_12[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_12[0]=(((r).cmic_stat_dma_portnum_map_15_12[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_12[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_12[0]=(((r).cmic_stat_dma_portnum_map_15_12[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_12[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_12[0]=(((r).cmic_stat_dma_portnum_map_15_12[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_GET(r) ((((r).cmic_stat_dma_portnum_map_15_12[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_SET(r,f) (r).cmic_stat_dma_portnum_map_15_12[0]=(((r).cmic_stat_dma_portnum_map_15_12[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_15_12.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_15_12r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r,r._cmic_stat_dma_portnum_map_15_12)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_12r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r,r._cmic_stat_dma_portnum_map_15_12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_t CMIC_STAT_DMA_PORTNUM_MAP_15_12r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_12f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_13f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_14f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r_SBUS_PORTNUM_15f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_15_12r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_15_12r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_12r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_15_12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_15_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_19_16
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 19_16

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_16  S-bus port number for port 16
 *     SBUS_PORTNUM_17  S-bus port number for port 17
 *     SBUS_PORTNUM_18  S-bus port number for port 18
 *     SBUS_PORTNUM_19  S-bus port number for port 19
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r 0x000005d0

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_19_16.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_19_16[1];
	uint32_t _cmic_stat_dma_portnum_map_19_16;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_CLR(r) (r).cmic_stat_dma_portnum_map_19_16[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SET(r,d) (r).cmic_stat_dma_portnum_map_19_16[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_GET(r) (r).cmic_stat_dma_portnum_map_19_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_GET(r) (((r).cmic_stat_dma_portnum_map_19_16[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_SET(r,f) (r).cmic_stat_dma_portnum_map_19_16[0]=(((r).cmic_stat_dma_portnum_map_19_16[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_GET(r) ((((r).cmic_stat_dma_portnum_map_19_16[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_SET(r,f) (r).cmic_stat_dma_portnum_map_19_16[0]=(((r).cmic_stat_dma_portnum_map_19_16[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_GET(r) ((((r).cmic_stat_dma_portnum_map_19_16[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_SET(r,f) (r).cmic_stat_dma_portnum_map_19_16[0]=(((r).cmic_stat_dma_portnum_map_19_16[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_GET(r) ((((r).cmic_stat_dma_portnum_map_19_16[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_SET(r,f) (r).cmic_stat_dma_portnum_map_19_16[0]=(((r).cmic_stat_dma_portnum_map_19_16[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_19_16.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_19_16r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r,r._cmic_stat_dma_portnum_map_19_16)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_19_16r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r,r._cmic_stat_dma_portnum_map_19_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_t CMIC_STAT_DMA_PORTNUM_MAP_19_16r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_16f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_17f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_18f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r_SBUS_PORTNUM_19f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_19_16r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_19_16r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_19_16r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_19_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_19_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_23_20
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 23_20

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_20  S-bus port number for port 20
 *     SBUS_PORTNUM_21  S-bus port number for port 21
 *     SBUS_PORTNUM_22  S-bus port number for port 22
 *     SBUS_PORTNUM_23  S-bus port number for port 23
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r 0x000005d4

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_23_20.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_23_20[1];
	uint32_t _cmic_stat_dma_portnum_map_23_20;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_CLR(r) (r).cmic_stat_dma_portnum_map_23_20[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SET(r,d) (r).cmic_stat_dma_portnum_map_23_20[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_GET(r) (r).cmic_stat_dma_portnum_map_23_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_GET(r) (((r).cmic_stat_dma_portnum_map_23_20[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_20[0]=(((r).cmic_stat_dma_portnum_map_23_20[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_20[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_20[0]=(((r).cmic_stat_dma_portnum_map_23_20[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_20[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_20[0]=(((r).cmic_stat_dma_portnum_map_23_20[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_20[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_20[0]=(((r).cmic_stat_dma_portnum_map_23_20[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_23_20.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_23_20r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r,r._cmic_stat_dma_portnum_map_23_20)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_20r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r,r._cmic_stat_dma_portnum_map_23_20)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_t CMIC_STAT_DMA_PORTNUM_MAP_23_20r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_20f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_21f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_22f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r_SBUS_PORTNUM_23f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_23_20r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_23_20r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_20r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_20r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_27_24
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 27_24

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_24  S-bus port number for port 24
 *     SBUS_PORTNUM_25  S-bus port number for port 25
 *     SBUS_PORTNUM_26  S-bus port number for port 26
 *     SBUS_PORTNUM_27  S-bus port number for port 27
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r 0x000005d8

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_27_24.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_27_24[1];
	uint32_t _cmic_stat_dma_portnum_map_27_24;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_CLR(r) (r).cmic_stat_dma_portnum_map_27_24[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SET(r,d) (r).cmic_stat_dma_portnum_map_27_24[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_GET(r) (r).cmic_stat_dma_portnum_map_27_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_GET(r) (((r).cmic_stat_dma_portnum_map_27_24[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_SET(r,f) (r).cmic_stat_dma_portnum_map_27_24[0]=(((r).cmic_stat_dma_portnum_map_27_24[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_GET(r) ((((r).cmic_stat_dma_portnum_map_27_24[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_SET(r,f) (r).cmic_stat_dma_portnum_map_27_24[0]=(((r).cmic_stat_dma_portnum_map_27_24[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_GET(r) ((((r).cmic_stat_dma_portnum_map_27_24[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_SET(r,f) (r).cmic_stat_dma_portnum_map_27_24[0]=(((r).cmic_stat_dma_portnum_map_27_24[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_GET(r) ((((r).cmic_stat_dma_portnum_map_27_24[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_SET(r,f) (r).cmic_stat_dma_portnum_map_27_24[0]=(((r).cmic_stat_dma_portnum_map_27_24[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_27_24.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_27_24r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r,r._cmic_stat_dma_portnum_map_27_24)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_27_24r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r,r._cmic_stat_dma_portnum_map_27_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_t CMIC_STAT_DMA_PORTNUM_MAP_27_24r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_24f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_25f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_26f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r_SBUS_PORTNUM_27f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_27_24r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_27_24r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_27_24r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_27_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_27_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_31_28
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 31_28

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_28  S-bus port number for port 28
 *     SBUS_PORTNUM_29  S-bus port number for port 29
 *     SBUS_PORTNUM_30  S-bus port number for port 30
 *     SBUS_PORTNUM_31  S-bus port number for port 31
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r 0x000005dc

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_31_28.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_31_28[1];
	uint32_t _cmic_stat_dma_portnum_map_31_28;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_CLR(r) (r).cmic_stat_dma_portnum_map_31_28[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SET(r,d) (r).cmic_stat_dma_portnum_map_31_28[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_GET(r) (r).cmic_stat_dma_portnum_map_31_28[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_GET(r) (((r).cmic_stat_dma_portnum_map_31_28[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_28[0]=(((r).cmic_stat_dma_portnum_map_31_28[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_28[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_28[0]=(((r).cmic_stat_dma_portnum_map_31_28[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_28[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_28[0]=(((r).cmic_stat_dma_portnum_map_31_28[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_GET(r) ((((r).cmic_stat_dma_portnum_map_31_28[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_SET(r,f) (r).cmic_stat_dma_portnum_map_31_28[0]=(((r).cmic_stat_dma_portnum_map_31_28[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_31_28.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_31_28r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r,r._cmic_stat_dma_portnum_map_31_28)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_28r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r,r._cmic_stat_dma_portnum_map_31_28)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_t CMIC_STAT_DMA_PORTNUM_MAP_31_28r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_28f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_29f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_30f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r_SBUS_PORTNUM_31f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_31_28r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_31_28r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_28r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_31_28r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_31_28r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_35_32
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 35_32

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_32  S-bus port number for port 32
 *     SBUS_PORTNUM_33  S-bus port number for port 33
 *     SBUS_PORTNUM_34  S-bus port number for port 34
 *     SBUS_PORTNUM_35  S-bus port number for port 35
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r 0x000005e0

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_35_32.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_35_32[1];
	uint32_t _cmic_stat_dma_portnum_map_35_32;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_CLR(r) (r).cmic_stat_dma_portnum_map_35_32[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SET(r,d) (r).cmic_stat_dma_portnum_map_35_32[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_GET(r) (r).cmic_stat_dma_portnum_map_35_32[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_GET(r) (((r).cmic_stat_dma_portnum_map_35_32[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_SET(r,f) (r).cmic_stat_dma_portnum_map_35_32[0]=(((r).cmic_stat_dma_portnum_map_35_32[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_GET(r) ((((r).cmic_stat_dma_portnum_map_35_32[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_SET(r,f) (r).cmic_stat_dma_portnum_map_35_32[0]=(((r).cmic_stat_dma_portnum_map_35_32[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_GET(r) ((((r).cmic_stat_dma_portnum_map_35_32[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_SET(r,f) (r).cmic_stat_dma_portnum_map_35_32[0]=(((r).cmic_stat_dma_portnum_map_35_32[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_GET(r) ((((r).cmic_stat_dma_portnum_map_35_32[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_SET(r,f) (r).cmic_stat_dma_portnum_map_35_32[0]=(((r).cmic_stat_dma_portnum_map_35_32[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_35_32.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_35_32r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r,r._cmic_stat_dma_portnum_map_35_32)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_35_32r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r,r._cmic_stat_dma_portnum_map_35_32)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_t CMIC_STAT_DMA_PORTNUM_MAP_35_32r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_32f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_33f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_34f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r_SBUS_PORTNUM_35f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_35_32r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_35_32r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_35_32r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_35_32r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_35_32r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_39_36
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 39_36

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_36  S-bus port number for port 36
 *     SBUS_PORTNUM_37  S-bus port number for port 37
 *     SBUS_PORTNUM_38  S-bus port number for port 38
 *     SBUS_PORTNUM_39  S-bus port number for port 39
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r 0x000005e4

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_39_36.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_39_36[1];
	uint32_t _cmic_stat_dma_portnum_map_39_36;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_CLR(r) (r).cmic_stat_dma_portnum_map_39_36[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SET(r,d) (r).cmic_stat_dma_portnum_map_39_36[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_GET(r) (r).cmic_stat_dma_portnum_map_39_36[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_GET(r) (((r).cmic_stat_dma_portnum_map_39_36[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_SET(r,f) (r).cmic_stat_dma_portnum_map_39_36[0]=(((r).cmic_stat_dma_portnum_map_39_36[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_GET(r) ((((r).cmic_stat_dma_portnum_map_39_36[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_SET(r,f) (r).cmic_stat_dma_portnum_map_39_36[0]=(((r).cmic_stat_dma_portnum_map_39_36[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_GET(r) ((((r).cmic_stat_dma_portnum_map_39_36[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_SET(r,f) (r).cmic_stat_dma_portnum_map_39_36[0]=(((r).cmic_stat_dma_portnum_map_39_36[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_GET(r) ((((r).cmic_stat_dma_portnum_map_39_36[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_SET(r,f) (r).cmic_stat_dma_portnum_map_39_36[0]=(((r).cmic_stat_dma_portnum_map_39_36[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_39_36.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_39_36r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r,r._cmic_stat_dma_portnum_map_39_36)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_39_36r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r,r._cmic_stat_dma_portnum_map_39_36)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_t CMIC_STAT_DMA_PORTNUM_MAP_39_36r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_36f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_37f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_38f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r_SBUS_PORTNUM_39f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_39_36r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_39_36r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_39_36r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_39_36r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_39_36r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_3_0
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 3_0

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_0   S-bus port number for port 0
 *     SBUS_PORTNUM_1   S-bus port number for port 1
 *     SBUS_PORTNUM_2   S-bus port number for port 2
 *     SBUS_PORTNUM_3   S-bus port number for port 3
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r 0x000005c0

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_3_0.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_3_0[1];
	uint32_t _cmic_stat_dma_portnum_map_3_0;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_CLR(r) (r).cmic_stat_dma_portnum_map_3_0[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SET(r,d) (r).cmic_stat_dma_portnum_map_3_0[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_GET(r) (r).cmic_stat_dma_portnum_map_3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_GET(r) (((r).cmic_stat_dma_portnum_map_3_0[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_SET(r,f) (r).cmic_stat_dma_portnum_map_3_0[0]=(((r).cmic_stat_dma_portnum_map_3_0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_GET(r) ((((r).cmic_stat_dma_portnum_map_3_0[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_SET(r,f) (r).cmic_stat_dma_portnum_map_3_0[0]=(((r).cmic_stat_dma_portnum_map_3_0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_GET(r) ((((r).cmic_stat_dma_portnum_map_3_0[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_SET(r,f) (r).cmic_stat_dma_portnum_map_3_0[0]=(((r).cmic_stat_dma_portnum_map_3_0[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_GET(r) ((((r).cmic_stat_dma_portnum_map_3_0[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_SET(r,f) (r).cmic_stat_dma_portnum_map_3_0[0]=(((r).cmic_stat_dma_portnum_map_3_0[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_3_0.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_3_0r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r,r._cmic_stat_dma_portnum_map_3_0)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_3_0r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r,r._cmic_stat_dma_portnum_map_3_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_t CMIC_STAT_DMA_PORTNUM_MAP_3_0r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_0f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_1f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_2f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r_SBUS_PORTNUM_3f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_3_0r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_3_0r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_3_0r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_3_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_43_40
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 43_40

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_40  S-bus port number for port 40
 *     SBUS_PORTNUM_41  S-bus port number for port 41
 *     SBUS_PORTNUM_42  S-bus port number for port 42
 *     SBUS_PORTNUM_43  S-bus port number for port 43
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r 0x000005e8

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_43_40.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_43_40[1];
	uint32_t _cmic_stat_dma_portnum_map_43_40;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_CLR(r) (r).cmic_stat_dma_portnum_map_43_40[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SET(r,d) (r).cmic_stat_dma_portnum_map_43_40[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_GET(r) (r).cmic_stat_dma_portnum_map_43_40[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_GET(r) (((r).cmic_stat_dma_portnum_map_43_40[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_SET(r,f) (r).cmic_stat_dma_portnum_map_43_40[0]=(((r).cmic_stat_dma_portnum_map_43_40[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_GET(r) ((((r).cmic_stat_dma_portnum_map_43_40[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_SET(r,f) (r).cmic_stat_dma_portnum_map_43_40[0]=(((r).cmic_stat_dma_portnum_map_43_40[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_GET(r) ((((r).cmic_stat_dma_portnum_map_43_40[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_SET(r,f) (r).cmic_stat_dma_portnum_map_43_40[0]=(((r).cmic_stat_dma_portnum_map_43_40[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_GET(r) ((((r).cmic_stat_dma_portnum_map_43_40[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_SET(r,f) (r).cmic_stat_dma_portnum_map_43_40[0]=(((r).cmic_stat_dma_portnum_map_43_40[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_43_40.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_43_40r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r,r._cmic_stat_dma_portnum_map_43_40)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_43_40r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r,r._cmic_stat_dma_portnum_map_43_40)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_t CMIC_STAT_DMA_PORTNUM_MAP_43_40r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_40f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_41f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_42f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r_SBUS_PORTNUM_43f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_43_40r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_43_40r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_43_40r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_43_40r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_43_40r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_47_44
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 47_44

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_44  S-bus port number for port 44
 *     SBUS_PORTNUM_45  S-bus port number for port 45
 *     SBUS_PORTNUM_46  S-bus port number for port 46
 *     SBUS_PORTNUM_47  S-bus port number for port 47
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r 0x000005ec

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_47_44.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_47_44[1];
	uint32_t _cmic_stat_dma_portnum_map_47_44;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_CLR(r) (r).cmic_stat_dma_portnum_map_47_44[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SET(r,d) (r).cmic_stat_dma_portnum_map_47_44[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_GET(r) (r).cmic_stat_dma_portnum_map_47_44[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_GET(r) (((r).cmic_stat_dma_portnum_map_47_44[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_SET(r,f) (r).cmic_stat_dma_portnum_map_47_44[0]=(((r).cmic_stat_dma_portnum_map_47_44[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_GET(r) ((((r).cmic_stat_dma_portnum_map_47_44[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_SET(r,f) (r).cmic_stat_dma_portnum_map_47_44[0]=(((r).cmic_stat_dma_portnum_map_47_44[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_GET(r) ((((r).cmic_stat_dma_portnum_map_47_44[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_SET(r,f) (r).cmic_stat_dma_portnum_map_47_44[0]=(((r).cmic_stat_dma_portnum_map_47_44[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_GET(r) ((((r).cmic_stat_dma_portnum_map_47_44[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_SET(r,f) (r).cmic_stat_dma_portnum_map_47_44[0]=(((r).cmic_stat_dma_portnum_map_47_44[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_47_44.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_47_44r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r,r._cmic_stat_dma_portnum_map_47_44)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_47_44r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r,r._cmic_stat_dma_portnum_map_47_44)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_t CMIC_STAT_DMA_PORTNUM_MAP_47_44r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_44f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_45f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_46f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r_SBUS_PORTNUM_47f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_47_44r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_47_44r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_47_44r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_47_44r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_47_44r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_51_48
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 51_48

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_48  S-bus port number for port 48
 *     SBUS_PORTNUM_49  S-bus port number for port 49
 *     SBUS_PORTNUM_50  S-bus port number for port 50
 *     SBUS_PORTNUM_51  S-bus port number for port 51
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r 0x000005f0

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_51_48.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_51_48[1];
	uint32_t _cmic_stat_dma_portnum_map_51_48;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_CLR(r) (r).cmic_stat_dma_portnum_map_51_48[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SET(r,d) (r).cmic_stat_dma_portnum_map_51_48[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_GET(r) (r).cmic_stat_dma_portnum_map_51_48[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_GET(r) (((r).cmic_stat_dma_portnum_map_51_48[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_SET(r,f) (r).cmic_stat_dma_portnum_map_51_48[0]=(((r).cmic_stat_dma_portnum_map_51_48[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_GET(r) ((((r).cmic_stat_dma_portnum_map_51_48[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_SET(r,f) (r).cmic_stat_dma_portnum_map_51_48[0]=(((r).cmic_stat_dma_portnum_map_51_48[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_GET(r) ((((r).cmic_stat_dma_portnum_map_51_48[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_SET(r,f) (r).cmic_stat_dma_portnum_map_51_48[0]=(((r).cmic_stat_dma_portnum_map_51_48[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_GET(r) ((((r).cmic_stat_dma_portnum_map_51_48[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_SET(r,f) (r).cmic_stat_dma_portnum_map_51_48[0]=(((r).cmic_stat_dma_portnum_map_51_48[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_51_48.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_51_48r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r,r._cmic_stat_dma_portnum_map_51_48)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_51_48r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r,r._cmic_stat_dma_portnum_map_51_48)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_t CMIC_STAT_DMA_PORTNUM_MAP_51_48r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_48f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_49f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_50f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r_SBUS_PORTNUM_51f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_51_48r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_51_48r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_51_48r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_51_48r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_51_48r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_55_52
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 55_52

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_52  S-bus port number for port 52
 *     SBUS_PORTNUM_53  S-bus port number for port 53
 *     SBUS_PORTNUM_54  S-bus port number for port 54
 *     SBUS_PORTNUM_55  S-bus port number for port 55
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r 0x000005f4

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_55_52.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_55_52[1];
	uint32_t _cmic_stat_dma_portnum_map_55_52;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_CLR(r) (r).cmic_stat_dma_portnum_map_55_52[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SET(r,d) (r).cmic_stat_dma_portnum_map_55_52[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_GET(r) (r).cmic_stat_dma_portnum_map_55_52[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_GET(r) (((r).cmic_stat_dma_portnum_map_55_52[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_SET(r,f) (r).cmic_stat_dma_portnum_map_55_52[0]=(((r).cmic_stat_dma_portnum_map_55_52[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_GET(r) ((((r).cmic_stat_dma_portnum_map_55_52[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_SET(r,f) (r).cmic_stat_dma_portnum_map_55_52[0]=(((r).cmic_stat_dma_portnum_map_55_52[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_GET(r) ((((r).cmic_stat_dma_portnum_map_55_52[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_SET(r,f) (r).cmic_stat_dma_portnum_map_55_52[0]=(((r).cmic_stat_dma_portnum_map_55_52[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_GET(r) ((((r).cmic_stat_dma_portnum_map_55_52[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_SET(r,f) (r).cmic_stat_dma_portnum_map_55_52[0]=(((r).cmic_stat_dma_portnum_map_55_52[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_55_52.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_55_52r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r,r._cmic_stat_dma_portnum_map_55_52)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_55_52r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r,r._cmic_stat_dma_portnum_map_55_52)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_t CMIC_STAT_DMA_PORTNUM_MAP_55_52r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_52f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_53f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_54f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r_SBUS_PORTNUM_55f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_55_52r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_55_52r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_55_52r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_55_52r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_55_52r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_59_56
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 59_56

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_56  S-bus port number for port 56
 *     SBUS_PORTNUM_57  S-bus port number for port 57
 *     SBUS_PORTNUM_58  S-bus port number for port 58
 *     SBUS_PORTNUM_59  S-bus port number for port 59
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r 0x000005f8

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_59_56.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_59_56[1];
	uint32_t _cmic_stat_dma_portnum_map_59_56;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_CLR(r) (r).cmic_stat_dma_portnum_map_59_56[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SET(r,d) (r).cmic_stat_dma_portnum_map_59_56[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_GET(r) (r).cmic_stat_dma_portnum_map_59_56[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_GET(r) (((r).cmic_stat_dma_portnum_map_59_56[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_SET(r,f) (r).cmic_stat_dma_portnum_map_59_56[0]=(((r).cmic_stat_dma_portnum_map_59_56[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_GET(r) ((((r).cmic_stat_dma_portnum_map_59_56[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_SET(r,f) (r).cmic_stat_dma_portnum_map_59_56[0]=(((r).cmic_stat_dma_portnum_map_59_56[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_GET(r) ((((r).cmic_stat_dma_portnum_map_59_56[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_SET(r,f) (r).cmic_stat_dma_portnum_map_59_56[0]=(((r).cmic_stat_dma_portnum_map_59_56[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_GET(r) ((((r).cmic_stat_dma_portnum_map_59_56[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_SET(r,f) (r).cmic_stat_dma_portnum_map_59_56[0]=(((r).cmic_stat_dma_portnum_map_59_56[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_59_56.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_59_56r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r,r._cmic_stat_dma_portnum_map_59_56)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_59_56r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r,r._cmic_stat_dma_portnum_map_59_56)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_t CMIC_STAT_DMA_PORTNUM_MAP_59_56r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_56f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_57f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_58f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r_SBUS_PORTNUM_59f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_59_56r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_59_56r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_59_56r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_59_56r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_59_56r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_63_60
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 63_60

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_60  S-bus port number for port 60
 *     SBUS_PORTNUM_61  S-bus port number for port 61
 *     SBUS_PORTNUM_62  S-bus port number for port 62
 *     SBUS_PORTNUM_63  S-bus port number for port 63
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r 0x000005fc

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_63_60.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_63_60[1];
	uint32_t _cmic_stat_dma_portnum_map_63_60;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_CLR(r) (r).cmic_stat_dma_portnum_map_63_60[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SET(r,d) (r).cmic_stat_dma_portnum_map_63_60[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_GET(r) (r).cmic_stat_dma_portnum_map_63_60[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_GET(r) (((r).cmic_stat_dma_portnum_map_63_60[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_SET(r,f) (r).cmic_stat_dma_portnum_map_63_60[0]=(((r).cmic_stat_dma_portnum_map_63_60[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_GET(r) ((((r).cmic_stat_dma_portnum_map_63_60[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_SET(r,f) (r).cmic_stat_dma_portnum_map_63_60[0]=(((r).cmic_stat_dma_portnum_map_63_60[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_GET(r) ((((r).cmic_stat_dma_portnum_map_63_60[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_SET(r,f) (r).cmic_stat_dma_portnum_map_63_60[0]=(((r).cmic_stat_dma_portnum_map_63_60[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_GET(r) ((((r).cmic_stat_dma_portnum_map_63_60[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_SET(r,f) (r).cmic_stat_dma_portnum_map_63_60[0]=(((r).cmic_stat_dma_portnum_map_63_60[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_63_60.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_63_60r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r,r._cmic_stat_dma_portnum_map_63_60)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_63_60r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r,r._cmic_stat_dma_portnum_map_63_60)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_t CMIC_STAT_DMA_PORTNUM_MAP_63_60r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_60f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_61f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_62f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r_SBUS_PORTNUM_63f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_63_60r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_63_60r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_63_60r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_63_60r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_63_60r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_7_4
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 7_4

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_4   S-bus port number for port 4
 *     SBUS_PORTNUM_5   S-bus port number for port 5
 *     SBUS_PORTNUM_6   S-bus port number for port 6
 *     SBUS_PORTNUM_7   S-bus port number for port 7
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r 0x000005c4

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_7_4.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_7_4[1];
	uint32_t _cmic_stat_dma_portnum_map_7_4;
} BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_CLR(r) (r).cmic_stat_dma_portnum_map_7_4[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SET(r,d) (r).cmic_stat_dma_portnum_map_7_4[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_GET(r) (r).cmic_stat_dma_portnum_map_7_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_GET(r) (((r).cmic_stat_dma_portnum_map_7_4[0]) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_4[0]=(((r).cmic_stat_dma_portnum_map_7_4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_4[0]) >> 8) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_4[0]=(((r).cmic_stat_dma_portnum_map_7_4[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_4[0]) >> 16) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_4[0]=(((r).cmic_stat_dma_portnum_map_7_4[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_GET(r) ((((r).cmic_stat_dma_portnum_map_7_4[0]) >> 24) & 0x3f)
#define BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_SET(r,f) (r).cmic_stat_dma_portnum_map_7_4[0]=(((r).cmic_stat_dma_portnum_map_7_4[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_7_4.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_7_4r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r,r._cmic_stat_dma_portnum_map_7_4)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_4r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r,r._cmic_stat_dma_portnum_map_7_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_t CMIC_STAT_DMA_PORTNUM_MAP_7_4r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_CLR BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_4f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_5f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_6f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_GET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_SET BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r_SBUS_PORTNUM_7f_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_7_4r BCM53324_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_7_4r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_4r BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_7_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTNUM_MAP_7_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTS
 * BLOCKS:   CMIC
 * DESC:     Stat Counter Port Bit Map Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Stat Counter Port Bit Map
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTSr 0x0000016c

#define BCM53324_A0_CMIC_STAT_DMA_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTS.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ports[1];
	uint32_t _cmic_stat_dma_ports;
} BCM53324_A0_CMIC_STAT_DMA_PORTSr_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTSr_CLR(r) (r).cmic_stat_dma_ports[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTSr_SET(r,d) (r).cmic_stat_dma_ports[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTSr_GET(r) (r).cmic_stat_dma_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_GET(r) ((r).cmic_stat_dma_ports[0])
#define BCM53324_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_SET(r,f) (r).cmic_stat_dma_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTS.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTSr,r._cmic_stat_dma_ports)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTSr,r._cmic_stat_dma_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTSr BCM53324_A0_CMIC_STAT_DMA_PORTSr
#define CMIC_STAT_DMA_PORTSr_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTSr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTSr_t CMIC_STAT_DMA_PORTSr_t;
#define CMIC_STAT_DMA_PORTSr_CLR BCM53324_A0_CMIC_STAT_DMA_PORTSr_CLR
#define CMIC_STAT_DMA_PORTSr_SET BCM53324_A0_CMIC_STAT_DMA_PORTSr_SET
#define CMIC_STAT_DMA_PORTSr_GET BCM53324_A0_CMIC_STAT_DMA_PORTSr_GET
#define CMIC_STAT_DMA_PORTSr_BITMAPf_GET BCM53324_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_GET
#define CMIC_STAT_DMA_PORTSr_BITMAPf_SET BCM53324_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORTSr BCM53324_A0_READ_CMIC_STAT_DMA_PORTSr
#define WRITE_CMIC_STAT_DMA_PORTSr BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORTS_HI
 * BLOCKS:   CMIC
 * DESC:     Stat Counter Port Bit Map Register, upper 32 bits
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Stat Counter Port Bit Map
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr 0x00000780

#define BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTS_HI.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ports_hi[1];
	uint32_t _cmic_stat_dma_ports_hi;
} BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_CLR(r) (r).cmic_stat_dma_ports_hi[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_SET(r,d) (r).cmic_stat_dma_ports_hi[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_GET(r) (r).cmic_stat_dma_ports_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_BITMAPf_GET(r) ((r).cmic_stat_dma_ports_hi[0])
#define BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_BITMAPf_SET(r,f) (r).cmic_stat_dma_ports_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTS_HI.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORTS_HIr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr,r._cmic_stat_dma_ports_hi)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTS_HIr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr,r._cmic_stat_dma_ports_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTS_HIr BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr
#define CMIC_STAT_DMA_PORTS_HIr_SIZE BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_t CMIC_STAT_DMA_PORTS_HIr_t;
#define CMIC_STAT_DMA_PORTS_HIr_CLR BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_CLR
#define CMIC_STAT_DMA_PORTS_HIr_SET BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_SET
#define CMIC_STAT_DMA_PORTS_HIr_GET BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_GET
#define CMIC_STAT_DMA_PORTS_HIr_BITMAPf_GET BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_BITMAPf_GET
#define CMIC_STAT_DMA_PORTS_HIr_BITMAPf_SET BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORTS_HIr BCM53324_A0_READ_CMIC_STAT_DMA_PORTS_HIr
#define WRITE_CMIC_STAT_DMA_PORTS_HIr BCM53324_A0_WRITE_CMIC_STAT_DMA_PORTS_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORTS_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORT_TYPE_MAP
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap for Stat DMA: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so get MAC_G_STAT_COUNTERS_NUM counters1 bits are Higig ports, so get MAC_X_STAT_COUNTERS_NUM counters
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr 0x0000046c

#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORT_TYPE_MAP.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_port_type_map[1];
	uint32_t _cmic_stat_dma_port_type_map;
} BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR(r) (r).cmic_stat_dma_port_type_map[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SET(r,d) (r).cmic_stat_dma_port_type_map[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_GET(r) (r).cmic_stat_dma_port_type_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET(r) ((r).cmic_stat_dma_port_type_map[0])
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET(r,f) (r).cmic_stat_dma_port_type_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORT_TYPE_MAP.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAPr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr,r._cmic_stat_dma_port_type_map)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr,r._cmic_stat_dma_port_type_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORT_TYPE_MAPr BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_t CMIC_STAT_DMA_PORT_TYPE_MAPr_t;
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_SET BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_GET BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORT_TYPE_MAPr BCM53324_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAPr
#define WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr BCM53324_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_PORT_TYPE_MAP_HI
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap for Stat DMA: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number. (upper 32-bits)

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so get MAC_G_STAT_COUNTERS_NUM counters1 bits are Higig ports, so get MAC_X_STAT_COUNTERS_NUM counters
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr 0x00000784

#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORT_TYPE_MAP_HI.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_port_type_map_hi[1];
	uint32_t _cmic_stat_dma_port_type_map_hi;
} BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_t;

#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_CLR(r) (r).cmic_stat_dma_port_type_map_hi[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SET(r,d) (r).cmic_stat_dma_port_type_map_hi[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_GET(r) (r).cmic_stat_dma_port_type_map_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_GET(r) ((r).cmic_stat_dma_port_type_map_hi[0])
#define BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_SET(r,f) (r).cmic_stat_dma_port_type_map_hi[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORT_TYPE_MAP_HI.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr,r._cmic_stat_dma_port_type_map_hi)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr,r._cmic_stat_dma_port_type_map_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SIZE BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_t CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_t;
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_CLR BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_CLR
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SET BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_SET
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_GET BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_GET BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_SET BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr BCM53324_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr
#define WRITE_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr BCM53324_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_PORT_TYPE_MAP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STAT_DMA_SETUP
 * BLOCKS:   CMIC
 * DESC:     Stat Counter DMA Access Setup Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     TIME_VAL         Timer Value
 *     E_T              Enable Timer
 *     EN               Enable DMA
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr 0x00000168

#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_SETUP.
 *
 */
typedef union BCM53324_A0_CMIC_STAT_DMA_SETUPr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_setup[1];
	uint32_t _cmic_stat_dma_setup;
} BCM53324_A0_CMIC_STAT_DMA_SETUPr_t;

#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_CLR(r) (r).cmic_stat_dma_setup[0] = 0
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_SET(r,d) (r).cmic_stat_dma_setup[0] = d
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_GET(r) (r).cmic_stat_dma_setup[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET(r) (((r).cmic_stat_dma_setup[0]) & 0xffff)
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 16) & 0x3fff)
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x3fff << 16)) | ((((uint32_t)f) & 0x3fff) << 16))
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_E_Tf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 30) & 0x1)
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_E_Tf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_ENf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 31) & 0x1)
#define BCM53324_A0_CMIC_STAT_DMA_SETUPr_ENf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_STAT_DMA_SETUP.
 *
 */
#define BCM53324_A0_READ_CMIC_STAT_DMA_SETUPr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STAT_DMA_SETUPr,r._cmic_stat_dma_setup)
#define BCM53324_A0_WRITE_CMIC_STAT_DMA_SETUPr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STAT_DMA_SETUPr,r._cmic_stat_dma_setup)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_SETUPr BCM53324_A0_CMIC_STAT_DMA_SETUPr
#define CMIC_STAT_DMA_SETUPr_SIZE BCM53324_A0_CMIC_STAT_DMA_SETUPr_SIZE
typedef BCM53324_A0_CMIC_STAT_DMA_SETUPr_t CMIC_STAT_DMA_SETUPr_t;
#define CMIC_STAT_DMA_SETUPr_CLR BCM53324_A0_CMIC_STAT_DMA_SETUPr_CLR
#define CMIC_STAT_DMA_SETUPr_SET BCM53324_A0_CMIC_STAT_DMA_SETUPr_SET
#define CMIC_STAT_DMA_SETUPr_GET BCM53324_A0_CMIC_STAT_DMA_SETUPr_GET
#define CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET BCM53324_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET
#define CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET BCM53324_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET
#define CMIC_STAT_DMA_SETUPr_TIME_VALf_GET BCM53324_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_GET
#define CMIC_STAT_DMA_SETUPr_TIME_VALf_SET BCM53324_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_SET
#define CMIC_STAT_DMA_SETUPr_E_Tf_GET BCM53324_A0_CMIC_STAT_DMA_SETUPr_E_Tf_GET
#define CMIC_STAT_DMA_SETUPr_E_Tf_SET BCM53324_A0_CMIC_STAT_DMA_SETUPr_E_Tf_SET
#define CMIC_STAT_DMA_SETUPr_ENf_GET BCM53324_A0_CMIC_STAT_DMA_SETUPr_ENf_GET
#define CMIC_STAT_DMA_SETUPr_ENf_SET BCM53324_A0_CMIC_STAT_DMA_SETUPr_ENf_SET
#define READ_CMIC_STAT_DMA_SETUPr BCM53324_A0_READ_CMIC_STAT_DMA_SETUPr
#define WRITE_CMIC_STAT_DMA_SETUPr BCM53324_A0_WRITE_CMIC_STAT_DMA_SETUPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STAT_DMA_SETUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_STRAP_OPTIONS
 * BLOCKS:   CMIC
 * DESC:     Strap option bits as descripbed below:
0   -  strap_unmanaged_mode            
1   - strap_raven_rstfsm_mode         
2   - strap_green_mode                
3   -  top_to_gport_bypass_port_stm_strap       
4   - strap_eep_load_enable           
5   -  strap_serial_flash              
6   - strap_memc_iotype               
7   - strap_mips_big_endian           
8   - strap_mips_async_clk_ctrl       
9   - strap_mips_enable_clk_ratio     
[11:10] - strap_mips_clk_ratio            
12  - strap_core_clk_freq_sel         
13  - strap_clk25_source_sel          
14  - strap_mips_pll_bypass           
15  - strap_i2c_mode_in               
16  - strap_ics_disable               
17  - strap_bypass_autoload           
18  - pci_eb_sel
19  - strap_pwrdwn_qsgmii             

 * SIZE:     32
 * FIELDS:
 *     STRAP_OPTIONS    Chip strap options.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_STRAP_OPTIONSr 0x00000188

#define BCM53324_A0_CMIC_STRAP_OPTIONSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STRAP_OPTIONS.
 *
 */
typedef union BCM53324_A0_CMIC_STRAP_OPTIONSr_s {
	uint32_t v[1];
	uint32_t cmic_strap_options[1];
	uint32_t _cmic_strap_options;
} BCM53324_A0_CMIC_STRAP_OPTIONSr_t;

#define BCM53324_A0_CMIC_STRAP_OPTIONSr_CLR(r) (r).cmic_strap_options[0] = 0
#define BCM53324_A0_CMIC_STRAP_OPTIONSr_SET(r,d) (r).cmic_strap_options[0] = d
#define BCM53324_A0_CMIC_STRAP_OPTIONSr_GET(r) (r).cmic_strap_options[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_GET(r) (((r).cmic_strap_options[0]) & 0xfffff)
#define BCM53324_A0_CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_SET(r,f) (r).cmic_strap_options[0]=(((r).cmic_strap_options[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM53324_A0_CMIC_STRAP_OPTIONSr_RESERVED_1f_GET(r) ((((r).cmic_strap_options[0]) >> 20) & 0xfff)
#define BCM53324_A0_CMIC_STRAP_OPTIONSr_RESERVED_1f_SET(r,f) (r).cmic_strap_options[0]=(((r).cmic_strap_options[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access CMIC_STRAP_OPTIONS.
 *
 */
#define BCM53324_A0_READ_CMIC_STRAP_OPTIONSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_STRAP_OPTIONSr,r._cmic_strap_options)
#define BCM53324_A0_WRITE_CMIC_STRAP_OPTIONSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_STRAP_OPTIONSr,r._cmic_strap_options)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STRAP_OPTIONSr BCM53324_A0_CMIC_STRAP_OPTIONSr
#define CMIC_STRAP_OPTIONSr_SIZE BCM53324_A0_CMIC_STRAP_OPTIONSr_SIZE
typedef BCM53324_A0_CMIC_STRAP_OPTIONSr_t CMIC_STRAP_OPTIONSr_t;
#define CMIC_STRAP_OPTIONSr_CLR BCM53324_A0_CMIC_STRAP_OPTIONSr_CLR
#define CMIC_STRAP_OPTIONSr_SET BCM53324_A0_CMIC_STRAP_OPTIONSr_SET
#define CMIC_STRAP_OPTIONSr_GET BCM53324_A0_CMIC_STRAP_OPTIONSr_GET
#define CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_GET BCM53324_A0_CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_GET
#define CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_SET BCM53324_A0_CMIC_STRAP_OPTIONSr_STRAP_OPTIONSf_SET
#define CMIC_STRAP_OPTIONSr_RESERVED_1f_GET BCM53324_A0_CMIC_STRAP_OPTIONSr_RESERVED_1f_GET
#define CMIC_STRAP_OPTIONSr_RESERVED_1f_SET BCM53324_A0_CMIC_STRAP_OPTIONSr_RESERVED_1f_SET
#define READ_CMIC_STRAP_OPTIONSr BCM53324_A0_READ_CMIC_STRAP_OPTIONSr
#define WRITE_CMIC_STRAP_OPTIONSr BCM53324_A0_WRITE_CMIC_STRAP_OPTIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_STRAP_OPTIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SWITCH_FEATURE_ENABLE
 * BLOCKS:   CMIC
 * DESC:     Bond feature enable
 * SIZE:     32
 * FIELDS:
 *     BOND_FEATURE_EN  Bond options for feature enable
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr 0x0000017c

#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SWITCH_FEATURE_ENABLE.
 *
 */
typedef union BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_s {
	uint32_t v[1];
	uint32_t cmic_switch_feature_enable[1];
	uint32_t _cmic_switch_feature_enable;
} BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_t;

#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_CLR(r) (r).cmic_switch_feature_enable[0] = 0
#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_SET(r,d) (r).cmic_switch_feature_enable[0] = d
#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_GET(r) (r).cmic_switch_feature_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_GET(r) (((r).cmic_switch_feature_enable[0]) & 0xffff)
#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_SET(r,f) (r).cmic_switch_feature_enable[0]=(((r).cmic_switch_feature_enable[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_GET(r) ((((r).cmic_switch_feature_enable[0]) >> 16) & 0xffff)
#define BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_SET(r,f) (r).cmic_switch_feature_enable[0]=(((r).cmic_switch_feature_enable[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_SWITCH_FEATURE_ENABLE.
 *
 */
#define BCM53324_A0_READ_CMIC_SWITCH_FEATURE_ENABLEr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr,r._cmic_switch_feature_enable)
#define BCM53324_A0_WRITE_CMIC_SWITCH_FEATURE_ENABLEr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr,r._cmic_switch_feature_enable)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SWITCH_FEATURE_ENABLEr BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr
#define CMIC_SWITCH_FEATURE_ENABLEr_SIZE BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_SIZE
typedef BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_t CMIC_SWITCH_FEATURE_ENABLEr_t;
#define CMIC_SWITCH_FEATURE_ENABLEr_CLR BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_CLR
#define CMIC_SWITCH_FEATURE_ENABLEr_SET BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_SET
#define CMIC_SWITCH_FEATURE_ENABLEr_GET BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_GET
#define CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_GET BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_GET
#define CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_SET BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_BOND_FEATURE_ENf_SET
#define CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_GET BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_GET
#define CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_SET BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr_RESERVEDf_SET
#define READ_CMIC_SWITCH_FEATURE_ENABLEr BCM53324_A0_READ_CMIC_SWITCH_FEATURE_ENABLEr
#define WRITE_CMIC_SWITCH_FEATURE_ENABLEr BCM53324_A0_WRITE_CMIC_SWITCH_FEATURE_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SWITCH_FEATURE_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_SW_PIO_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr 0x00000404

#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SW_PIO_ACK_DATA_BEAT_COUNT.
 *
 */
typedef union BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_sw_pio_ack_data_beat_count[1];
	uint32_t _cmic_sw_pio_ack_data_beat_count;
} BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t;

#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_sw_pio_ack_data_beat_count[0] = 0
#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_sw_pio_ack_data_beat_count[0] = d
#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_sw_pio_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_sw_pio_ack_data_beat_count[0]) & 0x1f)
#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_sw_pio_ack_data_beat_count[0]=(((r).cmic_sw_pio_ack_data_beat_count[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_sw_pio_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_sw_pio_ack_data_beat_count[0]=(((r).cmic_sw_pio_ack_data_beat_count[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_SW_PIO_ACK_DATA_BEAT_COUNT.
 *
 */
#define BCM53324_A0_READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr,r._cmic_sw_pio_ack_data_beat_count)
#define BCM53324_A0_WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr,r._cmic_sw_pio_ack_data_beat_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE
typedef BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t;
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET
#define READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM53324_A0_READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr
#define WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM53324_A0_WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TABLE_DMA_CFG
 * BLOCKS:   CMIC
 * DESC:     Table DMA Config Register
 * SIZE:     32
 * FIELDS:
 *     EN               Set by CPU to Enable Table DMA Transfer
 *     ABORT            Set by CPU to Abort Table DMA Transfer
 *     DONE             Set by CMIC to indicate Table DMA Transfer Completion.Can be cleared (but not set) by CPU.
 *     ERROR            Set by CMIC to indicate Table DMA Transfer wasaborted due to an error (most probably due to a NACK).Can be cleared (but not set) by CPU.
 *     RESERVED_1       Reserved
 *     BEATS            Written by CPU indicating number of data beats.For Table DMA purposes, each table entry is 32-bit aligned.The widest S-bus table wr/rd supported is 640 bits.So, the valid values for this field are 1-20 (beats).
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr 0x0000042c

#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_CFG.
 *
 */
typedef union BCM53324_A0_CMIC_TABLE_DMA_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_cfg[1];
	uint32_t _cmic_table_dma_cfg;
} BCM53324_A0_CMIC_TABLE_DMA_CFGr_t;

#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_CLR(r) (r).cmic_table_dma_cfg[0] = 0
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_SET(r,d) (r).cmic_table_dma_cfg[0] = d
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_GET(r) (r).cmic_table_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_ENf_GET(r) (((r).cmic_table_dma_cfg[0]) & 0x1)
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_ENf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_DONEf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_DONEf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_ERRORf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_ERRORf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 4) & 0xfff)
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_BEATSf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 16) & 0x1f)
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_BEATSf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 21) & 0x7ff)
#define BCM53324_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access CMIC_TABLE_DMA_CFG.
 *
 */
#define BCM53324_A0_READ_CMIC_TABLE_DMA_CFGr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TABLE_DMA_CFGr,r._cmic_table_dma_cfg)
#define BCM53324_A0_WRITE_CMIC_TABLE_DMA_CFGr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TABLE_DMA_CFGr,r._cmic_table_dma_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_CFGr BCM53324_A0_CMIC_TABLE_DMA_CFGr
#define CMIC_TABLE_DMA_CFGr_SIZE BCM53324_A0_CMIC_TABLE_DMA_CFGr_SIZE
typedef BCM53324_A0_CMIC_TABLE_DMA_CFGr_t CMIC_TABLE_DMA_CFGr_t;
#define CMIC_TABLE_DMA_CFGr_CLR BCM53324_A0_CMIC_TABLE_DMA_CFGr_CLR
#define CMIC_TABLE_DMA_CFGr_SET BCM53324_A0_CMIC_TABLE_DMA_CFGr_SET
#define CMIC_TABLE_DMA_CFGr_GET BCM53324_A0_CMIC_TABLE_DMA_CFGr_GET
#define CMIC_TABLE_DMA_CFGr_ENf_GET BCM53324_A0_CMIC_TABLE_DMA_CFGr_ENf_GET
#define CMIC_TABLE_DMA_CFGr_ENf_SET BCM53324_A0_CMIC_TABLE_DMA_CFGr_ENf_SET
#define CMIC_TABLE_DMA_CFGr_ABORTf_GET BCM53324_A0_CMIC_TABLE_DMA_CFGr_ABORTf_GET
#define CMIC_TABLE_DMA_CFGr_ABORTf_SET BCM53324_A0_CMIC_TABLE_DMA_CFGr_ABORTf_SET
#define CMIC_TABLE_DMA_CFGr_DONEf_GET BCM53324_A0_CMIC_TABLE_DMA_CFGr_DONEf_GET
#define CMIC_TABLE_DMA_CFGr_DONEf_SET BCM53324_A0_CMIC_TABLE_DMA_CFGr_DONEf_SET
#define CMIC_TABLE_DMA_CFGr_ERRORf_GET BCM53324_A0_CMIC_TABLE_DMA_CFGr_ERRORf_GET
#define CMIC_TABLE_DMA_CFGr_ERRORf_SET BCM53324_A0_CMIC_TABLE_DMA_CFGr_ERRORf_SET
#define CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET BCM53324_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET
#define CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET BCM53324_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET
#define CMIC_TABLE_DMA_CFGr_BEATSf_GET BCM53324_A0_CMIC_TABLE_DMA_CFGr_BEATSf_GET
#define CMIC_TABLE_DMA_CFGr_BEATSf_SET BCM53324_A0_CMIC_TABLE_DMA_CFGr_BEATSf_SET
#define CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET BCM53324_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET
#define CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET BCM53324_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET
#define READ_CMIC_TABLE_DMA_CFGr BCM53324_A0_READ_CMIC_TABLE_DMA_CFGr
#define WRITE_CMIC_TABLE_DMA_CFGr BCM53324_A0_WRITE_CMIC_TABLE_DMA_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TABLE_DMA_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA Current Entry S-bus Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CMIC indicating S-bus address of the Table Entrycurrently being processed
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr 0x00000434

#define BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_cur_entry_sbus_addr[1];
	uint32_t _cmic_table_dma_cur_entry_sbus_addr;
} BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t;

#define BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR(r) (r).cmic_table_dma_cur_entry_sbus_addr[0] = 0
#define BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET(r,d) (r).cmic_table_dma_cur_entry_sbus_addr[0] = d
#define BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET(r) (r).cmic_table_dma_cur_entry_sbus_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_cur_entry_sbus_addr[0])
#define BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_cur_entry_sbus_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_table_dma_cur_entry_sbus_addr)
#define BCM53324_A0_WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_table_dma_cur_entry_sbus_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE
typedef BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t;
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM53324_A0_READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr
#define WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM53324_A0_WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TABLE_DMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * DESC:     Table DMA Entry Count Register
 * SIZE:     32
 * FIELDS:
 *     COUNT            Written by CPU indicating number of Table entries for Table DMA.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr 0x00000428

#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_ENTRY_COUNT.
 *
 */
typedef union BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_entry_count[1];
	uint32_t _cmic_table_dma_entry_count;
} BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_t;

#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_CLR(r) (r).cmic_table_dma_entry_count[0] = 0
#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SET(r,d) (r).cmic_table_dma_entry_count[0] = d
#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_GET(r) (r).cmic_table_dma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_table_dma_entry_count[0]) & 0xffffff)
#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_table_dma_entry_count[0]=(((r).cmic_table_dma_entry_count[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET(r) ((((r).cmic_table_dma_entry_count[0]) >> 24) & 0xff)
#define BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET(r,f) (r).cmic_table_dma_entry_count[0]=(((r).cmic_table_dma_entry_count[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_TABLE_DMA_ENTRY_COUNT.
 *
 */
#define BCM53324_A0_READ_CMIC_TABLE_DMA_ENTRY_COUNTr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr,r._cmic_table_dma_entry_count)
#define BCM53324_A0_WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr,r._cmic_table_dma_entry_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_ENTRY_COUNTr BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr
#define CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE
typedef BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_t CMIC_TABLE_DMA_ENTRY_COUNTr_t;
#define CMIC_TABLE_DMA_ENTRY_COUNTr_CLR BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_CLR
#define CMIC_TABLE_DMA_ENTRY_COUNTr_SET BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_GET BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET
#define READ_CMIC_TABLE_DMA_ENTRY_COUNTr BCM53324_A0_READ_CMIC_TABLE_DMA_ENTRY_COUNTr
#define WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr BCM53324_A0_WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TABLE_DMA_ENTRY_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TABLE_DMA_PCIMEM_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA PCI Memory Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Table DMA Physical (PCI) Memory Start Address
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr 0x00000420

#define BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_PCIMEM_START_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_pcimem_start_addr[1];
	uint32_t _cmic_table_dma_pcimem_start_addr;
} BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t;

#define BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR(r) (r).cmic_table_dma_pcimem_start_addr[0] = 0
#define BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET(r,d) (r).cmic_table_dma_pcimem_start_addr[0] = d
#define BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET(r) (r).cmic_table_dma_pcimem_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_pcimem_start_addr[0])
#define BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_pcimem_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_PCIMEM_START_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr,r._cmic_table_dma_pcimem_start_addr)
#define BCM53324_A0_WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr,r._cmic_table_dma_pcimem_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE
typedef BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t;
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM53324_A0_READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr
#define WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM53324_A0_WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TABLE_DMA_SBUS_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA S-bus Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Table DMA Logical (S-bus) Memory Start Address. This address has the followingfields: table (6b), block (4b) and region+index (20b)
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr 0x00000424

#define BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_SBUS_START_ADDR.
 *
 */
typedef union BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_sbus_start_addr[1];
	uint32_t _cmic_table_dma_sbus_start_addr;
} BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_t;

#define BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR(r) (r).cmic_table_dma_sbus_start_addr[0] = 0
#define BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SET(r,d) (r).cmic_table_dma_sbus_start_addr[0] = d
#define BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_GET(r) (r).cmic_table_dma_sbus_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_sbus_start_addr[0])
#define BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_sbus_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_SBUS_START_ADDR.
 *
 */
#define BCM53324_A0_READ_CMIC_TABLE_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr,r._cmic_table_dma_sbus_start_addr)
#define BCM53324_A0_WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr,r._cmic_table_dma_sbus_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_SBUS_START_ADDRr BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE
typedef BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_t CMIC_TABLE_DMA_SBUS_START_ADDRr_t;
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_SET BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_GET BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_GET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_SBUS_START_ADDRr BCM53324_A0_READ_CMIC_TABLE_DMA_SBUS_START_ADDRr
#define WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr BCM53324_A0_WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TAP_CONTROL
 * BLOCKS:   CMIC
 * DESC:     Must follow TAP protocol to initiate BIST and read BIST results

 * SIZE:     32
 * FIELDS:
 *     TDI              Tap control data in
 *     TMS              Test mode select
 *     TCK              TAP clock
 *     TRST             TAP reset
 *     TDO              TAP data out
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TAP_CONTROLr 0x00000194

#define BCM53324_A0_CMIC_TAP_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TAP_CONTROL.
 *
 */
typedef union BCM53324_A0_CMIC_TAP_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_tap_control[1];
	uint32_t _cmic_tap_control;
} BCM53324_A0_CMIC_TAP_CONTROLr_t;

#define BCM53324_A0_CMIC_TAP_CONTROLr_CLR(r) (r).cmic_tap_control[0] = 0
#define BCM53324_A0_CMIC_TAP_CONTROLr_SET(r,d) (r).cmic_tap_control[0] = d
#define BCM53324_A0_CMIC_TAP_CONTROLr_GET(r) (r).cmic_tap_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TAP_CONTROLr_TDIf_GET(r) (((r).cmic_tap_control[0]) & 0x1)
#define BCM53324_A0_CMIC_TAP_CONTROLr_TDIf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_TAP_CONTROLr_TMSf_GET(r) ((((r).cmic_tap_control[0]) >> 1) & 0x1)
#define BCM53324_A0_CMIC_TAP_CONTROLr_TMSf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CMIC_TAP_CONTROLr_TCKf_GET(r) ((((r).cmic_tap_control[0]) >> 2) & 0x1)
#define BCM53324_A0_CMIC_TAP_CONTROLr_TCKf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CMIC_TAP_CONTROLr_TRSTf_GET(r) ((((r).cmic_tap_control[0]) >> 3) & 0x1)
#define BCM53324_A0_CMIC_TAP_CONTROLr_TRSTf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CMIC_TAP_CONTROLr_TDOf_GET(r) ((((r).cmic_tap_control[0]) >> 4) & 0x1)
#define BCM53324_A0_CMIC_TAP_CONTROLr_TDOf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CMIC_TAP_CONTROLr_RESERVED_1f_GET(r) ((((r).cmic_tap_control[0]) >> 5) & 0x7ffffff)
#define BCM53324_A0_CMIC_TAP_CONTROLr_RESERVED_1f_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_TAP_CONTROL.
 *
 */
#define BCM53324_A0_READ_CMIC_TAP_CONTROLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TAP_CONTROLr,r._cmic_tap_control)
#define BCM53324_A0_WRITE_CMIC_TAP_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TAP_CONTROLr,r._cmic_tap_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TAP_CONTROLr BCM53324_A0_CMIC_TAP_CONTROLr
#define CMIC_TAP_CONTROLr_SIZE BCM53324_A0_CMIC_TAP_CONTROLr_SIZE
typedef BCM53324_A0_CMIC_TAP_CONTROLr_t CMIC_TAP_CONTROLr_t;
#define CMIC_TAP_CONTROLr_CLR BCM53324_A0_CMIC_TAP_CONTROLr_CLR
#define CMIC_TAP_CONTROLr_SET BCM53324_A0_CMIC_TAP_CONTROLr_SET
#define CMIC_TAP_CONTROLr_GET BCM53324_A0_CMIC_TAP_CONTROLr_GET
#define CMIC_TAP_CONTROLr_TDIf_GET BCM53324_A0_CMIC_TAP_CONTROLr_TDIf_GET
#define CMIC_TAP_CONTROLr_TDIf_SET BCM53324_A0_CMIC_TAP_CONTROLr_TDIf_SET
#define CMIC_TAP_CONTROLr_TMSf_GET BCM53324_A0_CMIC_TAP_CONTROLr_TMSf_GET
#define CMIC_TAP_CONTROLr_TMSf_SET BCM53324_A0_CMIC_TAP_CONTROLr_TMSf_SET
#define CMIC_TAP_CONTROLr_TCKf_GET BCM53324_A0_CMIC_TAP_CONTROLr_TCKf_GET
#define CMIC_TAP_CONTROLr_TCKf_SET BCM53324_A0_CMIC_TAP_CONTROLr_TCKf_SET
#define CMIC_TAP_CONTROLr_TRSTf_GET BCM53324_A0_CMIC_TAP_CONTROLr_TRSTf_GET
#define CMIC_TAP_CONTROLr_TRSTf_SET BCM53324_A0_CMIC_TAP_CONTROLr_TRSTf_SET
#define CMIC_TAP_CONTROLr_TDOf_GET BCM53324_A0_CMIC_TAP_CONTROLr_TDOf_GET
#define CMIC_TAP_CONTROLr_TDOf_SET BCM53324_A0_CMIC_TAP_CONTROLr_TDOf_SET
#define CMIC_TAP_CONTROLr_RESERVED_1f_GET BCM53324_A0_CMIC_TAP_CONTROLr_RESERVED_1f_GET
#define CMIC_TAP_CONTROLr_RESERVED_1f_SET BCM53324_A0_CMIC_TAP_CONTROLr_RESERVED_1f_SET
#define READ_CMIC_TAP_CONTROLr BCM53324_A0_READ_CMIC_TAP_CONTROLr
#define WRITE_CMIC_TAP_CONTROLr BCM53324_A0_WRITE_CMIC_TAP_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TAP_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TIMESYNC_CONTROL
 * BLOCKS:   CMIC
 * DESC:     CMIC_TIMESYNC_CONTROL
 * SIZE:     32
 * FIELDS:
 *     TIMESYNC_ATTRIBUTES This is timesync attribute. when mode = 00 this filed has no meaning. When mode=01, bit [14:0] represents Phase adjustment duration and bit [19:15] represent phase adjustment step size. When mode = 10 or 11, bit [19:0] represent Frequency adjustment period.
 *     TIMESYNC_MODE    This is timesync mode. 
 *     RESERVED         reserved. 
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr 0x00000d4c

#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TIMESYNC_CONTROL.
 *
 */
typedef union BCM53324_A0_CMIC_TIMESYNC_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_timesync_control[1];
	uint32_t _cmic_timesync_control;
} BCM53324_A0_CMIC_TIMESYNC_CONTROLr_t;

#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_CLR(r) (r).cmic_timesync_control[0] = 0
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_SET(r,d) (r).cmic_timesync_control[0] = d
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_GET(r) (r).cmic_timesync_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_TIMESYNC_ATTRIBUTESf_GET(r) (((r).cmic_timesync_control[0]) & 0xfffff)
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_TIMESYNC_ATTRIBUTESf_SET(r,f) (r).cmic_timesync_control[0]=(((r).cmic_timesync_control[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_TIMESYNC_MODEf_GET(r) ((((r).cmic_timesync_control[0]) >> 20) & 0x3)
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_TIMESYNC_MODEf_SET(r,f) (r).cmic_timesync_control[0]=(((r).cmic_timesync_control[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_RESERVEDf_GET(r) ((((r).cmic_timesync_control[0]) >> 22) & 0x3ff)
#define BCM53324_A0_CMIC_TIMESYNC_CONTROLr_RESERVEDf_SET(r,f) (r).cmic_timesync_control[0]=(((r).cmic_timesync_control[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_TIMESYNC_CONTROL.
 *
 */
#define BCM53324_A0_READ_CMIC_TIMESYNC_CONTROLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TIMESYNC_CONTROLr,r._cmic_timesync_control)
#define BCM53324_A0_WRITE_CMIC_TIMESYNC_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TIMESYNC_CONTROLr,r._cmic_timesync_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TIMESYNC_CONTROLr BCM53324_A0_CMIC_TIMESYNC_CONTROLr
#define CMIC_TIMESYNC_CONTROLr_SIZE BCM53324_A0_CMIC_TIMESYNC_CONTROLr_SIZE
typedef BCM53324_A0_CMIC_TIMESYNC_CONTROLr_t CMIC_TIMESYNC_CONTROLr_t;
#define CMIC_TIMESYNC_CONTROLr_CLR BCM53324_A0_CMIC_TIMESYNC_CONTROLr_CLR
#define CMIC_TIMESYNC_CONTROLr_SET BCM53324_A0_CMIC_TIMESYNC_CONTROLr_SET
#define CMIC_TIMESYNC_CONTROLr_GET BCM53324_A0_CMIC_TIMESYNC_CONTROLr_GET
#define CMIC_TIMESYNC_CONTROLr_TIMESYNC_ATTRIBUTESf_GET BCM53324_A0_CMIC_TIMESYNC_CONTROLr_TIMESYNC_ATTRIBUTESf_GET
#define CMIC_TIMESYNC_CONTROLr_TIMESYNC_ATTRIBUTESf_SET BCM53324_A0_CMIC_TIMESYNC_CONTROLr_TIMESYNC_ATTRIBUTESf_SET
#define CMIC_TIMESYNC_CONTROLr_TIMESYNC_MODEf_GET BCM53324_A0_CMIC_TIMESYNC_CONTROLr_TIMESYNC_MODEf_GET
#define CMIC_TIMESYNC_CONTROLr_TIMESYNC_MODEf_SET BCM53324_A0_CMIC_TIMESYNC_CONTROLr_TIMESYNC_MODEf_SET
#define CMIC_TIMESYNC_CONTROLr_RESERVEDf_GET BCM53324_A0_CMIC_TIMESYNC_CONTROLr_RESERVEDf_GET
#define CMIC_TIMESYNC_CONTROLr_RESERVEDf_SET BCM53324_A0_CMIC_TIMESYNC_CONTROLr_RESERVEDf_SET
#define READ_CMIC_TIMESYNC_CONTROLr BCM53324_A0_READ_CMIC_TIMESYNC_CONTROLr
#define WRITE_CMIC_TIMESYNC_CONTROLr BCM53324_A0_WRITE_CMIC_TIMESYNC_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TIMESYNC_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TIMESYNC_TIMER
 * BLOCKS:   CMIC
 * DESC:     CMIC_TIMESYNC_TIMER
 * SIZE:     32
 * FIELDS:
 *     TIMESYNC_TIMER   TIMESYNC_TIMER 
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TIMESYNC_TIMERr 0x00000d50

#define BCM53324_A0_CMIC_TIMESYNC_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TIMESYNC_TIMER.
 *
 */
typedef union BCM53324_A0_CMIC_TIMESYNC_TIMERr_s {
	uint32_t v[1];
	uint32_t cmic_timesync_timer[1];
	uint32_t _cmic_timesync_timer;
} BCM53324_A0_CMIC_TIMESYNC_TIMERr_t;

#define BCM53324_A0_CMIC_TIMESYNC_TIMERr_CLR(r) (r).cmic_timesync_timer[0] = 0
#define BCM53324_A0_CMIC_TIMESYNC_TIMERr_SET(r,d) (r).cmic_timesync_timer[0] = d
#define BCM53324_A0_CMIC_TIMESYNC_TIMERr_GET(r) (r).cmic_timesync_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TIMESYNC_TIMERr_TIMESYNC_TIMERf_GET(r) ((r).cmic_timesync_timer[0])
#define BCM53324_A0_CMIC_TIMESYNC_TIMERr_TIMESYNC_TIMERf_SET(r,f) (r).cmic_timesync_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TIMESYNC_TIMER.
 *
 */
#define BCM53324_A0_READ_CMIC_TIMESYNC_TIMERr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TIMESYNC_TIMERr,r._cmic_timesync_timer)
#define BCM53324_A0_WRITE_CMIC_TIMESYNC_TIMERr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TIMESYNC_TIMERr,r._cmic_timesync_timer)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TIMESYNC_TIMERr BCM53324_A0_CMIC_TIMESYNC_TIMERr
#define CMIC_TIMESYNC_TIMERr_SIZE BCM53324_A0_CMIC_TIMESYNC_TIMERr_SIZE
typedef BCM53324_A0_CMIC_TIMESYNC_TIMERr_t CMIC_TIMESYNC_TIMERr_t;
#define CMIC_TIMESYNC_TIMERr_CLR BCM53324_A0_CMIC_TIMESYNC_TIMERr_CLR
#define CMIC_TIMESYNC_TIMERr_SET BCM53324_A0_CMIC_TIMESYNC_TIMERr_SET
#define CMIC_TIMESYNC_TIMERr_GET BCM53324_A0_CMIC_TIMESYNC_TIMERr_GET
#define CMIC_TIMESYNC_TIMERr_TIMESYNC_TIMERf_GET BCM53324_A0_CMIC_TIMESYNC_TIMERr_TIMESYNC_TIMERf_GET
#define CMIC_TIMESYNC_TIMERr_TIMESYNC_TIMERf_SET BCM53324_A0_CMIC_TIMESYNC_TIMERr_TIMESYNC_TIMERf_SET
#define READ_CMIC_TIMESYNC_TIMERr BCM53324_A0_READ_CMIC_TIMESYNC_TIMERr
#define WRITE_CMIC_TIMESYNC_TIMERr BCM53324_A0_WRITE_CMIC_TIMESYNC_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TIMESYNC_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TX_PAUSE_CAPABILITY
 * BLOCKS:   CMIC
 * DESC:     S/W can use this register to update tx pause capability information instead of using pause scan.S/W can override tx pause scan data with this register value by configuring pause override registers.
 * SIZE:     32
 * FIELDS:
 *     TX_PAUSE_CAPABILITY TX_PAUSE_CAPABILITY programmed by S/W
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr 0x00000d5c

#define BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TX_PAUSE_CAPABILITY.
 *
 */
typedef union BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_s {
	uint32_t v[1];
	uint32_t cmic_tx_pause_capability[1];
	uint32_t _cmic_tx_pause_capability;
} BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_t;

#define BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_CLR(r) (r).cmic_tx_pause_capability[0] = 0
#define BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_SET(r,d) (r).cmic_tx_pause_capability[0] = d
#define BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_GET(r) (r).cmic_tx_pause_capability[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_TX_PAUSE_CAPABILITYf_GET(r) ((r).cmic_tx_pause_capability[0])
#define BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_TX_PAUSE_CAPABILITYf_SET(r,f) (r).cmic_tx_pause_capability[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TX_PAUSE_CAPABILITY.
 *
 */
#define BCM53324_A0_READ_CMIC_TX_PAUSE_CAPABILITYr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr,r._cmic_tx_pause_capability)
#define BCM53324_A0_WRITE_CMIC_TX_PAUSE_CAPABILITYr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr,r._cmic_tx_pause_capability)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TX_PAUSE_CAPABILITYr BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr
#define CMIC_TX_PAUSE_CAPABILITYr_SIZE BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_SIZE
typedef BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_t CMIC_TX_PAUSE_CAPABILITYr_t;
#define CMIC_TX_PAUSE_CAPABILITYr_CLR BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_CLR
#define CMIC_TX_PAUSE_CAPABILITYr_SET BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_SET
#define CMIC_TX_PAUSE_CAPABILITYr_GET BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_GET
#define CMIC_TX_PAUSE_CAPABILITYr_TX_PAUSE_CAPABILITYf_GET BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_TX_PAUSE_CAPABILITYf_GET
#define CMIC_TX_PAUSE_CAPABILITYr_TX_PAUSE_CAPABILITYf_SET BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr_TX_PAUSE_CAPABILITYf_SET
#define READ_CMIC_TX_PAUSE_CAPABILITYr BCM53324_A0_READ_CMIC_TX_PAUSE_CAPABILITYr
#define WRITE_CMIC_TX_PAUSE_CAPABILITYr BCM53324_A0_WRITE_CMIC_TX_PAUSE_CAPABILITYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TX_PAUSE_CAPABILITYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TX_PAUSE_OVERRIDE_CONTROL
 * BLOCKS:   CMIC
 * DESC:     If Nth bit is set in this register, Nth port TX pause status will be taken from TX_PAUSE_CAPABILITY register else from tx scan result.
 * SIZE:     32
 * FIELDS:
 *     TX_PAUSE_OVERRIDE_CONTROL TX_PAUSE_OVERRIDE_CONTROL
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr 0x00000d64

#define BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TX_PAUSE_OVERRIDE_CONTROL.
 *
 */
typedef union BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_tx_pause_override_control[1];
	uint32_t _cmic_tx_pause_override_control;
} BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_t;

#define BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_CLR(r) (r).cmic_tx_pause_override_control[0] = 0
#define BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_SET(r,d) (r).cmic_tx_pause_override_control[0] = d
#define BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_GET(r) (r).cmic_tx_pause_override_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_TX_PAUSE_OVERRIDE_CONTROLf_GET(r) ((r).cmic_tx_pause_override_control[0])
#define BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_TX_PAUSE_OVERRIDE_CONTROLf_SET(r,f) (r).cmic_tx_pause_override_control[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TX_PAUSE_OVERRIDE_CONTROL.
 *
 */
#define BCM53324_A0_READ_CMIC_TX_PAUSE_OVERRIDE_CONTROLr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr,r._cmic_tx_pause_override_control)
#define BCM53324_A0_WRITE_CMIC_TX_PAUSE_OVERRIDE_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr,r._cmic_tx_pause_override_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TX_PAUSE_OVERRIDE_CONTROLr BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr
#define CMIC_TX_PAUSE_OVERRIDE_CONTROLr_SIZE BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_SIZE
typedef BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_t CMIC_TX_PAUSE_OVERRIDE_CONTROLr_t;
#define CMIC_TX_PAUSE_OVERRIDE_CONTROLr_CLR BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_CLR
#define CMIC_TX_PAUSE_OVERRIDE_CONTROLr_SET BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_SET
#define CMIC_TX_PAUSE_OVERRIDE_CONTROLr_GET BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_GET
#define CMIC_TX_PAUSE_OVERRIDE_CONTROLr_TX_PAUSE_OVERRIDE_CONTROLf_GET BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_TX_PAUSE_OVERRIDE_CONTROLf_GET
#define CMIC_TX_PAUSE_OVERRIDE_CONTROLr_TX_PAUSE_OVERRIDE_CONTROLf_SET BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr_TX_PAUSE_OVERRIDE_CONTROLf_SET
#define READ_CMIC_TX_PAUSE_OVERRIDE_CONTROLr BCM53324_A0_READ_CMIC_TX_PAUSE_OVERRIDE_CONTROLr
#define WRITE_CMIC_TX_PAUSE_OVERRIDE_CONTROLr BCM53324_A0_WRITE_CMIC_TX_PAUSE_OVERRIDE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TX_PAUSE_OVERRIDE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_TX_PAUSE_STAT
 * BLOCKS:   CMIC
 * DESC:     CMIC tx pause scan status
 * SIZE:     32
 * FIELDS:
 *     PAUSE_STAT       TX pause status
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_TX_PAUSE_STATr 0x00000d3c

#define BCM53324_A0_CMIC_TX_PAUSE_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TX_PAUSE_STAT.
 *
 */
typedef union BCM53324_A0_CMIC_TX_PAUSE_STATr_s {
	uint32_t v[1];
	uint32_t cmic_tx_pause_stat[1];
	uint32_t _cmic_tx_pause_stat;
} BCM53324_A0_CMIC_TX_PAUSE_STATr_t;

#define BCM53324_A0_CMIC_TX_PAUSE_STATr_CLR(r) (r).cmic_tx_pause_stat[0] = 0
#define BCM53324_A0_CMIC_TX_PAUSE_STATr_SET(r,d) (r).cmic_tx_pause_stat[0] = d
#define BCM53324_A0_CMIC_TX_PAUSE_STATr_GET(r) (r).cmic_tx_pause_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_TX_PAUSE_STATr_PAUSE_STATf_GET(r) ((r).cmic_tx_pause_stat[0])
#define BCM53324_A0_CMIC_TX_PAUSE_STATr_PAUSE_STATf_SET(r,f) (r).cmic_tx_pause_stat[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TX_PAUSE_STAT.
 *
 */
#define BCM53324_A0_READ_CMIC_TX_PAUSE_STATr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_TX_PAUSE_STATr,r._cmic_tx_pause_stat)
#define BCM53324_A0_WRITE_CMIC_TX_PAUSE_STATr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_TX_PAUSE_STATr,r._cmic_tx_pause_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TX_PAUSE_STATr BCM53324_A0_CMIC_TX_PAUSE_STATr
#define CMIC_TX_PAUSE_STATr_SIZE BCM53324_A0_CMIC_TX_PAUSE_STATr_SIZE
typedef BCM53324_A0_CMIC_TX_PAUSE_STATr_t CMIC_TX_PAUSE_STATr_t;
#define CMIC_TX_PAUSE_STATr_CLR BCM53324_A0_CMIC_TX_PAUSE_STATr_CLR
#define CMIC_TX_PAUSE_STATr_SET BCM53324_A0_CMIC_TX_PAUSE_STATr_SET
#define CMIC_TX_PAUSE_STATr_GET BCM53324_A0_CMIC_TX_PAUSE_STATr_GET
#define CMIC_TX_PAUSE_STATr_PAUSE_STATf_GET BCM53324_A0_CMIC_TX_PAUSE_STATr_PAUSE_STATf_GET
#define CMIC_TX_PAUSE_STATr_PAUSE_STATf_SET BCM53324_A0_CMIC_TX_PAUSE_STATr_PAUSE_STATf_SET
#define READ_CMIC_TX_PAUSE_STATr BCM53324_A0_READ_CMIC_TX_PAUSE_STATr
#define WRITE_CMIC_TX_PAUSE_STATr BCM53324_A0_WRITE_CMIC_TX_PAUSE_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_TX_PAUSE_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_0
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 0 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r 0x00000500

#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_0.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_0[1];
	uint32_t _cmic_xgxs_mdio_config_0;
} BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_t;

#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_CLR(r) (r).cmic_xgxs_mdio_config_0[0] = 0
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_SET(r,d) (r).cmic_xgxs_mdio_config_0[0] = d
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_GET(r) (r).cmic_xgxs_mdio_config_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_0[0]) & 0xff)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 14) & 0x3ffff)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_0.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_MDIO_CONFIG_0r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r,r._cmic_xgxs_mdio_config_0)
#define BCM53324_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_0r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r,r._cmic_xgxs_mdio_config_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_0r BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r
#define CMIC_XGXS_MDIO_CONFIG_0r_SIZE BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_SIZE
typedef BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_t CMIC_XGXS_MDIO_CONFIG_0r_t;
#define CMIC_XGXS_MDIO_CONFIG_0r_CLR BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_CLR
#define CMIC_XGXS_MDIO_CONFIG_0r_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_0r BCM53324_A0_READ_CMIC_XGXS_MDIO_CONFIG_0r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_0r BCM53324_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 1 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r 0x00000504

#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_1.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_1[1];
	uint32_t _cmic_xgxs_mdio_config_1;
} BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_t;

#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_CLR(r) (r).cmic_xgxs_mdio_config_1[0] = 0
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_SET(r,d) (r).cmic_xgxs_mdio_config_1[0] = d
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_GET(r) (r).cmic_xgxs_mdio_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_1[0]) & 0xff)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 14) & 0x3ffff)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_1.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_MDIO_CONFIG_1r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r,r._cmic_xgxs_mdio_config_1)
#define BCM53324_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_1r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r,r._cmic_xgxs_mdio_config_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_1r BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r
#define CMIC_XGXS_MDIO_CONFIG_1r_SIZE BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_SIZE
typedef BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_t CMIC_XGXS_MDIO_CONFIG_1r_t;
#define CMIC_XGXS_MDIO_CONFIG_1r_CLR BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_CLR
#define CMIC_XGXS_MDIO_CONFIG_1r_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_1r BCM53324_A0_READ_CMIC_XGXS_MDIO_CONFIG_1r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_1r BCM53324_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 2 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r 0x00000508

#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_2.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_2[1];
	uint32_t _cmic_xgxs_mdio_config_2;
} BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_t;

#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_CLR(r) (r).cmic_xgxs_mdio_config_2[0] = 0
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_SET(r,d) (r).cmic_xgxs_mdio_config_2[0] = d
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_GET(r) (r).cmic_xgxs_mdio_config_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_2[0]) & 0xff)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 14) & 0x3ffff)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_2.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_MDIO_CONFIG_2r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r,r._cmic_xgxs_mdio_config_2)
#define BCM53324_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_2r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r,r._cmic_xgxs_mdio_config_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_2r BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r
#define CMIC_XGXS_MDIO_CONFIG_2r_SIZE BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_SIZE
typedef BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_t CMIC_XGXS_MDIO_CONFIG_2r_t;
#define CMIC_XGXS_MDIO_CONFIG_2r_CLR BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_CLR
#define CMIC_XGXS_MDIO_CONFIG_2r_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_2r BCM53324_A0_READ_CMIC_XGXS_MDIO_CONFIG_2r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_2r BCM53324_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_3
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 3 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r 0x0000050c

#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_3.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_3[1];
	uint32_t _cmic_xgxs_mdio_config_3;
} BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_t;

#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_CLR(r) (r).cmic_xgxs_mdio_config_3[0] = 0
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_SET(r,d) (r).cmic_xgxs_mdio_config_3[0] = d
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_GET(r) (r).cmic_xgxs_mdio_config_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_3[0]) & 0xff)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 8) & 0x1f)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 13) & 0x1)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 14) & 0x3ffff)
#define BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_3.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_MDIO_CONFIG_3r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r,r._cmic_xgxs_mdio_config_3)
#define BCM53324_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_3r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r,r._cmic_xgxs_mdio_config_3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_3r BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r
#define CMIC_XGXS_MDIO_CONFIG_3r_SIZE BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_SIZE
typedef BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_t CMIC_XGXS_MDIO_CONFIG_3r_t;
#define CMIC_XGXS_MDIO_CONFIG_3r_CLR BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_CLR
#define CMIC_XGXS_MDIO_CONFIG_3r_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_3r BCM53324_A0_READ_CMIC_XGXS_MDIO_CONFIG_3r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_3r BCM53324_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_MDIO_CONFIG_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_PLL_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL Control register 1
 * SIZE:     32
 * FIELDS:
 *     PLL_CONTROL_0    1: Select Differential clock, 0: Select Xtal clock
 *     PLL_CONTROL_4_1  LCPLL CML Output clock buffer powerdown
 *     PLL_CONTROL_14_5 LCPLL charge pump and bias control.
 *     PLL_CONTROL_20_15 LCPLL TESTOUT CONFIG. Bit 15 enables LCPLL test output clocks, by default. Setting this bit to 1 disables the clocks
 *     PLL_CONTROL_26_21 LCPLL Loop Filter Control.
 *     PLL_CONTROL_31_27 LCPLL CONFIG.
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r 0x00000584

#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_CONTROL_1.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_control_1[1];
	uint32_t _cmic_xgxs_pll_control_1;
} BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_t;

#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_CLR(r) (r).cmic_xgxs_pll_control_1[0] = 0
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_SET(r,d) (r).cmic_xgxs_pll_control_1[0] = d
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_GET(r) (r).cmic_xgxs_pll_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_0f_GET(r) (((r).cmic_xgxs_pll_control_1[0]) & 0x1)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_0f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_4_1f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 1) & 0xf)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_4_1f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_14_5f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 5) & 0x3ff)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_14_5f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x3ff << 5)) | ((((uint32_t)f) & 0x3ff) << 5))
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_20_15f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 15) & 0x3f)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_20_15f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x3f << 15)) | ((((uint32_t)f) & 0x3f) << 15))
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_26_21f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 21) & 0x3f)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_26_21f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x3f << 21)) | ((((uint32_t)f) & 0x3f) << 21))
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_27f_GET(r) ((((r).cmic_xgxs_pll_control_1[0]) >> 27) & 0x1f)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_27f_SET(r,f) (r).cmic_xgxs_pll_control_1[0]=(((r).cmic_xgxs_pll_control_1[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access CMIC_XGXS_PLL_CONTROL_1.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_PLL_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r,r._cmic_xgxs_pll_control_1)
#define BCM53324_A0_WRITE_CMIC_XGXS_PLL_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r,r._cmic_xgxs_pll_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_CONTROL_1r BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r
#define CMIC_XGXS_PLL_CONTROL_1r_SIZE BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_SIZE
typedef BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_t CMIC_XGXS_PLL_CONTROL_1r_t;
#define CMIC_XGXS_PLL_CONTROL_1r_CLR BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_CLR
#define CMIC_XGXS_PLL_CONTROL_1r_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_SET
#define CMIC_XGXS_PLL_CONTROL_1r_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_0f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_0f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_0f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_0f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_4_1f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_4_1f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_4_1f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_4_1f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_14_5f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_14_5f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_14_5f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_14_5f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_20_15f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_20_15f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_20_15f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_20_15f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_26_21f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_26_21f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_26_21f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_26_21f_SET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_27f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_27f_GET
#define CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_27f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r_PLL_CONTROL_31_27f_SET
#define READ_CMIC_XGXS_PLL_CONTROL_1r BCM53324_A0_READ_CMIC_XGXS_PLL_CONTROL_1r
#define WRITE_CMIC_XGXS_PLL_CONTROL_1r BCM53324_A0_WRITE_CMIC_XGXS_PLL_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_PLL_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_PLL_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL Control register 2
 * SIZE:     32
 * FIELDS:
 *     PLL_CONTROL_63_32 XAUI PLLCONTROL register bits [63:32]
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r 0x00000588

#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_CONTROL_2.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_control_2[1];
	uint32_t _cmic_xgxs_pll_control_2;
} BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_t;

#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_CLR(r) (r).cmic_xgxs_pll_control_2[0] = 0
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_SET(r,d) (r).cmic_xgxs_pll_control_2[0] = d
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_GET(r) (r).cmic_xgxs_pll_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_63_32f_GET(r) ((r).cmic_xgxs_pll_control_2[0])
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_63_32f_SET(r,f) (r).cmic_xgxs_pll_control_2[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_XGXS_PLL_CONTROL_2.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_PLL_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r,r._cmic_xgxs_pll_control_2)
#define BCM53324_A0_WRITE_CMIC_XGXS_PLL_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r,r._cmic_xgxs_pll_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_CONTROL_2r BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r
#define CMIC_XGXS_PLL_CONTROL_2r_SIZE BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_SIZE
typedef BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_t CMIC_XGXS_PLL_CONTROL_2r_t;
#define CMIC_XGXS_PLL_CONTROL_2r_CLR BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_CLR
#define CMIC_XGXS_PLL_CONTROL_2r_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_SET
#define CMIC_XGXS_PLL_CONTROL_2r_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_63_32f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_63_32f_GET
#define CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_63_32f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r_PLL_CONTROL_63_32f_SET
#define READ_CMIC_XGXS_PLL_CONTROL_2r BCM53324_A0_READ_CMIC_XGXS_PLL_CONTROL_2r
#define WRITE_CMIC_XGXS_PLL_CONTROL_2r BCM53324_A0_WRITE_CMIC_XGXS_PLL_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_PLL_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_PLL_CONTROL_3
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL Control register 3
 * SIZE:     32
 * FIELDS:
 *     PLL_CONTROL_95_64 XAUI PLLCONTROL register bits [95:64]
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r 0x0000058c

#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_CONTROL_3.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_control_3[1];
	uint32_t _cmic_xgxs_pll_control_3;
} BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_t;

#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_CLR(r) (r).cmic_xgxs_pll_control_3[0] = 0
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_SET(r,d) (r).cmic_xgxs_pll_control_3[0] = d
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_GET(r) (r).cmic_xgxs_pll_control_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_PLL_CONTROL_95_64f_GET(r) ((r).cmic_xgxs_pll_control_3[0])
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_PLL_CONTROL_95_64f_SET(r,f) (r).cmic_xgxs_pll_control_3[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_XGXS_PLL_CONTROL_3.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_PLL_CONTROL_3r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r,r._cmic_xgxs_pll_control_3)
#define BCM53324_A0_WRITE_CMIC_XGXS_PLL_CONTROL_3r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r,r._cmic_xgxs_pll_control_3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_CONTROL_3r BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r
#define CMIC_XGXS_PLL_CONTROL_3r_SIZE BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_SIZE
typedef BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_t CMIC_XGXS_PLL_CONTROL_3r_t;
#define CMIC_XGXS_PLL_CONTROL_3r_CLR BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_CLR
#define CMIC_XGXS_PLL_CONTROL_3r_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_SET
#define CMIC_XGXS_PLL_CONTROL_3r_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_GET
#define CMIC_XGXS_PLL_CONTROL_3r_PLL_CONTROL_95_64f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_PLL_CONTROL_95_64f_GET
#define CMIC_XGXS_PLL_CONTROL_3r_PLL_CONTROL_95_64f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r_PLL_CONTROL_95_64f_SET
#define READ_CMIC_XGXS_PLL_CONTROL_3r BCM53324_A0_READ_CMIC_XGXS_PLL_CONTROL_3r
#define WRITE_CMIC_XGXS_PLL_CONTROL_3r BCM53324_A0_WRITE_CMIC_XGXS_PLL_CONTROL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_PLL_CONTROL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_PLL_CONTROL_4
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL Control register 4
 * SIZE:     32
 * FIELDS:
 *     PLL_CONTROL_124_96 XAUI PLLCONTROL register bits [124:96]
 *     RESERVED         Reserved
 *     LCPLL_PWRDWN     LCPLL Powerdown
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r 0x00000590

#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_CONTROL_4.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_control_4[1];
	uint32_t _cmic_xgxs_pll_control_4;
} BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_t;

#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_CLR(r) (r).cmic_xgxs_pll_control_4[0] = 0
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_SET(r,d) (r).cmic_xgxs_pll_control_4[0] = d
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_GET(r) (r).cmic_xgxs_pll_control_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_PLL_CONTROL_124_96f_GET(r) (((r).cmic_xgxs_pll_control_4[0]) & 0x1fffffff)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_PLL_CONTROL_124_96f_SET(r,f) (r).cmic_xgxs_pll_control_4[0]=(((r).cmic_xgxs_pll_control_4[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_RESERVEDf_GET(r) ((((r).cmic_xgxs_pll_control_4[0]) >> 29) & 0x3)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_RESERVEDf_SET(r,f) (r).cmic_xgxs_pll_control_4[0]=(((r).cmic_xgxs_pll_control_4[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_LCPLL_PWRDWNf_GET(r) ((((r).cmic_xgxs_pll_control_4[0]) >> 31) & 0x1)
#define BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_LCPLL_PWRDWNf_SET(r,f) (r).cmic_xgxs_pll_control_4[0]=(((r).cmic_xgxs_pll_control_4[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_XGXS_PLL_CONTROL_4.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_PLL_CONTROL_4r(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r,r._cmic_xgxs_pll_control_4)
#define BCM53324_A0_WRITE_CMIC_XGXS_PLL_CONTROL_4r(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r,r._cmic_xgxs_pll_control_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_CONTROL_4r BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r
#define CMIC_XGXS_PLL_CONTROL_4r_SIZE BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_SIZE
typedef BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_t CMIC_XGXS_PLL_CONTROL_4r_t;
#define CMIC_XGXS_PLL_CONTROL_4r_CLR BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_CLR
#define CMIC_XGXS_PLL_CONTROL_4r_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_SET
#define CMIC_XGXS_PLL_CONTROL_4r_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_GET
#define CMIC_XGXS_PLL_CONTROL_4r_PLL_CONTROL_124_96f_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_PLL_CONTROL_124_96f_GET
#define CMIC_XGXS_PLL_CONTROL_4r_PLL_CONTROL_124_96f_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_PLL_CONTROL_124_96f_SET
#define CMIC_XGXS_PLL_CONTROL_4r_RESERVEDf_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_RESERVEDf_GET
#define CMIC_XGXS_PLL_CONTROL_4r_RESERVEDf_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_RESERVEDf_SET
#define CMIC_XGXS_PLL_CONTROL_4r_LCPLL_PWRDWNf_GET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_LCPLL_PWRDWNf_GET
#define CMIC_XGXS_PLL_CONTROL_4r_LCPLL_PWRDWNf_SET BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r_LCPLL_PWRDWNf_SET
#define READ_CMIC_XGXS_PLL_CONTROL_4r BCM53324_A0_READ_CMIC_XGXS_PLL_CONTROL_4r
#define WRITE_CMIC_XGXS_PLL_CONTROL_4r BCM53324_A0_WRITE_CMIC_XGXS_PLL_CONTROL_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_PLL_CONTROL_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CMIC_XGXS_PLL_STATUS
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL Status
 * SIZE:     32
 * FIELDS:
 *     PLL_STATUS       XAUI PLL Status bits [17:0]
 *     RESERVED_1       Reserved
 *     QGPHY0_PLL_LOCK  QGPHY 0 PLL Lock
 *     QGPHY1_PLL_LOCK  QGPHY 1 PLL Lock
 *     CMIC_XG_PLL_LOCK XG PLL Lock
 *
 ******************************************************************************/
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr 0x00000594

#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_PLL_STATUS.
 *
 */
typedef union BCM53324_A0_CMIC_XGXS_PLL_STATUSr_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_pll_status[1];
	uint32_t _cmic_xgxs_pll_status;
} BCM53324_A0_CMIC_XGXS_PLL_STATUSr_t;

#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_CLR(r) (r).cmic_xgxs_pll_status[0] = 0
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_SET(r,d) (r).cmic_xgxs_pll_status[0] = d
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_GET(r) (r).cmic_xgxs_pll_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_PLL_STATUSf_GET(r) (((r).cmic_xgxs_pll_status[0]) & 0xffff)
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_PLL_STATUSf_SET(r,f) (r).cmic_xgxs_pll_status[0]=(((r).cmic_xgxs_pll_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_RESERVED_1f_GET(r) ((((r).cmic_xgxs_pll_status[0]) >> 16) & 0x1fff)
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_RESERVED_1f_SET(r,f) (r).cmic_xgxs_pll_status[0]=(((r).cmic_xgxs_pll_status[0] & ~((uint32_t)0x1fff << 16)) | ((((uint32_t)f) & 0x1fff) << 16))
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_QGPHY0_PLL_LOCKf_GET(r) ((((r).cmic_xgxs_pll_status[0]) >> 29) & 0x1)
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_QGPHY0_PLL_LOCKf_SET(r,f) (r).cmic_xgxs_pll_status[0]=(((r).cmic_xgxs_pll_status[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_QGPHY1_PLL_LOCKf_GET(r) ((((r).cmic_xgxs_pll_status[0]) >> 30) & 0x1)
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_QGPHY1_PLL_LOCKf_SET(r,f) (r).cmic_xgxs_pll_status[0]=(((r).cmic_xgxs_pll_status[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_CMIC_XG_PLL_LOCKf_GET(r) ((((r).cmic_xgxs_pll_status[0]) >> 31) & 0x1)
#define BCM53324_A0_CMIC_XGXS_PLL_STATUSr_CMIC_XG_PLL_LOCKf_SET(r,f) (r).cmic_xgxs_pll_status[0]=(((r).cmic_xgxs_pll_status[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_XGXS_PLL_STATUS.
 *
 */
#define BCM53324_A0_READ_CMIC_XGXS_PLL_STATUSr(u,r) CDK_DEV_READ32(u,BCM53324_A0_CMIC_XGXS_PLL_STATUSr,r._cmic_xgxs_pll_status)
#define BCM53324_A0_WRITE_CMIC_XGXS_PLL_STATUSr(u,r) CDK_DEV_WRITE32(u,BCM53324_A0_CMIC_XGXS_PLL_STATUSr,r._cmic_xgxs_pll_status)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_PLL_STATUSr BCM53324_A0_CMIC_XGXS_PLL_STATUSr
#define CMIC_XGXS_PLL_STATUSr_SIZE BCM53324_A0_CMIC_XGXS_PLL_STATUSr_SIZE
typedef BCM53324_A0_CMIC_XGXS_PLL_STATUSr_t CMIC_XGXS_PLL_STATUSr_t;
#define CMIC_XGXS_PLL_STATUSr_CLR BCM53324_A0_CMIC_XGXS_PLL_STATUSr_CLR
#define CMIC_XGXS_PLL_STATUSr_SET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_SET
#define CMIC_XGXS_PLL_STATUSr_GET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_GET
#define CMIC_XGXS_PLL_STATUSr_PLL_STATUSf_GET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_PLL_STATUSf_GET
#define CMIC_XGXS_PLL_STATUSr_PLL_STATUSf_SET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_PLL_STATUSf_SET
#define CMIC_XGXS_PLL_STATUSr_RESERVED_1f_GET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_RESERVED_1f_GET
#define CMIC_XGXS_PLL_STATUSr_RESERVED_1f_SET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_RESERVED_1f_SET
#define CMIC_XGXS_PLL_STATUSr_QGPHY0_PLL_LOCKf_GET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_QGPHY0_PLL_LOCKf_GET
#define CMIC_XGXS_PLL_STATUSr_QGPHY0_PLL_LOCKf_SET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_QGPHY0_PLL_LOCKf_SET
#define CMIC_XGXS_PLL_STATUSr_QGPHY1_PLL_LOCKf_GET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_QGPHY1_PLL_LOCKf_GET
#define CMIC_XGXS_PLL_STATUSr_QGPHY1_PLL_LOCKf_SET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_QGPHY1_PLL_LOCKf_SET
#define CMIC_XGXS_PLL_STATUSr_CMIC_XG_PLL_LOCKf_GET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_CMIC_XG_PLL_LOCKf_GET
#define CMIC_XGXS_PLL_STATUSr_CMIC_XG_PLL_LOCKf_SET BCM53324_A0_CMIC_XGXS_PLL_STATUSr_CMIC_XG_PLL_LOCKf_SET
#define READ_CMIC_XGXS_PLL_STATUSr BCM53324_A0_READ_CMIC_XGXS_PLL_STATUSr
#define WRITE_CMIC_XGXS_PLL_STATUSr BCM53324_A0_WRITE_CMIC_XGXS_PLL_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CMIC_XGXS_PLL_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNG0COSDROPRATE
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPRATE         Options for drop rate of Simple RED when packet count is over cos' CNG0 limit.0: 100% cliff drop1:  12.5%      2:   6.25%     3:   3.125%    4:   1.5625%   5:   0.78125%  6:   0.390625% 7:   0.1953125%
 *
 ******************************************************************************/
#define BCM53324_A0_CNG0COSDROPRATEr 0x00600094

#define BCM53324_A0_CNG0COSDROPRATEr_SIZE 4

/*
 * This structure should be used to declare and program CNG0COSDROPRATE.
 *
 */
typedef union BCM53324_A0_CNG0COSDROPRATEr_s {
	uint32_t v[1];
	uint32_t cng0cosdroprate[1];
	uint32_t _cng0cosdroprate;
} BCM53324_A0_CNG0COSDROPRATEr_t;

#define BCM53324_A0_CNG0COSDROPRATEr_CLR(r) (r).cng0cosdroprate[0] = 0
#define BCM53324_A0_CNG0COSDROPRATEr_SET(r,d) (r).cng0cosdroprate[0] = d
#define BCM53324_A0_CNG0COSDROPRATEr_GET(r) (r).cng0cosdroprate[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNG0COSDROPRATEr_DROPRATEf_GET(r) (((r).cng0cosdroprate[0]) & 0x7)
#define BCM53324_A0_CNG0COSDROPRATEr_DROPRATEf_SET(r,f) (r).cng0cosdroprate[0]=(((r).cng0cosdroprate[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access CNG0COSDROPRATE.
 *
 */
#define BCM53324_A0_READ_CNG0COSDROPRATEr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNG0COSDROPRATEr+(i),(r._cng0cosdroprate))
#define BCM53324_A0_WRITE_CNG0COSDROPRATEr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNG0COSDROPRATEr+(i),&(r._cng0cosdroprate))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNG0COSDROPRATEr BCM53324_A0_CNG0COSDROPRATEr
#define CNG0COSDROPRATEr_SIZE BCM53324_A0_CNG0COSDROPRATEr_SIZE
typedef BCM53324_A0_CNG0COSDROPRATEr_t CNG0COSDROPRATEr_t;
#define CNG0COSDROPRATEr_CLR BCM53324_A0_CNG0COSDROPRATEr_CLR
#define CNG0COSDROPRATEr_SET BCM53324_A0_CNG0COSDROPRATEr_SET
#define CNG0COSDROPRATEr_GET BCM53324_A0_CNG0COSDROPRATEr_GET
#define CNG0COSDROPRATEr_DROPRATEf_GET BCM53324_A0_CNG0COSDROPRATEr_DROPRATEf_GET
#define CNG0COSDROPRATEr_DROPRATEf_SET BCM53324_A0_CNG0COSDROPRATEr_DROPRATEf_SET
#define READ_CNG0COSDROPRATEr BCM53324_A0_READ_CNG0COSDROPRATEr
#define WRITE_CNG0COSDROPRATEr BCM53324_A0_WRITE_CNG0COSDROPRATEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNG0COSDROPRATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNG1COSDROPRATE
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPRATE         Options for drop rate of Simple RED when packet count is over cos' CNG1 limit.0: 100% cliff drop.1:  12.5%.2:   6.25%3:   3.125%4:   1.5625%5:   0.78125%6:   0.390625%7:   0.1953125%
 *
 ******************************************************************************/
#define BCM53324_A0_CNG1COSDROPRATEr 0x0060009c

#define BCM53324_A0_CNG1COSDROPRATEr_SIZE 4

/*
 * This structure should be used to declare and program CNG1COSDROPRATE.
 *
 */
typedef union BCM53324_A0_CNG1COSDROPRATEr_s {
	uint32_t v[1];
	uint32_t cng1cosdroprate[1];
	uint32_t _cng1cosdroprate;
} BCM53324_A0_CNG1COSDROPRATEr_t;

#define BCM53324_A0_CNG1COSDROPRATEr_CLR(r) (r).cng1cosdroprate[0] = 0
#define BCM53324_A0_CNG1COSDROPRATEr_SET(r,d) (r).cng1cosdroprate[0] = d
#define BCM53324_A0_CNG1COSDROPRATEr_GET(r) (r).cng1cosdroprate[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNG1COSDROPRATEr_DROPRATEf_GET(r) (((r).cng1cosdroprate[0]) & 0x7)
#define BCM53324_A0_CNG1COSDROPRATEr_DROPRATEf_SET(r,f) (r).cng1cosdroprate[0]=(((r).cng1cosdroprate[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access CNG1COSDROPRATE.
 *
 */
#define BCM53324_A0_READ_CNG1COSDROPRATEr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNG1COSDROPRATEr+(i),(r._cng1cosdroprate))
#define BCM53324_A0_WRITE_CNG1COSDROPRATEr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNG1COSDROPRATEr+(i),&(r._cng1cosdroprate))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNG1COSDROPRATEr BCM53324_A0_CNG1COSDROPRATEr
#define CNG1COSDROPRATEr_SIZE BCM53324_A0_CNG1COSDROPRATEr_SIZE
typedef BCM53324_A0_CNG1COSDROPRATEr_t CNG1COSDROPRATEr_t;
#define CNG1COSDROPRATEr_CLR BCM53324_A0_CNG1COSDROPRATEr_CLR
#define CNG1COSDROPRATEr_SET BCM53324_A0_CNG1COSDROPRATEr_SET
#define CNG1COSDROPRATEr_GET BCM53324_A0_CNG1COSDROPRATEr_GET
#define CNG1COSDROPRATEr_DROPRATEf_GET BCM53324_A0_CNG1COSDROPRATEr_DROPRATEf_GET
#define CNG1COSDROPRATEr_DROPRATEf_SET BCM53324_A0_CNG1COSDROPRATEr_DROPRATEf_SET
#define READ_CNG1COSDROPRATEr BCM53324_A0_READ_CNG1COSDROPRATEr
#define WRITE_CNG1COSDROPRATEr BCM53324_A0_WRITE_CNG1COSDROPRATEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNG1COSDROPRATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNGCOSPKTLIMIT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT0  CNG0 Set Limit for COS n for an egress port.This set limit is in the granuality of a packet.When packet count is above this limit, incoming packet carried congestioncolor red (CNG[1:0]==2'b01) or color yellow(CNG[1:0]==2'b11), whenSIMPLEREDCONFIG is set to 1, will be dropped. Packet drop rate is config byCNGDROPRATE  registers. This limit is needed to be set lower thanHOLCOSPKTSETLIMIT of the same port to ensure dropping CNG0 packetmechanism will take effect early than HOL. Number of packetallowed for CNG0 packet per egress port of COS x.
 *
 ******************************************************************************/
#define BCM53324_A0_CNGCOSPKTLIMIT0r 0x0060001f

#define BCM53324_A0_CNGCOSPKTLIMIT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT0.
 *
 */
typedef union BCM53324_A0_CNGCOSPKTLIMIT0r_s {
	uint32_t v[1];
	uint32_t cngcospktlimit0[1];
	uint32_t _cngcospktlimit0;
} BCM53324_A0_CNGCOSPKTLIMIT0r_t;

#define BCM53324_A0_CNGCOSPKTLIMIT0r_CLR(r) (r).cngcospktlimit0[0] = 0
#define BCM53324_A0_CNGCOSPKTLIMIT0r_SET(r,d) (r).cngcospktlimit0[0] = d
#define BCM53324_A0_CNGCOSPKTLIMIT0r_GET(r) (r).cngcospktlimit0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET(r) (((r).cngcospktlimit0[0]) & 0x7ff)
#define BCM53324_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET(r,f) (r).cngcospktlimit0[0]=(((r).cngcospktlimit0[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT0.
 *
 */
#define BCM53324_A0_READ_CNGCOSPKTLIMIT0r(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNGCOSPKTLIMIT0r+(i),(r._cngcospktlimit0))
#define BCM53324_A0_WRITE_CNGCOSPKTLIMIT0r(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNGCOSPKTLIMIT0r+(i),&(r._cngcospktlimit0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGCOSPKTLIMIT0r BCM53324_A0_CNGCOSPKTLIMIT0r
#define CNGCOSPKTLIMIT0r_SIZE BCM53324_A0_CNGCOSPKTLIMIT0r_SIZE
typedef BCM53324_A0_CNGCOSPKTLIMIT0r_t CNGCOSPKTLIMIT0r_t;
#define CNGCOSPKTLIMIT0r_CLR BCM53324_A0_CNGCOSPKTLIMIT0r_CLR
#define CNGCOSPKTLIMIT0r_SET BCM53324_A0_CNGCOSPKTLIMIT0r_SET
#define CNGCOSPKTLIMIT0r_GET BCM53324_A0_CNGCOSPKTLIMIT0r_GET
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET BCM53324_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_GET
#define CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET BCM53324_A0_CNGCOSPKTLIMIT0r_CNGPKTSETLIMIT0f_SET
#define READ_CNGCOSPKTLIMIT0r BCM53324_A0_READ_CNGCOSPKTLIMIT0r
#define WRITE_CNGCOSPKTLIMIT0r BCM53324_A0_WRITE_CNGCOSPKTLIMIT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNGCOSPKTLIMIT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNGCOSPKTLIMIT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPKTSETLIMIT1  CNG1 Set Limit for COS n for an egress port.This set limit is in the granuality of a packet.When packet count is above this limit, incoming packet carried congestioncolor green (CNG[1:0]==2'b00), whenSIMPLEREDCONFIG is set to 1, will be dropped. Packet drop rate is config byCNGDROPRATE  registers. This limit is needed to be set lower thanHOLCOSPKTSETLIMIT of the same port to ensure dropping CNG1 packetmechanism will take effect early than HOL. Number of packetallowed for CNG1 packet per egress port of COS x.
 *
 ******************************************************************************/
#define BCM53324_A0_CNGCOSPKTLIMIT1r 0x00600027

#define BCM53324_A0_CNGCOSPKTLIMIT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGCOSPKTLIMIT1.
 *
 */
typedef union BCM53324_A0_CNGCOSPKTLIMIT1r_s {
	uint32_t v[1];
	uint32_t cngcospktlimit1[1];
	uint32_t _cngcospktlimit1;
} BCM53324_A0_CNGCOSPKTLIMIT1r_t;

#define BCM53324_A0_CNGCOSPKTLIMIT1r_CLR(r) (r).cngcospktlimit1[0] = 0
#define BCM53324_A0_CNGCOSPKTLIMIT1r_SET(r,d) (r).cngcospktlimit1[0] = d
#define BCM53324_A0_CNGCOSPKTLIMIT1r_GET(r) (r).cngcospktlimit1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET(r) (((r).cngcospktlimit1[0]) & 0x7ff)
#define BCM53324_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET(r,f) (r).cngcospktlimit1[0]=(((r).cngcospktlimit1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CNGCOSPKTLIMIT1.
 *
 */
#define BCM53324_A0_READ_CNGCOSPKTLIMIT1r(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNGCOSPKTLIMIT1r+(i),(r._cngcospktlimit1))
#define BCM53324_A0_WRITE_CNGCOSPKTLIMIT1r(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNGCOSPKTLIMIT1r+(i),&(r._cngcospktlimit1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGCOSPKTLIMIT1r BCM53324_A0_CNGCOSPKTLIMIT1r
#define CNGCOSPKTLIMIT1r_SIZE BCM53324_A0_CNGCOSPKTLIMIT1r_SIZE
typedef BCM53324_A0_CNGCOSPKTLIMIT1r_t CNGCOSPKTLIMIT1r_t;
#define CNGCOSPKTLIMIT1r_CLR BCM53324_A0_CNGCOSPKTLIMIT1r_CLR
#define CNGCOSPKTLIMIT1r_SET BCM53324_A0_CNGCOSPKTLIMIT1r_SET
#define CNGCOSPKTLIMIT1r_GET BCM53324_A0_CNGCOSPKTLIMIT1r_GET
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET BCM53324_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_GET
#define CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET BCM53324_A0_CNGCOSPKTLIMIT1r_CNGPKTSETLIMIT1f_SET
#define READ_CNGCOSPKTLIMIT1r BCM53324_A0_READ_CNGCOSPKTLIMIT1r
#define WRITE_CNGCOSPKTLIMIT1r BCM53324_A0_WRITE_CNGCOSPKTLIMIT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNGCOSPKTLIMIT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNGDROPCOUNT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPKTCOUNT     Dropped Packet Count accounts for congestion color red dropped packets for eachegress port after its HOLPktCount over CNG0 Packet Set limit. This is per port based counter collecting all packets for this port on different COS. Number of packets per egress port.
 *
 ******************************************************************************/
#define BCM53324_A0_CNGDROPCOUNT0r 0x0060006b

#define BCM53324_A0_CNGDROPCOUNT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGDROPCOUNT0.
 *
 */
typedef union BCM53324_A0_CNGDROPCOUNT0r_s {
	uint32_t v[1];
	uint32_t cngdropcount0[1];
	uint32_t _cngdropcount0;
} BCM53324_A0_CNGDROPCOUNT0r_t;

#define BCM53324_A0_CNGDROPCOUNT0r_CLR(r) (r).cngdropcount0[0] = 0
#define BCM53324_A0_CNGDROPCOUNT0r_SET(r,d) (r).cngdropcount0[0] = d
#define BCM53324_A0_CNGDROPCOUNT0r_GET(r) (r).cngdropcount0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_GET(r) ((r).cngdropcount0[0])
#define BCM53324_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_SET(r,f) (r).cngdropcount0[0]=((uint32_t)f)

/*
 * These macros can be used to access CNGDROPCOUNT0.
 *
 */
#define BCM53324_A0_READ_CNGDROPCOUNT0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNGDROPCOUNT0r,(r._cngdropcount0))
#define BCM53324_A0_WRITE_CNGDROPCOUNT0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNGDROPCOUNT0r,&(r._cngdropcount0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGDROPCOUNT0r BCM53324_A0_CNGDROPCOUNT0r
#define CNGDROPCOUNT0r_SIZE BCM53324_A0_CNGDROPCOUNT0r_SIZE
typedef BCM53324_A0_CNGDROPCOUNT0r_t CNGDROPCOUNT0r_t;
#define CNGDROPCOUNT0r_CLR BCM53324_A0_CNGDROPCOUNT0r_CLR
#define CNGDROPCOUNT0r_SET BCM53324_A0_CNGDROPCOUNT0r_SET
#define CNGDROPCOUNT0r_GET BCM53324_A0_CNGDROPCOUNT0r_GET
#define CNGDROPCOUNT0r_DROPPKTCOUNTf_GET BCM53324_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_GET
#define CNGDROPCOUNT0r_DROPPKTCOUNTf_SET BCM53324_A0_CNGDROPCOUNT0r_DROPPKTCOUNTf_SET
#define READ_CNGDROPCOUNT0r BCM53324_A0_READ_CNGDROPCOUNT0r
#define WRITE_CNGDROPCOUNT0r BCM53324_A0_WRITE_CNGDROPCOUNT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNGDROPCOUNT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNGDROPCOUNT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPKTCOUNT     Dropped Packet Count accounts for congestion color yellow dropped packets for eachegress port after its HOLPktCount over CNG1 Packet Set limit. This is per port based counter collecting all packets for this port on different COS. Number of packets per egress port.
 *
 ******************************************************************************/
#define BCM53324_A0_CNGDROPCOUNT1r 0x0060006c

#define BCM53324_A0_CNGDROPCOUNT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGDROPCOUNT1.
 *
 */
typedef union BCM53324_A0_CNGDROPCOUNT1r_s {
	uint32_t v[1];
	uint32_t cngdropcount1[1];
	uint32_t _cngdropcount1;
} BCM53324_A0_CNGDROPCOUNT1r_t;

#define BCM53324_A0_CNGDROPCOUNT1r_CLR(r) (r).cngdropcount1[0] = 0
#define BCM53324_A0_CNGDROPCOUNT1r_SET(r,d) (r).cngdropcount1[0] = d
#define BCM53324_A0_CNGDROPCOUNT1r_GET(r) (r).cngdropcount1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_GET(r) ((r).cngdropcount1[0])
#define BCM53324_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_SET(r,f) (r).cngdropcount1[0]=((uint32_t)f)

/*
 * These macros can be used to access CNGDROPCOUNT1.
 *
 */
#define BCM53324_A0_READ_CNGDROPCOUNT1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNGDROPCOUNT1r,(r._cngdropcount1))
#define BCM53324_A0_WRITE_CNGDROPCOUNT1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNGDROPCOUNT1r,&(r._cngdropcount1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGDROPCOUNT1r BCM53324_A0_CNGDROPCOUNT1r
#define CNGDROPCOUNT1r_SIZE BCM53324_A0_CNGDROPCOUNT1r_SIZE
typedef BCM53324_A0_CNGDROPCOUNT1r_t CNGDROPCOUNT1r_t;
#define CNGDROPCOUNT1r_CLR BCM53324_A0_CNGDROPCOUNT1r_CLR
#define CNGDROPCOUNT1r_SET BCM53324_A0_CNGDROPCOUNT1r_SET
#define CNGDROPCOUNT1r_GET BCM53324_A0_CNGDROPCOUNT1r_GET
#define CNGDROPCOUNT1r_DROPPKTCOUNTf_GET BCM53324_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_GET
#define CNGDROPCOUNT1r_DROPPKTCOUNTf_SET BCM53324_A0_CNGDROPCOUNT1r_DROPPKTCOUNTf_SET
#define READ_CNGDROPCOUNT1r BCM53324_A0_READ_CNGDROPCOUNT1r
#define WRITE_CNGDROPCOUNT1r BCM53324_A0_WRITE_CNGDROPCOUNT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNGDROPCOUNT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNGPORTPKTLIMIT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPORTPKTLIMIT0 CNG0 Set Limit for an egress port.When packet count for an egress port is above this limit, incoming packet carried congestion color red (CNG[1:0]==2'b01) will be dropped for that port, if that cos is consuming XQ dynamicspace. This limit is needed to be set lower than Total XQ size of the same port to ensure dropping CNG0 packet mechanism will take effect early than HOL. 
 *
 ******************************************************************************/
#define BCM53324_A0_CNGPORTPKTLIMIT0r 0x00600037

#define BCM53324_A0_CNGPORTPKTLIMIT0r_SIZE 4

/*
 * This structure should be used to declare and program CNGPORTPKTLIMIT0.
 *
 */
typedef union BCM53324_A0_CNGPORTPKTLIMIT0r_s {
	uint32_t v[1];
	uint32_t cngportpktlimit0[1];
	uint32_t _cngportpktlimit0;
} BCM53324_A0_CNGPORTPKTLIMIT0r_t;

#define BCM53324_A0_CNGPORTPKTLIMIT0r_CLR(r) (r).cngportpktlimit0[0] = 0
#define BCM53324_A0_CNGPORTPKTLIMIT0r_SET(r,d) (r).cngportpktlimit0[0] = d
#define BCM53324_A0_CNGPORTPKTLIMIT0r_GET(r) (r).cngportpktlimit0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_GET(r) (((r).cngportpktlimit0[0]) & 0x7ff)
#define BCM53324_A0_CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_SET(r,f) (r).cngportpktlimit0[0]=(((r).cngportpktlimit0[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CNGPORTPKTLIMIT0.
 *
 */
#define BCM53324_A0_READ_CNGPORTPKTLIMIT0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNGPORTPKTLIMIT0r,(r._cngportpktlimit0))
#define BCM53324_A0_WRITE_CNGPORTPKTLIMIT0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNGPORTPKTLIMIT0r,&(r._cngportpktlimit0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGPORTPKTLIMIT0r BCM53324_A0_CNGPORTPKTLIMIT0r
#define CNGPORTPKTLIMIT0r_SIZE BCM53324_A0_CNGPORTPKTLIMIT0r_SIZE
typedef BCM53324_A0_CNGPORTPKTLIMIT0r_t CNGPORTPKTLIMIT0r_t;
#define CNGPORTPKTLIMIT0r_CLR BCM53324_A0_CNGPORTPKTLIMIT0r_CLR
#define CNGPORTPKTLIMIT0r_SET BCM53324_A0_CNGPORTPKTLIMIT0r_SET
#define CNGPORTPKTLIMIT0r_GET BCM53324_A0_CNGPORTPKTLIMIT0r_GET
#define CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_GET BCM53324_A0_CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_GET
#define CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_SET BCM53324_A0_CNGPORTPKTLIMIT0r_CNGPORTPKTLIMIT0f_SET
#define READ_CNGPORTPKTLIMIT0r BCM53324_A0_READ_CNGPORTPKTLIMIT0r
#define WRITE_CNGPORTPKTLIMIT0r BCM53324_A0_WRITE_CNGPORTPKTLIMIT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNGPORTPKTLIMIT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNGPORTPKTLIMIT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CNGPORTPKTLIMIT1 CNG1 Set Limit for an egress port.When packet count for the port is above this limit, incoming packet carried congestion color yellow (CNG[1:0]==2'b11) will be dropped. This limit is needed to be set lower than Total XQ size of the same port to ensure dropping CNG1 packet.
 *
 ******************************************************************************/
#define BCM53324_A0_CNGPORTPKTLIMIT1r 0x00600038

#define BCM53324_A0_CNGPORTPKTLIMIT1r_SIZE 4

/*
 * This structure should be used to declare and program CNGPORTPKTLIMIT1.
 *
 */
typedef union BCM53324_A0_CNGPORTPKTLIMIT1r_s {
	uint32_t v[1];
	uint32_t cngportpktlimit1[1];
	uint32_t _cngportpktlimit1;
} BCM53324_A0_CNGPORTPKTLIMIT1r_t;

#define BCM53324_A0_CNGPORTPKTLIMIT1r_CLR(r) (r).cngportpktlimit1[0] = 0
#define BCM53324_A0_CNGPORTPKTLIMIT1r_SET(r,d) (r).cngportpktlimit1[0] = d
#define BCM53324_A0_CNGPORTPKTLIMIT1r_GET(r) (r).cngportpktlimit1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_GET(r) (((r).cngportpktlimit1[0]) & 0x7ff)
#define BCM53324_A0_CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_SET(r,f) (r).cngportpktlimit1[0]=(((r).cngportpktlimit1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access CNGPORTPKTLIMIT1.
 *
 */
#define BCM53324_A0_READ_CNGPORTPKTLIMIT1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNGPORTPKTLIMIT1r,(r._cngportpktlimit1))
#define BCM53324_A0_WRITE_CNGPORTPKTLIMIT1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNGPORTPKTLIMIT1r,&(r._cngportpktlimit1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNGPORTPKTLIMIT1r BCM53324_A0_CNGPORTPKTLIMIT1r
#define CNGPORTPKTLIMIT1r_SIZE BCM53324_A0_CNGPORTPKTLIMIT1r_SIZE
typedef BCM53324_A0_CNGPORTPKTLIMIT1r_t CNGPORTPKTLIMIT1r_t;
#define CNGPORTPKTLIMIT1r_CLR BCM53324_A0_CNGPORTPKTLIMIT1r_CLR
#define CNGPORTPKTLIMIT1r_SET BCM53324_A0_CNGPORTPKTLIMIT1r_SET
#define CNGPORTPKTLIMIT1r_GET BCM53324_A0_CNGPORTPKTLIMIT1r_GET
#define CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_GET BCM53324_A0_CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_GET
#define CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_SET BCM53324_A0_CNGPORTPKTLIMIT1r_CNGPORTPKTLIMIT1f_SET
#define READ_CNGPORTPKTLIMIT1r BCM53324_A0_READ_CNGPORTPKTLIMIT1r
#define WRITE_CNGPORTPKTLIMIT1r BCM53324_A0_WRITE_CNGPORTPKTLIMIT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNGPORTPKTLIMIT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CNG_MAP
 * BLOCKS:   IPIPE
 * DESC:     CNG Mapping Register
 * SIZE:     32
 * FIELDS:
 *     PRIORITY0_CNG    Maps the packet priority(0) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY1_CNG    Maps the packet priority(1) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY2_CNG    Maps the packet priority(2) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY3_CNG    Maps the packet priority(3) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY4_CNG    Maps the packet priority(4) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY5_CNG    Maps the packet priority(5) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY6_CNG    Maps the packet priority(6) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY7_CNG    Maps the packet priority(7) to a default CNG (congestion value for untrusted ports)
 *
 ******************************************************************************/
#define BCM53324_A0_CNG_MAPr 0x0c700000

#define BCM53324_A0_CNG_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CNG_MAP.
 *
 */
typedef union BCM53324_A0_CNG_MAPr_s {
	uint32_t v[1];
	uint32_t cng_map[1];
	uint32_t _cng_map;
} BCM53324_A0_CNG_MAPr_t;

#define BCM53324_A0_CNG_MAPr_CLR(r) (r).cng_map[0] = 0
#define BCM53324_A0_CNG_MAPr_SET(r,d) (r).cng_map[0] = d
#define BCM53324_A0_CNG_MAPr_GET(r) (r).cng_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CNG_MAPr_PRIORITY0_CNGf_GET(r) (((r).cng_map[0]) & 0x3)
#define BCM53324_A0_CNG_MAPr_PRIORITY0_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_CNG_MAPr_PRIORITY1_CNGf_GET(r) ((((r).cng_map[0]) >> 2) & 0x3)
#define BCM53324_A0_CNG_MAPr_PRIORITY1_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_CNG_MAPr_PRIORITY2_CNGf_GET(r) ((((r).cng_map[0]) >> 4) & 0x3)
#define BCM53324_A0_CNG_MAPr_PRIORITY2_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_CNG_MAPr_PRIORITY3_CNGf_GET(r) ((((r).cng_map[0]) >> 6) & 0x3)
#define BCM53324_A0_CNG_MAPr_PRIORITY3_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53324_A0_CNG_MAPr_PRIORITY4_CNGf_GET(r) ((((r).cng_map[0]) >> 8) & 0x3)
#define BCM53324_A0_CNG_MAPr_PRIORITY4_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53324_A0_CNG_MAPr_PRIORITY5_CNGf_GET(r) ((((r).cng_map[0]) >> 10) & 0x3)
#define BCM53324_A0_CNG_MAPr_PRIORITY5_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53324_A0_CNG_MAPr_PRIORITY6_CNGf_GET(r) ((((r).cng_map[0]) >> 12) & 0x3)
#define BCM53324_A0_CNG_MAPr_PRIORITY6_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53324_A0_CNG_MAPr_PRIORITY7_CNGf_GET(r) ((((r).cng_map[0]) >> 14) & 0x3)
#define BCM53324_A0_CNG_MAPr_PRIORITY7_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access CNG_MAP.
 *
 */
#define BCM53324_A0_READ_CNG_MAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_CNG_MAPr,(r._cng_map))
#define BCM53324_A0_WRITE_CNG_MAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_CNG_MAPr,&(r._cng_map))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNG_MAPr BCM53324_A0_CNG_MAPr
#define CNG_MAPr_SIZE BCM53324_A0_CNG_MAPr_SIZE
typedef BCM53324_A0_CNG_MAPr_t CNG_MAPr_t;
#define CNG_MAPr_CLR BCM53324_A0_CNG_MAPr_CLR
#define CNG_MAPr_SET BCM53324_A0_CNG_MAPr_SET
#define CNG_MAPr_GET BCM53324_A0_CNG_MAPr_GET
#define CNG_MAPr_PRIORITY0_CNGf_GET BCM53324_A0_CNG_MAPr_PRIORITY0_CNGf_GET
#define CNG_MAPr_PRIORITY0_CNGf_SET BCM53324_A0_CNG_MAPr_PRIORITY0_CNGf_SET
#define CNG_MAPr_PRIORITY1_CNGf_GET BCM53324_A0_CNG_MAPr_PRIORITY1_CNGf_GET
#define CNG_MAPr_PRIORITY1_CNGf_SET BCM53324_A0_CNG_MAPr_PRIORITY1_CNGf_SET
#define CNG_MAPr_PRIORITY2_CNGf_GET BCM53324_A0_CNG_MAPr_PRIORITY2_CNGf_GET
#define CNG_MAPr_PRIORITY2_CNGf_SET BCM53324_A0_CNG_MAPr_PRIORITY2_CNGf_SET
#define CNG_MAPr_PRIORITY3_CNGf_GET BCM53324_A0_CNG_MAPr_PRIORITY3_CNGf_GET
#define CNG_MAPr_PRIORITY3_CNGf_SET BCM53324_A0_CNG_MAPr_PRIORITY3_CNGf_SET
#define CNG_MAPr_PRIORITY4_CNGf_GET BCM53324_A0_CNG_MAPr_PRIORITY4_CNGf_GET
#define CNG_MAPr_PRIORITY4_CNGf_SET BCM53324_A0_CNG_MAPr_PRIORITY4_CNGf_SET
#define CNG_MAPr_PRIORITY5_CNGf_GET BCM53324_A0_CNG_MAPr_PRIORITY5_CNGf_GET
#define CNG_MAPr_PRIORITY5_CNGf_SET BCM53324_A0_CNG_MAPr_PRIORITY5_CNGf_SET
#define CNG_MAPr_PRIORITY6_CNGf_GET BCM53324_A0_CNG_MAPr_PRIORITY6_CNGf_GET
#define CNG_MAPr_PRIORITY6_CNGf_SET BCM53324_A0_CNG_MAPr_PRIORITY6_CNGf_SET
#define CNG_MAPr_PRIORITY7_CNGf_GET BCM53324_A0_CNG_MAPr_PRIORITY7_CNGf_GET
#define CNG_MAPr_PRIORITY7_CNGf_SET BCM53324_A0_CNG_MAPr_PRIORITY7_CNGf_SET
#define READ_CNG_MAPr BCM53324_A0_READ_CNG_MAPr
#define WRITE_CNG_MAPr BCM53324_A0_WRITE_CNG_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CNG_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  COMMAND_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     Command register. Used by the host processor to control and configure the core
 * SIZE:     32
 * FIELDS:
 *     TX_ENA           Enable/Disable MAC transmit path for data packets & pause packets sent in the normal data path.Pause packets generated internally are allowed if ignore_tx_pause is not set.When set to '0' (Reset value), the MAC transmit function is disable.  When set to '1', the MAC transmit function is enabled.
 *     RX_ENA           Enable/Disable MAC receive path. When set to '0' (Reset value), the MAC receive function is disable.  When set to '1', the MAC receive function is enabled.
 *     ETH_SPEED         Set MAC speed. Ignored when the register bit ENA_EXT_CONFIG is set to '1'.  When the Register bit ENA_EXT_CONFIG is set to '0', used to set the core mode of operation: 00: Enable 10Mbps Ethernet mode 01: Enable 100Mbps Ethernet mode 10: Enable Gigabit Ethernet mode 11: Enable 2.5Gigabit Ethernet mode
 *     PROMIS_EN        Enable/Disable MAC promiscuous operation. When asserted (Set to '1'), all frames are received without Unicast address filtering.
 *     PAD_EN           Enable/Disable Frame Padding. If enabled (Set to '1') frames are padded on transmit if necessary to guarantee a minimum frame size of 64 octets and, on receive, padding is removed before the frame is transmitted to the userapplication. If disabled (set to reset value '0') no padding is appended on transmit and no padding is removed on receive by the MAC.
 *     CRC_FWD          Terminate/Forward Received CRC. If enabled (1) the CRC field of received frames is transmitted to the user application.If disabled (Set to reset value '0') the CRC field is stripped from the frame.Note: If padding function (Bit PAD_EN set to '1') is enabled. CRC_FWD is ignored and the CRC field is checked and always terminated and removed.
 *     PAUSE_FWD        Terminate/Forward Pause Frames. If enabled (Set to '1') pause frames are forwraded to the user application.  If disabled (Set to reset value '0'), pause frames are terminated and discarded in the MAC.
 *     PAUSE_IGNORE     Ignore Pause Frame Quanta. If enabled (Set to '1') received pause frames are ignored by the MAC. When disabled (Set to reset value '0') the transmit process is stopped for the amount of time specified in the pause quanta received within the pause frame.
 *     TX_ADDR_INS      Set MAC address on transmit. If enabled (Set to '1') the MAC overwrites the source MAC address with the programmed MAC address in registers MAC_0 and MAC_1. If disabled (Set to reset value '0'), the source MAC address received from the transmit application transmitted is not modified by the MAC.
 *     HD_ENA           Half duplex enable. When set to '1', enables half duplex mode, when set to '0', the MAC operates in full duplex mode.Ignored when the register bits ETH_SPEED(1:0) are set to '10' (Gigabit Ethernet enabled) or set to "11" (2.5 Gigabit Ethernet enabled) and the register ENA_EXT_CONFIG is set to '0'. Ignored when the register ENA_EXT_CONFIG is set to '1'.
 *     SW_RESET         Software Reset Command. When asserted, the TX and RX are disabled. Write a 0 to de-assert the sw reset. 
 *     LOOP_ENA         Enable GMII/MII loopback when set to '1', normal operation when set to '0' (Reset value).
 *     ENA_EXT_CONFIG   Enable Configuration with External Pins. When set to '0' (Reset value) the Core speed and Mode is programmed with the register bits ETH_SPEED(1:0) and HD_ENA. When set to '1', the Core is configured with the pins set_speed(1:0) and set_duplex.
 *     CNTL_FRM_ENA     MAC Control Frame Enable. When set to '1', MAC Control frames with any Opcode other than 0x0001 are accepted and forward to the Client interface. When set to '0' (Reset value), MAC Control frames with any Opcode other than 0x0001 are silently discarded.
 *     NO_LGTH_CHECK    Payload Length Check Disable. When set to '0', the Core checks the frame's payload length with the FrameLength/Type field, when set to '1'(Reset value), the payload length check is disabled.
 *     LINE_LOOPBACK    Enable GMII/MII Line Loopback when set to '1', normal operation when set to '0' (Reset value).
 *     RX_ERR_DISC      Receive Errored Frame Discard Enable. When set to '1', any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to '0', errored Frames are forwarded to the Client interface with ff_rx_err asserted.It is recommended to set RX_ERR_DISC to '1' only when Store and Forward operation is enabled on the Core Receive FIFO Receive FIFO Section full threshold set to 0).
 *     PRBL_ENA         EFM Preamble Insertion and Extraction. When set to '1', and only if the MAC is configured to support EFM Preamble, enables EFM Preamble Insertion and Extraction. When set to '0' (Reset value), enables standard Preamble support.
 *     IGNORE_TX_PAUSE  Ignores the back pressure signalling from the system and hence no pause generation, when set.
 *     SW_CTRL_RXTX_AFTER_LKUP After autoNeg link up, when set to '1', the RX_ENA/TX_ENA will not be back to alive automatically.It is for diagnostic purpose. By default '0', the RX_ENA/TX_ENA will be resumed after autoNeg is done.
 *     RUNT_FILTER_DIS  When set, disable runt filtering.
 *     LATE_COL_FIX     When set, enables the fix for late colision GNAT 13837. Can be cleared to disable the fix so the Mac works as before the fix. This is fall back plan if something goes wrong due to this fix in the chip.
 *
 ******************************************************************************/
#define BCM53324_A0_COMMAND_CONFIGr 0x00000102

#define BCM53324_A0_COMMAND_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program COMMAND_CONFIG.
 *
 */
typedef union BCM53324_A0_COMMAND_CONFIGr_s {
	uint32_t v[1];
	uint32_t command_config[1];
	uint32_t _command_config;
} BCM53324_A0_COMMAND_CONFIGr_t;

#define BCM53324_A0_COMMAND_CONFIGr_CLR(r) (r).command_config[0] = 0
#define BCM53324_A0_COMMAND_CONFIGr_SET(r,d) (r).command_config[0] = d
#define BCM53324_A0_COMMAND_CONFIGr_GET(r) (r).command_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_COMMAND_CONFIGr_TX_ENAf_GET(r) (((r).command_config[0]) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_TX_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_COMMAND_CONFIGr_RX_ENAf_GET(r) ((((r).command_config[0]) >> 1) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_RX_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_COMMAND_CONFIGr_ETH_SPEEDf_GET(r) ((((r).command_config[0]) >> 2) & 0x3)
#define BCM53324_A0_COMMAND_CONFIGr_ETH_SPEEDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_COMMAND_CONFIGr_PROMIS_ENf_GET(r) ((((r).command_config[0]) >> 4) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_PROMIS_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_COMMAND_CONFIGr_PAD_ENf_GET(r) ((((r).command_config[0]) >> 5) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_PAD_ENf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_COMMAND_CONFIGr_CRC_FWDf_GET(r) ((((r).command_config[0]) >> 6) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_CRC_FWDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_COMMAND_CONFIGr_PAUSE_FWDf_GET(r) ((((r).command_config[0]) >> 7) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_PAUSE_FWDf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_COMMAND_CONFIGr_PAUSE_IGNOREf_GET(r) ((((r).command_config[0]) >> 8) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_PAUSE_IGNOREf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_COMMAND_CONFIGr_TX_ADDR_INSf_GET(r) ((((r).command_config[0]) >> 9) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_TX_ADDR_INSf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_COMMAND_CONFIGr_HD_ENAf_GET(r) ((((r).command_config[0]) >> 10) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_HD_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_COMMAND_CONFIGr_SW_RESETf_GET(r) ((((r).command_config[0]) >> 13) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_SW_RESETf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_COMMAND_CONFIGr_LOOP_ENAf_GET(r) ((((r).command_config[0]) >> 15) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_LOOP_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_COMMAND_CONFIGr_ENA_EXT_CONFIGf_GET(r) ((((r).command_config[0]) >> 22) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_ENA_EXT_CONFIGf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_COMMAND_CONFIGr_CNTL_FRM_ENAf_GET(r) ((((r).command_config[0]) >> 23) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_CNTL_FRM_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_COMMAND_CONFIGr_NO_LGTH_CHECKf_GET(r) ((((r).command_config[0]) >> 24) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_NO_LGTH_CHECKf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_COMMAND_CONFIGr_LINE_LOOPBACKf_GET(r) ((((r).command_config[0]) >> 25) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_LINE_LOOPBACKf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_COMMAND_CONFIGr_RX_ERR_DISCf_GET(r) ((((r).command_config[0]) >> 26) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_RX_ERR_DISCf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_COMMAND_CONFIGr_PRBL_ENAf_GET(r) ((((r).command_config[0]) >> 27) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_PRBL_ENAf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_COMMAND_CONFIGr_IGNORE_TX_PAUSEf_GET(r) ((((r).command_config[0]) >> 28) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_IGNORE_TX_PAUSEf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53324_A0_COMMAND_CONFIGr_SW_CTRL_RXTX_AFTER_LKUPf_GET(r) ((((r).command_config[0]) >> 29) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_SW_CTRL_RXTX_AFTER_LKUPf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_COMMAND_CONFIGr_RUNT_FILTER_DISf_GET(r) ((((r).command_config[0]) >> 30) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_RUNT_FILTER_DISf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_COMMAND_CONFIGr_LATE_COL_FIXf_GET(r) ((((r).command_config[0]) >> 31) & 0x1)
#define BCM53324_A0_COMMAND_CONFIGr_LATE_COL_FIXf_SET(r,f) (r).command_config[0]=(((r).command_config[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access COMMAND_CONFIG.
 *
 */
#define BCM53324_A0_READ_COMMAND_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_COMMAND_CONFIGr,(r._command_config))
#define BCM53324_A0_WRITE_COMMAND_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_COMMAND_CONFIGr,&(r._command_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COMMAND_CONFIGr BCM53324_A0_COMMAND_CONFIGr
#define COMMAND_CONFIGr_SIZE BCM53324_A0_COMMAND_CONFIGr_SIZE
typedef BCM53324_A0_COMMAND_CONFIGr_t COMMAND_CONFIGr_t;
#define COMMAND_CONFIGr_CLR BCM53324_A0_COMMAND_CONFIGr_CLR
#define COMMAND_CONFIGr_SET BCM53324_A0_COMMAND_CONFIGr_SET
#define COMMAND_CONFIGr_GET BCM53324_A0_COMMAND_CONFIGr_GET
#define COMMAND_CONFIGr_TX_ENAf_GET BCM53324_A0_COMMAND_CONFIGr_TX_ENAf_GET
#define COMMAND_CONFIGr_TX_ENAf_SET BCM53324_A0_COMMAND_CONFIGr_TX_ENAf_SET
#define COMMAND_CONFIGr_RX_ENAf_GET BCM53324_A0_COMMAND_CONFIGr_RX_ENAf_GET
#define COMMAND_CONFIGr_RX_ENAf_SET BCM53324_A0_COMMAND_CONFIGr_RX_ENAf_SET
#define COMMAND_CONFIGr_ETH_SPEEDf_GET BCM53324_A0_COMMAND_CONFIGr_ETH_SPEEDf_GET
#define COMMAND_CONFIGr_ETH_SPEEDf_SET BCM53324_A0_COMMAND_CONFIGr_ETH_SPEEDf_SET
#define COMMAND_CONFIGr_PROMIS_ENf_GET BCM53324_A0_COMMAND_CONFIGr_PROMIS_ENf_GET
#define COMMAND_CONFIGr_PROMIS_ENf_SET BCM53324_A0_COMMAND_CONFIGr_PROMIS_ENf_SET
#define COMMAND_CONFIGr_PAD_ENf_GET BCM53324_A0_COMMAND_CONFIGr_PAD_ENf_GET
#define COMMAND_CONFIGr_PAD_ENf_SET BCM53324_A0_COMMAND_CONFIGr_PAD_ENf_SET
#define COMMAND_CONFIGr_CRC_FWDf_GET BCM53324_A0_COMMAND_CONFIGr_CRC_FWDf_GET
#define COMMAND_CONFIGr_CRC_FWDf_SET BCM53324_A0_COMMAND_CONFIGr_CRC_FWDf_SET
#define COMMAND_CONFIGr_PAUSE_FWDf_GET BCM53324_A0_COMMAND_CONFIGr_PAUSE_FWDf_GET
#define COMMAND_CONFIGr_PAUSE_FWDf_SET BCM53324_A0_COMMAND_CONFIGr_PAUSE_FWDf_SET
#define COMMAND_CONFIGr_PAUSE_IGNOREf_GET BCM53324_A0_COMMAND_CONFIGr_PAUSE_IGNOREf_GET
#define COMMAND_CONFIGr_PAUSE_IGNOREf_SET BCM53324_A0_COMMAND_CONFIGr_PAUSE_IGNOREf_SET
#define COMMAND_CONFIGr_TX_ADDR_INSf_GET BCM53324_A0_COMMAND_CONFIGr_TX_ADDR_INSf_GET
#define COMMAND_CONFIGr_TX_ADDR_INSf_SET BCM53324_A0_COMMAND_CONFIGr_TX_ADDR_INSf_SET
#define COMMAND_CONFIGr_HD_ENAf_GET BCM53324_A0_COMMAND_CONFIGr_HD_ENAf_GET
#define COMMAND_CONFIGr_HD_ENAf_SET BCM53324_A0_COMMAND_CONFIGr_HD_ENAf_SET
#define COMMAND_CONFIGr_SW_RESETf_GET BCM53324_A0_COMMAND_CONFIGr_SW_RESETf_GET
#define COMMAND_CONFIGr_SW_RESETf_SET BCM53324_A0_COMMAND_CONFIGr_SW_RESETf_SET
#define COMMAND_CONFIGr_LOOP_ENAf_GET BCM53324_A0_COMMAND_CONFIGr_LOOP_ENAf_GET
#define COMMAND_CONFIGr_LOOP_ENAf_SET BCM53324_A0_COMMAND_CONFIGr_LOOP_ENAf_SET
#define COMMAND_CONFIGr_ENA_EXT_CONFIGf_GET BCM53324_A0_COMMAND_CONFIGr_ENA_EXT_CONFIGf_GET
#define COMMAND_CONFIGr_ENA_EXT_CONFIGf_SET BCM53324_A0_COMMAND_CONFIGr_ENA_EXT_CONFIGf_SET
#define COMMAND_CONFIGr_CNTL_FRM_ENAf_GET BCM53324_A0_COMMAND_CONFIGr_CNTL_FRM_ENAf_GET
#define COMMAND_CONFIGr_CNTL_FRM_ENAf_SET BCM53324_A0_COMMAND_CONFIGr_CNTL_FRM_ENAf_SET
#define COMMAND_CONFIGr_NO_LGTH_CHECKf_GET BCM53324_A0_COMMAND_CONFIGr_NO_LGTH_CHECKf_GET
#define COMMAND_CONFIGr_NO_LGTH_CHECKf_SET BCM53324_A0_COMMAND_CONFIGr_NO_LGTH_CHECKf_SET
#define COMMAND_CONFIGr_LINE_LOOPBACKf_GET BCM53324_A0_COMMAND_CONFIGr_LINE_LOOPBACKf_GET
#define COMMAND_CONFIGr_LINE_LOOPBACKf_SET BCM53324_A0_COMMAND_CONFIGr_LINE_LOOPBACKf_SET
#define COMMAND_CONFIGr_RX_ERR_DISCf_GET BCM53324_A0_COMMAND_CONFIGr_RX_ERR_DISCf_GET
#define COMMAND_CONFIGr_RX_ERR_DISCf_SET BCM53324_A0_COMMAND_CONFIGr_RX_ERR_DISCf_SET
#define COMMAND_CONFIGr_PRBL_ENAf_GET BCM53324_A0_COMMAND_CONFIGr_PRBL_ENAf_GET
#define COMMAND_CONFIGr_PRBL_ENAf_SET BCM53324_A0_COMMAND_CONFIGr_PRBL_ENAf_SET
#define COMMAND_CONFIGr_IGNORE_TX_PAUSEf_GET BCM53324_A0_COMMAND_CONFIGr_IGNORE_TX_PAUSEf_GET
#define COMMAND_CONFIGr_IGNORE_TX_PAUSEf_SET BCM53324_A0_COMMAND_CONFIGr_IGNORE_TX_PAUSEf_SET
#define COMMAND_CONFIGr_SW_CTRL_RXTX_AFTER_LKUPf_GET BCM53324_A0_COMMAND_CONFIGr_SW_CTRL_RXTX_AFTER_LKUPf_GET
#define COMMAND_CONFIGr_SW_CTRL_RXTX_AFTER_LKUPf_SET BCM53324_A0_COMMAND_CONFIGr_SW_CTRL_RXTX_AFTER_LKUPf_SET
#define COMMAND_CONFIGr_RUNT_FILTER_DISf_GET BCM53324_A0_COMMAND_CONFIGr_RUNT_FILTER_DISf_GET
#define COMMAND_CONFIGr_RUNT_FILTER_DISf_SET BCM53324_A0_COMMAND_CONFIGr_RUNT_FILTER_DISf_SET
#define COMMAND_CONFIGr_LATE_COL_FIXf_GET BCM53324_A0_COMMAND_CONFIGr_LATE_COL_FIXf_GET
#define COMMAND_CONFIGr_LATE_COL_FIXf_SET BCM53324_A0_COMMAND_CONFIGr_LATE_COL_FIXf_SET
#define READ_COMMAND_CONFIGr BCM53324_A0_READ_COMMAND_CONFIGr
#define WRITE_COMMAND_CONFIGr BCM53324_A0_WRITE_COMMAND_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_COMMAND_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  COSLCCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     LCCOUNT          Cell Count for egress port packet of COS n: Number of cells per egress port of COS n.
 *
 ******************************************************************************/
#define BCM53324_A0_COSLCCOUNTr 0x00600044

#define BCM53324_A0_COSLCCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program COSLCCOUNT.
 *
 */
typedef union BCM53324_A0_COSLCCOUNTr_s {
	uint32_t v[1];
	uint32_t coslccount[1];
	uint32_t _coslccount;
} BCM53324_A0_COSLCCOUNTr_t;

#define BCM53324_A0_COSLCCOUNTr_CLR(r) (r).coslccount[0] = 0
#define BCM53324_A0_COSLCCOUNTr_SET(r,d) (r).coslccount[0] = d
#define BCM53324_A0_COSLCCOUNTr_GET(r) (r).coslccount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_COSLCCOUNTr_LCCOUNTf_GET(r) (((r).coslccount[0]) & 0xfff)
#define BCM53324_A0_COSLCCOUNTr_LCCOUNTf_SET(r,f) (r).coslccount[0]=(((r).coslccount[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access COSLCCOUNT.
 *
 */
#define BCM53324_A0_READ_COSLCCOUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_COSLCCOUNTr+(i),(r._coslccount))
#define BCM53324_A0_WRITE_COSLCCOUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_COSLCCOUNTr+(i),&(r._coslccount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COSLCCOUNTr BCM53324_A0_COSLCCOUNTr
#define COSLCCOUNTr_SIZE BCM53324_A0_COSLCCOUNTr_SIZE
typedef BCM53324_A0_COSLCCOUNTr_t COSLCCOUNTr_t;
#define COSLCCOUNTr_CLR BCM53324_A0_COSLCCOUNTr_CLR
#define COSLCCOUNTr_SET BCM53324_A0_COSLCCOUNTr_SET
#define COSLCCOUNTr_GET BCM53324_A0_COSLCCOUNTr_GET
#define COSLCCOUNTr_LCCOUNTf_GET BCM53324_A0_COSLCCOUNTr_LCCOUNTf_GET
#define COSLCCOUNTr_LCCOUNTf_SET BCM53324_A0_COSLCCOUNTr_LCCOUNTf_SET
#define READ_COSLCCOUNTr BCM53324_A0_READ_COSLCCOUNTr
#define WRITE_COSLCCOUNTr BCM53324_A0_WRITE_COSLCCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_COSLCCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  COSPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTCOUNT         Packet Count for egress port packet for COS n: This is current nuumber of entries in XQ of COS n for this egress port.Number of packets per egress port for COS n.
 *
 ******************************************************************************/
#define BCM53324_A0_COSPKTCOUNTr 0x0060002f

#define BCM53324_A0_COSPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program COSPKTCOUNT.
 *
 */
typedef union BCM53324_A0_COSPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t cospktcount[1];
	uint32_t _cospktcount;
} BCM53324_A0_COSPKTCOUNTr_t;

#define BCM53324_A0_COSPKTCOUNTr_CLR(r) (r).cospktcount[0] = 0
#define BCM53324_A0_COSPKTCOUNTr_SET(r,d) (r).cospktcount[0] = d
#define BCM53324_A0_COSPKTCOUNTr_GET(r) (r).cospktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_COSPKTCOUNTr_PKTCOUNTf_GET(r) (((r).cospktcount[0]) & 0x7ff)
#define BCM53324_A0_COSPKTCOUNTr_PKTCOUNTf_SET(r,f) (r).cospktcount[0]=(((r).cospktcount[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access COSPKTCOUNT.
 *
 */
#define BCM53324_A0_READ_COSPKTCOUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_COSPKTCOUNTr+(i),(r._cospktcount))
#define BCM53324_A0_WRITE_COSPKTCOUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_COSPKTCOUNTr+(i),&(r._cospktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COSPKTCOUNTr BCM53324_A0_COSPKTCOUNTr
#define COSPKTCOUNTr_SIZE BCM53324_A0_COSPKTCOUNTr_SIZE
typedef BCM53324_A0_COSPKTCOUNTr_t COSPKTCOUNTr_t;
#define COSPKTCOUNTr_CLR BCM53324_A0_COSPKTCOUNTr_CLR
#define COSPKTCOUNTr_SET BCM53324_A0_COSPKTCOUNTr_SET
#define COSPKTCOUNTr_GET BCM53324_A0_COSPKTCOUNTr_GET
#define COSPKTCOUNTr_PKTCOUNTf_GET BCM53324_A0_COSPKTCOUNTr_PKTCOUNTf_GET
#define COSPKTCOUNTr_PKTCOUNTf_SET BCM53324_A0_COSPKTCOUNTr_PKTCOUNTf_SET
#define READ_COSPKTCOUNTr BCM53324_A0_READ_COSPKTCOUNTr
#define WRITE_COSPKTCOUNTr BCM53324_A0_WRITE_COSPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_COSPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  COS_SEL
 * BLOCKS:   IPIPE
 * DESC:     COS Queue Mapping Register based on internal priority
 * SIZE:     32
 * FIELDS:
 *     COS0             COS-0 Value
 *     COS1             COS-1 Value
 *     COS2             COS-2 Value
 *     COS3             COS-3 Value
 *     COS4             COS-4 Value
 *     COS5             COS-5 Value
 *     COS6             COS-6 Value
 *     COS7             COS-7 Value
 *
 ******************************************************************************/
#define BCM53324_A0_COS_SELr 0x0f70010f

#define BCM53324_A0_COS_SELr_SIZE 4

/*
 * This structure should be used to declare and program COS_SEL.
 *
 */
typedef union BCM53324_A0_COS_SELr_s {
	uint32_t v[1];
	uint32_t cos_sel[1];
	uint32_t _cos_sel;
} BCM53324_A0_COS_SELr_t;

#define BCM53324_A0_COS_SELr_CLR(r) (r).cos_sel[0] = 0
#define BCM53324_A0_COS_SELr_SET(r,d) (r).cos_sel[0] = d
#define BCM53324_A0_COS_SELr_GET(r) (r).cos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_COS_SELr_COS0f_GET(r) (((r).cos_sel[0]) & 0x7)
#define BCM53324_A0_COS_SELr_COS0f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_COS_SELr_COS1f_GET(r) ((((r).cos_sel[0]) >> 3) & 0x7)
#define BCM53324_A0_COS_SELr_COS1f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53324_A0_COS_SELr_COS2f_GET(r) ((((r).cos_sel[0]) >> 6) & 0x7)
#define BCM53324_A0_COS_SELr_COS2f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53324_A0_COS_SELr_COS3f_GET(r) ((((r).cos_sel[0]) >> 9) & 0x7)
#define BCM53324_A0_COS_SELr_COS3f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53324_A0_COS_SELr_COS4f_GET(r) ((((r).cos_sel[0]) >> 12) & 0x7)
#define BCM53324_A0_COS_SELr_COS4f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53324_A0_COS_SELr_COS5f_GET(r) ((((r).cos_sel[0]) >> 15) & 0x7)
#define BCM53324_A0_COS_SELr_COS5f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53324_A0_COS_SELr_COS6f_GET(r) ((((r).cos_sel[0]) >> 18) & 0x7)
#define BCM53324_A0_COS_SELr_COS6f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53324_A0_COS_SELr_COS7f_GET(r) ((((r).cos_sel[0]) >> 21) & 0x7)
#define BCM53324_A0_COS_SELr_COS7f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access COS_SEL.
 *
 */
#define BCM53324_A0_READ_COS_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_COS_SELr,(r._cos_sel))
#define BCM53324_A0_WRITE_COS_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_COS_SELr,&(r._cos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COS_SELr BCM53324_A0_COS_SELr
#define COS_SELr_SIZE BCM53324_A0_COS_SELr_SIZE
typedef BCM53324_A0_COS_SELr_t COS_SELr_t;
#define COS_SELr_CLR BCM53324_A0_COS_SELr_CLR
#define COS_SELr_SET BCM53324_A0_COS_SELr_SET
#define COS_SELr_GET BCM53324_A0_COS_SELr_GET
#define COS_SELr_COS0f_GET BCM53324_A0_COS_SELr_COS0f_GET
#define COS_SELr_COS0f_SET BCM53324_A0_COS_SELr_COS0f_SET
#define COS_SELr_COS1f_GET BCM53324_A0_COS_SELr_COS1f_GET
#define COS_SELr_COS1f_SET BCM53324_A0_COS_SELr_COS1f_SET
#define COS_SELr_COS2f_GET BCM53324_A0_COS_SELr_COS2f_GET
#define COS_SELr_COS2f_SET BCM53324_A0_COS_SELr_COS2f_SET
#define COS_SELr_COS3f_GET BCM53324_A0_COS_SELr_COS3f_GET
#define COS_SELr_COS3f_SET BCM53324_A0_COS_SELr_COS3f_SET
#define COS_SELr_COS4f_GET BCM53324_A0_COS_SELr_COS4f_GET
#define COS_SELr_COS4f_SET BCM53324_A0_COS_SELr_COS4f_SET
#define COS_SELr_COS5f_GET BCM53324_A0_COS_SELr_COS5f_GET
#define COS_SELr_COS5f_SET BCM53324_A0_COS_SELr_COS5f_SET
#define COS_SELr_COS6f_GET BCM53324_A0_COS_SELr_COS6f_GET
#define COS_SELr_COS6f_SET BCM53324_A0_COS_SELr_COS6f_SET
#define COS_SELr_COS7f_GET BCM53324_A0_COS_SELr_COS7f_GET
#define COS_SELr_COS7f_SET BCM53324_A0_COS_SELr_COS7f_SET
#define READ_COS_SELr BCM53324_A0_READ_COS_SELr
#define WRITE_COS_SELr BCM53324_A0_WRITE_COS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_COS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CPU_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU
 * SIZE:     32
 * FIELDS:
 *     STATICMOVE_TOCPU Static move send to CPU enable
 *     NONSTATICMOVE_TOCPU Non-static move send to CPU enable
 *     UMC_TOCPU        Unknown multicast (L2MC miss) send to CPU enable
 *     UUCAST_TOCPU     Unknown unicast send to CPU enable
 *     V4L3ERR_TOCPU    IPv4 L3 error send to CPU enable
 *     IPMCERR_TOCPU    IPMC error send to CPU enable
 *     UVLAN_TOCPU      Unknown VLAN send to CPU enable
 *     UNRESOLVEDL3SRC_TOCPU Unresolved source for L3 send to CPU enable
 *     V6L3DSTMISS_TOCPU IPv6 L3 unicast destination miss send to CPU enable
 *     V4L3DSTMISS_TOCPU IPv4 L3 unicast destination miss send to CPU enable
 *     IPMCPORTMISS_TOCPU IPMC port mismatch send to CPU enable
 *     SRCROUTE_TOCPU   If SA[40] set, send to CPU enable
 *     V6L3ERR_TOCPU    IPv6 L3 error send to CPU enable
 *     MARTIAN_ADDR_TOCPU Martian address send to CPU enable
 *     TUNNEL_ERR_TOCPU Tunnel error send to CPU enable
 *     DOSATTACK_TOCPU  DOS attack send to CPU enable
 *     L3UC_TTL_ERR_TOCPU L3 unicast TTL error send to CPU enable
 *     IPMC_TTL_ERR_TOCPU L3 multicast TTL error send to CPU enable
 *     ICMP_REDIRECT_TOCPU ICMP redirect send to CPU enable
 *     L3_SLOWPATH_TOCPU L3 slow path to CPU enable
 *     PARITY_ERR_TOCPU Parity Error to CPU enable
 *     RESERVED0        RESERVED - 
 *     HG_HDR_ERROR_TOCPU HG Header Error Packet to CPU enable
 *     MC_INDEX_ERROR_TOCPU MC INDEX Error to CPU enable
 *     HG_HDR_TYPE1_TOCPU HiGig header type = 1 to CPU enable
 *     NIP_L3ERR_TOCPU  NON IP L3 error send to CPU enable
 *     MACLMT_STNMV_TOCPU Station Movement case alongwith Mac Limit Learn enable and counters exceeded
 *     IPMC_TTL1_ERR_TOCPU L3 multicast packets that have a TTL = 1 are sent to CPU enable
 *     L3UC_TTL1_ERR_TOCPU L3 unicast packets that have a TTL = 1 are sent to CPU enable
 *     L3_MTU_FAIL_TOCPU L3 MTU fail to CPU enable
 *
 ******************************************************************************/
#define BCM53324_A0_CPU_CONTROL_1r 0x0c780004

#define BCM53324_A0_CPU_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_1.
 *
 */
typedef union BCM53324_A0_CPU_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cpu_control_1[1];
	uint32_t _cpu_control_1;
} BCM53324_A0_CPU_CONTROL_1r_t;

#define BCM53324_A0_CPU_CONTROL_1r_CLR(r) (r).cpu_control_1[0] = 0
#define BCM53324_A0_CPU_CONTROL_1r_SET(r,d) (r).cpu_control_1[0] = d
#define BCM53324_A0_CPU_CONTROL_1r_GET(r) (r).cpu_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET(r) (((r).cpu_control_1[0]) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 1) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_CPU_CONTROL_1r_UMC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 2) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_UMC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 3) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 4) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 5) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 6) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 7) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 8) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 9) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 10) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 11) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 12) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 13) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 14) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 15) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 16) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 17) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 18) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 19) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 20) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_CPU_CONTROL_1r_RESERVED0f_GET(r) ((((r).cpu_control_1[0]) >> 21) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_RESERVED0f_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 22) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 23) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 24) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 25) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 26) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_CPU_CONTROL_1r_IPMC_TTL1_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 27) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_IPMC_TTL1_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_CPU_CONTROL_1r_L3UC_TTL1_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 28) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_L3UC_TTL1_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53324_A0_CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 29) & 0x1)
#define BCM53324_A0_CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access CPU_CONTROL_1.
 *
 */
#define BCM53324_A0_READ_CPU_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CPU_CONTROL_1r,(r._cpu_control_1))
#define BCM53324_A0_WRITE_CPU_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CPU_CONTROL_1r,&(r._cpu_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_1r BCM53324_A0_CPU_CONTROL_1r
#define CPU_CONTROL_1r_SIZE BCM53324_A0_CPU_CONTROL_1r_SIZE
typedef BCM53324_A0_CPU_CONTROL_1r_t CPU_CONTROL_1r_t;
#define CPU_CONTROL_1r_CLR BCM53324_A0_CPU_CONTROL_1r_CLR
#define CPU_CONTROL_1r_SET BCM53324_A0_CPU_CONTROL_1r_SET
#define CPU_CONTROL_1r_GET BCM53324_A0_CPU_CONTROL_1r_GET
#define CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET
#define CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET
#define CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET
#define CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET
#define CPU_CONTROL_1r_UMC_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_UMC_TOCPUf_GET
#define CPU_CONTROL_1r_UMC_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_UMC_TOCPUf_SET
#define CPU_CONTROL_1r_UUCAST_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_GET
#define CPU_CONTROL_1r_UUCAST_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_SET
#define CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMCERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMCERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_SET
#define CPU_CONTROL_1r_UVLAN_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_GET
#define CPU_CONTROL_1r_UVLAN_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_SET
#define CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET
#define CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET
#define CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET
#define CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET
#define CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET
#define CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET
#define CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET
#define CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET
#define CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET
#define CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET
#define CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET
#define CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET
#define CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_RESERVED0f_GET BCM53324_A0_CPU_CONTROL_1r_RESERVED0f_GET
#define CPU_CONTROL_1r_RESERVED0f_SET BCM53324_A0_CPU_CONTROL_1r_RESERVED0f_SET
#define CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET
#define CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET
#define CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET
#define CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET
#define CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET
#define CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET
#define CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_GET
#define CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_MACLMT_STNMV_TOCPUf_SET
#define CPU_CONTROL_1r_IPMC_TTL1_ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_IPMC_TTL1_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMC_TTL1_ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_IPMC_TTL1_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_L3UC_TTL1_ERR_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_L3UC_TTL1_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_L3UC_TTL1_ERR_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_L3UC_TTL1_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_GET BCM53324_A0_CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_GET
#define CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_SET BCM53324_A0_CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_SET
#define READ_CPU_CONTROL_1r BCM53324_A0_READ_CPU_CONTROL_1r
#define WRITE_CPU_CONTROL_1r BCM53324_A0_WRITE_CPU_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CPU_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CPU_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU. All Priorities are internal priorities.
 * SIZE:     32
 * FIELDS:
 *     CPU_MH_CONTROL_PRIORITY CPU OPCODE CONTROL Priority
 *     CPU_LKUPFAIL_PRIORITY CPU Lookup Fail Priority
 *     CPU_SFLOW_PRIORITY CPU SFLOW Priority
 *     CPU_DEFAULT_PRIORITY CPU Default Priority
 *     CPU_MTUFAIL_PRIORITY CPU MTU fail Priority
 *     CPU_FPCOPY_PRIORITY CPU FP copy to cpu Priority
 *     CPU_ICMP_REDIRECT_PRIORITY CPU ICMP Redirect Priority
 *     CPU_MIRROR_PRIORITY CPU Mirror Priority
 *
 ******************************************************************************/
#define BCM53324_A0_CPU_CONTROL_2r 0x0f780125

#define BCM53324_A0_CPU_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_2.
 *
 */
typedef union BCM53324_A0_CPU_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cpu_control_2[1];
	uint32_t _cpu_control_2;
} BCM53324_A0_CPU_CONTROL_2r_t;

#define BCM53324_A0_CPU_CONTROL_2r_CLR(r) (r).cpu_control_2[0] = 0
#define BCM53324_A0_CPU_CONTROL_2r_SET(r,d) (r).cpu_control_2[0] = d
#define BCM53324_A0_CPU_CONTROL_2r_GET(r) (r).cpu_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET(r) (((r).cpu_control_2[0]) & 0xf)
#define BCM53324_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 4) & 0xf)
#define BCM53324_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 8) & 0xf)
#define BCM53324_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 12) & 0xf)
#define BCM53324_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 16) & 0xf)
#define BCM53324_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 20) & 0xf)
#define BCM53324_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 24) & 0xf)
#define BCM53324_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 28) & 0xf)
#define BCM53324_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_CONTROL_2.
 *
 */
#define BCM53324_A0_READ_CPU_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CPU_CONTROL_2r,(r._cpu_control_2))
#define BCM53324_A0_WRITE_CPU_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CPU_CONTROL_2r,&(r._cpu_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_2r BCM53324_A0_CPU_CONTROL_2r
#define CPU_CONTROL_2r_SIZE BCM53324_A0_CPU_CONTROL_2r_SIZE
typedef BCM53324_A0_CPU_CONTROL_2r_t CPU_CONTROL_2r_t;
#define CPU_CONTROL_2r_CLR BCM53324_A0_CPU_CONTROL_2r_CLR
#define CPU_CONTROL_2r_SET BCM53324_A0_CPU_CONTROL_2r_SET
#define CPU_CONTROL_2r_GET BCM53324_A0_CPU_CONTROL_2r_GET
#define CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET
#define READ_CPU_CONTROL_2r BCM53324_A0_READ_CPU_CONTROL_2r
#define WRITE_CPU_CONTROL_2r BCM53324_A0_WRITE_CPU_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CPU_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CPU_CONTROL_3
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU. All priorities are internal priorities
 * SIZE:     32
 * FIELDS:
 *     CPU_PROTO_EXCEPTIONS_PRIORITY Priority for IPv4/IPv6 pkts with TTL=1 when it is copied/trapped to CPU.
 *     CPU_PROTO_IP_OPTIONS_PRIORITY Priority for IPv4/IPv6 pkts with options or IPv6 pkts with payload len zero (jumbo option) when it is copied/trapped to CPU.
 *     CPU_PROTO_IPMC_RESERVED_PRIORITY Priority for IPv4/IPv6 reserved multicast pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_DHCP_PRIORITY Priority for DHCP pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_IGMP_PRIORITY Priority for IGMP/MLD pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_ARP_PRIORITY Priority for ARP/ND pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_BPDU_PRIORITY Priority for BPDU pkts when it is copied/trapped to CPU.
 *     CPU_MAC_LIMIT_PRIORITY CPU priority for mac limit exceeded pkts that are copied to CPU
 *
 ******************************************************************************/
#define BCM53324_A0_CPU_CONTROL_3r 0x0f780132

#define BCM53324_A0_CPU_CONTROL_3r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_3.
 *
 */
typedef union BCM53324_A0_CPU_CONTROL_3r_s {
	uint32_t v[1];
	uint32_t cpu_control_3[1];
	uint32_t _cpu_control_3;
} BCM53324_A0_CPU_CONTROL_3r_t;

#define BCM53324_A0_CPU_CONTROL_3r_CLR(r) (r).cpu_control_3[0] = 0
#define BCM53324_A0_CPU_CONTROL_3r_SET(r,d) (r).cpu_control_3[0] = d
#define BCM53324_A0_CPU_CONTROL_3r_GET(r) (r).cpu_control_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET(r) (((r).cpu_control_3[0]) & 0xf)
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 4) & 0xf)
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 8) & 0xf)
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 12) & 0xf)
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 16) & 0xf)
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 20) & 0xf)
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 24) & 0xf)
#define BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 28) & 0xf)
#define BCM53324_A0_CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_CONTROL_3.
 *
 */
#define BCM53324_A0_READ_CPU_CONTROL_3r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CPU_CONTROL_3r,(r._cpu_control_3))
#define BCM53324_A0_WRITE_CPU_CONTROL_3r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CPU_CONTROL_3r,&(r._cpu_control_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_3r BCM53324_A0_CPU_CONTROL_3r
#define CPU_CONTROL_3r_SIZE BCM53324_A0_CPU_CONTROL_3r_SIZE
typedef BCM53324_A0_CPU_CONTROL_3r_t CPU_CONTROL_3r_t;
#define CPU_CONTROL_3r_CLR BCM53324_A0_CPU_CONTROL_3r_CLR
#define CPU_CONTROL_3r_SET BCM53324_A0_CPU_CONTROL_3r_SET
#define CPU_CONTROL_3r_GET BCM53324_A0_CPU_CONTROL_3r_GET
#define CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_3r_CPU_MAC_LIMIT_PRIORITYf_SET
#define READ_CPU_CONTROL_3r BCM53324_A0_READ_CPU_CONTROL_3r
#define WRITE_CPU_CONTROL_3r BCM53324_A0_WRITE_CPU_CONTROL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CPU_CONTROL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CPU_CONTROL_4
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU. All priorities are internal priorities
 * SIZE:     32
 * FIELDS:
 *     CPU_PROTO_TS_PRIORITY CPU priority for TS packets
 *     CPU_PROTO_SRP_PRIORITY CPU priority for SRP packets
 *     CPU_PROTO_MMRP_PRIORITY CPU priority for MMRP packets
 *
 ******************************************************************************/
#define BCM53324_A0_CPU_CONTROL_4r 0x0f780139

#define BCM53324_A0_CPU_CONTROL_4r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_4.
 *
 */
typedef union BCM53324_A0_CPU_CONTROL_4r_s {
	uint32_t v[1];
	uint32_t cpu_control_4[1];
	uint32_t _cpu_control_4;
} BCM53324_A0_CPU_CONTROL_4r_t;

#define BCM53324_A0_CPU_CONTROL_4r_CLR(r) (r).cpu_control_4[0] = 0
#define BCM53324_A0_CPU_CONTROL_4r_SET(r,d) (r).cpu_control_4[0] = d
#define BCM53324_A0_CPU_CONTROL_4r_GET(r) (r).cpu_control_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_TS_PRIORITYf_GET(r) (((r).cpu_control_4[0]) & 0xf)
#define BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_TS_PRIORITYf_SET(r,f) (r).cpu_control_4[0]=(((r).cpu_control_4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_SRP_PRIORITYf_GET(r) ((((r).cpu_control_4[0]) >> 4) & 0xf)
#define BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_SRP_PRIORITYf_SET(r,f) (r).cpu_control_4[0]=(((r).cpu_control_4[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_MMRP_PRIORITYf_GET(r) ((((r).cpu_control_4[0]) >> 8) & 0xf)
#define BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_MMRP_PRIORITYf_SET(r,f) (r).cpu_control_4[0]=(((r).cpu_control_4[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))

/*
 * These macros can be used to access CPU_CONTROL_4.
 *
 */
#define BCM53324_A0_READ_CPU_CONTROL_4r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CPU_CONTROL_4r,(r._cpu_control_4))
#define BCM53324_A0_WRITE_CPU_CONTROL_4r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CPU_CONTROL_4r,&(r._cpu_control_4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_4r BCM53324_A0_CPU_CONTROL_4r
#define CPU_CONTROL_4r_SIZE BCM53324_A0_CPU_CONTROL_4r_SIZE
typedef BCM53324_A0_CPU_CONTROL_4r_t CPU_CONTROL_4r_t;
#define CPU_CONTROL_4r_CLR BCM53324_A0_CPU_CONTROL_4r_CLR
#define CPU_CONTROL_4r_SET BCM53324_A0_CPU_CONTROL_4r_SET
#define CPU_CONTROL_4r_GET BCM53324_A0_CPU_CONTROL_4r_GET
#define CPU_CONTROL_4r_CPU_PROTO_TS_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_TS_PRIORITYf_GET
#define CPU_CONTROL_4r_CPU_PROTO_TS_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_TS_PRIORITYf_SET
#define CPU_CONTROL_4r_CPU_PROTO_SRP_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_SRP_PRIORITYf_GET
#define CPU_CONTROL_4r_CPU_PROTO_SRP_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_SRP_PRIORITYf_SET
#define CPU_CONTROL_4r_CPU_PROTO_MMRP_PRIORITYf_GET BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_MMRP_PRIORITYf_GET
#define CPU_CONTROL_4r_CPU_PROTO_MMRP_PRIORITYf_SET BCM53324_A0_CPU_CONTROL_4r_CPU_PROTO_MMRP_PRIORITYf_SET
#define READ_CPU_CONTROL_4r BCM53324_A0_READ_CPU_CONTROL_4r
#define WRITE_CPU_CONTROL_4r BCM53324_A0_WRITE_CPU_CONTROL_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CPU_CONTROL_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CPU_COS_SEL
 * BLOCKS:   IPIPE
 * DESC:     CPU COS Select Register based on internal priority
 * SIZE:     32
 * FIELDS:
 *     COS0             COS 0 value
 *     COS1             COS 1 value
 *     COS2             COS 2 value
 *     COS3             COS 3 value
 *     COS4             COS 4 value
 *     COS5             COS 5 value
 *     COS6             COS 6 value
 *     COS7             COS 7 value
 *
 ******************************************************************************/
#define BCM53324_A0_CPU_COS_SELr 0x0f78012a

#define BCM53324_A0_CPU_COS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CPU_COS_SEL.
 *
 */
typedef union BCM53324_A0_CPU_COS_SELr_s {
	uint32_t v[1];
	uint32_t cpu_cos_sel[1];
	uint32_t _cpu_cos_sel;
} BCM53324_A0_CPU_COS_SELr_t;

#define BCM53324_A0_CPU_COS_SELr_CLR(r) (r).cpu_cos_sel[0] = 0
#define BCM53324_A0_CPU_COS_SELr_SET(r,d) (r).cpu_cos_sel[0] = d
#define BCM53324_A0_CPU_COS_SELr_GET(r) (r).cpu_cos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CPU_COS_SELr_COS0f_GET(r) (((r).cpu_cos_sel[0]) & 0x7)
#define BCM53324_A0_CPU_COS_SELr_COS0f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_CPU_COS_SELr_COS1f_GET(r) ((((r).cpu_cos_sel[0]) >> 3) & 0x7)
#define BCM53324_A0_CPU_COS_SELr_COS1f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53324_A0_CPU_COS_SELr_COS2f_GET(r) ((((r).cpu_cos_sel[0]) >> 6) & 0x7)
#define BCM53324_A0_CPU_COS_SELr_COS2f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53324_A0_CPU_COS_SELr_COS3f_GET(r) ((((r).cpu_cos_sel[0]) >> 9) & 0x7)
#define BCM53324_A0_CPU_COS_SELr_COS3f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53324_A0_CPU_COS_SELr_COS4f_GET(r) ((((r).cpu_cos_sel[0]) >> 12) & 0x7)
#define BCM53324_A0_CPU_COS_SELr_COS4f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53324_A0_CPU_COS_SELr_COS5f_GET(r) ((((r).cpu_cos_sel[0]) >> 15) & 0x7)
#define BCM53324_A0_CPU_COS_SELr_COS5f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53324_A0_CPU_COS_SELr_COS6f_GET(r) ((((r).cpu_cos_sel[0]) >> 18) & 0x7)
#define BCM53324_A0_CPU_COS_SELr_COS6f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53324_A0_CPU_COS_SELr_COS7f_GET(r) ((((r).cpu_cos_sel[0]) >> 21) & 0x7)
#define BCM53324_A0_CPU_COS_SELr_COS7f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access CPU_COS_SEL.
 *
 */
#define BCM53324_A0_READ_CPU_COS_SELr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CPU_COS_SELr,(r._cpu_cos_sel))
#define BCM53324_A0_WRITE_CPU_COS_SELr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CPU_COS_SELr,&(r._cpu_cos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_COS_SELr BCM53324_A0_CPU_COS_SELr
#define CPU_COS_SELr_SIZE BCM53324_A0_CPU_COS_SELr_SIZE
typedef BCM53324_A0_CPU_COS_SELr_t CPU_COS_SELr_t;
#define CPU_COS_SELr_CLR BCM53324_A0_CPU_COS_SELr_CLR
#define CPU_COS_SELr_SET BCM53324_A0_CPU_COS_SELr_SET
#define CPU_COS_SELr_GET BCM53324_A0_CPU_COS_SELr_GET
#define CPU_COS_SELr_COS0f_GET BCM53324_A0_CPU_COS_SELr_COS0f_GET
#define CPU_COS_SELr_COS0f_SET BCM53324_A0_CPU_COS_SELr_COS0f_SET
#define CPU_COS_SELr_COS1f_GET BCM53324_A0_CPU_COS_SELr_COS1f_GET
#define CPU_COS_SELr_COS1f_SET BCM53324_A0_CPU_COS_SELr_COS1f_SET
#define CPU_COS_SELr_COS2f_GET BCM53324_A0_CPU_COS_SELr_COS2f_GET
#define CPU_COS_SELr_COS2f_SET BCM53324_A0_CPU_COS_SELr_COS2f_SET
#define CPU_COS_SELr_COS3f_GET BCM53324_A0_CPU_COS_SELr_COS3f_GET
#define CPU_COS_SELr_COS3f_SET BCM53324_A0_CPU_COS_SELr_COS3f_SET
#define CPU_COS_SELr_COS4f_GET BCM53324_A0_CPU_COS_SELr_COS4f_GET
#define CPU_COS_SELr_COS4f_SET BCM53324_A0_CPU_COS_SELr_COS4f_SET
#define CPU_COS_SELr_COS5f_GET BCM53324_A0_CPU_COS_SELr_COS5f_GET
#define CPU_COS_SELr_COS5f_SET BCM53324_A0_CPU_COS_SELr_COS5f_SET
#define CPU_COS_SELr_COS6f_GET BCM53324_A0_CPU_COS_SELr_COS6f_GET
#define CPU_COS_SELr_COS6f_SET BCM53324_A0_CPU_COS_SELr_COS6f_SET
#define CPU_COS_SELr_COS7f_GET BCM53324_A0_CPU_COS_SELr_COS7f_GET
#define CPU_COS_SELr_COS7f_SET BCM53324_A0_CPU_COS_SELr_COS7f_SET
#define READ_CPU_COS_SELr BCM53324_A0_READ_CPU_COS_SELr
#define WRITE_CPU_COS_SELr BCM53324_A0_WRITE_CPU_COS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CPU_COS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  CPU_PRIORITY_SEL
 * BLOCKS:   IPIPE
 * DESC:     CPU Internal Priority Select Register
 * SIZE:     32
 * FIELDS:
 *     PRI0             Priority 0 value
 *     PRI1             Priority 1 value
 *     PRI2             Priority 2 value
 *     PRI3             Priority 3 value
 *     PRI4             Priority 4 value
 *     PRI5             Priority 5 value
 *     PRI6             Priority 6 value
 *     PRI7             Priority 7 value
 *
 ******************************************************************************/
#define BCM53324_A0_CPU_PRIORITY_SELr 0x0f780129

#define BCM53324_A0_CPU_PRIORITY_SELr_SIZE 4

/*
 * This structure should be used to declare and program CPU_PRIORITY_SEL.
 *
 */
typedef union BCM53324_A0_CPU_PRIORITY_SELr_s {
	uint32_t v[1];
	uint32_t cpu_priority_sel[1];
	uint32_t _cpu_priority_sel;
} BCM53324_A0_CPU_PRIORITY_SELr_t;

#define BCM53324_A0_CPU_PRIORITY_SELr_CLR(r) (r).cpu_priority_sel[0] = 0
#define BCM53324_A0_CPU_PRIORITY_SELr_SET(r,d) (r).cpu_priority_sel[0] = d
#define BCM53324_A0_CPU_PRIORITY_SELr_GET(r) (r).cpu_priority_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI0f_GET(r) (((r).cpu_priority_sel[0]) & 0xf)
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI0f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI1f_GET(r) ((((r).cpu_priority_sel[0]) >> 4) & 0xf)
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI1f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI2f_GET(r) ((((r).cpu_priority_sel[0]) >> 8) & 0xf)
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI2f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI3f_GET(r) ((((r).cpu_priority_sel[0]) >> 12) & 0xf)
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI3f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI4f_GET(r) ((((r).cpu_priority_sel[0]) >> 16) & 0xf)
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI4f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI5f_GET(r) ((((r).cpu_priority_sel[0]) >> 20) & 0xf)
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI5f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI6f_GET(r) ((((r).cpu_priority_sel[0]) >> 24) & 0xf)
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI6f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI7f_GET(r) ((((r).cpu_priority_sel[0]) >> 28) & 0xf)
#define BCM53324_A0_CPU_PRIORITY_SELr_PRI7f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_PRIORITY_SEL.
 *
 */
#define BCM53324_A0_READ_CPU_PRIORITY_SELr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_CPU_PRIORITY_SELr,(r._cpu_priority_sel))
#define BCM53324_A0_WRITE_CPU_PRIORITY_SELr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_CPU_PRIORITY_SELr,&(r._cpu_priority_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_PRIORITY_SELr BCM53324_A0_CPU_PRIORITY_SELr
#define CPU_PRIORITY_SELr_SIZE BCM53324_A0_CPU_PRIORITY_SELr_SIZE
typedef BCM53324_A0_CPU_PRIORITY_SELr_t CPU_PRIORITY_SELr_t;
#define CPU_PRIORITY_SELr_CLR BCM53324_A0_CPU_PRIORITY_SELr_CLR
#define CPU_PRIORITY_SELr_SET BCM53324_A0_CPU_PRIORITY_SELr_SET
#define CPU_PRIORITY_SELr_GET BCM53324_A0_CPU_PRIORITY_SELr_GET
#define CPU_PRIORITY_SELr_PRI0f_GET BCM53324_A0_CPU_PRIORITY_SELr_PRI0f_GET
#define CPU_PRIORITY_SELr_PRI0f_SET BCM53324_A0_CPU_PRIORITY_SELr_PRI0f_SET
#define CPU_PRIORITY_SELr_PRI1f_GET BCM53324_A0_CPU_PRIORITY_SELr_PRI1f_GET
#define CPU_PRIORITY_SELr_PRI1f_SET BCM53324_A0_CPU_PRIORITY_SELr_PRI1f_SET
#define CPU_PRIORITY_SELr_PRI2f_GET BCM53324_A0_CPU_PRIORITY_SELr_PRI2f_GET
#define CPU_PRIORITY_SELr_PRI2f_SET BCM53324_A0_CPU_PRIORITY_SELr_PRI2f_SET
#define CPU_PRIORITY_SELr_PRI3f_GET BCM53324_A0_CPU_PRIORITY_SELr_PRI3f_GET
#define CPU_PRIORITY_SELr_PRI3f_SET BCM53324_A0_CPU_PRIORITY_SELr_PRI3f_SET
#define CPU_PRIORITY_SELr_PRI4f_GET BCM53324_A0_CPU_PRIORITY_SELr_PRI4f_GET
#define CPU_PRIORITY_SELr_PRI4f_SET BCM53324_A0_CPU_PRIORITY_SELr_PRI4f_SET
#define CPU_PRIORITY_SELr_PRI5f_GET BCM53324_A0_CPU_PRIORITY_SELr_PRI5f_GET
#define CPU_PRIORITY_SELr_PRI5f_SET BCM53324_A0_CPU_PRIORITY_SELr_PRI5f_SET
#define CPU_PRIORITY_SELr_PRI6f_GET BCM53324_A0_CPU_PRIORITY_SELr_PRI6f_GET
#define CPU_PRIORITY_SELr_PRI6f_SET BCM53324_A0_CPU_PRIORITY_SELr_PRI6f_SET
#define CPU_PRIORITY_SELr_PRI7f_GET BCM53324_A0_CPU_PRIORITY_SELr_PRI7f_GET
#define CPU_PRIORITY_SELr_PRI7f_SET BCM53324_A0_CPU_PRIORITY_SELr_PRI7f_SET
#define READ_CPU_PRIORITY_SELr BCM53324_A0_READ_CPU_PRIORITY_SELr
#define WRITE_CPU_PRIORITY_SELr BCM53324_A0_WRITE_CPU_PRIORITY_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_CPU_PRIORITY_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DLFBC_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet DLF Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           DLF rate control enable
 *
 ******************************************************************************/
#define BCM53324_A0_DLFBC_STORM_CONTROLr 0x0c700003

#define BCM53324_A0_DLFBC_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DLFBC_STORM_CONTROL.
 *
 */
typedef union BCM53324_A0_DLFBC_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t dlfbc_storm_control[1];
	uint32_t _dlfbc_storm_control;
} BCM53324_A0_DLFBC_STORM_CONTROLr_t;

#define BCM53324_A0_DLFBC_STORM_CONTROLr_CLR(r) (r).dlfbc_storm_control[0] = 0
#define BCM53324_A0_DLFBC_STORM_CONTROLr_SET(r,d) (r).dlfbc_storm_control[0] = d
#define BCM53324_A0_DLFBC_STORM_CONTROLr_GET(r) (r).dlfbc_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).dlfbc_storm_control[0]) & 0x1ffffff)
#define BCM53324_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).dlfbc_storm_control[0]=(((r).dlfbc_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_DLFBC_STORM_CONTROLr_ENABLEf_GET(r) ((((r).dlfbc_storm_control[0]) >> 25) & 0x1)
#define BCM53324_A0_DLFBC_STORM_CONTROLr_ENABLEf_SET(r,f) (r).dlfbc_storm_control[0]=(((r).dlfbc_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access DLFBC_STORM_CONTROL.
 *
 */
#define BCM53324_A0_READ_DLFBC_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_DLFBC_STORM_CONTROLr,(r._dlfbc_storm_control))
#define BCM53324_A0_WRITE_DLFBC_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_DLFBC_STORM_CONTROLr,&(r._dlfbc_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DLFBC_STORM_CONTROLr BCM53324_A0_DLFBC_STORM_CONTROLr
#define DLFBC_STORM_CONTROLr_SIZE BCM53324_A0_DLFBC_STORM_CONTROLr_SIZE
typedef BCM53324_A0_DLFBC_STORM_CONTROLr_t DLFBC_STORM_CONTROLr_t;
#define DLFBC_STORM_CONTROLr_CLR BCM53324_A0_DLFBC_STORM_CONTROLr_CLR
#define DLFBC_STORM_CONTROLr_SET BCM53324_A0_DLFBC_STORM_CONTROLr_SET
#define DLFBC_STORM_CONTROLr_GET BCM53324_A0_DLFBC_STORM_CONTROLr_GET
#define DLFBC_STORM_CONTROLr_THRESHOLDf_GET BCM53324_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_GET
#define DLFBC_STORM_CONTROLr_THRESHOLDf_SET BCM53324_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_SET
#define DLFBC_STORM_CONTROLr_ENABLEf_GET BCM53324_A0_DLFBC_STORM_CONTROLr_ENABLEf_GET
#define DLFBC_STORM_CONTROLr_ENABLEf_SET BCM53324_A0_DLFBC_STORM_CONTROLr_ENABLEf_SET
#define READ_DLFBC_STORM_CONTROLr BCM53324_A0_READ_DLFBC_STORM_CONTROLr
#define WRITE_DLFBC_STORM_CONTROLr BCM53324_A0_WRITE_DLFBC_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DLFBC_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DOS_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED0        RESERVED Enable ICMP DOS attack checks
 *     RESERVED1        RESERVED Enable checking TCP DOS fragment attack
 *     RESERVED2        RESERVED Enable checking TCP/UDP DOS attack for dropping packet if TCP/UDP source port == destination port
 *     MACSA_EQUALS_MACDA_DROP Drop MACSA == MACDA
 *     IPV4_FIRST_FRAG_CHECK_ENABLE Enable checking DOS attacks on IP first fragments
 *     DROP_IF_SIP_EQUALS_DIP Drop IPv4/IPv6 packets if the SIP == DIP
 *     TCP_FLAGS_SYN_FRAG_ENABLE TCP SYN Packet with Source Port 0-1023 for non-first fragments tcp/udp port values are always zero and will match this condition and WILL BE DROPPED
 *     TCP_FLAGS_CTRL0_SEQ0_ENABLE TCP Packets with control flags == 0 && sequence number == 0 will be dropped
 *     TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLE TCP Packets with FIN,URG & PSH bits set & seq. number == 0
 *     TCP_FLAGS_SYN_FIN_ENABLE TCP Packets with SYN & FIN bits set
 *     TCP_SPORT_EQ_DPORT_ENABLE BLAT - TCP Packets with SPORT = DPORT
 *     UDP_SPORT_EQ_DPORT_ENABLE BLAT - UDP Packets with SPORT = DPORT
 *     TCP_HDR_PARTIAL_ENABLE FIRST TCP fragments that don't have the full TCP header. defined as the smaller than DOS_CONTROL.MIN_TCPHDR_SIZE programmed
 *     TCP_HDR_OFFSET_EQ1_ENABLE TCP fragments with offset value of 1 fragment offset values are programmed in 8byte increments. The value of 1 means 8bytes
 *     ICMP_V6_PING_SIZE_ENABLE ICMPV6 ping packets with payload size greater than the programmable value in DOS_CONTROL.BIG_ICMP_PKT_SIZE.
 *     ICMP_V4_PING_SIZE_ENABLE ICMPV6 ping packets with payload size greater than the programmable value in DOS_CONTROL.BIG_ICMP_PKT_SIZE
 *     ICMP_FRAG_PKTS_ENABLE Fragmented ICMP packets
 *     MIN_TCPHDR_SIZE  Minimum TCP header length allowed (minimum 0 bytes, maximum 255 bytes)
 *
 ******************************************************************************/
#define BCM53324_A0_DOS_CONTROLr 0x01780001

#define BCM53324_A0_DOS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL.
 *
 */
typedef union BCM53324_A0_DOS_CONTROLr_s {
	uint32_t v[1];
	uint32_t dos_control[1];
	uint32_t _dos_control;
} BCM53324_A0_DOS_CONTROLr_t;

#define BCM53324_A0_DOS_CONTROLr_CLR(r) (r).dos_control[0] = 0
#define BCM53324_A0_DOS_CONTROLr_SET(r,d) (r).dos_control[0] = d
#define BCM53324_A0_DOS_CONTROLr_GET(r) (r).dos_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DOS_CONTROLr_RESERVED0f_GET(r) (((r).dos_control[0]) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_RESERVED0f_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_DOS_CONTROLr_RESERVED1f_GET(r) ((((r).dos_control[0]) >> 1) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_RESERVED1f_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_DOS_CONTROLr_RESERVED2f_GET(r) ((((r).dos_control[0]) >> 2) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_RESERVED2f_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_GET(r) ((((r).dos_control[0]) >> 3) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 4) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET(r) ((((r).dos_control[0]) >> 5) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_GET(r) ((((r).dos_control[0]) >> 6) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_GET(r) ((((r).dos_control[0]) >> 7) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_GET(r) ((((r).dos_control[0]) >> 8) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FIN_ENABLEf_GET(r) ((((r).dos_control[0]) >> 9) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FIN_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_DOS_CONTROLr_TCP_SPORT_EQ_DPORT_ENABLEf_GET(r) ((((r).dos_control[0]) >> 10) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_TCP_SPORT_EQ_DPORT_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_DOS_CONTROLr_UDP_SPORT_EQ_DPORT_ENABLEf_GET(r) ((((r).dos_control[0]) >> 11) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_UDP_SPORT_EQ_DPORT_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_DOS_CONTROLr_TCP_HDR_PARTIAL_ENABLEf_GET(r) ((((r).dos_control[0]) >> 12) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_TCP_HDR_PARTIAL_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_DOS_CONTROLr_TCP_HDR_OFFSET_EQ1_ENABLEf_GET(r) ((((r).dos_control[0]) >> 13) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_TCP_HDR_OFFSET_EQ1_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_DOS_CONTROLr_ICMP_V6_PING_SIZE_ENABLEf_GET(r) ((((r).dos_control[0]) >> 14) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_ICMP_V6_PING_SIZE_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_DOS_CONTROLr_ICMP_V4_PING_SIZE_ENABLEf_GET(r) ((((r).dos_control[0]) >> 15) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_ICMP_V4_PING_SIZE_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_DOS_CONTROLr_ICMP_FRAG_PKTS_ENABLEf_GET(r) ((((r).dos_control[0]) >> 16) & 0x1)
#define BCM53324_A0_DOS_CONTROLr_ICMP_FRAG_PKTS_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET(r) ((((r).dos_control[0]) >> 17) & 0xff)
#define BCM53324_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0xff << 17)) | ((((uint32_t)f) & 0xff) << 17))

/*
 * These macros can be used to access DOS_CONTROL.
 *
 */
#define BCM53324_A0_READ_DOS_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_DOS_CONTROLr,(r._dos_control))
#define BCM53324_A0_WRITE_DOS_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_DOS_CONTROLr,&(r._dos_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CONTROLr BCM53324_A0_DOS_CONTROLr
#define DOS_CONTROLr_SIZE BCM53324_A0_DOS_CONTROLr_SIZE
typedef BCM53324_A0_DOS_CONTROLr_t DOS_CONTROLr_t;
#define DOS_CONTROLr_CLR BCM53324_A0_DOS_CONTROLr_CLR
#define DOS_CONTROLr_SET BCM53324_A0_DOS_CONTROLr_SET
#define DOS_CONTROLr_GET BCM53324_A0_DOS_CONTROLr_GET
#define DOS_CONTROLr_RESERVED0f_GET BCM53324_A0_DOS_CONTROLr_RESERVED0f_GET
#define DOS_CONTROLr_RESERVED0f_SET BCM53324_A0_DOS_CONTROLr_RESERVED0f_SET
#define DOS_CONTROLr_RESERVED1f_GET BCM53324_A0_DOS_CONTROLr_RESERVED1f_GET
#define DOS_CONTROLr_RESERVED1f_SET BCM53324_A0_DOS_CONTROLr_RESERVED1f_SET
#define DOS_CONTROLr_RESERVED2f_GET BCM53324_A0_DOS_CONTROLr_RESERVED2f_GET
#define DOS_CONTROLr_RESERVED2f_SET BCM53324_A0_DOS_CONTROLr_RESERVED2f_SET
#define DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_GET BCM53324_A0_DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_GET
#define DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_SET BCM53324_A0_DOS_CONTROLr_MACSA_EQUALS_MACDA_DROPf_SET
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET BCM53324_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET BCM53324_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET
#define DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_GET
#define DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FRAG_ENABLEf_SET
#define DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_GET
#define DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_CTRL0_SEQ0_ENABLEf_SET
#define DOS_CONTROLr_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_GET
#define DOS_CONTROLr_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_FIN_URG_PSH_SEQ0_ENABLEf_SET
#define DOS_CONTROLr_TCP_FLAGS_SYN_FIN_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FIN_ENABLEf_GET
#define DOS_CONTROLr_TCP_FLAGS_SYN_FIN_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_TCP_FLAGS_SYN_FIN_ENABLEf_SET
#define DOS_CONTROLr_TCP_SPORT_EQ_DPORT_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_TCP_SPORT_EQ_DPORT_ENABLEf_GET
#define DOS_CONTROLr_TCP_SPORT_EQ_DPORT_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_TCP_SPORT_EQ_DPORT_ENABLEf_SET
#define DOS_CONTROLr_UDP_SPORT_EQ_DPORT_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_UDP_SPORT_EQ_DPORT_ENABLEf_GET
#define DOS_CONTROLr_UDP_SPORT_EQ_DPORT_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_UDP_SPORT_EQ_DPORT_ENABLEf_SET
#define DOS_CONTROLr_TCP_HDR_PARTIAL_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_TCP_HDR_PARTIAL_ENABLEf_GET
#define DOS_CONTROLr_TCP_HDR_PARTIAL_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_TCP_HDR_PARTIAL_ENABLEf_SET
#define DOS_CONTROLr_TCP_HDR_OFFSET_EQ1_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_TCP_HDR_OFFSET_EQ1_ENABLEf_GET
#define DOS_CONTROLr_TCP_HDR_OFFSET_EQ1_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_TCP_HDR_OFFSET_EQ1_ENABLEf_SET
#define DOS_CONTROLr_ICMP_V6_PING_SIZE_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_ICMP_V6_PING_SIZE_ENABLEf_GET
#define DOS_CONTROLr_ICMP_V6_PING_SIZE_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_ICMP_V6_PING_SIZE_ENABLEf_SET
#define DOS_CONTROLr_ICMP_V4_PING_SIZE_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_ICMP_V4_PING_SIZE_ENABLEf_GET
#define DOS_CONTROLr_ICMP_V4_PING_SIZE_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_ICMP_V4_PING_SIZE_ENABLEf_SET
#define DOS_CONTROLr_ICMP_FRAG_PKTS_ENABLEf_GET BCM53324_A0_DOS_CONTROLr_ICMP_FRAG_PKTS_ENABLEf_GET
#define DOS_CONTROLr_ICMP_FRAG_PKTS_ENABLEf_SET BCM53324_A0_DOS_CONTROLr_ICMP_FRAG_PKTS_ENABLEf_SET
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET BCM53324_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET BCM53324_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET
#define READ_DOS_CONTROLr BCM53324_A0_READ_DOS_CONTROLr
#define WRITE_DOS_CONTROLr BCM53324_A0_WRITE_DOS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DOS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DOS_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register #2
 * SIZE:     32
 * FIELDS:
 *     BIG_ICMPV6_PKT_SIZE Maximum length ICMPv6 ping packet allowed before dropping (maximum 16k bytes)
 *     BIG_ICMP_PKT_SIZE Maximum length ICMP packet allowed before dropping (maximum 16k bytes)
 *
 ******************************************************************************/
#define BCM53324_A0_DOS_CONTROL_2r 0x01780002

#define BCM53324_A0_DOS_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL_2.
 *
 */
typedef union BCM53324_A0_DOS_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t dos_control_2[1];
	uint32_t _dos_control_2;
} BCM53324_A0_DOS_CONTROL_2r_t;

#define BCM53324_A0_DOS_CONTROL_2r_CLR(r) (r).dos_control_2[0] = 0
#define BCM53324_A0_DOS_CONTROL_2r_SET(r,d) (r).dos_control_2[0] = d
#define BCM53324_A0_DOS_CONTROL_2r_GET(r) (r).dos_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET(r) (((r).dos_control_2[0]) & 0xffff)
#define BCM53324_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_DOS_CONTROL_2r_BIG_ICMP_PKT_SIZEf_GET(r) ((((r).dos_control_2[0]) >> 16) & 0xffff)
#define BCM53324_A0_DOS_CONTROL_2r_BIG_ICMP_PKT_SIZEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access DOS_CONTROL_2.
 *
 */
#define BCM53324_A0_READ_DOS_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_DOS_CONTROL_2r,(r._dos_control_2))
#define BCM53324_A0_WRITE_DOS_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_DOS_CONTROL_2r,&(r._dos_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CONTROL_2r BCM53324_A0_DOS_CONTROL_2r
#define DOS_CONTROL_2r_SIZE BCM53324_A0_DOS_CONTROL_2r_SIZE
typedef BCM53324_A0_DOS_CONTROL_2r_t DOS_CONTROL_2r_t;
#define DOS_CONTROL_2r_CLR BCM53324_A0_DOS_CONTROL_2r_CLR
#define DOS_CONTROL_2r_SET BCM53324_A0_DOS_CONTROL_2r_SET
#define DOS_CONTROL_2r_GET BCM53324_A0_DOS_CONTROL_2r_GET
#define DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET BCM53324_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET
#define DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET BCM53324_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET
#define DOS_CONTROL_2r_BIG_ICMP_PKT_SIZEf_GET BCM53324_A0_DOS_CONTROL_2r_BIG_ICMP_PKT_SIZEf_GET
#define DOS_CONTROL_2r_BIG_ICMP_PKT_SIZEf_SET BCM53324_A0_DOS_CONTROL_2r_BIG_ICMP_PKT_SIZEf_SET
#define READ_DOS_CONTROL_2r BCM53324_A0_READ_DOS_CONTROL_2r
#define WRITE_DOS_CONTROL_2r BCM53324_A0_WRITE_DOS_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DOS_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  DSCP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Diff Serv Code Point Table. This table is divided on Per Ingress Port basis. The index is constructed as [ingress_port[5:0], dscp[5:0]]
 * SIZE:     12
 * FIELDS:
 *     DSCP             New Diff Serv Code Point
 *     PRI              Priority
 *     CNG              Congestion bits
 *     EVEN_PARITY      Even parity for the DSCP_TABLE RAM fields
 *
 ******************************************************************************/
#define BCM53324_A0_DSCP_TABLEm 0x0c710000

#define BCM53324_A0_DSCP_TABLEm_MIN 0
#define BCM53324_A0_DSCP_TABLEm_MAX 1599
#define BCM53324_A0_DSCP_TABLEm_CMAX(u) 1599
#define BCM53324_A0_DSCP_TABLEm_SIZE 2

/*
 * This structure should be used to declare and program DSCP_TABLE.
 *
 */
typedef union BCM53324_A0_DSCP_TABLEm_s {
	uint32_t v[1];
	uint32_t dscp_table[1];
	uint32_t _dscp_table;
} BCM53324_A0_DSCP_TABLEm_t;

#define BCM53324_A0_DSCP_TABLEm_CLR(r) (r).dscp_table[0] = 0
#define BCM53324_A0_DSCP_TABLEm_SET(r,d) (r).dscp_table[0] = d
#define BCM53324_A0_DSCP_TABLEm_GET(r) (r).dscp_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DSCP_TABLEm_DSCPf_GET(r) (((r).dscp_table[0]) & 0x3f)
#define BCM53324_A0_DSCP_TABLEm_DSCPf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_DSCP_TABLEm_PRIf_GET(r) ((((r).dscp_table[0]) >> 6) & 0x7)
#define BCM53324_A0_DSCP_TABLEm_PRIf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53324_A0_DSCP_TABLEm_CNGf_GET(r) ((((r).dscp_table[0]) >> 9) & 0x3)
#define BCM53324_A0_DSCP_TABLEm_CNGf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53324_A0_DSCP_TABLEm_EVEN_PARITYf_GET(r) ((((r).dscp_table[0]) >> 11) & 0x1)
#define BCM53324_A0_DSCP_TABLEm_EVEN_PARITYf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access DSCP_TABLE.
 *
 */
#define BCM53324_A0_READ_DSCP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_DSCP_TABLEm,i,(m._dscp_table),1)
#define BCM53324_A0_WRITE_DSCP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_DSCP_TABLEm,i,&(m._dscp_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DSCP_TABLEm BCM53324_A0_DSCP_TABLEm
#define DSCP_TABLEm_MIN BCM53324_A0_DSCP_TABLEm_MIN
#define DSCP_TABLEm_MAX BCM53324_A0_DSCP_TABLEm_MAX
#define DSCP_TABLEm_CMAX(u) BCM53324_A0_DSCP_TABLEm_CMAX(u)
#define DSCP_TABLEm_SIZE BCM53324_A0_DSCP_TABLEm_SIZE
typedef BCM53324_A0_DSCP_TABLEm_t DSCP_TABLEm_t;
#define DSCP_TABLEm_CLR BCM53324_A0_DSCP_TABLEm_CLR
#define DSCP_TABLEm_SET BCM53324_A0_DSCP_TABLEm_SET
#define DSCP_TABLEm_GET BCM53324_A0_DSCP_TABLEm_GET
#define DSCP_TABLEm_DSCPf_GET BCM53324_A0_DSCP_TABLEm_DSCPf_GET
#define DSCP_TABLEm_DSCPf_SET BCM53324_A0_DSCP_TABLEm_DSCPf_SET
#define DSCP_TABLEm_PRIf_GET BCM53324_A0_DSCP_TABLEm_PRIf_GET
#define DSCP_TABLEm_PRIf_SET BCM53324_A0_DSCP_TABLEm_PRIf_SET
#define DSCP_TABLEm_CNGf_GET BCM53324_A0_DSCP_TABLEm_CNGf_GET
#define DSCP_TABLEm_CNGf_SET BCM53324_A0_DSCP_TABLEm_CNGf_SET
#define DSCP_TABLEm_EVEN_PARITYf_GET BCM53324_A0_DSCP_TABLEm_EVEN_PARITYf_GET
#define DSCP_TABLEm_EVEN_PARITYf_SET BCM53324_A0_DSCP_TABLEm_EVEN_PARITYf_SET
#define READ_DSCP_TABLEm BCM53324_A0_READ_DSCP_TABLEm
#define WRITE_DSCP_TABLEm BCM53324_A0_WRITE_DSCP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DSCP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DSCP_TABLE_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     DSCP_TABLE_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    Interrupt Enable. This bit is ANDed with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and ERR_ADRR are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the DSCP_TABLE table.
 *
 ******************************************************************************/
#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr 0x0c780013

#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DSCP_TABLE_PARITY_CONTROL.
 *
 */
typedef union BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t dscp_table_parity_control[1];
	uint32_t _dscp_table_parity_control;
} BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_t;

#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_CLR(r) (r).dscp_table_parity_control[0] = 0
#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_SET(r,d) (r).dscp_table_parity_control[0] = d
#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_GET(r) (r).dscp_table_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).dscp_table_parity_control[0]) & 0x1)
#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).dscp_table_parity_control[0]=(((r).dscp_table_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).dscp_table_parity_control[0]) >> 1) & 0x1)
#define BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).dscp_table_parity_control[0]=(((r).dscp_table_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access DSCP_TABLE_PARITY_CONTROL.
 *
 */
#define BCM53324_A0_READ_DSCP_TABLE_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr,(r._dscp_table_parity_control))
#define BCM53324_A0_WRITE_DSCP_TABLE_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr,&(r._dscp_table_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DSCP_TABLE_PARITY_CONTROLr BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr
#define DSCP_TABLE_PARITY_CONTROLr_SIZE BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_SIZE
typedef BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_t DSCP_TABLE_PARITY_CONTROLr_t;
#define DSCP_TABLE_PARITY_CONTROLr_CLR BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_CLR
#define DSCP_TABLE_PARITY_CONTROLr_SET BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_SET
#define DSCP_TABLE_PARITY_CONTROLr_GET BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_GET
#define DSCP_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define DSCP_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define DSCP_TABLE_PARITY_CONTROLr_PARITY_ENf_GET BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_PARITY_ENf_GET
#define DSCP_TABLE_PARITY_CONTROLr_PARITY_ENf_SET BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_DSCP_TABLE_PARITY_CONTROLr BCM53324_A0_READ_DSCP_TABLE_PARITY_CONTROLr
#define WRITE_DSCP_TABLE_PARITY_CONTROLr BCM53324_A0_WRITE_DSCP_TABLE_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DSCP_TABLE_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DSCP_TABLE_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     DSCP_TABLE_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ERR_ADDR         This field indicates the address location in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr 0x0c780014

#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program DSCP_TABLE_PARITY_STATUS.
 *
 */
typedef union BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t dscp_table_parity_status[1];
	uint32_t _dscp_table_parity_status;
} BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_t;

#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_CLR(r) (r).dscp_table_parity_status[0] = 0
#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_SET(r,d) (r).dscp_table_parity_status[0] = d
#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_GET(r) (r).dscp_table_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).dscp_table_parity_status[0]) & 0x1)
#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).dscp_table_parity_status[0]=(((r).dscp_table_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_ERR_ADDRf_GET(r) ((((r).dscp_table_parity_status[0]) >> 1) & 0x7fff)
#define BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_ERR_ADDRf_SET(r,f) (r).dscp_table_parity_status[0]=(((r).dscp_table_parity_status[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access DSCP_TABLE_PARITY_STATUS.
 *
 */
#define BCM53324_A0_READ_DSCP_TABLE_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_DSCP_TABLE_PARITY_STATUSr,(r._dscp_table_parity_status))
#define BCM53324_A0_WRITE_DSCP_TABLE_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_DSCP_TABLE_PARITY_STATUSr,&(r._dscp_table_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DSCP_TABLE_PARITY_STATUSr BCM53324_A0_DSCP_TABLE_PARITY_STATUSr
#define DSCP_TABLE_PARITY_STATUSr_SIZE BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_SIZE
typedef BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_t DSCP_TABLE_PARITY_STATUSr_t;
#define DSCP_TABLE_PARITY_STATUSr_CLR BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_CLR
#define DSCP_TABLE_PARITY_STATUSr_SET BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_SET
#define DSCP_TABLE_PARITY_STATUSr_GET BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_GET
#define DSCP_TABLE_PARITY_STATUSr_PARITY_ERRf_GET BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_PARITY_ERRf_GET
#define DSCP_TABLE_PARITY_STATUSr_PARITY_ERRf_SET BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_PARITY_ERRf_SET
#define DSCP_TABLE_PARITY_STATUSr_ERR_ADDRf_GET BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_ERR_ADDRf_GET
#define DSCP_TABLE_PARITY_STATUSr_ERR_ADDRf_SET BCM53324_A0_DSCP_TABLE_PARITY_STATUSr_ERR_ADDRf_SET
#define READ_DSCP_TABLE_PARITY_STATUSr BCM53324_A0_READ_DSCP_TABLE_PARITY_STATUSr
#define WRITE_DSCP_TABLE_PARITY_STATUSr BCM53324_A0_WRITE_DSCP_TABLE_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DSCP_TABLE_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DYNCELLCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNAMICCELLCOUNT Dynamic Cell Count for each egress port: 
 *
 ******************************************************************************/
#define BCM53324_A0_DYNCELLCOUNTr 0x0060005d

#define BCM53324_A0_DYNCELLCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program DYNCELLCOUNT.
 *
 */
typedef union BCM53324_A0_DYNCELLCOUNTr_s {
	uint32_t v[1];
	uint32_t dyncellcount[1];
	uint32_t _dyncellcount;
} BCM53324_A0_DYNCELLCOUNTr_t;

#define BCM53324_A0_DYNCELLCOUNTr_CLR(r) (r).dyncellcount[0] = 0
#define BCM53324_A0_DYNCELLCOUNTr_SET(r,d) (r).dyncellcount[0] = d
#define BCM53324_A0_DYNCELLCOUNTr_GET(r) (r).dyncellcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET(r) (((r).dyncellcount[0]) & 0xfff)
#define BCM53324_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET(r,f) (r).dyncellcount[0]=(((r).dyncellcount[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access DYNCELLCOUNT.
 *
 */
#define BCM53324_A0_READ_DYNCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_DYNCELLCOUNTr,(r._dyncellcount))
#define BCM53324_A0_WRITE_DYNCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_DYNCELLCOUNTr,&(r._dyncellcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNCELLCOUNTr BCM53324_A0_DYNCELLCOUNTr
#define DYNCELLCOUNTr_SIZE BCM53324_A0_DYNCELLCOUNTr_SIZE
typedef BCM53324_A0_DYNCELLCOUNTr_t DYNCELLCOUNTr_t;
#define DYNCELLCOUNTr_CLR BCM53324_A0_DYNCELLCOUNTr_CLR
#define DYNCELLCOUNTr_SET BCM53324_A0_DYNCELLCOUNTr_SET
#define DYNCELLCOUNTr_GET BCM53324_A0_DYNCELLCOUNTr_GET
#define DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET BCM53324_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_GET
#define DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET BCM53324_A0_DYNCELLCOUNTr_DYNAMICCELLCOUNTf_SET
#define READ_DYNCELLCOUNTr BCM53324_A0_READ_DYNCELLCOUNTr
#define WRITE_DYNCELLCOUNTr BCM53324_A0_WRITE_DYNCELLCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DYNCELLCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DYNCELLLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNCELLSETLIMIT  In Dynamic Memory mode:This regs represent the total dynamic cells that can be used by a port for all COSs. This CBP cells (LCCOUNT>LWM) that are used above the LWM limit are compared against this limit. Effectivelythis limit represents the HOL cell limit for a port. This limit is usedonly if Draco_1.5_mode is enabled.This limit is not used in Draco 1.0 mode.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *     DYNCELLRESETLIMIT In Dynamic Memory mode:This regs represent maximum port dynamic cells usage for its 8 COS queue.When a port is already in dropping state, and when its Dynamic cell countis less than this dyncellresetlimit or its LCCOUNT is less than its LWM. If all above conditions met, a COS queue will get back cell admission state.This limit is used only if Dynamic mode is enabled.This limit is not used in Draco 1.0 mode.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM53324_A0_DYNCELLLIMITr 0x0060005c

#define BCM53324_A0_DYNCELLLIMITr_SIZE 4

/*
 * This structure should be used to declare and program DYNCELLLIMIT.
 *
 */
typedef union BCM53324_A0_DYNCELLLIMITr_s {
	uint32_t v[1];
	uint32_t dyncelllimit[1];
	uint32_t _dyncelllimit;
} BCM53324_A0_DYNCELLLIMITr_t;

#define BCM53324_A0_DYNCELLLIMITr_CLR(r) (r).dyncelllimit[0] = 0
#define BCM53324_A0_DYNCELLLIMITr_SET(r,d) (r).dyncelllimit[0] = d
#define BCM53324_A0_DYNCELLLIMITr_GET(r) (r).dyncelllimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DYNCELLLIMITr_DYNCELLSETLIMITf_GET(r) (((r).dyncelllimit[0]) & 0xfff)
#define BCM53324_A0_DYNCELLLIMITr_DYNCELLSETLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_DYNCELLLIMITr_DYNCELLRESETLIMITf_GET(r) ((((r).dyncelllimit[0]) >> 12) & 0xfff)
#define BCM53324_A0_DYNCELLLIMITr_DYNCELLRESETLIMITf_SET(r,f) (r).dyncelllimit[0]=(((r).dyncelllimit[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access DYNCELLLIMIT.
 *
 */
#define BCM53324_A0_READ_DYNCELLLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_DYNCELLLIMITr,(r._dyncelllimit))
#define BCM53324_A0_WRITE_DYNCELLLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_DYNCELLLIMITr,&(r._dyncelllimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNCELLLIMITr BCM53324_A0_DYNCELLLIMITr
#define DYNCELLLIMITr_SIZE BCM53324_A0_DYNCELLLIMITr_SIZE
typedef BCM53324_A0_DYNCELLLIMITr_t DYNCELLLIMITr_t;
#define DYNCELLLIMITr_CLR BCM53324_A0_DYNCELLLIMITr_CLR
#define DYNCELLLIMITr_SET BCM53324_A0_DYNCELLLIMITr_SET
#define DYNCELLLIMITr_GET BCM53324_A0_DYNCELLLIMITr_GET
#define DYNCELLLIMITr_DYNCELLSETLIMITf_GET BCM53324_A0_DYNCELLLIMITr_DYNCELLSETLIMITf_GET
#define DYNCELLLIMITr_DYNCELLSETLIMITf_SET BCM53324_A0_DYNCELLLIMITr_DYNCELLSETLIMITf_SET
#define DYNCELLLIMITr_DYNCELLRESETLIMITf_GET BCM53324_A0_DYNCELLLIMITr_DYNCELLRESETLIMITf_GET
#define DYNCELLLIMITr_DYNCELLRESETLIMITf_SET BCM53324_A0_DYNCELLLIMITr_DYNCELLRESETLIMITf_SET
#define READ_DYNCELLLIMITr BCM53324_A0_READ_DYNCELLLIMITr
#define WRITE_DYNCELLLIMITr BCM53324_A0_WRITE_DYNCELLLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DYNCELLLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DYNPKTCNTPORT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNPKTCNTPORT    Dynamic packet count for an egress portThis is a status register. Software can read this register to find outpacket count which are in dynamic space.
 *
 ******************************************************************************/
#define BCM53324_A0_DYNPKTCNTPORTr 0x0060003b

#define BCM53324_A0_DYNPKTCNTPORTr_SIZE 4

/*
 * This structure should be used to declare and program DYNPKTCNTPORT.
 *
 */
typedef union BCM53324_A0_DYNPKTCNTPORTr_s {
	uint32_t v[1];
	uint32_t dynpktcntport[1];
	uint32_t _dynpktcntport;
} BCM53324_A0_DYNPKTCNTPORTr_t;

#define BCM53324_A0_DYNPKTCNTPORTr_CLR(r) (r).dynpktcntport[0] = 0
#define BCM53324_A0_DYNPKTCNTPORTr_SET(r,d) (r).dynpktcntport[0] = d
#define BCM53324_A0_DYNPKTCNTPORTr_GET(r) (r).dynpktcntport[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DYNPKTCNTPORTr_DYNPKTCNTPORTf_GET(r) (((r).dynpktcntport[0]) & 0x7ff)
#define BCM53324_A0_DYNPKTCNTPORTr_DYNPKTCNTPORTf_SET(r,f) (r).dynpktcntport[0]=(((r).dynpktcntport[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access DYNPKTCNTPORT.
 *
 */
#define BCM53324_A0_READ_DYNPKTCNTPORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_DYNPKTCNTPORTr,(r._dynpktcntport))
#define BCM53324_A0_WRITE_DYNPKTCNTPORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_DYNPKTCNTPORTr,&(r._dynpktcntport))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNPKTCNTPORTr BCM53324_A0_DYNPKTCNTPORTr
#define DYNPKTCNTPORTr_SIZE BCM53324_A0_DYNPKTCNTPORTr_SIZE
typedef BCM53324_A0_DYNPKTCNTPORTr_t DYNPKTCNTPORTr_t;
#define DYNPKTCNTPORTr_CLR BCM53324_A0_DYNPKTCNTPORTr_CLR
#define DYNPKTCNTPORTr_SET BCM53324_A0_DYNPKTCNTPORTr_SET
#define DYNPKTCNTPORTr_GET BCM53324_A0_DYNPKTCNTPORTr_GET
#define DYNPKTCNTPORTr_DYNPKTCNTPORTf_GET BCM53324_A0_DYNPKTCNTPORTr_DYNPKTCNTPORTf_GET
#define DYNPKTCNTPORTr_DYNPKTCNTPORTf_SET BCM53324_A0_DYNPKTCNTPORTr_DYNPKTCNTPORTf_SET
#define READ_DYNPKTCNTPORTr BCM53324_A0_READ_DYNPKTCNTPORTr
#define WRITE_DYNPKTCNTPORTr BCM53324_A0_WRITE_DYNPKTCNTPORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DYNPKTCNTPORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DYNRESETLIMPORT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNRESETLIMPORT  Dyanmic reset limit for HOLWhen dynamic packet count for an egress port is **above** the DYNXQCNTPORTPKT HOL will be asserted for COS which are consuming dynamic space.when dynamic packet count for an egress port is **below** DYNRESETLIMPORTPKT HOL will be de-asserted for COS which are consuming dynamic space.Default value of DYNRESETLIMPORT is DYNXQCNTPORT-4 (Unmanaged mode TCP performance drives the reset limit to be close to the setlimit). It is equal to decimal 483 (Unmanaged) and 467 (Managed).Unmanaged mode settings are the default. For managed mode, s/w has to reporgram these registers.
 *
 ******************************************************************************/
#define BCM53324_A0_DYNRESETLIMPORTr 0x0060003a

#define BCM53324_A0_DYNRESETLIMPORTr_SIZE 4

/*
 * This structure should be used to declare and program DYNRESETLIMPORT.
 *
 */
typedef union BCM53324_A0_DYNRESETLIMPORTr_s {
	uint32_t v[1];
	uint32_t dynresetlimport[1];
	uint32_t _dynresetlimport;
} BCM53324_A0_DYNRESETLIMPORTr_t;

#define BCM53324_A0_DYNRESETLIMPORTr_CLR(r) (r).dynresetlimport[0] = 0
#define BCM53324_A0_DYNRESETLIMPORTr_SET(r,d) (r).dynresetlimport[0] = d
#define BCM53324_A0_DYNRESETLIMPORTr_GET(r) (r).dynresetlimport[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DYNRESETLIMPORTr_DYNRESETLIMPORTf_GET(r) (((r).dynresetlimport[0]) & 0x7ff)
#define BCM53324_A0_DYNRESETLIMPORTr_DYNRESETLIMPORTf_SET(r,f) (r).dynresetlimport[0]=(((r).dynresetlimport[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access DYNRESETLIMPORT.
 *
 */
#define BCM53324_A0_READ_DYNRESETLIMPORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_DYNRESETLIMPORTr,(r._dynresetlimport))
#define BCM53324_A0_WRITE_DYNRESETLIMPORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_DYNRESETLIMPORTr,&(r._dynresetlimport))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNRESETLIMPORTr BCM53324_A0_DYNRESETLIMPORTr
#define DYNRESETLIMPORTr_SIZE BCM53324_A0_DYNRESETLIMPORTr_SIZE
typedef BCM53324_A0_DYNRESETLIMPORTr_t DYNRESETLIMPORTr_t;
#define DYNRESETLIMPORTr_CLR BCM53324_A0_DYNRESETLIMPORTr_CLR
#define DYNRESETLIMPORTr_SET BCM53324_A0_DYNRESETLIMPORTr_SET
#define DYNRESETLIMPORTr_GET BCM53324_A0_DYNRESETLIMPORTr_GET
#define DYNRESETLIMPORTr_DYNRESETLIMPORTf_GET BCM53324_A0_DYNRESETLIMPORTr_DYNRESETLIMPORTf_GET
#define DYNRESETLIMPORTr_DYNRESETLIMPORTf_SET BCM53324_A0_DYNRESETLIMPORTr_DYNRESETLIMPORTf_SET
#define READ_DYNRESETLIMPORTr BCM53324_A0_READ_DYNRESETLIMPORTr
#define WRITE_DYNRESETLIMPORTr BCM53324_A0_WRITE_DYNRESETLIMPORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DYNRESETLIMPORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  DYNXQCNTPORT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DYNXQCNTPORT     Dynamic XQ count per egress port.if XQ is not programmed to work in dynamic mode do following:  1. Disable (write 0) dyn_xq_en bit in MISCCONFIG register  2. program this register to be 0.If XQ is programmed to work in dynamic mode, do following:****IMPORTANT****    1. Enable (write 1) dyn_xq_en bit in MISCCONFIG register.  2. program this register to be    (XQ_DEPTH - SKID_MARKER - (sum of all  HOLCOSMINXQCNT) - Prefetch_reserve(5)).Software needs to program this register. Default is programmed to -	* Managed mode		- 471 (Decimal)	* Unmanaged mode (only 2 COS) - 487 (Decimal)Unmanaged mode settings are the default. For managed mode, s/w has to reporgram these registers.
 *
 ******************************************************************************/
#define BCM53324_A0_DYNXQCNTPORTr 0x00600039

#define BCM53324_A0_DYNXQCNTPORTr_SIZE 4

/*
 * This structure should be used to declare and program DYNXQCNTPORT.
 *
 */
typedef union BCM53324_A0_DYNXQCNTPORTr_s {
	uint32_t v[1];
	uint32_t dynxqcntport[1];
	uint32_t _dynxqcntport;
} BCM53324_A0_DYNXQCNTPORTr_t;

#define BCM53324_A0_DYNXQCNTPORTr_CLR(r) (r).dynxqcntport[0] = 0
#define BCM53324_A0_DYNXQCNTPORTr_SET(r,d) (r).dynxqcntport[0] = d
#define BCM53324_A0_DYNXQCNTPORTr_GET(r) (r).dynxqcntport[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_DYNXQCNTPORTr_DYNXQCNTPORTf_GET(r) (((r).dynxqcntport[0]) & 0x7ff)
#define BCM53324_A0_DYNXQCNTPORTr_DYNXQCNTPORTf_SET(r,f) (r).dynxqcntport[0]=(((r).dynxqcntport[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access DYNXQCNTPORT.
 *
 */
#define BCM53324_A0_READ_DYNXQCNTPORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_DYNXQCNTPORTr,(r._dynxqcntport))
#define BCM53324_A0_WRITE_DYNXQCNTPORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_DYNXQCNTPORTr,&(r._dynxqcntport))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DYNXQCNTPORTr BCM53324_A0_DYNXQCNTPORTr
#define DYNXQCNTPORTr_SIZE BCM53324_A0_DYNXQCNTPORTr_SIZE
typedef BCM53324_A0_DYNXQCNTPORTr_t DYNXQCNTPORTr_t;
#define DYNXQCNTPORTr_CLR BCM53324_A0_DYNXQCNTPORTr_CLR
#define DYNXQCNTPORTr_SET BCM53324_A0_DYNXQCNTPORTr_SET
#define DYNXQCNTPORTr_GET BCM53324_A0_DYNXQCNTPORTr_GET
#define DYNXQCNTPORTr_DYNXQCNTPORTf_GET BCM53324_A0_DYNXQCNTPORTr_DYNXQCNTPORTf_GET
#define DYNXQCNTPORTr_DYNXQCNTPORTf_SET BCM53324_A0_DYNXQCNTPORTr_DYNXQCNTPORTf_SET
#define READ_DYNXQCNTPORTr BCM53324_A0_READ_DYNXQCNTPORTr
#define WRITE_DYNXQCNTPORTr BCM53324_A0_WRITE_DYNXQCNTPORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_DYNXQCNTPORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EAVBUCKETCONFIG_EXT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CLASSB_THD_SEL_6LSB When EAV is enabled for a port, this register is used to program the lower 6 bits of the 18-bit EAV bucket threshold.See the MAXBUCKETCONFIG for further details.
 *     CLASSA_THD_SEL_6LSB When EAV is enabled for a port, this register is used to program the lower 6 bits of the 18-bit EAV bucket threshold.See the MAXBUCKETCONFIG for further details.
 *
 ******************************************************************************/
#define BCM53324_A0_EAVBUCKETCONFIG_EXTr 0x006000ad

#define BCM53324_A0_EAVBUCKETCONFIG_EXTr_SIZE 4

/*
 * This structure should be used to declare and program EAVBUCKETCONFIG_EXT.
 *
 */
typedef union BCM53324_A0_EAVBUCKETCONFIG_EXTr_s {
	uint32_t v[1];
	uint32_t eavbucketconfig_ext[1];
	uint32_t _eavbucketconfig_ext;
} BCM53324_A0_EAVBUCKETCONFIG_EXTr_t;

#define BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLR(r) (r).eavbucketconfig_ext[0] = 0
#define BCM53324_A0_EAVBUCKETCONFIG_EXTr_SET(r,d) (r).eavbucketconfig_ext[0] = d
#define BCM53324_A0_EAVBUCKETCONFIG_EXTr_GET(r) (r).eavbucketconfig_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLASSB_THD_SEL_6LSBf_GET(r) (((r).eavbucketconfig_ext[0]) & 0x3f)
#define BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLASSB_THD_SEL_6LSBf_SET(r,f) (r).eavbucketconfig_ext[0]=(((r).eavbucketconfig_ext[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLASSA_THD_SEL_6LSBf_GET(r) ((((r).eavbucketconfig_ext[0]) >> 6) & 0x3f)
#define BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLASSA_THD_SEL_6LSBf_SET(r,f) (r).eavbucketconfig_ext[0]=(((r).eavbucketconfig_ext[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))

/*
 * These macros can be used to access EAVBUCKETCONFIG_EXT.
 *
 */
#define BCM53324_A0_READ_EAVBUCKETCONFIG_EXTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EAVBUCKETCONFIG_EXTr,(r._eavbucketconfig_ext))
#define BCM53324_A0_WRITE_EAVBUCKETCONFIG_EXTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EAVBUCKETCONFIG_EXTr,&(r._eavbucketconfig_ext))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAVBUCKETCONFIG_EXTr BCM53324_A0_EAVBUCKETCONFIG_EXTr
#define EAVBUCKETCONFIG_EXTr_SIZE BCM53324_A0_EAVBUCKETCONFIG_EXTr_SIZE
typedef BCM53324_A0_EAVBUCKETCONFIG_EXTr_t EAVBUCKETCONFIG_EXTr_t;
#define EAVBUCKETCONFIG_EXTr_CLR BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLR
#define EAVBUCKETCONFIG_EXTr_SET BCM53324_A0_EAVBUCKETCONFIG_EXTr_SET
#define EAVBUCKETCONFIG_EXTr_GET BCM53324_A0_EAVBUCKETCONFIG_EXTr_GET
#define EAVBUCKETCONFIG_EXTr_CLASSB_THD_SEL_6LSBf_GET BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLASSB_THD_SEL_6LSBf_GET
#define EAVBUCKETCONFIG_EXTr_CLASSB_THD_SEL_6LSBf_SET BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLASSB_THD_SEL_6LSBf_SET
#define EAVBUCKETCONFIG_EXTr_CLASSA_THD_SEL_6LSBf_GET BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLASSA_THD_SEL_6LSBf_GET
#define EAVBUCKETCONFIG_EXTr_CLASSA_THD_SEL_6LSBf_SET BCM53324_A0_EAVBUCKETCONFIG_EXTr_CLASSA_THD_SEL_6LSBf_SET
#define READ_EAVBUCKETCONFIG_EXTr BCM53324_A0_READ_EAVBUCKETCONFIG_EXTr
#define WRITE_EAVBUCKETCONFIG_EXTr BCM53324_A0_WRITE_EAVBUCKETCONFIG_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EAVBUCKETCONFIG_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EAV_ENABLE_BMAP
 * BLOCKS:   IPIPE
 * DESC:     EAV Enable Bitmap
 * SIZE:     32
 * FIELDS:
 *     BITMAP           EAV Enable Bitmap
 *
 ******************************************************************************/
#define BCM53324_A0_EAV_ENABLE_BMAPr 0x0f78013a

#define BCM53324_A0_EAV_ENABLE_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program EAV_ENABLE_BMAP.
 *
 */
typedef union BCM53324_A0_EAV_ENABLE_BMAPr_s {
	uint32_t v[1];
	uint32_t eav_enable_bmap[1];
	uint32_t _eav_enable_bmap;
} BCM53324_A0_EAV_ENABLE_BMAPr_t;

#define BCM53324_A0_EAV_ENABLE_BMAPr_CLR(r) (r).eav_enable_bmap[0] = 0
#define BCM53324_A0_EAV_ENABLE_BMAPr_SET(r,d) (r).eav_enable_bmap[0] = d
#define BCM53324_A0_EAV_ENABLE_BMAPr_GET(r) (r).eav_enable_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EAV_ENABLE_BMAPr_BITMAPf_GET(r) (((r).eav_enable_bmap[0]) & 0x1ffffff)
#define BCM53324_A0_EAV_ENABLE_BMAPr_BITMAPf_SET(r,f) (r).eav_enable_bmap[0]=(((r).eav_enable_bmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access EAV_ENABLE_BMAP.
 *
 */
#define BCM53324_A0_READ_EAV_ENABLE_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EAV_ENABLE_BMAPr,(r._eav_enable_bmap))
#define BCM53324_A0_WRITE_EAV_ENABLE_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EAV_ENABLE_BMAPr,&(r._eav_enable_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAV_ENABLE_BMAPr BCM53324_A0_EAV_ENABLE_BMAPr
#define EAV_ENABLE_BMAPr_SIZE BCM53324_A0_EAV_ENABLE_BMAPr_SIZE
typedef BCM53324_A0_EAV_ENABLE_BMAPr_t EAV_ENABLE_BMAPr_t;
#define EAV_ENABLE_BMAPr_CLR BCM53324_A0_EAV_ENABLE_BMAPr_CLR
#define EAV_ENABLE_BMAPr_SET BCM53324_A0_EAV_ENABLE_BMAPr_SET
#define EAV_ENABLE_BMAPr_GET BCM53324_A0_EAV_ENABLE_BMAPr_GET
#define EAV_ENABLE_BMAPr_BITMAPf_GET BCM53324_A0_EAV_ENABLE_BMAPr_BITMAPf_GET
#define EAV_ENABLE_BMAPr_BITMAPf_SET BCM53324_A0_EAV_ENABLE_BMAPr_BITMAPf_SET
#define READ_EAV_ENABLE_BMAPr BCM53324_A0_READ_EAV_ENABLE_BMAPr
#define WRITE_EAV_ENABLE_BMAPr BCM53324_A0_WRITE_EAV_ENABLE_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EAV_ENABLE_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EEE_DELAY_ENTRY_TIMER
 * BLOCKS:   GPORT0
 * DESC:     EEE LPI timer
 * SIZE:     32
 * FIELDS:
 *     EEE_LPI_TIMER    This is the duration for which condition to move to LPI state must be satisfied, at the end of which MAC transitions to LPI State. The decrement unit is 1 micro-second.
 *
 ******************************************************************************/
#define BCM53324_A0_EEE_DELAY_ENTRY_TIMERr 0x0000011a

#define BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program EEE_DELAY_ENTRY_TIMER.
 *
 */
typedef union BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_s {
	uint32_t v[1];
	uint32_t eee_delay_entry_timer[1];
	uint32_t _eee_delay_entry_timer;
} BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_t;

#define BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_CLR(r) (r).eee_delay_entry_timer[0] = 0
#define BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_SET(r,d) (r).eee_delay_entry_timer[0] = d
#define BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_GET(r) (r).eee_delay_entry_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_EEE_LPI_TIMERf_GET(r) ((r).eee_delay_entry_timer[0])
#define BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_EEE_LPI_TIMERf_SET(r,f) (r).eee_delay_entry_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access EEE_DELAY_ENTRY_TIMER.
 *
 */
#define BCM53324_A0_READ_EEE_DELAY_ENTRY_TIMERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EEE_DELAY_ENTRY_TIMERr,(r._eee_delay_entry_timer))
#define BCM53324_A0_WRITE_EEE_DELAY_ENTRY_TIMERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EEE_DELAY_ENTRY_TIMERr,&(r._eee_delay_entry_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_DELAY_ENTRY_TIMERr BCM53324_A0_EEE_DELAY_ENTRY_TIMERr
#define EEE_DELAY_ENTRY_TIMERr_SIZE BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_SIZE
typedef BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_t EEE_DELAY_ENTRY_TIMERr_t;
#define EEE_DELAY_ENTRY_TIMERr_CLR BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_CLR
#define EEE_DELAY_ENTRY_TIMERr_SET BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_SET
#define EEE_DELAY_ENTRY_TIMERr_GET BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_GET
#define EEE_DELAY_ENTRY_TIMERr_EEE_LPI_TIMERf_GET BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_EEE_LPI_TIMERf_GET
#define EEE_DELAY_ENTRY_TIMERr_EEE_LPI_TIMERf_SET BCM53324_A0_EEE_DELAY_ENTRY_TIMERr_EEE_LPI_TIMERf_SET
#define READ_EEE_DELAY_ENTRY_TIMERr BCM53324_A0_READ_EEE_DELAY_ENTRY_TIMERr
#define WRITE_EEE_DELAY_ENTRY_TIMERr BCM53324_A0_WRITE_EEE_DELAY_ENTRY_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EEE_DELAY_ENTRY_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EEE_WAKE_TIMER
 * BLOCKS:   GPORT0
 * DESC:     EEE Wake timer
 * SIZE:     32
 * FIELDS:
 *     EEE_WAKE_TIMER   This is the duration for which MAC must wait to go back to ACTIVE state from LPI state when it receives packet for transmission. The decrement unit is 1 micro-second.
 *
 ******************************************************************************/
#define BCM53324_A0_EEE_WAKE_TIMERr 0x0000011b

#define BCM53324_A0_EEE_WAKE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program EEE_WAKE_TIMER.
 *
 */
typedef union BCM53324_A0_EEE_WAKE_TIMERr_s {
	uint32_t v[1];
	uint32_t eee_wake_timer[1];
	uint32_t _eee_wake_timer;
} BCM53324_A0_EEE_WAKE_TIMERr_t;

#define BCM53324_A0_EEE_WAKE_TIMERr_CLR(r) (r).eee_wake_timer[0] = 0
#define BCM53324_A0_EEE_WAKE_TIMERr_SET(r,d) (r).eee_wake_timer[0] = d
#define BCM53324_A0_EEE_WAKE_TIMERr_GET(r) (r).eee_wake_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EEE_WAKE_TIMERr_EEE_WAKE_TIMERf_GET(r) (((r).eee_wake_timer[0]) & 0xffff)
#define BCM53324_A0_EEE_WAKE_TIMERr_EEE_WAKE_TIMERf_SET(r,f) (r).eee_wake_timer[0]=(((r).eee_wake_timer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EEE_WAKE_TIMER.
 *
 */
#define BCM53324_A0_READ_EEE_WAKE_TIMERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EEE_WAKE_TIMERr,(r._eee_wake_timer))
#define BCM53324_A0_WRITE_EEE_WAKE_TIMERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EEE_WAKE_TIMERr,&(r._eee_wake_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EEE_WAKE_TIMERr BCM53324_A0_EEE_WAKE_TIMERr
#define EEE_WAKE_TIMERr_SIZE BCM53324_A0_EEE_WAKE_TIMERr_SIZE
typedef BCM53324_A0_EEE_WAKE_TIMERr_t EEE_WAKE_TIMERr_t;
#define EEE_WAKE_TIMERr_CLR BCM53324_A0_EEE_WAKE_TIMERr_CLR
#define EEE_WAKE_TIMERr_SET BCM53324_A0_EEE_WAKE_TIMERr_SET
#define EEE_WAKE_TIMERr_GET BCM53324_A0_EEE_WAKE_TIMERr_GET
#define EEE_WAKE_TIMERr_EEE_WAKE_TIMERf_GET BCM53324_A0_EEE_WAKE_TIMERr_EEE_WAKE_TIMERf_GET
#define EEE_WAKE_TIMERr_EEE_WAKE_TIMERf_SET BCM53324_A0_EEE_WAKE_TIMERr_EEE_WAKE_TIMERf_SET
#define READ_EEE_WAKE_TIMERr BCM53324_A0_READ_EEE_WAKE_TIMERr
#define WRITE_EEE_WAKE_TIMERr BCM53324_A0_WRITE_EEE_WAKE_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EEE_WAKE_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGRDROPPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DROPPEDPKTCOUNT  This is per egress port based counter and it counts the number of whole packets dropped by MMU and will not pass to egress port. MMU counts packets only if the portbitmap of the received packet is non-zero and not purgedThe reasons for mmu to drop packet:1. CBP memory Full,2. IBP Cell count over IBPDISCARDSETLIMIT,3. HOL Cell count over HOLCOSxCELLSETLIMIT,4. HOL Packet count over HOLCOSxPKTSETLIMIT or dyanmic packet count is more than DYNXQCNT,5. HOL Packet count over CNGCOSxPKTSETLIMIT0 and Packet with CNG[1:0]=2'b01,6. HOL Packet count over CNGCOSxPKTSETLIMIT1 and Packet with CNG[1:0]=2'b11,7. Single cell packet (64~128 bytes) purged by Ingress Pipeline. (do we count these packets..?? DV needsto check).For packet just dropped when the some cells of the packet are already beenadmitted by mmu, this packet will not get counted by MMU EGRDROPPKTCOUNT. 
 *
 ******************************************************************************/
#define BCM53324_A0_EGRDROPPKTCOUNTr 0x0060006a

#define BCM53324_A0_EGRDROPPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program EGRDROPPKTCOUNT.
 *
 */
typedef union BCM53324_A0_EGRDROPPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t egrdroppktcount[1];
	uint32_t _egrdroppktcount;
} BCM53324_A0_EGRDROPPKTCOUNTr_t;

#define BCM53324_A0_EGRDROPPKTCOUNTr_CLR(r) (r).egrdroppktcount[0] = 0
#define BCM53324_A0_EGRDROPPKTCOUNTr_SET(r,d) (r).egrdroppktcount[0] = d
#define BCM53324_A0_EGRDROPPKTCOUNTr_GET(r) (r).egrdroppktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET(r) ((r).egrdroppktcount[0])
#define BCM53324_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET(r,f) (r).egrdroppktcount[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRDROPPKTCOUNT.
 *
 */
#define BCM53324_A0_READ_EGRDROPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGRDROPPKTCOUNTr,(r._egrdroppktcount))
#define BCM53324_A0_WRITE_EGRDROPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGRDROPPKTCOUNTr,&(r._egrdroppktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRDROPPKTCOUNTr BCM53324_A0_EGRDROPPKTCOUNTr
#define EGRDROPPKTCOUNTr_SIZE BCM53324_A0_EGRDROPPKTCOUNTr_SIZE
typedef BCM53324_A0_EGRDROPPKTCOUNTr_t EGRDROPPKTCOUNTr_t;
#define EGRDROPPKTCOUNTr_CLR BCM53324_A0_EGRDROPPKTCOUNTr_CLR
#define EGRDROPPKTCOUNTr_SET BCM53324_A0_EGRDROPPKTCOUNTr_SET
#define EGRDROPPKTCOUNTr_GET BCM53324_A0_EGRDROPPKTCOUNTr_GET
#define EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET BCM53324_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_GET
#define EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET BCM53324_A0_EGRDROPPKTCOUNTr_DROPPEDPKTCOUNTf_SET
#define READ_EGRDROPPKTCOUNTr BCM53324_A0_READ_EGRDROPPKTCOUNTr
#define WRITE_EGRDROPPKTCOUNTr BCM53324_A0_WRITE_EGRDROPPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGRDROPPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGRESSCELLREQUESTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     REQUESTCOUNT     Egress Cell request Counter.Counter needs to reset when reseting Egress port.
 *
 ******************************************************************************/
#define BCM53324_A0_EGRESSCELLREQUESTCOUNTr 0x00600060

#define BCM53324_A0_EGRESSCELLREQUESTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program EGRESSCELLREQUESTCOUNT.
 *
 */
typedef union BCM53324_A0_EGRESSCELLREQUESTCOUNTr_s {
	uint32_t v[1];
	uint32_t egresscellrequestcount[1];
	uint32_t _egresscellrequestcount;
} BCM53324_A0_EGRESSCELLREQUESTCOUNTr_t;

#define BCM53324_A0_EGRESSCELLREQUESTCOUNTr_CLR(r) (r).egresscellrequestcount[0] = 0
#define BCM53324_A0_EGRESSCELLREQUESTCOUNTr_SET(r,d) (r).egresscellrequestcount[0] = d
#define BCM53324_A0_EGRESSCELLREQUESTCOUNTr_GET(r) (r).egresscellrequestcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET(r) (((r).egresscellrequestcount[0]) & 0xf)
#define BCM53324_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET(r,f) (r).egresscellrequestcount[0]=(((r).egresscellrequestcount[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGRESSCELLREQUESTCOUNT.
 *
 */
#define BCM53324_A0_READ_EGRESSCELLREQUESTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGRESSCELLREQUESTCOUNTr,(r._egresscellrequestcount))
#define BCM53324_A0_WRITE_EGRESSCELLREQUESTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGRESSCELLREQUESTCOUNTr,&(r._egresscellrequestcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESSCELLREQUESTCOUNTr BCM53324_A0_EGRESSCELLREQUESTCOUNTr
#define EGRESSCELLREQUESTCOUNTr_SIZE BCM53324_A0_EGRESSCELLREQUESTCOUNTr_SIZE
typedef BCM53324_A0_EGRESSCELLREQUESTCOUNTr_t EGRESSCELLREQUESTCOUNTr_t;
#define EGRESSCELLREQUESTCOUNTr_CLR BCM53324_A0_EGRESSCELLREQUESTCOUNTr_CLR
#define EGRESSCELLREQUESTCOUNTr_SET BCM53324_A0_EGRESSCELLREQUESTCOUNTr_SET
#define EGRESSCELLREQUESTCOUNTr_GET BCM53324_A0_EGRESSCELLREQUESTCOUNTr_GET
#define EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET BCM53324_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_GET
#define EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET BCM53324_A0_EGRESSCELLREQUESTCOUNTr_REQUESTCOUNTf_SET
#define READ_EGRESSCELLREQUESTCOUNTr BCM53324_A0_READ_EGRESSCELLREQUESTCOUNTr
#define WRITE_EGRESSCELLREQUESTCOUNTr BCM53324_A0_WRITE_EGRESSCELLREQUESTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGRESSCELLREQUESTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGRMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET           Maximum rate bucket with unit is 0.5 bit.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of metering bucket1: out of profile0: In profileDefault value is in profile.
 *
 ******************************************************************************/
#define BCM53324_A0_EGRMETERINGBUCKETr 0x0060006e

#define BCM53324_A0_EGRMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGBUCKET.
 *
 */
typedef union BCM53324_A0_EGRMETERINGBUCKETr_s {
	uint32_t v[1];
	uint32_t egrmeteringbucket[1];
	uint32_t _egrmeteringbucket;
} BCM53324_A0_EGRMETERINGBUCKETr_t;

#define BCM53324_A0_EGRMETERINGBUCKETr_CLR(r) (r).egrmeteringbucket[0] = 0
#define BCM53324_A0_EGRMETERINGBUCKETr_SET(r,d) (r).egrmeteringbucket[0] = d
#define BCM53324_A0_EGRMETERINGBUCKETr_GET(r) (r).egrmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGRMETERINGBUCKETr_BUCKETf_GET(r) (((r).egrmeteringbucket[0]) & 0x1fffffff)
#define BCM53324_A0_EGRMETERINGBUCKETr_BUCKETf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53324_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).egrmeteringbucket[0]) >> 29) & 0x1)
#define BCM53324_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access EGRMETERINGBUCKET.
 *
 */
#define BCM53324_A0_READ_EGRMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGRMETERINGBUCKETr,(r._egrmeteringbucket))
#define BCM53324_A0_WRITE_EGRMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGRMETERINGBUCKETr,&(r._egrmeteringbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRMETERINGBUCKETr BCM53324_A0_EGRMETERINGBUCKETr
#define EGRMETERINGBUCKETr_SIZE BCM53324_A0_EGRMETERINGBUCKETr_SIZE
typedef BCM53324_A0_EGRMETERINGBUCKETr_t EGRMETERINGBUCKETr_t;
#define EGRMETERINGBUCKETr_CLR BCM53324_A0_EGRMETERINGBUCKETr_CLR
#define EGRMETERINGBUCKETr_SET BCM53324_A0_EGRMETERINGBUCKETr_SET
#define EGRMETERINGBUCKETr_GET BCM53324_A0_EGRMETERINGBUCKETr_GET
#define EGRMETERINGBUCKETr_BUCKETf_GET BCM53324_A0_EGRMETERINGBUCKETr_BUCKETf_GET
#define EGRMETERINGBUCKETr_BUCKETf_SET BCM53324_A0_EGRMETERINGBUCKETr_BUCKETf_SET
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET BCM53324_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_GET
#define EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET BCM53324_A0_EGRMETERINGBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_EGRMETERINGBUCKETr BCM53324_A0_READ_EGRMETERINGBUCKETr
#define WRITE_EGRMETERINGBUCKETr BCM53324_A0_WRITE_EGRMETERINGBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGRMETERINGBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGRMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     THD_SEL          Threshold for metering bucket.The setting of Threshold determines the size ofbucket and not related to rate. It also determines how burstness of traffic is.The Bucket size is range from 4k Bytes to 16M Bytes with 4k Bytes incrementThe Bucket size is determined by the formula,BucketSize = THD_SEL * 4KBytesEgress Metering Bucket function is disable when bucket size is 0.
 *     REFRESH          Refresh count for metering bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set REFRESH = 15624.
 *
 ******************************************************************************/
#define BCM53324_A0_EGRMETERINGCONFIGr 0x0060006d

#define BCM53324_A0_EGRMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGCONFIG.
 *
 */
typedef union BCM53324_A0_EGRMETERINGCONFIGr_s {
	uint32_t v[1];
	uint32_t egrmeteringconfig[1];
	uint32_t _egrmeteringconfig;
} BCM53324_A0_EGRMETERINGCONFIGr_t;

#define BCM53324_A0_EGRMETERINGCONFIGr_CLR(r) (r).egrmeteringconfig[0] = 0
#define BCM53324_A0_EGRMETERINGCONFIGr_SET(r,d) (r).egrmeteringconfig[0] = d
#define BCM53324_A0_EGRMETERINGCONFIGr_GET(r) (r).egrmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGRMETERINGCONFIGr_THD_SELf_GET(r) (((r).egrmeteringconfig[0]) & 0xfff)
#define BCM53324_A0_EGRMETERINGCONFIGr_THD_SELf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_EGRMETERINGCONFIGr_REFRESHf_GET(r) ((((r).egrmeteringconfig[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_EGRMETERINGCONFIGr_REFRESHf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access EGRMETERINGCONFIG.
 *
 */
#define BCM53324_A0_READ_EGRMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGRMETERINGCONFIGr,(r._egrmeteringconfig))
#define BCM53324_A0_WRITE_EGRMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGRMETERINGCONFIGr,&(r._egrmeteringconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRMETERINGCONFIGr BCM53324_A0_EGRMETERINGCONFIGr
#define EGRMETERINGCONFIGr_SIZE BCM53324_A0_EGRMETERINGCONFIGr_SIZE
typedef BCM53324_A0_EGRMETERINGCONFIGr_t EGRMETERINGCONFIGr_t;
#define EGRMETERINGCONFIGr_CLR BCM53324_A0_EGRMETERINGCONFIGr_CLR
#define EGRMETERINGCONFIGr_SET BCM53324_A0_EGRMETERINGCONFIGr_SET
#define EGRMETERINGCONFIGr_GET BCM53324_A0_EGRMETERINGCONFIGr_GET
#define EGRMETERINGCONFIGr_THD_SELf_GET BCM53324_A0_EGRMETERINGCONFIGr_THD_SELf_GET
#define EGRMETERINGCONFIGr_THD_SELf_SET BCM53324_A0_EGRMETERINGCONFIGr_THD_SELf_SET
#define EGRMETERINGCONFIGr_REFRESHf_GET BCM53324_A0_EGRMETERINGCONFIGr_REFRESHf_GET
#define EGRMETERINGCONFIGr_REFRESHf_SET BCM53324_A0_EGRMETERINGCONFIGr_REFRESHf_SET
#define READ_EGRMETERINGCONFIGr BCM53324_A0_READ_EGRMETERINGCONFIGr
#define WRITE_EGRMETERINGCONFIGr BCM53324_A0_WRITE_EGRMETERINGCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGRMETERINGCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGRTXPKTCTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXPKTCOUNT       Transmit Packet Counter: When TXPKTCOUNT_SEL in EGRTXPKTCTR is selected, this packet tranmit counter will count all the packets to be tranmitted topre-configured egress port with pre-configurated cos on EGRTXPKTCTRCONFIG0.  
 *
 ******************************************************************************/
#define BCM53324_A0_EGRTXPKTCTRr 0x0068001f

#define BCM53324_A0_EGRTXPKTCTRr_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTR.
 *
 */
typedef union BCM53324_A0_EGRTXPKTCTRr_s {
	uint32_t v[1];
	uint32_t egrtxpktctr[1];
	uint32_t _egrtxpktctr;
} BCM53324_A0_EGRTXPKTCTRr_t;

#define BCM53324_A0_EGRTXPKTCTRr_CLR(r) (r).egrtxpktctr[0] = 0
#define BCM53324_A0_EGRTXPKTCTRr_SET(r,d) (r).egrtxpktctr[0] = d
#define BCM53324_A0_EGRTXPKTCTRr_GET(r) (r).egrtxpktctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGRTXPKTCTRr_TXPKTCOUNTf_GET(r) ((r).egrtxpktctr[0])
#define BCM53324_A0_EGRTXPKTCTRr_TXPKTCOUNTf_SET(r,f) (r).egrtxpktctr[0]=((uint32_t)f)

/*
 * These macros can be used to access EGRTXPKTCTR.
 *
 */
#define BCM53324_A0_READ_EGRTXPKTCTRr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGRTXPKTCTRr+(i),(r._egrtxpktctr))
#define BCM53324_A0_WRITE_EGRTXPKTCTRr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGRTXPKTCTRr+(i),&(r._egrtxpktctr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRr BCM53324_A0_EGRTXPKTCTRr
#define EGRTXPKTCTRr_SIZE BCM53324_A0_EGRTXPKTCTRr_SIZE
typedef BCM53324_A0_EGRTXPKTCTRr_t EGRTXPKTCTRr_t;
#define EGRTXPKTCTRr_CLR BCM53324_A0_EGRTXPKTCTRr_CLR
#define EGRTXPKTCTRr_SET BCM53324_A0_EGRTXPKTCTRr_SET
#define EGRTXPKTCTRr_GET BCM53324_A0_EGRTXPKTCTRr_GET
#define EGRTXPKTCTRr_TXPKTCOUNTf_GET BCM53324_A0_EGRTXPKTCTRr_TXPKTCOUNTf_GET
#define EGRTXPKTCTRr_TXPKTCOUNTf_SET BCM53324_A0_EGRTXPKTCTRr_TXPKTCOUNTf_SET
#define READ_EGRTXPKTCTRr BCM53324_A0_READ_EGRTXPKTCTRr
#define WRITE_EGRTXPKTCTRr BCM53324_A0_WRITE_EGRTXPKTCTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGRTXPKTCTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGRTXPKTCTRCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TXEPORTNUM       Egress port number: When TXPKTCOUNT_EN is selected, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets to be tranmitted to this egress port.  
 *     TXIPORTNUM       Ingress port number: When TXPKTCOUNT_IPORTEN is selected, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets received from this ingress port.  
 *     TXCOSNUM         Egress cos number: When TXPKTCOUNT_EN is aseerted, this packet tranmitcounter EGRTXPKTCTR0 will count all the packets to be tranmitted to pre-configured cos.  
 *     TXPKTCOUNT_SEL   Transmit Packet Counter Select: Select the way EGRTXPKTCTR count the packet:2'b00: Disable, not counting.2'b01: Count packets transmit to egress port with cos defined in        TXEPORTNUM and TXCOSNUM2'b10: Count packets receive from ingress port with cos defined in       TXIPORTNUM and TXCOSNUM2'b11: Count packets receive from ingress port and transmit to egress port       with cos defined in TXIPORTNUM, TXEPORTNUM and TXCOSNUM.
 *
 ******************************************************************************/
#define BCM53324_A0_EGRTXPKTCTRCONFIGr 0x00680017

#define BCM53324_A0_EGRTXPKTCTRCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGRTXPKTCTRCONFIG.
 *
 */
typedef union BCM53324_A0_EGRTXPKTCTRCONFIGr_s {
	uint32_t v[1];
	uint32_t egrtxpktctrconfig[1];
	uint32_t _egrtxpktctrconfig;
} BCM53324_A0_EGRTXPKTCTRCONFIGr_t;

#define BCM53324_A0_EGRTXPKTCTRCONFIGr_CLR(r) (r).egrtxpktctrconfig[0] = 0
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_SET(r,d) (r).egrtxpktctrconfig[0] = d
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_GET(r) (r).egrtxpktctrconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_TXEPORTNUMf_GET(r) (((r).egrtxpktctrconfig[0]) & 0x3f)
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_TXEPORTNUMf_SET(r,f) (r).egrtxpktctrconfig[0]=(((r).egrtxpktctrconfig[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_TXIPORTNUMf_GET(r) ((((r).egrtxpktctrconfig[0]) >> 6) & 0x3f)
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_TXIPORTNUMf_SET(r,f) (r).egrtxpktctrconfig[0]=(((r).egrtxpktctrconfig[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_TXCOSNUMf_GET(r) ((((r).egrtxpktctrconfig[0]) >> 12) & 0x7)
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_TXCOSNUMf_SET(r,f) (r).egrtxpktctrconfig[0]=(((r).egrtxpktctrconfig[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_GET(r) ((((r).egrtxpktctrconfig[0]) >> 15) & 0x3)
#define BCM53324_A0_EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_SET(r,f) (r).egrtxpktctrconfig[0]=(((r).egrtxpktctrconfig[0] & ~((uint32_t)0x3 << 15)) | ((((uint32_t)f) & 0x3) << 15))

/*
 * These macros can be used to access EGRTXPKTCTRCONFIG.
 *
 */
#define BCM53324_A0_READ_EGRTXPKTCTRCONFIGr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGRTXPKTCTRCONFIGr+(i),(r._egrtxpktctrconfig))
#define BCM53324_A0_WRITE_EGRTXPKTCTRCONFIGr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGRTXPKTCTRCONFIGr+(i),&(r._egrtxpktctrconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRTXPKTCTRCONFIGr BCM53324_A0_EGRTXPKTCTRCONFIGr
#define EGRTXPKTCTRCONFIGr_SIZE BCM53324_A0_EGRTXPKTCTRCONFIGr_SIZE
typedef BCM53324_A0_EGRTXPKTCTRCONFIGr_t EGRTXPKTCTRCONFIGr_t;
#define EGRTXPKTCTRCONFIGr_CLR BCM53324_A0_EGRTXPKTCTRCONFIGr_CLR
#define EGRTXPKTCTRCONFIGr_SET BCM53324_A0_EGRTXPKTCTRCONFIGr_SET
#define EGRTXPKTCTRCONFIGr_GET BCM53324_A0_EGRTXPKTCTRCONFIGr_GET
#define EGRTXPKTCTRCONFIGr_TXEPORTNUMf_GET BCM53324_A0_EGRTXPKTCTRCONFIGr_TXEPORTNUMf_GET
#define EGRTXPKTCTRCONFIGr_TXEPORTNUMf_SET BCM53324_A0_EGRTXPKTCTRCONFIGr_TXEPORTNUMf_SET
#define EGRTXPKTCTRCONFIGr_TXIPORTNUMf_GET BCM53324_A0_EGRTXPKTCTRCONFIGr_TXIPORTNUMf_GET
#define EGRTXPKTCTRCONFIGr_TXIPORTNUMf_SET BCM53324_A0_EGRTXPKTCTRCONFIGr_TXIPORTNUMf_SET
#define EGRTXPKTCTRCONFIGr_TXCOSNUMf_GET BCM53324_A0_EGRTXPKTCTRCONFIGr_TXCOSNUMf_GET
#define EGRTXPKTCTRCONFIGr_TXCOSNUMf_SET BCM53324_A0_EGRTXPKTCTRCONFIGr_TXCOSNUMf_SET
#define EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_GET BCM53324_A0_EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_GET
#define EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_SET BCM53324_A0_EGRTXPKTCTRCONFIGr_TXPKTCOUNT_SELf_SET
#define READ_EGRTXPKTCTRCONFIGr BCM53324_A0_READ_EGRTXPKTCTRCONFIGr
#define WRITE_EGRTXPKTCTRCONFIGr BCM53324_A0_WRITE_EGRTXPKTCTRCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGRTXPKTCTRCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_CONFIG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for the entire chip. 


 * SIZE:     32
 * FIELDS:
 *     DT_MODE          Double Tagging Mode is enabled or not.
 *     USE_LEARN_VID    Use the learn_vid for vid membership and stg state check.
 *     LEARN_VID        Vid to be used for vid membership and stg state check when USE_LEARN_VID is set.
 *     INNER_TPID       TPID to identify inner vlan tag of the packet when switch is operating in DT mode, i.e. DT_MODE bit is set.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_CONFIGr 0x01980000

#define BCM53324_A0_EGR_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG.
 *
 */
typedef union BCM53324_A0_EGR_CONFIGr_s {
	uint32_t v[1];
	uint32_t egr_config[1];
	uint32_t _egr_config;
} BCM53324_A0_EGR_CONFIGr_t;

#define BCM53324_A0_EGR_CONFIGr_CLR(r) (r).egr_config[0] = 0
#define BCM53324_A0_EGR_CONFIGr_SET(r,d) (r).egr_config[0] = d
#define BCM53324_A0_EGR_CONFIGr_GET(r) (r).egr_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_CONFIGr_DT_MODEf_GET(r) (((r).egr_config[0]) & 0x1)
#define BCM53324_A0_EGR_CONFIGr_DT_MODEf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_CONFIGr_USE_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 1) & 0x1)
#define BCM53324_A0_EGR_CONFIGr_USE_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_EGR_CONFIGr_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 2) & 0xfff)
#define BCM53324_A0_EGR_CONFIGr_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM53324_A0_EGR_CONFIGr_INNER_TPIDf_GET(r) ((((r).egr_config[0]) >> 14) & 0xffff)
#define BCM53324_A0_EGR_CONFIGr_INNER_TPIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0xffff << 14)) | ((((uint32_t)f) & 0xffff) << 14))

/*
 * These macros can be used to access EGR_CONFIG.
 *
 */
#define BCM53324_A0_READ_EGR_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_CONFIGr,(r._egr_config))
#define BCM53324_A0_WRITE_EGR_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_CONFIGr,&(r._egr_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_CONFIGr BCM53324_A0_EGR_CONFIGr
#define EGR_CONFIGr_SIZE BCM53324_A0_EGR_CONFIGr_SIZE
typedef BCM53324_A0_EGR_CONFIGr_t EGR_CONFIGr_t;
#define EGR_CONFIGr_CLR BCM53324_A0_EGR_CONFIGr_CLR
#define EGR_CONFIGr_SET BCM53324_A0_EGR_CONFIGr_SET
#define EGR_CONFIGr_GET BCM53324_A0_EGR_CONFIGr_GET
#define EGR_CONFIGr_DT_MODEf_GET BCM53324_A0_EGR_CONFIGr_DT_MODEf_GET
#define EGR_CONFIGr_DT_MODEf_SET BCM53324_A0_EGR_CONFIGr_DT_MODEf_SET
#define EGR_CONFIGr_USE_LEARN_VIDf_GET BCM53324_A0_EGR_CONFIGr_USE_LEARN_VIDf_GET
#define EGR_CONFIGr_USE_LEARN_VIDf_SET BCM53324_A0_EGR_CONFIGr_USE_LEARN_VIDf_SET
#define EGR_CONFIGr_LEARN_VIDf_GET BCM53324_A0_EGR_CONFIGr_LEARN_VIDf_GET
#define EGR_CONFIGr_LEARN_VIDf_SET BCM53324_A0_EGR_CONFIGr_LEARN_VIDf_SET
#define EGR_CONFIGr_INNER_TPIDf_GET BCM53324_A0_EGR_CONFIGr_INNER_TPIDf_GET
#define EGR_CONFIGr_INNER_TPIDf_SET BCM53324_A0_EGR_CONFIGr_INNER_TPIDf_SET
#define READ_EGR_CONFIGr BCM53324_A0_READ_EGR_CONFIGr
#define WRITE_EGR_CONFIGr BCM53324_A0_WRITE_EGR_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_CONFIG_1
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register Extension for the entire chip. 


 * SIZE:     32
 * FIELDS:
 *     RING_MODE        User should set it when switches are cascaded in a ring fashion
 *     FORCE_STATIC_MH_PFM Forces MH_PFM in the module header for pkts going to Higig Port.
 *     MH_PFM           PFM to be used to construct the Module Header.
 *     IPMC_ROUTE_SAME_VLAN When special processing is needed for IPMC replicated pkt which has same vlan as incoming packet's vlan.
 *     RESERVED_5       Reserved
 *     MIRROR_INVALID_VLAN_DROP Will control whether packets are dropped or forwarded for the mirror-to-port when the packet going out contains an invalid VLAN.  A '1' will force the packet to be dropped, while a '0' will allow it to forward.
 *     IGNORE_HG_HDR_DONOT_LEARN If set, HiGig hdrs DONOT_LEARN bit will be ignored and will be treated as reserved bit.
 *     BPDU_INVALID_VLAN_DROP Will control whether BPDU packets are dropped or forwarded when the packet going out contains an invalid VLAN.  A '1' will force the packet to be dropped, while a '0' will allow it to forward.
 *     DISABLE_MIRROR_CHECKS Will disable im and em mirror checks?
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_CONFIG_1r 0x01980001

#define BCM53324_A0_EGR_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG_1.
 *
 */
typedef union BCM53324_A0_EGR_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t egr_config_1[1];
	uint32_t _egr_config_1;
} BCM53324_A0_EGR_CONFIG_1r_t;

#define BCM53324_A0_EGR_CONFIG_1r_CLR(r) (r).egr_config_1[0] = 0
#define BCM53324_A0_EGR_CONFIG_1r_SET(r,d) (r).egr_config_1[0] = d
#define BCM53324_A0_EGR_CONFIG_1r_GET(r) (r).egr_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_CONFIG_1r_RING_MODEf_GET(r) (((r).egr_config_1[0]) & 0x1)
#define BCM53324_A0_EGR_CONFIG_1r_RING_MODEf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET(r) ((((r).egr_config_1[0]) >> 1) & 0x1)
#define BCM53324_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_EGR_CONFIG_1r_MH_PFMf_GET(r) ((((r).egr_config_1[0]) >> 2) & 0x3)
#define BCM53324_A0_EGR_CONFIG_1r_MH_PFMf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET(r) ((((r).egr_config_1[0]) >> 4) & 0x1)
#define BCM53324_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_EGR_CONFIG_1r_RESERVED_5f_GET(r) ((((r).egr_config_1[0]) >> 5) & 0x1)
#define BCM53324_A0_EGR_CONFIG_1r_RESERVED_5f_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_GET(r) ((((r).egr_config_1[0]) >> 6) & 0x1)
#define BCM53324_A0_EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET(r) ((((r).egr_config_1[0]) >> 7) & 0x1)
#define BCM53324_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_GET(r) ((((r).egr_config_1[0]) >> 8) & 0x1)
#define BCM53324_A0_EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_EGR_CONFIG_1r_DISABLE_MIRROR_CHECKSf_GET(r) ((((r).egr_config_1[0]) >> 9) & 0x1)
#define BCM53324_A0_EGR_CONFIG_1r_DISABLE_MIRROR_CHECKSf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access EGR_CONFIG_1.
 *
 */
#define BCM53324_A0_READ_EGR_CONFIG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_CONFIG_1r,(r._egr_config_1))
#define BCM53324_A0_WRITE_EGR_CONFIG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_CONFIG_1r,&(r._egr_config_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_CONFIG_1r BCM53324_A0_EGR_CONFIG_1r
#define EGR_CONFIG_1r_SIZE BCM53324_A0_EGR_CONFIG_1r_SIZE
typedef BCM53324_A0_EGR_CONFIG_1r_t EGR_CONFIG_1r_t;
#define EGR_CONFIG_1r_CLR BCM53324_A0_EGR_CONFIG_1r_CLR
#define EGR_CONFIG_1r_SET BCM53324_A0_EGR_CONFIG_1r_SET
#define EGR_CONFIG_1r_GET BCM53324_A0_EGR_CONFIG_1r_GET
#define EGR_CONFIG_1r_RING_MODEf_GET BCM53324_A0_EGR_CONFIG_1r_RING_MODEf_GET
#define EGR_CONFIG_1r_RING_MODEf_SET BCM53324_A0_EGR_CONFIG_1r_RING_MODEf_SET
#define EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET BCM53324_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET
#define EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET BCM53324_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET
#define EGR_CONFIG_1r_MH_PFMf_GET BCM53324_A0_EGR_CONFIG_1r_MH_PFMf_GET
#define EGR_CONFIG_1r_MH_PFMf_SET BCM53324_A0_EGR_CONFIG_1r_MH_PFMf_SET
#define EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET BCM53324_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET
#define EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET BCM53324_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET
#define EGR_CONFIG_1r_RESERVED_5f_GET BCM53324_A0_EGR_CONFIG_1r_RESERVED_5f_GET
#define EGR_CONFIG_1r_RESERVED_5f_SET BCM53324_A0_EGR_CONFIG_1r_RESERVED_5f_SET
#define EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_GET BCM53324_A0_EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_GET
#define EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_SET BCM53324_A0_EGR_CONFIG_1r_MIRROR_INVALID_VLAN_DROPf_SET
#define EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET BCM53324_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET
#define EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET BCM53324_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET
#define EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_GET BCM53324_A0_EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_GET
#define EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_SET BCM53324_A0_EGR_CONFIG_1r_BPDU_INVALID_VLAN_DROPf_SET
#define EGR_CONFIG_1r_DISABLE_MIRROR_CHECKSf_GET BCM53324_A0_EGR_CONFIG_1r_DISABLE_MIRROR_CHECKSf_GET
#define EGR_CONFIG_1r_DISABLE_MIRROR_CHECKSf_SET BCM53324_A0_EGR_CONFIG_1r_DISABLE_MIRROR_CHECKSf_SET
#define READ_EGR_CONFIG_1r BCM53324_A0_READ_EGR_CONFIG_1r
#define WRITE_EGR_CONFIG_1r BCM53324_A0_WRITE_EGR_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_DBG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is same for GE, 10GE, Higig Ports.


 * SIZE:     32
 * FIELDS:
 *     RESURRECT        Enable the resurrect feature for purge, aged and cell_error packets.If this bit is set, the packets marked as Purge, Aged, Cell_error are not dropped in the chip.
 *     DISABLE_CRC_REGEN Disable CRC regeneration for GE ports only. In case of Higig or 10GE, theCRC regeration is config based in the mac.
 *     ALWAYS_CRC_REGEN Always regenrate the CRC for GE ports only. In case of Higig or 10GE, theCRC regeration is config based in the mac.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_DBGr 0x06900000

#define BCM53324_A0_EGR_DBGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_DBG.
 *
 */
typedef union BCM53324_A0_EGR_DBGr_s {
	uint32_t v[1];
	uint32_t egr_dbg[1];
	uint32_t _egr_dbg;
} BCM53324_A0_EGR_DBGr_t;

#define BCM53324_A0_EGR_DBGr_CLR(r) (r).egr_dbg[0] = 0
#define BCM53324_A0_EGR_DBGr_SET(r,d) (r).egr_dbg[0] = d
#define BCM53324_A0_EGR_DBGr_GET(r) (r).egr_dbg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_DBGr_RESURRECTf_GET(r) (((r).egr_dbg[0]) & 0x1)
#define BCM53324_A0_EGR_DBGr_RESURRECTf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_DBGr_DISABLE_CRC_REGENf_GET(r) ((((r).egr_dbg[0]) >> 1) & 0x1)
#define BCM53324_A0_EGR_DBGr_DISABLE_CRC_REGENf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_EGR_DBGr_ALWAYS_CRC_REGENf_GET(r) ((((r).egr_dbg[0]) >> 2) & 0x1)
#define BCM53324_A0_EGR_DBGr_ALWAYS_CRC_REGENf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access EGR_DBG.
 *
 */
#define BCM53324_A0_READ_EGR_DBGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_DBGr,(r._egr_dbg))
#define BCM53324_A0_WRITE_EGR_DBGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_DBGr,&(r._egr_dbg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DBGr BCM53324_A0_EGR_DBGr
#define EGR_DBGr_SIZE BCM53324_A0_EGR_DBGr_SIZE
typedef BCM53324_A0_EGR_DBGr_t EGR_DBGr_t;
#define EGR_DBGr_CLR BCM53324_A0_EGR_DBGr_CLR
#define EGR_DBGr_SET BCM53324_A0_EGR_DBGr_SET
#define EGR_DBGr_GET BCM53324_A0_EGR_DBGr_GET
#define EGR_DBGr_RESURRECTf_GET BCM53324_A0_EGR_DBGr_RESURRECTf_GET
#define EGR_DBGr_RESURRECTf_SET BCM53324_A0_EGR_DBGr_RESURRECTf_SET
#define EGR_DBGr_DISABLE_CRC_REGENf_GET BCM53324_A0_EGR_DBGr_DISABLE_CRC_REGENf_GET
#define EGR_DBGr_DISABLE_CRC_REGENf_SET BCM53324_A0_EGR_DBGr_DISABLE_CRC_REGENf_SET
#define EGR_DBGr_ALWAYS_CRC_REGENf_GET BCM53324_A0_EGR_DBGr_ALWAYS_CRC_REGENf_GET
#define EGR_DBGr_ALWAYS_CRC_REGENf_SET BCM53324_A0_EGR_DBGr_ALWAYS_CRC_REGENf_SET
#define READ_EGR_DBGr BCM53324_A0_READ_EGR_DBGr
#define WRITE_EGR_DBGr BCM53324_A0_WRITE_EGR_DBGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_DBGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_EAV_CLASS
 * BLOCKS:   EPIPE
 * DESC:     To support PCP remarking for non-EAV Traffic going out on EAV-port 
 * SIZE:     32
 * FIELDS:
 *     CLASS_A          Class_A value
 *     CLASS_B          Class_B value
 *     REMAP_CLASS_A    Class_A traffic should be remarked with this value
 *     REMAP_CLASS_B    Class_B traffic should be remarked with this value
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_EAV_CLASSr 0x06980003

#define BCM53324_A0_EGR_EAV_CLASSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_EAV_CLASS.
 *
 */
typedef union BCM53324_A0_EGR_EAV_CLASSr_s {
	uint32_t v[1];
	uint32_t egr_eav_class[1];
	uint32_t _egr_eav_class;
} BCM53324_A0_EGR_EAV_CLASSr_t;

#define BCM53324_A0_EGR_EAV_CLASSr_CLR(r) (r).egr_eav_class[0] = 0
#define BCM53324_A0_EGR_EAV_CLASSr_SET(r,d) (r).egr_eav_class[0] = d
#define BCM53324_A0_EGR_EAV_CLASSr_GET(r) (r).egr_eav_class[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_EAV_CLASSr_CLASS_Af_GET(r) (((r).egr_eav_class[0]) & 0x7)
#define BCM53324_A0_EGR_EAV_CLASSr_CLASS_Af_SET(r,f) (r).egr_eav_class[0]=(((r).egr_eav_class[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_EGR_EAV_CLASSr_CLASS_Bf_GET(r) ((((r).egr_eav_class[0]) >> 3) & 0x7)
#define BCM53324_A0_EGR_EAV_CLASSr_CLASS_Bf_SET(r,f) (r).egr_eav_class[0]=(((r).egr_eav_class[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53324_A0_EGR_EAV_CLASSr_REMAP_CLASS_Af_GET(r) ((((r).egr_eav_class[0]) >> 6) & 0x7)
#define BCM53324_A0_EGR_EAV_CLASSr_REMAP_CLASS_Af_SET(r,f) (r).egr_eav_class[0]=(((r).egr_eav_class[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53324_A0_EGR_EAV_CLASSr_REMAP_CLASS_Bf_GET(r) ((((r).egr_eav_class[0]) >> 9) & 0x7)
#define BCM53324_A0_EGR_EAV_CLASSr_REMAP_CLASS_Bf_SET(r,f) (r).egr_eav_class[0]=(((r).egr_eav_class[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))

/*
 * These macros can be used to access EGR_EAV_CLASS.
 *
 */
#define BCM53324_A0_READ_EGR_EAV_CLASSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_EAV_CLASSr,(r._egr_eav_class))
#define BCM53324_A0_WRITE_EGR_EAV_CLASSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_EAV_CLASSr,&(r._egr_eav_class))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_EAV_CLASSr BCM53324_A0_EGR_EAV_CLASSr
#define EGR_EAV_CLASSr_SIZE BCM53324_A0_EGR_EAV_CLASSr_SIZE
typedef BCM53324_A0_EGR_EAV_CLASSr_t EGR_EAV_CLASSr_t;
#define EGR_EAV_CLASSr_CLR BCM53324_A0_EGR_EAV_CLASSr_CLR
#define EGR_EAV_CLASSr_SET BCM53324_A0_EGR_EAV_CLASSr_SET
#define EGR_EAV_CLASSr_GET BCM53324_A0_EGR_EAV_CLASSr_GET
#define EGR_EAV_CLASSr_CLASS_Af_GET BCM53324_A0_EGR_EAV_CLASSr_CLASS_Af_GET
#define EGR_EAV_CLASSr_CLASS_Af_SET BCM53324_A0_EGR_EAV_CLASSr_CLASS_Af_SET
#define EGR_EAV_CLASSr_CLASS_Bf_GET BCM53324_A0_EGR_EAV_CLASSr_CLASS_Bf_GET
#define EGR_EAV_CLASSr_CLASS_Bf_SET BCM53324_A0_EGR_EAV_CLASSr_CLASS_Bf_SET
#define EGR_EAV_CLASSr_REMAP_CLASS_Af_GET BCM53324_A0_EGR_EAV_CLASSr_REMAP_CLASS_Af_GET
#define EGR_EAV_CLASSr_REMAP_CLASS_Af_SET BCM53324_A0_EGR_EAV_CLASSr_REMAP_CLASS_Af_SET
#define EGR_EAV_CLASSr_REMAP_CLASS_Bf_GET BCM53324_A0_EGR_EAV_CLASSr_REMAP_CLASS_Bf_GET
#define EGR_EAV_CLASSr_REMAP_CLASS_Bf_SET BCM53324_A0_EGR_EAV_CLASSr_REMAP_CLASS_Bf_SET
#define READ_EGR_EAV_CLASSr BCM53324_A0_READ_EGR_EAV_CLASSr
#define WRITE_EGR_EAV_CLASSr BCM53324_A0_WRITE_EGR_EAV_CLASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_EAV_CLASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_ENABLE
 * BLOCKS:   EPIPE
 * DESC:     Enables the Egress Port for transmission.

 * SIZE:     32
 * FIELDS:
 *     PRT_ENABLE       Port is enabled. If this bit is set, the requests to MMU will be made from this port to the MMU.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_ENABLEr 0x0a900100

#define BCM53324_A0_EGR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program EGR_ENABLE.
 *
 */
typedef union BCM53324_A0_EGR_ENABLEr_s {
	uint32_t v[1];
	uint32_t egr_enable[1];
	uint32_t _egr_enable;
} BCM53324_A0_EGR_ENABLEr_t;

#define BCM53324_A0_EGR_ENABLEr_CLR(r) (r).egr_enable[0] = 0
#define BCM53324_A0_EGR_ENABLEr_SET(r,d) (r).egr_enable[0] = d
#define BCM53324_A0_EGR_ENABLEr_GET(r) (r).egr_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_ENABLEr_PRT_ENABLEf_GET(r) (((r).egr_enable[0]) & 0x1)
#define BCM53324_A0_EGR_ENABLEr_PRT_ENABLEf_SET(r,f) (r).egr_enable[0]=(((r).egr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_ENABLE.
 *
 */
#define BCM53324_A0_READ_EGR_ENABLEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_ENABLEr,(r._egr_enable))
#define BCM53324_A0_WRITE_EGR_ENABLEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_ENABLEr,&(r._egr_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_ENABLEr BCM53324_A0_EGR_ENABLEr
#define EGR_ENABLEr_SIZE BCM53324_A0_EGR_ENABLEr_SIZE
typedef BCM53324_A0_EGR_ENABLEr_t EGR_ENABLEr_t;
#define EGR_ENABLEr_CLR BCM53324_A0_EGR_ENABLEr_CLR
#define EGR_ENABLEr_SET BCM53324_A0_EGR_ENABLEr_SET
#define EGR_ENABLEr_GET BCM53324_A0_EGR_ENABLEr_GET
#define EGR_ENABLEr_PRT_ENABLEf_GET BCM53324_A0_EGR_ENABLEr_PRT_ENABLEf_GET
#define EGR_ENABLEr_PRT_ENABLEf_SET BCM53324_A0_EGR_ENABLEr_PRT_ENABLEf_SET
#define READ_EGR_ENABLEr BCM53324_A0_READ_EGR_ENABLEr
#define WRITE_EGR_ENABLEr BCM53324_A0_WRITE_EGR_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_ENABLE_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Specifies from where the PORT_ENABLES needs to be chosen.

 * SIZE:     32
 * FIELDS:
 *     ENABLE_SELECT    If "1" the PORT_ENABLES will be taken from the EGR_ENABLE registerIf "0" the PORT_ENABLES will be set based on "top_to_ep_enable_all_ports" signal.This register provides a fail-safe mode in case of Unmanaged-Mode for HK
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_ENABLE_SELECTr 0x0a980105

#define BCM53324_A0_EGR_ENABLE_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program EGR_ENABLE_SELECT.
 *
 */
typedef union BCM53324_A0_EGR_ENABLE_SELECTr_s {
	uint32_t v[1];
	uint32_t egr_enable_select[1];
	uint32_t _egr_enable_select;
} BCM53324_A0_EGR_ENABLE_SELECTr_t;

#define BCM53324_A0_EGR_ENABLE_SELECTr_CLR(r) (r).egr_enable_select[0] = 0
#define BCM53324_A0_EGR_ENABLE_SELECTr_SET(r,d) (r).egr_enable_select[0] = d
#define BCM53324_A0_EGR_ENABLE_SELECTr_GET(r) (r).egr_enable_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_ENABLE_SELECTr_ENABLE_SELECTf_GET(r) (((r).egr_enable_select[0]) & 0x1)
#define BCM53324_A0_EGR_ENABLE_SELECTr_ENABLE_SELECTf_SET(r,f) (r).egr_enable_select[0]=(((r).egr_enable_select[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_ENABLE_SELECT.
 *
 */
#define BCM53324_A0_READ_EGR_ENABLE_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_ENABLE_SELECTr,(r._egr_enable_select))
#define BCM53324_A0_WRITE_EGR_ENABLE_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_ENABLE_SELECTr,&(r._egr_enable_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_ENABLE_SELECTr BCM53324_A0_EGR_ENABLE_SELECTr
#define EGR_ENABLE_SELECTr_SIZE BCM53324_A0_EGR_ENABLE_SELECTr_SIZE
typedef BCM53324_A0_EGR_ENABLE_SELECTr_t EGR_ENABLE_SELECTr_t;
#define EGR_ENABLE_SELECTr_CLR BCM53324_A0_EGR_ENABLE_SELECTr_CLR
#define EGR_ENABLE_SELECTr_SET BCM53324_A0_EGR_ENABLE_SELECTr_SET
#define EGR_ENABLE_SELECTr_GET BCM53324_A0_EGR_ENABLE_SELECTr_GET
#define EGR_ENABLE_SELECTr_ENABLE_SELECTf_GET BCM53324_A0_EGR_ENABLE_SELECTr_ENABLE_SELECTf_GET
#define EGR_ENABLE_SELECTr_ENABLE_SELECTf_SET BCM53324_A0_EGR_ENABLE_SELECTr_ENABLE_SELECTf_SET
#define READ_EGR_ENABLE_SELECTr BCM53324_A0_READ_EGR_ENABLE_SELECTr
#define WRITE_EGR_ENABLE_SELECTr BCM53324_A0_WRITE_EGR_ENABLE_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_ENABLE_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_EVENT_DEBUG
 * BLOCKS:   EPIPE
 * DESC:     Sticky stats bits. This register is updated with the reasons for which a pkt is dropped or transmitted. This is a sticky register, so once a bit is set, it'll stay set till the software clears it.

 * SIZE:     32
 * FIELDS:
 *     TGIP4            Bit 0 - Transmit Good IPv4 L3 UC packet counter
 *     TIPD4            Bit 1 - Transmit IPv4 L3 UC Aged and Drop packet counter
 *     TGIPMC4          Bit 2 - Transmit Good IPv4 IPMC packet counter
 *     TIPMCD4          Bit 3 - Transmit IPv4 IPMC Aged and Drop packet counter
 *     TGIP6            Bit 4 - Transmit Good IPv6 L3 UC packet counter
 *     TIPD6            Bit 5 - Transmit IPv6 L3 UC Aged and Drop Packet counter
 *     TGIPMC6          Bit 6 - Transmit Good IPv6 IPMC packet counter
 *     TIPMCD6          Bit 7 - Transmit IPv6 IPMC Aged and Drop packet counter
 *     TTNL             Bit 8 - Transmit Tunnel packet counter
 *     TTNLE            Bit 9 - Transmit Tunnel error packet counter (inner v6 is not 6to4 or ISATAP for automatic tunnel encapsulation)
 *     TTTLD            Bit 10 - Packets dropped due to TTL threshold counter
 *     TCFID            Bit 11 - Packets dropped when CFI bit set and packet is untagged or L3_switched for IPMC counter
 *     TVLAN            Bit 12 - Transmit VLAN tagged packet counter
 *     TVLAND           Bit 13 - Packet dropped due to invalid VLAN counter
 *     TVXLTMD          Bit 14 - Packet dropped due to miss in VXLT table counter
 *     TSTGD            Bit 15 - Packet dropped due to Spanning Tree State not in forwarding state counter
 *     TAGED            Bit 16 - Packet dropped due to packet aged counter
 *     TL2MCD           Bit 17 - L2 MC packet drop counter
 *     TPKTD            Bit 17 - Packet dropped due to any condition
 *     TMIRR            Bit 19 - mirroring flag.
 *     TSIPL            Bit 20 - SIP Link Local Drop flag.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_EVENT_DEBUGr 0x09980003

#define BCM53324_A0_EGR_EVENT_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_EVENT_DEBUG.
 *
 */
typedef union BCM53324_A0_EGR_EVENT_DEBUGr_s {
	uint32_t v[1];
	uint32_t egr_event_debug[1];
	uint32_t _egr_event_debug;
} BCM53324_A0_EGR_EVENT_DEBUGr_t;

#define BCM53324_A0_EGR_EVENT_DEBUGr_CLR(r) (r).egr_event_debug[0] = 0
#define BCM53324_A0_EGR_EVENT_DEBUGr_SET(r,d) (r).egr_event_debug[0] = d
#define BCM53324_A0_EGR_EVENT_DEBUGr_GET(r) (r).egr_event_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_EVENT_DEBUGr_TGIP4f_GET(r) (((r).egr_event_debug[0]) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TGIP4f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TIPD4f_GET(r) ((((r).egr_event_debug[0]) >> 1) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TIPD4f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TGIPMC4f_GET(r) ((((r).egr_event_debug[0]) >> 2) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TGIPMC4f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TIPMCD4f_GET(r) ((((r).egr_event_debug[0]) >> 3) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TIPMCD4f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TGIP6f_GET(r) ((((r).egr_event_debug[0]) >> 4) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TGIP6f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TIPD6f_GET(r) ((((r).egr_event_debug[0]) >> 5) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TIPD6f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TGIPMC6f_GET(r) ((((r).egr_event_debug[0]) >> 6) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TGIPMC6f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TIPMCD6f_GET(r) ((((r).egr_event_debug[0]) >> 7) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TIPMCD6f_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TTNLf_GET(r) ((((r).egr_event_debug[0]) >> 8) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TTNLf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TTNLEf_GET(r) ((((r).egr_event_debug[0]) >> 9) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TTNLEf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TTTLDf_GET(r) ((((r).egr_event_debug[0]) >> 10) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TTTLDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TCFIDf_GET(r) ((((r).egr_event_debug[0]) >> 11) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TCFIDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TVLANf_GET(r) ((((r).egr_event_debug[0]) >> 12) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TVLANf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TVLANDf_GET(r) ((((r).egr_event_debug[0]) >> 13) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TVLANDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TVXLTMDf_GET(r) ((((r).egr_event_debug[0]) >> 14) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TVXLTMDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TSTGDf_GET(r) ((((r).egr_event_debug[0]) >> 15) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TSTGDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TAGEDf_GET(r) ((((r).egr_event_debug[0]) >> 16) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TAGEDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TL2MCDf_GET(r) ((((r).egr_event_debug[0]) >> 17) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TL2MCDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TPKTDf_GET(r) ((((r).egr_event_debug[0]) >> 18) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TPKTDf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TMIRRf_GET(r) ((((r).egr_event_debug[0]) >> 19) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TMIRRf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_EGR_EVENT_DEBUGr_TSIPLf_GET(r) ((((r).egr_event_debug[0]) >> 20) & 0x1)
#define BCM53324_A0_EGR_EVENT_DEBUGr_TSIPLf_SET(r,f) (r).egr_event_debug[0]=(((r).egr_event_debug[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access EGR_EVENT_DEBUG.
 *
 */
#define BCM53324_A0_READ_EGR_EVENT_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_EVENT_DEBUGr,(r._egr_event_debug))
#define BCM53324_A0_WRITE_EGR_EVENT_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_EVENT_DEBUGr,&(r._egr_event_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_EVENT_DEBUGr BCM53324_A0_EGR_EVENT_DEBUGr
#define EGR_EVENT_DEBUGr_SIZE BCM53324_A0_EGR_EVENT_DEBUGr_SIZE
typedef BCM53324_A0_EGR_EVENT_DEBUGr_t EGR_EVENT_DEBUGr_t;
#define EGR_EVENT_DEBUGr_CLR BCM53324_A0_EGR_EVENT_DEBUGr_CLR
#define EGR_EVENT_DEBUGr_SET BCM53324_A0_EGR_EVENT_DEBUGr_SET
#define EGR_EVENT_DEBUGr_GET BCM53324_A0_EGR_EVENT_DEBUGr_GET
#define EGR_EVENT_DEBUGr_TGIP4f_GET BCM53324_A0_EGR_EVENT_DEBUGr_TGIP4f_GET
#define EGR_EVENT_DEBUGr_TGIP4f_SET BCM53324_A0_EGR_EVENT_DEBUGr_TGIP4f_SET
#define EGR_EVENT_DEBUGr_TIPD4f_GET BCM53324_A0_EGR_EVENT_DEBUGr_TIPD4f_GET
#define EGR_EVENT_DEBUGr_TIPD4f_SET BCM53324_A0_EGR_EVENT_DEBUGr_TIPD4f_SET
#define EGR_EVENT_DEBUGr_TGIPMC4f_GET BCM53324_A0_EGR_EVENT_DEBUGr_TGIPMC4f_GET
#define EGR_EVENT_DEBUGr_TGIPMC4f_SET BCM53324_A0_EGR_EVENT_DEBUGr_TGIPMC4f_SET
#define EGR_EVENT_DEBUGr_TIPMCD4f_GET BCM53324_A0_EGR_EVENT_DEBUGr_TIPMCD4f_GET
#define EGR_EVENT_DEBUGr_TIPMCD4f_SET BCM53324_A0_EGR_EVENT_DEBUGr_TIPMCD4f_SET
#define EGR_EVENT_DEBUGr_TGIP6f_GET BCM53324_A0_EGR_EVENT_DEBUGr_TGIP6f_GET
#define EGR_EVENT_DEBUGr_TGIP6f_SET BCM53324_A0_EGR_EVENT_DEBUGr_TGIP6f_SET
#define EGR_EVENT_DEBUGr_TIPD6f_GET BCM53324_A0_EGR_EVENT_DEBUGr_TIPD6f_GET
#define EGR_EVENT_DEBUGr_TIPD6f_SET BCM53324_A0_EGR_EVENT_DEBUGr_TIPD6f_SET
#define EGR_EVENT_DEBUGr_TGIPMC6f_GET BCM53324_A0_EGR_EVENT_DEBUGr_TGIPMC6f_GET
#define EGR_EVENT_DEBUGr_TGIPMC6f_SET BCM53324_A0_EGR_EVENT_DEBUGr_TGIPMC6f_SET
#define EGR_EVENT_DEBUGr_TIPMCD6f_GET BCM53324_A0_EGR_EVENT_DEBUGr_TIPMCD6f_GET
#define EGR_EVENT_DEBUGr_TIPMCD6f_SET BCM53324_A0_EGR_EVENT_DEBUGr_TIPMCD6f_SET
#define EGR_EVENT_DEBUGr_TTNLf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TTNLf_GET
#define EGR_EVENT_DEBUGr_TTNLf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TTNLf_SET
#define EGR_EVENT_DEBUGr_TTNLEf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TTNLEf_GET
#define EGR_EVENT_DEBUGr_TTNLEf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TTNLEf_SET
#define EGR_EVENT_DEBUGr_TTTLDf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TTTLDf_GET
#define EGR_EVENT_DEBUGr_TTTLDf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TTTLDf_SET
#define EGR_EVENT_DEBUGr_TCFIDf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TCFIDf_GET
#define EGR_EVENT_DEBUGr_TCFIDf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TCFIDf_SET
#define EGR_EVENT_DEBUGr_TVLANf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TVLANf_GET
#define EGR_EVENT_DEBUGr_TVLANf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TVLANf_SET
#define EGR_EVENT_DEBUGr_TVLANDf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TVLANDf_GET
#define EGR_EVENT_DEBUGr_TVLANDf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TVLANDf_SET
#define EGR_EVENT_DEBUGr_TVXLTMDf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TVXLTMDf_GET
#define EGR_EVENT_DEBUGr_TVXLTMDf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TVXLTMDf_SET
#define EGR_EVENT_DEBUGr_TSTGDf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TSTGDf_GET
#define EGR_EVENT_DEBUGr_TSTGDf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TSTGDf_SET
#define EGR_EVENT_DEBUGr_TAGEDf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TAGEDf_GET
#define EGR_EVENT_DEBUGr_TAGEDf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TAGEDf_SET
#define EGR_EVENT_DEBUGr_TL2MCDf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TL2MCDf_GET
#define EGR_EVENT_DEBUGr_TL2MCDf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TL2MCDf_SET
#define EGR_EVENT_DEBUGr_TPKTDf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TPKTDf_GET
#define EGR_EVENT_DEBUGr_TPKTDf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TPKTDf_SET
#define EGR_EVENT_DEBUGr_TMIRRf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TMIRRf_GET
#define EGR_EVENT_DEBUGr_TMIRRf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TMIRRf_SET
#define EGR_EVENT_DEBUGr_TSIPLf_GET BCM53324_A0_EGR_EVENT_DEBUGr_TSIPLf_GET
#define EGR_EVENT_DEBUGr_TSIPLf_SET BCM53324_A0_EGR_EVENT_DEBUGr_TSIPLf_SET
#define READ_EGR_EVENT_DEBUGr BCM53324_A0_READ_EGR_EVENT_DEBUGr
#define WRITE_EGR_EVENT_DEBUGr BCM53324_A0_WRITE_EGR_EVENT_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_EVENT_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_HW_RESET_CONTROL_0
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.
This register should be programmed before programming EGR_HW_RESET_CONTROL_1 register.

 * SIZE:     32
 * FIELDS:
 *     STAGE_NUMBER     Stage Number where table to be reset is located. This is NOT used when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *     START_ADDRESS    20 bit starting address for the memory. HW starts incrementing from this address until EGR_HW_RESET_CONTROL_1.COUNT is completed.  START_ADDRESS is relevant even when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r 0x00980000

#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_0.
 *
 */
typedef union BCM53324_A0_EGR_HW_RESET_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t egr_hw_reset_control_0[1];
	uint32_t _egr_hw_reset_control_0;
} BCM53324_A0_EGR_HW_RESET_CONTROL_0r_t;

#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r_CLR(r) (r).egr_hw_reset_control_0[0] = 0
#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r_SET(r,d) (r).egr_hw_reset_control_0[0] = d
#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r_GET(r) (r).egr_hw_reset_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET(r) (((r).egr_hw_reset_control_0[0]) & 0x3f)
#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET(r) ((((r).egr_hw_reset_control_0[0]) >> 6) & 0xfffff)
#define BCM53324_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32_t)0xfffff << 6)) | ((((uint32_t)f) & 0xfffff) << 6))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_0.
 *
 */
#define BCM53324_A0_READ_EGR_HW_RESET_CONTROL_0r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_HW_RESET_CONTROL_0r,(r._egr_hw_reset_control_0))
#define BCM53324_A0_WRITE_EGR_HW_RESET_CONTROL_0r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_HW_RESET_CONTROL_0r,&(r._egr_hw_reset_control_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_HW_RESET_CONTROL_0r BCM53324_A0_EGR_HW_RESET_CONTROL_0r
#define EGR_HW_RESET_CONTROL_0r_SIZE BCM53324_A0_EGR_HW_RESET_CONTROL_0r_SIZE
typedef BCM53324_A0_EGR_HW_RESET_CONTROL_0r_t EGR_HW_RESET_CONTROL_0r_t;
#define EGR_HW_RESET_CONTROL_0r_CLR BCM53324_A0_EGR_HW_RESET_CONTROL_0r_CLR
#define EGR_HW_RESET_CONTROL_0r_SET BCM53324_A0_EGR_HW_RESET_CONTROL_0r_SET
#define EGR_HW_RESET_CONTROL_0r_GET BCM53324_A0_EGR_HW_RESET_CONTROL_0r_GET
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET BCM53324_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET BCM53324_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET BCM53324_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET BCM53324_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET
#define READ_EGR_HW_RESET_CONTROL_0r BCM53324_A0_READ_EGR_HW_RESET_CONTROL_0r
#define WRITE_EGR_HW_RESET_CONTROL_0r BCM53324_A0_WRITE_EGR_HW_RESET_CONTROL_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_HW_RESET_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_HW_RESET_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count of entries which need to be resetted starting from EGR_HW_RESET_CONTROL_0.START_ADDRESS.
 *     RESET_ALL        If set, then ALL Tables in the Egress Pipeline will be resetted for COUNT entries. STAGE_NUMBER is ignored when this bit is set. 
 *     VALID            The HW table initialization will start after Logic sees this bit as set.
 *     DONE             After HW has issued memory reset commands equal to COUNT times, it will set DONE bit,SW can poll this bit from time to time and whenever it is set, SW should reset DONE and VALIDbits to 0. This will end the HW Reset Sequence of memories in the HW.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r 0x00980001

#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_1.
 *
 */
typedef union BCM53324_A0_EGR_HW_RESET_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_hw_reset_control_1[1];
	uint32_t _egr_hw_reset_control_1;
} BCM53324_A0_EGR_HW_RESET_CONTROL_1r_t;

#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_CLR(r) (r).egr_hw_reset_control_1[0] = 0
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_SET(r,d) (r).egr_hw_reset_control_1[0] = d
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_GET(r) (r).egr_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_GET(r) (((r).egr_hw_reset_control_1[0]) & 0xffff)
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 16) & 0x1)
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 17) & 0x1)
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_DONEf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 18) & 0x1)
#define BCM53324_A0_EGR_HW_RESET_CONTROL_1r_DONEf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_1.
 *
 */
#define BCM53324_A0_READ_EGR_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_HW_RESET_CONTROL_1r,(r._egr_hw_reset_control_1))
#define BCM53324_A0_WRITE_EGR_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_HW_RESET_CONTROL_1r,&(r._egr_hw_reset_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_HW_RESET_CONTROL_1r BCM53324_A0_EGR_HW_RESET_CONTROL_1r
#define EGR_HW_RESET_CONTROL_1r_SIZE BCM53324_A0_EGR_HW_RESET_CONTROL_1r_SIZE
typedef BCM53324_A0_EGR_HW_RESET_CONTROL_1r_t EGR_HW_RESET_CONTROL_1r_t;
#define EGR_HW_RESET_CONTROL_1r_CLR BCM53324_A0_EGR_HW_RESET_CONTROL_1r_CLR
#define EGR_HW_RESET_CONTROL_1r_SET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_SET
#define EGR_HW_RESET_CONTROL_1r_GET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_GET
#define EGR_HW_RESET_CONTROL_1r_COUNTf_GET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_GET
#define EGR_HW_RESET_CONTROL_1r_COUNTf_SET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_SET
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET
#define EGR_HW_RESET_CONTROL_1r_VALIDf_GET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_GET
#define EGR_HW_RESET_CONTROL_1r_VALIDf_SET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_SET
#define EGR_HW_RESET_CONTROL_1r_DONEf_GET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_DONEf_GET
#define EGR_HW_RESET_CONTROL_1r_DONEf_SET BCM53324_A0_EGR_HW_RESET_CONTROL_1r_DONEf_SET
#define READ_EGR_HW_RESET_CONTROL_1r BCM53324_A0_READ_EGR_HW_RESET_CONTROL_1r
#define WRITE_EGR_HW_RESET_CONTROL_1r BCM53324_A0_WRITE_EGR_HW_RESET_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_HW_RESET_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_L3_INTF
 * BLOCKS:   EPIPE
 * DESC:     L3 Interface Table;Indexed by INTF_NUM got from next_hop_table in case of L3 Unicast or IPMC_INTF_NUM on PBE in case of L3 Multicast
 * SIZE:     72
 * FIELDS:
 *     TUNNEL_INDEX     Tunnel Index to be used to index EGR_IP_TUNNEL table.
 *     L2_SWITCH        Indicates if the packet needs to be only L2 Switched and only L2 modifications needs to be done.
 *     VID              VID to be used for L3 replacement
 *     MAC_ADDRESS      MAC Address to be used for SA Replacement in the L3 modifications.
 *     TTL_THRESHOLD    TTL Threshold to be used for L3 TTL checks
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_L3_INTFm 0x03920000

#define BCM53324_A0_EGR_L3_INTFm_MIN 0
#define BCM53324_A0_EGR_L3_INTFm_MAX 15
#define BCM53324_A0_EGR_L3_INTFm_CMAX(u) 15
#define BCM53324_A0_EGR_L3_INTFm_SIZE 9

/*
 * This structure should be used to declare and program EGR_L3_INTF.
 *
 */
typedef union BCM53324_A0_EGR_L3_INTFm_s {
	uint32_t v[3];
	uint32_t egr_l3_intf[3];
	uint32_t _egr_l3_intf;
} BCM53324_A0_EGR_L3_INTFm_t;

#define BCM53324_A0_EGR_L3_INTFm_CLR(r) CDK_MEMSET(&((r)._egr_l3_intf), 0, sizeof(BCM53324_A0_EGR_L3_INTFm_t))
#define BCM53324_A0_EGR_L3_INTFm_SET(r,i,d) (r).egr_l3_intf[i] = d
#define BCM53324_A0_EGR_L3_INTFm_GET(r,i) (r).egr_l3_intf[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_L3_INTFm_TUNNEL_INDEXf_GET(r) (((r).egr_l3_intf[0]) & 0x7)
#define BCM53324_A0_EGR_L3_INTFm_TUNNEL_INDEXf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_EGR_L3_INTFm_L2_SWITCHf_GET(r) ((((r).egr_l3_intf[0]) >> 3) & 0x1)
#define BCM53324_A0_EGR_L3_INTFm_L2_SWITCHf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_EGR_L3_INTFm_VIDf_GET(r) ((((r).egr_l3_intf[0]) >> 4) & 0xfff)
#define BCM53324_A0_EGR_L3_INTFm_VIDf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM53324_A0_EGR_L3_INTFm_MAC_ADDRESSf_GET(r,a) cdk_field_get((r).egr_l3_intf,16,63,a)
#define BCM53324_A0_EGR_L3_INTFm_MAC_ADDRESSf_SET(r,a) cdk_field_set((r).egr_l3_intf,16,63,a)
#define BCM53324_A0_EGR_L3_INTFm_TTL_THRESHOLDf_GET(r) (((r).egr_l3_intf[2]) & 0xff)
#define BCM53324_A0_EGR_L3_INTFm_TTL_THRESHOLDf_SET(r,f) (r).egr_l3_intf[2]=(((r).egr_l3_intf[2] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access EGR_L3_INTF.
 *
 */
#define BCM53324_A0_READ_EGR_L3_INTFm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_L3_INTFm,i,(m._egr_l3_intf),3)
#define BCM53324_A0_WRITE_EGR_L3_INTFm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_L3_INTFm,i,&(m._egr_l3_intf),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_INTFm BCM53324_A0_EGR_L3_INTFm
#define EGR_L3_INTFm_MIN BCM53324_A0_EGR_L3_INTFm_MIN
#define EGR_L3_INTFm_MAX BCM53324_A0_EGR_L3_INTFm_MAX
#define EGR_L3_INTFm_CMAX(u) BCM53324_A0_EGR_L3_INTFm_CMAX(u)
#define EGR_L3_INTFm_SIZE BCM53324_A0_EGR_L3_INTFm_SIZE
typedef BCM53324_A0_EGR_L3_INTFm_t EGR_L3_INTFm_t;
#define EGR_L3_INTFm_CLR BCM53324_A0_EGR_L3_INTFm_CLR
#define EGR_L3_INTFm_SET BCM53324_A0_EGR_L3_INTFm_SET
#define EGR_L3_INTFm_GET BCM53324_A0_EGR_L3_INTFm_GET
#define EGR_L3_INTFm_TUNNEL_INDEXf_GET BCM53324_A0_EGR_L3_INTFm_TUNNEL_INDEXf_GET
#define EGR_L3_INTFm_TUNNEL_INDEXf_SET BCM53324_A0_EGR_L3_INTFm_TUNNEL_INDEXf_SET
#define EGR_L3_INTFm_L2_SWITCHf_GET BCM53324_A0_EGR_L3_INTFm_L2_SWITCHf_GET
#define EGR_L3_INTFm_L2_SWITCHf_SET BCM53324_A0_EGR_L3_INTFm_L2_SWITCHf_SET
#define EGR_L3_INTFm_VIDf_GET BCM53324_A0_EGR_L3_INTFm_VIDf_GET
#define EGR_L3_INTFm_VIDf_SET BCM53324_A0_EGR_L3_INTFm_VIDf_SET
#define EGR_L3_INTFm_MAC_ADDRESSf_GET BCM53324_A0_EGR_L3_INTFm_MAC_ADDRESSf_GET
#define EGR_L3_INTFm_MAC_ADDRESSf_SET BCM53324_A0_EGR_L3_INTFm_MAC_ADDRESSf_SET
#define EGR_L3_INTFm_TTL_THRESHOLDf_GET BCM53324_A0_EGR_L3_INTFm_TTL_THRESHOLDf_GET
#define EGR_L3_INTFm_TTL_THRESHOLDf_SET BCM53324_A0_EGR_L3_INTFm_TTL_THRESHOLDf_SET
#define READ_EGR_L3_INTFm BCM53324_A0_READ_EGR_L3_INTFm
#define WRITE_EGR_L3_INTFm BCM53324_A0_WRITE_EGR_L3_INTFm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_L3_INTFm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_L3_NEXT_HOP
 * BLOCKS:   EPIPE
 * DESC:     Next Hop Table; Indexed by NHOP_INDEX coming from PBE bus
 * SIZE:     60
 * FIELDS:
 *     INTF_NUM         Interface Number to be used as index for L3_INTF table if a pkt is L3 routed.In case FP indicates change_vid and pkt is NOT l3 routed, this field will give new vid.
 *     MAC_ADDRESS      Mac Address to be used for DA replacement by L3UC or FP modified packets.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_L3_NEXT_HOPm 0x03910000

#define BCM53324_A0_EGR_L3_NEXT_HOPm_MIN 0
#define BCM53324_A0_EGR_L3_NEXT_HOPm_MAX 15
#define BCM53324_A0_EGR_L3_NEXT_HOPm_CMAX(u) 15
#define BCM53324_A0_EGR_L3_NEXT_HOPm_SIZE 8

/*
 * This structure should be used to declare and program EGR_L3_NEXT_HOP.
 *
 */
typedef union BCM53324_A0_EGR_L3_NEXT_HOPm_s {
	uint32_t v[2];
	uint32_t egr_l3_next_hop[2];
	uint32_t _egr_l3_next_hop;
} BCM53324_A0_EGR_L3_NEXT_HOPm_t;

#define BCM53324_A0_EGR_L3_NEXT_HOPm_CLR(r) CDK_MEMSET(&((r)._egr_l3_next_hop), 0, sizeof(BCM53324_A0_EGR_L3_NEXT_HOPm_t))
#define BCM53324_A0_EGR_L3_NEXT_HOPm_SET(r,i,d) (r).egr_l3_next_hop[i] = d
#define BCM53324_A0_EGR_L3_NEXT_HOPm_GET(r,i) (r).egr_l3_next_hop[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_GET(r) (((r).egr_l3_next_hop[0]) & 0xfff)
#define BCM53324_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_SET(r,f) (r).egr_l3_next_hop[0]=(((r).egr_l3_next_hop[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET(r,a) cdk_field_get((r).egr_l3_next_hop,12,59,a)
#define BCM53324_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET(r,a) cdk_field_set((r).egr_l3_next_hop,12,59,a)

/*
 * These macros can be used to access EGR_L3_NEXT_HOP.
 *
 */
#define BCM53324_A0_READ_EGR_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_L3_NEXT_HOPm,i,(m._egr_l3_next_hop),2)
#define BCM53324_A0_WRITE_EGR_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_L3_NEXT_HOPm,i,&(m._egr_l3_next_hop),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_NEXT_HOPm BCM53324_A0_EGR_L3_NEXT_HOPm
#define EGR_L3_NEXT_HOPm_MIN BCM53324_A0_EGR_L3_NEXT_HOPm_MIN
#define EGR_L3_NEXT_HOPm_MAX BCM53324_A0_EGR_L3_NEXT_HOPm_MAX
#define EGR_L3_NEXT_HOPm_CMAX(u) BCM53324_A0_EGR_L3_NEXT_HOPm_CMAX(u)
#define EGR_L3_NEXT_HOPm_SIZE BCM53324_A0_EGR_L3_NEXT_HOPm_SIZE
typedef BCM53324_A0_EGR_L3_NEXT_HOPm_t EGR_L3_NEXT_HOPm_t;
#define EGR_L3_NEXT_HOPm_CLR BCM53324_A0_EGR_L3_NEXT_HOPm_CLR
#define EGR_L3_NEXT_HOPm_SET BCM53324_A0_EGR_L3_NEXT_HOPm_SET
#define EGR_L3_NEXT_HOPm_GET BCM53324_A0_EGR_L3_NEXT_HOPm_GET
#define EGR_L3_NEXT_HOPm_INTF_NUMf_GET BCM53324_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_GET
#define EGR_L3_NEXT_HOPm_INTF_NUMf_SET BCM53324_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_SET
#define EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET BCM53324_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET
#define EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET BCM53324_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET
#define READ_EGR_L3_NEXT_HOPm BCM53324_A0_READ_EGR_L3_NEXT_HOPm
#define WRITE_EGR_L3_NEXT_HOPm BCM53324_A0_WRITE_EGR_L3_NEXT_HOPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_L3_NEXT_HOPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_MASK
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table. Table index is (modid,port_tgid)
 * SIZE:     25
 * FIELDS:
 *     EGRESS_MASK      Egress mask block mask for source port
 *     EGRESS_MASK_LO   Egress mask block mask for source port
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_MASKm 0x0f700000

#define BCM53324_A0_EGR_MASKm_MIN 0
#define BCM53324_A0_EGR_MASKm_MAX 63
#define BCM53324_A0_EGR_MASKm_CMAX(u) 63
#define BCM53324_A0_EGR_MASKm_SIZE 4

/*
 * This structure should be used to declare and program EGR_MASK.
 *
 */
typedef union BCM53324_A0_EGR_MASKm_s {
	uint32_t v[1];
	uint32_t egr_mask[1];
	uint32_t _egr_mask;
} BCM53324_A0_EGR_MASKm_t;

#define BCM53324_A0_EGR_MASKm_CLR(r) (r).egr_mask[0] = 0
#define BCM53324_A0_EGR_MASKm_SET(r,d) (r).egr_mask[0] = d
#define BCM53324_A0_EGR_MASKm_GET(r) (r).egr_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_MASKm_EGRESS_MASKf_GET(r) (((r).egr_mask[0]) & 0x1ffffff)
#define BCM53324_A0_EGR_MASKm_EGRESS_MASKf_SET(r,f) (r).egr_mask[0]=(((r).egr_mask[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_EGR_MASKm_EGRESS_MASK_LOf_GET(r) (((r).egr_mask[0]) & 0x1ffffff)
#define BCM53324_A0_EGR_MASKm_EGRESS_MASK_LOf_SET(r,f) (r).egr_mask[0]=(((r).egr_mask[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access EGR_MASK.
 *
 */
#define BCM53324_A0_READ_EGR_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_MASKm,i,(m._egr_mask),1)
#define BCM53324_A0_WRITE_EGR_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_MASKm,i,&(m._egr_mask),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MASKm BCM53324_A0_EGR_MASKm
#define EGR_MASKm_MIN BCM53324_A0_EGR_MASKm_MIN
#define EGR_MASKm_MAX BCM53324_A0_EGR_MASKm_MAX
#define EGR_MASKm_CMAX(u) BCM53324_A0_EGR_MASKm_CMAX(u)
#define EGR_MASKm_SIZE BCM53324_A0_EGR_MASKm_SIZE
typedef BCM53324_A0_EGR_MASKm_t EGR_MASKm_t;
#define EGR_MASKm_CLR BCM53324_A0_EGR_MASKm_CLR
#define EGR_MASKm_SET BCM53324_A0_EGR_MASKm_SET
#define EGR_MASKm_GET BCM53324_A0_EGR_MASKm_GET
#define EGR_MASKm_EGRESS_MASKf_GET BCM53324_A0_EGR_MASKm_EGRESS_MASKf_GET
#define EGR_MASKm_EGRESS_MASKf_SET BCM53324_A0_EGR_MASKm_EGRESS_MASKf_SET
#define EGR_MASKm_EGRESS_MASK_LOf_GET BCM53324_A0_EGR_MASKm_EGRESS_MASK_LOf_GET
#define EGR_MASKm_EGRESS_MASK_LOf_SET BCM53324_A0_EGR_MASKm_EGRESS_MASK_LOf_SET
#define READ_EGR_MASKm BCM53324_A0_READ_EGR_MASKm
#define WRITE_EGR_MASKm BCM53324_A0_WRITE_EGR_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_MMU_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This register contains the cell requests asserted by TP for individual ports to MMU.
Meaning of cell request is 1024 bits data. All it shows is the number of times cell_request signal
was asserted by TP to MMU for each port. 

 * SIZE:     32
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_MMU_REQUESTSr 0x0a900102

#define BCM53324_A0_EGR_MMU_REQUESTSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MMU_REQUESTS.
 *
 */
typedef union BCM53324_A0_EGR_MMU_REQUESTSr_s {
	uint32_t v[1];
	uint32_t egr_mmu_requests[1];
	uint32_t _egr_mmu_requests;
} BCM53324_A0_EGR_MMU_REQUESTSr_t;

#define BCM53324_A0_EGR_MMU_REQUESTSr_CLR(r) (r).egr_mmu_requests[0] = 0
#define BCM53324_A0_EGR_MMU_REQUESTSr_SET(r,d) (r).egr_mmu_requests[0] = d
#define BCM53324_A0_EGR_MMU_REQUESTSr_GET(r) (r).egr_mmu_requests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_mmu_requests[0]) & 0xf)
#define BCM53324_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_mmu_requests[0]=(((r).egr_mmu_requests[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGR_MMU_REQUESTS.
 *
 */
#define BCM53324_A0_READ_EGR_MMU_REQUESTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_MMU_REQUESTSr,(r._egr_mmu_requests))
#define BCM53324_A0_WRITE_EGR_MMU_REQUESTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_MMU_REQUESTSr,&(r._egr_mmu_requests))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MMU_REQUESTSr BCM53324_A0_EGR_MMU_REQUESTSr
#define EGR_MMU_REQUESTSr_SIZE BCM53324_A0_EGR_MMU_REQUESTSr_SIZE
typedef BCM53324_A0_EGR_MMU_REQUESTSr_t EGR_MMU_REQUESTSr_t;
#define EGR_MMU_REQUESTSr_CLR BCM53324_A0_EGR_MMU_REQUESTSr_CLR
#define EGR_MMU_REQUESTSr_SET BCM53324_A0_EGR_MMU_REQUESTSr_SET
#define EGR_MMU_REQUESTSr_GET BCM53324_A0_EGR_MMU_REQUESTSr_GET
#define EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET BCM53324_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET
#define EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET BCM53324_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET
#define READ_EGR_MMU_REQUESTSr BCM53324_A0_READ_EGR_MMU_REQUESTSr
#define WRITE_EGR_MMU_REQUESTSr BCM53324_A0_WRITE_EGR_MMU_REQUESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_MMU_REQUESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_MTU_SIZE
 * BLOCKS:   IPIPE
 * DESC:     Egress MTU Size Register
 * SIZE:     32
 * FIELDS:
 *     MTU_SIZE         Egress ports MTU limit
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_MTU_SIZEr 0x0f700124

#define BCM53324_A0_EGR_MTU_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MTU_SIZE.
 *
 */
typedef union BCM53324_A0_EGR_MTU_SIZEr_s {
	uint32_t v[1];
	uint32_t egr_mtu_size[1];
	uint32_t _egr_mtu_size;
} BCM53324_A0_EGR_MTU_SIZEr_t;

#define BCM53324_A0_EGR_MTU_SIZEr_CLR(r) (r).egr_mtu_size[0] = 0
#define BCM53324_A0_EGR_MTU_SIZEr_SET(r,d) (r).egr_mtu_size[0] = d
#define BCM53324_A0_EGR_MTU_SIZEr_GET(r) (r).egr_mtu_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_MTU_SIZEr_MTU_SIZEf_GET(r) (((r).egr_mtu_size[0]) & 0x3fff)
#define BCM53324_A0_EGR_MTU_SIZEr_MTU_SIZEf_SET(r,f) (r).egr_mtu_size[0]=(((r).egr_mtu_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access EGR_MTU_SIZE.
 *
 */
#define BCM53324_A0_READ_EGR_MTU_SIZEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_MTU_SIZEr,(r._egr_mtu_size))
#define BCM53324_A0_WRITE_EGR_MTU_SIZEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_MTU_SIZEr,&(r._egr_mtu_size))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MTU_SIZEr BCM53324_A0_EGR_MTU_SIZEr
#define EGR_MTU_SIZEr_SIZE BCM53324_A0_EGR_MTU_SIZEr_SIZE
typedef BCM53324_A0_EGR_MTU_SIZEr_t EGR_MTU_SIZEr_t;
#define EGR_MTU_SIZEr_CLR BCM53324_A0_EGR_MTU_SIZEr_CLR
#define EGR_MTU_SIZEr_SET BCM53324_A0_EGR_MTU_SIZEr_SET
#define EGR_MTU_SIZEr_GET BCM53324_A0_EGR_MTU_SIZEr_GET
#define EGR_MTU_SIZEr_MTU_SIZEf_GET BCM53324_A0_EGR_MTU_SIZEr_MTU_SIZEf_GET
#define EGR_MTU_SIZEr_MTU_SIZEf_SET BCM53324_A0_EGR_MTU_SIZEr_MTU_SIZEf_SET
#define READ_EGR_MTU_SIZEr BCM53324_A0_READ_EGR_MTU_SIZEr
#define WRITE_EGR_MTU_SIZEr BCM53324_A0_WRITE_EGR_MTU_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_MTU_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_OUTER_TPID
 * BLOCKS:   EPIPE
 * DESC:     Egress Outer TPID register
 * SIZE:     32
 * FIELDS:
 *     TPID             Egress outer TPID field
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_OUTER_TPIDr 0x04980000

#define BCM53324_A0_EGR_OUTER_TPIDr_SIZE 4

/*
 * This structure should be used to declare and program EGR_OUTER_TPID.
 *
 */
typedef union BCM53324_A0_EGR_OUTER_TPIDr_s {
	uint32_t v[1];
	uint32_t egr_outer_tpid[1];
	uint32_t _egr_outer_tpid;
} BCM53324_A0_EGR_OUTER_TPIDr_t;

#define BCM53324_A0_EGR_OUTER_TPIDr_CLR(r) (r).egr_outer_tpid[0] = 0
#define BCM53324_A0_EGR_OUTER_TPIDr_SET(r,d) (r).egr_outer_tpid[0] = d
#define BCM53324_A0_EGR_OUTER_TPIDr_GET(r) (r).egr_outer_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_OUTER_TPIDr_TPIDf_GET(r) (((r).egr_outer_tpid[0]) & 0xffff)
#define BCM53324_A0_EGR_OUTER_TPIDr_TPIDf_SET(r,f) (r).egr_outer_tpid[0]=(((r).egr_outer_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_OUTER_TPID.
 *
 */
#define BCM53324_A0_READ_EGR_OUTER_TPIDr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_OUTER_TPIDr+(i),(r._egr_outer_tpid))
#define BCM53324_A0_WRITE_EGR_OUTER_TPIDr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_OUTER_TPIDr+(i),&(r._egr_outer_tpid))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_OUTER_TPIDr BCM53324_A0_EGR_OUTER_TPIDr
#define EGR_OUTER_TPIDr_SIZE BCM53324_A0_EGR_OUTER_TPIDr_SIZE
typedef BCM53324_A0_EGR_OUTER_TPIDr_t EGR_OUTER_TPIDr_t;
#define EGR_OUTER_TPIDr_CLR BCM53324_A0_EGR_OUTER_TPIDr_CLR
#define EGR_OUTER_TPIDr_SET BCM53324_A0_EGR_OUTER_TPIDr_SET
#define EGR_OUTER_TPIDr_GET BCM53324_A0_EGR_OUTER_TPIDr_GET
#define EGR_OUTER_TPIDr_TPIDf_GET BCM53324_A0_EGR_OUTER_TPIDr_TPIDf_GET
#define EGR_OUTER_TPIDr_TPIDf_SET BCM53324_A0_EGR_OUTER_TPIDr_TPIDf_SET
#define READ_EGR_OUTER_TPIDr BCM53324_A0_READ_EGR_OUTER_TPIDr
#define WRITE_EGR_OUTER_TPIDr BCM53324_A0_WRITE_EGR_OUTER_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_OUTER_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_OUTER_TPID_0
 * BLOCKS:   EPIPE
 * DESC:     Egress outer TPID register #0
 * SIZE:     32
 * FIELDS:
 *     TPID             Outer TPID field
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_OUTER_TPID_0r 0x04980000

#define BCM53324_A0_EGR_OUTER_TPID_0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_OUTER_TPID_0.
 *
 */
typedef union BCM53324_A0_EGR_OUTER_TPID_0r_s {
	uint32_t v[1];
	uint32_t egr_outer_tpid_0[1];
	uint32_t _egr_outer_tpid_0;
} BCM53324_A0_EGR_OUTER_TPID_0r_t;

#define BCM53324_A0_EGR_OUTER_TPID_0r_CLR(r) (r).egr_outer_tpid_0[0] = 0
#define BCM53324_A0_EGR_OUTER_TPID_0r_SET(r,d) (r).egr_outer_tpid_0[0] = d
#define BCM53324_A0_EGR_OUTER_TPID_0r_GET(r) (r).egr_outer_tpid_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_OUTER_TPID_0r_TPIDf_GET(r) (((r).egr_outer_tpid_0[0]) & 0xffff)
#define BCM53324_A0_EGR_OUTER_TPID_0r_TPIDf_SET(r,f) (r).egr_outer_tpid_0[0]=(((r).egr_outer_tpid_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_OUTER_TPID_0.
 *
 */
#define BCM53324_A0_READ_EGR_OUTER_TPID_0r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_OUTER_TPID_0r,(r._egr_outer_tpid_0))
#define BCM53324_A0_WRITE_EGR_OUTER_TPID_0r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_OUTER_TPID_0r,&(r._egr_outer_tpid_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_OUTER_TPID_0r BCM53324_A0_EGR_OUTER_TPID_0r
#define EGR_OUTER_TPID_0r_SIZE BCM53324_A0_EGR_OUTER_TPID_0r_SIZE
typedef BCM53324_A0_EGR_OUTER_TPID_0r_t EGR_OUTER_TPID_0r_t;
#define EGR_OUTER_TPID_0r_CLR BCM53324_A0_EGR_OUTER_TPID_0r_CLR
#define EGR_OUTER_TPID_0r_SET BCM53324_A0_EGR_OUTER_TPID_0r_SET
#define EGR_OUTER_TPID_0r_GET BCM53324_A0_EGR_OUTER_TPID_0r_GET
#define EGR_OUTER_TPID_0r_TPIDf_GET BCM53324_A0_EGR_OUTER_TPID_0r_TPIDf_GET
#define EGR_OUTER_TPID_0r_TPIDf_SET BCM53324_A0_EGR_OUTER_TPID_0r_TPIDf_SET
#define READ_EGR_OUTER_TPID_0r BCM53324_A0_READ_EGR_OUTER_TPID_0r
#define WRITE_EGR_OUTER_TPID_0r BCM53324_A0_WRITE_EGR_OUTER_TPID_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_OUTER_TPID_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_OUTER_TPID_1
 * BLOCKS:   EPIPE
 * DESC:     Egress outer TPID register #1
 * SIZE:     32
 * FIELDS:
 *     TPID             Outer TPID field
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_OUTER_TPID_1r 0x04980001

#define BCM53324_A0_EGR_OUTER_TPID_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_OUTER_TPID_1.
 *
 */
typedef union BCM53324_A0_EGR_OUTER_TPID_1r_s {
	uint32_t v[1];
	uint32_t egr_outer_tpid_1[1];
	uint32_t _egr_outer_tpid_1;
} BCM53324_A0_EGR_OUTER_TPID_1r_t;

#define BCM53324_A0_EGR_OUTER_TPID_1r_CLR(r) (r).egr_outer_tpid_1[0] = 0
#define BCM53324_A0_EGR_OUTER_TPID_1r_SET(r,d) (r).egr_outer_tpid_1[0] = d
#define BCM53324_A0_EGR_OUTER_TPID_1r_GET(r) (r).egr_outer_tpid_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_OUTER_TPID_1r_TPIDf_GET(r) (((r).egr_outer_tpid_1[0]) & 0xffff)
#define BCM53324_A0_EGR_OUTER_TPID_1r_TPIDf_SET(r,f) (r).egr_outer_tpid_1[0]=(((r).egr_outer_tpid_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_OUTER_TPID_1.
 *
 */
#define BCM53324_A0_READ_EGR_OUTER_TPID_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_OUTER_TPID_1r,(r._egr_outer_tpid_1))
#define BCM53324_A0_WRITE_EGR_OUTER_TPID_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_OUTER_TPID_1r,&(r._egr_outer_tpid_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_OUTER_TPID_1r BCM53324_A0_EGR_OUTER_TPID_1r
#define EGR_OUTER_TPID_1r_SIZE BCM53324_A0_EGR_OUTER_TPID_1r_SIZE
typedef BCM53324_A0_EGR_OUTER_TPID_1r_t EGR_OUTER_TPID_1r_t;
#define EGR_OUTER_TPID_1r_CLR BCM53324_A0_EGR_OUTER_TPID_1r_CLR
#define EGR_OUTER_TPID_1r_SET BCM53324_A0_EGR_OUTER_TPID_1r_SET
#define EGR_OUTER_TPID_1r_GET BCM53324_A0_EGR_OUTER_TPID_1r_GET
#define EGR_OUTER_TPID_1r_TPIDf_GET BCM53324_A0_EGR_OUTER_TPID_1r_TPIDf_GET
#define EGR_OUTER_TPID_1r_TPIDf_SET BCM53324_A0_EGR_OUTER_TPID_1r_TPIDf_SET
#define READ_EGR_OUTER_TPID_1r BCM53324_A0_READ_EGR_OUTER_TPID_1r
#define WRITE_EGR_OUTER_TPID_1r BCM53324_A0_WRITE_EGR_OUTER_TPID_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_OUTER_TPID_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_OUTER_TPID_2
 * BLOCKS:   EPIPE
 * DESC:     Egress outer TPID register #2
 * SIZE:     32
 * FIELDS:
 *     TPID             Outer TPID field
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_OUTER_TPID_2r 0x04980002

#define BCM53324_A0_EGR_OUTER_TPID_2r_SIZE 4

/*
 * This structure should be used to declare and program EGR_OUTER_TPID_2.
 *
 */
typedef union BCM53324_A0_EGR_OUTER_TPID_2r_s {
	uint32_t v[1];
	uint32_t egr_outer_tpid_2[1];
	uint32_t _egr_outer_tpid_2;
} BCM53324_A0_EGR_OUTER_TPID_2r_t;

#define BCM53324_A0_EGR_OUTER_TPID_2r_CLR(r) (r).egr_outer_tpid_2[0] = 0
#define BCM53324_A0_EGR_OUTER_TPID_2r_SET(r,d) (r).egr_outer_tpid_2[0] = d
#define BCM53324_A0_EGR_OUTER_TPID_2r_GET(r) (r).egr_outer_tpid_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_OUTER_TPID_2r_TPIDf_GET(r) (((r).egr_outer_tpid_2[0]) & 0xffff)
#define BCM53324_A0_EGR_OUTER_TPID_2r_TPIDf_SET(r,f) (r).egr_outer_tpid_2[0]=(((r).egr_outer_tpid_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_OUTER_TPID_2.
 *
 */
#define BCM53324_A0_READ_EGR_OUTER_TPID_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_OUTER_TPID_2r,(r._egr_outer_tpid_2))
#define BCM53324_A0_WRITE_EGR_OUTER_TPID_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_OUTER_TPID_2r,&(r._egr_outer_tpid_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_OUTER_TPID_2r BCM53324_A0_EGR_OUTER_TPID_2r
#define EGR_OUTER_TPID_2r_SIZE BCM53324_A0_EGR_OUTER_TPID_2r_SIZE
typedef BCM53324_A0_EGR_OUTER_TPID_2r_t EGR_OUTER_TPID_2r_t;
#define EGR_OUTER_TPID_2r_CLR BCM53324_A0_EGR_OUTER_TPID_2r_CLR
#define EGR_OUTER_TPID_2r_SET BCM53324_A0_EGR_OUTER_TPID_2r_SET
#define EGR_OUTER_TPID_2r_GET BCM53324_A0_EGR_OUTER_TPID_2r_GET
#define EGR_OUTER_TPID_2r_TPIDf_GET BCM53324_A0_EGR_OUTER_TPID_2r_TPIDf_GET
#define EGR_OUTER_TPID_2r_TPIDf_SET BCM53324_A0_EGR_OUTER_TPID_2r_TPIDf_SET
#define READ_EGR_OUTER_TPID_2r BCM53324_A0_READ_EGR_OUTER_TPID_2r
#define WRITE_EGR_OUTER_TPID_2r BCM53324_A0_WRITE_EGR_OUTER_TPID_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_OUTER_TPID_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_OUTER_TPID_3
 * BLOCKS:   EPIPE
 * DESC:     Egress outer TPID register #3
 * SIZE:     32
 * FIELDS:
 *     TPID             Outer TPID field
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_OUTER_TPID_3r 0x04980003

#define BCM53324_A0_EGR_OUTER_TPID_3r_SIZE 4

/*
 * This structure should be used to declare and program EGR_OUTER_TPID_3.
 *
 */
typedef union BCM53324_A0_EGR_OUTER_TPID_3r_s {
	uint32_t v[1];
	uint32_t egr_outer_tpid_3[1];
	uint32_t _egr_outer_tpid_3;
} BCM53324_A0_EGR_OUTER_TPID_3r_t;

#define BCM53324_A0_EGR_OUTER_TPID_3r_CLR(r) (r).egr_outer_tpid_3[0] = 0
#define BCM53324_A0_EGR_OUTER_TPID_3r_SET(r,d) (r).egr_outer_tpid_3[0] = d
#define BCM53324_A0_EGR_OUTER_TPID_3r_GET(r) (r).egr_outer_tpid_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_OUTER_TPID_3r_TPIDf_GET(r) (((r).egr_outer_tpid_3[0]) & 0xffff)
#define BCM53324_A0_EGR_OUTER_TPID_3r_TPIDf_SET(r,f) (r).egr_outer_tpid_3[0]=(((r).egr_outer_tpid_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_OUTER_TPID_3.
 *
 */
#define BCM53324_A0_READ_EGR_OUTER_TPID_3r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_OUTER_TPID_3r,(r._egr_outer_tpid_3))
#define BCM53324_A0_WRITE_EGR_OUTER_TPID_3r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_OUTER_TPID_3r,&(r._egr_outer_tpid_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_OUTER_TPID_3r BCM53324_A0_EGR_OUTER_TPID_3r
#define EGR_OUTER_TPID_3r_SIZE BCM53324_A0_EGR_OUTER_TPID_3r_SIZE
typedef BCM53324_A0_EGR_OUTER_TPID_3r_t EGR_OUTER_TPID_3r_t;
#define EGR_OUTER_TPID_3r_CLR BCM53324_A0_EGR_OUTER_TPID_3r_CLR
#define EGR_OUTER_TPID_3r_SET BCM53324_A0_EGR_OUTER_TPID_3r_SET
#define EGR_OUTER_TPID_3r_GET BCM53324_A0_EGR_OUTER_TPID_3r_GET
#define EGR_OUTER_TPID_3r_TPIDf_GET BCM53324_A0_EGR_OUTER_TPID_3r_TPIDf_GET
#define EGR_OUTER_TPID_3r_TPIDf_SET BCM53324_A0_EGR_OUTER_TPID_3r_TPIDf_SET
#define READ_EGR_OUTER_TPID_3r BCM53324_A0_READ_EGR_OUTER_TPID_3r
#define WRITE_EGR_OUTER_TPID_3r BCM53324_A0_WRITE_EGR_OUTER_TPID_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_OUTER_TPID_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_PORT
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port.


 * SIZE:     32
 * FIELDS:
 *     PORT_TYPE        Specifies the type of the port. Bit[0] of PORT_TYPE field is HIGIG_BIT. If it is set, then the port is in Higig Mode.	0 = GE/10GE/CPU Port.	1 = HIGIG Port.Bit[1] of PORT_TYPE field is NNI_BIT. If it is set, then the port is NNI port, else UNI Port.	0 = UNI Port.	1 = NNI Port.
 *     HIGIG_PACKET     This port is a higig port.
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port.
 *     EN_EFILTER       If this bit is set, the VLAN Membership check is done for the outgoing port.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     CFI              If CFI-CNG mapping is enabled for the chip, i.e. EGR_CONFIG.CFI_AS_CNG bit is set, then thisfield corresponds to the values of CNG coming from MMU. e.g. If MMU.CNG = 0, then Packet.CFI = CFI[0]     If MMU.CNG = 1, then Packet.CFI = CFI[1] and so on.These bits are reserved for RAVEN
 *     EM_SRCMOD_CHANGE Set to change the src_modid for the egress mirrored pkts going out of the higig port.
 *     MY_MODID         Module ID of this chip.
 *     IEEE_802_1AS_ENABLE Time-Sync protocol packets will be processed only when this bit is set.
 *     EAV_CAPABLE      If set it means that PORT is in EAV mode.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_PORTr 0x01900002

#define BCM53324_A0_EGR_PORTr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT.
 *
 */
typedef union BCM53324_A0_EGR_PORTr_s {
	uint32_t v[1];
	uint32_t egr_port[1];
	uint32_t _egr_port;
} BCM53324_A0_EGR_PORTr_t;

#define BCM53324_A0_EGR_PORTr_CLR(r) (r).egr_port[0] = 0
#define BCM53324_A0_EGR_PORTr_SET(r,d) (r).egr_port[0] = d
#define BCM53324_A0_EGR_PORTr_GET(r) (r).egr_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_PORTr_PORT_TYPEf_GET(r) (((r).egr_port[0]) & 0x3)
#define BCM53324_A0_EGR_PORTr_PORT_TYPEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_EGR_PORTr_HIGIG_PACKETf_GET(r) (((r).egr_port[0]) & 0x1)
#define BCM53324_A0_EGR_PORTr_HIGIG_PACKETf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_PORTr_NNI_PORTf_GET(r) ((((r).egr_port[0]) >> 1) & 0x1)
#define BCM53324_A0_EGR_PORTr_NNI_PORTf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_EGR_PORTr_EN_EFILTERf_GET(r) ((((r).egr_port[0]) >> 2) & 0x1)
#define BCM53324_A0_EGR_PORTr_EN_EFILTERf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_EGR_PORTr_PRESERVE_CPU_TAGf_GET(r) ((((r).egr_port[0]) >> 3) & 0x1)
#define BCM53324_A0_EGR_PORTr_PRESERVE_CPU_TAGf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_EGR_PORTr_CFIf_GET(r) ((((r).egr_port[0]) >> 4) & 0xf)
#define BCM53324_A0_EGR_PORTr_CFIf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_GET(r) ((((r).egr_port[0]) >> 8) & 0x1)
#define BCM53324_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_EGR_PORTr_MY_MODIDf_GET(r) ((((r).egr_port[0]) >> 9) & 0xf)
#define BCM53324_A0_EGR_PORTr_MY_MODIDf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53324_A0_EGR_PORTr_IEEE_802_1AS_ENABLEf_GET(r) ((((r).egr_port[0]) >> 13) & 0x1)
#define BCM53324_A0_EGR_PORTr_IEEE_802_1AS_ENABLEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_EGR_PORTr_EAV_CAPABLEf_GET(r) ((((r).egr_port[0]) >> 14) & 0x1)
#define BCM53324_A0_EGR_PORTr_EAV_CAPABLEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access EGR_PORT.
 *
 */
#define BCM53324_A0_READ_EGR_PORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_PORTr,(r._egr_port))
#define BCM53324_A0_WRITE_EGR_PORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_PORTr,&(r._egr_port))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORTr BCM53324_A0_EGR_PORTr
#define EGR_PORTr_SIZE BCM53324_A0_EGR_PORTr_SIZE
typedef BCM53324_A0_EGR_PORTr_t EGR_PORTr_t;
#define EGR_PORTr_CLR BCM53324_A0_EGR_PORTr_CLR
#define EGR_PORTr_SET BCM53324_A0_EGR_PORTr_SET
#define EGR_PORTr_GET BCM53324_A0_EGR_PORTr_GET
#define EGR_PORTr_PORT_TYPEf_GET BCM53324_A0_EGR_PORTr_PORT_TYPEf_GET
#define EGR_PORTr_PORT_TYPEf_SET BCM53324_A0_EGR_PORTr_PORT_TYPEf_SET
#define EGR_PORTr_HIGIG_PACKETf_GET BCM53324_A0_EGR_PORTr_HIGIG_PACKETf_GET
#define EGR_PORTr_HIGIG_PACKETf_SET BCM53324_A0_EGR_PORTr_HIGIG_PACKETf_SET
#define EGR_PORTr_NNI_PORTf_GET BCM53324_A0_EGR_PORTr_NNI_PORTf_GET
#define EGR_PORTr_NNI_PORTf_SET BCM53324_A0_EGR_PORTr_NNI_PORTf_SET
#define EGR_PORTr_EN_EFILTERf_GET BCM53324_A0_EGR_PORTr_EN_EFILTERf_GET
#define EGR_PORTr_EN_EFILTERf_SET BCM53324_A0_EGR_PORTr_EN_EFILTERf_SET
#define EGR_PORTr_PRESERVE_CPU_TAGf_GET BCM53324_A0_EGR_PORTr_PRESERVE_CPU_TAGf_GET
#define EGR_PORTr_PRESERVE_CPU_TAGf_SET BCM53324_A0_EGR_PORTr_PRESERVE_CPU_TAGf_SET
#define EGR_PORTr_CFIf_GET BCM53324_A0_EGR_PORTr_CFIf_GET
#define EGR_PORTr_CFIf_SET BCM53324_A0_EGR_PORTr_CFIf_SET
#define EGR_PORTr_EM_SRCMOD_CHANGEf_GET BCM53324_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_GET
#define EGR_PORTr_EM_SRCMOD_CHANGEf_SET BCM53324_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_SET
#define EGR_PORTr_MY_MODIDf_GET BCM53324_A0_EGR_PORTr_MY_MODIDf_GET
#define EGR_PORTr_MY_MODIDf_SET BCM53324_A0_EGR_PORTr_MY_MODIDf_SET
#define EGR_PORTr_IEEE_802_1AS_ENABLEf_GET BCM53324_A0_EGR_PORTr_IEEE_802_1AS_ENABLEf_GET
#define EGR_PORTr_IEEE_802_1AS_ENABLEf_SET BCM53324_A0_EGR_PORTr_IEEE_802_1AS_ENABLEf_SET
#define EGR_PORTr_EAV_CAPABLEf_GET BCM53324_A0_EGR_PORTr_EAV_CAPABLEf_GET
#define EGR_PORTr_EAV_CAPABLEf_SET BCM53324_A0_EGR_PORTr_EAV_CAPABLEf_SET
#define READ_EGR_PORTr BCM53324_A0_READ_EGR_PORTr
#define WRITE_EGR_PORTr BCM53324_A0_WRITE_EGR_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_PORT_L3UC_MODS
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for IPMC related modifications.


 * SIZE:     32
 * FIELDS:
 *     L3_UC_SA_DISABLE Disable the SA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_DA_DISABLE Disable the DA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_TTL_DISABLE Disable the TTL decrement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_VLAN_DISABLE Disable the outer VID replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_PORT_L3UC_MODSr 0x01900004

#define BCM53324_A0_EGR_PORT_L3UC_MODSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_L3UC_MODS.
 *
 */
typedef union BCM53324_A0_EGR_PORT_L3UC_MODSr_s {
	uint32_t v[1];
	uint32_t egr_port_l3uc_mods[1];
	uint32_t _egr_port_l3uc_mods;
} BCM53324_A0_EGR_PORT_L3UC_MODSr_t;

#define BCM53324_A0_EGR_PORT_L3UC_MODSr_CLR(r) (r).egr_port_l3uc_mods[0] = 0
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_SET(r,d) (r).egr_port_l3uc_mods[0] = d
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_GET(r) (r).egr_port_l3uc_mods[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET(r) (((r).egr_port_l3uc_mods[0]) & 0x1)
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 1) & 0x1)
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 2) & 0x1)
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 3) & 0x1)
#define BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access EGR_PORT_L3UC_MODS.
 *
 */
#define BCM53324_A0_READ_EGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_PORT_L3UC_MODSr,(r._egr_port_l3uc_mods))
#define BCM53324_A0_WRITE_EGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_PORT_L3UC_MODSr,&(r._egr_port_l3uc_mods))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORT_L3UC_MODSr BCM53324_A0_EGR_PORT_L3UC_MODSr
#define EGR_PORT_L3UC_MODSr_SIZE BCM53324_A0_EGR_PORT_L3UC_MODSr_SIZE
typedef BCM53324_A0_EGR_PORT_L3UC_MODSr_t EGR_PORT_L3UC_MODSr_t;
#define EGR_PORT_L3UC_MODSr_CLR BCM53324_A0_EGR_PORT_L3UC_MODSr_CLR
#define EGR_PORT_L3UC_MODSr_SET BCM53324_A0_EGR_PORT_L3UC_MODSr_SET
#define EGR_PORT_L3UC_MODSr_GET BCM53324_A0_EGR_PORT_L3UC_MODSr_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET BCM53324_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET
#define READ_EGR_PORT_L3UC_MODSr BCM53324_A0_READ_EGR_PORT_L3UC_MODSr
#define WRITE_EGR_PORT_L3UC_MODSr BCM53324_A0_WRITE_EGR_PORT_L3UC_MODSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_PORT_L3UC_MODSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_PORT_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This register contains the cell requests asserted by individual ports from GPORT, XPORT, CMIC
blocks. Meaning of cell request is different for different ports, but this register has no
understanding of those meanings. All it shows is the number of times cell_request signal
was asserted by each port to TP. 

 * SIZE:     32
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_PORT_REQUESTSr 0x0a900101

#define BCM53324_A0_EGR_PORT_REQUESTSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_REQUESTS.
 *
 */
typedef union BCM53324_A0_EGR_PORT_REQUESTSr_s {
	uint32_t v[1];
	uint32_t egr_port_requests[1];
	uint32_t _egr_port_requests;
} BCM53324_A0_EGR_PORT_REQUESTSr_t;

#define BCM53324_A0_EGR_PORT_REQUESTSr_CLR(r) (r).egr_port_requests[0] = 0
#define BCM53324_A0_EGR_PORT_REQUESTSr_SET(r,d) (r).egr_port_requests[0] = d
#define BCM53324_A0_EGR_PORT_REQUESTSr_GET(r) (r).egr_port_requests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_port_requests[0]) & 0xf)
#define BCM53324_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_port_requests[0]=(((r).egr_port_requests[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGR_PORT_REQUESTS.
 *
 */
#define BCM53324_A0_READ_EGR_PORT_REQUESTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_PORT_REQUESTSr,(r._egr_port_requests))
#define BCM53324_A0_WRITE_EGR_PORT_REQUESTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_PORT_REQUESTSr,&(r._egr_port_requests))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORT_REQUESTSr BCM53324_A0_EGR_PORT_REQUESTSr
#define EGR_PORT_REQUESTSr_SIZE BCM53324_A0_EGR_PORT_REQUESTSr_SIZE
typedef BCM53324_A0_EGR_PORT_REQUESTSr_t EGR_PORT_REQUESTSr_t;
#define EGR_PORT_REQUESTSr_CLR BCM53324_A0_EGR_PORT_REQUESTSr_CLR
#define EGR_PORT_REQUESTSr_SET BCM53324_A0_EGR_PORT_REQUESTSr_SET
#define EGR_PORT_REQUESTSr_GET BCM53324_A0_EGR_PORT_REQUESTSr_GET
#define EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET BCM53324_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET
#define EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET BCM53324_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET
#define READ_EGR_PORT_REQUESTSr BCM53324_A0_READ_EGR_PORT_REQUESTSr
#define WRITE_EGR_PORT_REQUESTSr BCM53324_A0_WRITE_EGR_PORT_REQUESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_PORT_REQUESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_PRI_CNG_MAP
 * BLOCKS:   EPIPE
 * DESC:     Per port egress priority/CFI mapping table.
We use {pbe.egress_port, pbe.mmu_outer_pri, pbe.cng} to index into this table.

 * SIZE:     4
 * FIELDS:
 *     CFI              Outgoing CFI
 *     PRI              Outgoing Priority
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_PRI_CNG_MAPm 0x05990000

#define BCM53324_A0_EGR_PRI_CNG_MAPm_MIN 0
#define BCM53324_A0_EGR_PRI_CNG_MAPm_MAX 799
#define BCM53324_A0_EGR_PRI_CNG_MAPm_CMAX(u) 799
#define BCM53324_A0_EGR_PRI_CNG_MAPm_SIZE 1

/*
 * This structure should be used to declare and program EGR_PRI_CNG_MAP.
 *
 */
typedef union BCM53324_A0_EGR_PRI_CNG_MAPm_s {
	uint32_t v[1];
	uint32_t egr_pri_cng_map[1];
	uint32_t _egr_pri_cng_map;
} BCM53324_A0_EGR_PRI_CNG_MAPm_t;

#define BCM53324_A0_EGR_PRI_CNG_MAPm_CLR(r) (r).egr_pri_cng_map[0] = 0
#define BCM53324_A0_EGR_PRI_CNG_MAPm_SET(r,d) (r).egr_pri_cng_map[0] = d
#define BCM53324_A0_EGR_PRI_CNG_MAPm_GET(r) (r).egr_pri_cng_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_PRI_CNG_MAPm_CFIf_GET(r) (((r).egr_pri_cng_map[0]) & 0x1)
#define BCM53324_A0_EGR_PRI_CNG_MAPm_CFIf_SET(r,f) (r).egr_pri_cng_map[0]=(((r).egr_pri_cng_map[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_PRI_CNG_MAPm_PRIf_GET(r) ((((r).egr_pri_cng_map[0]) >> 1) & 0x7)
#define BCM53324_A0_EGR_PRI_CNG_MAPm_PRIf_SET(r,f) (r).egr_pri_cng_map[0]=(((r).egr_pri_cng_map[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))

/*
 * These macros can be used to access EGR_PRI_CNG_MAP.
 *
 */
#define BCM53324_A0_READ_EGR_PRI_CNG_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_PRI_CNG_MAPm,i,(m._egr_pri_cng_map),1)
#define BCM53324_A0_WRITE_EGR_PRI_CNG_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_PRI_CNG_MAPm,i,&(m._egr_pri_cng_map),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PRI_CNG_MAPm BCM53324_A0_EGR_PRI_CNG_MAPm
#define EGR_PRI_CNG_MAPm_MIN BCM53324_A0_EGR_PRI_CNG_MAPm_MIN
#define EGR_PRI_CNG_MAPm_MAX BCM53324_A0_EGR_PRI_CNG_MAPm_MAX
#define EGR_PRI_CNG_MAPm_CMAX(u) BCM53324_A0_EGR_PRI_CNG_MAPm_CMAX(u)
#define EGR_PRI_CNG_MAPm_SIZE BCM53324_A0_EGR_PRI_CNG_MAPm_SIZE
typedef BCM53324_A0_EGR_PRI_CNG_MAPm_t EGR_PRI_CNG_MAPm_t;
#define EGR_PRI_CNG_MAPm_CLR BCM53324_A0_EGR_PRI_CNG_MAPm_CLR
#define EGR_PRI_CNG_MAPm_SET BCM53324_A0_EGR_PRI_CNG_MAPm_SET
#define EGR_PRI_CNG_MAPm_GET BCM53324_A0_EGR_PRI_CNG_MAPm_GET
#define EGR_PRI_CNG_MAPm_CFIf_GET BCM53324_A0_EGR_PRI_CNG_MAPm_CFIf_GET
#define EGR_PRI_CNG_MAPm_CFIf_SET BCM53324_A0_EGR_PRI_CNG_MAPm_CFIf_SET
#define EGR_PRI_CNG_MAPm_PRIf_GET BCM53324_A0_EGR_PRI_CNG_MAPm_PRIf_GET
#define EGR_PRI_CNG_MAPm_PRIf_SET BCM53324_A0_EGR_PRI_CNG_MAPm_PRIf_SET
#define READ_EGR_PRI_CNG_MAPm BCM53324_A0_READ_EGR_PRI_CNG_MAPm
#define WRITE_EGR_PRI_CNG_MAPm BCM53324_A0_WRITE_EGR_PRI_CNG_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_PRI_CNG_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_Q_BEGIN
 * BLOCKS:   EPIPE
 * DESC:     Register starts an EQ Bus which is provided for later ECO reasons, if any.

 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_Q_BEGINr 0x00980002

#define BCM53324_A0_EGR_Q_BEGINr_SIZE 4

/*
 * This structure should be used to declare and program EGR_Q_BEGIN.
 *
 */
typedef union BCM53324_A0_EGR_Q_BEGINr_s {
	uint32_t v[1];
	uint32_t egr_q_begin[1];
	uint32_t _egr_q_begin;
} BCM53324_A0_EGR_Q_BEGINr_t;

#define BCM53324_A0_EGR_Q_BEGINr_CLR(r) (r).egr_q_begin[0] = 0
#define BCM53324_A0_EGR_Q_BEGINr_SET(r,d) (r).egr_q_begin[0] = d
#define BCM53324_A0_EGR_Q_BEGINr_GET(r) (r).egr_q_begin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_Q_BEGINr_QBUSf_GET(r) (((r).egr_q_begin[0]) & 0xffff)
#define BCM53324_A0_EGR_Q_BEGINr_QBUSf_SET(r,f) (r).egr_q_begin[0]=(((r).egr_q_begin[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_Q_BEGIN.
 *
 */
#define BCM53324_A0_READ_EGR_Q_BEGINr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_Q_BEGINr,(r._egr_q_begin))
#define BCM53324_A0_WRITE_EGR_Q_BEGINr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_Q_BEGINr,&(r._egr_q_begin))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_Q_BEGINr BCM53324_A0_EGR_Q_BEGINr
#define EGR_Q_BEGINr_SIZE BCM53324_A0_EGR_Q_BEGINr_SIZE
typedef BCM53324_A0_EGR_Q_BEGINr_t EGR_Q_BEGINr_t;
#define EGR_Q_BEGINr_CLR BCM53324_A0_EGR_Q_BEGINr_CLR
#define EGR_Q_BEGINr_SET BCM53324_A0_EGR_Q_BEGINr_SET
#define EGR_Q_BEGINr_GET BCM53324_A0_EGR_Q_BEGINr_GET
#define EGR_Q_BEGINr_QBUSf_GET BCM53324_A0_EGR_Q_BEGINr_QBUSf_GET
#define EGR_Q_BEGINr_QBUSf_SET BCM53324_A0_EGR_Q_BEGINr_QBUSf_SET
#define READ_EGR_Q_BEGINr BCM53324_A0_READ_EGR_Q_BEGINr
#define WRITE_EGR_Q_BEGINr BCM53324_A0_WRITE_EGR_Q_BEGINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_Q_BEGINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_Q_END
 * BLOCKS:   EPIPE
 * DESC:     Register starts an EQ Bus which is provided for later ECO reasons, if any.

 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_Q_ENDr 0x0a980103

#define BCM53324_A0_EGR_Q_ENDr_SIZE 4

/*
 * This structure should be used to declare and program EGR_Q_END.
 *
 */
typedef union BCM53324_A0_EGR_Q_ENDr_s {
	uint32_t v[1];
	uint32_t egr_q_end[1];
	uint32_t _egr_q_end;
} BCM53324_A0_EGR_Q_ENDr_t;

#define BCM53324_A0_EGR_Q_ENDr_CLR(r) (r).egr_q_end[0] = 0
#define BCM53324_A0_EGR_Q_ENDr_SET(r,d) (r).egr_q_end[0] = d
#define BCM53324_A0_EGR_Q_ENDr_GET(r) (r).egr_q_end[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_Q_ENDr_QBUSf_GET(r) (((r).egr_q_end[0]) & 0xffff)
#define BCM53324_A0_EGR_Q_ENDr_QBUSf_SET(r,f) (r).egr_q_end[0]=(((r).egr_q_end[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_Q_END.
 *
 */
#define BCM53324_A0_READ_EGR_Q_ENDr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_Q_ENDr,(r._egr_q_end))
#define BCM53324_A0_WRITE_EGR_Q_ENDr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_Q_ENDr,&(r._egr_q_end))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_Q_ENDr BCM53324_A0_EGR_Q_ENDr
#define EGR_Q_ENDr_SIZE BCM53324_A0_EGR_Q_ENDr_SIZE
typedef BCM53324_A0_EGR_Q_ENDr_t EGR_Q_ENDr_t;
#define EGR_Q_ENDr_CLR BCM53324_A0_EGR_Q_ENDr_CLR
#define EGR_Q_ENDr_SET BCM53324_A0_EGR_Q_ENDr_SET
#define EGR_Q_ENDr_GET BCM53324_A0_EGR_Q_ENDr_GET
#define EGR_Q_ENDr_QBUSf_GET BCM53324_A0_EGR_Q_ENDr_QBUSf_GET
#define EGR_Q_ENDr_QBUSf_SET BCM53324_A0_EGR_Q_ENDr_QBUSf_SET
#define READ_EGR_Q_ENDr BCM53324_A0_READ_EGR_Q_ENDr
#define WRITE_EGR_Q_ENDr BCM53324_A0_WRITE_EGR_Q_ENDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_Q_ENDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_RSPAN_VLAN_TAG
 * BLOCKS:   EPIPE
 * DESC:     For RSPAN feature, the vlan tag is picked up from here.


 * SIZE:     32
 * FIELDS:
 *     TAG              This field contains the entire 4 bytes (32 bits wide) tag to be added to the packet for RSPAN.The way it should be programmed is, 	TAG[31:16] = TPID,Tpid to be used when rspan tag will be added in the packet modifier. 	TAG[15:13] = Priority to be used when rspan tag will be added in the packet modifier. 	TAG[12]    = CFI to be used when rspan tag will be added in the packet modifier. 	TAG[11:0]  = VID to be used when rspan tag will be added in the packet modifier. If TAG is all zero then it means we do not add the rspan tag.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_RSPAN_VLAN_TAGr 0x09900000

#define BCM53324_A0_EGR_RSPAN_VLAN_TAGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_RSPAN_VLAN_TAG.
 *
 */
typedef union BCM53324_A0_EGR_RSPAN_VLAN_TAGr_s {
	uint32_t v[1];
	uint32_t egr_rspan_vlan_tag[1];
	uint32_t _egr_rspan_vlan_tag;
} BCM53324_A0_EGR_RSPAN_VLAN_TAGr_t;

#define BCM53324_A0_EGR_RSPAN_VLAN_TAGr_CLR(r) (r).egr_rspan_vlan_tag[0] = 0
#define BCM53324_A0_EGR_RSPAN_VLAN_TAGr_SET(r,d) (r).egr_rspan_vlan_tag[0] = d
#define BCM53324_A0_EGR_RSPAN_VLAN_TAGr_GET(r) (r).egr_rspan_vlan_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_RSPAN_VLAN_TAGr_TAGf_GET(r) ((r).egr_rspan_vlan_tag[0])
#define BCM53324_A0_EGR_RSPAN_VLAN_TAGr_TAGf_SET(r,f) (r).egr_rspan_vlan_tag[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_RSPAN_VLAN_TAG.
 *
 */
#define BCM53324_A0_READ_EGR_RSPAN_VLAN_TAGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_RSPAN_VLAN_TAGr,(r._egr_rspan_vlan_tag))
#define BCM53324_A0_WRITE_EGR_RSPAN_VLAN_TAGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_RSPAN_VLAN_TAGr,&(r._egr_rspan_vlan_tag))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_RSPAN_VLAN_TAGr BCM53324_A0_EGR_RSPAN_VLAN_TAGr
#define EGR_RSPAN_VLAN_TAGr_SIZE BCM53324_A0_EGR_RSPAN_VLAN_TAGr_SIZE
typedef BCM53324_A0_EGR_RSPAN_VLAN_TAGr_t EGR_RSPAN_VLAN_TAGr_t;
#define EGR_RSPAN_VLAN_TAGr_CLR BCM53324_A0_EGR_RSPAN_VLAN_TAGr_CLR
#define EGR_RSPAN_VLAN_TAGr_SET BCM53324_A0_EGR_RSPAN_VLAN_TAGr_SET
#define EGR_RSPAN_VLAN_TAGr_GET BCM53324_A0_EGR_RSPAN_VLAN_TAGr_GET
#define EGR_RSPAN_VLAN_TAGr_TAGf_GET BCM53324_A0_EGR_RSPAN_VLAN_TAGr_TAGf_GET
#define EGR_RSPAN_VLAN_TAGr_TAGf_SET BCM53324_A0_EGR_RSPAN_VLAN_TAGr_TAGf_SET
#define READ_EGR_RSPAN_VLAN_TAGr BCM53324_A0_READ_EGR_RSPAN_VLAN_TAGr
#define WRITE_EGR_RSPAN_VLAN_TAGr BCM53324_A0_WRITE_EGR_RSPAN_VLAN_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_RSPAN_VLAN_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_SHAPING_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     Specifies control fields Egress for the Shaping Counters.

 * SIZE:     32
 * FIELDS:
 *     PACKET_IFG_BYTES Number of Preamble and IFG bytes to be added in the Shaping counters.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_SHAPING_CONTROLr 0x0a980104

#define BCM53324_A0_EGR_SHAPING_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_SHAPING_CONTROL.
 *
 */
typedef union BCM53324_A0_EGR_SHAPING_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_shaping_control[1];
	uint32_t _egr_shaping_control;
} BCM53324_A0_EGR_SHAPING_CONTROLr_t;

#define BCM53324_A0_EGR_SHAPING_CONTROLr_CLR(r) (r).egr_shaping_control[0] = 0
#define BCM53324_A0_EGR_SHAPING_CONTROLr_SET(r,d) (r).egr_shaping_control[0] = d
#define BCM53324_A0_EGR_SHAPING_CONTROLr_GET(r) (r).egr_shaping_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET(r) (((r).egr_shaping_control[0]) & 0x1f)
#define BCM53324_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET(r,f) (r).egr_shaping_control[0]=(((r).egr_shaping_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access EGR_SHAPING_CONTROL.
 *
 */
#define BCM53324_A0_READ_EGR_SHAPING_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_SHAPING_CONTROLr,(r._egr_shaping_control))
#define BCM53324_A0_WRITE_EGR_SHAPING_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_SHAPING_CONTROLr,&(r._egr_shaping_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_SHAPING_CONTROLr BCM53324_A0_EGR_SHAPING_CONTROLr
#define EGR_SHAPING_CONTROLr_SIZE BCM53324_A0_EGR_SHAPING_CONTROLr_SIZE
typedef BCM53324_A0_EGR_SHAPING_CONTROLr_t EGR_SHAPING_CONTROLr_t;
#define EGR_SHAPING_CONTROLr_CLR BCM53324_A0_EGR_SHAPING_CONTROLr_CLR
#define EGR_SHAPING_CONTROLr_SET BCM53324_A0_EGR_SHAPING_CONTROLr_SET
#define EGR_SHAPING_CONTROLr_GET BCM53324_A0_EGR_SHAPING_CONTROLr_GET
#define EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET BCM53324_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET
#define EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET BCM53324_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET
#define READ_EGR_SHAPING_CONTROLr BCM53324_A0_READ_EGR_SHAPING_CONTROLr
#define WRITE_EGR_SHAPING_CONTROLr BCM53324_A0_WRITE_EGR_SHAPING_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_SHAPING_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_SRC_PORT
 * BLOCKS:   EPIPE
 * DESC:     Per egress port register for QinQ functionality.


 * SIZE:     32
 * FIELDS:
 *     ADD_INNER_TAG    Add inner tag to the untagged packet (0 => do not add, 1 => add).
 *     INNER_TAG        The inner tag (pri, cfi, vid) to be added if ADD_INNER_TAG=1
 *     OUTER_TPID_ENABLE Enables for marking the 4 EGR_OUTER_TPID values as an allowed outer TPID.Bit 0 of the field is associated with EGR_OUTER_TPID[0], and so on.If a bit is set, the corresponding EGR_OUTER_TPID value is allowedas a valid outer TPID, else it is not allowed.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_SRC_PORTr 0x06900002

#define BCM53324_A0_EGR_SRC_PORTr_SIZE 4

/*
 * This structure should be used to declare and program EGR_SRC_PORT.
 *
 */
typedef union BCM53324_A0_EGR_SRC_PORTr_s {
	uint32_t v[1];
	uint32_t egr_src_port[1];
	uint32_t _egr_src_port;
} BCM53324_A0_EGR_SRC_PORTr_t;

#define BCM53324_A0_EGR_SRC_PORTr_CLR(r) (r).egr_src_port[0] = 0
#define BCM53324_A0_EGR_SRC_PORTr_SET(r,d) (r).egr_src_port[0] = d
#define BCM53324_A0_EGR_SRC_PORTr_GET(r) (r).egr_src_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_SRC_PORTr_ADD_INNER_TAGf_GET(r) (((r).egr_src_port[0]) & 0x1)
#define BCM53324_A0_EGR_SRC_PORTr_ADD_INNER_TAGf_SET(r,f) (r).egr_src_port[0]=(((r).egr_src_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_SRC_PORTr_INNER_TAGf_GET(r) ((((r).egr_src_port[0]) >> 1) & 0xffff)
#define BCM53324_A0_EGR_SRC_PORTr_INNER_TAGf_SET(r,f) (r).egr_src_port[0]=(((r).egr_src_port[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_EGR_SRC_PORTr_OUTER_TPID_ENABLEf_GET(r) ((((r).egr_src_port[0]) >> 17) & 0xf)
#define BCM53324_A0_EGR_SRC_PORTr_OUTER_TPID_ENABLEf_SET(r,f) (r).egr_src_port[0]=(((r).egr_src_port[0] & ~((uint32_t)0xf << 17)) | ((((uint32_t)f) & 0xf) << 17))

/*
 * These macros can be used to access EGR_SRC_PORT.
 *
 */
#define BCM53324_A0_READ_EGR_SRC_PORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_SRC_PORTr,(r._egr_src_port))
#define BCM53324_A0_WRITE_EGR_SRC_PORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_SRC_PORTr,&(r._egr_src_port))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_SRC_PORTr BCM53324_A0_EGR_SRC_PORTr
#define EGR_SRC_PORTr_SIZE BCM53324_A0_EGR_SRC_PORTr_SIZE
typedef BCM53324_A0_EGR_SRC_PORTr_t EGR_SRC_PORTr_t;
#define EGR_SRC_PORTr_CLR BCM53324_A0_EGR_SRC_PORTr_CLR
#define EGR_SRC_PORTr_SET BCM53324_A0_EGR_SRC_PORTr_SET
#define EGR_SRC_PORTr_GET BCM53324_A0_EGR_SRC_PORTr_GET
#define EGR_SRC_PORTr_ADD_INNER_TAGf_GET BCM53324_A0_EGR_SRC_PORTr_ADD_INNER_TAGf_GET
#define EGR_SRC_PORTr_ADD_INNER_TAGf_SET BCM53324_A0_EGR_SRC_PORTr_ADD_INNER_TAGf_SET
#define EGR_SRC_PORTr_INNER_TAGf_GET BCM53324_A0_EGR_SRC_PORTr_INNER_TAGf_GET
#define EGR_SRC_PORTr_INNER_TAGf_SET BCM53324_A0_EGR_SRC_PORTr_INNER_TAGf_SET
#define EGR_SRC_PORTr_OUTER_TPID_ENABLEf_GET BCM53324_A0_EGR_SRC_PORTr_OUTER_TPID_ENABLEf_GET
#define EGR_SRC_PORTr_OUTER_TPID_ENABLEf_SET BCM53324_A0_EGR_SRC_PORTr_OUTER_TPID_ENABLEf_SET
#define READ_EGR_SRC_PORTr BCM53324_A0_READ_EGR_SRC_PORTr
#define WRITE_EGR_SRC_PORTr BCM53324_A0_WRITE_EGR_SRC_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_SRC_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_VLAN
 * BLOCKS:   EPIPE
 * DESC:     Vlan Membership Table for Egress; Resolved vlan id is used to index this table
 * SIZE:     60
 * FIELDS:
 *     UT_BITMAP        Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     UT_BITMAP_LO     Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     UT_PORT_BITMAP   Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     UT_PORT_BITMAP_LO Untag Port Bitmap. Indicates on which port the packet needs to be sent untagged. A bit for CPU is not needed.
 *     PORT_BITMAP      Indiactes which port is member of this VLAN.  A bit for CPU is needed.
 *     STG              Spanning Tree Group Number. To be used for indexing VLAN_STG table.
 *     VALID            Indicates if the entry is valid.
 *     OUTER_TPID_INDEX Used when EGR_VLAN_CONTROL_1.OUTER_TPID_SEL is set and indicates which ofthe EGR_OUTER_TPID[xx] registers is to be used as the TPID for this VLAN
 *     PARITY           Contains Even parity for data upto OUTER_TPID_INDEX(for 59 bits)
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_VLANm 0x04910000

#define BCM53324_A0_EGR_VLANm_MIN 0
#define BCM53324_A0_EGR_VLANm_MAX 4095
#define BCM53324_A0_EGR_VLANm_CMAX(u) 4095
#define BCM53324_A0_EGR_VLANm_SIZE 8

/*
 * This structure should be used to declare and program EGR_VLAN.
 *
 */
typedef union BCM53324_A0_EGR_VLANm_s {
	uint32_t v[2];
	uint32_t egr_vlan[2];
	uint32_t _egr_vlan;
} BCM53324_A0_EGR_VLANm_t;

#define BCM53324_A0_EGR_VLANm_CLR(r) CDK_MEMSET(&((r)._egr_vlan), 0, sizeof(BCM53324_A0_EGR_VLANm_t))
#define BCM53324_A0_EGR_VLANm_SET(r,i,d) (r).egr_vlan[i] = d
#define BCM53324_A0_EGR_VLANm_GET(r,i) (r).egr_vlan[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_VLANm_UT_BITMAPf_GET(r) (((r).egr_vlan[0]) & 0x1ffffff)
#define BCM53324_A0_EGR_VLANm_UT_BITMAPf_SET(r,f) (r).egr_vlan[0]=(((r).egr_vlan[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_EGR_VLANm_UT_BITMAP_LOf_GET(r) (((r).egr_vlan[0]) & 0x1ffffff)
#define BCM53324_A0_EGR_VLANm_UT_BITMAP_LOf_SET(r,f) (r).egr_vlan[0]=(((r).egr_vlan[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_EGR_VLANm_UT_PORT_BITMAPf_GET(r) (((r).egr_vlan[0]) & 0x1ffffff)
#define BCM53324_A0_EGR_VLANm_UT_PORT_BITMAPf_SET(r,f) (r).egr_vlan[0]=(((r).egr_vlan[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_EGR_VLANm_UT_PORT_BITMAP_LOf_GET(r) (((r).egr_vlan[0]) & 0x1ffffff)
#define BCM53324_A0_EGR_VLANm_UT_PORT_BITMAP_LOf_SET(r,f) (r).egr_vlan[0]=(((r).egr_vlan[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_EGR_VLANm_PORT_BITMAPf_GET(r) cdk_field32_get((r).egr_vlan,25,49)
#define BCM53324_A0_EGR_VLANm_PORT_BITMAPf_SET(r,f) cdk_field32_set((r).egr_vlan,25,49,f)
#define BCM53324_A0_EGR_VLANm_STGf_GET(r) ((((r).egr_vlan[1]) >> 18) & 0x3f)
#define BCM53324_A0_EGR_VLANm_STGf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_EGR_VLANm_VALIDf_GET(r) ((((r).egr_vlan[1]) >> 24) & 0x1)
#define BCM53324_A0_EGR_VLANm_VALIDf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_EGR_VLANm_OUTER_TPID_INDEXf_GET(r) ((((r).egr_vlan[1]) >> 25) & 0x3)
#define BCM53324_A0_EGR_VLANm_OUTER_TPID_INDEXf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53324_A0_EGR_VLANm_PARITYf_GET(r) ((((r).egr_vlan[1]) >> 27) & 0x1)
#define BCM53324_A0_EGR_VLANm_PARITYf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access EGR_VLAN.
 *
 */
#define BCM53324_A0_READ_EGR_VLANm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_VLANm,i,(m._egr_vlan),2)
#define BCM53324_A0_WRITE_EGR_VLANm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_VLANm,i,&(m._egr_vlan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLANm BCM53324_A0_EGR_VLANm
#define EGR_VLANm_MIN BCM53324_A0_EGR_VLANm_MIN
#define EGR_VLANm_MAX BCM53324_A0_EGR_VLANm_MAX
#define EGR_VLANm_CMAX(u) BCM53324_A0_EGR_VLANm_CMAX(u)
#define EGR_VLANm_SIZE BCM53324_A0_EGR_VLANm_SIZE
typedef BCM53324_A0_EGR_VLANm_t EGR_VLANm_t;
#define EGR_VLANm_CLR BCM53324_A0_EGR_VLANm_CLR
#define EGR_VLANm_SET BCM53324_A0_EGR_VLANm_SET
#define EGR_VLANm_GET BCM53324_A0_EGR_VLANm_GET
#define EGR_VLANm_UT_BITMAPf_GET BCM53324_A0_EGR_VLANm_UT_BITMAPf_GET
#define EGR_VLANm_UT_BITMAPf_SET BCM53324_A0_EGR_VLANm_UT_BITMAPf_SET
#define EGR_VLANm_UT_BITMAP_LOf_GET BCM53324_A0_EGR_VLANm_UT_BITMAP_LOf_GET
#define EGR_VLANm_UT_BITMAP_LOf_SET BCM53324_A0_EGR_VLANm_UT_BITMAP_LOf_SET
#define EGR_VLANm_UT_PORT_BITMAPf_GET BCM53324_A0_EGR_VLANm_UT_PORT_BITMAPf_GET
#define EGR_VLANm_UT_PORT_BITMAPf_SET BCM53324_A0_EGR_VLANm_UT_PORT_BITMAPf_SET
#define EGR_VLANm_UT_PORT_BITMAP_LOf_GET BCM53324_A0_EGR_VLANm_UT_PORT_BITMAP_LOf_GET
#define EGR_VLANm_UT_PORT_BITMAP_LOf_SET BCM53324_A0_EGR_VLANm_UT_PORT_BITMAP_LOf_SET
#define EGR_VLANm_PORT_BITMAPf_GET BCM53324_A0_EGR_VLANm_PORT_BITMAPf_GET
#define EGR_VLANm_PORT_BITMAPf_SET BCM53324_A0_EGR_VLANm_PORT_BITMAPf_SET
#define EGR_VLANm_STGf_GET BCM53324_A0_EGR_VLANm_STGf_GET
#define EGR_VLANm_STGf_SET BCM53324_A0_EGR_VLANm_STGf_SET
#define EGR_VLANm_VALIDf_GET BCM53324_A0_EGR_VLANm_VALIDf_GET
#define EGR_VLANm_VALIDf_SET BCM53324_A0_EGR_VLANm_VALIDf_SET
#define EGR_VLANm_OUTER_TPID_INDEXf_GET BCM53324_A0_EGR_VLANm_OUTER_TPID_INDEXf_GET
#define EGR_VLANm_OUTER_TPID_INDEXf_SET BCM53324_A0_EGR_VLANm_OUTER_TPID_INDEXf_SET
#define EGR_VLANm_PARITYf_GET BCM53324_A0_EGR_VLANm_PARITYf_GET
#define EGR_VLANm_PARITYf_SET BCM53324_A0_EGR_VLANm_PARITYf_SET
#define READ_EGR_VLANm BCM53324_A0_READ_EGR_VLANm
#define WRITE_EGR_VLANm BCM53324_A0_WRITE_EGR_VLANm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_VLANm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_VLAN_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     Controls Vlan Translate and VLAN membership related functions.

 * SIZE:     32
 * FIELDS:
 *     VT_ENABLE        VLAN Translate is enabled on this port. If this bit is set, then the vid, pri obtained from the VXLTCAM Lookup is used.
 *     VT_MISS_DROP     If this bit is set, and a lookup in the vxlt cam table results in a miss, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *     VT_MISS_UT_DROP  If this bit is set, and a lookup in the vxlt cam table results in a miss, Andpkt is getting untagged due to EGR_VLAN untag bitmap settings, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *     VT_MISS_UNTAG    If this bit is set, it will force vlan translation misses to be untagged
 *     OUTER_TPID_SEL   If this bit is set, use the use the EGR_VLAN table's OUTER_TPID_INDEX to index into the EGR_OUTER_TPID registers and obtain the outer TPID.Else, use the EGR_VLAN_CONTROL_1 register's OUTER_TPID_INDEXfield to index into the EGR_OUTER_TPID registers and obtain the outer TPID.
 *     OUTER_TPID_INDEX Index into the EGR_OUTER_TPID[xx] register array.
 *     CFI_AS_CNG       For UNI Egress ports, if bit[0] of this field is 1, the CFI bitin the packet's inner tag indicates CNG.For NNI Egress ports, the 4 bits are associated with the 4EGR_OUTER_TPID registers. If one of these bits is set, theCFI bit in packets with the corresponding EGR_OUTER_TPIDregister indicates CNG.
 *     REMOVE_INNER_TAG If this bit is set, it indicates that the inner tag must be removed.(0 => do not remove, 1 => remove)
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_VLAN_CONTROL_1r 0x01900003

#define BCM53324_A0_EGR_VLAN_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_CONTROL_1.
 *
 */
typedef union BCM53324_A0_EGR_VLAN_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_vlan_control_1[1];
	uint32_t _egr_vlan_control_1;
} BCM53324_A0_EGR_VLAN_CONTROL_1r_t;

#define BCM53324_A0_EGR_VLAN_CONTROL_1r_CLR(r) (r).egr_vlan_control_1[0] = 0
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_SET(r,d) (r).egr_vlan_control_1[0] = d
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_GET(r) (r).egr_vlan_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET(r) (((r).egr_vlan_control_1[0]) & 0x1)
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 1) & 0x1)
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 2) & 0x1)
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_GET(r) ((((r).egr_vlan_control_1[0]) >> 3) & 0x1)
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_GET(r) ((((r).egr_vlan_control_1[0]) >> 4) & 0x1)
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_GET(r) ((((r).egr_vlan_control_1[0]) >> 5) & 0x3)
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_GET(r) ((((r).egr_vlan_control_1[0]) >> 7) & 0xf)
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_REMOVE_INNER_TAGf_GET(r) ((((r).egr_vlan_control_1[0]) >> 11) & 0x1)
#define BCM53324_A0_EGR_VLAN_CONTROL_1r_REMOVE_INNER_TAGf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access EGR_VLAN_CONTROL_1.
 *
 */
#define BCM53324_A0_READ_EGR_VLAN_CONTROL_1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EGR_VLAN_CONTROL_1r,(r._egr_vlan_control_1))
#define BCM53324_A0_WRITE_EGR_VLAN_CONTROL_1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EGR_VLAN_CONTROL_1r,&(r._egr_vlan_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_CONTROL_1r BCM53324_A0_EGR_VLAN_CONTROL_1r
#define EGR_VLAN_CONTROL_1r_SIZE BCM53324_A0_EGR_VLAN_CONTROL_1r_SIZE
typedef BCM53324_A0_EGR_VLAN_CONTROL_1r_t EGR_VLAN_CONTROL_1r_t;
#define EGR_VLAN_CONTROL_1r_CLR BCM53324_A0_EGR_VLAN_CONTROL_1r_CLR
#define EGR_VLAN_CONTROL_1r_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_SET
#define EGR_VLAN_CONTROL_1r_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_GET
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET
#define EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_GET
#define EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_SET
#define EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_GET
#define EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UNTAGf_SET
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_GET
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_OUTER_TPID_SELf_SET
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_GET
#define EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_OUTER_TPID_INDEXf_SET
#define EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_GET
#define EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_CFI_AS_CNGf_SET
#define EGR_VLAN_CONTROL_1r_REMOVE_INNER_TAGf_GET BCM53324_A0_EGR_VLAN_CONTROL_1r_REMOVE_INNER_TAGf_GET
#define EGR_VLAN_CONTROL_1r_REMOVE_INNER_TAGf_SET BCM53324_A0_EGR_VLAN_CONTROL_1r_REMOVE_INNER_TAGf_SET
#define READ_EGR_VLAN_CONTROL_1r BCM53324_A0_READ_EGR_VLAN_CONTROL_1r
#define WRITE_EGR_VLAN_CONTROL_1r BCM53324_A0_WRITE_EGR_VLAN_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_VLAN_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_VLAN_STG
 * BLOCKS:   EPIPE
 * DESC:     Egress Spanning Tree Stage Table; Spanning Tree Group Number obtained from VLAN Table is used to index this table
 * SIZE:     50
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for Port 0.
 *     SP_TREE_PORT1    Spanning Tree State for Port 1.
 *     SP_TREE_PORT2    Spanning Tree State for Port 2.
 *     SP_TREE_PORT3    Spanning Tree State for Port 3.
 *     SP_TREE_PORT4    Spanning Tree State for Port 4.
 *     SP_TREE_PORT5    Spanning Tree State for Port 5.
 *     SP_TREE_PORT6    Spanning Tree State for Port 6.
 *     SP_TREE_PORT7    Spanning Tree State for Port 7.
 *     SP_TREE_PORT8    Spanning Tree State for Port 8.
 *     SP_TREE_PORT9    Spanning Tree State for Port 9.
 *     SP_TREE_PORT10   Spanning Tree State for Port 10.
 *     SP_TREE_PORT11   Spanning Tree State for Port 11.
 *     SP_TREE_PORT12   Spanning Tree State for Port 12.
 *     SP_TREE_PORT13   Spanning Tree State for Port 13.
 *     SP_TREE_PORT14   Spanning Tree State for Port 14.
 *     SP_TREE_PORT15   Spanning Tree State for Port 15.
 *     SP_TREE_PORT16   Spanning Tree State for Port 16.
 *     SP_TREE_PORT17   Spanning Tree State for Port 17.
 *     SP_TREE_PORT18   Spanning Tree State for Port 18.
 *     SP_TREE_PORT19   Spanning Tree State for Port 19.
 *     SP_TREE_PORT20   Spanning Tree State for Port 20.
 *     SP_TREE_PORT21   Spanning Tree State for Port 21.
 *     SP_TREE_PORT22   Spanning Tree State for Port 22.
 *     SP_TREE_PORT23   Spanning Tree State for Port 23.
 *     SP_TREE_PORT24   Spanning Tree State for Port 24.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_VLAN_STGm 0x04920000

#define BCM53324_A0_EGR_VLAN_STGm_MIN 0
#define BCM53324_A0_EGR_VLAN_STGm_MAX 63
#define BCM53324_A0_EGR_VLAN_STGm_CMAX(u) 63
#define BCM53324_A0_EGR_VLAN_STGm_SIZE 7

/*
 * This structure should be used to declare and program EGR_VLAN_STG.
 *
 */
typedef union BCM53324_A0_EGR_VLAN_STGm_s {
	uint32_t v[2];
	uint32_t egr_vlan_stg[2];
	uint32_t _egr_vlan_stg;
} BCM53324_A0_EGR_VLAN_STGm_t;

#define BCM53324_A0_EGR_VLAN_STGm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_stg), 0, sizeof(BCM53324_A0_EGR_VLAN_STGm_t))
#define BCM53324_A0_EGR_VLAN_STGm_SET(r,i,d) (r).egr_vlan_stg[i] = d
#define BCM53324_A0_EGR_VLAN_STGm_GET(r,i) (r).egr_vlan_stg[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_GET(r) (((r).egr_vlan_stg[0]) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_GET(r) ((((r).egr_vlan_stg[0]) >> 2) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_GET(r) ((((r).egr_vlan_stg[0]) >> 4) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_GET(r) ((((r).egr_vlan_stg[0]) >> 6) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_GET(r) ((((r).egr_vlan_stg[0]) >> 8) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_GET(r) ((((r).egr_vlan_stg[0]) >> 10) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_GET(r) ((((r).egr_vlan_stg[0]) >> 12) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_GET(r) ((((r).egr_vlan_stg[0]) >> 14) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_GET(r) ((((r).egr_vlan_stg[0]) >> 16) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_GET(r) ((((r).egr_vlan_stg[0]) >> 18) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_GET(r) ((((r).egr_vlan_stg[0]) >> 20) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_GET(r) ((((r).egr_vlan_stg[0]) >> 22) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_GET(r) ((((r).egr_vlan_stg[0]) >> 24) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_GET(r) ((((r).egr_vlan_stg[0]) >> 26) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_GET(r) ((((r).egr_vlan_stg[0]) >> 28) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_GET(r) ((((r).egr_vlan_stg[0]) >> 30) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_GET(r) (((r).egr_vlan_stg[1]) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_GET(r) ((((r).egr_vlan_stg[1]) >> 2) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_GET(r) ((((r).egr_vlan_stg[1]) >> 4) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_GET(r) ((((r).egr_vlan_stg[1]) >> 6) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_GET(r) ((((r).egr_vlan_stg[1]) >> 8) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_GET(r) ((((r).egr_vlan_stg[1]) >> 10) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_GET(r) ((((r).egr_vlan_stg[1]) >> 12) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_GET(r) ((((r).egr_vlan_stg[1]) >> 14) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_GET(r) ((((r).egr_vlan_stg[1]) >> 16) & 0x3)
#define BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))

/*
 * These macros can be used to access EGR_VLAN_STG.
 *
 */
#define BCM53324_A0_READ_EGR_VLAN_STGm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_VLAN_STGm,i,(m._egr_vlan_stg),2)
#define BCM53324_A0_WRITE_EGR_VLAN_STGm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_VLAN_STGm,i,&(m._egr_vlan_stg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_STGm BCM53324_A0_EGR_VLAN_STGm
#define EGR_VLAN_STGm_MIN BCM53324_A0_EGR_VLAN_STGm_MIN
#define EGR_VLAN_STGm_MAX BCM53324_A0_EGR_VLAN_STGm_MAX
#define EGR_VLAN_STGm_CMAX(u) BCM53324_A0_EGR_VLAN_STGm_CMAX(u)
#define EGR_VLAN_STGm_SIZE BCM53324_A0_EGR_VLAN_STGm_SIZE
typedef BCM53324_A0_EGR_VLAN_STGm_t EGR_VLAN_STGm_t;
#define EGR_VLAN_STGm_CLR BCM53324_A0_EGR_VLAN_STGm_CLR
#define EGR_VLAN_STGm_SET BCM53324_A0_EGR_VLAN_STGm_SET
#define EGR_VLAN_STGm_GET BCM53324_A0_EGR_VLAN_STGm_GET
#define EGR_VLAN_STGm_SP_TREE_PORT0f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT0f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT1f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT1f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT2f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT2f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT3f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT3f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT4f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT4f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT5f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT5f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT6f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT6f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT7f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT7f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT8f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT8f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT9f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT9f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT10f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT10f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT11f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT11f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT12f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT12f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT13f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT13f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT14f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT14f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT15f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT15f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT16f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT16f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT17f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT17f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT18f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT18f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT19f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT19f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT20f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT20f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT20f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT21f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT21f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT21f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT22f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT22f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT22f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT23f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT23f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT23f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT24f_GET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT24f_SET BCM53324_A0_EGR_VLAN_STGm_SP_TREE_PORT24f_SET
#define READ_EGR_VLAN_STGm BCM53324_A0_READ_EGR_VLAN_STGm
#define WRITE_EGR_VLAN_STGm BCM53324_A0_WRITE_EGR_VLAN_STGm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_VLAN_STGm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_VLAN_TABLE_PARITY_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     This bit enables parity checking for the VLAN table
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set. Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        Parity enable for L3 INTF memory
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr 0x04980004

#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_TABLE_PARITY_CONTROL.
 *
 */
typedef union BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_vlan_table_parity_control[1];
	uint32_t _egr_vlan_table_parity_control;
} BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_t;

#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_CLR(r) (r).egr_vlan_table_parity_control[0] = 0
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_SET(r,d) (r).egr_vlan_table_parity_control[0] = d
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_GET(r) (r).egr_vlan_table_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).egr_vlan_table_parity_control[0]) & 0x1)
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).egr_vlan_table_parity_control[0]=(((r).egr_vlan_table_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).egr_vlan_table_parity_control[0]) >> 1) & 0x1)
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).egr_vlan_table_parity_control[0]=(((r).egr_vlan_table_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_VLAN_TABLE_PARITY_CONTROL.
 *
 */
#define BCM53324_A0_READ_EGR_VLAN_TABLE_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr,(r._egr_vlan_table_parity_control))
#define BCM53324_A0_WRITE_EGR_VLAN_TABLE_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr,&(r._egr_vlan_table_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_TABLE_PARITY_CONTROLr BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr
#define EGR_VLAN_TABLE_PARITY_CONTROLr_SIZE BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_SIZE
typedef BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_t EGR_VLAN_TABLE_PARITY_CONTROLr_t;
#define EGR_VLAN_TABLE_PARITY_CONTROLr_CLR BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_CLR
#define EGR_VLAN_TABLE_PARITY_CONTROLr_SET BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_SET
#define EGR_VLAN_TABLE_PARITY_CONTROLr_GET BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_GET
#define EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_ENf_GET BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_ENf_GET
#define EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_ENf_SET BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_EGR_VLAN_TABLE_PARITY_CONTROLr BCM53324_A0_READ_EGR_VLAN_TABLE_PARITY_CONTROLr
#define WRITE_EGR_VLAN_TABLE_PARITY_CONTROLr BCM53324_A0_WRITE_EGR_VLAN_TABLE_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_VLAN_TABLE_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EGR_VLAN_TABLE_PARITY_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VLAN_TABLE_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERROR     This bit when set indicates that a parity error has been detected.
 *     MEMORY_IDX       This field indicates the address in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr 0x04980005

#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_TABLE_PARITY_STATUS.
 *
 */
typedef union BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vlan_table_parity_status[1];
	uint32_t _egr_vlan_table_parity_status;
} BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_t;

#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_CLR(r) (r).egr_vlan_table_parity_status[0] = 0
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_SET(r,d) (r).egr_vlan_table_parity_status[0] = d
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_GET(r) (r).egr_vlan_table_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_PARITY_ERRORf_GET(r) (((r).egr_vlan_table_parity_status[0]) & 0x1)
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_PARITY_ERRORf_SET(r,f) (r).egr_vlan_table_parity_status[0]=(((r).egr_vlan_table_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_MEMORY_IDXf_GET(r) ((((r).egr_vlan_table_parity_status[0]) >> 1) & 0xfff)
#define BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_MEMORY_IDXf_SET(r,f) (r).egr_vlan_table_parity_status[0]=(((r).egr_vlan_table_parity_status[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))

/*
 * These macros can be used to access EGR_VLAN_TABLE_PARITY_STATUS.
 *
 */
#define BCM53324_A0_READ_EGR_VLAN_TABLE_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr,(r._egr_vlan_table_parity_status))
#define BCM53324_A0_WRITE_EGR_VLAN_TABLE_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr,&(r._egr_vlan_table_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_TABLE_PARITY_STATUSr BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr
#define EGR_VLAN_TABLE_PARITY_STATUSr_SIZE BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_SIZE
typedef BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_t EGR_VLAN_TABLE_PARITY_STATUSr_t;
#define EGR_VLAN_TABLE_PARITY_STATUSr_CLR BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_CLR
#define EGR_VLAN_TABLE_PARITY_STATUSr_SET BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_SET
#define EGR_VLAN_TABLE_PARITY_STATUSr_GET BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_GET
#define EGR_VLAN_TABLE_PARITY_STATUSr_PARITY_ERRORf_GET BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_PARITY_ERRORf_GET
#define EGR_VLAN_TABLE_PARITY_STATUSr_PARITY_ERRORf_SET BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_PARITY_ERRORf_SET
#define EGR_VLAN_TABLE_PARITY_STATUSr_MEMORY_IDXf_GET BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_MEMORY_IDXf_GET
#define EGR_VLAN_TABLE_PARITY_STATUSr_MEMORY_IDXf_SET BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr_MEMORY_IDXf_SET
#define READ_EGR_VLAN_TABLE_PARITY_STATUSr BCM53324_A0_READ_EGR_VLAN_TABLE_PARITY_STATUSr
#define WRITE_EGR_VLAN_TABLE_PARITY_STATUSr BCM53324_A0_WRITE_EGR_VLAN_TABLE_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_VLAN_TABLE_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_VLAN_XLATE
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate CAM-RAM Combined View.
 * SIZE:     53
 * FIELDS:
 *     VALID            Valid Bit for the Entry. It has to be 0th bit in the CAM.
 *     OLD_VLAN_ID      VID to be compared wrt the input Key.
 *     VID              VID to be compared wrt the input Key.
 *     EGRESS_PORT      Destination port to be compared wrt the input key.
 *     PORT             Destination port to be compared wrt the input key.
 *     RESERVED_DATA     RESERVED BITS FOR 64 ports
 *     MASK             mask for the key{reserved,egress_port,vlan_id}
 *     RESERVED_MASK    RESERVED MASK BIT for extending ports later; Must be tied to 0
 *     NEW_VID          VID to be used to translate the original packet or so far constructed VID at L3 stage.
 *     NEW_VLAN_ID      VID to be used to translate the original packet or so far constructed VID at L3 stage.
 *     PRI              Priority to be used to translate the original priority.
 *     RPE              Used to determine if the vlan_xlate_data PRI needs to be replaced.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_VLAN_XLATEm 0x05960000

#define BCM53324_A0_EGR_VLAN_XLATEm_MIN 0
#define BCM53324_A0_EGR_VLAN_XLATEm_MAX 15
#define BCM53324_A0_EGR_VLAN_XLATEm_CMAX(u) 15
#define BCM53324_A0_EGR_VLAN_XLATEm_SIZE 7

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE.
 *
 */
typedef union BCM53324_A0_EGR_VLAN_XLATEm_s {
	uint32_t v[2];
	uint32_t egr_vlan_xlate[2];
	uint32_t _egr_vlan_xlate;
} BCM53324_A0_EGR_VLAN_XLATEm_t;

#define BCM53324_A0_EGR_VLAN_XLATEm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_xlate), 0, sizeof(BCM53324_A0_EGR_VLAN_XLATEm_t))
#define BCM53324_A0_EGR_VLAN_XLATEm_SET(r,i,d) (r).egr_vlan_xlate[i] = d
#define BCM53324_A0_EGR_VLAN_XLATEm_GET(r,i) (r).egr_vlan_xlate[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_VLAN_XLATEm_VALIDf_GET(r) (((r).egr_vlan_xlate[0]) & 0x1)
#define BCM53324_A0_EGR_VLAN_XLATEm_VALIDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_VLAN_XLATEm_OLD_VLAN_IDf_GET(r) ((((r).egr_vlan_xlate[0]) >> 1) & 0xfff)
#define BCM53324_A0_EGR_VLAN_XLATEm_OLD_VLAN_IDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))
#define BCM53324_A0_EGR_VLAN_XLATEm_VIDf_GET(r) ((((r).egr_vlan_xlate[0]) >> 1) & 0xfff)
#define BCM53324_A0_EGR_VLAN_XLATEm_VIDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))
#define BCM53324_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_GET(r) ((((r).egr_vlan_xlate[0]) >> 13) & 0x1f)
#define BCM53324_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM53324_A0_EGR_VLAN_XLATEm_PORTf_GET(r) ((((r).egr_vlan_xlate[0]) >> 13) & 0x1f)
#define BCM53324_A0_EGR_VLAN_XLATEm_PORTf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM53324_A0_EGR_VLAN_XLATEm_RESERVED_DATAf_GET(r) ((((r).egr_vlan_xlate[0]) >> 18) & 0x1)
#define BCM53324_A0_EGR_VLAN_XLATEm_RESERVED_DATAf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_EGR_VLAN_XLATEm_MASKf_GET(r) cdk_field32_get((r).egr_vlan_xlate,19,35)
#define BCM53324_A0_EGR_VLAN_XLATEm_MASKf_SET(r,f) cdk_field32_set((r).egr_vlan_xlate,19,35,f)
#define BCM53324_A0_EGR_VLAN_XLATEm_RESERVED_MASKf_GET(r) ((((r).egr_vlan_xlate[1]) >> 4) & 0x1)
#define BCM53324_A0_EGR_VLAN_XLATEm_RESERVED_MASKf_SET(r,f) (r).egr_vlan_xlate[1]=(((r).egr_vlan_xlate[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_EGR_VLAN_XLATEm_NEW_VIDf_GET(r) ((((r).egr_vlan_xlate[1]) >> 5) & 0xfff)
#define BCM53324_A0_EGR_VLAN_XLATEm_NEW_VIDf_SET(r,f) (r).egr_vlan_xlate[1]=(((r).egr_vlan_xlate[1] & ~((uint32_t)0xfff << 5)) | ((((uint32_t)f) & 0xfff) << 5))
#define BCM53324_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET(r) ((((r).egr_vlan_xlate[1]) >> 5) & 0xfff)
#define BCM53324_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET(r,f) (r).egr_vlan_xlate[1]=(((r).egr_vlan_xlate[1] & ~((uint32_t)0xfff << 5)) | ((((uint32_t)f) & 0xfff) << 5))
#define BCM53324_A0_EGR_VLAN_XLATEm_PRIf_GET(r) ((((r).egr_vlan_xlate[1]) >> 17) & 0x7)
#define BCM53324_A0_EGR_VLAN_XLATEm_PRIf_SET(r,f) (r).egr_vlan_xlate[1]=(((r).egr_vlan_xlate[1] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define BCM53324_A0_EGR_VLAN_XLATEm_RPEf_GET(r) ((((r).egr_vlan_xlate[1]) >> 20) & 0x1)
#define BCM53324_A0_EGR_VLAN_XLATEm_RPEf_SET(r,f) (r).egr_vlan_xlate[1]=(((r).egr_vlan_xlate[1] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access EGR_VLAN_XLATE.
 *
 */
#define BCM53324_A0_READ_EGR_VLAN_XLATEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_VLAN_XLATEm,i,(m._egr_vlan_xlate),2)
#define BCM53324_A0_WRITE_EGR_VLAN_XLATEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_VLAN_XLATEm,i,&(m._egr_vlan_xlate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATEm BCM53324_A0_EGR_VLAN_XLATEm
#define EGR_VLAN_XLATEm_MIN BCM53324_A0_EGR_VLAN_XLATEm_MIN
#define EGR_VLAN_XLATEm_MAX BCM53324_A0_EGR_VLAN_XLATEm_MAX
#define EGR_VLAN_XLATEm_CMAX(u) BCM53324_A0_EGR_VLAN_XLATEm_CMAX(u)
#define EGR_VLAN_XLATEm_SIZE BCM53324_A0_EGR_VLAN_XLATEm_SIZE
typedef BCM53324_A0_EGR_VLAN_XLATEm_t EGR_VLAN_XLATEm_t;
#define EGR_VLAN_XLATEm_CLR BCM53324_A0_EGR_VLAN_XLATEm_CLR
#define EGR_VLAN_XLATEm_SET BCM53324_A0_EGR_VLAN_XLATEm_SET
#define EGR_VLAN_XLATEm_GET BCM53324_A0_EGR_VLAN_XLATEm_GET
#define EGR_VLAN_XLATEm_VALIDf_GET BCM53324_A0_EGR_VLAN_XLATEm_VALIDf_GET
#define EGR_VLAN_XLATEm_VALIDf_SET BCM53324_A0_EGR_VLAN_XLATEm_VALIDf_SET
#define EGR_VLAN_XLATEm_OLD_VLAN_IDf_GET BCM53324_A0_EGR_VLAN_XLATEm_OLD_VLAN_IDf_GET
#define EGR_VLAN_XLATEm_OLD_VLAN_IDf_SET BCM53324_A0_EGR_VLAN_XLATEm_OLD_VLAN_IDf_SET
#define EGR_VLAN_XLATEm_VIDf_GET BCM53324_A0_EGR_VLAN_XLATEm_VIDf_GET
#define EGR_VLAN_XLATEm_VIDf_SET BCM53324_A0_EGR_VLAN_XLATEm_VIDf_SET
#define EGR_VLAN_XLATEm_EGRESS_PORTf_GET BCM53324_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_GET
#define EGR_VLAN_XLATEm_EGRESS_PORTf_SET BCM53324_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_SET
#define EGR_VLAN_XLATEm_PORTf_GET BCM53324_A0_EGR_VLAN_XLATEm_PORTf_GET
#define EGR_VLAN_XLATEm_PORTf_SET BCM53324_A0_EGR_VLAN_XLATEm_PORTf_SET
#define EGR_VLAN_XLATEm_RESERVED_DATAf_GET BCM53324_A0_EGR_VLAN_XLATEm_RESERVED_DATAf_GET
#define EGR_VLAN_XLATEm_RESERVED_DATAf_SET BCM53324_A0_EGR_VLAN_XLATEm_RESERVED_DATAf_SET
#define EGR_VLAN_XLATEm_MASKf_GET BCM53324_A0_EGR_VLAN_XLATEm_MASKf_GET
#define EGR_VLAN_XLATEm_MASKf_SET BCM53324_A0_EGR_VLAN_XLATEm_MASKf_SET
#define EGR_VLAN_XLATEm_RESERVED_MASKf_GET BCM53324_A0_EGR_VLAN_XLATEm_RESERVED_MASKf_GET
#define EGR_VLAN_XLATEm_RESERVED_MASKf_SET BCM53324_A0_EGR_VLAN_XLATEm_RESERVED_MASKf_SET
#define EGR_VLAN_XLATEm_NEW_VIDf_GET BCM53324_A0_EGR_VLAN_XLATEm_NEW_VIDf_GET
#define EGR_VLAN_XLATEm_NEW_VIDf_SET BCM53324_A0_EGR_VLAN_XLATEm_NEW_VIDf_SET
#define EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET BCM53324_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET
#define EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET BCM53324_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET
#define EGR_VLAN_XLATEm_PRIf_GET BCM53324_A0_EGR_VLAN_XLATEm_PRIf_GET
#define EGR_VLAN_XLATEm_PRIf_SET BCM53324_A0_EGR_VLAN_XLATEm_PRIf_SET
#define EGR_VLAN_XLATEm_RPEf_GET BCM53324_A0_EGR_VLAN_XLATEm_RPEf_GET
#define EGR_VLAN_XLATEm_RPEf_SET BCM53324_A0_EGR_VLAN_XLATEm_RPEf_SET
#define READ_EGR_VLAN_XLATEm BCM53324_A0_READ_EGR_VLAN_XLATEm
#define WRITE_EGR_VLAN_XLATEm BCM53324_A0_WRITE_EGR_VLAN_XLATEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_VLAN_XLATEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_VLAN_XLATE_DATA_ONLY
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate Data Table only
 * SIZE:     16
 * FIELDS:
 *     NEW_VID          VID to be used to translate the original packet or so far constructed VID at L3 stage.
 *     PRI              Priority to be used to translate the original priority.
 *     RPE              Used to determine if the vlan_xlate_data PRI needs to be replaced.
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm 0x05980000

#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_MIN 0
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_MAX 15
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u) 15
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_SIZE 2

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE_DATA_ONLY.
 *
 */
typedef union BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t egr_vlan_xlate_data_only[1];
	uint32_t _egr_vlan_xlate_data_only;
} BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_t;

#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_CLR(r) (r).egr_vlan_xlate_data_only[0] = 0
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_SET(r,d) (r).egr_vlan_xlate_data_only[0] = d
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_GET(r) (r).egr_vlan_xlate_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET(r) (((r).egr_vlan_xlate_data_only[0]) & 0xfff)
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET(r) ((((r).egr_vlan_xlate_data_only[0]) >> 12) & 0x7)
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET(r) ((((r).egr_vlan_xlate_data_only[0]) >> 15) & 0x1)
#define BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access EGR_VLAN_XLATE_DATA_ONLY.
 *
 */
#define BCM53324_A0_READ_EGR_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm,i,(m._egr_vlan_xlate_data_only),1)
#define BCM53324_A0_WRITE_EGR_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm,i,&(m._egr_vlan_xlate_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATE_DATA_ONLYm BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm
#define EGR_VLAN_XLATE_DATA_ONLYm_MIN BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_MIN
#define EGR_VLAN_XLATE_DATA_ONLYm_MAX BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_MAX
#define EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u) BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u)
#define EGR_VLAN_XLATE_DATA_ONLYm_SIZE BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_SIZE
typedef BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_t EGR_VLAN_XLATE_DATA_ONLYm_t;
#define EGR_VLAN_XLATE_DATA_ONLYm_CLR BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_CLR
#define EGR_VLAN_XLATE_DATA_ONLYm_SET BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_GET BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET
#define READ_EGR_VLAN_XLATE_DATA_ONLYm BCM53324_A0_READ_EGR_VLAN_XLATE_DATA_ONLYm
#define WRITE_EGR_VLAN_XLATE_DATA_ONLYm BCM53324_A0_WRITE_EGR_VLAN_XLATE_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_VLAN_XLATE_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EGR_VLAN_XLATE_ONLY
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate CAM only.
 * SIZE:     37
 * FIELDS:
 *     VALID            Valid Bit for the Entry. It has to be 0th bit in the CAM.
 *     VID              VID to be compared wrt the input Key.
 *     EGRESS_PORT      Destination port to be compared wrt the input key.
 *     RESERVED_DATA    RESERVED BITS for extending ports later; ignored for now
 *     MASK             mask for the key{reserved, egress_port, vlan_id}
 *     RESERVED_MASK    RESERVED MASK BIT for extending ports later; Must be tied to 0
 *
 ******************************************************************************/
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm 0x05970000

#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_MIN 0
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_MAX 15
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_CMAX(u) 15
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_SIZE 5

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE_ONLY.
 *
 */
typedef union BCM53324_A0_EGR_VLAN_XLATE_ONLYm_s {
	uint32_t v[2];
	uint32_t egr_vlan_xlate_only[2];
	uint32_t _egr_vlan_xlate_only;
} BCM53324_A0_EGR_VLAN_XLATE_ONLYm_t;

#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_xlate_only), 0, sizeof(BCM53324_A0_EGR_VLAN_XLATE_ONLYm_t))
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_SET(r,i,d) (r).egr_vlan_xlate_only[i] = d
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_GET(r,i) (r).egr_vlan_xlate_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_GET(r) (((r).egr_vlan_xlate_only[0]) & 0x1)
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_VIDf_GET(r) ((((r).egr_vlan_xlate_only[0]) >> 1) & 0xfff)
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_VIDf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET(r) ((((r).egr_vlan_xlate_only[0]) >> 13) & 0x1f)
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_RESERVED_DATAf_GET(r) ((((r).egr_vlan_xlate_only[0]) >> 18) & 0x1)
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_RESERVED_DATAf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_MASKf_GET(r) cdk_field32_get((r).egr_vlan_xlate_only,19,35)
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_MASKf_SET(r,f) cdk_field32_set((r).egr_vlan_xlate_only,19,35,f)
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_RESERVED_MASKf_GET(r) ((((r).egr_vlan_xlate_only[1]) >> 4) & 0x1)
#define BCM53324_A0_EGR_VLAN_XLATE_ONLYm_RESERVED_MASKf_SET(r,f) (r).egr_vlan_xlate_only[1]=(((r).egr_vlan_xlate_only[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access EGR_VLAN_XLATE_ONLY.
 *
 */
#define BCM53324_A0_READ_EGR_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EGR_VLAN_XLATE_ONLYm,i,(m._egr_vlan_xlate_only),2)
#define BCM53324_A0_WRITE_EGR_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EGR_VLAN_XLATE_ONLYm,i,&(m._egr_vlan_xlate_only),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATE_ONLYm BCM53324_A0_EGR_VLAN_XLATE_ONLYm
#define EGR_VLAN_XLATE_ONLYm_MIN BCM53324_A0_EGR_VLAN_XLATE_ONLYm_MIN
#define EGR_VLAN_XLATE_ONLYm_MAX BCM53324_A0_EGR_VLAN_XLATE_ONLYm_MAX
#define EGR_VLAN_XLATE_ONLYm_CMAX(u) BCM53324_A0_EGR_VLAN_XLATE_ONLYm_CMAX(u)
#define EGR_VLAN_XLATE_ONLYm_SIZE BCM53324_A0_EGR_VLAN_XLATE_ONLYm_SIZE
typedef BCM53324_A0_EGR_VLAN_XLATE_ONLYm_t EGR_VLAN_XLATE_ONLYm_t;
#define EGR_VLAN_XLATE_ONLYm_CLR BCM53324_A0_EGR_VLAN_XLATE_ONLYm_CLR
#define EGR_VLAN_XLATE_ONLYm_SET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_SET
#define EGR_VLAN_XLATE_ONLYm_GET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_GET
#define EGR_VLAN_XLATE_ONLYm_VALIDf_GET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_GET
#define EGR_VLAN_XLATE_ONLYm_VALIDf_SET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_SET
#define EGR_VLAN_XLATE_ONLYm_VIDf_GET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_VIDf_GET
#define EGR_VLAN_XLATE_ONLYm_VIDf_SET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_VIDf_SET
#define EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET
#define EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET
#define EGR_VLAN_XLATE_ONLYm_RESERVED_DATAf_GET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_RESERVED_DATAf_GET
#define EGR_VLAN_XLATE_ONLYm_RESERVED_DATAf_SET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_RESERVED_DATAf_SET
#define EGR_VLAN_XLATE_ONLYm_MASKf_GET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_MASKf_GET
#define EGR_VLAN_XLATE_ONLYm_MASKf_SET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_MASKf_SET
#define EGR_VLAN_XLATE_ONLYm_RESERVED_MASKf_GET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_RESERVED_MASKf_GET
#define EGR_VLAN_XLATE_ONLYm_RESERVED_MASKf_SET BCM53324_A0_EGR_VLAN_XLATE_ONLYm_RESERVED_MASKf_SET
#define READ_EGR_VLAN_XLATE_ONLYm BCM53324_A0_READ_EGR_VLAN_XLATE_ONLYm
#define WRITE_EGR_VLAN_XLATE_ONLYm BCM53324_A0_WRITE_EGR_VLAN_XLATE_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EGR_VLAN_XLATE_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EMIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Egress mirror bitmap register - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM53324_A0_EMIRROR_CONTROLr 0x0f700109

#define BCM53324_A0_EMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EMIRROR_CONTROL.
 *
 */
typedef union BCM53324_A0_EMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t emirror_control[1];
	uint32_t _emirror_control;
} BCM53324_A0_EMIRROR_CONTROLr_t;

#define BCM53324_A0_EMIRROR_CONTROLr_CLR(r) (r).emirror_control[0] = 0
#define BCM53324_A0_EMIRROR_CONTROLr_SET(r,d) (r).emirror_control[0] = d
#define BCM53324_A0_EMIRROR_CONTROLr_GET(r) (r).emirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EMIRROR_CONTROLr_BITMAPf_GET(r) (((r).emirror_control[0]) & 0x1ffffff)
#define BCM53324_A0_EMIRROR_CONTROLr_BITMAPf_SET(r,f) (r).emirror_control[0]=(((r).emirror_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access EMIRROR_CONTROL.
 *
 */
#define BCM53324_A0_READ_EMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_EMIRROR_CONTROLr,(r._emirror_control))
#define BCM53324_A0_WRITE_EMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_EMIRROR_CONTROLr,&(r._emirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EMIRROR_CONTROLr BCM53324_A0_EMIRROR_CONTROLr
#define EMIRROR_CONTROLr_SIZE BCM53324_A0_EMIRROR_CONTROLr_SIZE
typedef BCM53324_A0_EMIRROR_CONTROLr_t EMIRROR_CONTROLr_t;
#define EMIRROR_CONTROLr_CLR BCM53324_A0_EMIRROR_CONTROLr_CLR
#define EMIRROR_CONTROLr_SET BCM53324_A0_EMIRROR_CONTROLr_SET
#define EMIRROR_CONTROLr_GET BCM53324_A0_EMIRROR_CONTROLr_GET
#define EMIRROR_CONTROLr_BITMAPf_GET BCM53324_A0_EMIRROR_CONTROLr_BITMAPf_GET
#define EMIRROR_CONTROLr_BITMAPf_SET BCM53324_A0_EMIRROR_CONTROLr_BITMAPf_SET
#define READ_EMIRROR_CONTROLr BCM53324_A0_READ_EMIRROR_CONTROLr
#define WRITE_EMIRROR_CONTROLr BCM53324_A0_WRITE_EMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  EM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Egress Mirror to Port Table. Indexed using the MIRROR_CONTROL.EM_MTP_INDEX
 * SIZE:     11
 * FIELDS:
 *     PORT_TGID        Mirror to port port/TGID
 *     MODULE_ID        Mirror to port module ID. Needs to be Zeros
 *
 ******************************************************************************/
#define BCM53324_A0_EM_MTP_INDEXm 0x0f7b0000

#define BCM53324_A0_EM_MTP_INDEXm_MIN 0
#define BCM53324_A0_EM_MTP_INDEXm_MAX 3
#define BCM53324_A0_EM_MTP_INDEXm_CMAX(u) 3
#define BCM53324_A0_EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EM_MTP_INDEX.
 *
 */
typedef union BCM53324_A0_EM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t em_mtp_index[1];
	uint32_t _em_mtp_index;
} BCM53324_A0_EM_MTP_INDEXm_t;

#define BCM53324_A0_EM_MTP_INDEXm_CLR(r) (r).em_mtp_index[0] = 0
#define BCM53324_A0_EM_MTP_INDEXm_SET(r,d) (r).em_mtp_index[0] = d
#define BCM53324_A0_EM_MTP_INDEXm_GET(r) (r).em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EM_MTP_INDEXm_PORT_TGIDf_GET(r) (((r).em_mtp_index[0]) & 0x7f)
#define BCM53324_A0_EM_MTP_INDEXm_PORT_TGIDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53324_A0_EM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).em_mtp_index[0]) >> 7) & 0xf)
#define BCM53324_A0_EM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))

/*
 * These macros can be used to access EM_MTP_INDEX.
 *
 */
#define BCM53324_A0_READ_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_EM_MTP_INDEXm,i,(m._em_mtp_index),1)
#define BCM53324_A0_WRITE_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_EM_MTP_INDEXm,i,&(m._em_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EM_MTP_INDEXm BCM53324_A0_EM_MTP_INDEXm
#define EM_MTP_INDEXm_MIN BCM53324_A0_EM_MTP_INDEXm_MIN
#define EM_MTP_INDEXm_MAX BCM53324_A0_EM_MTP_INDEXm_MAX
#define EM_MTP_INDEXm_CMAX(u) BCM53324_A0_EM_MTP_INDEXm_CMAX(u)
#define EM_MTP_INDEXm_SIZE BCM53324_A0_EM_MTP_INDEXm_SIZE
typedef BCM53324_A0_EM_MTP_INDEXm_t EM_MTP_INDEXm_t;
#define EM_MTP_INDEXm_CLR BCM53324_A0_EM_MTP_INDEXm_CLR
#define EM_MTP_INDEXm_SET BCM53324_A0_EM_MTP_INDEXm_SET
#define EM_MTP_INDEXm_GET BCM53324_A0_EM_MTP_INDEXm_GET
#define EM_MTP_INDEXm_PORT_TGIDf_GET BCM53324_A0_EM_MTP_INDEXm_PORT_TGIDf_GET
#define EM_MTP_INDEXm_PORT_TGIDf_SET BCM53324_A0_EM_MTP_INDEXm_PORT_TGIDf_SET
#define EM_MTP_INDEXm_MODULE_IDf_GET BCM53324_A0_EM_MTP_INDEXm_MODULE_IDf_GET
#define EM_MTP_INDEXm_MODULE_IDf_SET BCM53324_A0_EM_MTP_INDEXm_MODULE_IDf_SET
#define READ_EM_MTP_INDEXm BCM53324_A0_READ_EM_MTP_INDEXm
#define WRITE_EM_MTP_INDEXm BCM53324_A0_WRITE_EM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EPC_LINK_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Link status register - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link status bitmap 
 *
 ******************************************************************************/
#define BCM53324_A0_EPC_LINK_BMAPr 0x0f780110

#define BCM53324_A0_EPC_LINK_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program EPC_LINK_BMAP.
 *
 */
typedef union BCM53324_A0_EPC_LINK_BMAPr_s {
	uint32_t v[1];
	uint32_t epc_link_bmap[1];
	uint32_t _epc_link_bmap;
} BCM53324_A0_EPC_LINK_BMAPr_t;

#define BCM53324_A0_EPC_LINK_BMAPr_CLR(r) (r).epc_link_bmap[0] = 0
#define BCM53324_A0_EPC_LINK_BMAPr_SET(r,d) (r).epc_link_bmap[0] = d
#define BCM53324_A0_EPC_LINK_BMAPr_GET(r) (r).epc_link_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EPC_LINK_BMAPr_PORT_BITMAPf_GET(r) (((r).epc_link_bmap[0]) & 0x1ffffff)
#define BCM53324_A0_EPC_LINK_BMAPr_PORT_BITMAPf_SET(r,f) (r).epc_link_bmap[0]=(((r).epc_link_bmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access EPC_LINK_BMAP.
 *
 */
#define BCM53324_A0_READ_EPC_LINK_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EPC_LINK_BMAPr,(r._epc_link_bmap))
#define BCM53324_A0_WRITE_EPC_LINK_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EPC_LINK_BMAPr,&(r._epc_link_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EPC_LINK_BMAPr BCM53324_A0_EPC_LINK_BMAPr
#define EPC_LINK_BMAPr_SIZE BCM53324_A0_EPC_LINK_BMAPr_SIZE
typedef BCM53324_A0_EPC_LINK_BMAPr_t EPC_LINK_BMAPr_t;
#define EPC_LINK_BMAPr_CLR BCM53324_A0_EPC_LINK_BMAPr_CLR
#define EPC_LINK_BMAPr_SET BCM53324_A0_EPC_LINK_BMAPr_SET
#define EPC_LINK_BMAPr_GET BCM53324_A0_EPC_LINK_BMAPr_GET
#define EPC_LINK_BMAPr_PORT_BITMAPf_GET BCM53324_A0_EPC_LINK_BMAPr_PORT_BITMAPf_GET
#define EPC_LINK_BMAPr_PORT_BITMAPf_SET BCM53324_A0_EPC_LINK_BMAPr_PORT_BITMAPf_SET
#define READ_EPC_LINK_BMAPr BCM53324_A0_READ_EPC_LINK_BMAPr
#define WRITE_EPC_LINK_BMAPr BCM53324_A0_WRITE_EPC_LINK_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EPC_LINK_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EVLAN_TM_REG_1
 * BLOCKS:   EPIPE
 * DESC:     Test Mode bits for EVLAN stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_VLAN          Test Mode bits for VLAN memory
 *     TM_VLAN_STG      Test Mode bits for VLAN_STG memory
 *
 ******************************************************************************/
#define BCM53324_A0_EVLAN_TM_REG_1r 0x04980006

#define BCM53324_A0_EVLAN_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program EVLAN_TM_REG_1.
 *
 */
typedef union BCM53324_A0_EVLAN_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t evlan_tm_reg_1[1];
	uint32_t _evlan_tm_reg_1;
} BCM53324_A0_EVLAN_TM_REG_1r_t;

#define BCM53324_A0_EVLAN_TM_REG_1r_CLR(r) (r).evlan_tm_reg_1[0] = 0
#define BCM53324_A0_EVLAN_TM_REG_1r_SET(r,d) (r).evlan_tm_reg_1[0] = d
#define BCM53324_A0_EVLAN_TM_REG_1r_GET(r) (r).evlan_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EVLAN_TM_REG_1r_TM_VLANf_GET(r) (((r).evlan_tm_reg_1[0]) & 0xf)
#define BCM53324_A0_EVLAN_TM_REG_1r_TM_VLANf_SET(r,f) (r).evlan_tm_reg_1[0]=(((r).evlan_tm_reg_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_EVLAN_TM_REG_1r_TM_VLAN_STGf_GET(r) ((((r).evlan_tm_reg_1[0]) >> 4) & 0xf)
#define BCM53324_A0_EVLAN_TM_REG_1r_TM_VLAN_STGf_SET(r,f) (r).evlan_tm_reg_1[0]=(((r).evlan_tm_reg_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access EVLAN_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_EVLAN_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EVLAN_TM_REG_1r,(r._evlan_tm_reg_1))
#define BCM53324_A0_WRITE_EVLAN_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EVLAN_TM_REG_1r,&(r._evlan_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EVLAN_TM_REG_1r BCM53324_A0_EVLAN_TM_REG_1r
#define EVLAN_TM_REG_1r_SIZE BCM53324_A0_EVLAN_TM_REG_1r_SIZE
typedef BCM53324_A0_EVLAN_TM_REG_1r_t EVLAN_TM_REG_1r_t;
#define EVLAN_TM_REG_1r_CLR BCM53324_A0_EVLAN_TM_REG_1r_CLR
#define EVLAN_TM_REG_1r_SET BCM53324_A0_EVLAN_TM_REG_1r_SET
#define EVLAN_TM_REG_1r_GET BCM53324_A0_EVLAN_TM_REG_1r_GET
#define EVLAN_TM_REG_1r_TM_VLANf_GET BCM53324_A0_EVLAN_TM_REG_1r_TM_VLANf_GET
#define EVLAN_TM_REG_1r_TM_VLANf_SET BCM53324_A0_EVLAN_TM_REG_1r_TM_VLANf_SET
#define EVLAN_TM_REG_1r_TM_VLAN_STGf_GET BCM53324_A0_EVLAN_TM_REG_1r_TM_VLAN_STGf_GET
#define EVLAN_TM_REG_1r_TM_VLAN_STGf_SET BCM53324_A0_EVLAN_TM_REG_1r_TM_VLAN_STGf_SET
#define READ_EVLAN_TM_REG_1r BCM53324_A0_READ_EVLAN_TM_REG_1r
#define WRITE_EVLAN_TM_REG_1r BCM53324_A0_WRITE_EVLAN_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EVLAN_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EVLAN_WW_REG_1
 * BLOCKS:   EPIPE
 * DESC:     Weak Write bits for EVLAN stage memories
 * SIZE:     32
 * FIELDS:
 *     WW_VLAN          Weak Write bit for VLAN memory
 *     WW_VLAN_STG      Weak Write bit for VLAN_STG memory
 *
 ******************************************************************************/
#define BCM53324_A0_EVLAN_WW_REG_1r 0x04980007

#define BCM53324_A0_EVLAN_WW_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program EVLAN_WW_REG_1.
 *
 */
typedef union BCM53324_A0_EVLAN_WW_REG_1r_s {
	uint32_t v[1];
	uint32_t evlan_ww_reg_1[1];
	uint32_t _evlan_ww_reg_1;
} BCM53324_A0_EVLAN_WW_REG_1r_t;

#define BCM53324_A0_EVLAN_WW_REG_1r_CLR(r) (r).evlan_ww_reg_1[0] = 0
#define BCM53324_A0_EVLAN_WW_REG_1r_SET(r,d) (r).evlan_ww_reg_1[0] = d
#define BCM53324_A0_EVLAN_WW_REG_1r_GET(r) (r).evlan_ww_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EVLAN_WW_REG_1r_WW_VLANf_GET(r) (((r).evlan_ww_reg_1[0]) & 0x1)
#define BCM53324_A0_EVLAN_WW_REG_1r_WW_VLANf_SET(r,f) (r).evlan_ww_reg_1[0]=(((r).evlan_ww_reg_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_EVLAN_WW_REG_1r_WW_VLAN_STGf_GET(r) ((((r).evlan_ww_reg_1[0]) >> 1) & 0x1)
#define BCM53324_A0_EVLAN_WW_REG_1r_WW_VLAN_STGf_SET(r,f) (r).evlan_ww_reg_1[0]=(((r).evlan_ww_reg_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EVLAN_WW_REG_1.
 *
 */
#define BCM53324_A0_READ_EVLAN_WW_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EVLAN_WW_REG_1r,(r._evlan_ww_reg_1))
#define BCM53324_A0_WRITE_EVLAN_WW_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EVLAN_WW_REG_1r,&(r._evlan_ww_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EVLAN_WW_REG_1r BCM53324_A0_EVLAN_WW_REG_1r
#define EVLAN_WW_REG_1r_SIZE BCM53324_A0_EVLAN_WW_REG_1r_SIZE
typedef BCM53324_A0_EVLAN_WW_REG_1r_t EVLAN_WW_REG_1r_t;
#define EVLAN_WW_REG_1r_CLR BCM53324_A0_EVLAN_WW_REG_1r_CLR
#define EVLAN_WW_REG_1r_SET BCM53324_A0_EVLAN_WW_REG_1r_SET
#define EVLAN_WW_REG_1r_GET BCM53324_A0_EVLAN_WW_REG_1r_GET
#define EVLAN_WW_REG_1r_WW_VLANf_GET BCM53324_A0_EVLAN_WW_REG_1r_WW_VLANf_GET
#define EVLAN_WW_REG_1r_WW_VLANf_SET BCM53324_A0_EVLAN_WW_REG_1r_WW_VLANf_SET
#define EVLAN_WW_REG_1r_WW_VLAN_STGf_GET BCM53324_A0_EVLAN_WW_REG_1r_WW_VLAN_STGf_GET
#define EVLAN_WW_REG_1r_WW_VLAN_STGf_SET BCM53324_A0_EVLAN_WW_REG_1r_WW_VLAN_STGf_SET
#define READ_EVLAN_WW_REG_1r BCM53324_A0_READ_EVLAN_WW_REG_1r
#define WRITE_EVLAN_WW_REG_1r BCM53324_A0_WRITE_EVLAN_WW_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EVLAN_WW_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EVXLT_TM_REG_1
 * BLOCKS:   EPIPE
 * DESC:     Test Mode bits for EVXLT stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_PRI_CNG       Test Mode bits for PRI_CNG memory
 *
 ******************************************************************************/
#define BCM53324_A0_EVXLT_TM_REG_1r 0x05980000

#define BCM53324_A0_EVXLT_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program EVXLT_TM_REG_1.
 *
 */
typedef union BCM53324_A0_EVXLT_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t evxlt_tm_reg_1[1];
	uint32_t _evxlt_tm_reg_1;
} BCM53324_A0_EVXLT_TM_REG_1r_t;

#define BCM53324_A0_EVXLT_TM_REG_1r_CLR(r) (r).evxlt_tm_reg_1[0] = 0
#define BCM53324_A0_EVXLT_TM_REG_1r_SET(r,d) (r).evxlt_tm_reg_1[0] = d
#define BCM53324_A0_EVXLT_TM_REG_1r_GET(r) (r).evxlt_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EVXLT_TM_REG_1r_TM_PRI_CNGf_GET(r) (((r).evxlt_tm_reg_1[0]) & 0xf)
#define BCM53324_A0_EVXLT_TM_REG_1r_TM_PRI_CNGf_SET(r,f) (r).evxlt_tm_reg_1[0]=(((r).evxlt_tm_reg_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EVXLT_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_EVXLT_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EVXLT_TM_REG_1r,(r._evxlt_tm_reg_1))
#define BCM53324_A0_WRITE_EVXLT_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EVXLT_TM_REG_1r,&(r._evxlt_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EVXLT_TM_REG_1r BCM53324_A0_EVXLT_TM_REG_1r
#define EVXLT_TM_REG_1r_SIZE BCM53324_A0_EVXLT_TM_REG_1r_SIZE
typedef BCM53324_A0_EVXLT_TM_REG_1r_t EVXLT_TM_REG_1r_t;
#define EVXLT_TM_REG_1r_CLR BCM53324_A0_EVXLT_TM_REG_1r_CLR
#define EVXLT_TM_REG_1r_SET BCM53324_A0_EVXLT_TM_REG_1r_SET
#define EVXLT_TM_REG_1r_GET BCM53324_A0_EVXLT_TM_REG_1r_GET
#define EVXLT_TM_REG_1r_TM_PRI_CNGf_GET BCM53324_A0_EVXLT_TM_REG_1r_TM_PRI_CNGf_GET
#define EVXLT_TM_REG_1r_TM_PRI_CNGf_SET BCM53324_A0_EVXLT_TM_REG_1r_TM_PRI_CNGf_SET
#define READ_EVXLT_TM_REG_1r BCM53324_A0_READ_EVXLT_TM_REG_1r
#define WRITE_EVXLT_TM_REG_1r BCM53324_A0_WRITE_EVXLT_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EVXLT_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  EVXLT_WW_REG_1
 * BLOCKS:   EPIPE
 * DESC:     Weak Write bits for EVXLT stage memories
 * SIZE:     32
 * FIELDS:
 *     WW_PRI_CNG       Weak Write bit for PRI_CNG memory
 *
 ******************************************************************************/
#define BCM53324_A0_EVXLT_WW_REG_1r 0x05980001

#define BCM53324_A0_EVXLT_WW_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program EVXLT_WW_REG_1.
 *
 */
typedef union BCM53324_A0_EVXLT_WW_REG_1r_s {
	uint32_t v[1];
	uint32_t evxlt_ww_reg_1[1];
	uint32_t _evxlt_ww_reg_1;
} BCM53324_A0_EVXLT_WW_REG_1r_t;

#define BCM53324_A0_EVXLT_WW_REG_1r_CLR(r) (r).evxlt_ww_reg_1[0] = 0
#define BCM53324_A0_EVXLT_WW_REG_1r_SET(r,d) (r).evxlt_ww_reg_1[0] = d
#define BCM53324_A0_EVXLT_WW_REG_1r_GET(r) (r).evxlt_ww_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_EVXLT_WW_REG_1r_WW_PRI_CNGf_GET(r) (((r).evxlt_ww_reg_1[0]) & 0x1)
#define BCM53324_A0_EVXLT_WW_REG_1r_WW_PRI_CNGf_SET(r,f) (r).evxlt_ww_reg_1[0]=(((r).evxlt_ww_reg_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EVXLT_WW_REG_1.
 *
 */
#define BCM53324_A0_READ_EVXLT_WW_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_EVXLT_WW_REG_1r,(r._evxlt_ww_reg_1))
#define BCM53324_A0_WRITE_EVXLT_WW_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_EVXLT_WW_REG_1r,&(r._evxlt_ww_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EVXLT_WW_REG_1r BCM53324_A0_EVXLT_WW_REG_1r
#define EVXLT_WW_REG_1r_SIZE BCM53324_A0_EVXLT_WW_REG_1r_SIZE
typedef BCM53324_A0_EVXLT_WW_REG_1r_t EVXLT_WW_REG_1r_t;
#define EVXLT_WW_REG_1r_CLR BCM53324_A0_EVXLT_WW_REG_1r_CLR
#define EVXLT_WW_REG_1r_SET BCM53324_A0_EVXLT_WW_REG_1r_SET
#define EVXLT_WW_REG_1r_GET BCM53324_A0_EVXLT_WW_REG_1r_GET
#define EVXLT_WW_REG_1r_WW_PRI_CNGf_GET BCM53324_A0_EVXLT_WW_REG_1r_WW_PRI_CNGf_GET
#define EVXLT_WW_REG_1r_WW_PRI_CNGf_SET BCM53324_A0_EVXLT_WW_REG_1r_WW_PRI_CNGf_SET
#define READ_EVXLT_WW_REG_1r BCM53324_A0_READ_EVXLT_WW_REG_1r
#define WRITE_EVXLT_WW_REG_1r BCM53324_A0_WRITE_EVXLT_WW_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_EVXLT_WW_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FLUSH_CONTROL
 * BLOCKS:   GPORT0
 * DESC:     Flush enable control register
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Flush enable bit to drop out all packets in Tx fifo without egressing any packets when set.
 *
 ******************************************************************************/
#define BCM53324_A0_FLUSH_CONTROLr 0x000001cd

#define BCM53324_A0_FLUSH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FLUSH_CONTROL.
 *
 */
typedef union BCM53324_A0_FLUSH_CONTROLr_s {
	uint32_t v[1];
	uint32_t flush_control[1];
	uint32_t _flush_control;
} BCM53324_A0_FLUSH_CONTROLr_t;

#define BCM53324_A0_FLUSH_CONTROLr_CLR(r) (r).flush_control[0] = 0
#define BCM53324_A0_FLUSH_CONTROLr_SET(r,d) (r).flush_control[0] = d
#define BCM53324_A0_FLUSH_CONTROLr_GET(r) (r).flush_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FLUSH_CONTROLr_FLUSHf_GET(r) (((r).flush_control[0]) & 0x1)
#define BCM53324_A0_FLUSH_CONTROLr_FLUSHf_SET(r,f) (r).flush_control[0]=(((r).flush_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access FLUSH_CONTROL.
 *
 */
#define BCM53324_A0_READ_FLUSH_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_FLUSH_CONTROLr,(r._flush_control))
#define BCM53324_A0_WRITE_FLUSH_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_FLUSH_CONTROLr,&(r._flush_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FLUSH_CONTROLr BCM53324_A0_FLUSH_CONTROLr
#define FLUSH_CONTROLr_SIZE BCM53324_A0_FLUSH_CONTROLr_SIZE
typedef BCM53324_A0_FLUSH_CONTROLr_t FLUSH_CONTROLr_t;
#define FLUSH_CONTROLr_CLR BCM53324_A0_FLUSH_CONTROLr_CLR
#define FLUSH_CONTROLr_SET BCM53324_A0_FLUSH_CONTROLr_SET
#define FLUSH_CONTROLr_GET BCM53324_A0_FLUSH_CONTROLr_GET
#define FLUSH_CONTROLr_FLUSHf_GET BCM53324_A0_FLUSH_CONTROLr_FLUSHf_GET
#define FLUSH_CONTROLr_FLUSHf_SET BCM53324_A0_FLUSH_CONTROLr_FLUSHf_SET
#define READ_FLUSH_CONTROLr BCM53324_A0_READ_FLUSH_CONTROLr
#define WRITE_FLUSH_CONTROLr BCM53324_A0_WRITE_FLUSH_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FLUSH_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FP_CAM_BIST_DBG_DATA_VALID
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_DBG_DATA_VALID
 * SIZE:     32
 * FIELDS:
 *     BIST_DBG_DATA_VALID data valid signal validates input data to cam
 *
 ******************************************************************************/
#define BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr 0x0d780005

#define BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_DBG_DATA_VALID.
 *
 */
typedef union BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_dbg_data_valid[1];
	uint32_t _fp_cam_bist_dbg_data_valid;
} BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_t;

#define BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_CLR(r) (r).fp_cam_bist_dbg_data_valid[0] = 0
#define BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_SET(r,d) (r).fp_cam_bist_dbg_data_valid[0] = d
#define BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_GET(r) (r).fp_cam_bist_dbg_data_valid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_BIST_DBG_DATA_VALIDf_GET(r) (((r).fp_cam_bist_dbg_data_valid[0]) & 0x1)
#define BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_BIST_DBG_DATA_VALIDf_SET(r,f) (r).fp_cam_bist_dbg_data_valid[0]=(((r).fp_cam_bist_dbg_data_valid[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access FP_CAM_BIST_DBG_DATA_VALID.
 *
 */
#define BCM53324_A0_READ_FP_CAM_BIST_DBG_DATA_VALIDr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr,(r._fp_cam_bist_dbg_data_valid))
#define BCM53324_A0_WRITE_FP_CAM_BIST_DBG_DATA_VALIDr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr,&(r._fp_cam_bist_dbg_data_valid))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_DBG_DATA_VALIDr BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr
#define FP_CAM_BIST_DBG_DATA_VALIDr_SIZE BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_SIZE
typedef BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_t FP_CAM_BIST_DBG_DATA_VALIDr_t;
#define FP_CAM_BIST_DBG_DATA_VALIDr_CLR BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_CLR
#define FP_CAM_BIST_DBG_DATA_VALIDr_SET BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_SET
#define FP_CAM_BIST_DBG_DATA_VALIDr_GET BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_GET
#define FP_CAM_BIST_DBG_DATA_VALIDr_BIST_DBG_DATA_VALIDf_GET BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_BIST_DBG_DATA_VALIDf_GET
#define FP_CAM_BIST_DBG_DATA_VALIDr_BIST_DBG_DATA_VALIDf_SET BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr_BIST_DBG_DATA_VALIDf_SET
#define READ_FP_CAM_BIST_DBG_DATA_VALIDr BCM53324_A0_READ_FP_CAM_BIST_DBG_DATA_VALIDr
#define WRITE_FP_CAM_BIST_DBG_DATA_VALIDr BCM53324_A0_WRITE_FP_CAM_BIST_DBG_DATA_VALIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_CAM_BIST_DBG_DATA_VALIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_COUNTER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     COUNTER TABLE FOR THE FP. Indexed using counter_index from policy_table.
 * SIZE:     32
 * FIELDS:
 *     COUNTER          COUNTER
 *
 ******************************************************************************/
#define BCM53324_A0_FP_COUNTER_TABLEm 0x0d770000

#define BCM53324_A0_FP_COUNTER_TABLEm_MIN 0
#define BCM53324_A0_FP_COUNTER_TABLEm_MAX 511
#define BCM53324_A0_FP_COUNTER_TABLEm_CMAX(u) 511
#define BCM53324_A0_FP_COUNTER_TABLEm_SIZE 4

/*
 * This structure should be used to declare and program FP_COUNTER_TABLE.
 *
 */
typedef union BCM53324_A0_FP_COUNTER_TABLEm_s {
	uint32_t v[1];
	uint32_t fp_counter_table[1];
	uint32_t _fp_counter_table;
} BCM53324_A0_FP_COUNTER_TABLEm_t;

#define BCM53324_A0_FP_COUNTER_TABLEm_CLR(r) (r).fp_counter_table[0] = 0
#define BCM53324_A0_FP_COUNTER_TABLEm_SET(r,d) (r).fp_counter_table[0] = d
#define BCM53324_A0_FP_COUNTER_TABLEm_GET(r) (r).fp_counter_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_COUNTER_TABLEm_COUNTERf_GET(r) ((r).fp_counter_table[0])
#define BCM53324_A0_FP_COUNTER_TABLEm_COUNTERf_SET(r,f) (r).fp_counter_table[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_COUNTER_TABLE.
 *
 */
#define BCM53324_A0_READ_FP_COUNTER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_COUNTER_TABLEm,i,(m._fp_counter_table),1)
#define BCM53324_A0_WRITE_FP_COUNTER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_COUNTER_TABLEm,i,&(m._fp_counter_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_COUNTER_TABLEm BCM53324_A0_FP_COUNTER_TABLEm
#define FP_COUNTER_TABLEm_MIN BCM53324_A0_FP_COUNTER_TABLEm_MIN
#define FP_COUNTER_TABLEm_MAX BCM53324_A0_FP_COUNTER_TABLEm_MAX
#define FP_COUNTER_TABLEm_CMAX(u) BCM53324_A0_FP_COUNTER_TABLEm_CMAX(u)
#define FP_COUNTER_TABLEm_SIZE BCM53324_A0_FP_COUNTER_TABLEm_SIZE
typedef BCM53324_A0_FP_COUNTER_TABLEm_t FP_COUNTER_TABLEm_t;
#define FP_COUNTER_TABLEm_CLR BCM53324_A0_FP_COUNTER_TABLEm_CLR
#define FP_COUNTER_TABLEm_SET BCM53324_A0_FP_COUNTER_TABLEm_SET
#define FP_COUNTER_TABLEm_GET BCM53324_A0_FP_COUNTER_TABLEm_GET
#define FP_COUNTER_TABLEm_COUNTERf_GET BCM53324_A0_FP_COUNTER_TABLEm_COUNTERf_GET
#define FP_COUNTER_TABLEm_COUNTERf_SET BCM53324_A0_FP_COUNTER_TABLEm_COUNTERf_SET
#define READ_FP_COUNTER_TABLEm BCM53324_A0_READ_FP_COUNTER_TABLEm
#define WRITE_FP_COUNTER_TABLEm BCM53324_A0_WRITE_FP_COUNTER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_COUNTER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FP_METER_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     FP_METER_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PACKET_IFG_BYTES BYTES TO ADD IN ADDITION TO THE PACKET BYTE COUNT FOR METERING
 *
 ******************************************************************************/
#define BCM53324_A0_FP_METER_CONTROLr 0x0d780008

#define BCM53324_A0_FP_METER_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FP_METER_CONTROL.
 *
 */
typedef union BCM53324_A0_FP_METER_CONTROLr_s {
	uint32_t v[1];
	uint32_t fp_meter_control[1];
	uint32_t _fp_meter_control;
} BCM53324_A0_FP_METER_CONTROLr_t;

#define BCM53324_A0_FP_METER_CONTROLr_CLR(r) (r).fp_meter_control[0] = 0
#define BCM53324_A0_FP_METER_CONTROLr_SET(r,d) (r).fp_meter_control[0] = d
#define BCM53324_A0_FP_METER_CONTROLr_GET(r) (r).fp_meter_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET(r) (((r).fp_meter_control[0]) & 0x1f)
#define BCM53324_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET(r,f) (r).fp_meter_control[0]=(((r).fp_meter_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access FP_METER_CONTROL.
 *
 */
#define BCM53324_A0_READ_FP_METER_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_FP_METER_CONTROLr,(r._fp_meter_control))
#define BCM53324_A0_WRITE_FP_METER_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_FP_METER_CONTROLr,&(r._fp_meter_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_METER_CONTROLr BCM53324_A0_FP_METER_CONTROLr
#define FP_METER_CONTROLr_SIZE BCM53324_A0_FP_METER_CONTROLr_SIZE
typedef BCM53324_A0_FP_METER_CONTROLr_t FP_METER_CONTROLr_t;
#define FP_METER_CONTROLr_CLR BCM53324_A0_FP_METER_CONTROLr_CLR
#define FP_METER_CONTROLr_SET BCM53324_A0_FP_METER_CONTROLr_SET
#define FP_METER_CONTROLr_GET BCM53324_A0_FP_METER_CONTROLr_GET
#define FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET BCM53324_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET
#define FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET BCM53324_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET
#define READ_FP_METER_CONTROLr BCM53324_A0_READ_FP_METER_CONTROLr
#define WRITE_FP_METER_CONTROLr BCM53324_A0_WRITE_FP_METER_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_METER_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     METER TABLE STRUCTURES FOR THE FP. Indexed using meter_index from policy_table.
 * SIZE:     54
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *     REFRESH_MODE     REFRESH_MODE
 *
 ******************************************************************************/
#define BCM53324_A0_FP_METER_TABLEm 0x0d760000

#define BCM53324_A0_FP_METER_TABLEm_MIN 0
#define BCM53324_A0_FP_METER_TABLEm_MAX 511
#define BCM53324_A0_FP_METER_TABLEm_CMAX(u) 511
#define BCM53324_A0_FP_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_METER_TABLE.
 *
 */
typedef union BCM53324_A0_FP_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_meter_table[2];
	uint32_t _fp_meter_table;
} BCM53324_A0_FP_METER_TABLEm_t;

#define BCM53324_A0_FP_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_meter_table), 0, sizeof(BCM53324_A0_FP_METER_TABLEm_t))
#define BCM53324_A0_FP_METER_TABLEm_SET(r,i,d) (r).fp_meter_table[i] = d
#define BCM53324_A0_FP_METER_TABLEm_GET(r,i) (r).fp_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_meter_table[0]) & 0x3fffffff)
#define BCM53324_A0_FP_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_meter_table[0]=(((r).fp_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM53324_A0_FP_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_meter_table,30,33)
#define BCM53324_A0_FP_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_meter_table,30,33,f)
#define BCM53324_A0_FP_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_meter_table[1]) >> 2) & 0x7ffff)
#define BCM53324_A0_FP_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))
#define BCM53324_A0_FP_METER_TABLEm_REFRESH_MODEf_GET(r) ((((r).fp_meter_table[1]) >> 21) & 0x1)
#define BCM53324_A0_FP_METER_TABLEm_REFRESH_MODEf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))

/*
 * These macros can be used to access FP_METER_TABLE.
 *
 */
#define BCM53324_A0_READ_FP_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_METER_TABLEm,i,(m._fp_meter_table),2)
#define BCM53324_A0_WRITE_FP_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_METER_TABLEm,i,&(m._fp_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_METER_TABLEm BCM53324_A0_FP_METER_TABLEm
#define FP_METER_TABLEm_MIN BCM53324_A0_FP_METER_TABLEm_MIN
#define FP_METER_TABLEm_MAX BCM53324_A0_FP_METER_TABLEm_MAX
#define FP_METER_TABLEm_CMAX(u) BCM53324_A0_FP_METER_TABLEm_CMAX(u)
#define FP_METER_TABLEm_SIZE BCM53324_A0_FP_METER_TABLEm_SIZE
typedef BCM53324_A0_FP_METER_TABLEm_t FP_METER_TABLEm_t;
#define FP_METER_TABLEm_CLR BCM53324_A0_FP_METER_TABLEm_CLR
#define FP_METER_TABLEm_SET BCM53324_A0_FP_METER_TABLEm_SET
#define FP_METER_TABLEm_GET BCM53324_A0_FP_METER_TABLEm_GET
#define FP_METER_TABLEm_BUCKETCOUNTf_GET BCM53324_A0_FP_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_METER_TABLEm_BUCKETCOUNTf_SET BCM53324_A0_FP_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_METER_TABLEm_BUCKETSIZEf_GET BCM53324_A0_FP_METER_TABLEm_BUCKETSIZEf_GET
#define FP_METER_TABLEm_BUCKETSIZEf_SET BCM53324_A0_FP_METER_TABLEm_BUCKETSIZEf_SET
#define FP_METER_TABLEm_REFRESHCOUNTf_GET BCM53324_A0_FP_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_METER_TABLEm_REFRESHCOUNTf_SET BCM53324_A0_FP_METER_TABLEm_REFRESHCOUNTf_SET
#define FP_METER_TABLEm_REFRESH_MODEf_GET BCM53324_A0_FP_METER_TABLEm_REFRESH_MODEf_GET
#define FP_METER_TABLEm_REFRESH_MODEf_SET BCM53324_A0_FP_METER_TABLEm_REFRESH_MODEf_SET
#define READ_FP_METER_TABLEm BCM53324_A0_READ_FP_METER_TABLEm
#define WRITE_FP_METER_TABLEm BCM53324_A0_WRITE_FP_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FP_POLICY_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     FP_POLICY_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit. Here the bit 0 is for slice 0 bit 1 for slice 1 and so on
 *     PARITY_EN        This bit enables parity checking for the FP_POLICY table for each of the slices bit 16 is for slice 0, bit 17 for slice 1 etc.
 *
 ******************************************************************************/
#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr 0x0d78000d

#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FP_POLICY_PARITY_CONTROL.
 *
 */
typedef union BCM53324_A0_FP_POLICY_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t fp_policy_parity_control[1];
	uint32_t _fp_policy_parity_control;
} BCM53324_A0_FP_POLICY_PARITY_CONTROLr_t;

#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr_CLR(r) (r).fp_policy_parity_control[0] = 0
#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr_SET(r,d) (r).fp_policy_parity_control[0] = d
#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr_GET(r) (r).fp_policy_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).fp_policy_parity_control[0]) & 0xf)
#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).fp_policy_parity_control[0]=(((r).fp_policy_parity_control[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).fp_policy_parity_control[0]) >> 4) & 0xf)
#define BCM53324_A0_FP_POLICY_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).fp_policy_parity_control[0]=(((r).fp_policy_parity_control[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access FP_POLICY_PARITY_CONTROL.
 *
 */
#define BCM53324_A0_READ_FP_POLICY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_FP_POLICY_PARITY_CONTROLr,(r._fp_policy_parity_control))
#define BCM53324_A0_WRITE_FP_POLICY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_FP_POLICY_PARITY_CONTROLr,&(r._fp_policy_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_POLICY_PARITY_CONTROLr BCM53324_A0_FP_POLICY_PARITY_CONTROLr
#define FP_POLICY_PARITY_CONTROLr_SIZE BCM53324_A0_FP_POLICY_PARITY_CONTROLr_SIZE
typedef BCM53324_A0_FP_POLICY_PARITY_CONTROLr_t FP_POLICY_PARITY_CONTROLr_t;
#define FP_POLICY_PARITY_CONTROLr_CLR BCM53324_A0_FP_POLICY_PARITY_CONTROLr_CLR
#define FP_POLICY_PARITY_CONTROLr_SET BCM53324_A0_FP_POLICY_PARITY_CONTROLr_SET
#define FP_POLICY_PARITY_CONTROLr_GET BCM53324_A0_FP_POLICY_PARITY_CONTROLr_GET
#define FP_POLICY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM53324_A0_FP_POLICY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define FP_POLICY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM53324_A0_FP_POLICY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define FP_POLICY_PARITY_CONTROLr_PARITY_ENf_GET BCM53324_A0_FP_POLICY_PARITY_CONTROLr_PARITY_ENf_GET
#define FP_POLICY_PARITY_CONTROLr_PARITY_ENf_SET BCM53324_A0_FP_POLICY_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_FP_POLICY_PARITY_CONTROLr BCM53324_A0_READ_FP_POLICY_PARITY_CONTROLr
#define WRITE_FP_POLICY_PARITY_CONTROLr BCM53324_A0_WRITE_FP_POLICY_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_POLICY_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FP_POLICY_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_POLICY_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected, bit 0 is for slice 0 bit 1 for slice 1 and so on.
 *     MEMORY_IDX       This field indicates the index to the bucket in which the parity error was detected.
 *     SLICE_IDX        This field indicates the slice in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr 0x0d78000e

#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_POLICY_PARITY_STATUS.
 *
 */
typedef union BCM53324_A0_FP_POLICY_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_policy_parity_status[1];
	uint32_t _fp_policy_parity_status;
} BCM53324_A0_FP_POLICY_PARITY_STATUSr_t;

#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_CLR(r) (r).fp_policy_parity_status[0] = 0
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_SET(r,d) (r).fp_policy_parity_status[0] = d
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_GET(r) (r).fp_policy_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).fp_policy_parity_status[0]) & 0x1)
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).fp_policy_parity_status[0]=(((r).fp_policy_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_MEMORY_IDXf_GET(r) ((((r).fp_policy_parity_status[0]) >> 1) & 0x7f)
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_MEMORY_IDXf_SET(r,f) (r).fp_policy_parity_status[0]=(((r).fp_policy_parity_status[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_SLICE_IDXf_GET(r) ((((r).fp_policy_parity_status[0]) >> 8) & 0xf)
#define BCM53324_A0_FP_POLICY_PARITY_STATUSr_SLICE_IDXf_SET(r,f) (r).fp_policy_parity_status[0]=(((r).fp_policy_parity_status[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))

/*
 * These macros can be used to access FP_POLICY_PARITY_STATUS.
 *
 */
#define BCM53324_A0_READ_FP_POLICY_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_FP_POLICY_PARITY_STATUSr,(r._fp_policy_parity_status))
#define BCM53324_A0_WRITE_FP_POLICY_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_FP_POLICY_PARITY_STATUSr,&(r._fp_policy_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_POLICY_PARITY_STATUSr BCM53324_A0_FP_POLICY_PARITY_STATUSr
#define FP_POLICY_PARITY_STATUSr_SIZE BCM53324_A0_FP_POLICY_PARITY_STATUSr_SIZE
typedef BCM53324_A0_FP_POLICY_PARITY_STATUSr_t FP_POLICY_PARITY_STATUSr_t;
#define FP_POLICY_PARITY_STATUSr_CLR BCM53324_A0_FP_POLICY_PARITY_STATUSr_CLR
#define FP_POLICY_PARITY_STATUSr_SET BCM53324_A0_FP_POLICY_PARITY_STATUSr_SET
#define FP_POLICY_PARITY_STATUSr_GET BCM53324_A0_FP_POLICY_PARITY_STATUSr_GET
#define FP_POLICY_PARITY_STATUSr_PARITY_ERRf_GET BCM53324_A0_FP_POLICY_PARITY_STATUSr_PARITY_ERRf_GET
#define FP_POLICY_PARITY_STATUSr_PARITY_ERRf_SET BCM53324_A0_FP_POLICY_PARITY_STATUSr_PARITY_ERRf_SET
#define FP_POLICY_PARITY_STATUSr_MEMORY_IDXf_GET BCM53324_A0_FP_POLICY_PARITY_STATUSr_MEMORY_IDXf_GET
#define FP_POLICY_PARITY_STATUSr_MEMORY_IDXf_SET BCM53324_A0_FP_POLICY_PARITY_STATUSr_MEMORY_IDXf_SET
#define FP_POLICY_PARITY_STATUSr_SLICE_IDXf_GET BCM53324_A0_FP_POLICY_PARITY_STATUSr_SLICE_IDXf_GET
#define FP_POLICY_PARITY_STATUSr_SLICE_IDXf_SET BCM53324_A0_FP_POLICY_PARITY_STATUSr_SLICE_IDXf_SET
#define READ_FP_POLICY_PARITY_STATUSr BCM53324_A0_READ_FP_POLICY_PARITY_STATUSr
#define WRITE_FP_POLICY_PARITY_STATUSr BCM53324_A0_WRITE_FP_POLICY_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_POLICY_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_POLICY_TABLE
 * BLOCKS:   IPIPE
 * DESC:     POLICY TABLE FOR DETERMINING ACTIONS IN THE FP. Indexed using the final match address in the FP TCAM.
 * SIZE:     159
 * FIELDS:
 *     EM_MTP_INDEX     EM_MTP_INDEX
 *     IM_MTP_INDEX     IM_MTP_INDEX
 *     MTP_INDEX_SPARE  MTP_INDEX_SPARE
 *     REDIRECTION      REDIRECTION
 *     REDIRECTION_LO   REDIRECTION
 *     CHAIN_INDEX      CHAIN_INDEX
 *     CHAIN_VALID      CHAIN_VALID
 *     CLASSIFICATION_TAG CLASSIFICATION_TAG. Obsolete as there is no HG support.
 *     ECMP_PTR         ECMP_PTR
 *     NEXT_HOP_INDEX   NEXT_HOP_INDEX
 *     MATCHED_RULE     MATCHED_RULE
 *     ECMP_COUNT       ECMP_COUNT
 *     ECMP             ECMP
 *     DO_NOT_CHANGE_TTL DO_NOT_CHANGE_TTL
 *     YP_DSCP          YP_DSCP
 *     RP_DSCP          RP_DSCP
 *     NEWDSCP_TOS      NEWDSCP_TOS
 *     NEWPRI           NEWPRI for green coloured packets
 *     METER_PAIR_MODE  METER_PAIR_MODE
 *     METER_TEST_EVEN  METER_TEST_EVEN
 *     METER_TEST_ODD   METER_TEST_ODD
 *     METER_UPDATE_EVEN METER_UPDATE_EVEN
 *     METER_UPDATE_ODD METER_UPDATE_ODD
 *     METER_INDEX_EVEN METER_INDEX_EVEN
 *     METER_INDEX_ODD  METER_INDEX_ODD
 *     COUNTER_MODE     COUNTER_MODE
 *     COUNTER_INDEX    COUNTER_INDEX
 *     YP_CHANGE_DSCP   YP_CHANGE_DSCP
 *     YP_COPY_TO_CPU   YP_COPY_TO_CPU
 *     YP_DROP_PRECEDENCE YP_DROP_PRECEDENCE
 *     YP_DROP          YP_DROP
 *     RP_CHANGE_DSCP   RP_CHANGE_DSCP
 *     RP_COPY_TO_CPU   RP_COPY_TO_CPU
 *     RP_DROP_PRECEDENCE RP_DROP_PRECEDENCE
 *     RP_DROP          RP_DROP
 *     DROP_PRECEDENCE  DROP_PRECEDENCE
 *     L3SW_CHANGE_MACDA_OR_VLAN L3SW_CHANGE_MACDA_OR_VLAN
 *     MIRROR           MIRROR
 *     MIRROR_OVERRIDE  CONTROLS OVERRIDING MIRROR PROCESSING IN SW2 STAGE
 *     DROP             DROP
 *     CHAIN            CHAIN
 *     PACKET_REDIRECTION PACKET_REDIRECTION
 *     COPY_TO_CPU      COPY_TO_CPU
 *     CHANGE_DSCP_TOS  CHANGE_DSCP_TOS
 *     CHANGE_PRIORITY  CHANGE_PRIORITY
 *     ECN_CNG          CONTROL WHETHER DROP PRECEDENCE SETS ECN OR CNG BITS
 *     GREEN_TO_PID     GREEN_TO_PID CONTROLS WHETHER PACKET_REDIRECTION and L3SW_CHANGE_MACDA_OR_VLAN  are Green (0) or Color Independent (1) actions
 *     RP_NEWPRI        New priority for red coloured packets
 *     YP_NEWPRI        New priority for yellow coloured packets
 *     RP_CHANGE_PRIORITY CHANGE_PRIORITY encode for red colored packets
 *     YP_CHANGE_PRIORITY CHANGE_PRIORITY encode for yellow colored packets
 *     PRI_MODE         For Backward compatibilty, If set to 0, change_priority works as before, If set to 1, color based remarking of the pri will take place
 *     EVEN_PARITY      Even parity for the FP_POLICY_TABLE RAM fields
 *
 ******************************************************************************/
#define BCM53324_A0_FP_POLICY_TABLEm 0x0d750000

#define BCM53324_A0_FP_POLICY_TABLEm_MIN 0
#define BCM53324_A0_FP_POLICY_TABLEm_MAX 511
#define BCM53324_A0_FP_POLICY_TABLEm_CMAX(u) 511
#define BCM53324_A0_FP_POLICY_TABLEm_SIZE 20

/*
 * This structure should be used to declare and program FP_POLICY_TABLE.
 *
 */
typedef union BCM53324_A0_FP_POLICY_TABLEm_s {
	uint32_t v[5];
	uint32_t fp_policy_table[5];
	uint32_t _fp_policy_table;
} BCM53324_A0_FP_POLICY_TABLEm_t;

#define BCM53324_A0_FP_POLICY_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_policy_table), 0, sizeof(BCM53324_A0_FP_POLICY_TABLEm_t))
#define BCM53324_A0_FP_POLICY_TABLEm_SET(r,i,d) (r).fp_policy_table[i] = d
#define BCM53324_A0_FP_POLICY_TABLEm_GET(r,i) (r).fp_policy_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_GET(r) (((r).fp_policy_table[0]) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_GET(r) ((((r).fp_policy_table[0]) >> 2) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET(r) ((((r).fp_policy_table[0]) >> 4) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_FP_POLICY_TABLEm_REDIRECTIONf_GET(r) cdk_field32_get((r).fp_policy_table,5,34)
#define BCM53324_A0_FP_POLICY_TABLEm_REDIRECTIONf_SET(r,f) cdk_field32_set((r).fp_policy_table,5,34,f)
#define BCM53324_A0_FP_POLICY_TABLEm_REDIRECTION_LOf_GET(r) cdk_field32_get((r).fp_policy_table,5,34)
#define BCM53324_A0_FP_POLICY_TABLEm_REDIRECTION_LOf_SET(r,f) cdk_field32_set((r).fp_policy_table,5,34,f)
#define BCM53324_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_GET(r) cdk_field32_get((r).fp_policy_table,27,33)
#define BCM53324_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_SET(r,f) cdk_field32_set((r).fp_policy_table,27,33,f)
#define BCM53324_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_GET(r) ((((r).fp_policy_table[1]) >> 2) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET(r) ((((r).fp_policy_table[1]) >> 3) & 0x7ff)
#define BCM53324_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x7ff << 3)) | ((((uint32_t)f) & 0x7ff) << 3))
#define BCM53324_A0_FP_POLICY_TABLEm_ECMP_PTRf_GET(r) ((((r).fp_policy_table[1]) >> 3) & 0x7ff)
#define BCM53324_A0_FP_POLICY_TABLEm_ECMP_PTRf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x7ff << 3)) | ((((uint32_t)f) & 0x7ff) << 3))
#define BCM53324_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET(r) ((((r).fp_policy_table[1]) >> 3) & 0x7ff)
#define BCM53324_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x7ff << 3)) | ((((uint32_t)f) & 0x7ff) << 3))
#define BCM53324_A0_FP_POLICY_TABLEm_MATCHED_RULEf_GET(r) ((((r).fp_policy_table[1]) >> 14) & 0xff)
#define BCM53324_A0_FP_POLICY_TABLEm_MATCHED_RULEf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0xff << 14)) | ((((uint32_t)f) & 0xff) << 14))
#define BCM53324_A0_FP_POLICY_TABLEm_ECMP_COUNTf_GET(r) ((((r).fp_policy_table[1]) >> 14) & 0x1f)
#define BCM53324_A0_FP_POLICY_TABLEm_ECMP_COUNTf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM53324_A0_FP_POLICY_TABLEm_ECMPf_GET(r) ((((r).fp_policy_table[1]) >> 19) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_ECMPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET(r) ((((r).fp_policy_table[1]) >> 21) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_FP_POLICY_TABLEm_YP_DSCPf_GET(r) ((((r).fp_policy_table[1]) >> 22) & 0x3f)
#define BCM53324_A0_FP_POLICY_TABLEm_YP_DSCPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x3f << 22)) | ((((uint32_t)f) & 0x3f) << 22))
#define BCM53324_A0_FP_POLICY_TABLEm_RP_DSCPf_GET(r) cdk_field32_get((r).fp_policy_table,60,65)
#define BCM53324_A0_FP_POLICY_TABLEm_RP_DSCPf_SET(r,f) cdk_field32_set((r).fp_policy_table,60,65,f)
#define BCM53324_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_GET(r) ((((r).fp_policy_table[2]) >> 2) & 0x3f)
#define BCM53324_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM53324_A0_FP_POLICY_TABLEm_NEWPRIf_GET(r) ((((r).fp_policy_table[2]) >> 8) & 0x7)
#define BCM53324_A0_FP_POLICY_TABLEm_NEWPRIf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53324_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_GET(r) ((((r).fp_policy_table[2]) >> 11) & 0x7)
#define BCM53324_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53324_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 14) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 15) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 16) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 17) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 18) & 0x3f)
#define BCM53324_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 24) & 0x3f)
#define BCM53324_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53324_A0_FP_POLICY_TABLEm_COUNTER_MODEf_GET(r) cdk_field32_get((r).fp_policy_table,94,97)
#define BCM53324_A0_FP_POLICY_TABLEm_COUNTER_MODEf_SET(r,f) cdk_field32_set((r).fp_policy_table,94,97,f)
#define BCM53324_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_GET(r) ((((r).fp_policy_table[3]) >> 2) & 0x3f)
#define BCM53324_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM53324_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[3]) >> 8) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[3]) >> 9) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53324_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 11) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53324_A0_FP_POLICY_TABLEm_YP_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 13) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_YP_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53324_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[3]) >> 15) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[3]) >> 16) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53324_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 18) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53324_A0_FP_POLICY_TABLEm_RP_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 20) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_RP_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53324_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 22) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53324_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET(r) ((((r).fp_policy_table[3]) >> 24) & 0x7)
#define BCM53324_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53324_A0_FP_POLICY_TABLEm_MIRRORf_GET(r) ((((r).fp_policy_table[3]) >> 27) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_MIRRORf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 27)) | ((((uint32_t)f) & 0x3) << 27))
#define BCM53324_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET(r) ((((r).fp_policy_table[3]) >> 29) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_FP_POLICY_TABLEm_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 30) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53324_A0_FP_POLICY_TABLEm_CHAINf_GET(r) (((r).fp_policy_table[4]) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_CHAINf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET(r) ((((r).fp_policy_table[4]) >> 1) & 0x7)
#define BCM53324_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53324_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[4]) >> 4) & 0x3)
#define BCM53324_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET(r) ((((r).fp_policy_table[4]) >> 6) & 0x7)
#define BCM53324_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53324_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET(r) ((((r).fp_policy_table[4]) >> 9) & 0xf)
#define BCM53324_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53324_A0_FP_POLICY_TABLEm_ECN_CNGf_GET(r) ((((r).fp_policy_table[4]) >> 13) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_ECN_CNGf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_GET(r) ((((r).fp_policy_table[4]) >> 14) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_FP_POLICY_TABLEm_RP_NEWPRIf_GET(r) ((((r).fp_policy_table[4]) >> 15) & 0x7)
#define BCM53324_A0_FP_POLICY_TABLEm_RP_NEWPRIf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53324_A0_FP_POLICY_TABLEm_YP_NEWPRIf_GET(r) ((((r).fp_policy_table[4]) >> 18) & 0x7)
#define BCM53324_A0_FP_POLICY_TABLEm_YP_NEWPRIf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53324_A0_FP_POLICY_TABLEm_RP_CHANGE_PRIORITYf_GET(r) ((((r).fp_policy_table[4]) >> 21) & 0xf)
#define BCM53324_A0_FP_POLICY_TABLEm_RP_CHANGE_PRIORITYf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM53324_A0_FP_POLICY_TABLEm_YP_CHANGE_PRIORITYf_GET(r) ((((r).fp_policy_table[4]) >> 25) & 0xf)
#define BCM53324_A0_FP_POLICY_TABLEm_YP_CHANGE_PRIORITYf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0xf << 25)) | ((((uint32_t)f) & 0xf) << 25))
#define BCM53324_A0_FP_POLICY_TABLEm_PRI_MODEf_GET(r) ((((r).fp_policy_table[4]) >> 29) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_PRI_MODEf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_FP_POLICY_TABLEm_EVEN_PARITYf_GET(r) ((((r).fp_policy_table[4]) >> 30) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLEm_EVEN_PARITYf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))

/*
 * These macros can be used to access FP_POLICY_TABLE.
 *
 */
#define BCM53324_A0_READ_FP_POLICY_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_POLICY_TABLEm,i,(m._fp_policy_table),5)
#define BCM53324_A0_WRITE_FP_POLICY_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_POLICY_TABLEm,i,&(m._fp_policy_table),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_POLICY_TABLEm BCM53324_A0_FP_POLICY_TABLEm
#define FP_POLICY_TABLEm_MIN BCM53324_A0_FP_POLICY_TABLEm_MIN
#define FP_POLICY_TABLEm_MAX BCM53324_A0_FP_POLICY_TABLEm_MAX
#define FP_POLICY_TABLEm_CMAX(u) BCM53324_A0_FP_POLICY_TABLEm_CMAX(u)
#define FP_POLICY_TABLEm_SIZE BCM53324_A0_FP_POLICY_TABLEm_SIZE
typedef BCM53324_A0_FP_POLICY_TABLEm_t FP_POLICY_TABLEm_t;
#define FP_POLICY_TABLEm_CLR BCM53324_A0_FP_POLICY_TABLEm_CLR
#define FP_POLICY_TABLEm_SET BCM53324_A0_FP_POLICY_TABLEm_SET
#define FP_POLICY_TABLEm_GET BCM53324_A0_FP_POLICY_TABLEm_GET
#define FP_POLICY_TABLEm_EM_MTP_INDEXf_GET BCM53324_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_GET
#define FP_POLICY_TABLEm_EM_MTP_INDEXf_SET BCM53324_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_SET
#define FP_POLICY_TABLEm_IM_MTP_INDEXf_GET BCM53324_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_GET
#define FP_POLICY_TABLEm_IM_MTP_INDEXf_SET BCM53324_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_SET
#define FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET BCM53324_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET
#define FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET BCM53324_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET
#define FP_POLICY_TABLEm_REDIRECTIONf_GET BCM53324_A0_FP_POLICY_TABLEm_REDIRECTIONf_GET
#define FP_POLICY_TABLEm_REDIRECTIONf_SET BCM53324_A0_FP_POLICY_TABLEm_REDIRECTIONf_SET
#define FP_POLICY_TABLEm_REDIRECTION_LOf_GET BCM53324_A0_FP_POLICY_TABLEm_REDIRECTION_LOf_GET
#define FP_POLICY_TABLEm_REDIRECTION_LOf_SET BCM53324_A0_FP_POLICY_TABLEm_REDIRECTION_LOf_SET
#define FP_POLICY_TABLEm_CHAIN_INDEXf_GET BCM53324_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_GET
#define FP_POLICY_TABLEm_CHAIN_INDEXf_SET BCM53324_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_SET
#define FP_POLICY_TABLEm_CHAIN_VALIDf_GET BCM53324_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_GET
#define FP_POLICY_TABLEm_CHAIN_VALIDf_SET BCM53324_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_SET
#define FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET BCM53324_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET
#define FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET BCM53324_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET
#define FP_POLICY_TABLEm_ECMP_PTRf_GET BCM53324_A0_FP_POLICY_TABLEm_ECMP_PTRf_GET
#define FP_POLICY_TABLEm_ECMP_PTRf_SET BCM53324_A0_FP_POLICY_TABLEm_ECMP_PTRf_SET
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET BCM53324_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET BCM53324_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET
#define FP_POLICY_TABLEm_MATCHED_RULEf_GET BCM53324_A0_FP_POLICY_TABLEm_MATCHED_RULEf_GET
#define FP_POLICY_TABLEm_MATCHED_RULEf_SET BCM53324_A0_FP_POLICY_TABLEm_MATCHED_RULEf_SET
#define FP_POLICY_TABLEm_ECMP_COUNTf_GET BCM53324_A0_FP_POLICY_TABLEm_ECMP_COUNTf_GET
#define FP_POLICY_TABLEm_ECMP_COUNTf_SET BCM53324_A0_FP_POLICY_TABLEm_ECMP_COUNTf_SET
#define FP_POLICY_TABLEm_ECMPf_GET BCM53324_A0_FP_POLICY_TABLEm_ECMPf_GET
#define FP_POLICY_TABLEm_ECMPf_SET BCM53324_A0_FP_POLICY_TABLEm_ECMPf_SET
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET BCM53324_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET BCM53324_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET
#define FP_POLICY_TABLEm_YP_DSCPf_GET BCM53324_A0_FP_POLICY_TABLEm_YP_DSCPf_GET
#define FP_POLICY_TABLEm_YP_DSCPf_SET BCM53324_A0_FP_POLICY_TABLEm_YP_DSCPf_SET
#define FP_POLICY_TABLEm_RP_DSCPf_GET BCM53324_A0_FP_POLICY_TABLEm_RP_DSCPf_GET
#define FP_POLICY_TABLEm_RP_DSCPf_SET BCM53324_A0_FP_POLICY_TABLEm_RP_DSCPf_SET
#define FP_POLICY_TABLEm_NEWDSCP_TOSf_GET BCM53324_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_GET
#define FP_POLICY_TABLEm_NEWDSCP_TOSf_SET BCM53324_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_SET
#define FP_POLICY_TABLEm_NEWPRIf_GET BCM53324_A0_FP_POLICY_TABLEm_NEWPRIf_GET
#define FP_POLICY_TABLEm_NEWPRIf_SET BCM53324_A0_FP_POLICY_TABLEm_NEWPRIf_SET
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_GET BCM53324_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_GET
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_SET BCM53324_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_SET
#define FP_POLICY_TABLEm_METER_TEST_EVENf_GET BCM53324_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_GET
#define FP_POLICY_TABLEm_METER_TEST_EVENf_SET BCM53324_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_SET
#define FP_POLICY_TABLEm_METER_TEST_ODDf_GET BCM53324_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_GET
#define FP_POLICY_TABLEm_METER_TEST_ODDf_SET BCM53324_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_SET
#define FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET BCM53324_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET
#define FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET BCM53324_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET
#define FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET BCM53324_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET
#define FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET BCM53324_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET
#define FP_POLICY_TABLEm_METER_INDEX_EVENf_GET BCM53324_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_GET
#define FP_POLICY_TABLEm_METER_INDEX_EVENf_SET BCM53324_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_SET
#define FP_POLICY_TABLEm_METER_INDEX_ODDf_GET BCM53324_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_GET
#define FP_POLICY_TABLEm_METER_INDEX_ODDf_SET BCM53324_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_SET
#define FP_POLICY_TABLEm_COUNTER_MODEf_GET BCM53324_A0_FP_POLICY_TABLEm_COUNTER_MODEf_GET
#define FP_POLICY_TABLEm_COUNTER_MODEf_SET BCM53324_A0_FP_POLICY_TABLEm_COUNTER_MODEf_SET
#define FP_POLICY_TABLEm_COUNTER_INDEXf_GET BCM53324_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_GET
#define FP_POLICY_TABLEm_COUNTER_INDEXf_SET BCM53324_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_SET
#define FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET BCM53324_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET
#define FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET BCM53324_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET
#define FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET BCM53324_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET BCM53324_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET BCM53324_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET BCM53324_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_YP_DROPf_GET BCM53324_A0_FP_POLICY_TABLEm_YP_DROPf_GET
#define FP_POLICY_TABLEm_YP_DROPf_SET BCM53324_A0_FP_POLICY_TABLEm_YP_DROPf_SET
#define FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET BCM53324_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET
#define FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET BCM53324_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET
#define FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET BCM53324_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET BCM53324_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET BCM53324_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET BCM53324_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_RP_DROPf_GET BCM53324_A0_FP_POLICY_TABLEm_RP_DROPf_GET
#define FP_POLICY_TABLEm_RP_DROPf_SET BCM53324_A0_FP_POLICY_TABLEm_RP_DROPf_SET
#define FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET BCM53324_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET BCM53324_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET BCM53324_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET
#define FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET BCM53324_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET
#define FP_POLICY_TABLEm_MIRRORf_GET BCM53324_A0_FP_POLICY_TABLEm_MIRRORf_GET
#define FP_POLICY_TABLEm_MIRRORf_SET BCM53324_A0_FP_POLICY_TABLEm_MIRRORf_SET
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET BCM53324_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET BCM53324_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET
#define FP_POLICY_TABLEm_DROPf_GET BCM53324_A0_FP_POLICY_TABLEm_DROPf_GET
#define FP_POLICY_TABLEm_DROPf_SET BCM53324_A0_FP_POLICY_TABLEm_DROPf_SET
#define FP_POLICY_TABLEm_CHAINf_GET BCM53324_A0_FP_POLICY_TABLEm_CHAINf_GET
#define FP_POLICY_TABLEm_CHAINf_SET BCM53324_A0_FP_POLICY_TABLEm_CHAINf_SET
#define FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET BCM53324_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET
#define FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET BCM53324_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET
#define FP_POLICY_TABLEm_COPY_TO_CPUf_GET BCM53324_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_COPY_TO_CPUf_SET BCM53324_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET BCM53324_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET
#define FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET BCM53324_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET
#define FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET BCM53324_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET
#define FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET BCM53324_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET
#define FP_POLICY_TABLEm_ECN_CNGf_GET BCM53324_A0_FP_POLICY_TABLEm_ECN_CNGf_GET
#define FP_POLICY_TABLEm_ECN_CNGf_SET BCM53324_A0_FP_POLICY_TABLEm_ECN_CNGf_SET
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_GET BCM53324_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_GET
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_SET BCM53324_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_SET
#define FP_POLICY_TABLEm_RP_NEWPRIf_GET BCM53324_A0_FP_POLICY_TABLEm_RP_NEWPRIf_GET
#define FP_POLICY_TABLEm_RP_NEWPRIf_SET BCM53324_A0_FP_POLICY_TABLEm_RP_NEWPRIf_SET
#define FP_POLICY_TABLEm_YP_NEWPRIf_GET BCM53324_A0_FP_POLICY_TABLEm_YP_NEWPRIf_GET
#define FP_POLICY_TABLEm_YP_NEWPRIf_SET BCM53324_A0_FP_POLICY_TABLEm_YP_NEWPRIf_SET
#define FP_POLICY_TABLEm_RP_CHANGE_PRIORITYf_GET BCM53324_A0_FP_POLICY_TABLEm_RP_CHANGE_PRIORITYf_GET
#define FP_POLICY_TABLEm_RP_CHANGE_PRIORITYf_SET BCM53324_A0_FP_POLICY_TABLEm_RP_CHANGE_PRIORITYf_SET
#define FP_POLICY_TABLEm_YP_CHANGE_PRIORITYf_GET BCM53324_A0_FP_POLICY_TABLEm_YP_CHANGE_PRIORITYf_GET
#define FP_POLICY_TABLEm_YP_CHANGE_PRIORITYf_SET BCM53324_A0_FP_POLICY_TABLEm_YP_CHANGE_PRIORITYf_SET
#define FP_POLICY_TABLEm_PRI_MODEf_GET BCM53324_A0_FP_POLICY_TABLEm_PRI_MODEf_GET
#define FP_POLICY_TABLEm_PRI_MODEf_SET BCM53324_A0_FP_POLICY_TABLEm_PRI_MODEf_SET
#define FP_POLICY_TABLEm_EVEN_PARITYf_GET BCM53324_A0_FP_POLICY_TABLEm_EVEN_PARITYf_GET
#define FP_POLICY_TABLEm_EVEN_PARITYf_SET BCM53324_A0_FP_POLICY_TABLEm_EVEN_PARITYf_SET
#define READ_FP_POLICY_TABLEm BCM53324_A0_READ_FP_POLICY_TABLEm
#define WRITE_FP_POLICY_TABLEm BCM53324_A0_WRITE_FP_POLICY_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_POLICY_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FP_POLICY_TABLE_TM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Test Mode bits for FP stage memories
 * SIZE:     32
 * FIELDS:
 *     FP_POLICY_TABLE_TM Test Mode bits for Ifp_policy_table memory 
 *     FP_POLICY_TABLE_WW Weak Write bits for Ifp_policy_table memory 
 *
 ******************************************************************************/
#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr 0x0d78000c

#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FP_POLICY_TABLE_TM_CONTROL.
 *
 */
typedef union BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_s {
	uint32_t v[1];
	uint32_t fp_policy_table_tm_control[1];
	uint32_t _fp_policy_table_tm_control;
} BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_t;

#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_CLR(r) (r).fp_policy_table_tm_control[0] = 0
#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_SET(r,d) (r).fp_policy_table_tm_control[0] = d
#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_GET(r) (r).fp_policy_table_tm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_TMf_GET(r) (((r).fp_policy_table_tm_control[0]) & 0xf)
#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_TMf_SET(r,f) (r).fp_policy_table_tm_control[0]=(((r).fp_policy_table_tm_control[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_WWf_GET(r) ((((r).fp_policy_table_tm_control[0]) >> 4) & 0x1)
#define BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_WWf_SET(r,f) (r).fp_policy_table_tm_control[0]=(((r).fp_policy_table_tm_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access FP_POLICY_TABLE_TM_CONTROL.
 *
 */
#define BCM53324_A0_READ_FP_POLICY_TABLE_TM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr,(r._fp_policy_table_tm_control))
#define BCM53324_A0_WRITE_FP_POLICY_TABLE_TM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr,&(r._fp_policy_table_tm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_POLICY_TABLE_TM_CONTROLr BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr
#define FP_POLICY_TABLE_TM_CONTROLr_SIZE BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_SIZE
typedef BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_t FP_POLICY_TABLE_TM_CONTROLr_t;
#define FP_POLICY_TABLE_TM_CONTROLr_CLR BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_CLR
#define FP_POLICY_TABLE_TM_CONTROLr_SET BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_SET
#define FP_POLICY_TABLE_TM_CONTROLr_GET BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_GET
#define FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_TMf_GET BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_TMf_GET
#define FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_TMf_SET BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_TMf_SET
#define FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_WWf_GET BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_WWf_GET
#define FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_WWf_SET BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr_FP_POLICY_TABLE_WWf_SET
#define READ_FP_POLICY_TABLE_TM_CONTROLr BCM53324_A0_READ_FP_POLICY_TABLE_TM_CONTROLr
#define WRITE_FP_POLICY_TABLE_TM_CONTROLr BCM53324_A0_WRITE_FP_POLICY_TABLE_TM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_POLICY_TABLE_TM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_PORT_FIELD_SEL
 * BLOCKS:   IPIPE
 * DESC:     FIELD SELECT VALUE FOR EACH SLICE IN THE FP. Indexed using either ingress port number or the index coming from UDF table for Packet based key selection feature. 
 * SIZE:     52
 * FIELDS:
 *     SLICE0_F1        F1 field for slice 0.
 *     SLICE0_F2        F2 field for slice 0
 *     SLICE0_F3        F3 field for slice 0
 *     SLICE0_F4        CONTROL for F4 selector for SLICE 1. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE1_F1        F1 field for slice 1.
 *     SLICE1_F2        F2 field for slice 1
 *     SLICE1_F3        F3 field for slice 1
 *     SLICE1_F4        CONTROL for F4 selector for SLICE 2. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT, 2= PKT BASED FLOW KEY
 *     SLICE2_F1        F1 field for slice 2.
 *     SLICE2_F2        F2 field for slice 2
 *     SLICE2_F3        F3 field for slice 2
 *     SLICE2_F4        CONTROL for F4 selector for SLICE 2. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT, 2= PKT BASED FLOW KEY
 *     SLICE3_F1        F1 field for slice 3.
 *     SLICE3_F2        F2 field for slice 3
 *     SLICE3_F3        F3 field for slice 3
 *     SLICE3_F4        CONTROL for F4 selector for SLICE 3. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT, 2= PKT BASED FLOW KEY
 *
 ******************************************************************************/
#define BCM53324_A0_FP_PORT_FIELD_SELm 0x0c700000

#define BCM53324_A0_FP_PORT_FIELD_SELm_MIN 0
#define BCM53324_A0_FP_PORT_FIELD_SELm_MAX 24
#define BCM53324_A0_FP_PORT_FIELD_SELm_CMAX(u) 24
#define BCM53324_A0_FP_PORT_FIELD_SELm_SIZE 7

/*
 * This structure should be used to declare and program FP_PORT_FIELD_SEL.
 *
 */
typedef union BCM53324_A0_FP_PORT_FIELD_SELm_s {
	uint32_t v[2];
	uint32_t fp_port_field_sel[2];
	uint32_t _fp_port_field_sel;
} BCM53324_A0_FP_PORT_FIELD_SELm_t;

#define BCM53324_A0_FP_PORT_FIELD_SELm_CLR(r) CDK_MEMSET(&((r)._fp_port_field_sel), 0, sizeof(BCM53324_A0_FP_PORT_FIELD_SELm_t))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SET(r,i,d) (r).fp_port_field_sel[i] = d
#define BCM53324_A0_FP_PORT_FIELD_SELm_GET(r,i) (r).fp_port_field_sel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_GET(r) (((r).fp_port_field_sel[0]) & 0xf)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 4) & 0xf)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 8) & 0x7)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F4f_GET(r) ((((r).fp_port_field_sel[0]) >> 11) & 0x3)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F4f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 13) & 0xf)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 13)) | ((((uint32_t)f) & 0xf) << 13))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 17) & 0xf)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 17)) | ((((uint32_t)f) & 0xf) << 17))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 21) & 0x7)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F4f_GET(r) ((((r).fp_port_field_sel[0]) >> 24) & 0x3)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F4f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 26) & 0xf)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 26)) | ((((uint32_t)f) & 0xf) << 26))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_GET(r) cdk_field32_get((r).fp_port_field_sel,30,33)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_SET(r,f) cdk_field32_set((r).fp_port_field_sel,30,33,f)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 2) & 0x7)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F4f_GET(r) ((((r).fp_port_field_sel[1]) >> 5) & 0x3)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F4f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 7) & 0xf)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 11) & 0xf)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 15) & 0x7)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F4f_GET(r) ((((r).fp_port_field_sel[1]) >> 18) & 0x3)
#define BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F4f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))

/*
 * These macros can be used to access FP_PORT_FIELD_SEL.
 *
 */
#define BCM53324_A0_READ_FP_PORT_FIELD_SELm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_PORT_FIELD_SELm,i,(m._fp_port_field_sel),2)
#define BCM53324_A0_WRITE_FP_PORT_FIELD_SELm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_PORT_FIELD_SELm,i,&(m._fp_port_field_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_PORT_FIELD_SELm BCM53324_A0_FP_PORT_FIELD_SELm
#define FP_PORT_FIELD_SELm_MIN BCM53324_A0_FP_PORT_FIELD_SELm_MIN
#define FP_PORT_FIELD_SELm_MAX BCM53324_A0_FP_PORT_FIELD_SELm_MAX
#define FP_PORT_FIELD_SELm_CMAX(u) BCM53324_A0_FP_PORT_FIELD_SELm_CMAX(u)
#define FP_PORT_FIELD_SELm_SIZE BCM53324_A0_FP_PORT_FIELD_SELm_SIZE
typedef BCM53324_A0_FP_PORT_FIELD_SELm_t FP_PORT_FIELD_SELm_t;
#define FP_PORT_FIELD_SELm_CLR BCM53324_A0_FP_PORT_FIELD_SELm_CLR
#define FP_PORT_FIELD_SELm_SET BCM53324_A0_FP_PORT_FIELD_SELm_SET
#define FP_PORT_FIELD_SELm_GET BCM53324_A0_FP_PORT_FIELD_SELm_GET
#define FP_PORT_FIELD_SELm_SLICE0_F1f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F1f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F2f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F2f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F3f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F3f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F4f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F4f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE0_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F1f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F1f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F2f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F2f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F3f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F3f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F4f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F4f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE1_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F1f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F1f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F2f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F2f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F3f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F3f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F4f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F4f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE2_F4f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F1f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F1f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F2f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F2f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F3f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F3f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F4f_GET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F4f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F4f_SET BCM53324_A0_FP_PORT_FIELD_SELm_SLICE3_F4f_SET
#define READ_FP_PORT_FIELD_SELm BCM53324_A0_READ_FP_PORT_FIELD_SELm
#define WRITE_FP_PORT_FIELD_SELm BCM53324_A0_WRITE_FP_PORT_FIELD_SELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_PORT_FIELD_SELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_RANGE_CHECK
 * BLOCKS:   IPIPE
 * DESC:     RANGE CHECK VALUES FOR FP
 * SIZE:     34
 * FIELDS:
 *     LOWER_BOUNDS     Lower bounds of range to be checked.
 *     UPPER_BOUNDS     Upper bounds of range to be checked.
 *     ENABLE           Enable range check
 *     SOURCE_DESTINATION_SELECT Selects whether the Source or Destination Port is range checked.
 *
 ******************************************************************************/
#define BCM53324_A0_FP_RANGE_CHECKm 0x0d700000

#define BCM53324_A0_FP_RANGE_CHECKm_MIN 0
#define BCM53324_A0_FP_RANGE_CHECKm_MAX 15
#define BCM53324_A0_FP_RANGE_CHECKm_CMAX(u) 15
#define BCM53324_A0_FP_RANGE_CHECKm_SIZE 5

/*
 * This structure should be used to declare and program FP_RANGE_CHECK.
 *
 */
typedef union BCM53324_A0_FP_RANGE_CHECKm_s {
	uint32_t v[2];
	uint32_t fp_range_check[2];
	uint32_t _fp_range_check;
} BCM53324_A0_FP_RANGE_CHECKm_t;

#define BCM53324_A0_FP_RANGE_CHECKm_CLR(r) CDK_MEMSET(&((r)._fp_range_check), 0, sizeof(BCM53324_A0_FP_RANGE_CHECKm_t))
#define BCM53324_A0_FP_RANGE_CHECKm_SET(r,i,d) (r).fp_range_check[i] = d
#define BCM53324_A0_FP_RANGE_CHECKm_GET(r,i) (r).fp_range_check[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_GET(r) (((r).fp_range_check[0]) & 0xffff)
#define BCM53324_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_SET(r,f) (r).fp_range_check[0]=(((r).fp_range_check[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_GET(r) ((((r).fp_range_check[0]) >> 16) & 0xffff)
#define BCM53324_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_SET(r,f) (r).fp_range_check[0]=(((r).fp_range_check[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define BCM53324_A0_FP_RANGE_CHECKm_ENABLEf_GET(r) (((r).fp_range_check[1]) & 0x1)
#define BCM53324_A0_FP_RANGE_CHECKm_ENABLEf_SET(r,f) (r).fp_range_check[1]=(((r).fp_range_check[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET(r) ((((r).fp_range_check[1]) >> 1) & 0x1)
#define BCM53324_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET(r,f) (r).fp_range_check[1]=(((r).fp_range_check[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_RANGE_CHECK.
 *
 */
#define BCM53324_A0_READ_FP_RANGE_CHECKm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_RANGE_CHECKm,i,(m._fp_range_check),2)
#define BCM53324_A0_WRITE_FP_RANGE_CHECKm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_RANGE_CHECKm,i,&(m._fp_range_check),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_RANGE_CHECKm BCM53324_A0_FP_RANGE_CHECKm
#define FP_RANGE_CHECKm_MIN BCM53324_A0_FP_RANGE_CHECKm_MIN
#define FP_RANGE_CHECKm_MAX BCM53324_A0_FP_RANGE_CHECKm_MAX
#define FP_RANGE_CHECKm_CMAX(u) BCM53324_A0_FP_RANGE_CHECKm_CMAX(u)
#define FP_RANGE_CHECKm_SIZE BCM53324_A0_FP_RANGE_CHECKm_SIZE
typedef BCM53324_A0_FP_RANGE_CHECKm_t FP_RANGE_CHECKm_t;
#define FP_RANGE_CHECKm_CLR BCM53324_A0_FP_RANGE_CHECKm_CLR
#define FP_RANGE_CHECKm_SET BCM53324_A0_FP_RANGE_CHECKm_SET
#define FP_RANGE_CHECKm_GET BCM53324_A0_FP_RANGE_CHECKm_GET
#define FP_RANGE_CHECKm_LOWER_BOUNDSf_GET BCM53324_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_GET
#define FP_RANGE_CHECKm_LOWER_BOUNDSf_SET BCM53324_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_SET
#define FP_RANGE_CHECKm_UPPER_BOUNDSf_GET BCM53324_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_GET
#define FP_RANGE_CHECKm_UPPER_BOUNDSf_SET BCM53324_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_SET
#define FP_RANGE_CHECKm_ENABLEf_GET BCM53324_A0_FP_RANGE_CHECKm_ENABLEf_GET
#define FP_RANGE_CHECKm_ENABLEf_SET BCM53324_A0_FP_RANGE_CHECKm_ENABLEf_SET
#define FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET BCM53324_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET
#define FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET BCM53324_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET
#define READ_FP_RANGE_CHECKm BCM53324_A0_READ_FP_RANGE_CHECKm
#define WRITE_FP_RANGE_CHECKm BCM53324_A0_WRITE_FP_RANGE_CHECKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_RANGE_CHECKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_SC_BCAST_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     SC METER TABLE STRUCTURES FOR THE FP. Indexed using ingress port number.
 * SIZE:     53
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *
 ******************************************************************************/
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm 0x0d780000

#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_MIN 0
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_MAX 24
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_CMAX(u) 24
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_SC_BCAST_METER_TABLE.
 *
 */
typedef union BCM53324_A0_FP_SC_BCAST_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_sc_bcast_meter_table[2];
	uint32_t _fp_sc_bcast_meter_table;
} BCM53324_A0_FP_SC_BCAST_METER_TABLEm_t;

#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_sc_bcast_meter_table), 0, sizeof(BCM53324_A0_FP_SC_BCAST_METER_TABLEm_t))
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_SET(r,i,d) (r).fp_sc_bcast_meter_table[i] = d
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_GET(r,i) (r).fp_sc_bcast_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_sc_bcast_meter_table[0]) & 0x3fffffff)
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_sc_bcast_meter_table[0]=(((r).fp_sc_bcast_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_sc_bcast_meter_table,30,33)
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_sc_bcast_meter_table,30,33,f)
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_sc_bcast_meter_table[1]) >> 2) & 0x7ffff)
#define BCM53324_A0_FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_sc_bcast_meter_table[1]=(((r).fp_sc_bcast_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))

/*
 * These macros can be used to access FP_SC_BCAST_METER_TABLE.
 *
 */
#define BCM53324_A0_READ_FP_SC_BCAST_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_SC_BCAST_METER_TABLEm,i,(m._fp_sc_bcast_meter_table),2)
#define BCM53324_A0_WRITE_FP_SC_BCAST_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_SC_BCAST_METER_TABLEm,i,&(m._fp_sc_bcast_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SC_BCAST_METER_TABLEm BCM53324_A0_FP_SC_BCAST_METER_TABLEm
#define FP_SC_BCAST_METER_TABLEm_MIN BCM53324_A0_FP_SC_BCAST_METER_TABLEm_MIN
#define FP_SC_BCAST_METER_TABLEm_MAX BCM53324_A0_FP_SC_BCAST_METER_TABLEm_MAX
#define FP_SC_BCAST_METER_TABLEm_CMAX(u) BCM53324_A0_FP_SC_BCAST_METER_TABLEm_CMAX(u)
#define FP_SC_BCAST_METER_TABLEm_SIZE BCM53324_A0_FP_SC_BCAST_METER_TABLEm_SIZE
typedef BCM53324_A0_FP_SC_BCAST_METER_TABLEm_t FP_SC_BCAST_METER_TABLEm_t;
#define FP_SC_BCAST_METER_TABLEm_CLR BCM53324_A0_FP_SC_BCAST_METER_TABLEm_CLR
#define FP_SC_BCAST_METER_TABLEm_SET BCM53324_A0_FP_SC_BCAST_METER_TABLEm_SET
#define FP_SC_BCAST_METER_TABLEm_GET BCM53324_A0_FP_SC_BCAST_METER_TABLEm_GET
#define FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_GET BCM53324_A0_FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_SET BCM53324_A0_FP_SC_BCAST_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_GET BCM53324_A0_FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_GET
#define FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_SET BCM53324_A0_FP_SC_BCAST_METER_TABLEm_BUCKETSIZEf_SET
#define FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_GET BCM53324_A0_FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_SET BCM53324_A0_FP_SC_BCAST_METER_TABLEm_REFRESHCOUNTf_SET
#define READ_FP_SC_BCAST_METER_TABLEm BCM53324_A0_READ_FP_SC_BCAST_METER_TABLEm
#define WRITE_FP_SC_BCAST_METER_TABLEm BCM53324_A0_WRITE_FP_SC_BCAST_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_SC_BCAST_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_SC_DLF_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     SC METER TABLE STRUCTURES FOR THE FP. Indexed using ingress port number.
 * SIZE:     53
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *
 ******************************************************************************/
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm 0x0d780032

#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_MIN 0
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_MAX 24
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_CMAX(u) 24
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_SC_DLF_METER_TABLE.
 *
 */
typedef union BCM53324_A0_FP_SC_DLF_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_sc_dlf_meter_table[2];
	uint32_t _fp_sc_dlf_meter_table;
} BCM53324_A0_FP_SC_DLF_METER_TABLEm_t;

#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_sc_dlf_meter_table), 0, sizeof(BCM53324_A0_FP_SC_DLF_METER_TABLEm_t))
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_SET(r,i,d) (r).fp_sc_dlf_meter_table[i] = d
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_GET(r,i) (r).fp_sc_dlf_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_sc_dlf_meter_table[0]) & 0x3fffffff)
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_sc_dlf_meter_table[0]=(((r).fp_sc_dlf_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_sc_dlf_meter_table,30,33)
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_sc_dlf_meter_table,30,33,f)
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_sc_dlf_meter_table[1]) >> 2) & 0x7ffff)
#define BCM53324_A0_FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_sc_dlf_meter_table[1]=(((r).fp_sc_dlf_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))

/*
 * These macros can be used to access FP_SC_DLF_METER_TABLE.
 *
 */
#define BCM53324_A0_READ_FP_SC_DLF_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_SC_DLF_METER_TABLEm,i,(m._fp_sc_dlf_meter_table),2)
#define BCM53324_A0_WRITE_FP_SC_DLF_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_SC_DLF_METER_TABLEm,i,&(m._fp_sc_dlf_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SC_DLF_METER_TABLEm BCM53324_A0_FP_SC_DLF_METER_TABLEm
#define FP_SC_DLF_METER_TABLEm_MIN BCM53324_A0_FP_SC_DLF_METER_TABLEm_MIN
#define FP_SC_DLF_METER_TABLEm_MAX BCM53324_A0_FP_SC_DLF_METER_TABLEm_MAX
#define FP_SC_DLF_METER_TABLEm_CMAX(u) BCM53324_A0_FP_SC_DLF_METER_TABLEm_CMAX(u)
#define FP_SC_DLF_METER_TABLEm_SIZE BCM53324_A0_FP_SC_DLF_METER_TABLEm_SIZE
typedef BCM53324_A0_FP_SC_DLF_METER_TABLEm_t FP_SC_DLF_METER_TABLEm_t;
#define FP_SC_DLF_METER_TABLEm_CLR BCM53324_A0_FP_SC_DLF_METER_TABLEm_CLR
#define FP_SC_DLF_METER_TABLEm_SET BCM53324_A0_FP_SC_DLF_METER_TABLEm_SET
#define FP_SC_DLF_METER_TABLEm_GET BCM53324_A0_FP_SC_DLF_METER_TABLEm_GET
#define FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_GET BCM53324_A0_FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_SET BCM53324_A0_FP_SC_DLF_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_GET BCM53324_A0_FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_GET
#define FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_SET BCM53324_A0_FP_SC_DLF_METER_TABLEm_BUCKETSIZEf_SET
#define FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_GET BCM53324_A0_FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_SET BCM53324_A0_FP_SC_DLF_METER_TABLEm_REFRESHCOUNTf_SET
#define READ_FP_SC_DLF_METER_TABLEm BCM53324_A0_READ_FP_SC_DLF_METER_TABLEm
#define WRITE_FP_SC_DLF_METER_TABLEm BCM53324_A0_WRITE_FP_SC_DLF_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_SC_DLF_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_SC_MCAST_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     SC METER TABLE STRUCTURES FOR THE FP. Indexed using ingress port number.
 * SIZE:     53
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *
 ******************************************************************************/
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm 0x0d780019

#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_MIN 0
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_MAX 24
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_CMAX(u) 24
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_SC_MCAST_METER_TABLE.
 *
 */
typedef union BCM53324_A0_FP_SC_MCAST_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_sc_mcast_meter_table[2];
	uint32_t _fp_sc_mcast_meter_table;
} BCM53324_A0_FP_SC_MCAST_METER_TABLEm_t;

#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_sc_mcast_meter_table), 0, sizeof(BCM53324_A0_FP_SC_MCAST_METER_TABLEm_t))
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_SET(r,i,d) (r).fp_sc_mcast_meter_table[i] = d
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_GET(r,i) (r).fp_sc_mcast_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_sc_mcast_meter_table[0]) & 0x3fffffff)
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_sc_mcast_meter_table[0]=(((r).fp_sc_mcast_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_sc_mcast_meter_table,30,33)
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_sc_mcast_meter_table,30,33,f)
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_sc_mcast_meter_table[1]) >> 2) & 0x7ffff)
#define BCM53324_A0_FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_sc_mcast_meter_table[1]=(((r).fp_sc_mcast_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))

/*
 * These macros can be used to access FP_SC_MCAST_METER_TABLE.
 *
 */
#define BCM53324_A0_READ_FP_SC_MCAST_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_SC_MCAST_METER_TABLEm,i,(m._fp_sc_mcast_meter_table),2)
#define BCM53324_A0_WRITE_FP_SC_MCAST_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_SC_MCAST_METER_TABLEm,i,&(m._fp_sc_mcast_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SC_MCAST_METER_TABLEm BCM53324_A0_FP_SC_MCAST_METER_TABLEm
#define FP_SC_MCAST_METER_TABLEm_MIN BCM53324_A0_FP_SC_MCAST_METER_TABLEm_MIN
#define FP_SC_MCAST_METER_TABLEm_MAX BCM53324_A0_FP_SC_MCAST_METER_TABLEm_MAX
#define FP_SC_MCAST_METER_TABLEm_CMAX(u) BCM53324_A0_FP_SC_MCAST_METER_TABLEm_CMAX(u)
#define FP_SC_MCAST_METER_TABLEm_SIZE BCM53324_A0_FP_SC_MCAST_METER_TABLEm_SIZE
typedef BCM53324_A0_FP_SC_MCAST_METER_TABLEm_t FP_SC_MCAST_METER_TABLEm_t;
#define FP_SC_MCAST_METER_TABLEm_CLR BCM53324_A0_FP_SC_MCAST_METER_TABLEm_CLR
#define FP_SC_MCAST_METER_TABLEm_SET BCM53324_A0_FP_SC_MCAST_METER_TABLEm_SET
#define FP_SC_MCAST_METER_TABLEm_GET BCM53324_A0_FP_SC_MCAST_METER_TABLEm_GET
#define FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_GET BCM53324_A0_FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_SET BCM53324_A0_FP_SC_MCAST_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_GET BCM53324_A0_FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_GET
#define FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_SET BCM53324_A0_FP_SC_MCAST_METER_TABLEm_BUCKETSIZEf_SET
#define FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_GET BCM53324_A0_FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_SET BCM53324_A0_FP_SC_MCAST_METER_TABLEm_REFRESHCOUNTf_SET
#define READ_FP_SC_MCAST_METER_TABLEm BCM53324_A0_READ_FP_SC_MCAST_METER_TABLEm
#define WRITE_FP_SC_MCAST_METER_TABLEm BCM53324_A0_WRITE_FP_SC_MCAST_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_SC_MCAST_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_SC_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     SC METER TABLE STRUCTURES FOR THE FP
 * SIZE:     53
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *
 ******************************************************************************/
#define BCM53324_A0_FP_SC_METER_TABLEm 0x0d780000

#define BCM53324_A0_FP_SC_METER_TABLEm_MIN 0
#define BCM53324_A0_FP_SC_METER_TABLEm_MAX 74
#define BCM53324_A0_FP_SC_METER_TABLEm_CMAX(u) 74
#define BCM53324_A0_FP_SC_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_SC_METER_TABLE.
 *
 */
typedef union BCM53324_A0_FP_SC_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_sc_meter_table[2];
	uint32_t _fp_sc_meter_table;
} BCM53324_A0_FP_SC_METER_TABLEm_t;

#define BCM53324_A0_FP_SC_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_sc_meter_table), 0, sizeof(BCM53324_A0_FP_SC_METER_TABLEm_t))
#define BCM53324_A0_FP_SC_METER_TABLEm_SET(r,i,d) (r).fp_sc_meter_table[i] = d
#define BCM53324_A0_FP_SC_METER_TABLEm_GET(r,i) (r).fp_sc_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_SC_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_sc_meter_table[0]) & 0x3fffffff)
#define BCM53324_A0_FP_SC_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_sc_meter_table[0]=(((r).fp_sc_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM53324_A0_FP_SC_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_sc_meter_table,30,33)
#define BCM53324_A0_FP_SC_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_sc_meter_table,30,33,f)
#define BCM53324_A0_FP_SC_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_sc_meter_table[1]) >> 2) & 0x7ffff)
#define BCM53324_A0_FP_SC_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_sc_meter_table[1]=(((r).fp_sc_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))

/*
 * These macros can be used to access FP_SC_METER_TABLE.
 *
 */
#define BCM53324_A0_READ_FP_SC_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_SC_METER_TABLEm,i,(m._fp_sc_meter_table),2)
#define BCM53324_A0_WRITE_FP_SC_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_SC_METER_TABLEm,i,&(m._fp_sc_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SC_METER_TABLEm BCM53324_A0_FP_SC_METER_TABLEm
#define FP_SC_METER_TABLEm_MIN BCM53324_A0_FP_SC_METER_TABLEm_MIN
#define FP_SC_METER_TABLEm_MAX BCM53324_A0_FP_SC_METER_TABLEm_MAX
#define FP_SC_METER_TABLEm_CMAX(u) BCM53324_A0_FP_SC_METER_TABLEm_CMAX(u)
#define FP_SC_METER_TABLEm_SIZE BCM53324_A0_FP_SC_METER_TABLEm_SIZE
typedef BCM53324_A0_FP_SC_METER_TABLEm_t FP_SC_METER_TABLEm_t;
#define FP_SC_METER_TABLEm_CLR BCM53324_A0_FP_SC_METER_TABLEm_CLR
#define FP_SC_METER_TABLEm_SET BCM53324_A0_FP_SC_METER_TABLEm_SET
#define FP_SC_METER_TABLEm_GET BCM53324_A0_FP_SC_METER_TABLEm_GET
#define FP_SC_METER_TABLEm_BUCKETCOUNTf_GET BCM53324_A0_FP_SC_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_SC_METER_TABLEm_BUCKETCOUNTf_SET BCM53324_A0_FP_SC_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_SC_METER_TABLEm_BUCKETSIZEf_GET BCM53324_A0_FP_SC_METER_TABLEm_BUCKETSIZEf_GET
#define FP_SC_METER_TABLEm_BUCKETSIZEf_SET BCM53324_A0_FP_SC_METER_TABLEm_BUCKETSIZEf_SET
#define FP_SC_METER_TABLEm_REFRESHCOUNTf_GET BCM53324_A0_FP_SC_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_SC_METER_TABLEm_REFRESHCOUNTf_SET BCM53324_A0_FP_SC_METER_TABLEm_REFRESHCOUNTf_SET
#define READ_FP_SC_METER_TABLEm BCM53324_A0_READ_FP_SC_METER_TABLEm
#define WRITE_FP_SC_METER_TABLEm BCM53324_A0_WRITE_FP_SC_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_SC_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FP_SLICE_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     FP_SLICE_CONFIG
 * SIZE:     32
 * FIELDS:
 *     SLICE_0_MODE     CONFIG FOR SLICE 0: 00=Single Wide 01=Double Wide (with SLICE 1) 10=Triple Wide (with SLICES 1 & 2)  11=N/A
 *     SLICE_1_MODE     CONFIG FOR SLICE 1: 00=Single Wide 01=Double Wide (with SLICE 0) 10=Triple Wide ( with SLICES 0 & 2 ) 11=N/A
 *     SLICE_2_MODE     CONFIG FOR SLICE 2: 00=Single Wide 01=Double Wide (with SLICE 3) 10=Triple Wide ( with SLICES 0 & 1 ) 11=N/A
 *     SLICE_3_MODE     CONFIG FOR SLICE 3: 0=Single Wide 1=Double Wide (with SLICE 2) 
 *
 ******************************************************************************/
#define BCM53324_A0_FP_SLICE_CONFIGr 0x0d78000b

#define BCM53324_A0_FP_SLICE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_CONFIG.
 *
 */
typedef union BCM53324_A0_FP_SLICE_CONFIGr_s {
	uint32_t v[1];
	uint32_t fp_slice_config[1];
	uint32_t _fp_slice_config;
} BCM53324_A0_FP_SLICE_CONFIGr_t;

#define BCM53324_A0_FP_SLICE_CONFIGr_CLR(r) (r).fp_slice_config[0] = 0
#define BCM53324_A0_FP_SLICE_CONFIGr_SET(r,d) (r).fp_slice_config[0] = d
#define BCM53324_A0_FP_SLICE_CONFIGr_GET(r) (r).fp_slice_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_GET(r) (((r).fp_slice_config[0]) & 0x3)
#define BCM53324_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 2) & 0x3)
#define BCM53324_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 4) & 0x3)
#define BCM53324_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 6) & 0x1)
#define BCM53324_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access FP_SLICE_CONFIG.
 *
 */
#define BCM53324_A0_READ_FP_SLICE_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_FP_SLICE_CONFIGr,(r._fp_slice_config))
#define BCM53324_A0_WRITE_FP_SLICE_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_FP_SLICE_CONFIGr,&(r._fp_slice_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_CONFIGr BCM53324_A0_FP_SLICE_CONFIGr
#define FP_SLICE_CONFIGr_SIZE BCM53324_A0_FP_SLICE_CONFIGr_SIZE
typedef BCM53324_A0_FP_SLICE_CONFIGr_t FP_SLICE_CONFIGr_t;
#define FP_SLICE_CONFIGr_CLR BCM53324_A0_FP_SLICE_CONFIGr_CLR
#define FP_SLICE_CONFIGr_SET BCM53324_A0_FP_SLICE_CONFIGr_SET
#define FP_SLICE_CONFIGr_GET BCM53324_A0_FP_SLICE_CONFIGr_GET
#define FP_SLICE_CONFIGr_SLICE_0_MODEf_GET BCM53324_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_0_MODEf_SET BCM53324_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_1_MODEf_GET BCM53324_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_1_MODEf_SET BCM53324_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_2_MODEf_GET BCM53324_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_2_MODEf_SET BCM53324_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_3_MODEf_GET BCM53324_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_3_MODEf_SET BCM53324_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_SET
#define READ_FP_SLICE_CONFIGr BCM53324_A0_READ_FP_SLICE_CONFIGr
#define WRITE_FP_SLICE_CONFIGr BCM53324_A0_WRITE_FP_SLICE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_SLICE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FP_SLICE_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_SLICE_ENABLE
 * SIZE:     32
 * FIELDS:
 *     FP_SLICE_ENABLE_ALL_SLICES FP_SLICE_ENABLE Overlay FOR ALL FP Slices
 *     FP_SLICE_ENABLE_SLICE_0 FP_SLICE_ENABLE FOR FP SLICE 0
 *     FP_SLICE_ENABLE_SLICE_1 FP_SLICE_ENABLE FOR FP SLICE 1
 *     FP_SLICE_ENABLE_SLICE_2 FP_SLICE_ENABLE FOR FP SLICE 2
 *     FP_SLICE_ENABLE_SLICE_3 FP_SLICE_ENABLE FOR FP SLICE 3
 *     FP_LOOKUP_ENABLE_ALL_SLICES LOOKUP ENABLE Overlay FOR All FP SLICES
 *     FP_LOOKUP_ENABLE_SLICE_0 LOOKUP ENABLE FOR FP SLICE 0
 *     FP_LOOKUP_ENABLE_SLICE_1 LOOKUP ENABLE FOR FP SLICE 1
 *     FP_LOOKUP_ENABLE_SLICE_2 LOOKUP ENABLE FOR FP SLICE 2
 *     FP_LOOKUP_ENABLE_SLICE_3 LOOKUP ENABLE FOR FP SLICE 3
 *
 ******************************************************************************/
#define BCM53324_A0_FP_SLICE_ENABLEr 0x0d780007

#define BCM53324_A0_FP_SLICE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_ENABLE.
 *
 */
typedef union BCM53324_A0_FP_SLICE_ENABLEr_s {
	uint32_t v[1];
	uint32_t fp_slice_enable[1];
	uint32_t _fp_slice_enable;
} BCM53324_A0_FP_SLICE_ENABLEr_t;

#define BCM53324_A0_FP_SLICE_ENABLEr_CLR(r) (r).fp_slice_enable[0] = 0
#define BCM53324_A0_FP_SLICE_ENABLEr_SET(r,d) (r).fp_slice_enable[0] = d
#define BCM53324_A0_FP_SLICE_ENABLEr_GET(r) (r).fp_slice_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALL_SLICESf_GET(r) (((r).fp_slice_enable[0]) & 0xf)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALL_SLICESf_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET(r) (((r).fp_slice_enable[0]) & 0x1)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 1) & 0x1)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 2) & 0x1)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 3) & 0x1)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALL_SLICESf_GET(r) ((((r).fp_slice_enable[0]) >> 4) & 0xf)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALL_SLICESf_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET(r) ((((r).fp_slice_enable[0]) >> 4) & 0x1)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 5) & 0x1)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 6) & 0x1)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 7) & 0x1)
#define BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FP_SLICE_ENABLE.
 *
 */
#define BCM53324_A0_READ_FP_SLICE_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_FP_SLICE_ENABLEr,(r._fp_slice_enable))
#define BCM53324_A0_WRITE_FP_SLICE_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_FP_SLICE_ENABLEr,&(r._fp_slice_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_ENABLEr BCM53324_A0_FP_SLICE_ENABLEr
#define FP_SLICE_ENABLEr_SIZE BCM53324_A0_FP_SLICE_ENABLEr_SIZE
typedef BCM53324_A0_FP_SLICE_ENABLEr_t FP_SLICE_ENABLEr_t;
#define FP_SLICE_ENABLEr_CLR BCM53324_A0_FP_SLICE_ENABLEr_CLR
#define FP_SLICE_ENABLEr_SET BCM53324_A0_FP_SLICE_ENABLEr_SET
#define FP_SLICE_ENABLEr_GET BCM53324_A0_FP_SLICE_ENABLEr_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALL_SLICESf_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALL_SLICESf_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALL_SLICESf_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_ALL_SLICESf_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALL_SLICESf_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALL_SLICESf_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALL_SLICESf_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_ALL_SLICESf_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET BCM53324_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET
#define READ_FP_SLICE_ENABLEr BCM53324_A0_READ_FP_SLICE_ENABLEr
#define WRITE_FP_SLICE_ENABLEr BCM53324_A0_WRITE_FP_SLICE_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_SLICE_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_SLICE_ENTRY_PORT_SEL
 * BLOCKS:   IPIPE
 * DESC:     ENTRIES ENABLED FOR EACH SOURCE PORT FOR EACH SLICE. The index for this table is created by concatenating {Ingress Port(5bits) and Slice Number(2bits)}.
 * SIZE:     128
 * FIELDS:
 *     ENTRIES_PER_PORT 1 bit for each entry in the TCAM of each slice to indicate if that entry should hit
 *     ENTRIES_PER_PORT_31_0 for entries from 31 to 0.
 *     ENTRIES_PER_PORT_63_32 for entries from 63 to 32.
 *     ENTRIES_PER_PORT_95_64 for entries from 95 to 64.
 *     ENTRIES_PER_PORT_127_96 for entries from 127 to 96.
 *
 ******************************************************************************/
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm 0x0d710000

#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_MIN 0
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_MAX 99
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_CMAX(u) 99
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_SIZE 16

/*
 * This structure should be used to declare and program FP_SLICE_ENTRY_PORT_SEL.
 *
 */
typedef union BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_s {
	uint32_t v[4];
	uint32_t fp_slice_entry_port_sel[4];
	uint32_t _fp_slice_entry_port_sel;
} BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_t;

#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_CLR(r) CDK_MEMSET(&((r)._fp_slice_entry_port_sel), 0, sizeof(BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_t))
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_SET(r,i,d) (r).fp_slice_entry_port_sel[i] = d
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_GET(r,i) (r).fp_slice_entry_port_sel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_GET(r,a) cdk_field_get((r).fp_slice_entry_port_sel,0,127,a)
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_SET(r,a) cdk_field_set((r).fp_slice_entry_port_sel,0,127,a)
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_GET(r) ((r).fp_slice_entry_port_sel[0])
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_SET(r,f) (r).fp_slice_entry_port_sel[0]=((uint32_t)f)
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_GET(r) ((r).fp_slice_entry_port_sel[1])
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_SET(r,f) (r).fp_slice_entry_port_sel[1]=((uint32_t)f)
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_GET(r) ((r).fp_slice_entry_port_sel[2])
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_SET(r,f) (r).fp_slice_entry_port_sel[2]=((uint32_t)f)
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_GET(r) ((r).fp_slice_entry_port_sel[3])
#define BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_SET(r,f) (r).fp_slice_entry_port_sel[3]=((uint32_t)f)

/*
 * These macros can be used to access FP_SLICE_ENTRY_PORT_SEL.
 *
 */
#define BCM53324_A0_READ_FP_SLICE_ENTRY_PORT_SELm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm,i,(m._fp_slice_entry_port_sel),4)
#define BCM53324_A0_WRITE_FP_SLICE_ENTRY_PORT_SELm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm,i,&(m._fp_slice_entry_port_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_ENTRY_PORT_SELm BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm
#define FP_SLICE_ENTRY_PORT_SELm_MIN BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_MIN
#define FP_SLICE_ENTRY_PORT_SELm_MAX BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_MAX
#define FP_SLICE_ENTRY_PORT_SELm_CMAX(u) BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_CMAX(u)
#define FP_SLICE_ENTRY_PORT_SELm_SIZE BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_SIZE
typedef BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_t FP_SLICE_ENTRY_PORT_SELm_t;
#define FP_SLICE_ENTRY_PORT_SELm_CLR BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_CLR
#define FP_SLICE_ENTRY_PORT_SELm_SET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_SET
#define FP_SLICE_ENTRY_PORT_SELm_GET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_GET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_SET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORTf_SET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_GET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_SET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_31_0f_SET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_GET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_SET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_63_32f_SET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_GET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_SET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_95_64f_SET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_GET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_GET
#define FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_SET BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm_ENTRIES_PER_PORT_127_96f_SET
#define READ_FP_SLICE_ENTRY_PORT_SELm BCM53324_A0_READ_FP_SLICE_ENTRY_PORT_SELm
#define WRITE_FP_SLICE_ENTRY_PORT_SELm BCM53324_A0_WRITE_FP_SLICE_ENTRY_PORT_SELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_SLICE_ENTRY_PORT_SELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_SLICE_MAP
 * BLOCKS:   IPIPE
 * DESC:     SLICE MAPPING CONTROLS FOR IFP
 * SIZE:     32
 * FIELDS:
 *     VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 0 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 1 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 2 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBER MAPS VIRTUAL SLICE 3 TO A PHYSICAL SLICE NUMBER
 *     VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 0 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 1 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 2 TO A VIRTUAL SLICE GROUP
 *     VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUP MAPS VIRTUAL SLICE 3 TO A VIRTUAL SLICE GROUP
 *
 ******************************************************************************/
#define BCM53324_A0_FP_SLICE_MAPm 0x0d730000

#define BCM53324_A0_FP_SLICE_MAPm_MIN 0
#define BCM53324_A0_FP_SLICE_MAPm_MAX 0
#define BCM53324_A0_FP_SLICE_MAPm_CMAX(u) 0
#define BCM53324_A0_FP_SLICE_MAPm_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_MAP.
 *
 */
typedef union BCM53324_A0_FP_SLICE_MAPm_s {
	uint32_t v[1];
	uint32_t fp_slice_map[1];
	uint32_t _fp_slice_map;
} BCM53324_A0_FP_SLICE_MAPm_t;

#define BCM53324_A0_FP_SLICE_MAPm_CLR(r) (r).fp_slice_map[0] = 0
#define BCM53324_A0_FP_SLICE_MAPm_SET(r,d) (r).fp_slice_map[0] = d
#define BCM53324_A0_FP_SLICE_MAPm_GET(r) (r).fp_slice_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_GET(r) (((r).fp_slice_map[0]) & 0xf)
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 4) & 0xf)
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 8) & 0xf)
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_GET(r) ((((r).fp_slice_map[0]) >> 12) & 0xf)
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[0]) >> 16) & 0xf)
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[0]) >> 20) & 0xf)
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[0]) >> 24) & 0xf)
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_GET(r) ((((r).fp_slice_map[0]) >> 28) & 0xf)
#define BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_SET(r,f) (r).fp_slice_map[0]=(((r).fp_slice_map[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access FP_SLICE_MAP.
 *
 */
#define BCM53324_A0_READ_FP_SLICE_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_SLICE_MAPm,i,(m._fp_slice_map),1)
#define BCM53324_A0_WRITE_FP_SLICE_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_SLICE_MAPm,i,&(m._fp_slice_map),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_MAPm BCM53324_A0_FP_SLICE_MAPm
#define FP_SLICE_MAPm_MIN BCM53324_A0_FP_SLICE_MAPm_MIN
#define FP_SLICE_MAPm_MAX BCM53324_A0_FP_SLICE_MAPm_MAX
#define FP_SLICE_MAPm_CMAX(u) BCM53324_A0_FP_SLICE_MAPm_CMAX(u)
#define FP_SLICE_MAPm_SIZE BCM53324_A0_FP_SLICE_MAPm_SIZE
typedef BCM53324_A0_FP_SLICE_MAPm_t FP_SLICE_MAPm_t;
#define FP_SLICE_MAPm_CLR BCM53324_A0_FP_SLICE_MAPm_CLR
#define FP_SLICE_MAPm_SET BCM53324_A0_FP_SLICE_MAPm_SET
#define FP_SLICE_MAPm_GET BCM53324_A0_FP_SLICE_MAPm_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_GET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_SET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_GET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_SET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_GET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_SET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_GET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_SET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_GET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_SET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_GET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_SET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_GET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_SET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf_SET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_GET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_GET
#define FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_SET BCM53324_A0_FP_SLICE_MAPm_VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf_SET
#define READ_FP_SLICE_MAPm BCM53324_A0_READ_FP_SLICE_MAPm
#define WRITE_FP_SLICE_MAPm BCM53324_A0_WRITE_FP_SLICE_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_SLICE_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_TCAM
 * BLOCKS:   IPIPE
 * DESC:     TCAM FOR FP. Indexed using the key constructed by choosing various fields based on FP_PORT_FIELD_SELCT table.
 * SIZE:     422
 * FIELDS:
 *     VALID            VALID BIT
 *     FULL_KEY         Entire Key excluding the valid bits
 *     HIGIG_PKT        Indicates if the packet is a HIGIG (1) or non HIGIG (0) packet
 *     IP_TYPE          IP TYPE
 *     F4               F4
 *     KEY              F1,F2,F3 fields 
 *     F3               F3 field
 *     F2               F2 field
 *     F1               F1 field
 *     RESERVED_KEY     RESERVED Bits to support 212 bit wide key for 65LP CAM
 *     FULL_MASK        Full 210 Bit Mask
 *     HIGIG_PKT_MASK   HIGIG PACKET MASK
 *     IP_TYPE_MASK     IP_TYPE MASK
 *     F4_MASK          F4 MASK
 *     MASK             F1,F2,F3 field MASK
 *     F3_MASK          F3 field MASK
 *     F2_MASK          F2 field MASK
 *     F1_MASK          F1 field MASK
 *     RESERVED_MASK    RESERVED Bits to support 212 bit wide key for 65LP CAM
 *
 ******************************************************************************/
#define BCM53324_A0_FP_TCAMm 0x0d720000

#define BCM53324_A0_FP_TCAMm_MIN 0
#define BCM53324_A0_FP_TCAMm_MAX 511
#define BCM53324_A0_FP_TCAMm_CMAX(u) 511
#define BCM53324_A0_FP_TCAMm_SIZE 53

/*
 * This structure should be used to declare and program FP_TCAM.
 *
 */
typedef union BCM53324_A0_FP_TCAMm_s {
	uint32_t v[14];
	uint32_t fp_tcam[14];
	uint32_t _fp_tcam;
} BCM53324_A0_FP_TCAMm_t;

#define BCM53324_A0_FP_TCAMm_CLR(r) CDK_MEMSET(&((r)._fp_tcam), 0, sizeof(BCM53324_A0_FP_TCAMm_t))
#define BCM53324_A0_FP_TCAMm_SET(r,i,d) (r).fp_tcam[i] = d
#define BCM53324_A0_FP_TCAMm_GET(r,i) (r).fp_tcam[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_TCAMm_VALIDf_GET(r) (((r).fp_tcam[0]) & 0x3)
#define BCM53324_A0_FP_TCAMm_VALIDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_FP_TCAMm_FULL_KEYf_GET(r,a) cdk_field_get((r).fp_tcam,2,211,a)
#define BCM53324_A0_FP_TCAMm_FULL_KEYf_SET(r,a) cdk_field_set((r).fp_tcam,2,211,a)
#define BCM53324_A0_FP_TCAMm_HIGIG_PKTf_GET(r) ((((r).fp_tcam[0]) >> 2) & 0x1)
#define BCM53324_A0_FP_TCAMm_HIGIG_PKTf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_FP_TCAMm_IP_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x3)
#define BCM53324_A0_FP_TCAMm_IP_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53324_A0_FP_TCAMm_F4f_GET(r) ((((r).fp_tcam[0]) >> 5) & 0x1f)
#define BCM53324_A0_FP_TCAMm_F4f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM53324_A0_FP_TCAMm_KEYf_GET(r,a) cdk_field_get((r).fp_tcam,10,185,a)
#define BCM53324_A0_FP_TCAMm_KEYf_SET(r,a) cdk_field_set((r).fp_tcam,10,185,a)
#define BCM53324_A0_FP_TCAMm_F3f_GET(r) ((((r).fp_tcam[0]) >> 10) & 0xffff)
#define BCM53324_A0_FP_TCAMm_F3f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0xffff << 10)) | ((((uint32_t)f) & 0xffff) << 10))
#define BCM53324_A0_FP_TCAMm_F2f_GET(r,a) cdk_field_get((r).fp_tcam,26,153,a)
#define BCM53324_A0_FP_TCAMm_F2f_SET(r,a) cdk_field_set((r).fp_tcam,26,153,a)
#define BCM53324_A0_FP_TCAMm_F1f_GET(r) cdk_field32_get((r).fp_tcam,154,185)
#define BCM53324_A0_FP_TCAMm_F1f_SET(r,f) cdk_field32_set((r).fp_tcam,154,185,f)
#define BCM53324_A0_FP_TCAMm_RESERVED_KEYf_GET(r) cdk_field32_get((r).fp_tcam,186,211)
#define BCM53324_A0_FP_TCAMm_RESERVED_KEYf_SET(r,f) cdk_field32_set((r).fp_tcam,186,211,f)
#define BCM53324_A0_FP_TCAMm_FULL_MASKf_GET(r,a) cdk_field_get((r).fp_tcam,212,421,a)
#define BCM53324_A0_FP_TCAMm_FULL_MASKf_SET(r,a) cdk_field_set((r).fp_tcam,212,421,a)
#define BCM53324_A0_FP_TCAMm_HIGIG_PKT_MASKf_GET(r) ((((r).fp_tcam[6]) >> 20) & 0x1)
#define BCM53324_A0_FP_TCAMm_HIGIG_PKT_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_FP_TCAMm_IP_TYPE_MASKf_GET(r) ((((r).fp_tcam[6]) >> 21) & 0x3)
#define BCM53324_A0_FP_TCAMm_IP_TYPE_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define BCM53324_A0_FP_TCAMm_F4_MASKf_GET(r) ((((r).fp_tcam[6]) >> 23) & 0x1f)
#define BCM53324_A0_FP_TCAMm_F4_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0x1f << 23)) | ((((uint32_t)f) & 0x1f) << 23))
#define BCM53324_A0_FP_TCAMm_MASKf_GET(r,a) cdk_field_get((r).fp_tcam,220,395,a)
#define BCM53324_A0_FP_TCAMm_MASKf_SET(r,a) cdk_field_set((r).fp_tcam,220,395,a)
#define BCM53324_A0_FP_TCAMm_F3_MASKf_GET(r) cdk_field32_get((r).fp_tcam,220,235)
#define BCM53324_A0_FP_TCAMm_F3_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,220,235,f)
#define BCM53324_A0_FP_TCAMm_F2_MASKf_GET(r,a) cdk_field_get((r).fp_tcam,236,363,a)
#define BCM53324_A0_FP_TCAMm_F2_MASKf_SET(r,a) cdk_field_set((r).fp_tcam,236,363,a)
#define BCM53324_A0_FP_TCAMm_F1_MASKf_GET(r) cdk_field32_get((r).fp_tcam,364,395)
#define BCM53324_A0_FP_TCAMm_F1_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,364,395,f)
#define BCM53324_A0_FP_TCAMm_RESERVED_MASKf_GET(r) cdk_field32_get((r).fp_tcam,396,421)
#define BCM53324_A0_FP_TCAMm_RESERVED_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,396,421,f)

/*
 * These macros can be used to access FP_TCAM.
 *
 */
#define BCM53324_A0_READ_FP_TCAMm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_TCAMm,i,(m._fp_tcam),14)
#define BCM53324_A0_WRITE_FP_TCAMm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_TCAMm,i,&(m._fp_tcam),14)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_TCAMm BCM53324_A0_FP_TCAMm
#define FP_TCAMm_MIN BCM53324_A0_FP_TCAMm_MIN
#define FP_TCAMm_MAX BCM53324_A0_FP_TCAMm_MAX
#define FP_TCAMm_CMAX(u) BCM53324_A0_FP_TCAMm_CMAX(u)
#define FP_TCAMm_SIZE BCM53324_A0_FP_TCAMm_SIZE
typedef BCM53324_A0_FP_TCAMm_t FP_TCAMm_t;
#define FP_TCAMm_CLR BCM53324_A0_FP_TCAMm_CLR
#define FP_TCAMm_SET BCM53324_A0_FP_TCAMm_SET
#define FP_TCAMm_GET BCM53324_A0_FP_TCAMm_GET
#define FP_TCAMm_VALIDf_GET BCM53324_A0_FP_TCAMm_VALIDf_GET
#define FP_TCAMm_VALIDf_SET BCM53324_A0_FP_TCAMm_VALIDf_SET
#define FP_TCAMm_FULL_KEYf_GET BCM53324_A0_FP_TCAMm_FULL_KEYf_GET
#define FP_TCAMm_FULL_KEYf_SET BCM53324_A0_FP_TCAMm_FULL_KEYf_SET
#define FP_TCAMm_HIGIG_PKTf_GET BCM53324_A0_FP_TCAMm_HIGIG_PKTf_GET
#define FP_TCAMm_HIGIG_PKTf_SET BCM53324_A0_FP_TCAMm_HIGIG_PKTf_SET
#define FP_TCAMm_IP_TYPEf_GET BCM53324_A0_FP_TCAMm_IP_TYPEf_GET
#define FP_TCAMm_IP_TYPEf_SET BCM53324_A0_FP_TCAMm_IP_TYPEf_SET
#define FP_TCAMm_F4f_GET BCM53324_A0_FP_TCAMm_F4f_GET
#define FP_TCAMm_F4f_SET BCM53324_A0_FP_TCAMm_F4f_SET
#define FP_TCAMm_KEYf_GET BCM53324_A0_FP_TCAMm_KEYf_GET
#define FP_TCAMm_KEYf_SET BCM53324_A0_FP_TCAMm_KEYf_SET
#define FP_TCAMm_F3f_GET BCM53324_A0_FP_TCAMm_F3f_GET
#define FP_TCAMm_F3f_SET BCM53324_A0_FP_TCAMm_F3f_SET
#define FP_TCAMm_F2f_GET BCM53324_A0_FP_TCAMm_F2f_GET
#define FP_TCAMm_F2f_SET BCM53324_A0_FP_TCAMm_F2f_SET
#define FP_TCAMm_F1f_GET BCM53324_A0_FP_TCAMm_F1f_GET
#define FP_TCAMm_F1f_SET BCM53324_A0_FP_TCAMm_F1f_SET
#define FP_TCAMm_RESERVED_KEYf_GET BCM53324_A0_FP_TCAMm_RESERVED_KEYf_GET
#define FP_TCAMm_RESERVED_KEYf_SET BCM53324_A0_FP_TCAMm_RESERVED_KEYf_SET
#define FP_TCAMm_FULL_MASKf_GET BCM53324_A0_FP_TCAMm_FULL_MASKf_GET
#define FP_TCAMm_FULL_MASKf_SET BCM53324_A0_FP_TCAMm_FULL_MASKf_SET
#define FP_TCAMm_HIGIG_PKT_MASKf_GET BCM53324_A0_FP_TCAMm_HIGIG_PKT_MASKf_GET
#define FP_TCAMm_HIGIG_PKT_MASKf_SET BCM53324_A0_FP_TCAMm_HIGIG_PKT_MASKf_SET
#define FP_TCAMm_IP_TYPE_MASKf_GET BCM53324_A0_FP_TCAMm_IP_TYPE_MASKf_GET
#define FP_TCAMm_IP_TYPE_MASKf_SET BCM53324_A0_FP_TCAMm_IP_TYPE_MASKf_SET
#define FP_TCAMm_F4_MASKf_GET BCM53324_A0_FP_TCAMm_F4_MASKf_GET
#define FP_TCAMm_F4_MASKf_SET BCM53324_A0_FP_TCAMm_F4_MASKf_SET
#define FP_TCAMm_MASKf_GET BCM53324_A0_FP_TCAMm_MASKf_GET
#define FP_TCAMm_MASKf_SET BCM53324_A0_FP_TCAMm_MASKf_SET
#define FP_TCAMm_F3_MASKf_GET BCM53324_A0_FP_TCAMm_F3_MASKf_GET
#define FP_TCAMm_F3_MASKf_SET BCM53324_A0_FP_TCAMm_F3_MASKf_SET
#define FP_TCAMm_F2_MASKf_GET BCM53324_A0_FP_TCAMm_F2_MASKf_GET
#define FP_TCAMm_F2_MASKf_SET BCM53324_A0_FP_TCAMm_F2_MASKf_SET
#define FP_TCAMm_F1_MASKf_GET BCM53324_A0_FP_TCAMm_F1_MASKf_GET
#define FP_TCAMm_F1_MASKf_SET BCM53324_A0_FP_TCAMm_F1_MASKf_SET
#define FP_TCAMm_RESERVED_MASKf_GET BCM53324_A0_FP_TCAMm_RESERVED_MASKf_GET
#define FP_TCAMm_RESERVED_MASKf_SET BCM53324_A0_FP_TCAMm_RESERVED_MASKf_SET
#define READ_FP_TCAMm BCM53324_A0_READ_FP_TCAMm
#define WRITE_FP_TCAMm BCM53324_A0_WRITE_FP_TCAMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_TCAMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  FP_UDF_OFFSET
 * BLOCKS:   IPIPE
 * DESC:     FP UDF offset table. Refer to C code for index creation.
 * SIZE:     58
 * FIELDS:
 *     UDF1_OFFSET0     Offset value for UDF1.0
 *     UDF1_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET1     Offset value for UDF1.1
 *     UDF1_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET2     Offset value for UDF1.2
 *     UDF1_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET3     Offset value for UDF1.3
 *     UDF1_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET0     Offset value for UDF2.0
 *     UDF2_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET1     Offset value for UDF2.1
 *     UDF2_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET2     Offset value for UDF2.2
 *     UDF2_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET3     Offset value for UDF2.3
 *     UDF2_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     PORT_FIELD_SEL_INDEX0 Used to index into the FP_PORT_FIELD_SEL table (if packet indexing is enabled) and FP_PORT_SELECT_TYPE equals 0
 *     PORT_FIELD_SEL_INDEX1 Used to index into the FP_PORT_FIELD_SEL table (if packet indexing is enabled) and FP_PORT_SELECT_TYPE equals 1
 *
 ******************************************************************************/
#define BCM53324_A0_FP_UDF_OFFSETm 0x02720000

#define BCM53324_A0_FP_UDF_OFFSETm_MIN 0
#define BCM53324_A0_FP_UDF_OFFSETm_MAX 95
#define BCM53324_A0_FP_UDF_OFFSETm_CMAX(u) 95
#define BCM53324_A0_FP_UDF_OFFSETm_SIZE 8

/*
 * This structure should be used to declare and program FP_UDF_OFFSET.
 *
 */
typedef union BCM53324_A0_FP_UDF_OFFSETm_s {
	uint32_t v[2];
	uint32_t fp_udf_offset[2];
	uint32_t _fp_udf_offset;
} BCM53324_A0_FP_UDF_OFFSETm_t;

#define BCM53324_A0_FP_UDF_OFFSETm_CLR(r) CDK_MEMSET(&((r)._fp_udf_offset), 0, sizeof(BCM53324_A0_FP_UDF_OFFSETm_t))
#define BCM53324_A0_FP_UDF_OFFSETm_SET(r,i,d) (r).fp_udf_offset[i] = d
#define BCM53324_A0_FP_UDF_OFFSETm_GET(r,i) (r).fp_udf_offset[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_GET(r) (((r).fp_udf_offset[0]) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 5) & 0x1)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_GET(r) ((((r).fp_udf_offset[0]) >> 6) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[0]) >> 11) & 0x1)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_GET(r) ((((r).fp_udf_offset[0]) >> 12) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[0]) >> 17) & 0x1)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_GET(r) ((((r).fp_udf_offset[0]) >> 18) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[0]) >> 23) & 0x1)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_GET(r) ((((r).fp_udf_offset[0]) >> 24) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 29) & 0x1)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_GET(r) cdk_field32_get((r).fp_udf_offset,30,34)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_SET(r,f) cdk_field32_set((r).fp_udf_offset,30,34,f)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[1]) >> 3) & 0x1)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_GET(r) ((((r).fp_udf_offset[1]) >> 4) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[1]) >> 9) & 0x1)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_GET(r) ((((r).fp_udf_offset[1]) >> 10) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[1]) >> 15) & 0x1)
#define BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_GET(r) ((((r).fp_udf_offset[1]) >> 16) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM53324_A0_FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_GET(r) ((((r).fp_udf_offset[1]) >> 21) & 0x1f)
#define BCM53324_A0_FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 21)) | ((((uint32_t)f) & 0x1f) << 21))

/*
 * These macros can be used to access FP_UDF_OFFSET.
 *
 */
#define BCM53324_A0_READ_FP_UDF_OFFSETm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_FP_UDF_OFFSETm,i,(m._fp_udf_offset),2)
#define BCM53324_A0_WRITE_FP_UDF_OFFSETm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_FP_UDF_OFFSETm,i,&(m._fp_udf_offset),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_UDF_OFFSETm BCM53324_A0_FP_UDF_OFFSETm
#define FP_UDF_OFFSETm_MIN BCM53324_A0_FP_UDF_OFFSETm_MIN
#define FP_UDF_OFFSETm_MAX BCM53324_A0_FP_UDF_OFFSETm_MAX
#define FP_UDF_OFFSETm_CMAX(u) BCM53324_A0_FP_UDF_OFFSETm_CMAX(u)
#define FP_UDF_OFFSETm_SIZE BCM53324_A0_FP_UDF_OFFSETm_SIZE
typedef BCM53324_A0_FP_UDF_OFFSETm_t FP_UDF_OFFSETm_t;
#define FP_UDF_OFFSETm_CLR BCM53324_A0_FP_UDF_OFFSETm_CLR
#define FP_UDF_OFFSETm_SET BCM53324_A0_FP_UDF_OFFSETm_SET
#define FP_UDF_OFFSETm_GET BCM53324_A0_FP_UDF_OFFSETm_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET BCM53324_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_GET BCM53324_A0_FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_GET
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_SET BCM53324_A0_FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX0f_SET
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_GET BCM53324_A0_FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_GET
#define FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_SET BCM53324_A0_FP_UDF_OFFSETm_PORT_FIELD_SEL_INDEX1f_SET
#define READ_FP_UDF_OFFSETm BCM53324_A0_READ_FP_UDF_OFFSETm
#define WRITE_FP_UDF_OFFSETm BCM53324_A0_WRITE_FP_UDF_OFFSETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FP_UDF_OFFSETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  FRM_LENGTH
 * BLOCKS:   GPORT0
 * DESC:     Maximum Frame Length.
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Defines a 14-Bit maximum frame length used by the MAC receive logic to check frames.
 *
 ******************************************************************************/
#define BCM53324_A0_FRM_LENGTHr 0x00000105

#define BCM53324_A0_FRM_LENGTHr_SIZE 4

/*
 * This structure should be used to declare and program FRM_LENGTH.
 *
 */
typedef union BCM53324_A0_FRM_LENGTHr_s {
	uint32_t v[1];
	uint32_t frm_length[1];
	uint32_t _frm_length;
} BCM53324_A0_FRM_LENGTHr_t;

#define BCM53324_A0_FRM_LENGTHr_CLR(r) (r).frm_length[0] = 0
#define BCM53324_A0_FRM_LENGTHr_SET(r,d) (r).frm_length[0] = d
#define BCM53324_A0_FRM_LENGTHr_GET(r) (r).frm_length[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_FRM_LENGTHr_MAXFRf_GET(r) (((r).frm_length[0]) & 0x3fff)
#define BCM53324_A0_FRM_LENGTHr_MAXFRf_SET(r,f) (r).frm_length[0]=(((r).frm_length[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access FRM_LENGTH.
 *
 */
#define BCM53324_A0_READ_FRM_LENGTHr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_FRM_LENGTHr,(r._frm_length))
#define BCM53324_A0_WRITE_FRM_LENGTHr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_FRM_LENGTHr,&(r._frm_length))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FRM_LENGTHr BCM53324_A0_FRM_LENGTHr
#define FRM_LENGTHr_SIZE BCM53324_A0_FRM_LENGTHr_SIZE
typedef BCM53324_A0_FRM_LENGTHr_t FRM_LENGTHr_t;
#define FRM_LENGTHr_CLR BCM53324_A0_FRM_LENGTHr_CLR
#define FRM_LENGTHr_SET BCM53324_A0_FRM_LENGTHr_SET
#define FRM_LENGTHr_GET BCM53324_A0_FRM_LENGTHr_GET
#define FRM_LENGTHr_MAXFRf_GET BCM53324_A0_FRM_LENGTHr_MAXFRf_GET
#define FRM_LENGTHr_MAXFRf_SET BCM53324_A0_FRM_LENGTHr_MAXFRf_SET
#define READ_FRM_LENGTHr BCM53324_A0_READ_FRM_LENGTHr
#define WRITE_FRM_LENGTHr BCM53324_A0_WRITE_FRM_LENGTHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_FRM_LENGTHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE0_EEE_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE0 EEE config
 * SIZE:     32
 * FIELDS:
 *     EEE_DURATION_TIMER_PULSE Timer to generate 10us pulse using 125MHz MAC TX Pll clock.
 *     COUNTER_MODE     RX & TX Counter behaviour. 1 - symmetric mode 0-aymmetric mode.
 *     COUNTER_ROLLOVER 1- Rollover 2- Clear on read with saturate.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_GE0_EEE_CONFIGr 0x00080036

#define BCM53324_A0_GE0_EEE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE0_EEE_CONFIG.
 *
 */
typedef union BCM53324_A0_GE0_EEE_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge0_eee_config[1];
	uint32_t _ge0_eee_config;
} BCM53324_A0_GE0_EEE_CONFIGr_t;

#define BCM53324_A0_GE0_EEE_CONFIGr_CLR(r) (r).ge0_eee_config[0] = 0
#define BCM53324_A0_GE0_EEE_CONFIGr_SET(r,d) (r).ge0_eee_config[0] = d
#define BCM53324_A0_GE0_EEE_CONFIGr_GET(r) (r).ge0_eee_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE0_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET(r) (((r).ge0_eee_config[0]) & 0x7ff)
#define BCM53324_A0_GE0_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET(r,f) (r).ge0_eee_config[0]=(((r).ge0_eee_config[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_GE0_EEE_CONFIGr_COUNTER_MODEf_GET(r) ((((r).ge0_eee_config[0]) >> 11) & 0x1)
#define BCM53324_A0_GE0_EEE_CONFIGr_COUNTER_MODEf_SET(r,f) (r).ge0_eee_config[0]=(((r).ge0_eee_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_GE0_EEE_CONFIGr_COUNTER_ROLLOVERf_GET(r) ((((r).ge0_eee_config[0]) >> 12) & 0x1)
#define BCM53324_A0_GE0_EEE_CONFIGr_COUNTER_ROLLOVERf_SET(r,f) (r).ge0_eee_config[0]=(((r).ge0_eee_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_GE0_EEE_CONFIGr_RESERVEDf_GET(r) ((((r).ge0_eee_config[0]) >> 13) & 0x7ffff)
#define BCM53324_A0_GE0_EEE_CONFIGr_RESERVEDf_SET(r,f) (r).ge0_eee_config[0]=(((r).ge0_eee_config[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access GE0_EEE_CONFIG.
 *
 */
#define BCM53324_A0_READ_GE0_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE0_EEE_CONFIGr,(r._ge0_eee_config))
#define BCM53324_A0_WRITE_GE0_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE0_EEE_CONFIGr,&(r._ge0_eee_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_EEE_CONFIGr BCM53324_A0_GE0_EEE_CONFIGr
#define GE0_EEE_CONFIGr_SIZE BCM53324_A0_GE0_EEE_CONFIGr_SIZE
typedef BCM53324_A0_GE0_EEE_CONFIGr_t GE0_EEE_CONFIGr_t;
#define GE0_EEE_CONFIGr_CLR BCM53324_A0_GE0_EEE_CONFIGr_CLR
#define GE0_EEE_CONFIGr_SET BCM53324_A0_GE0_EEE_CONFIGr_SET
#define GE0_EEE_CONFIGr_GET BCM53324_A0_GE0_EEE_CONFIGr_GET
#define GE0_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET BCM53324_A0_GE0_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET
#define GE0_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET BCM53324_A0_GE0_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET
#define GE0_EEE_CONFIGr_COUNTER_MODEf_GET BCM53324_A0_GE0_EEE_CONFIGr_COUNTER_MODEf_GET
#define GE0_EEE_CONFIGr_COUNTER_MODEf_SET BCM53324_A0_GE0_EEE_CONFIGr_COUNTER_MODEf_SET
#define GE0_EEE_CONFIGr_COUNTER_ROLLOVERf_GET BCM53324_A0_GE0_EEE_CONFIGr_COUNTER_ROLLOVERf_GET
#define GE0_EEE_CONFIGr_COUNTER_ROLLOVERf_SET BCM53324_A0_GE0_EEE_CONFIGr_COUNTER_ROLLOVERf_SET
#define GE0_EEE_CONFIGr_RESERVEDf_GET BCM53324_A0_GE0_EEE_CONFIGr_RESERVEDf_GET
#define GE0_EEE_CONFIGr_RESERVEDf_SET BCM53324_A0_GE0_EEE_CONFIGr_RESERVEDf_SET
#define READ_GE0_EEE_CONFIGr BCM53324_A0_READ_GE0_EEE_CONFIGr
#define WRITE_GE0_EEE_CONFIGr BCM53324_A0_WRITE_GE0_EEE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE0_EEE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE0_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE0 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE0_GBODE_CELL_CNTr 0x00080010

#define BCM53324_A0_GE0_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE0_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge0_gbode_cell_cnt[1];
	uint32_t _ge0_gbode_cell_cnt;
} BCM53324_A0_GE0_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE0_GBODE_CELL_CNTr_CLR(r) (r).ge0_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE0_GBODE_CELL_CNTr_SET(r,d) (r).ge0_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE0_GBODE_CELL_CNTr_GET(r) (r).ge0_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge0_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge0_gbode_cell_cnt[0]=(((r).ge0_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE0_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE0_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE0_GBODE_CELL_CNTr,(r._ge0_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE0_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE0_GBODE_CELL_CNTr,&(r._ge0_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBODE_CELL_CNTr BCM53324_A0_GE0_GBODE_CELL_CNTr
#define GE0_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE0_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE0_GBODE_CELL_CNTr_t GE0_GBODE_CELL_CNTr_t;
#define GE0_GBODE_CELL_CNTr_CLR BCM53324_A0_GE0_GBODE_CELL_CNTr_CLR
#define GE0_GBODE_CELL_CNTr_SET BCM53324_A0_GE0_GBODE_CELL_CNTr_SET
#define GE0_GBODE_CELL_CNTr_GET BCM53324_A0_GE0_GBODE_CELL_CNTr_GET
#define GE0_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE0_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE0_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE0_GBODE_CELL_CNTr BCM53324_A0_READ_GE0_GBODE_CELL_CNTr
#define WRITE_GE0_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE0_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE0_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE0_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE0 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr 0x0008001c

#define BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge0_gbode_cell_req_cnt[1];
	uint32_t _ge0_gbode_cell_req_cnt;
} BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge0_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge0_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_GET(r) (r).ge0_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge0_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge0_gbode_cell_req_cnt[0]=(((r).ge0_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE0_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE0_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr,(r._ge0_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE0_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr,&(r._ge0_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBODE_CELL_REQ_CNTr BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr
#define GE0_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_t GE0_GBODE_CELL_REQ_CNTr_t;
#define GE0_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_CLR
#define GE0_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_SET
#define GE0_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_GET
#define GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE0_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE0_GBODE_CELL_REQ_CNTr
#define WRITE_GE0_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE0_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE0_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE0_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE0 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE0_GBOD_OVRFLWr 0x00080004

#define BCM53324_A0_GE0_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE0_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE0_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge0_gbod_ovrflw[1];
	uint32_t _ge0_gbod_ovrflw;
} BCM53324_A0_GE0_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE0_GBOD_OVRFLWr_CLR(r) (r).ge0_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE0_GBOD_OVRFLWr_SET(r,d) (r).ge0_gbod_ovrflw[0] = d
#define BCM53324_A0_GE0_GBOD_OVRFLWr_GET(r) (r).ge0_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE0_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge0_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE0_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge0_gbod_ovrflw[0]=(((r).ge0_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE0_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE0_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE0_GBOD_OVRFLWr,(r._ge0_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE0_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE0_GBOD_OVRFLWr,&(r._ge0_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE0_GBOD_OVRFLWr BCM53324_A0_GE0_GBOD_OVRFLWr
#define GE0_GBOD_OVRFLWr_SIZE BCM53324_A0_GE0_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE0_GBOD_OVRFLWr_t GE0_GBOD_OVRFLWr_t;
#define GE0_GBOD_OVRFLWr_CLR BCM53324_A0_GE0_GBOD_OVRFLWr_CLR
#define GE0_GBOD_OVRFLWr_SET BCM53324_A0_GE0_GBOD_OVRFLWr_SET
#define GE0_GBOD_OVRFLWr_GET BCM53324_A0_GE0_GBOD_OVRFLWr_GET
#define GE0_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE0_GBOD_OVRFLWr_OVRFLWf_GET
#define GE0_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE0_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE0_GBOD_OVRFLWr BCM53324_A0_READ_GE0_GBOD_OVRFLWr
#define WRITE_GE0_GBOD_OVRFLWr BCM53324_A0_WRITE_GE0_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE0_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE10_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE10 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE10_GBODE_CELL_CNTr 0x0008001a

#define BCM53324_A0_GE10_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE10_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge10_gbode_cell_cnt[1];
	uint32_t _ge10_gbode_cell_cnt;
} BCM53324_A0_GE10_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE10_GBODE_CELL_CNTr_CLR(r) (r).ge10_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE10_GBODE_CELL_CNTr_SET(r,d) (r).ge10_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE10_GBODE_CELL_CNTr_GET(r) (r).ge10_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge10_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge10_gbode_cell_cnt[0]=(((r).ge10_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE10_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE10_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE10_GBODE_CELL_CNTr,(r._ge10_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE10_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE10_GBODE_CELL_CNTr,&(r._ge10_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBODE_CELL_CNTr BCM53324_A0_GE10_GBODE_CELL_CNTr
#define GE10_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE10_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE10_GBODE_CELL_CNTr_t GE10_GBODE_CELL_CNTr_t;
#define GE10_GBODE_CELL_CNTr_CLR BCM53324_A0_GE10_GBODE_CELL_CNTr_CLR
#define GE10_GBODE_CELL_CNTr_SET BCM53324_A0_GE10_GBODE_CELL_CNTr_SET
#define GE10_GBODE_CELL_CNTr_GET BCM53324_A0_GE10_GBODE_CELL_CNTr_GET
#define GE10_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE10_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE10_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE10_GBODE_CELL_CNTr BCM53324_A0_READ_GE10_GBODE_CELL_CNTr
#define WRITE_GE10_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE10_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE10_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE10_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE10 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr 0x00080026

#define BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge10_gbode_cell_req_cnt[1];
	uint32_t _ge10_gbode_cell_req_cnt;
} BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge10_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge10_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_GET(r) (r).ge10_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge10_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge10_gbode_cell_req_cnt[0]=(((r).ge10_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE10_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE10_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr,(r._ge10_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE10_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr,&(r._ge10_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBODE_CELL_REQ_CNTr BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr
#define GE10_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_t GE10_GBODE_CELL_REQ_CNTr_t;
#define GE10_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_CLR
#define GE10_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_SET
#define GE10_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_GET
#define GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE10_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE10_GBODE_CELL_REQ_CNTr
#define WRITE_GE10_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE10_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE10_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE10_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE10 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE10_GBOD_OVRFLWr 0x0008000e

#define BCM53324_A0_GE10_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE10_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE10_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge10_gbod_ovrflw[1];
	uint32_t _ge10_gbod_ovrflw;
} BCM53324_A0_GE10_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE10_GBOD_OVRFLWr_CLR(r) (r).ge10_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE10_GBOD_OVRFLWr_SET(r,d) (r).ge10_gbod_ovrflw[0] = d
#define BCM53324_A0_GE10_GBOD_OVRFLWr_GET(r) (r).ge10_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE10_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge10_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE10_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge10_gbod_ovrflw[0]=(((r).ge10_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE10_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE10_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE10_GBOD_OVRFLWr,(r._ge10_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE10_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE10_GBOD_OVRFLWr,&(r._ge10_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE10_GBOD_OVRFLWr BCM53324_A0_GE10_GBOD_OVRFLWr
#define GE10_GBOD_OVRFLWr_SIZE BCM53324_A0_GE10_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE10_GBOD_OVRFLWr_t GE10_GBOD_OVRFLWr_t;
#define GE10_GBOD_OVRFLWr_CLR BCM53324_A0_GE10_GBOD_OVRFLWr_CLR
#define GE10_GBOD_OVRFLWr_SET BCM53324_A0_GE10_GBOD_OVRFLWr_SET
#define GE10_GBOD_OVRFLWr_GET BCM53324_A0_GE10_GBOD_OVRFLWr_GET
#define GE10_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE10_GBOD_OVRFLWr_OVRFLWf_GET
#define GE10_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE10_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE10_GBOD_OVRFLWr BCM53324_A0_READ_GE10_GBOD_OVRFLWr
#define WRITE_GE10_GBOD_OVRFLWr BCM53324_A0_WRITE_GE10_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE10_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE11_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE11 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE11_GBODE_CELL_CNTr 0x0008001b

#define BCM53324_A0_GE11_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE11_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge11_gbode_cell_cnt[1];
	uint32_t _ge11_gbode_cell_cnt;
} BCM53324_A0_GE11_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE11_GBODE_CELL_CNTr_CLR(r) (r).ge11_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE11_GBODE_CELL_CNTr_SET(r,d) (r).ge11_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE11_GBODE_CELL_CNTr_GET(r) (r).ge11_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge11_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge11_gbode_cell_cnt[0]=(((r).ge11_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE11_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE11_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE11_GBODE_CELL_CNTr,(r._ge11_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE11_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE11_GBODE_CELL_CNTr,&(r._ge11_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBODE_CELL_CNTr BCM53324_A0_GE11_GBODE_CELL_CNTr
#define GE11_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE11_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE11_GBODE_CELL_CNTr_t GE11_GBODE_CELL_CNTr_t;
#define GE11_GBODE_CELL_CNTr_CLR BCM53324_A0_GE11_GBODE_CELL_CNTr_CLR
#define GE11_GBODE_CELL_CNTr_SET BCM53324_A0_GE11_GBODE_CELL_CNTr_SET
#define GE11_GBODE_CELL_CNTr_GET BCM53324_A0_GE11_GBODE_CELL_CNTr_GET
#define GE11_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE11_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE11_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE11_GBODE_CELL_CNTr BCM53324_A0_READ_GE11_GBODE_CELL_CNTr
#define WRITE_GE11_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE11_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE11_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE11_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE11 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr 0x00080027

#define BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge11_gbode_cell_req_cnt[1];
	uint32_t _ge11_gbode_cell_req_cnt;
} BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge11_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge11_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_GET(r) (r).ge11_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge11_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge11_gbode_cell_req_cnt[0]=(((r).ge11_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE11_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE11_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr,(r._ge11_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE11_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr,&(r._ge11_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBODE_CELL_REQ_CNTr BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr
#define GE11_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_t GE11_GBODE_CELL_REQ_CNTr_t;
#define GE11_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_CLR
#define GE11_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_SET
#define GE11_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_GET
#define GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE11_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE11_GBODE_CELL_REQ_CNTr
#define WRITE_GE11_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE11_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE11_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE11_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE11 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE11_GBOD_OVRFLWr 0x0008000f

#define BCM53324_A0_GE11_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE11_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE11_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge11_gbod_ovrflw[1];
	uint32_t _ge11_gbod_ovrflw;
} BCM53324_A0_GE11_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE11_GBOD_OVRFLWr_CLR(r) (r).ge11_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE11_GBOD_OVRFLWr_SET(r,d) (r).ge11_gbod_ovrflw[0] = d
#define BCM53324_A0_GE11_GBOD_OVRFLWr_GET(r) (r).ge11_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE11_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge11_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE11_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge11_gbod_ovrflw[0]=(((r).ge11_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE11_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE11_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE11_GBOD_OVRFLWr,(r._ge11_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE11_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE11_GBOD_OVRFLWr,&(r._ge11_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE11_GBOD_OVRFLWr BCM53324_A0_GE11_GBOD_OVRFLWr
#define GE11_GBOD_OVRFLWr_SIZE BCM53324_A0_GE11_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE11_GBOD_OVRFLWr_t GE11_GBOD_OVRFLWr_t;
#define GE11_GBOD_OVRFLWr_CLR BCM53324_A0_GE11_GBOD_OVRFLWr_CLR
#define GE11_GBOD_OVRFLWr_SET BCM53324_A0_GE11_GBOD_OVRFLWr_SET
#define GE11_GBOD_OVRFLWr_GET BCM53324_A0_GE11_GBOD_OVRFLWr_GET
#define GE11_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE11_GBOD_OVRFLWr_OVRFLWf_GET
#define GE11_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE11_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE11_GBOD_OVRFLWr BCM53324_A0_READ_GE11_GBOD_OVRFLWr
#define WRITE_GE11_GBOD_OVRFLWr BCM53324_A0_WRITE_GE11_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE11_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE1_EEE_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE1 EEE config
 * SIZE:     32
 * FIELDS:
 *     EEE_DURATION_TIMER_PULSE Timer to generate 10us pulse using 125MHz MAC TX Pll clock.
 *     COUNTER_MODE     RX & TX Counter behaviour. 1 - symmetric mode 0-aymmetric mode.
 *     COUNTER_ROLLOVER 1- Rollover 2- Clear on read with saturate.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_GE1_EEE_CONFIGr 0x00080037

#define BCM53324_A0_GE1_EEE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE1_EEE_CONFIG.
 *
 */
typedef union BCM53324_A0_GE1_EEE_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge1_eee_config[1];
	uint32_t _ge1_eee_config;
} BCM53324_A0_GE1_EEE_CONFIGr_t;

#define BCM53324_A0_GE1_EEE_CONFIGr_CLR(r) (r).ge1_eee_config[0] = 0
#define BCM53324_A0_GE1_EEE_CONFIGr_SET(r,d) (r).ge1_eee_config[0] = d
#define BCM53324_A0_GE1_EEE_CONFIGr_GET(r) (r).ge1_eee_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE1_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET(r) (((r).ge1_eee_config[0]) & 0x7ff)
#define BCM53324_A0_GE1_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET(r,f) (r).ge1_eee_config[0]=(((r).ge1_eee_config[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_GE1_EEE_CONFIGr_COUNTER_MODEf_GET(r) ((((r).ge1_eee_config[0]) >> 11) & 0x1)
#define BCM53324_A0_GE1_EEE_CONFIGr_COUNTER_MODEf_SET(r,f) (r).ge1_eee_config[0]=(((r).ge1_eee_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_GE1_EEE_CONFIGr_COUNTER_ROLLOVERf_GET(r) ((((r).ge1_eee_config[0]) >> 12) & 0x1)
#define BCM53324_A0_GE1_EEE_CONFIGr_COUNTER_ROLLOVERf_SET(r,f) (r).ge1_eee_config[0]=(((r).ge1_eee_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_GE1_EEE_CONFIGr_RESERVEDf_GET(r) ((((r).ge1_eee_config[0]) >> 13) & 0x7ffff)
#define BCM53324_A0_GE1_EEE_CONFIGr_RESERVEDf_SET(r,f) (r).ge1_eee_config[0]=(((r).ge1_eee_config[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access GE1_EEE_CONFIG.
 *
 */
#define BCM53324_A0_READ_GE1_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE1_EEE_CONFIGr,(r._ge1_eee_config))
#define BCM53324_A0_WRITE_GE1_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE1_EEE_CONFIGr,&(r._ge1_eee_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_EEE_CONFIGr BCM53324_A0_GE1_EEE_CONFIGr
#define GE1_EEE_CONFIGr_SIZE BCM53324_A0_GE1_EEE_CONFIGr_SIZE
typedef BCM53324_A0_GE1_EEE_CONFIGr_t GE1_EEE_CONFIGr_t;
#define GE1_EEE_CONFIGr_CLR BCM53324_A0_GE1_EEE_CONFIGr_CLR
#define GE1_EEE_CONFIGr_SET BCM53324_A0_GE1_EEE_CONFIGr_SET
#define GE1_EEE_CONFIGr_GET BCM53324_A0_GE1_EEE_CONFIGr_GET
#define GE1_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET BCM53324_A0_GE1_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET
#define GE1_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET BCM53324_A0_GE1_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET
#define GE1_EEE_CONFIGr_COUNTER_MODEf_GET BCM53324_A0_GE1_EEE_CONFIGr_COUNTER_MODEf_GET
#define GE1_EEE_CONFIGr_COUNTER_MODEf_SET BCM53324_A0_GE1_EEE_CONFIGr_COUNTER_MODEf_SET
#define GE1_EEE_CONFIGr_COUNTER_ROLLOVERf_GET BCM53324_A0_GE1_EEE_CONFIGr_COUNTER_ROLLOVERf_GET
#define GE1_EEE_CONFIGr_COUNTER_ROLLOVERf_SET BCM53324_A0_GE1_EEE_CONFIGr_COUNTER_ROLLOVERf_SET
#define GE1_EEE_CONFIGr_RESERVEDf_GET BCM53324_A0_GE1_EEE_CONFIGr_RESERVEDf_GET
#define GE1_EEE_CONFIGr_RESERVEDf_SET BCM53324_A0_GE1_EEE_CONFIGr_RESERVEDf_SET
#define READ_GE1_EEE_CONFIGr BCM53324_A0_READ_GE1_EEE_CONFIGr
#define WRITE_GE1_EEE_CONFIGr BCM53324_A0_WRITE_GE1_EEE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE1_EEE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE1_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE1 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE1_GBODE_CELL_CNTr 0x00080011

#define BCM53324_A0_GE1_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE1_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge1_gbode_cell_cnt[1];
	uint32_t _ge1_gbode_cell_cnt;
} BCM53324_A0_GE1_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE1_GBODE_CELL_CNTr_CLR(r) (r).ge1_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE1_GBODE_CELL_CNTr_SET(r,d) (r).ge1_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE1_GBODE_CELL_CNTr_GET(r) (r).ge1_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge1_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge1_gbode_cell_cnt[0]=(((r).ge1_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE1_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE1_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE1_GBODE_CELL_CNTr,(r._ge1_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE1_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE1_GBODE_CELL_CNTr,&(r._ge1_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBODE_CELL_CNTr BCM53324_A0_GE1_GBODE_CELL_CNTr
#define GE1_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE1_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE1_GBODE_CELL_CNTr_t GE1_GBODE_CELL_CNTr_t;
#define GE1_GBODE_CELL_CNTr_CLR BCM53324_A0_GE1_GBODE_CELL_CNTr_CLR
#define GE1_GBODE_CELL_CNTr_SET BCM53324_A0_GE1_GBODE_CELL_CNTr_SET
#define GE1_GBODE_CELL_CNTr_GET BCM53324_A0_GE1_GBODE_CELL_CNTr_GET
#define GE1_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE1_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE1_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE1_GBODE_CELL_CNTr BCM53324_A0_READ_GE1_GBODE_CELL_CNTr
#define WRITE_GE1_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE1_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE1_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE1_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE1 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr 0x0008001d

#define BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge1_gbode_cell_req_cnt[1];
	uint32_t _ge1_gbode_cell_req_cnt;
} BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge1_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge1_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_GET(r) (r).ge1_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge1_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge1_gbode_cell_req_cnt[0]=(((r).ge1_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE1_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE1_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr,(r._ge1_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE1_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr,&(r._ge1_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBODE_CELL_REQ_CNTr BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr
#define GE1_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_t GE1_GBODE_CELL_REQ_CNTr_t;
#define GE1_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_CLR
#define GE1_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_SET
#define GE1_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_GET
#define GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE1_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE1_GBODE_CELL_REQ_CNTr
#define WRITE_GE1_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE1_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE1_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE1_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE1 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE1_GBOD_OVRFLWr 0x00080005

#define BCM53324_A0_GE1_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE1_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE1_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge1_gbod_ovrflw[1];
	uint32_t _ge1_gbod_ovrflw;
} BCM53324_A0_GE1_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE1_GBOD_OVRFLWr_CLR(r) (r).ge1_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE1_GBOD_OVRFLWr_SET(r,d) (r).ge1_gbod_ovrflw[0] = d
#define BCM53324_A0_GE1_GBOD_OVRFLWr_GET(r) (r).ge1_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE1_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge1_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE1_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge1_gbod_ovrflw[0]=(((r).ge1_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE1_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE1_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE1_GBOD_OVRFLWr,(r._ge1_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE1_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE1_GBOD_OVRFLWr,&(r._ge1_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE1_GBOD_OVRFLWr BCM53324_A0_GE1_GBOD_OVRFLWr
#define GE1_GBOD_OVRFLWr_SIZE BCM53324_A0_GE1_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE1_GBOD_OVRFLWr_t GE1_GBOD_OVRFLWr_t;
#define GE1_GBOD_OVRFLWr_CLR BCM53324_A0_GE1_GBOD_OVRFLWr_CLR
#define GE1_GBOD_OVRFLWr_SET BCM53324_A0_GE1_GBOD_OVRFLWr_SET
#define GE1_GBOD_OVRFLWr_GET BCM53324_A0_GE1_GBOD_OVRFLWr_GET
#define GE1_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE1_GBOD_OVRFLWr_OVRFLWf_GET
#define GE1_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE1_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE1_GBOD_OVRFLWr BCM53324_A0_READ_GE1_GBOD_OVRFLWr
#define WRITE_GE1_GBOD_OVRFLWr BCM53324_A0_WRITE_GE1_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE1_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE2_EEE_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE2 EEE config
 * SIZE:     32
 * FIELDS:
 *     EEE_DURATION_TIMER_PULSE Timer to generate 10us pulse using 125MHz MAC TX Pll clock.
 *     COUNTER_MODE     RX & TX Counter behaviour. 1 - symmetric mode 0-aymmetric mode.
 *     COUNTER_ROLLOVER 1- Rollover 2- Clear on read with saturate.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_GE2_EEE_CONFIGr 0x00080038

#define BCM53324_A0_GE2_EEE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE2_EEE_CONFIG.
 *
 */
typedef union BCM53324_A0_GE2_EEE_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge2_eee_config[1];
	uint32_t _ge2_eee_config;
} BCM53324_A0_GE2_EEE_CONFIGr_t;

#define BCM53324_A0_GE2_EEE_CONFIGr_CLR(r) (r).ge2_eee_config[0] = 0
#define BCM53324_A0_GE2_EEE_CONFIGr_SET(r,d) (r).ge2_eee_config[0] = d
#define BCM53324_A0_GE2_EEE_CONFIGr_GET(r) (r).ge2_eee_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE2_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET(r) (((r).ge2_eee_config[0]) & 0x7ff)
#define BCM53324_A0_GE2_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET(r,f) (r).ge2_eee_config[0]=(((r).ge2_eee_config[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_GE2_EEE_CONFIGr_COUNTER_MODEf_GET(r) ((((r).ge2_eee_config[0]) >> 11) & 0x1)
#define BCM53324_A0_GE2_EEE_CONFIGr_COUNTER_MODEf_SET(r,f) (r).ge2_eee_config[0]=(((r).ge2_eee_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_GE2_EEE_CONFIGr_COUNTER_ROLLOVERf_GET(r) ((((r).ge2_eee_config[0]) >> 12) & 0x1)
#define BCM53324_A0_GE2_EEE_CONFIGr_COUNTER_ROLLOVERf_SET(r,f) (r).ge2_eee_config[0]=(((r).ge2_eee_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_GE2_EEE_CONFIGr_RESERVEDf_GET(r) ((((r).ge2_eee_config[0]) >> 13) & 0x7ffff)
#define BCM53324_A0_GE2_EEE_CONFIGr_RESERVEDf_SET(r,f) (r).ge2_eee_config[0]=(((r).ge2_eee_config[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access GE2_EEE_CONFIG.
 *
 */
#define BCM53324_A0_READ_GE2_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE2_EEE_CONFIGr,(r._ge2_eee_config))
#define BCM53324_A0_WRITE_GE2_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE2_EEE_CONFIGr,&(r._ge2_eee_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_EEE_CONFIGr BCM53324_A0_GE2_EEE_CONFIGr
#define GE2_EEE_CONFIGr_SIZE BCM53324_A0_GE2_EEE_CONFIGr_SIZE
typedef BCM53324_A0_GE2_EEE_CONFIGr_t GE2_EEE_CONFIGr_t;
#define GE2_EEE_CONFIGr_CLR BCM53324_A0_GE2_EEE_CONFIGr_CLR
#define GE2_EEE_CONFIGr_SET BCM53324_A0_GE2_EEE_CONFIGr_SET
#define GE2_EEE_CONFIGr_GET BCM53324_A0_GE2_EEE_CONFIGr_GET
#define GE2_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET BCM53324_A0_GE2_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET
#define GE2_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET BCM53324_A0_GE2_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET
#define GE2_EEE_CONFIGr_COUNTER_MODEf_GET BCM53324_A0_GE2_EEE_CONFIGr_COUNTER_MODEf_GET
#define GE2_EEE_CONFIGr_COUNTER_MODEf_SET BCM53324_A0_GE2_EEE_CONFIGr_COUNTER_MODEf_SET
#define GE2_EEE_CONFIGr_COUNTER_ROLLOVERf_GET BCM53324_A0_GE2_EEE_CONFIGr_COUNTER_ROLLOVERf_GET
#define GE2_EEE_CONFIGr_COUNTER_ROLLOVERf_SET BCM53324_A0_GE2_EEE_CONFIGr_COUNTER_ROLLOVERf_SET
#define GE2_EEE_CONFIGr_RESERVEDf_GET BCM53324_A0_GE2_EEE_CONFIGr_RESERVEDf_GET
#define GE2_EEE_CONFIGr_RESERVEDf_SET BCM53324_A0_GE2_EEE_CONFIGr_RESERVEDf_SET
#define READ_GE2_EEE_CONFIGr BCM53324_A0_READ_GE2_EEE_CONFIGr
#define WRITE_GE2_EEE_CONFIGr BCM53324_A0_WRITE_GE2_EEE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE2_EEE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE2_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE2 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE2_GBODE_CELL_CNTr 0x00080012

#define BCM53324_A0_GE2_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE2_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge2_gbode_cell_cnt[1];
	uint32_t _ge2_gbode_cell_cnt;
} BCM53324_A0_GE2_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE2_GBODE_CELL_CNTr_CLR(r) (r).ge2_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE2_GBODE_CELL_CNTr_SET(r,d) (r).ge2_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE2_GBODE_CELL_CNTr_GET(r) (r).ge2_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge2_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge2_gbode_cell_cnt[0]=(((r).ge2_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE2_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE2_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE2_GBODE_CELL_CNTr,(r._ge2_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE2_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE2_GBODE_CELL_CNTr,&(r._ge2_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBODE_CELL_CNTr BCM53324_A0_GE2_GBODE_CELL_CNTr
#define GE2_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE2_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE2_GBODE_CELL_CNTr_t GE2_GBODE_CELL_CNTr_t;
#define GE2_GBODE_CELL_CNTr_CLR BCM53324_A0_GE2_GBODE_CELL_CNTr_CLR
#define GE2_GBODE_CELL_CNTr_SET BCM53324_A0_GE2_GBODE_CELL_CNTr_SET
#define GE2_GBODE_CELL_CNTr_GET BCM53324_A0_GE2_GBODE_CELL_CNTr_GET
#define GE2_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE2_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE2_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE2_GBODE_CELL_CNTr BCM53324_A0_READ_GE2_GBODE_CELL_CNTr
#define WRITE_GE2_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE2_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE2_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE2_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE2 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr 0x0008001e

#define BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge2_gbode_cell_req_cnt[1];
	uint32_t _ge2_gbode_cell_req_cnt;
} BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge2_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge2_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_GET(r) (r).ge2_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge2_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge2_gbode_cell_req_cnt[0]=(((r).ge2_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE2_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE2_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr,(r._ge2_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE2_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr,&(r._ge2_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBODE_CELL_REQ_CNTr BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr
#define GE2_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_t GE2_GBODE_CELL_REQ_CNTr_t;
#define GE2_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_CLR
#define GE2_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_SET
#define GE2_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_GET
#define GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE2_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE2_GBODE_CELL_REQ_CNTr
#define WRITE_GE2_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE2_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE2_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE2_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE2 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE2_GBOD_OVRFLWr 0x00080006

#define BCM53324_A0_GE2_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE2_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE2_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge2_gbod_ovrflw[1];
	uint32_t _ge2_gbod_ovrflw;
} BCM53324_A0_GE2_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE2_GBOD_OVRFLWr_CLR(r) (r).ge2_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE2_GBOD_OVRFLWr_SET(r,d) (r).ge2_gbod_ovrflw[0] = d
#define BCM53324_A0_GE2_GBOD_OVRFLWr_GET(r) (r).ge2_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE2_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge2_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE2_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge2_gbod_ovrflw[0]=(((r).ge2_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE2_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE2_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE2_GBOD_OVRFLWr,(r._ge2_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE2_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE2_GBOD_OVRFLWr,&(r._ge2_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE2_GBOD_OVRFLWr BCM53324_A0_GE2_GBOD_OVRFLWr
#define GE2_GBOD_OVRFLWr_SIZE BCM53324_A0_GE2_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE2_GBOD_OVRFLWr_t GE2_GBOD_OVRFLWr_t;
#define GE2_GBOD_OVRFLWr_CLR BCM53324_A0_GE2_GBOD_OVRFLWr_CLR
#define GE2_GBOD_OVRFLWr_SET BCM53324_A0_GE2_GBOD_OVRFLWr_SET
#define GE2_GBOD_OVRFLWr_GET BCM53324_A0_GE2_GBOD_OVRFLWr_GET
#define GE2_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE2_GBOD_OVRFLWr_OVRFLWf_GET
#define GE2_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE2_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE2_GBOD_OVRFLWr BCM53324_A0_READ_GE2_GBOD_OVRFLWr
#define WRITE_GE2_GBOD_OVRFLWr BCM53324_A0_WRITE_GE2_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE2_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE3_EEE_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE3 EEE config
 * SIZE:     32
 * FIELDS:
 *     EEE_DURATION_TIMER_PULSE Timer to generate 10us pulse using 125MHz MAC TX Pll clock.
 *     COUNTER_MODE     RX & TX Counter behaviour. 1 - symmetric mode 0-aymmetric mode.
 *     COUNTER_ROLLOVER 1- Rollover 2- Clear on read with saturate.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_GE3_EEE_CONFIGr 0x00080039

#define BCM53324_A0_GE3_EEE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE3_EEE_CONFIG.
 *
 */
typedef union BCM53324_A0_GE3_EEE_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge3_eee_config[1];
	uint32_t _ge3_eee_config;
} BCM53324_A0_GE3_EEE_CONFIGr_t;

#define BCM53324_A0_GE3_EEE_CONFIGr_CLR(r) (r).ge3_eee_config[0] = 0
#define BCM53324_A0_GE3_EEE_CONFIGr_SET(r,d) (r).ge3_eee_config[0] = d
#define BCM53324_A0_GE3_EEE_CONFIGr_GET(r) (r).ge3_eee_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE3_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET(r) (((r).ge3_eee_config[0]) & 0x7ff)
#define BCM53324_A0_GE3_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET(r,f) (r).ge3_eee_config[0]=(((r).ge3_eee_config[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_GE3_EEE_CONFIGr_COUNTER_MODEf_GET(r) ((((r).ge3_eee_config[0]) >> 11) & 0x1)
#define BCM53324_A0_GE3_EEE_CONFIGr_COUNTER_MODEf_SET(r,f) (r).ge3_eee_config[0]=(((r).ge3_eee_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_GE3_EEE_CONFIGr_COUNTER_ROLLOVERf_GET(r) ((((r).ge3_eee_config[0]) >> 12) & 0x1)
#define BCM53324_A0_GE3_EEE_CONFIGr_COUNTER_ROLLOVERf_SET(r,f) (r).ge3_eee_config[0]=(((r).ge3_eee_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_GE3_EEE_CONFIGr_RESERVEDf_GET(r) ((((r).ge3_eee_config[0]) >> 13) & 0x7ffff)
#define BCM53324_A0_GE3_EEE_CONFIGr_RESERVEDf_SET(r,f) (r).ge3_eee_config[0]=(((r).ge3_eee_config[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access GE3_EEE_CONFIG.
 *
 */
#define BCM53324_A0_READ_GE3_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE3_EEE_CONFIGr,(r._ge3_eee_config))
#define BCM53324_A0_WRITE_GE3_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE3_EEE_CONFIGr,&(r._ge3_eee_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_EEE_CONFIGr BCM53324_A0_GE3_EEE_CONFIGr
#define GE3_EEE_CONFIGr_SIZE BCM53324_A0_GE3_EEE_CONFIGr_SIZE
typedef BCM53324_A0_GE3_EEE_CONFIGr_t GE3_EEE_CONFIGr_t;
#define GE3_EEE_CONFIGr_CLR BCM53324_A0_GE3_EEE_CONFIGr_CLR
#define GE3_EEE_CONFIGr_SET BCM53324_A0_GE3_EEE_CONFIGr_SET
#define GE3_EEE_CONFIGr_GET BCM53324_A0_GE3_EEE_CONFIGr_GET
#define GE3_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET BCM53324_A0_GE3_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET
#define GE3_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET BCM53324_A0_GE3_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET
#define GE3_EEE_CONFIGr_COUNTER_MODEf_GET BCM53324_A0_GE3_EEE_CONFIGr_COUNTER_MODEf_GET
#define GE3_EEE_CONFIGr_COUNTER_MODEf_SET BCM53324_A0_GE3_EEE_CONFIGr_COUNTER_MODEf_SET
#define GE3_EEE_CONFIGr_COUNTER_ROLLOVERf_GET BCM53324_A0_GE3_EEE_CONFIGr_COUNTER_ROLLOVERf_GET
#define GE3_EEE_CONFIGr_COUNTER_ROLLOVERf_SET BCM53324_A0_GE3_EEE_CONFIGr_COUNTER_ROLLOVERf_SET
#define GE3_EEE_CONFIGr_RESERVEDf_GET BCM53324_A0_GE3_EEE_CONFIGr_RESERVEDf_GET
#define GE3_EEE_CONFIGr_RESERVEDf_SET BCM53324_A0_GE3_EEE_CONFIGr_RESERVEDf_SET
#define READ_GE3_EEE_CONFIGr BCM53324_A0_READ_GE3_EEE_CONFIGr
#define WRITE_GE3_EEE_CONFIGr BCM53324_A0_WRITE_GE3_EEE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE3_EEE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE3_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE3 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE3_GBODE_CELL_CNTr 0x00080013

#define BCM53324_A0_GE3_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE3_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge3_gbode_cell_cnt[1];
	uint32_t _ge3_gbode_cell_cnt;
} BCM53324_A0_GE3_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE3_GBODE_CELL_CNTr_CLR(r) (r).ge3_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE3_GBODE_CELL_CNTr_SET(r,d) (r).ge3_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE3_GBODE_CELL_CNTr_GET(r) (r).ge3_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge3_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge3_gbode_cell_cnt[0]=(((r).ge3_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE3_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE3_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE3_GBODE_CELL_CNTr,(r._ge3_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE3_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE3_GBODE_CELL_CNTr,&(r._ge3_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBODE_CELL_CNTr BCM53324_A0_GE3_GBODE_CELL_CNTr
#define GE3_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE3_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE3_GBODE_CELL_CNTr_t GE3_GBODE_CELL_CNTr_t;
#define GE3_GBODE_CELL_CNTr_CLR BCM53324_A0_GE3_GBODE_CELL_CNTr_CLR
#define GE3_GBODE_CELL_CNTr_SET BCM53324_A0_GE3_GBODE_CELL_CNTr_SET
#define GE3_GBODE_CELL_CNTr_GET BCM53324_A0_GE3_GBODE_CELL_CNTr_GET
#define GE3_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE3_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE3_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE3_GBODE_CELL_CNTr BCM53324_A0_READ_GE3_GBODE_CELL_CNTr
#define WRITE_GE3_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE3_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE3_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE3_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE3 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr 0x0008001f

#define BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge3_gbode_cell_req_cnt[1];
	uint32_t _ge3_gbode_cell_req_cnt;
} BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge3_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge3_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_GET(r) (r).ge3_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge3_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge3_gbode_cell_req_cnt[0]=(((r).ge3_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE3_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE3_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr,(r._ge3_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE3_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr,&(r._ge3_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBODE_CELL_REQ_CNTr BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr
#define GE3_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_t GE3_GBODE_CELL_REQ_CNTr_t;
#define GE3_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_CLR
#define GE3_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_SET
#define GE3_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_GET
#define GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE3_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE3_GBODE_CELL_REQ_CNTr
#define WRITE_GE3_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE3_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE3_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE3_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE3 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE3_GBOD_OVRFLWr 0x00080007

#define BCM53324_A0_GE3_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE3_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE3_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge3_gbod_ovrflw[1];
	uint32_t _ge3_gbod_ovrflw;
} BCM53324_A0_GE3_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE3_GBOD_OVRFLWr_CLR(r) (r).ge3_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE3_GBOD_OVRFLWr_SET(r,d) (r).ge3_gbod_ovrflw[0] = d
#define BCM53324_A0_GE3_GBOD_OVRFLWr_GET(r) (r).ge3_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE3_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge3_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE3_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge3_gbod_ovrflw[0]=(((r).ge3_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE3_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE3_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE3_GBOD_OVRFLWr,(r._ge3_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE3_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE3_GBOD_OVRFLWr,&(r._ge3_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE3_GBOD_OVRFLWr BCM53324_A0_GE3_GBOD_OVRFLWr
#define GE3_GBOD_OVRFLWr_SIZE BCM53324_A0_GE3_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE3_GBOD_OVRFLWr_t GE3_GBOD_OVRFLWr_t;
#define GE3_GBOD_OVRFLWr_CLR BCM53324_A0_GE3_GBOD_OVRFLWr_CLR
#define GE3_GBOD_OVRFLWr_SET BCM53324_A0_GE3_GBOD_OVRFLWr_SET
#define GE3_GBOD_OVRFLWr_GET BCM53324_A0_GE3_GBOD_OVRFLWr_GET
#define GE3_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE3_GBOD_OVRFLWr_OVRFLWf_GET
#define GE3_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE3_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE3_GBOD_OVRFLWr BCM53324_A0_READ_GE3_GBOD_OVRFLWr
#define WRITE_GE3_GBOD_OVRFLWr BCM53324_A0_WRITE_GE3_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE3_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE4_EEE_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE4 EEE config
 * SIZE:     32
 * FIELDS:
 *     EEE_DURATION_TIMER_PULSE Timer to generate 10us pulse using 125MHz MAC TX Pll clock.
 *     COUNTER_MODE     RX & TX Counter behaviour. 1 - symmetric mode 0-aymmetric mode.
 *     COUNTER_ROLLOVER 1- Rollover 2- Clear on read with saturate.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_GE4_EEE_CONFIGr 0x0008003a

#define BCM53324_A0_GE4_EEE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE4_EEE_CONFIG.
 *
 */
typedef union BCM53324_A0_GE4_EEE_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge4_eee_config[1];
	uint32_t _ge4_eee_config;
} BCM53324_A0_GE4_EEE_CONFIGr_t;

#define BCM53324_A0_GE4_EEE_CONFIGr_CLR(r) (r).ge4_eee_config[0] = 0
#define BCM53324_A0_GE4_EEE_CONFIGr_SET(r,d) (r).ge4_eee_config[0] = d
#define BCM53324_A0_GE4_EEE_CONFIGr_GET(r) (r).ge4_eee_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE4_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET(r) (((r).ge4_eee_config[0]) & 0x7ff)
#define BCM53324_A0_GE4_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET(r,f) (r).ge4_eee_config[0]=(((r).ge4_eee_config[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_GE4_EEE_CONFIGr_COUNTER_MODEf_GET(r) ((((r).ge4_eee_config[0]) >> 11) & 0x1)
#define BCM53324_A0_GE4_EEE_CONFIGr_COUNTER_MODEf_SET(r,f) (r).ge4_eee_config[0]=(((r).ge4_eee_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_GE4_EEE_CONFIGr_COUNTER_ROLLOVERf_GET(r) ((((r).ge4_eee_config[0]) >> 12) & 0x1)
#define BCM53324_A0_GE4_EEE_CONFIGr_COUNTER_ROLLOVERf_SET(r,f) (r).ge4_eee_config[0]=(((r).ge4_eee_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_GE4_EEE_CONFIGr_RESERVEDf_GET(r) ((((r).ge4_eee_config[0]) >> 13) & 0x7ffff)
#define BCM53324_A0_GE4_EEE_CONFIGr_RESERVEDf_SET(r,f) (r).ge4_eee_config[0]=(((r).ge4_eee_config[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access GE4_EEE_CONFIG.
 *
 */
#define BCM53324_A0_READ_GE4_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE4_EEE_CONFIGr,(r._ge4_eee_config))
#define BCM53324_A0_WRITE_GE4_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE4_EEE_CONFIGr,&(r._ge4_eee_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_EEE_CONFIGr BCM53324_A0_GE4_EEE_CONFIGr
#define GE4_EEE_CONFIGr_SIZE BCM53324_A0_GE4_EEE_CONFIGr_SIZE
typedef BCM53324_A0_GE4_EEE_CONFIGr_t GE4_EEE_CONFIGr_t;
#define GE4_EEE_CONFIGr_CLR BCM53324_A0_GE4_EEE_CONFIGr_CLR
#define GE4_EEE_CONFIGr_SET BCM53324_A0_GE4_EEE_CONFIGr_SET
#define GE4_EEE_CONFIGr_GET BCM53324_A0_GE4_EEE_CONFIGr_GET
#define GE4_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET BCM53324_A0_GE4_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET
#define GE4_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET BCM53324_A0_GE4_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET
#define GE4_EEE_CONFIGr_COUNTER_MODEf_GET BCM53324_A0_GE4_EEE_CONFIGr_COUNTER_MODEf_GET
#define GE4_EEE_CONFIGr_COUNTER_MODEf_SET BCM53324_A0_GE4_EEE_CONFIGr_COUNTER_MODEf_SET
#define GE4_EEE_CONFIGr_COUNTER_ROLLOVERf_GET BCM53324_A0_GE4_EEE_CONFIGr_COUNTER_ROLLOVERf_GET
#define GE4_EEE_CONFIGr_COUNTER_ROLLOVERf_SET BCM53324_A0_GE4_EEE_CONFIGr_COUNTER_ROLLOVERf_SET
#define GE4_EEE_CONFIGr_RESERVEDf_GET BCM53324_A0_GE4_EEE_CONFIGr_RESERVEDf_GET
#define GE4_EEE_CONFIGr_RESERVEDf_SET BCM53324_A0_GE4_EEE_CONFIGr_RESERVEDf_SET
#define READ_GE4_EEE_CONFIGr BCM53324_A0_READ_GE4_EEE_CONFIGr
#define WRITE_GE4_EEE_CONFIGr BCM53324_A0_WRITE_GE4_EEE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE4_EEE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE4_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE4 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE4_GBODE_CELL_CNTr 0x00080014

#define BCM53324_A0_GE4_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE4_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge4_gbode_cell_cnt[1];
	uint32_t _ge4_gbode_cell_cnt;
} BCM53324_A0_GE4_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE4_GBODE_CELL_CNTr_CLR(r) (r).ge4_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE4_GBODE_CELL_CNTr_SET(r,d) (r).ge4_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE4_GBODE_CELL_CNTr_GET(r) (r).ge4_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge4_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge4_gbode_cell_cnt[0]=(((r).ge4_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE4_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE4_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE4_GBODE_CELL_CNTr,(r._ge4_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE4_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE4_GBODE_CELL_CNTr,&(r._ge4_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBODE_CELL_CNTr BCM53324_A0_GE4_GBODE_CELL_CNTr
#define GE4_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE4_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE4_GBODE_CELL_CNTr_t GE4_GBODE_CELL_CNTr_t;
#define GE4_GBODE_CELL_CNTr_CLR BCM53324_A0_GE4_GBODE_CELL_CNTr_CLR
#define GE4_GBODE_CELL_CNTr_SET BCM53324_A0_GE4_GBODE_CELL_CNTr_SET
#define GE4_GBODE_CELL_CNTr_GET BCM53324_A0_GE4_GBODE_CELL_CNTr_GET
#define GE4_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE4_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE4_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE4_GBODE_CELL_CNTr BCM53324_A0_READ_GE4_GBODE_CELL_CNTr
#define WRITE_GE4_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE4_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE4_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE4_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE4 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr 0x00080020

#define BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge4_gbode_cell_req_cnt[1];
	uint32_t _ge4_gbode_cell_req_cnt;
} BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge4_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge4_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_GET(r) (r).ge4_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge4_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge4_gbode_cell_req_cnt[0]=(((r).ge4_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE4_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE4_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr,(r._ge4_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE4_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr,&(r._ge4_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBODE_CELL_REQ_CNTr BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr
#define GE4_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_t GE4_GBODE_CELL_REQ_CNTr_t;
#define GE4_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_CLR
#define GE4_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_SET
#define GE4_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_GET
#define GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE4_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE4_GBODE_CELL_REQ_CNTr
#define WRITE_GE4_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE4_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE4_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE4_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE4 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE4_GBOD_OVRFLWr 0x00080008

#define BCM53324_A0_GE4_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE4_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE4_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge4_gbod_ovrflw[1];
	uint32_t _ge4_gbod_ovrflw;
} BCM53324_A0_GE4_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE4_GBOD_OVRFLWr_CLR(r) (r).ge4_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE4_GBOD_OVRFLWr_SET(r,d) (r).ge4_gbod_ovrflw[0] = d
#define BCM53324_A0_GE4_GBOD_OVRFLWr_GET(r) (r).ge4_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE4_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge4_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE4_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge4_gbod_ovrflw[0]=(((r).ge4_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE4_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE4_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE4_GBOD_OVRFLWr,(r._ge4_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE4_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE4_GBOD_OVRFLWr,&(r._ge4_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE4_GBOD_OVRFLWr BCM53324_A0_GE4_GBOD_OVRFLWr
#define GE4_GBOD_OVRFLWr_SIZE BCM53324_A0_GE4_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE4_GBOD_OVRFLWr_t GE4_GBOD_OVRFLWr_t;
#define GE4_GBOD_OVRFLWr_CLR BCM53324_A0_GE4_GBOD_OVRFLWr_CLR
#define GE4_GBOD_OVRFLWr_SET BCM53324_A0_GE4_GBOD_OVRFLWr_SET
#define GE4_GBOD_OVRFLWr_GET BCM53324_A0_GE4_GBOD_OVRFLWr_GET
#define GE4_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE4_GBOD_OVRFLWr_OVRFLWf_GET
#define GE4_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE4_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE4_GBOD_OVRFLWr BCM53324_A0_READ_GE4_GBOD_OVRFLWr
#define WRITE_GE4_GBOD_OVRFLWr BCM53324_A0_WRITE_GE4_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE4_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE5_EEE_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE5 EEE config
 * SIZE:     32
 * FIELDS:
 *     EEE_DURATION_TIMER_PULSE Timer to generate 10us pulse using 125MHz MAC TX Pll clock.
 *     COUNTER_MODE     RX & TX Counter behaviour. 1 - symmetric mode 0-aymmetric mode.
 *     COUNTER_ROLLOVER 1- Rollover 2- Clear on read with saturate.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_GE5_EEE_CONFIGr 0x0008003b

#define BCM53324_A0_GE5_EEE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE5_EEE_CONFIG.
 *
 */
typedef union BCM53324_A0_GE5_EEE_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge5_eee_config[1];
	uint32_t _ge5_eee_config;
} BCM53324_A0_GE5_EEE_CONFIGr_t;

#define BCM53324_A0_GE5_EEE_CONFIGr_CLR(r) (r).ge5_eee_config[0] = 0
#define BCM53324_A0_GE5_EEE_CONFIGr_SET(r,d) (r).ge5_eee_config[0] = d
#define BCM53324_A0_GE5_EEE_CONFIGr_GET(r) (r).ge5_eee_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE5_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET(r) (((r).ge5_eee_config[0]) & 0x7ff)
#define BCM53324_A0_GE5_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET(r,f) (r).ge5_eee_config[0]=(((r).ge5_eee_config[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_GE5_EEE_CONFIGr_COUNTER_MODEf_GET(r) ((((r).ge5_eee_config[0]) >> 11) & 0x1)
#define BCM53324_A0_GE5_EEE_CONFIGr_COUNTER_MODEf_SET(r,f) (r).ge5_eee_config[0]=(((r).ge5_eee_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_GE5_EEE_CONFIGr_COUNTER_ROLLOVERf_GET(r) ((((r).ge5_eee_config[0]) >> 12) & 0x1)
#define BCM53324_A0_GE5_EEE_CONFIGr_COUNTER_ROLLOVERf_SET(r,f) (r).ge5_eee_config[0]=(((r).ge5_eee_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_GE5_EEE_CONFIGr_RESERVEDf_GET(r) ((((r).ge5_eee_config[0]) >> 13) & 0x7ffff)
#define BCM53324_A0_GE5_EEE_CONFIGr_RESERVEDf_SET(r,f) (r).ge5_eee_config[0]=(((r).ge5_eee_config[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access GE5_EEE_CONFIG.
 *
 */
#define BCM53324_A0_READ_GE5_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE5_EEE_CONFIGr,(r._ge5_eee_config))
#define BCM53324_A0_WRITE_GE5_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE5_EEE_CONFIGr,&(r._ge5_eee_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_EEE_CONFIGr BCM53324_A0_GE5_EEE_CONFIGr
#define GE5_EEE_CONFIGr_SIZE BCM53324_A0_GE5_EEE_CONFIGr_SIZE
typedef BCM53324_A0_GE5_EEE_CONFIGr_t GE5_EEE_CONFIGr_t;
#define GE5_EEE_CONFIGr_CLR BCM53324_A0_GE5_EEE_CONFIGr_CLR
#define GE5_EEE_CONFIGr_SET BCM53324_A0_GE5_EEE_CONFIGr_SET
#define GE5_EEE_CONFIGr_GET BCM53324_A0_GE5_EEE_CONFIGr_GET
#define GE5_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET BCM53324_A0_GE5_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET
#define GE5_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET BCM53324_A0_GE5_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET
#define GE5_EEE_CONFIGr_COUNTER_MODEf_GET BCM53324_A0_GE5_EEE_CONFIGr_COUNTER_MODEf_GET
#define GE5_EEE_CONFIGr_COUNTER_MODEf_SET BCM53324_A0_GE5_EEE_CONFIGr_COUNTER_MODEf_SET
#define GE5_EEE_CONFIGr_COUNTER_ROLLOVERf_GET BCM53324_A0_GE5_EEE_CONFIGr_COUNTER_ROLLOVERf_GET
#define GE5_EEE_CONFIGr_COUNTER_ROLLOVERf_SET BCM53324_A0_GE5_EEE_CONFIGr_COUNTER_ROLLOVERf_SET
#define GE5_EEE_CONFIGr_RESERVEDf_GET BCM53324_A0_GE5_EEE_CONFIGr_RESERVEDf_GET
#define GE5_EEE_CONFIGr_RESERVEDf_SET BCM53324_A0_GE5_EEE_CONFIGr_RESERVEDf_SET
#define READ_GE5_EEE_CONFIGr BCM53324_A0_READ_GE5_EEE_CONFIGr
#define WRITE_GE5_EEE_CONFIGr BCM53324_A0_WRITE_GE5_EEE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE5_EEE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE5_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE5 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE5_GBODE_CELL_CNTr 0x00080015

#define BCM53324_A0_GE5_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE5_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge5_gbode_cell_cnt[1];
	uint32_t _ge5_gbode_cell_cnt;
} BCM53324_A0_GE5_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE5_GBODE_CELL_CNTr_CLR(r) (r).ge5_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE5_GBODE_CELL_CNTr_SET(r,d) (r).ge5_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE5_GBODE_CELL_CNTr_GET(r) (r).ge5_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge5_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge5_gbode_cell_cnt[0]=(((r).ge5_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE5_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE5_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE5_GBODE_CELL_CNTr,(r._ge5_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE5_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE5_GBODE_CELL_CNTr,&(r._ge5_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBODE_CELL_CNTr BCM53324_A0_GE5_GBODE_CELL_CNTr
#define GE5_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE5_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE5_GBODE_CELL_CNTr_t GE5_GBODE_CELL_CNTr_t;
#define GE5_GBODE_CELL_CNTr_CLR BCM53324_A0_GE5_GBODE_CELL_CNTr_CLR
#define GE5_GBODE_CELL_CNTr_SET BCM53324_A0_GE5_GBODE_CELL_CNTr_SET
#define GE5_GBODE_CELL_CNTr_GET BCM53324_A0_GE5_GBODE_CELL_CNTr_GET
#define GE5_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE5_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE5_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE5_GBODE_CELL_CNTr BCM53324_A0_READ_GE5_GBODE_CELL_CNTr
#define WRITE_GE5_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE5_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE5_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE5_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE5 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr 0x00080021

#define BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge5_gbode_cell_req_cnt[1];
	uint32_t _ge5_gbode_cell_req_cnt;
} BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge5_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge5_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_GET(r) (r).ge5_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge5_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge5_gbode_cell_req_cnt[0]=(((r).ge5_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE5_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE5_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr,(r._ge5_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE5_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr,&(r._ge5_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBODE_CELL_REQ_CNTr BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr
#define GE5_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_t GE5_GBODE_CELL_REQ_CNTr_t;
#define GE5_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_CLR
#define GE5_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_SET
#define GE5_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_GET
#define GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE5_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE5_GBODE_CELL_REQ_CNTr
#define WRITE_GE5_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE5_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE5_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE5_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE5 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE5_GBOD_OVRFLWr 0x00080009

#define BCM53324_A0_GE5_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE5_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE5_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge5_gbod_ovrflw[1];
	uint32_t _ge5_gbod_ovrflw;
} BCM53324_A0_GE5_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE5_GBOD_OVRFLWr_CLR(r) (r).ge5_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE5_GBOD_OVRFLWr_SET(r,d) (r).ge5_gbod_ovrflw[0] = d
#define BCM53324_A0_GE5_GBOD_OVRFLWr_GET(r) (r).ge5_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE5_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge5_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE5_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge5_gbod_ovrflw[0]=(((r).ge5_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE5_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE5_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE5_GBOD_OVRFLWr,(r._ge5_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE5_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE5_GBOD_OVRFLWr,&(r._ge5_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE5_GBOD_OVRFLWr BCM53324_A0_GE5_GBOD_OVRFLWr
#define GE5_GBOD_OVRFLWr_SIZE BCM53324_A0_GE5_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE5_GBOD_OVRFLWr_t GE5_GBOD_OVRFLWr_t;
#define GE5_GBOD_OVRFLWr_CLR BCM53324_A0_GE5_GBOD_OVRFLWr_CLR
#define GE5_GBOD_OVRFLWr_SET BCM53324_A0_GE5_GBOD_OVRFLWr_SET
#define GE5_GBOD_OVRFLWr_GET BCM53324_A0_GE5_GBOD_OVRFLWr_GET
#define GE5_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE5_GBOD_OVRFLWr_OVRFLWf_GET
#define GE5_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE5_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE5_GBOD_OVRFLWr BCM53324_A0_READ_GE5_GBOD_OVRFLWr
#define WRITE_GE5_GBOD_OVRFLWr BCM53324_A0_WRITE_GE5_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE5_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE6_EEE_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE6 EEE config
 * SIZE:     32
 * FIELDS:
 *     EEE_DURATION_TIMER_PULSE Timer to generate 10us pulse using 125MHz MAC TX Pll clock.
 *     COUNTER_MODE     RX & TX Counter behaviour. 1 - symmetric mode 0-aymmetric mode.
 *     COUNTER_ROLLOVER 1- Rollover 2- Clear on read with saturate.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_GE6_EEE_CONFIGr 0x0008003c

#define BCM53324_A0_GE6_EEE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE6_EEE_CONFIG.
 *
 */
typedef union BCM53324_A0_GE6_EEE_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge6_eee_config[1];
	uint32_t _ge6_eee_config;
} BCM53324_A0_GE6_EEE_CONFIGr_t;

#define BCM53324_A0_GE6_EEE_CONFIGr_CLR(r) (r).ge6_eee_config[0] = 0
#define BCM53324_A0_GE6_EEE_CONFIGr_SET(r,d) (r).ge6_eee_config[0] = d
#define BCM53324_A0_GE6_EEE_CONFIGr_GET(r) (r).ge6_eee_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE6_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET(r) (((r).ge6_eee_config[0]) & 0x7ff)
#define BCM53324_A0_GE6_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET(r,f) (r).ge6_eee_config[0]=(((r).ge6_eee_config[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_GE6_EEE_CONFIGr_COUNTER_MODEf_GET(r) ((((r).ge6_eee_config[0]) >> 11) & 0x1)
#define BCM53324_A0_GE6_EEE_CONFIGr_COUNTER_MODEf_SET(r,f) (r).ge6_eee_config[0]=(((r).ge6_eee_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_GE6_EEE_CONFIGr_COUNTER_ROLLOVERf_GET(r) ((((r).ge6_eee_config[0]) >> 12) & 0x1)
#define BCM53324_A0_GE6_EEE_CONFIGr_COUNTER_ROLLOVERf_SET(r,f) (r).ge6_eee_config[0]=(((r).ge6_eee_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_GE6_EEE_CONFIGr_RESERVEDf_GET(r) ((((r).ge6_eee_config[0]) >> 13) & 0x7ffff)
#define BCM53324_A0_GE6_EEE_CONFIGr_RESERVEDf_SET(r,f) (r).ge6_eee_config[0]=(((r).ge6_eee_config[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access GE6_EEE_CONFIG.
 *
 */
#define BCM53324_A0_READ_GE6_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE6_EEE_CONFIGr,(r._ge6_eee_config))
#define BCM53324_A0_WRITE_GE6_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE6_EEE_CONFIGr,&(r._ge6_eee_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_EEE_CONFIGr BCM53324_A0_GE6_EEE_CONFIGr
#define GE6_EEE_CONFIGr_SIZE BCM53324_A0_GE6_EEE_CONFIGr_SIZE
typedef BCM53324_A0_GE6_EEE_CONFIGr_t GE6_EEE_CONFIGr_t;
#define GE6_EEE_CONFIGr_CLR BCM53324_A0_GE6_EEE_CONFIGr_CLR
#define GE6_EEE_CONFIGr_SET BCM53324_A0_GE6_EEE_CONFIGr_SET
#define GE6_EEE_CONFIGr_GET BCM53324_A0_GE6_EEE_CONFIGr_GET
#define GE6_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET BCM53324_A0_GE6_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET
#define GE6_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET BCM53324_A0_GE6_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET
#define GE6_EEE_CONFIGr_COUNTER_MODEf_GET BCM53324_A0_GE6_EEE_CONFIGr_COUNTER_MODEf_GET
#define GE6_EEE_CONFIGr_COUNTER_MODEf_SET BCM53324_A0_GE6_EEE_CONFIGr_COUNTER_MODEf_SET
#define GE6_EEE_CONFIGr_COUNTER_ROLLOVERf_GET BCM53324_A0_GE6_EEE_CONFIGr_COUNTER_ROLLOVERf_GET
#define GE6_EEE_CONFIGr_COUNTER_ROLLOVERf_SET BCM53324_A0_GE6_EEE_CONFIGr_COUNTER_ROLLOVERf_SET
#define GE6_EEE_CONFIGr_RESERVEDf_GET BCM53324_A0_GE6_EEE_CONFIGr_RESERVEDf_GET
#define GE6_EEE_CONFIGr_RESERVEDf_SET BCM53324_A0_GE6_EEE_CONFIGr_RESERVEDf_SET
#define READ_GE6_EEE_CONFIGr BCM53324_A0_READ_GE6_EEE_CONFIGr
#define WRITE_GE6_EEE_CONFIGr BCM53324_A0_WRITE_GE6_EEE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE6_EEE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE6_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE6 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE6_GBODE_CELL_CNTr 0x00080016

#define BCM53324_A0_GE6_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE6_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge6_gbode_cell_cnt[1];
	uint32_t _ge6_gbode_cell_cnt;
} BCM53324_A0_GE6_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE6_GBODE_CELL_CNTr_CLR(r) (r).ge6_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE6_GBODE_CELL_CNTr_SET(r,d) (r).ge6_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE6_GBODE_CELL_CNTr_GET(r) (r).ge6_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge6_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge6_gbode_cell_cnt[0]=(((r).ge6_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE6_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE6_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE6_GBODE_CELL_CNTr,(r._ge6_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE6_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE6_GBODE_CELL_CNTr,&(r._ge6_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBODE_CELL_CNTr BCM53324_A0_GE6_GBODE_CELL_CNTr
#define GE6_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE6_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE6_GBODE_CELL_CNTr_t GE6_GBODE_CELL_CNTr_t;
#define GE6_GBODE_CELL_CNTr_CLR BCM53324_A0_GE6_GBODE_CELL_CNTr_CLR
#define GE6_GBODE_CELL_CNTr_SET BCM53324_A0_GE6_GBODE_CELL_CNTr_SET
#define GE6_GBODE_CELL_CNTr_GET BCM53324_A0_GE6_GBODE_CELL_CNTr_GET
#define GE6_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE6_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE6_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE6_GBODE_CELL_CNTr BCM53324_A0_READ_GE6_GBODE_CELL_CNTr
#define WRITE_GE6_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE6_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE6_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE6_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE6 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr 0x00080022

#define BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge6_gbode_cell_req_cnt[1];
	uint32_t _ge6_gbode_cell_req_cnt;
} BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge6_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge6_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_GET(r) (r).ge6_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge6_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge6_gbode_cell_req_cnt[0]=(((r).ge6_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE6_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE6_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr,(r._ge6_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE6_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr,&(r._ge6_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBODE_CELL_REQ_CNTr BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr
#define GE6_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_t GE6_GBODE_CELL_REQ_CNTr_t;
#define GE6_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_CLR
#define GE6_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_SET
#define GE6_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_GET
#define GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE6_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE6_GBODE_CELL_REQ_CNTr
#define WRITE_GE6_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE6_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE6_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE6_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE6 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE6_GBOD_OVRFLWr 0x0008000a

#define BCM53324_A0_GE6_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE6_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE6_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge6_gbod_ovrflw[1];
	uint32_t _ge6_gbod_ovrflw;
} BCM53324_A0_GE6_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE6_GBOD_OVRFLWr_CLR(r) (r).ge6_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE6_GBOD_OVRFLWr_SET(r,d) (r).ge6_gbod_ovrflw[0] = d
#define BCM53324_A0_GE6_GBOD_OVRFLWr_GET(r) (r).ge6_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE6_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge6_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE6_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge6_gbod_ovrflw[0]=(((r).ge6_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE6_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE6_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE6_GBOD_OVRFLWr,(r._ge6_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE6_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE6_GBOD_OVRFLWr,&(r._ge6_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE6_GBOD_OVRFLWr BCM53324_A0_GE6_GBOD_OVRFLWr
#define GE6_GBOD_OVRFLWr_SIZE BCM53324_A0_GE6_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE6_GBOD_OVRFLWr_t GE6_GBOD_OVRFLWr_t;
#define GE6_GBOD_OVRFLWr_CLR BCM53324_A0_GE6_GBOD_OVRFLWr_CLR
#define GE6_GBOD_OVRFLWr_SET BCM53324_A0_GE6_GBOD_OVRFLWr_SET
#define GE6_GBOD_OVRFLWr_GET BCM53324_A0_GE6_GBOD_OVRFLWr_GET
#define GE6_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE6_GBOD_OVRFLWr_OVRFLWf_GET
#define GE6_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE6_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE6_GBOD_OVRFLWr BCM53324_A0_READ_GE6_GBOD_OVRFLWr
#define WRITE_GE6_GBOD_OVRFLWr BCM53324_A0_WRITE_GE6_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE6_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE7_EEE_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GE7 EEE config
 * SIZE:     32
 * FIELDS:
 *     EEE_DURATION_TIMER_PULSE Timer to generate 10us pulse using 125MHz MAC TX Pll clock.
 *     COUNTER_MODE     RX & TX Counter behaviour. 1 - symmetric mode 0-aymmetric mode.
 *     COUNTER_ROLLOVER 1- Rollover 2- Clear on read with saturate.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_GE7_EEE_CONFIGr 0x0008003d

#define BCM53324_A0_GE7_EEE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE7_EEE_CONFIG.
 *
 */
typedef union BCM53324_A0_GE7_EEE_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge7_eee_config[1];
	uint32_t _ge7_eee_config;
} BCM53324_A0_GE7_EEE_CONFIGr_t;

#define BCM53324_A0_GE7_EEE_CONFIGr_CLR(r) (r).ge7_eee_config[0] = 0
#define BCM53324_A0_GE7_EEE_CONFIGr_SET(r,d) (r).ge7_eee_config[0] = d
#define BCM53324_A0_GE7_EEE_CONFIGr_GET(r) (r).ge7_eee_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE7_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET(r) (((r).ge7_eee_config[0]) & 0x7ff)
#define BCM53324_A0_GE7_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET(r,f) (r).ge7_eee_config[0]=(((r).ge7_eee_config[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_GE7_EEE_CONFIGr_COUNTER_MODEf_GET(r) ((((r).ge7_eee_config[0]) >> 11) & 0x1)
#define BCM53324_A0_GE7_EEE_CONFIGr_COUNTER_MODEf_SET(r,f) (r).ge7_eee_config[0]=(((r).ge7_eee_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_GE7_EEE_CONFIGr_COUNTER_ROLLOVERf_GET(r) ((((r).ge7_eee_config[0]) >> 12) & 0x1)
#define BCM53324_A0_GE7_EEE_CONFIGr_COUNTER_ROLLOVERf_SET(r,f) (r).ge7_eee_config[0]=(((r).ge7_eee_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_GE7_EEE_CONFIGr_RESERVEDf_GET(r) ((((r).ge7_eee_config[0]) >> 13) & 0x7ffff)
#define BCM53324_A0_GE7_EEE_CONFIGr_RESERVEDf_SET(r,f) (r).ge7_eee_config[0]=(((r).ge7_eee_config[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access GE7_EEE_CONFIG.
 *
 */
#define BCM53324_A0_READ_GE7_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE7_EEE_CONFIGr,(r._ge7_eee_config))
#define BCM53324_A0_WRITE_GE7_EEE_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE7_EEE_CONFIGr,&(r._ge7_eee_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_EEE_CONFIGr BCM53324_A0_GE7_EEE_CONFIGr
#define GE7_EEE_CONFIGr_SIZE BCM53324_A0_GE7_EEE_CONFIGr_SIZE
typedef BCM53324_A0_GE7_EEE_CONFIGr_t GE7_EEE_CONFIGr_t;
#define GE7_EEE_CONFIGr_CLR BCM53324_A0_GE7_EEE_CONFIGr_CLR
#define GE7_EEE_CONFIGr_SET BCM53324_A0_GE7_EEE_CONFIGr_SET
#define GE7_EEE_CONFIGr_GET BCM53324_A0_GE7_EEE_CONFIGr_GET
#define GE7_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET BCM53324_A0_GE7_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_GET
#define GE7_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET BCM53324_A0_GE7_EEE_CONFIGr_EEE_DURATION_TIMER_PULSEf_SET
#define GE7_EEE_CONFIGr_COUNTER_MODEf_GET BCM53324_A0_GE7_EEE_CONFIGr_COUNTER_MODEf_GET
#define GE7_EEE_CONFIGr_COUNTER_MODEf_SET BCM53324_A0_GE7_EEE_CONFIGr_COUNTER_MODEf_SET
#define GE7_EEE_CONFIGr_COUNTER_ROLLOVERf_GET BCM53324_A0_GE7_EEE_CONFIGr_COUNTER_ROLLOVERf_GET
#define GE7_EEE_CONFIGr_COUNTER_ROLLOVERf_SET BCM53324_A0_GE7_EEE_CONFIGr_COUNTER_ROLLOVERf_SET
#define GE7_EEE_CONFIGr_RESERVEDf_GET BCM53324_A0_GE7_EEE_CONFIGr_RESERVEDf_GET
#define GE7_EEE_CONFIGr_RESERVEDf_SET BCM53324_A0_GE7_EEE_CONFIGr_RESERVEDf_SET
#define READ_GE7_EEE_CONFIGr BCM53324_A0_READ_GE7_EEE_CONFIGr
#define WRITE_GE7_EEE_CONFIGr BCM53324_A0_WRITE_GE7_EEE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE7_EEE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE7_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE7 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE7_GBODE_CELL_CNTr 0x00080017

#define BCM53324_A0_GE7_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE7_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge7_gbode_cell_cnt[1];
	uint32_t _ge7_gbode_cell_cnt;
} BCM53324_A0_GE7_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE7_GBODE_CELL_CNTr_CLR(r) (r).ge7_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE7_GBODE_CELL_CNTr_SET(r,d) (r).ge7_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE7_GBODE_CELL_CNTr_GET(r) (r).ge7_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge7_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge7_gbode_cell_cnt[0]=(((r).ge7_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE7_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE7_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE7_GBODE_CELL_CNTr,(r._ge7_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE7_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE7_GBODE_CELL_CNTr,&(r._ge7_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBODE_CELL_CNTr BCM53324_A0_GE7_GBODE_CELL_CNTr
#define GE7_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE7_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE7_GBODE_CELL_CNTr_t GE7_GBODE_CELL_CNTr_t;
#define GE7_GBODE_CELL_CNTr_CLR BCM53324_A0_GE7_GBODE_CELL_CNTr_CLR
#define GE7_GBODE_CELL_CNTr_SET BCM53324_A0_GE7_GBODE_CELL_CNTr_SET
#define GE7_GBODE_CELL_CNTr_GET BCM53324_A0_GE7_GBODE_CELL_CNTr_GET
#define GE7_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE7_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE7_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE7_GBODE_CELL_CNTr BCM53324_A0_READ_GE7_GBODE_CELL_CNTr
#define WRITE_GE7_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE7_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE7_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE7_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE7 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr 0x00080023

#define BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge7_gbode_cell_req_cnt[1];
	uint32_t _ge7_gbode_cell_req_cnt;
} BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge7_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge7_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_GET(r) (r).ge7_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge7_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge7_gbode_cell_req_cnt[0]=(((r).ge7_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE7_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE7_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr,(r._ge7_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE7_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr,&(r._ge7_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBODE_CELL_REQ_CNTr BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr
#define GE7_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_t GE7_GBODE_CELL_REQ_CNTr_t;
#define GE7_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_CLR
#define GE7_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_SET
#define GE7_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_GET
#define GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE7_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE7_GBODE_CELL_REQ_CNTr
#define WRITE_GE7_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE7_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE7_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE7_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE7 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE7_GBOD_OVRFLWr 0x0008000b

#define BCM53324_A0_GE7_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE7_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE7_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge7_gbod_ovrflw[1];
	uint32_t _ge7_gbod_ovrflw;
} BCM53324_A0_GE7_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE7_GBOD_OVRFLWr_CLR(r) (r).ge7_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE7_GBOD_OVRFLWr_SET(r,d) (r).ge7_gbod_ovrflw[0] = d
#define BCM53324_A0_GE7_GBOD_OVRFLWr_GET(r) (r).ge7_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE7_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge7_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE7_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge7_gbod_ovrflw[0]=(((r).ge7_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE7_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE7_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE7_GBOD_OVRFLWr,(r._ge7_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE7_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE7_GBOD_OVRFLWr,&(r._ge7_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE7_GBOD_OVRFLWr BCM53324_A0_GE7_GBOD_OVRFLWr
#define GE7_GBOD_OVRFLWr_SIZE BCM53324_A0_GE7_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE7_GBOD_OVRFLWr_t GE7_GBOD_OVRFLWr_t;
#define GE7_GBOD_OVRFLWr_CLR BCM53324_A0_GE7_GBOD_OVRFLWr_CLR
#define GE7_GBOD_OVRFLWr_SET BCM53324_A0_GE7_GBOD_OVRFLWr_SET
#define GE7_GBOD_OVRFLWr_GET BCM53324_A0_GE7_GBOD_OVRFLWr_GET
#define GE7_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE7_GBOD_OVRFLWr_OVRFLWf_GET
#define GE7_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE7_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE7_GBOD_OVRFLWr BCM53324_A0_READ_GE7_GBOD_OVRFLWr
#define WRITE_GE7_GBOD_OVRFLWr BCM53324_A0_WRITE_GE7_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE7_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE8_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE8 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE8_GBODE_CELL_CNTr 0x00080018

#define BCM53324_A0_GE8_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE8_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge8_gbode_cell_cnt[1];
	uint32_t _ge8_gbode_cell_cnt;
} BCM53324_A0_GE8_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE8_GBODE_CELL_CNTr_CLR(r) (r).ge8_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE8_GBODE_CELL_CNTr_SET(r,d) (r).ge8_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE8_GBODE_CELL_CNTr_GET(r) (r).ge8_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge8_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge8_gbode_cell_cnt[0]=(((r).ge8_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE8_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE8_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE8_GBODE_CELL_CNTr,(r._ge8_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE8_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE8_GBODE_CELL_CNTr,&(r._ge8_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBODE_CELL_CNTr BCM53324_A0_GE8_GBODE_CELL_CNTr
#define GE8_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE8_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE8_GBODE_CELL_CNTr_t GE8_GBODE_CELL_CNTr_t;
#define GE8_GBODE_CELL_CNTr_CLR BCM53324_A0_GE8_GBODE_CELL_CNTr_CLR
#define GE8_GBODE_CELL_CNTr_SET BCM53324_A0_GE8_GBODE_CELL_CNTr_SET
#define GE8_GBODE_CELL_CNTr_GET BCM53324_A0_GE8_GBODE_CELL_CNTr_GET
#define GE8_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE8_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE8_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE8_GBODE_CELL_CNTr BCM53324_A0_READ_GE8_GBODE_CELL_CNTr
#define WRITE_GE8_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE8_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE8_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE8_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE8 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr 0x00080024

#define BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge8_gbode_cell_req_cnt[1];
	uint32_t _ge8_gbode_cell_req_cnt;
} BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge8_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge8_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_GET(r) (r).ge8_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge8_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge8_gbode_cell_req_cnt[0]=(((r).ge8_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE8_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE8_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr,(r._ge8_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE8_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr,&(r._ge8_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBODE_CELL_REQ_CNTr BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr
#define GE8_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_t GE8_GBODE_CELL_REQ_CNTr_t;
#define GE8_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_CLR
#define GE8_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_SET
#define GE8_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_GET
#define GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE8_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE8_GBODE_CELL_REQ_CNTr
#define WRITE_GE8_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE8_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE8_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE8_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE8 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE8_GBOD_OVRFLWr 0x0008000c

#define BCM53324_A0_GE8_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE8_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE8_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge8_gbod_ovrflw[1];
	uint32_t _ge8_gbod_ovrflw;
} BCM53324_A0_GE8_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE8_GBOD_OVRFLWr_CLR(r) (r).ge8_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE8_GBOD_OVRFLWr_SET(r,d) (r).ge8_gbod_ovrflw[0] = d
#define BCM53324_A0_GE8_GBOD_OVRFLWr_GET(r) (r).ge8_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE8_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge8_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE8_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge8_gbod_ovrflw[0]=(((r).ge8_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE8_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE8_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE8_GBOD_OVRFLWr,(r._ge8_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE8_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE8_GBOD_OVRFLWr,&(r._ge8_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE8_GBOD_OVRFLWr BCM53324_A0_GE8_GBOD_OVRFLWr
#define GE8_GBOD_OVRFLWr_SIZE BCM53324_A0_GE8_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE8_GBOD_OVRFLWr_t GE8_GBOD_OVRFLWr_t;
#define GE8_GBOD_OVRFLWr_CLR BCM53324_A0_GE8_GBOD_OVRFLWr_CLR
#define GE8_GBOD_OVRFLWr_SET BCM53324_A0_GE8_GBOD_OVRFLWr_SET
#define GE8_GBOD_OVRFLWr_GET BCM53324_A0_GE8_GBOD_OVRFLWr_GET
#define GE8_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE8_GBOD_OVRFLWr_OVRFLWf_GET
#define GE8_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE8_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE8_GBOD_OVRFLWr BCM53324_A0_READ_GE8_GBOD_OVRFLWr
#define WRITE_GE8_GBOD_OVRFLWr BCM53324_A0_WRITE_GE8_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE8_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE9_GBODE_CELL_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell count register for GE9 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM53324_A0_GE9_GBODE_CELL_CNTr 0x00080019

#define BCM53324_A0_GE9_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBODE_CELL_CNT.
 *
 */
typedef union BCM53324_A0_GE9_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge9_gbode_cell_cnt[1];
	uint32_t _ge9_gbode_cell_cnt;
} BCM53324_A0_GE9_GBODE_CELL_CNTr_t;

#define BCM53324_A0_GE9_GBODE_CELL_CNTr_CLR(r) (r).ge9_gbode_cell_cnt[0] = 0
#define BCM53324_A0_GE9_GBODE_CELL_CNTr_SET(r,d) (r).ge9_gbode_cell_cnt[0] = d
#define BCM53324_A0_GE9_GBODE_CELL_CNTr_GET(r) (r).ge9_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge9_gbode_cell_cnt[0]) & 0xf)
#define BCM53324_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge9_gbode_cell_cnt[0]=(((r).ge9_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE9_GBODE_CELL_CNT.
 *
 */
#define BCM53324_A0_READ_GE9_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE9_GBODE_CELL_CNTr,(r._ge9_gbode_cell_cnt))
#define BCM53324_A0_WRITE_GE9_GBODE_CELL_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE9_GBODE_CELL_CNTr,&(r._ge9_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBODE_CELL_CNTr BCM53324_A0_GE9_GBODE_CELL_CNTr
#define GE9_GBODE_CELL_CNTr_SIZE BCM53324_A0_GE9_GBODE_CELL_CNTr_SIZE
typedef BCM53324_A0_GE9_GBODE_CELL_CNTr_t GE9_GBODE_CELL_CNTr_t;
#define GE9_GBODE_CELL_CNTr_CLR BCM53324_A0_GE9_GBODE_CELL_CNTr_CLR
#define GE9_GBODE_CELL_CNTr_SET BCM53324_A0_GE9_GBODE_CELL_CNTr_SET
#define GE9_GBODE_CELL_CNTr_GET BCM53324_A0_GE9_GBODE_CELL_CNTr_GET
#define GE9_GBODE_CELL_CNTr_CELL_CNTf_GET BCM53324_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE9_GBODE_CELL_CNTr_CELL_CNTf_SET BCM53324_A0_GE9_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE9_GBODE_CELL_CNTr BCM53324_A0_READ_GE9_GBODE_CELL_CNTr
#define WRITE_GE9_GBODE_CELL_CNTr BCM53324_A0_WRITE_GE9_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE9_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE9_GBODE_CELL_REQ_CNT
 * BLOCKS:   GPORT0
 * DESC:     GBODE cell request count register for GE9 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr 0x00080025

#define BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge9_gbode_cell_req_cnt[1];
	uint32_t _ge9_gbode_cell_req_cnt;
} BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_t;

#define BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge9_gbode_cell_req_cnt[0] = 0
#define BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge9_gbode_cell_req_cnt[0] = d
#define BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_GET(r) (r).ge9_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge9_gbode_cell_req_cnt[0]) & 0xf)
#define BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge9_gbode_cell_req_cnt[0]=(((r).ge9_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE9_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM53324_A0_READ_GE9_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr,(r._ge9_gbode_cell_req_cnt))
#define BCM53324_A0_WRITE_GE9_GBODE_CELL_REQ_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr,&(r._ge9_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBODE_CELL_REQ_CNTr BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr
#define GE9_GBODE_CELL_REQ_CNTr_SIZE BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_t GE9_GBODE_CELL_REQ_CNTr_t;
#define GE9_GBODE_CELL_REQ_CNTr_CLR BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_CLR
#define GE9_GBODE_CELL_REQ_CNTr_SET BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_SET
#define GE9_GBODE_CELL_REQ_CNTr_GET BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_GET
#define GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE9_GBODE_CELL_REQ_CNTr BCM53324_A0_READ_GE9_GBODE_CELL_REQ_CNTr
#define WRITE_GE9_GBODE_CELL_REQ_CNTr BCM53324_A0_WRITE_GE9_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE9_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GE9_GBOD_OVRFLW
 * BLOCKS:   GPORT0
 * DESC:     GBOD RX fifo overflow for GE9 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM53324_A0_GE9_GBOD_OVRFLWr 0x0008000d

#define BCM53324_A0_GE9_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE9_GBOD_OVRFLW.
 *
 */
typedef union BCM53324_A0_GE9_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge9_gbod_ovrflw[1];
	uint32_t _ge9_gbod_ovrflw;
} BCM53324_A0_GE9_GBOD_OVRFLWr_t;

#define BCM53324_A0_GE9_GBOD_OVRFLWr_CLR(r) (r).ge9_gbod_ovrflw[0] = 0
#define BCM53324_A0_GE9_GBOD_OVRFLWr_SET(r,d) (r).ge9_gbod_ovrflw[0] = d
#define BCM53324_A0_GE9_GBOD_OVRFLWr_GET(r) (r).ge9_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GE9_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge9_gbod_ovrflw[0]) & 0x1)
#define BCM53324_A0_GE9_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge9_gbod_ovrflw[0]=(((r).ge9_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE9_GBOD_OVRFLW.
 *
 */
#define BCM53324_A0_READ_GE9_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE9_GBOD_OVRFLWr,(r._ge9_gbod_ovrflw))
#define BCM53324_A0_WRITE_GE9_GBOD_OVRFLWr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GE9_GBOD_OVRFLWr,&(r._ge9_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE9_GBOD_OVRFLWr BCM53324_A0_GE9_GBOD_OVRFLWr
#define GE9_GBOD_OVRFLWr_SIZE BCM53324_A0_GE9_GBOD_OVRFLWr_SIZE
typedef BCM53324_A0_GE9_GBOD_OVRFLWr_t GE9_GBOD_OVRFLWr_t;
#define GE9_GBOD_OVRFLWr_CLR BCM53324_A0_GE9_GBOD_OVRFLWr_CLR
#define GE9_GBOD_OVRFLWr_SET BCM53324_A0_GE9_GBOD_OVRFLWr_SET
#define GE9_GBOD_OVRFLWr_GET BCM53324_A0_GE9_GBOD_OVRFLWr_GET
#define GE9_GBOD_OVRFLWr_OVRFLWf_GET BCM53324_A0_GE9_GBOD_OVRFLWr_OVRFLWf_GET
#define GE9_GBOD_OVRFLWr_OVRFLWf_SET BCM53324_A0_GE9_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE9_GBOD_OVRFLWr BCM53324_A0_READ_GE9_GBOD_OVRFLWr
#define WRITE_GE9_GBOD_OVRFLWr BCM53324_A0_WRITE_GE9_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GE9_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_CNTMAXSIZE
 * BLOCKS:   GPORT0
 * DESC:     GPORT CNTMAXSIZE register
 * SIZE:     32
 * FIELDS:
 *     CNTMAXSIZE       The max packet size that is used in statistic counter update. Default to 2800.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_CNTMAXSIZEr 0x00080003

#define BCM53324_A0_GPORT_CNTMAXSIZEr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CNTMAXSIZE.
 *
 */
typedef union BCM53324_A0_GPORT_CNTMAXSIZEr_s {
	uint32_t v[1];
	uint32_t gport_cntmaxsize[1];
	uint32_t _gport_cntmaxsize;
} BCM53324_A0_GPORT_CNTMAXSIZEr_t;

#define BCM53324_A0_GPORT_CNTMAXSIZEr_CLR(r) (r).gport_cntmaxsize[0] = 0
#define BCM53324_A0_GPORT_CNTMAXSIZEr_SET(r,d) (r).gport_cntmaxsize[0] = d
#define BCM53324_A0_GPORT_CNTMAXSIZEr_GET(r) (r).gport_cntmaxsize[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET(r) (((r).gport_cntmaxsize[0]) & 0x3fff)
#define BCM53324_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET(r,f) (r).gport_cntmaxsize[0]=(((r).gport_cntmaxsize[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access GPORT_CNTMAXSIZE.
 *
 */
#define BCM53324_A0_READ_GPORT_CNTMAXSIZEr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_CNTMAXSIZEr,(r._gport_cntmaxsize))
#define BCM53324_A0_WRITE_GPORT_CNTMAXSIZEr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_CNTMAXSIZEr,&(r._gport_cntmaxsize))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_CNTMAXSIZEr BCM53324_A0_GPORT_CNTMAXSIZEr
#define GPORT_CNTMAXSIZEr_SIZE BCM53324_A0_GPORT_CNTMAXSIZEr_SIZE
typedef BCM53324_A0_GPORT_CNTMAXSIZEr_t GPORT_CNTMAXSIZEr_t;
#define GPORT_CNTMAXSIZEr_CLR BCM53324_A0_GPORT_CNTMAXSIZEr_CLR
#define GPORT_CNTMAXSIZEr_SET BCM53324_A0_GPORT_CNTMAXSIZEr_SET
#define GPORT_CNTMAXSIZEr_GET BCM53324_A0_GPORT_CNTMAXSIZEr_GET
#define GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET BCM53324_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET
#define GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET BCM53324_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET
#define READ_GPORT_CNTMAXSIZEr BCM53324_A0_READ_GPORT_CNTMAXSIZEr
#define WRITE_GPORT_CNTMAXSIZEr BCM53324_A0_WRITE_GPORT_CNTMAXSIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_CNTMAXSIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_CONFIG
 * BLOCKS:   GPORT0
 * DESC:     GPORT configuration Register
 * SIZE:     32
 * FIELDS:
 *     GPORT_EN         Enable GPORT. This field is effective only if the field 10, ENABLE_PORT_STM is 0
 *     CLR_CNT          Clear all 12 GE port statistic Counters.
 *     HGIG2_EN_S0      Enable HGIG2 FOR SPORT0.
 *     HGIG2_EN_S1      Enable HGIG2 FOR SPORT1.
 *     DROP_ON_WRONG_SOP_EN_S0 If set, drops the packet with wrong SOP BYTE for S0.
 *     DROP_ON_WRONG_SOP_EN_S1 If set, drops the packet with wrong SOP BYTE for S1.
 *     HGIG2_EN_S3      Enable HGIG2 FOR SPORT3.
 *     HGIG2_EN_S4      Enable HGIG2 FOR SPORT4.
 *     DROP_ON_WRONG_SOP_EN_S3 If set, drops the packet with wrong SOP BYTE for S3.
 *     DROP_ON_WRONG_SOP_EN_S4 If set, drops the packet with wrong SOP BYTE for S4.
 *     ENABLE_PORT_STM  If set, enables the per port state machine used for unmanaged mode of GPORT. If enabled, GPORT_EN (field 0) does not work. gport should be enabled before the "ENABLE_PORT_STM" is made 1
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_CONFIGr 0x00080000

#define BCM53324_A0_GPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CONFIG.
 *
 */
typedef union BCM53324_A0_GPORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t gport_config[1];
	uint32_t _gport_config;
} BCM53324_A0_GPORT_CONFIGr_t;

#define BCM53324_A0_GPORT_CONFIGr_CLR(r) (r).gport_config[0] = 0
#define BCM53324_A0_GPORT_CONFIGr_SET(r,d) (r).gport_config[0] = d
#define BCM53324_A0_GPORT_CONFIGr_GET(r) (r).gport_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_CONFIGr_GPORT_ENf_GET(r) (((r).gport_config[0]) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_GPORT_ENf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_GPORT_CONFIGr_CLR_CNTf_GET(r) ((((r).gport_config[0]) >> 1) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_CLR_CNTf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S0f_GET(r) ((((r).gport_config[0]) >> 2) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S0f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S1f_GET(r) ((((r).gport_config[0]) >> 3) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S1f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_GET(r) ((((r).gport_config[0]) >> 4) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_GET(r) ((((r).gport_config[0]) >> 5) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S3f_GET(r) ((((r).gport_config[0]) >> 6) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S3f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S4f_GET(r) ((((r).gport_config[0]) >> 7) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S4f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S3f_GET(r) ((((r).gport_config[0]) >> 8) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S3f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S4f_GET(r) ((((r).gport_config[0]) >> 9) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S4f_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_GPORT_CONFIGr_ENABLE_PORT_STMf_GET(r) ((((r).gport_config[0]) >> 10) & 0x1)
#define BCM53324_A0_GPORT_CONFIGr_ENABLE_PORT_STMf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))

/*
 * These macros can be used to access GPORT_CONFIG.
 *
 */
#define BCM53324_A0_READ_GPORT_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_CONFIGr,(r._gport_config))
#define BCM53324_A0_WRITE_GPORT_CONFIGr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_CONFIGr,&(r._gport_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_CONFIGr BCM53324_A0_GPORT_CONFIGr
#define GPORT_CONFIGr_SIZE BCM53324_A0_GPORT_CONFIGr_SIZE
typedef BCM53324_A0_GPORT_CONFIGr_t GPORT_CONFIGr_t;
#define GPORT_CONFIGr_CLR BCM53324_A0_GPORT_CONFIGr_CLR
#define GPORT_CONFIGr_SET BCM53324_A0_GPORT_CONFIGr_SET
#define GPORT_CONFIGr_GET BCM53324_A0_GPORT_CONFIGr_GET
#define GPORT_CONFIGr_GPORT_ENf_GET BCM53324_A0_GPORT_CONFIGr_GPORT_ENf_GET
#define GPORT_CONFIGr_GPORT_ENf_SET BCM53324_A0_GPORT_CONFIGr_GPORT_ENf_SET
#define GPORT_CONFIGr_CLR_CNTf_GET BCM53324_A0_GPORT_CONFIGr_CLR_CNTf_GET
#define GPORT_CONFIGr_CLR_CNTf_SET BCM53324_A0_GPORT_CONFIGr_CLR_CNTf_SET
#define GPORT_CONFIGr_HGIG2_EN_S0f_GET BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S0f_GET
#define GPORT_CONFIGr_HGIG2_EN_S0f_SET BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S0f_SET
#define GPORT_CONFIGr_HGIG2_EN_S1f_GET BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S1f_GET
#define GPORT_CONFIGr_HGIG2_EN_S1f_SET BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S1f_SET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_GET BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_GET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_SET BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S0f_SET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_GET BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_GET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_SET BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S1f_SET
#define GPORT_CONFIGr_HGIG2_EN_S3f_GET BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S3f_GET
#define GPORT_CONFIGr_HGIG2_EN_S3f_SET BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S3f_SET
#define GPORT_CONFIGr_HGIG2_EN_S4f_GET BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S4f_GET
#define GPORT_CONFIGr_HGIG2_EN_S4f_SET BCM53324_A0_GPORT_CONFIGr_HGIG2_EN_S4f_SET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S3f_GET BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S3f_GET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S3f_SET BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S3f_SET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S4f_GET BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S4f_GET
#define GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S4f_SET BCM53324_A0_GPORT_CONFIGr_DROP_ON_WRONG_SOP_EN_S4f_SET
#define GPORT_CONFIGr_ENABLE_PORT_STMf_GET BCM53324_A0_GPORT_CONFIGr_ENABLE_PORT_STMf_GET
#define GPORT_CONFIGr_ENABLE_PORT_STMf_SET BCM53324_A0_GPORT_CONFIGr_ENABLE_PORT_STMf_SET
#define READ_GPORT_CONFIGr BCM53324_A0_READ_GPORT_CONFIGr
#define WRITE_GPORT_CONFIGr BCM53324_A0_WRITE_GPORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_DROP_ON_WRONG_SOP_S0_CNT
 * BLOCKS:   GPORT0
 * DESC:     Drop Counter against wrong K.SOP for FPORT-S0
 * SIZE:     32
 * FIELDS:
 *     S0_CNT           Counts the dropped packets because of wrong SOP Byte in FPORT-S0.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr 0x0008002c

#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_DROP_ON_WRONG_SOP_S0_CNT.
 *
 */
typedef union BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_s {
	uint32_t v[1];
	uint32_t gport_drop_on_wrong_sop_s0_cnt[1];
	uint32_t _gport_drop_on_wrong_sop_s0_cnt;
} BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_t;

#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_CLR(r) (r).gport_drop_on_wrong_sop_s0_cnt[0] = 0
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SET(r,d) (r).gport_drop_on_wrong_sop_s0_cnt[0] = d
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_GET(r) (r).gport_drop_on_wrong_sop_s0_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_GET(r) (((r).gport_drop_on_wrong_sop_s0_cnt[0]) & 0xffffff)
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_SET(r,f) (r).gport_drop_on_wrong_sop_s0_cnt[0]=(((r).gport_drop_on_wrong_sop_s0_cnt[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access GPORT_DROP_ON_WRONG_SOP_S0_CNT.
 *
 */
#define BCM53324_A0_READ_GPORT_DROP_ON_WRONG_SOP_S0_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr,(r._gport_drop_on_wrong_sop_s0_cnt))
#define BCM53324_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S0_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr,&(r._gport_drop_on_wrong_sop_s0_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SIZE BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SIZE
typedef BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_t GPORT_DROP_ON_WRONG_SOP_S0_CNTr_t;
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_CLR BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_CLR
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_SET
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_GET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_GET
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_GET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_GET
#define GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_SET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr_S0_CNTf_SET
#define READ_GPORT_DROP_ON_WRONG_SOP_S0_CNTr BCM53324_A0_READ_GPORT_DROP_ON_WRONG_SOP_S0_CNTr
#define WRITE_GPORT_DROP_ON_WRONG_SOP_S0_CNTr BCM53324_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S0_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S0_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_DROP_ON_WRONG_SOP_S1_CNT
 * BLOCKS:   GPORT0
 * DESC:     Drop Counter against wrong K.SOP for FPORT-S1
 * SIZE:     32
 * FIELDS:
 *     S1_CNT           Counts the dropped packets because of wrong SOP Byte in FPORT-S1.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr 0x0008002b

#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_DROP_ON_WRONG_SOP_S1_CNT.
 *
 */
typedef union BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_s {
	uint32_t v[1];
	uint32_t gport_drop_on_wrong_sop_s1_cnt[1];
	uint32_t _gport_drop_on_wrong_sop_s1_cnt;
} BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_t;

#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_CLR(r) (r).gport_drop_on_wrong_sop_s1_cnt[0] = 0
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SET(r,d) (r).gport_drop_on_wrong_sop_s1_cnt[0] = d
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_GET(r) (r).gport_drop_on_wrong_sop_s1_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_GET(r) (((r).gport_drop_on_wrong_sop_s1_cnt[0]) & 0xffffff)
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_SET(r,f) (r).gport_drop_on_wrong_sop_s1_cnt[0]=(((r).gport_drop_on_wrong_sop_s1_cnt[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access GPORT_DROP_ON_WRONG_SOP_S1_CNT.
 *
 */
#define BCM53324_A0_READ_GPORT_DROP_ON_WRONG_SOP_S1_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr,(r._gport_drop_on_wrong_sop_s1_cnt))
#define BCM53324_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S1_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr,&(r._gport_drop_on_wrong_sop_s1_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SIZE BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SIZE
typedef BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_t GPORT_DROP_ON_WRONG_SOP_S1_CNTr_t;
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_CLR BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_CLR
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_SET
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_GET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_GET
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_GET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_GET
#define GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_SET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr_S1_CNTf_SET
#define READ_GPORT_DROP_ON_WRONG_SOP_S1_CNTr BCM53324_A0_READ_GPORT_DROP_ON_WRONG_SOP_S1_CNTr
#define WRITE_GPORT_DROP_ON_WRONG_SOP_S1_CNTr BCM53324_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S1_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S1_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_DROP_ON_WRONG_SOP_S3_CNT
 * BLOCKS:   GPORT0
 * DESC:     Drop Counter against wrong K.SOP for FPORT-S3
 * SIZE:     32
 * FIELDS:
 *     S3_CNT           Counts the dropped packets because of wrong SOP Byte in FPORT-S3.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr 0x00080030

#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_DROP_ON_WRONG_SOP_S3_CNT.
 *
 */
typedef union BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_s {
	uint32_t v[1];
	uint32_t gport_drop_on_wrong_sop_s3_cnt[1];
	uint32_t _gport_drop_on_wrong_sop_s3_cnt;
} BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_t;

#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_CLR(r) (r).gport_drop_on_wrong_sop_s3_cnt[0] = 0
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_SET(r,d) (r).gport_drop_on_wrong_sop_s3_cnt[0] = d
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_GET(r) (r).gport_drop_on_wrong_sop_s3_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_S3_CNTf_GET(r) (((r).gport_drop_on_wrong_sop_s3_cnt[0]) & 0xffffff)
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_S3_CNTf_SET(r,f) (r).gport_drop_on_wrong_sop_s3_cnt[0]=(((r).gport_drop_on_wrong_sop_s3_cnt[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access GPORT_DROP_ON_WRONG_SOP_S3_CNT.
 *
 */
#define BCM53324_A0_READ_GPORT_DROP_ON_WRONG_SOP_S3_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr,(r._gport_drop_on_wrong_sop_s3_cnt))
#define BCM53324_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S3_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr,&(r._gport_drop_on_wrong_sop_s3_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_DROP_ON_WRONG_SOP_S3_CNTr BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr
#define GPORT_DROP_ON_WRONG_SOP_S3_CNTr_SIZE BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_SIZE
typedef BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_t GPORT_DROP_ON_WRONG_SOP_S3_CNTr_t;
#define GPORT_DROP_ON_WRONG_SOP_S3_CNTr_CLR BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_CLR
#define GPORT_DROP_ON_WRONG_SOP_S3_CNTr_SET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_SET
#define GPORT_DROP_ON_WRONG_SOP_S3_CNTr_GET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_GET
#define GPORT_DROP_ON_WRONG_SOP_S3_CNTr_S3_CNTf_GET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_S3_CNTf_GET
#define GPORT_DROP_ON_WRONG_SOP_S3_CNTr_S3_CNTf_SET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr_S3_CNTf_SET
#define READ_GPORT_DROP_ON_WRONG_SOP_S3_CNTr BCM53324_A0_READ_GPORT_DROP_ON_WRONG_SOP_S3_CNTr
#define WRITE_GPORT_DROP_ON_WRONG_SOP_S3_CNTr BCM53324_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S3_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S3_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_DROP_ON_WRONG_SOP_S4_CNT
 * BLOCKS:   GPORT0
 * DESC:     Drop Counter against wrong K.SOP for FPORT-S4
 * SIZE:     32
 * FIELDS:
 *     S4_CNT           Counts the dropped packets because of wrong SOP Byte in FPORT-S4.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr 0x0008002f

#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_DROP_ON_WRONG_SOP_S4_CNT.
 *
 */
typedef union BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_s {
	uint32_t v[1];
	uint32_t gport_drop_on_wrong_sop_s4_cnt[1];
	uint32_t _gport_drop_on_wrong_sop_s4_cnt;
} BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_t;

#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_CLR(r) (r).gport_drop_on_wrong_sop_s4_cnt[0] = 0
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_SET(r,d) (r).gport_drop_on_wrong_sop_s4_cnt[0] = d
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_GET(r) (r).gport_drop_on_wrong_sop_s4_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_S4_CNTf_GET(r) (((r).gport_drop_on_wrong_sop_s4_cnt[0]) & 0xffffff)
#define BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_S4_CNTf_SET(r,f) (r).gport_drop_on_wrong_sop_s4_cnt[0]=(((r).gport_drop_on_wrong_sop_s4_cnt[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access GPORT_DROP_ON_WRONG_SOP_S4_CNT.
 *
 */
#define BCM53324_A0_READ_GPORT_DROP_ON_WRONG_SOP_S4_CNTr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr,(r._gport_drop_on_wrong_sop_s4_cnt))
#define BCM53324_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S4_CNTr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr,&(r._gport_drop_on_wrong_sop_s4_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_DROP_ON_WRONG_SOP_S4_CNTr BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr
#define GPORT_DROP_ON_WRONG_SOP_S4_CNTr_SIZE BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_SIZE
typedef BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_t GPORT_DROP_ON_WRONG_SOP_S4_CNTr_t;
#define GPORT_DROP_ON_WRONG_SOP_S4_CNTr_CLR BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_CLR
#define GPORT_DROP_ON_WRONG_SOP_S4_CNTr_SET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_SET
#define GPORT_DROP_ON_WRONG_SOP_S4_CNTr_GET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_GET
#define GPORT_DROP_ON_WRONG_SOP_S4_CNTr_S4_CNTf_GET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_S4_CNTf_GET
#define GPORT_DROP_ON_WRONG_SOP_S4_CNTr_S4_CNTf_SET BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr_S4_CNTf_SET
#define READ_GPORT_DROP_ON_WRONG_SOP_S4_CNTr BCM53324_A0_READ_GPORT_DROP_ON_WRONG_SOP_S4_CNTr
#define WRITE_GPORT_DROP_ON_WRONG_SOP_S4_CNTr BCM53324_A0_WRITE_GPORT_DROP_ON_WRONG_SOP_S4_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_DROP_ON_WRONG_SOP_S4_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_MAC_CRS_SEL
 * BLOCKS:   GPORT0
 * DESC:     Register for MAC_CRS_SEL signals.
 * SIZE:     32
 * FIELDS:
 *     MAC_CRS_SEL      Each of the 8-bits selects the crs for the corresponding mac, between phy_crs and serdes_crs.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_MAC_CRS_SELr 0x00080031

#define BCM53324_A0_GPORT_MAC_CRS_SELr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_MAC_CRS_SEL.
 *
 */
typedef union BCM53324_A0_GPORT_MAC_CRS_SELr_s {
	uint32_t v[1];
	uint32_t gport_mac_crs_sel[1];
	uint32_t _gport_mac_crs_sel;
} BCM53324_A0_GPORT_MAC_CRS_SELr_t;

#define BCM53324_A0_GPORT_MAC_CRS_SELr_CLR(r) (r).gport_mac_crs_sel[0] = 0
#define BCM53324_A0_GPORT_MAC_CRS_SELr_SET(r,d) (r).gport_mac_crs_sel[0] = d
#define BCM53324_A0_GPORT_MAC_CRS_SELr_GET(r) (r).gport_mac_crs_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_MAC_CRS_SELr_MAC_CRS_SELf_GET(r) (((r).gport_mac_crs_sel[0]) & 0xff)
#define BCM53324_A0_GPORT_MAC_CRS_SELr_MAC_CRS_SELf_SET(r,f) (r).gport_mac_crs_sel[0]=(((r).gport_mac_crs_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GPORT_MAC_CRS_SEL.
 *
 */
#define BCM53324_A0_READ_GPORT_MAC_CRS_SELr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_MAC_CRS_SELr,(r._gport_mac_crs_sel))
#define BCM53324_A0_WRITE_GPORT_MAC_CRS_SELr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_MAC_CRS_SELr,&(r._gport_mac_crs_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_MAC_CRS_SELr BCM53324_A0_GPORT_MAC_CRS_SELr
#define GPORT_MAC_CRS_SELr_SIZE BCM53324_A0_GPORT_MAC_CRS_SELr_SIZE
typedef BCM53324_A0_GPORT_MAC_CRS_SELr_t GPORT_MAC_CRS_SELr_t;
#define GPORT_MAC_CRS_SELr_CLR BCM53324_A0_GPORT_MAC_CRS_SELr_CLR
#define GPORT_MAC_CRS_SELr_SET BCM53324_A0_GPORT_MAC_CRS_SELr_SET
#define GPORT_MAC_CRS_SELr_GET BCM53324_A0_GPORT_MAC_CRS_SELr_GET
#define GPORT_MAC_CRS_SELr_MAC_CRS_SELf_GET BCM53324_A0_GPORT_MAC_CRS_SELr_MAC_CRS_SELf_GET
#define GPORT_MAC_CRS_SELr_MAC_CRS_SELf_SET BCM53324_A0_GPORT_MAC_CRS_SELr_MAC_CRS_SELf_SET
#define READ_GPORT_MAC_CRS_SELr BCM53324_A0_READ_GPORT_MAC_CRS_SELr
#define WRITE_GPORT_MAC_CRS_SELr BCM53324_A0_WRITE_GPORT_MAC_CRS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_MAC_CRS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_RSV_MASK
 * BLOCKS:   GPORT0
 * DESC:     GPORT RSV MASK register, used to purge packet data received from the MACs
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV bits cause packets to be purged
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_RSV_MASKr 0x00080001

#define BCM53324_A0_GPORT_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_RSV_MASK.
 *
 */
typedef union BCM53324_A0_GPORT_RSV_MASKr_s {
	uint32_t v[1];
	uint32_t gport_rsv_mask[1];
	uint32_t _gport_rsv_mask;
} BCM53324_A0_GPORT_RSV_MASKr_t;

#define BCM53324_A0_GPORT_RSV_MASKr_CLR(r) (r).gport_rsv_mask[0] = 0
#define BCM53324_A0_GPORT_RSV_MASKr_SET(r,d) (r).gport_rsv_mask[0] = d
#define BCM53324_A0_GPORT_RSV_MASKr_GET(r) (r).gport_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_RSV_MASKr_MASKf_GET(r) (((r).gport_rsv_mask[0]) & 0x3ffff)
#define BCM53324_A0_GPORT_RSV_MASKr_MASKf_SET(r,f) (r).gport_rsv_mask[0]=(((r).gport_rsv_mask[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access GPORT_RSV_MASK.
 *
 */
#define BCM53324_A0_READ_GPORT_RSV_MASKr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_RSV_MASKr,(r._gport_rsv_mask))
#define BCM53324_A0_WRITE_GPORT_RSV_MASKr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_RSV_MASKr,&(r._gport_rsv_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_RSV_MASKr BCM53324_A0_GPORT_RSV_MASKr
#define GPORT_RSV_MASKr_SIZE BCM53324_A0_GPORT_RSV_MASKr_SIZE
typedef BCM53324_A0_GPORT_RSV_MASKr_t GPORT_RSV_MASKr_t;
#define GPORT_RSV_MASKr_CLR BCM53324_A0_GPORT_RSV_MASKr_CLR
#define GPORT_RSV_MASKr_SET BCM53324_A0_GPORT_RSV_MASKr_SET
#define GPORT_RSV_MASKr_GET BCM53324_A0_GPORT_RSV_MASKr_GET
#define GPORT_RSV_MASKr_MASKf_GET BCM53324_A0_GPORT_RSV_MASKr_MASKf_GET
#define GPORT_RSV_MASKr_MASKf_SET BCM53324_A0_GPORT_RSV_MASKr_MASKf_SET
#define READ_GPORT_RSV_MASKr BCM53324_A0_READ_GPORT_RSV_MASKr
#define WRITE_GPORT_RSV_MASKr BCM53324_A0_WRITE_GPORT_RSV_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_RSV_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_SGN_DET_SEL
 * BLOCKS:   GPORT0
 * DESC:     Register for SGN_DET_SEL signals.
 * SIZE:     32
 * FIELDS:
 *     SGN_DET_SEL      Each of the 8-bits selects the sgn_det for the corresponding mac, for 1000-x mode.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_SGN_DET_SELr 0x00080032

#define BCM53324_A0_GPORT_SGN_DET_SELr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_SGN_DET_SEL.
 *
 */
typedef union BCM53324_A0_GPORT_SGN_DET_SELr_s {
	uint32_t v[1];
	uint32_t gport_sgn_det_sel[1];
	uint32_t _gport_sgn_det_sel;
} BCM53324_A0_GPORT_SGN_DET_SELr_t;

#define BCM53324_A0_GPORT_SGN_DET_SELr_CLR(r) (r).gport_sgn_det_sel[0] = 0
#define BCM53324_A0_GPORT_SGN_DET_SELr_SET(r,d) (r).gport_sgn_det_sel[0] = d
#define BCM53324_A0_GPORT_SGN_DET_SELr_GET(r) (r).gport_sgn_det_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_SGN_DET_SELr_SGN_DET_SELf_GET(r) (((r).gport_sgn_det_sel[0]) & 0xff)
#define BCM53324_A0_GPORT_SGN_DET_SELr_SGN_DET_SELf_SET(r,f) (r).gport_sgn_det_sel[0]=(((r).gport_sgn_det_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GPORT_SGN_DET_SEL.
 *
 */
#define BCM53324_A0_READ_GPORT_SGN_DET_SELr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SGN_DET_SELr,(r._gport_sgn_det_sel))
#define BCM53324_A0_WRITE_GPORT_SGN_DET_SELr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SGN_DET_SELr,&(r._gport_sgn_det_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_SGN_DET_SELr BCM53324_A0_GPORT_SGN_DET_SELr
#define GPORT_SGN_DET_SELr_SIZE BCM53324_A0_GPORT_SGN_DET_SELr_SIZE
typedef BCM53324_A0_GPORT_SGN_DET_SELr_t GPORT_SGN_DET_SELr_t;
#define GPORT_SGN_DET_SELr_CLR BCM53324_A0_GPORT_SGN_DET_SELr_CLR
#define GPORT_SGN_DET_SELr_SET BCM53324_A0_GPORT_SGN_DET_SELr_SET
#define GPORT_SGN_DET_SELr_GET BCM53324_A0_GPORT_SGN_DET_SELr_GET
#define GPORT_SGN_DET_SELr_SGN_DET_SELf_GET BCM53324_A0_GPORT_SGN_DET_SELr_SGN_DET_SELf_GET
#define GPORT_SGN_DET_SELr_SGN_DET_SELf_SET BCM53324_A0_GPORT_SGN_DET_SELr_SGN_DET_SELf_SET
#define READ_GPORT_SGN_DET_SELr BCM53324_A0_READ_GPORT_SGN_DET_SELr
#define WRITE_GPORT_SGN_DET_SELr BCM53324_A0_WRITE_GPORT_SGN_DET_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_SGN_DET_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_SOP_S0
 * BLOCKS:   GPORT0
 * DESC:     GPORT K.SOP used in stacking port FPORT-S0
 * SIZE:     32
 * FIELDS:
 *     K_SOP_S0         Used in FPORT-S0 for dropping packets against wrong SOP.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_SOP_S0r 0x0008002a

#define BCM53324_A0_GPORT_SOP_S0r_SIZE 4

/*
 * This structure should be used to declare and program GPORT_SOP_S0.
 *
 */
typedef union BCM53324_A0_GPORT_SOP_S0r_s {
	uint32_t v[1];
	uint32_t gport_sop_s0[1];
	uint32_t _gport_sop_s0;
} BCM53324_A0_GPORT_SOP_S0r_t;

#define BCM53324_A0_GPORT_SOP_S0r_CLR(r) (r).gport_sop_s0[0] = 0
#define BCM53324_A0_GPORT_SOP_S0r_SET(r,d) (r).gport_sop_s0[0] = d
#define BCM53324_A0_GPORT_SOP_S0r_GET(r) (r).gport_sop_s0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_SOP_S0r_K_SOP_S0f_GET(r) (((r).gport_sop_s0[0]) & 0xff)
#define BCM53324_A0_GPORT_SOP_S0r_K_SOP_S0f_SET(r,f) (r).gport_sop_s0[0]=(((r).gport_sop_s0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GPORT_SOP_S0.
 *
 */
#define BCM53324_A0_READ_GPORT_SOP_S0r(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SOP_S0r,(r._gport_sop_s0))
#define BCM53324_A0_WRITE_GPORT_SOP_S0r(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SOP_S0r,&(r._gport_sop_s0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_SOP_S0r BCM53324_A0_GPORT_SOP_S0r
#define GPORT_SOP_S0r_SIZE BCM53324_A0_GPORT_SOP_S0r_SIZE
typedef BCM53324_A0_GPORT_SOP_S0r_t GPORT_SOP_S0r_t;
#define GPORT_SOP_S0r_CLR BCM53324_A0_GPORT_SOP_S0r_CLR
#define GPORT_SOP_S0r_SET BCM53324_A0_GPORT_SOP_S0r_SET
#define GPORT_SOP_S0r_GET BCM53324_A0_GPORT_SOP_S0r_GET
#define GPORT_SOP_S0r_K_SOP_S0f_GET BCM53324_A0_GPORT_SOP_S0r_K_SOP_S0f_GET
#define GPORT_SOP_S0r_K_SOP_S0f_SET BCM53324_A0_GPORT_SOP_S0r_K_SOP_S0f_SET
#define READ_GPORT_SOP_S0r BCM53324_A0_READ_GPORT_SOP_S0r
#define WRITE_GPORT_SOP_S0r BCM53324_A0_WRITE_GPORT_SOP_S0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_SOP_S0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_SOP_S1
 * BLOCKS:   GPORT0
 * DESC:     GPORT K.SOP used in stacking port FPORT-S1
 * SIZE:     32
 * FIELDS:
 *     K_SOP_S1         Used in FPORT-S1 for dropping packets against wrong SOP.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_SOP_S1r 0x00080029

#define BCM53324_A0_GPORT_SOP_S1r_SIZE 4

/*
 * This structure should be used to declare and program GPORT_SOP_S1.
 *
 */
typedef union BCM53324_A0_GPORT_SOP_S1r_s {
	uint32_t v[1];
	uint32_t gport_sop_s1[1];
	uint32_t _gport_sop_s1;
} BCM53324_A0_GPORT_SOP_S1r_t;

#define BCM53324_A0_GPORT_SOP_S1r_CLR(r) (r).gport_sop_s1[0] = 0
#define BCM53324_A0_GPORT_SOP_S1r_SET(r,d) (r).gport_sop_s1[0] = d
#define BCM53324_A0_GPORT_SOP_S1r_GET(r) (r).gport_sop_s1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_SOP_S1r_K_SOP_S1f_GET(r) (((r).gport_sop_s1[0]) & 0xff)
#define BCM53324_A0_GPORT_SOP_S1r_K_SOP_S1f_SET(r,f) (r).gport_sop_s1[0]=(((r).gport_sop_s1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GPORT_SOP_S1.
 *
 */
#define BCM53324_A0_READ_GPORT_SOP_S1r(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SOP_S1r,(r._gport_sop_s1))
#define BCM53324_A0_WRITE_GPORT_SOP_S1r(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SOP_S1r,&(r._gport_sop_s1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_SOP_S1r BCM53324_A0_GPORT_SOP_S1r
#define GPORT_SOP_S1r_SIZE BCM53324_A0_GPORT_SOP_S1r_SIZE
typedef BCM53324_A0_GPORT_SOP_S1r_t GPORT_SOP_S1r_t;
#define GPORT_SOP_S1r_CLR BCM53324_A0_GPORT_SOP_S1r_CLR
#define GPORT_SOP_S1r_SET BCM53324_A0_GPORT_SOP_S1r_SET
#define GPORT_SOP_S1r_GET BCM53324_A0_GPORT_SOP_S1r_GET
#define GPORT_SOP_S1r_K_SOP_S1f_GET BCM53324_A0_GPORT_SOP_S1r_K_SOP_S1f_GET
#define GPORT_SOP_S1r_K_SOP_S1f_SET BCM53324_A0_GPORT_SOP_S1r_K_SOP_S1f_SET
#define READ_GPORT_SOP_S1r BCM53324_A0_READ_GPORT_SOP_S1r
#define WRITE_GPORT_SOP_S1r BCM53324_A0_WRITE_GPORT_SOP_S1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_SOP_S1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_SOP_S3
 * BLOCKS:   GPORT0
 * DESC:     GPORT K.SOP used in stacking port FPORT-S3
 * SIZE:     32
 * FIELDS:
 *     K_SOP_S3         Used in FPORT-S3 for dropping packets against wrong SOP.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_SOP_S3r 0x0008002e

#define BCM53324_A0_GPORT_SOP_S3r_SIZE 4

/*
 * This structure should be used to declare and program GPORT_SOP_S3.
 *
 */
typedef union BCM53324_A0_GPORT_SOP_S3r_s {
	uint32_t v[1];
	uint32_t gport_sop_s3[1];
	uint32_t _gport_sop_s3;
} BCM53324_A0_GPORT_SOP_S3r_t;

#define BCM53324_A0_GPORT_SOP_S3r_CLR(r) (r).gport_sop_s3[0] = 0
#define BCM53324_A0_GPORT_SOP_S3r_SET(r,d) (r).gport_sop_s3[0] = d
#define BCM53324_A0_GPORT_SOP_S3r_GET(r) (r).gport_sop_s3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_SOP_S3r_K_SOP_S3f_GET(r) (((r).gport_sop_s3[0]) & 0xff)
#define BCM53324_A0_GPORT_SOP_S3r_K_SOP_S3f_SET(r,f) (r).gport_sop_s3[0]=(((r).gport_sop_s3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GPORT_SOP_S3.
 *
 */
#define BCM53324_A0_READ_GPORT_SOP_S3r(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SOP_S3r,(r._gport_sop_s3))
#define BCM53324_A0_WRITE_GPORT_SOP_S3r(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SOP_S3r,&(r._gport_sop_s3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_SOP_S3r BCM53324_A0_GPORT_SOP_S3r
#define GPORT_SOP_S3r_SIZE BCM53324_A0_GPORT_SOP_S3r_SIZE
typedef BCM53324_A0_GPORT_SOP_S3r_t GPORT_SOP_S3r_t;
#define GPORT_SOP_S3r_CLR BCM53324_A0_GPORT_SOP_S3r_CLR
#define GPORT_SOP_S3r_SET BCM53324_A0_GPORT_SOP_S3r_SET
#define GPORT_SOP_S3r_GET BCM53324_A0_GPORT_SOP_S3r_GET
#define GPORT_SOP_S3r_K_SOP_S3f_GET BCM53324_A0_GPORT_SOP_S3r_K_SOP_S3f_GET
#define GPORT_SOP_S3r_K_SOP_S3f_SET BCM53324_A0_GPORT_SOP_S3r_K_SOP_S3f_SET
#define READ_GPORT_SOP_S3r BCM53324_A0_READ_GPORT_SOP_S3r
#define WRITE_GPORT_SOP_S3r BCM53324_A0_WRITE_GPORT_SOP_S3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_SOP_S3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_SOP_S4
 * BLOCKS:   GPORT0
 * DESC:     GPORT K.SOP used in stacking port FPORT-S4
 * SIZE:     32
 * FIELDS:
 *     K_SOP_S4         Used in FPORT-S4 for dropping packets against wrong SOP.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_SOP_S4r 0x0008002d

#define BCM53324_A0_GPORT_SOP_S4r_SIZE 4

/*
 * This structure should be used to declare and program GPORT_SOP_S4.
 *
 */
typedef union BCM53324_A0_GPORT_SOP_S4r_s {
	uint32_t v[1];
	uint32_t gport_sop_s4[1];
	uint32_t _gport_sop_s4;
} BCM53324_A0_GPORT_SOP_S4r_t;

#define BCM53324_A0_GPORT_SOP_S4r_CLR(r) (r).gport_sop_s4[0] = 0
#define BCM53324_A0_GPORT_SOP_S4r_SET(r,d) (r).gport_sop_s4[0] = d
#define BCM53324_A0_GPORT_SOP_S4r_GET(r) (r).gport_sop_s4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_SOP_S4r_K_SOP_S4f_GET(r) (((r).gport_sop_s4[0]) & 0xff)
#define BCM53324_A0_GPORT_SOP_S4r_K_SOP_S4f_SET(r,f) (r).gport_sop_s4[0]=(((r).gport_sop_s4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access GPORT_SOP_S4.
 *
 */
#define BCM53324_A0_READ_GPORT_SOP_S4r(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SOP_S4r,(r._gport_sop_s4))
#define BCM53324_A0_WRITE_GPORT_SOP_S4r(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_SOP_S4r,&(r._gport_sop_s4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_SOP_S4r BCM53324_A0_GPORT_SOP_S4r
#define GPORT_SOP_S4r_SIZE BCM53324_A0_GPORT_SOP_S4r_SIZE
typedef BCM53324_A0_GPORT_SOP_S4r_t GPORT_SOP_S4r_t;
#define GPORT_SOP_S4r_CLR BCM53324_A0_GPORT_SOP_S4r_CLR
#define GPORT_SOP_S4r_SET BCM53324_A0_GPORT_SOP_S4r_SET
#define GPORT_SOP_S4r_GET BCM53324_A0_GPORT_SOP_S4r_GET
#define GPORT_SOP_S4r_K_SOP_S4f_GET BCM53324_A0_GPORT_SOP_S4r_K_SOP_S4f_GET
#define GPORT_SOP_S4r_K_SOP_S4f_SET BCM53324_A0_GPORT_SOP_S4r_K_SOP_S4f_SET
#define READ_GPORT_SOP_S4r BCM53324_A0_READ_GPORT_SOP_S4r
#define WRITE_GPORT_SOP_S4r BCM53324_A0_WRITE_GPORT_SOP_S4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_SOP_S4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_STAT_UPDATE_MASK
 * BLOCKS:   GPORT0
 * DESC:     GPORT STAT_UPDATE MASK register, used to control the statistic counter update in the Ingress
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV event should have the statistic counter updated in the Ingress.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_STAT_UPDATE_MASKr 0x00080002

#define BCM53324_A0_GPORT_STAT_UPDATE_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_STAT_UPDATE_MASK.
 *
 */
typedef union BCM53324_A0_GPORT_STAT_UPDATE_MASKr_s {
	uint32_t v[1];
	uint32_t gport_stat_update_mask[1];
	uint32_t _gport_stat_update_mask;
} BCM53324_A0_GPORT_STAT_UPDATE_MASKr_t;

#define BCM53324_A0_GPORT_STAT_UPDATE_MASKr_CLR(r) (r).gport_stat_update_mask[0] = 0
#define BCM53324_A0_GPORT_STAT_UPDATE_MASKr_SET(r,d) (r).gport_stat_update_mask[0] = d
#define BCM53324_A0_GPORT_STAT_UPDATE_MASKr_GET(r) (r).gport_stat_update_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_STAT_UPDATE_MASKr_MASKf_GET(r) (((r).gport_stat_update_mask[0]) & 0x3ffff)
#define BCM53324_A0_GPORT_STAT_UPDATE_MASKr_MASKf_SET(r,f) (r).gport_stat_update_mask[0]=(((r).gport_stat_update_mask[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access GPORT_STAT_UPDATE_MASK.
 *
 */
#define BCM53324_A0_READ_GPORT_STAT_UPDATE_MASKr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_STAT_UPDATE_MASKr,(r._gport_stat_update_mask))
#define BCM53324_A0_WRITE_GPORT_STAT_UPDATE_MASKr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_STAT_UPDATE_MASKr,&(r._gport_stat_update_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_STAT_UPDATE_MASKr BCM53324_A0_GPORT_STAT_UPDATE_MASKr
#define GPORT_STAT_UPDATE_MASKr_SIZE BCM53324_A0_GPORT_STAT_UPDATE_MASKr_SIZE
typedef BCM53324_A0_GPORT_STAT_UPDATE_MASKr_t GPORT_STAT_UPDATE_MASKr_t;
#define GPORT_STAT_UPDATE_MASKr_CLR BCM53324_A0_GPORT_STAT_UPDATE_MASKr_CLR
#define GPORT_STAT_UPDATE_MASKr_SET BCM53324_A0_GPORT_STAT_UPDATE_MASKr_SET
#define GPORT_STAT_UPDATE_MASKr_GET BCM53324_A0_GPORT_STAT_UPDATE_MASKr_GET
#define GPORT_STAT_UPDATE_MASKr_MASKf_GET BCM53324_A0_GPORT_STAT_UPDATE_MASKr_MASKf_GET
#define GPORT_STAT_UPDATE_MASKr_MASKf_SET BCM53324_A0_GPORT_STAT_UPDATE_MASKr_MASKf_SET
#define READ_GPORT_STAT_UPDATE_MASKr BCM53324_A0_READ_GPORT_STAT_UPDATE_MASKr
#define WRITE_GPORT_STAT_UPDATE_MASKr BCM53324_A0_WRITE_GPORT_STAT_UPDATE_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_STAT_UPDATE_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GPORT_TPID
 * BLOCKS:   GPORT0
 * DESC:     GPORT VLAN Tag Protocol ID
 * SIZE:     32
 * FIELDS:
 *     TPID             Used in TriMAC to detect VLAN tagged packets.
 *
 ******************************************************************************/
#define BCM53324_A0_GPORT_TPIDr 0x00080028

#define BCM53324_A0_GPORT_TPIDr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_TPID.
 *
 */
typedef union BCM53324_A0_GPORT_TPIDr_s {
	uint32_t v[1];
	uint32_t gport_tpid[1];
	uint32_t _gport_tpid;
} BCM53324_A0_GPORT_TPIDr_t;

#define BCM53324_A0_GPORT_TPIDr_CLR(r) (r).gport_tpid[0] = 0
#define BCM53324_A0_GPORT_TPIDr_SET(r,d) (r).gport_tpid[0] = d
#define BCM53324_A0_GPORT_TPIDr_GET(r) (r).gport_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_GPORT_TPIDr_TPIDf_GET(r) (((r).gport_tpid[0]) & 0xffff)
#define BCM53324_A0_GPORT_TPIDr_TPIDf_SET(r,f) (r).gport_tpid[0]=(((r).gport_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access GPORT_TPID.
 *
 */
#define BCM53324_A0_READ_GPORT_TPIDr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_TPIDr,(r._gport_tpid))
#define BCM53324_A0_WRITE_GPORT_TPIDr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_GPORT_TPIDr,&(r._gport_tpid))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_TPIDr BCM53324_A0_GPORT_TPIDr
#define GPORT_TPIDr_SIZE BCM53324_A0_GPORT_TPIDr_SIZE
typedef BCM53324_A0_GPORT_TPIDr_t GPORT_TPIDr_t;
#define GPORT_TPIDr_CLR BCM53324_A0_GPORT_TPIDr_CLR
#define GPORT_TPIDr_SET BCM53324_A0_GPORT_TPIDr_SET
#define GPORT_TPIDr_GET BCM53324_A0_GPORT_TPIDr_GET
#define GPORT_TPIDr_TPIDf_GET BCM53324_A0_GPORT_TPIDr_TPIDf_GET
#define GPORT_TPIDr_TPIDf_SET BCM53324_A0_GPORT_TPIDr_TPIDf_SET
#define READ_GPORT_TPIDr BCM53324_A0_READ_GPORT_TPIDr
#define WRITE_GPORT_TPIDr BCM53324_A0_WRITE_GPORT_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GPORT_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR1023
 * BLOCKS:   GPORT0
 * DESC:     Receive 512 to 1023 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR1023r 0x00000015

#define BCM53324_A0_GR1023r_SIZE 4

/*
 * This structure should be used to declare and program GR1023.
 *
 */
typedef union BCM53324_A0_GR1023r_s {
	uint32_t v[1];
	uint32_t gr1023[1];
	uint32_t _gr1023;
} BCM53324_A0_GR1023r_t;

#define BCM53324_A0_GR1023r_CLR(r) (r).gr1023[0] = 0
#define BCM53324_A0_GR1023r_SET(r,d) (r).gr1023[0] = d
#define BCM53324_A0_GR1023r_GET(r) (r).gr1023[0]


/*
 * These macros can be used to access GR1023.
 *
 */
#define BCM53324_A0_READ_GR1023r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR1023r,(r._gr1023))
#define BCM53324_A0_WRITE_GR1023r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR1023r,&(r._gr1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR1023r BCM53324_A0_GR1023r
#define GR1023r_SIZE BCM53324_A0_GR1023r_SIZE
typedef BCM53324_A0_GR1023r_t GR1023r_t;
#define GR1023r_CLR BCM53324_A0_GR1023r_CLR
#define GR1023r_SET BCM53324_A0_GR1023r_SET
#define GR1023r_GET BCM53324_A0_GR1023r_GET
#define READ_GR1023r BCM53324_A0_READ_GR1023r
#define WRITE_GR1023r BCM53324_A0_WRITE_GR1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR127
 * BLOCKS:   GPORT0
 * DESC:     Receive 65 to 127 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR127r 0x00000012

#define BCM53324_A0_GR127r_SIZE 4

/*
 * This structure should be used to declare and program GR127.
 *
 */
typedef union BCM53324_A0_GR127r_s {
	uint32_t v[1];
	uint32_t gr127[1];
	uint32_t _gr127;
} BCM53324_A0_GR127r_t;

#define BCM53324_A0_GR127r_CLR(r) (r).gr127[0] = 0
#define BCM53324_A0_GR127r_SET(r,d) (r).gr127[0] = d
#define BCM53324_A0_GR127r_GET(r) (r).gr127[0]


/*
 * These macros can be used to access GR127.
 *
 */
#define BCM53324_A0_READ_GR127r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR127r,(r._gr127))
#define BCM53324_A0_WRITE_GR127r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR127r,&(r._gr127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR127r BCM53324_A0_GR127r
#define GR127r_SIZE BCM53324_A0_GR127r_SIZE
typedef BCM53324_A0_GR127r_t GR127r_t;
#define GR127r_CLR BCM53324_A0_GR127r_CLR
#define GR127r_SET BCM53324_A0_GR127r_SET
#define GR127r_GET BCM53324_A0_GR127r_GET
#define READ_GR127r BCM53324_A0_READ_GR127r
#define WRITE_GR127r BCM53324_A0_WRITE_GR127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR1518
 * BLOCKS:   GPORT0
 * DESC:     Receive 1024 to 1518 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR1518r 0x00000016

#define BCM53324_A0_GR1518r_SIZE 4

/*
 * This structure should be used to declare and program GR1518.
 *
 */
typedef union BCM53324_A0_GR1518r_s {
	uint32_t v[1];
	uint32_t gr1518[1];
	uint32_t _gr1518;
} BCM53324_A0_GR1518r_t;

#define BCM53324_A0_GR1518r_CLR(r) (r).gr1518[0] = 0
#define BCM53324_A0_GR1518r_SET(r,d) (r).gr1518[0] = d
#define BCM53324_A0_GR1518r_GET(r) (r).gr1518[0]


/*
 * These macros can be used to access GR1518.
 *
 */
#define BCM53324_A0_READ_GR1518r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR1518r,(r._gr1518))
#define BCM53324_A0_WRITE_GR1518r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR1518r,&(r._gr1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR1518r BCM53324_A0_GR1518r
#define GR1518r_SIZE BCM53324_A0_GR1518r_SIZE
typedef BCM53324_A0_GR1518r_t GR1518r_t;
#define GR1518r_CLR BCM53324_A0_GR1518r_CLR
#define GR1518r_SET BCM53324_A0_GR1518r_SET
#define GR1518r_GET BCM53324_A0_GR1518r_GET
#define READ_GR1518r BCM53324_A0_READ_GR1518r
#define WRITE_GR1518r BCM53324_A0_WRITE_GR1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR2047
 * BLOCKS:   GPORT0
 * DESC:     Receive 1519 to 2047 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR2047r 0x00000018

#define BCM53324_A0_GR2047r_SIZE 4

/*
 * This structure should be used to declare and program GR2047.
 *
 */
typedef union BCM53324_A0_GR2047r_s {
	uint32_t v[1];
	uint32_t gr2047[1];
	uint32_t _gr2047;
} BCM53324_A0_GR2047r_t;

#define BCM53324_A0_GR2047r_CLR(r) (r).gr2047[0] = 0
#define BCM53324_A0_GR2047r_SET(r,d) (r).gr2047[0] = d
#define BCM53324_A0_GR2047r_GET(r) (r).gr2047[0]


/*
 * These macros can be used to access GR2047.
 *
 */
#define BCM53324_A0_READ_GR2047r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR2047r,(r._gr2047))
#define BCM53324_A0_WRITE_GR2047r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR2047r,&(r._gr2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR2047r BCM53324_A0_GR2047r
#define GR2047r_SIZE BCM53324_A0_GR2047r_SIZE
typedef BCM53324_A0_GR2047r_t GR2047r_t;
#define GR2047r_CLR BCM53324_A0_GR2047r_CLR
#define GR2047r_SET BCM53324_A0_GR2047r_SET
#define GR2047r_GET BCM53324_A0_GR2047r_GET
#define READ_GR2047r BCM53324_A0_READ_GR2047r
#define WRITE_GR2047r BCM53324_A0_WRITE_GR2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR255
 * BLOCKS:   GPORT0
 * DESC:     Receive 128 to 255 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR255r 0x00000013

#define BCM53324_A0_GR255r_SIZE 4

/*
 * This structure should be used to declare and program GR255.
 *
 */
typedef union BCM53324_A0_GR255r_s {
	uint32_t v[1];
	uint32_t gr255[1];
	uint32_t _gr255;
} BCM53324_A0_GR255r_t;

#define BCM53324_A0_GR255r_CLR(r) (r).gr255[0] = 0
#define BCM53324_A0_GR255r_SET(r,d) (r).gr255[0] = d
#define BCM53324_A0_GR255r_GET(r) (r).gr255[0]


/*
 * These macros can be used to access GR255.
 *
 */
#define BCM53324_A0_READ_GR255r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR255r,(r._gr255))
#define BCM53324_A0_WRITE_GR255r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR255r,&(r._gr255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR255r BCM53324_A0_GR255r
#define GR255r_SIZE BCM53324_A0_GR255r_SIZE
typedef BCM53324_A0_GR255r_t GR255r_t;
#define GR255r_CLR BCM53324_A0_GR255r_CLR
#define GR255r_SET BCM53324_A0_GR255r_SET
#define GR255r_GET BCM53324_A0_GR255r_GET
#define READ_GR255r BCM53324_A0_READ_GR255r
#define WRITE_GR255r BCM53324_A0_WRITE_GR255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR4095
 * BLOCKS:   GPORT0
 * DESC:     Receive 2048 to 4095 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR4095r 0x00000019

#define BCM53324_A0_GR4095r_SIZE 4

/*
 * This structure should be used to declare and program GR4095.
 *
 */
typedef union BCM53324_A0_GR4095r_s {
	uint32_t v[1];
	uint32_t gr4095[1];
	uint32_t _gr4095;
} BCM53324_A0_GR4095r_t;

#define BCM53324_A0_GR4095r_CLR(r) (r).gr4095[0] = 0
#define BCM53324_A0_GR4095r_SET(r,d) (r).gr4095[0] = d
#define BCM53324_A0_GR4095r_GET(r) (r).gr4095[0]


/*
 * These macros can be used to access GR4095.
 *
 */
#define BCM53324_A0_READ_GR4095r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR4095r,(r._gr4095))
#define BCM53324_A0_WRITE_GR4095r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR4095r,&(r._gr4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR4095r BCM53324_A0_GR4095r
#define GR4095r_SIZE BCM53324_A0_GR4095r_SIZE
typedef BCM53324_A0_GR4095r_t GR4095r_t;
#define GR4095r_CLR BCM53324_A0_GR4095r_CLR
#define GR4095r_SET BCM53324_A0_GR4095r_SET
#define GR4095r_GET BCM53324_A0_GR4095r_GET
#define READ_GR4095r BCM53324_A0_READ_GR4095r
#define WRITE_GR4095r BCM53324_A0_WRITE_GR4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR511
 * BLOCKS:   GPORT0
 * DESC:     Receive 256 to 511 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR511r 0x00000014

#define BCM53324_A0_GR511r_SIZE 4

/*
 * This structure should be used to declare and program GR511.
 *
 */
typedef union BCM53324_A0_GR511r_s {
	uint32_t v[1];
	uint32_t gr511[1];
	uint32_t _gr511;
} BCM53324_A0_GR511r_t;

#define BCM53324_A0_GR511r_CLR(r) (r).gr511[0] = 0
#define BCM53324_A0_GR511r_SET(r,d) (r).gr511[0] = d
#define BCM53324_A0_GR511r_GET(r) (r).gr511[0]


/*
 * These macros can be used to access GR511.
 *
 */
#define BCM53324_A0_READ_GR511r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR511r,(r._gr511))
#define BCM53324_A0_WRITE_GR511r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR511r,&(r._gr511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR511r BCM53324_A0_GR511r
#define GR511r_SIZE BCM53324_A0_GR511r_SIZE
typedef BCM53324_A0_GR511r_t GR511r_t;
#define GR511r_CLR BCM53324_A0_GR511r_CLR
#define GR511r_SET BCM53324_A0_GR511r_SET
#define GR511r_GET BCM53324_A0_GR511r_GET
#define READ_GR511r BCM53324_A0_READ_GR511r
#define WRITE_GR511r BCM53324_A0_WRITE_GR511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR64
 * BLOCKS:   GPORT0
 * DESC:     Receive 64 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR64r 0x00000011

#define BCM53324_A0_GR64r_SIZE 4

/*
 * This structure should be used to declare and program GR64.
 *
 */
typedef union BCM53324_A0_GR64r_s {
	uint32_t v[1];
	uint32_t gr64[1];
	uint32_t _gr64;
} BCM53324_A0_GR64r_t;

#define BCM53324_A0_GR64r_CLR(r) (r).gr64[0] = 0
#define BCM53324_A0_GR64r_SET(r,d) (r).gr64[0] = d
#define BCM53324_A0_GR64r_GET(r) (r).gr64[0]


/*
 * These macros can be used to access GR64.
 *
 */
#define BCM53324_A0_READ_GR64r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR64r,(r._gr64))
#define BCM53324_A0_WRITE_GR64r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR64r,&(r._gr64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR64r BCM53324_A0_GR64r
#define GR64r_SIZE BCM53324_A0_GR64r_SIZE
typedef BCM53324_A0_GR64r_t GR64r_t;
#define GR64r_CLR BCM53324_A0_GR64r_CLR
#define GR64r_SET BCM53324_A0_GR64r_SET
#define GR64r_GET BCM53324_A0_GR64r_GET
#define READ_GR64r BCM53324_A0_READ_GR64r
#define WRITE_GR64r BCM53324_A0_WRITE_GR64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GR9216
 * BLOCKS:   GPORT0
 * DESC:     Receive 4096 to 9216 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GR9216r 0x0000001a

#define BCM53324_A0_GR9216r_SIZE 4

/*
 * This structure should be used to declare and program GR9216.
 *
 */
typedef union BCM53324_A0_GR9216r_s {
	uint32_t v[1];
	uint32_t gr9216[1];
	uint32_t _gr9216;
} BCM53324_A0_GR9216r_t;

#define BCM53324_A0_GR9216r_CLR(r) (r).gr9216[0] = 0
#define BCM53324_A0_GR9216r_SET(r,d) (r).gr9216[0] = d
#define BCM53324_A0_GR9216r_GET(r) (r).gr9216[0]


/*
 * These macros can be used to access GR9216.
 *
 */
#define BCM53324_A0_READ_GR9216r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GR9216r,(r._gr9216))
#define BCM53324_A0_WRITE_GR9216r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GR9216r,&(r._gr9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR9216r BCM53324_A0_GR9216r
#define GR9216r_SIZE BCM53324_A0_GR9216r_SIZE
typedef BCM53324_A0_GR9216r_t GR9216r_t;
#define GR9216r_CLR BCM53324_A0_GR9216r_CLR
#define GR9216r_SET BCM53324_A0_GR9216r_SET
#define GR9216r_GET BCM53324_A0_GR9216r_GET
#define READ_GR9216r BCM53324_A0_READ_GR9216r
#define WRITE_GR9216r BCM53324_A0_WRITE_GR9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GR9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRALN
 * BLOCKS:   GPORT0
 * DESC:     Receive Alignment Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRALNr 0x00000004

#define BCM53324_A0_GRALNr_SIZE 4

/*
 * This structure should be used to declare and program GRALN.
 *
 */
typedef union BCM53324_A0_GRALNr_s {
	uint32_t v[1];
	uint32_t graln[1];
	uint32_t _graln;
} BCM53324_A0_GRALNr_t;

#define BCM53324_A0_GRALNr_CLR(r) (r).graln[0] = 0
#define BCM53324_A0_GRALNr_SET(r,d) (r).graln[0] = d
#define BCM53324_A0_GRALNr_GET(r) (r).graln[0]


/*
 * These macros can be used to access GRALN.
 *
 */
#define BCM53324_A0_READ_GRALNr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRALNr,(r._graln))
#define BCM53324_A0_WRITE_GRALNr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRALNr,&(r._graln))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRALNr BCM53324_A0_GRALNr
#define GRALNr_SIZE BCM53324_A0_GRALNr_SIZE
typedef BCM53324_A0_GRALNr_t GRALNr_t;
#define GRALNr_CLR BCM53324_A0_GRALNr_CLR
#define GRALNr_SET BCM53324_A0_GRALNr_SET
#define GRALNr_GET BCM53324_A0_GRALNr_GET
#define READ_GRALNr BCM53324_A0_READ_GRALNr
#define WRITE_GRALNr BCM53324_A0_WRITE_GRALNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRALNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRBCA
 * BLOCKS:   GPORT0
 * DESC:     Receive Broadcast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRBCAr 0x00000010

#define BCM53324_A0_GRBCAr_SIZE 4

/*
 * This structure should be used to declare and program GRBCA.
 *
 */
typedef union BCM53324_A0_GRBCAr_s {
	uint32_t v[1];
	uint32_t grbca[1];
	uint32_t _grbca;
} BCM53324_A0_GRBCAr_t;

#define BCM53324_A0_GRBCAr_CLR(r) (r).grbca[0] = 0
#define BCM53324_A0_GRBCAr_SET(r,d) (r).grbca[0] = d
#define BCM53324_A0_GRBCAr_GET(r) (r).grbca[0]


/*
 * These macros can be used to access GRBCA.
 *
 */
#define BCM53324_A0_READ_GRBCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRBCAr,(r._grbca))
#define BCM53324_A0_WRITE_GRBCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRBCAr,&(r._grbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRBCAr BCM53324_A0_GRBCAr
#define GRBCAr_SIZE BCM53324_A0_GRBCAr_SIZE
typedef BCM53324_A0_GRBCAr_t GRBCAr_t;
#define GRBCAr_CLR BCM53324_A0_GRBCAr_CLR
#define GRBCAr_SET BCM53324_A0_GRBCAr_SET
#define GRBCAr_GET BCM53324_A0_GRBCAr_GET
#define READ_GRBCAr BCM53324_A0_READ_GRBCAr
#define WRITE_GRBCAr BCM53324_A0_WRITE_GRBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRBYT
 * BLOCKS:   GPORT0
 * DESC:     Receive Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRBYTr 0x0000001c

#define BCM53324_A0_GRBYTr_SIZE 4

/*
 * This structure should be used to declare and program GRBYT.
 *
 */
typedef union BCM53324_A0_GRBYTr_s {
	uint32_t v[1];
	uint32_t grbyt[1];
	uint32_t _grbyt;
} BCM53324_A0_GRBYTr_t;

#define BCM53324_A0_GRBYTr_CLR(r) (r).grbyt[0] = 0
#define BCM53324_A0_GRBYTr_SET(r,d) (r).grbyt[0] = d
#define BCM53324_A0_GRBYTr_GET(r) (r).grbyt[0]


/*
 * These macros can be used to access GRBYT.
 *
 */
#define BCM53324_A0_READ_GRBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRBYTr,(r._grbyt))
#define BCM53324_A0_WRITE_GRBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRBYTr,&(r._grbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRBYTr BCM53324_A0_GRBYTr
#define GRBYTr_SIZE BCM53324_A0_GRBYTr_SIZE
typedef BCM53324_A0_GRBYTr_t GRBYTr_t;
#define GRBYTr_CLR BCM53324_A0_GRBYTr_CLR
#define GRBYTr_SET BCM53324_A0_GRBYTr_SET
#define GRBYTr_GET BCM53324_A0_GRBYTr_GET
#define READ_GRBYTr BCM53324_A0_READ_GRBYTr
#define WRITE_GRBYTr BCM53324_A0_WRITE_GRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRCDE
 * BLOCKS:   GPORT0
 * DESC:     Receive Code Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRCDEr 0x00000006

#define BCM53324_A0_GRCDEr_SIZE 4

/*
 * This structure should be used to declare and program GRCDE.
 *
 */
typedef union BCM53324_A0_GRCDEr_s {
	uint32_t v[1];
	uint32_t grcde[1];
	uint32_t _grcde;
} BCM53324_A0_GRCDEr_t;

#define BCM53324_A0_GRCDEr_CLR(r) (r).grcde[0] = 0
#define BCM53324_A0_GRCDEr_SET(r,d) (r).grcde[0] = d
#define BCM53324_A0_GRCDEr_GET(r) (r).grcde[0]


/*
 * These macros can be used to access GRCDE.
 *
 */
#define BCM53324_A0_READ_GRCDEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRCDEr,(r._grcde))
#define BCM53324_A0_WRITE_GRCDEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRCDEr,&(r._grcde))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRCDEr BCM53324_A0_GRCDEr
#define GRCDEr_SIZE BCM53324_A0_GRCDEr_SIZE
typedef BCM53324_A0_GRCDEr_t GRCDEr_t;
#define GRCDEr_CLR BCM53324_A0_GRCDEr_CLR
#define GRCDEr_SET BCM53324_A0_GRCDEr_SET
#define GRCDEr_GET BCM53324_A0_GRCDEr_GET
#define READ_GRCDEr BCM53324_A0_READ_GRCDEr
#define WRITE_GRCDEr BCM53324_A0_WRITE_GRCDEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRCDEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRFCR
 * BLOCKS:   GPORT0
 * DESC:     Receive False Carrier Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRFCRr 0x00000007

#define BCM53324_A0_GRFCRr_SIZE 4

/*
 * This structure should be used to declare and program GRFCR.
 *
 */
typedef union BCM53324_A0_GRFCRr_s {
	uint32_t v[1];
	uint32_t grfcr[1];
	uint32_t _grfcr;
} BCM53324_A0_GRFCRr_t;

#define BCM53324_A0_GRFCRr_CLR(r) (r).grfcr[0] = 0
#define BCM53324_A0_GRFCRr_SET(r,d) (r).grfcr[0] = d
#define BCM53324_A0_GRFCRr_GET(r) (r).grfcr[0]


/*
 * These macros can be used to access GRFCR.
 *
 */
#define BCM53324_A0_READ_GRFCRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRFCRr,(r._grfcr))
#define BCM53324_A0_WRITE_GRFCRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRFCRr,&(r._grfcr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFCRr BCM53324_A0_GRFCRr
#define GRFCRr_SIZE BCM53324_A0_GRFCRr_SIZE
typedef BCM53324_A0_GRFCRr_t GRFCRr_t;
#define GRFCRr_CLR BCM53324_A0_GRFCRr_CLR
#define GRFCRr_SET BCM53324_A0_GRFCRr_SET
#define GRFCRr_GET BCM53324_A0_GRFCRr_GET
#define READ_GRFCRr BCM53324_A0_READ_GRFCRr
#define WRITE_GRFCRr BCM53324_A0_WRITE_GRFCRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRFCRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRFCS
 * BLOCKS:   GPORT0
 * DESC:     Receive FCS Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRFCSr 0x00000000

#define BCM53324_A0_GRFCSr_SIZE 4

/*
 * This structure should be used to declare and program GRFCS.
 *
 */
typedef union BCM53324_A0_GRFCSr_s {
	uint32_t v[1];
	uint32_t grfcs[1];
	uint32_t _grfcs;
} BCM53324_A0_GRFCSr_t;

#define BCM53324_A0_GRFCSr_CLR(r) (r).grfcs[0] = 0
#define BCM53324_A0_GRFCSr_SET(r,d) (r).grfcs[0] = d
#define BCM53324_A0_GRFCSr_GET(r) (r).grfcs[0]


/*
 * These macros can be used to access GRFCS.
 *
 */
#define BCM53324_A0_READ_GRFCSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRFCSr,(r._grfcs))
#define BCM53324_A0_WRITE_GRFCSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRFCSr,&(r._grfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFCSr BCM53324_A0_GRFCSr
#define GRFCSr_SIZE BCM53324_A0_GRFCSr_SIZE
typedef BCM53324_A0_GRFCSr_t GRFCSr_t;
#define GRFCSr_CLR BCM53324_A0_GRFCSr_CLR
#define GRFCSr_SET BCM53324_A0_GRFCSr_SET
#define GRFCSr_GET BCM53324_A0_GRFCSr_GET
#define READ_GRFCSr BCM53324_A0_READ_GRFCSr
#define WRITE_GRFCSr BCM53324_A0_WRITE_GRFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRFLR
 * BLOCKS:   GPORT0
 * DESC:     Receive Length Out of Range Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRFLRr 0x00000005

#define BCM53324_A0_GRFLRr_SIZE 4

/*
 * This structure should be used to declare and program GRFLR.
 *
 */
typedef union BCM53324_A0_GRFLRr_s {
	uint32_t v[1];
	uint32_t grflr[1];
	uint32_t _grflr;
} BCM53324_A0_GRFLRr_t;

#define BCM53324_A0_GRFLRr_CLR(r) (r).grflr[0] = 0
#define BCM53324_A0_GRFLRr_SET(r,d) (r).grflr[0] = d
#define BCM53324_A0_GRFLRr_GET(r) (r).grflr[0]


/*
 * These macros can be used to access GRFLR.
 *
 */
#define BCM53324_A0_READ_GRFLRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRFLRr,(r._grflr))
#define BCM53324_A0_WRITE_GRFLRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRFLRr,&(r._grflr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFLRr BCM53324_A0_GRFLRr
#define GRFLRr_SIZE BCM53324_A0_GRFLRr_SIZE
typedef BCM53324_A0_GRFLRr_t GRFLRr_t;
#define GRFLRr_CLR BCM53324_A0_GRFLRr_CLR
#define GRFLRr_SET BCM53324_A0_GRFLRr_SET
#define GRFLRr_GET BCM53324_A0_GRFLRr_GET
#define READ_GRFLRr BCM53324_A0_READ_GRFLRr
#define WRITE_GRFLRr BCM53324_A0_WRITE_GRFLRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRFLRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRFRG
 * BLOCKS:   GPORT0
 * DESC:     Receive Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRFRGr 0x0000000d

#define BCM53324_A0_GRFRGr_SIZE 4

/*
 * This structure should be used to declare and program GRFRG.
 *
 */
typedef union BCM53324_A0_GRFRGr_s {
	uint32_t v[1];
	uint32_t grfrg[1];
	uint32_t _grfrg;
} BCM53324_A0_GRFRGr_t;

#define BCM53324_A0_GRFRGr_CLR(r) (r).grfrg[0] = 0
#define BCM53324_A0_GRFRGr_SET(r,d) (r).grfrg[0] = d
#define BCM53324_A0_GRFRGr_GET(r) (r).grfrg[0]


/*
 * These macros can be used to access GRFRG.
 *
 */
#define BCM53324_A0_READ_GRFRGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRFRGr,(r._grfrg))
#define BCM53324_A0_WRITE_GRFRGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRFRGr,&(r._grfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFRGr BCM53324_A0_GRFRGr
#define GRFRGr_SIZE BCM53324_A0_GRFRGr_SIZE
typedef BCM53324_A0_GRFRGr_t GRFRGr_t;
#define GRFRGr_CLR BCM53324_A0_GRFRGr_CLR
#define GRFRGr_SET BCM53324_A0_GRFRGr_SET
#define GRFRGr_GET BCM53324_A0_GRFRGr_GET
#define READ_GRFRGr BCM53324_A0_READ_GRFRGr
#define WRITE_GRFRGr BCM53324_A0_WRITE_GRFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRJBR
 * BLOCKS:   GPORT0
 * DESC:     Receive Jabber Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRJBRr 0x00000009

#define BCM53324_A0_GRJBRr_SIZE 4

/*
 * This structure should be used to declare and program GRJBR.
 *
 */
typedef union BCM53324_A0_GRJBRr_s {
	uint32_t v[1];
	uint32_t grjbr[1];
	uint32_t _grjbr;
} BCM53324_A0_GRJBRr_t;

#define BCM53324_A0_GRJBRr_CLR(r) (r).grjbr[0] = 0
#define BCM53324_A0_GRJBRr_SET(r,d) (r).grjbr[0] = d
#define BCM53324_A0_GRJBRr_GET(r) (r).grjbr[0]


/*
 * These macros can be used to access GRJBR.
 *
 */
#define BCM53324_A0_READ_GRJBRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRJBRr,(r._grjbr))
#define BCM53324_A0_WRITE_GRJBRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRJBRr,&(r._grjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRJBRr BCM53324_A0_GRJBRr
#define GRJBRr_SIZE BCM53324_A0_GRJBRr_SIZE
typedef BCM53324_A0_GRJBRr_t GRJBRr_t;
#define GRJBRr_CLR BCM53324_A0_GRJBRr_CLR
#define GRJBRr_SET BCM53324_A0_GRJBRr_SET
#define GRJBRr_GET BCM53324_A0_GRJBRr_GET
#define READ_GRJBRr BCM53324_A0_READ_GRJBRr
#define WRITE_GRJBRr BCM53324_A0_WRITE_GRJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRMCA
 * BLOCKS:   GPORT0
 * DESC:     Receive Multicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRMCAr 0x0000000f

#define BCM53324_A0_GRMCAr_SIZE 4

/*
 * This structure should be used to declare and program GRMCA.
 *
 */
typedef union BCM53324_A0_GRMCAr_s {
	uint32_t v[1];
	uint32_t grmca[1];
	uint32_t _grmca;
} BCM53324_A0_GRMCAr_t;

#define BCM53324_A0_GRMCAr_CLR(r) (r).grmca[0] = 0
#define BCM53324_A0_GRMCAr_SET(r,d) (r).grmca[0] = d
#define BCM53324_A0_GRMCAr_GET(r) (r).grmca[0]


/*
 * These macros can be used to access GRMCA.
 *
 */
#define BCM53324_A0_READ_GRMCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRMCAr,(r._grmca))
#define BCM53324_A0_WRITE_GRMCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRMCAr,&(r._grmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMCAr BCM53324_A0_GRMCAr
#define GRMCAr_SIZE BCM53324_A0_GRMCAr_SIZE
typedef BCM53324_A0_GRMCAr_t GRMCAr_t;
#define GRMCAr_CLR BCM53324_A0_GRMCAr_CLR
#define GRMCAr_SET BCM53324_A0_GRMCAr_SET
#define GRMCAr_GET BCM53324_A0_GRMCAr_GET
#define READ_GRMCAr BCM53324_A0_READ_GRMCAr
#define WRITE_GRMCAr BCM53324_A0_WRITE_GRMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRMGV
 * BLOCKS:   GPORT0
 * DESC:     Receive 1519 to 1522 Byte Good VLAN Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRMGVr 0x00000017

#define BCM53324_A0_GRMGVr_SIZE 4

/*
 * This structure should be used to declare and program GRMGV.
 *
 */
typedef union BCM53324_A0_GRMGVr_s {
	uint32_t v[1];
	uint32_t grmgv[1];
	uint32_t _grmgv;
} BCM53324_A0_GRMGVr_t;

#define BCM53324_A0_GRMGVr_CLR(r) (r).grmgv[0] = 0
#define BCM53324_A0_GRMGVr_SET(r,d) (r).grmgv[0] = d
#define BCM53324_A0_GRMGVr_GET(r) (r).grmgv[0]


/*
 * These macros can be used to access GRMGV.
 *
 */
#define BCM53324_A0_READ_GRMGVr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRMGVr,(r._grmgv))
#define BCM53324_A0_WRITE_GRMGVr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRMGVr,&(r._grmgv))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMGVr BCM53324_A0_GRMGVr
#define GRMGVr_SIZE BCM53324_A0_GRMGVr_SIZE
typedef BCM53324_A0_GRMGVr_t GRMGVr_t;
#define GRMGVr_CLR BCM53324_A0_GRMGVr_CLR
#define GRMGVr_SET BCM53324_A0_GRMGVr_SET
#define GRMGVr_GET BCM53324_A0_GRMGVr_GET
#define READ_GRMGVr BCM53324_A0_READ_GRMGVr
#define WRITE_GRMGVr BCM53324_A0_WRITE_GRMGVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRMGVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRMTUE
 * BLOCKS:   GPORT0
 * DESC:     Receive MTU Check Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRMTUEr 0x0000000a

#define BCM53324_A0_GRMTUEr_SIZE 4

/*
 * This structure should be used to declare and program GRMTUE.
 *
 */
typedef union BCM53324_A0_GRMTUEr_s {
	uint32_t v[1];
	uint32_t grmtue[1];
	uint32_t _grmtue;
} BCM53324_A0_GRMTUEr_t;

#define BCM53324_A0_GRMTUEr_CLR(r) (r).grmtue[0] = 0
#define BCM53324_A0_GRMTUEr_SET(r,d) (r).grmtue[0] = d
#define BCM53324_A0_GRMTUEr_GET(r) (r).grmtue[0]


/*
 * These macros can be used to access GRMTUE.
 *
 */
#define BCM53324_A0_READ_GRMTUEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRMTUEr,(r._grmtue))
#define BCM53324_A0_WRITE_GRMTUEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRMTUEr,&(r._grmtue))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMTUEr BCM53324_A0_GRMTUEr
#define GRMTUEr_SIZE BCM53324_A0_GRMTUEr_SIZE
typedef BCM53324_A0_GRMTUEr_t GRMTUEr_t;
#define GRMTUEr_CLR BCM53324_A0_GRMTUEr_CLR
#define GRMTUEr_SET BCM53324_A0_GRMTUEr_SET
#define GRMTUEr_GET BCM53324_A0_GRMTUEr_GET
#define READ_GRMTUEr BCM53324_A0_READ_GRMTUEr
#define WRITE_GRMTUEr BCM53324_A0_WRITE_GRMTUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRMTUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GROVR
 * BLOCKS:   GPORT0
 * DESC:     Receive Oversized Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GROVRr 0x00000008

#define BCM53324_A0_GROVRr_SIZE 4

/*
 * This structure should be used to declare and program GROVR.
 *
 */
typedef union BCM53324_A0_GROVRr_s {
	uint32_t v[1];
	uint32_t grovr[1];
	uint32_t _grovr;
} BCM53324_A0_GROVRr_t;

#define BCM53324_A0_GROVRr_CLR(r) (r).grovr[0] = 0
#define BCM53324_A0_GROVRr_SET(r,d) (r).grovr[0] = d
#define BCM53324_A0_GROVRr_GET(r) (r).grovr[0]


/*
 * These macros can be used to access GROVR.
 *
 */
#define BCM53324_A0_READ_GROVRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GROVRr,(r._grovr))
#define BCM53324_A0_WRITE_GROVRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GROVRr,&(r._grovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GROVRr BCM53324_A0_GROVRr
#define GROVRr_SIZE BCM53324_A0_GROVRr_SIZE
typedef BCM53324_A0_GROVRr_t GROVRr_t;
#define GROVRr_CLR BCM53324_A0_GROVRr_CLR
#define GROVRr_SET BCM53324_A0_GROVRr_SET
#define GROVRr_GET BCM53324_A0_GROVRr_GET
#define READ_GROVRr BCM53324_A0_READ_GROVRr
#define WRITE_GROVRr BCM53324_A0_WRITE_GROVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GROVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRPKT
 * BLOCKS:   GPORT0
 * DESC:     Receive frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRPKTr 0x0000001b

#define BCM53324_A0_GRPKTr_SIZE 4

/*
 * This structure should be used to declare and program GRPKT.
 *
 */
typedef union BCM53324_A0_GRPKTr_s {
	uint32_t v[1];
	uint32_t grpkt[1];
	uint32_t _grpkt;
} BCM53324_A0_GRPKTr_t;

#define BCM53324_A0_GRPKTr_CLR(r) (r).grpkt[0] = 0
#define BCM53324_A0_GRPKTr_SET(r,d) (r).grpkt[0] = d
#define BCM53324_A0_GRPKTr_GET(r) (r).grpkt[0]


/*
 * These macros can be used to access GRPKT.
 *
 */
#define BCM53324_A0_READ_GRPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRPKTr,(r._grpkt))
#define BCM53324_A0_WRITE_GRPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRPKTr,&(r._grpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPKTr BCM53324_A0_GRPKTr
#define GRPKTr_SIZE BCM53324_A0_GRPKTr_SIZE
typedef BCM53324_A0_GRPKTr_t GRPKTr_t;
#define GRPKTr_CLR BCM53324_A0_GRPKTr_CLR
#define GRPKTr_SET BCM53324_A0_GRPKTr_SET
#define GRPKTr_GET BCM53324_A0_GRPKTr_GET
#define READ_GRPKTr BCM53324_A0_READ_GRPKTr
#define WRITE_GRPKTr BCM53324_A0_WRITE_GRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRPOK
 * BLOCKS:   GPORT0
 * DESC:     Received Packets OK Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRPOKr 0x0000001e

#define BCM53324_A0_GRPOKr_SIZE 4

/*
 * This structure should be used to declare and program GRPOK.
 *
 */
typedef union BCM53324_A0_GRPOKr_s {
	uint32_t v[1];
	uint32_t grpok[1];
	uint32_t _grpok;
} BCM53324_A0_GRPOKr_t;

#define BCM53324_A0_GRPOKr_CLR(r) (r).grpok[0] = 0
#define BCM53324_A0_GRPOKr_SET(r,d) (r).grpok[0] = d
#define BCM53324_A0_GRPOKr_GET(r) (r).grpok[0]


/*
 * These macros can be used to access GRPOK.
 *
 */
#define BCM53324_A0_READ_GRPOKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRPOKr,(r._grpok))
#define BCM53324_A0_WRITE_GRPOKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRPOKr,&(r._grpok))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPOKr BCM53324_A0_GRPOKr
#define GRPOKr_SIZE BCM53324_A0_GRPOKr_SIZE
typedef BCM53324_A0_GRPOKr_t GRPOKr_t;
#define GRPOKr_CLR BCM53324_A0_GRPOKr_CLR
#define GRPOKr_SET BCM53324_A0_GRPOKr_SET
#define GRPOKr_GET BCM53324_A0_GRPOKr_GET
#define READ_GRPOKr BCM53324_A0_READ_GRPOKr
#define WRITE_GRPOKr BCM53324_A0_WRITE_GRPOKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRPOKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRUC
 * BLOCKS:   GPORT0
 * DESC:     Receive Unicast Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRUCr 0x0000001d

#define BCM53324_A0_GRUCr_SIZE 4

/*
 * This structure should be used to declare and program GRUC.
 *
 */
typedef union BCM53324_A0_GRUCr_s {
	uint32_t v[1];
	uint32_t gruc[1];
	uint32_t _gruc;
} BCM53324_A0_GRUCr_t;

#define BCM53324_A0_GRUCr_CLR(r) (r).gruc[0] = 0
#define BCM53324_A0_GRUCr_SET(r,d) (r).gruc[0] = d
#define BCM53324_A0_GRUCr_GET(r) (r).gruc[0]


/*
 * These macros can be used to access GRUC.
 *
 */
#define BCM53324_A0_READ_GRUCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRUCr,(r._gruc))
#define BCM53324_A0_WRITE_GRUCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRUCr,&(r._gruc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRUCr BCM53324_A0_GRUCr
#define GRUCr_SIZE BCM53324_A0_GRUCr_SIZE
typedef BCM53324_A0_GRUCr_t GRUCr_t;
#define GRUCr_CLR BCM53324_A0_GRUCr_CLR
#define GRUCr_SET BCM53324_A0_GRUCr_SET
#define GRUCr_GET BCM53324_A0_GRUCr_GET
#define READ_GRUCr BCM53324_A0_READ_GRUCr
#define WRITE_GRUCr BCM53324_A0_WRITE_GRUCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRUCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRUND
 * BLOCKS:   GPORT0
 * DESC:     Receive Undersize Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRUNDr 0x0000000c

#define BCM53324_A0_GRUNDr_SIZE 4

/*
 * This structure should be used to declare and program GRUND.
 *
 */
typedef union BCM53324_A0_GRUNDr_s {
	uint32_t v[1];
	uint32_t grund[1];
	uint32_t _grund;
} BCM53324_A0_GRUNDr_t;

#define BCM53324_A0_GRUNDr_CLR(r) (r).grund[0] = 0
#define BCM53324_A0_GRUNDr_SET(r,d) (r).grund[0] = d
#define BCM53324_A0_GRUNDr_GET(r) (r).grund[0]


/*
 * These macros can be used to access GRUND.
 *
 */
#define BCM53324_A0_READ_GRUNDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRUNDr,(r._grund))
#define BCM53324_A0_WRITE_GRUNDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRUNDr,&(r._grund))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRUNDr BCM53324_A0_GRUNDr
#define GRUNDr_SIZE BCM53324_A0_GRUNDr_SIZE
typedef BCM53324_A0_GRUNDr_t GRUNDr_t;
#define GRUNDr_CLR BCM53324_A0_GRUNDr_CLR
#define GRUNDr_SET BCM53324_A0_GRUNDr_SET
#define GRUNDr_GET BCM53324_A0_GRUNDr_GET
#define READ_GRUNDr BCM53324_A0_READ_GRUNDr
#define WRITE_GRUNDr BCM53324_A0_WRITE_GRUNDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRUNDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRXCF
 * BLOCKS:   GPORT0
 * DESC:     Receive Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRXCFr 0x00000001

#define BCM53324_A0_GRXCFr_SIZE 4

/*
 * This structure should be used to declare and program GRXCF.
 *
 */
typedef union BCM53324_A0_GRXCFr_s {
	uint32_t v[1];
	uint32_t grxcf[1];
	uint32_t _grxcf;
} BCM53324_A0_GRXCFr_t;

#define BCM53324_A0_GRXCFr_CLR(r) (r).grxcf[0] = 0
#define BCM53324_A0_GRXCFr_SET(r,d) (r).grxcf[0] = d
#define BCM53324_A0_GRXCFr_GET(r) (r).grxcf[0]


/*
 * These macros can be used to access GRXCF.
 *
 */
#define BCM53324_A0_READ_GRXCFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRXCFr,(r._grxcf))
#define BCM53324_A0_WRITE_GRXCFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRXCFr,&(r._grxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXCFr BCM53324_A0_GRXCFr
#define GRXCFr_SIZE BCM53324_A0_GRXCFr_SIZE
typedef BCM53324_A0_GRXCFr_t GRXCFr_t;
#define GRXCFr_CLR BCM53324_A0_GRXCFr_CLR
#define GRXCFr_SET BCM53324_A0_GRXCFr_SET
#define GRXCFr_GET BCM53324_A0_GRXCFr_GET
#define READ_GRXCFr BCM53324_A0_READ_GRXCFr
#define WRITE_GRXCFr BCM53324_A0_WRITE_GRXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRXPF
 * BLOCKS:   GPORT0
 * DESC:     Receive Pause Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRXPFr 0x00000002

#define BCM53324_A0_GRXPFr_SIZE 4

/*
 * This structure should be used to declare and program GRXPF.
 *
 */
typedef union BCM53324_A0_GRXPFr_s {
	uint32_t v[1];
	uint32_t grxpf[1];
	uint32_t _grxpf;
} BCM53324_A0_GRXPFr_t;

#define BCM53324_A0_GRXPFr_CLR(r) (r).grxpf[0] = 0
#define BCM53324_A0_GRXPFr_SET(r,d) (r).grxpf[0] = d
#define BCM53324_A0_GRXPFr_GET(r) (r).grxpf[0]


/*
 * These macros can be used to access GRXPF.
 *
 */
#define BCM53324_A0_READ_GRXPFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRXPFr,(r._grxpf))
#define BCM53324_A0_WRITE_GRXPFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRXPFr,&(r._grxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXPFr BCM53324_A0_GRXPFr
#define GRXPFr_SIZE BCM53324_A0_GRXPFr_SIZE
typedef BCM53324_A0_GRXPFr_t GRXPFr_t;
#define GRXPFr_CLR BCM53324_A0_GRXPFr_CLR
#define GRXPFr_SET BCM53324_A0_GRXPFr_SET
#define GRXPFr_GET BCM53324_A0_GRXPFr_GET
#define READ_GRXPFr BCM53324_A0_READ_GRXPFr
#define WRITE_GRXPFr BCM53324_A0_WRITE_GRXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GRXUO
 * BLOCKS:   GPORT0
 * DESC:     Receive Unsupported Opcode Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GRXUOr 0x00000003

#define BCM53324_A0_GRXUOr_SIZE 4

/*
 * This structure should be used to declare and program GRXUO.
 *
 */
typedef union BCM53324_A0_GRXUOr_s {
	uint32_t v[1];
	uint32_t grxuo[1];
	uint32_t _grxuo;
} BCM53324_A0_GRXUOr_t;

#define BCM53324_A0_GRXUOr_CLR(r) (r).grxuo[0] = 0
#define BCM53324_A0_GRXUOr_SET(r,d) (r).grxuo[0] = d
#define BCM53324_A0_GRXUOr_GET(r) (r).grxuo[0]


/*
 * These macros can be used to access GRXUO.
 *
 */
#define BCM53324_A0_READ_GRXUOr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GRXUOr,(r._grxuo))
#define BCM53324_A0_WRITE_GRXUOr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GRXUOr,&(r._grxuo))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXUOr BCM53324_A0_GRXUOr
#define GRXUOr_SIZE BCM53324_A0_GRXUOr_SIZE
typedef BCM53324_A0_GRXUOr_t GRXUOr_t;
#define GRXUOr_CLR BCM53324_A0_GRXUOr_CLR
#define GRXUOr_SET BCM53324_A0_GRXUOr_SET
#define GRXUOr_GET BCM53324_A0_GRXUOr_GET
#define READ_GRXUOr BCM53324_A0_READ_GRXUOr
#define WRITE_GRXUOr BCM53324_A0_WRITE_GRXUOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GRXUOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT1023
 * BLOCKS:   GPORT0
 * DESC:     Transmit 512 to 1023 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT1023r 0x00000032

#define BCM53324_A0_GT1023r_SIZE 4

/*
 * This structure should be used to declare and program GT1023.
 *
 */
typedef union BCM53324_A0_GT1023r_s {
	uint32_t v[1];
	uint32_t gt1023[1];
	uint32_t _gt1023;
} BCM53324_A0_GT1023r_t;

#define BCM53324_A0_GT1023r_CLR(r) (r).gt1023[0] = 0
#define BCM53324_A0_GT1023r_SET(r,d) (r).gt1023[0] = d
#define BCM53324_A0_GT1023r_GET(r) (r).gt1023[0]


/*
 * These macros can be used to access GT1023.
 *
 */
#define BCM53324_A0_READ_GT1023r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT1023r,(r._gt1023))
#define BCM53324_A0_WRITE_GT1023r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT1023r,&(r._gt1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT1023r BCM53324_A0_GT1023r
#define GT1023r_SIZE BCM53324_A0_GT1023r_SIZE
typedef BCM53324_A0_GT1023r_t GT1023r_t;
#define GT1023r_CLR BCM53324_A0_GT1023r_CLR
#define GT1023r_SET BCM53324_A0_GT1023r_SET
#define GT1023r_GET BCM53324_A0_GT1023r_GET
#define READ_GT1023r BCM53324_A0_READ_GT1023r
#define WRITE_GT1023r BCM53324_A0_WRITE_GT1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT127
 * BLOCKS:   GPORT0
 * DESC:     Transmit 65 to 127 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT127r 0x0000002f

#define BCM53324_A0_GT127r_SIZE 4

/*
 * This structure should be used to declare and program GT127.
 *
 */
typedef union BCM53324_A0_GT127r_s {
	uint32_t v[1];
	uint32_t gt127[1];
	uint32_t _gt127;
} BCM53324_A0_GT127r_t;

#define BCM53324_A0_GT127r_CLR(r) (r).gt127[0] = 0
#define BCM53324_A0_GT127r_SET(r,d) (r).gt127[0] = d
#define BCM53324_A0_GT127r_GET(r) (r).gt127[0]


/*
 * These macros can be used to access GT127.
 *
 */
#define BCM53324_A0_READ_GT127r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT127r,(r._gt127))
#define BCM53324_A0_WRITE_GT127r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT127r,&(r._gt127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT127r BCM53324_A0_GT127r
#define GT127r_SIZE BCM53324_A0_GT127r_SIZE
typedef BCM53324_A0_GT127r_t GT127r_t;
#define GT127r_CLR BCM53324_A0_GT127r_CLR
#define GT127r_SET BCM53324_A0_GT127r_SET
#define GT127r_GET BCM53324_A0_GT127r_GET
#define READ_GT127r BCM53324_A0_READ_GT127r
#define WRITE_GT127r BCM53324_A0_WRITE_GT127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT1518
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1024 to 1518 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT1518r 0x00000033

#define BCM53324_A0_GT1518r_SIZE 4

/*
 * This structure should be used to declare and program GT1518.
 *
 */
typedef union BCM53324_A0_GT1518r_s {
	uint32_t v[1];
	uint32_t gt1518[1];
	uint32_t _gt1518;
} BCM53324_A0_GT1518r_t;

#define BCM53324_A0_GT1518r_CLR(r) (r).gt1518[0] = 0
#define BCM53324_A0_GT1518r_SET(r,d) (r).gt1518[0] = d
#define BCM53324_A0_GT1518r_GET(r) (r).gt1518[0]


/*
 * These macros can be used to access GT1518.
 *
 */
#define BCM53324_A0_READ_GT1518r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT1518r,(r._gt1518))
#define BCM53324_A0_WRITE_GT1518r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT1518r,&(r._gt1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT1518r BCM53324_A0_GT1518r
#define GT1518r_SIZE BCM53324_A0_GT1518r_SIZE
typedef BCM53324_A0_GT1518r_t GT1518r_t;
#define GT1518r_CLR BCM53324_A0_GT1518r_CLR
#define GT1518r_SET BCM53324_A0_GT1518r_SET
#define GT1518r_GET BCM53324_A0_GT1518r_GET
#define READ_GT1518r BCM53324_A0_READ_GT1518r
#define WRITE_GT1518r BCM53324_A0_WRITE_GT1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT2047
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1519 to 2047 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT2047r 0x00000035

#define BCM53324_A0_GT2047r_SIZE 4

/*
 * This structure should be used to declare and program GT2047.
 *
 */
typedef union BCM53324_A0_GT2047r_s {
	uint32_t v[1];
	uint32_t gt2047[1];
	uint32_t _gt2047;
} BCM53324_A0_GT2047r_t;

#define BCM53324_A0_GT2047r_CLR(r) (r).gt2047[0] = 0
#define BCM53324_A0_GT2047r_SET(r,d) (r).gt2047[0] = d
#define BCM53324_A0_GT2047r_GET(r) (r).gt2047[0]


/*
 * These macros can be used to access GT2047.
 *
 */
#define BCM53324_A0_READ_GT2047r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT2047r,(r._gt2047))
#define BCM53324_A0_WRITE_GT2047r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT2047r,&(r._gt2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT2047r BCM53324_A0_GT2047r
#define GT2047r_SIZE BCM53324_A0_GT2047r_SIZE
typedef BCM53324_A0_GT2047r_t GT2047r_t;
#define GT2047r_CLR BCM53324_A0_GT2047r_CLR
#define GT2047r_SET BCM53324_A0_GT2047r_SET
#define GT2047r_GET BCM53324_A0_GT2047r_GET
#define READ_GT2047r BCM53324_A0_READ_GT2047r
#define WRITE_GT2047r BCM53324_A0_WRITE_GT2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT255
 * BLOCKS:   GPORT0
 * DESC:     Transmit 128 to 255 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT255r 0x00000030

#define BCM53324_A0_GT255r_SIZE 4

/*
 * This structure should be used to declare and program GT255.
 *
 */
typedef union BCM53324_A0_GT255r_s {
	uint32_t v[1];
	uint32_t gt255[1];
	uint32_t _gt255;
} BCM53324_A0_GT255r_t;

#define BCM53324_A0_GT255r_CLR(r) (r).gt255[0] = 0
#define BCM53324_A0_GT255r_SET(r,d) (r).gt255[0] = d
#define BCM53324_A0_GT255r_GET(r) (r).gt255[0]


/*
 * These macros can be used to access GT255.
 *
 */
#define BCM53324_A0_READ_GT255r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT255r,(r._gt255))
#define BCM53324_A0_WRITE_GT255r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT255r,&(r._gt255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT255r BCM53324_A0_GT255r
#define GT255r_SIZE BCM53324_A0_GT255r_SIZE
typedef BCM53324_A0_GT255r_t GT255r_t;
#define GT255r_CLR BCM53324_A0_GT255r_CLR
#define GT255r_SET BCM53324_A0_GT255r_SET
#define GT255r_GET BCM53324_A0_GT255r_GET
#define READ_GT255r BCM53324_A0_READ_GT255r
#define WRITE_GT255r BCM53324_A0_WRITE_GT255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT4095
 * BLOCKS:   GPORT0
 * DESC:     Transmit 2048 to 4095 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT4095r 0x00000036

#define BCM53324_A0_GT4095r_SIZE 4

/*
 * This structure should be used to declare and program GT4095.
 *
 */
typedef union BCM53324_A0_GT4095r_s {
	uint32_t v[1];
	uint32_t gt4095[1];
	uint32_t _gt4095;
} BCM53324_A0_GT4095r_t;

#define BCM53324_A0_GT4095r_CLR(r) (r).gt4095[0] = 0
#define BCM53324_A0_GT4095r_SET(r,d) (r).gt4095[0] = d
#define BCM53324_A0_GT4095r_GET(r) (r).gt4095[0]


/*
 * These macros can be used to access GT4095.
 *
 */
#define BCM53324_A0_READ_GT4095r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT4095r,(r._gt4095))
#define BCM53324_A0_WRITE_GT4095r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT4095r,&(r._gt4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT4095r BCM53324_A0_GT4095r
#define GT4095r_SIZE BCM53324_A0_GT4095r_SIZE
typedef BCM53324_A0_GT4095r_t GT4095r_t;
#define GT4095r_CLR BCM53324_A0_GT4095r_CLR
#define GT4095r_SET BCM53324_A0_GT4095r_SET
#define GT4095r_GET BCM53324_A0_GT4095r_GET
#define READ_GT4095r BCM53324_A0_READ_GT4095r
#define WRITE_GT4095r BCM53324_A0_WRITE_GT4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT511
 * BLOCKS:   GPORT0
 * DESC:     Transmit 256 to 511 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT511r 0x00000031

#define BCM53324_A0_GT511r_SIZE 4

/*
 * This structure should be used to declare and program GT511.
 *
 */
typedef union BCM53324_A0_GT511r_s {
	uint32_t v[1];
	uint32_t gt511[1];
	uint32_t _gt511;
} BCM53324_A0_GT511r_t;

#define BCM53324_A0_GT511r_CLR(r) (r).gt511[0] = 0
#define BCM53324_A0_GT511r_SET(r,d) (r).gt511[0] = d
#define BCM53324_A0_GT511r_GET(r) (r).gt511[0]


/*
 * These macros can be used to access GT511.
 *
 */
#define BCM53324_A0_READ_GT511r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT511r,(r._gt511))
#define BCM53324_A0_WRITE_GT511r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT511r,&(r._gt511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT511r BCM53324_A0_GT511r
#define GT511r_SIZE BCM53324_A0_GT511r_SIZE
typedef BCM53324_A0_GT511r_t GT511r_t;
#define GT511r_CLR BCM53324_A0_GT511r_CLR
#define GT511r_SET BCM53324_A0_GT511r_SET
#define GT511r_GET BCM53324_A0_GT511r_GET
#define READ_GT511r BCM53324_A0_READ_GT511r
#define WRITE_GT511r BCM53324_A0_WRITE_GT511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT64
 * BLOCKS:   GPORT0
 * DESC:     Transmit 64 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT64r 0x0000002e

#define BCM53324_A0_GT64r_SIZE 4

/*
 * This structure should be used to declare and program GT64.
 *
 */
typedef union BCM53324_A0_GT64r_s {
	uint32_t v[1];
	uint32_t gt64[1];
	uint32_t _gt64;
} BCM53324_A0_GT64r_t;

#define BCM53324_A0_GT64r_CLR(r) (r).gt64[0] = 0
#define BCM53324_A0_GT64r_SET(r,d) (r).gt64[0] = d
#define BCM53324_A0_GT64r_GET(r) (r).gt64[0]


/*
 * These macros can be used to access GT64.
 *
 */
#define BCM53324_A0_READ_GT64r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT64r,(r._gt64))
#define BCM53324_A0_WRITE_GT64r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT64r,&(r._gt64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT64r BCM53324_A0_GT64r
#define GT64r_SIZE BCM53324_A0_GT64r_SIZE
typedef BCM53324_A0_GT64r_t GT64r_t;
#define GT64r_CLR BCM53324_A0_GT64r_CLR
#define GT64r_SET BCM53324_A0_GT64r_SET
#define GT64r_GET BCM53324_A0_GT64r_GET
#define READ_GT64r BCM53324_A0_READ_GT64r
#define WRITE_GT64r BCM53324_A0_WRITE_GT64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GT9216
 * BLOCKS:   GPORT0
 * DESC:     Transmit 4096 to 9216 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GT9216r 0x00000037

#define BCM53324_A0_GT9216r_SIZE 4

/*
 * This structure should be used to declare and program GT9216.
 *
 */
typedef union BCM53324_A0_GT9216r_s {
	uint32_t v[1];
	uint32_t gt9216[1];
	uint32_t _gt9216;
} BCM53324_A0_GT9216r_t;

#define BCM53324_A0_GT9216r_CLR(r) (r).gt9216[0] = 0
#define BCM53324_A0_GT9216r_SET(r,d) (r).gt9216[0] = d
#define BCM53324_A0_GT9216r_GET(r) (r).gt9216[0]


/*
 * These macros can be used to access GT9216.
 *
 */
#define BCM53324_A0_READ_GT9216r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GT9216r,(r._gt9216))
#define BCM53324_A0_WRITE_GT9216r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GT9216r,&(r._gt9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT9216r BCM53324_A0_GT9216r
#define GT9216r_SIZE BCM53324_A0_GT9216r_SIZE
typedef BCM53324_A0_GT9216r_t GT9216r_t;
#define GT9216r_CLR BCM53324_A0_GT9216r_CLR
#define GT9216r_SET BCM53324_A0_GT9216r_SET
#define GT9216r_GET BCM53324_A0_GT9216r_GET
#define READ_GT9216r BCM53324_A0_READ_GT9216r
#define WRITE_GT9216r BCM53324_A0_WRITE_GT9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GT9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTBCA
 * BLOCKS:   GPORT0
 * DESC:     Transmit Broadcast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTBCAr 0x0000002d

#define BCM53324_A0_GTBCAr_SIZE 4

/*
 * This structure should be used to declare and program GTBCA.
 *
 */
typedef union BCM53324_A0_GTBCAr_s {
	uint32_t v[1];
	uint32_t gtbca[1];
	uint32_t _gtbca;
} BCM53324_A0_GTBCAr_t;

#define BCM53324_A0_GTBCAr_CLR(r) (r).gtbca[0] = 0
#define BCM53324_A0_GTBCAr_SET(r,d) (r).gtbca[0] = d
#define BCM53324_A0_GTBCAr_GET(r) (r).gtbca[0]


/*
 * These macros can be used to access GTBCA.
 *
 */
#define BCM53324_A0_READ_GTBCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTBCAr,(r._gtbca))
#define BCM53324_A0_WRITE_GTBCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTBCAr,&(r._gtbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTBCAr BCM53324_A0_GTBCAr
#define GTBCAr_SIZE BCM53324_A0_GTBCAr_SIZE
typedef BCM53324_A0_GTBCAr_t GTBCAr_t;
#define GTBCAr_CLR BCM53324_A0_GTBCAr_CLR
#define GTBCAr_SET BCM53324_A0_GTBCAr_SET
#define GTBCAr_GET BCM53324_A0_GTBCAr_GET
#define READ_GTBCAr BCM53324_A0_READ_GTBCAr
#define WRITE_GTBCAr BCM53324_A0_WRITE_GTBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTBYT
 * BLOCKS:   GPORT0
 * DESC:     Transmit Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTBYTr 0x00000039

#define BCM53324_A0_GTBYTr_SIZE 4

/*
 * This structure should be used to declare and program GTBYT.
 *
 */
typedef union BCM53324_A0_GTBYTr_s {
	uint32_t v[1];
	uint32_t gtbyt[1];
	uint32_t _gtbyt;
} BCM53324_A0_GTBYTr_t;

#define BCM53324_A0_GTBYTr_CLR(r) (r).gtbyt[0] = 0
#define BCM53324_A0_GTBYTr_SET(r,d) (r).gtbyt[0] = d
#define BCM53324_A0_GTBYTr_GET(r) (r).gtbyt[0]


/*
 * These macros can be used to access GTBYT.
 *
 */
#define BCM53324_A0_READ_GTBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTBYTr,(r._gtbyt))
#define BCM53324_A0_WRITE_GTBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTBYTr,&(r._gtbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTBYTr BCM53324_A0_GTBYTr
#define GTBYTr_SIZE BCM53324_A0_GTBYTr_SIZE
typedef BCM53324_A0_GTBYTr_t GTBYTr_t;
#define GTBYTr_CLR BCM53324_A0_GTBYTr_CLR
#define GTBYTr_SET BCM53324_A0_GTBYTr_SET
#define GTBYTr_GET BCM53324_A0_GTBYTr_GET
#define READ_GTBYTr BCM53324_A0_READ_GTBYTr
#define WRITE_GTBYTr BCM53324_A0_WRITE_GTBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTDFR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Single Deferral Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTDFRr 0x00000024

#define BCM53324_A0_GTDFRr_SIZE 4

/*
 * This structure should be used to declare and program GTDFR.
 *
 */
typedef union BCM53324_A0_GTDFRr_s {
	uint32_t v[1];
	uint32_t gtdfr[1];
	uint32_t _gtdfr;
} BCM53324_A0_GTDFRr_t;

#define BCM53324_A0_GTDFRr_CLR(r) (r).gtdfr[0] = 0
#define BCM53324_A0_GTDFRr_SET(r,d) (r).gtdfr[0] = d
#define BCM53324_A0_GTDFRr_GET(r) (r).gtdfr[0]


/*
 * These macros can be used to access GTDFR.
 *
 */
#define BCM53324_A0_READ_GTDFRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTDFRr,(r._gtdfr))
#define BCM53324_A0_WRITE_GTDFRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTDFRr,&(r._gtdfr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTDFRr BCM53324_A0_GTDFRr
#define GTDFRr_SIZE BCM53324_A0_GTDFRr_SIZE
typedef BCM53324_A0_GTDFRr_t GTDFRr_t;
#define GTDFRr_CLR BCM53324_A0_GTDFRr_CLR
#define GTDFRr_SET BCM53324_A0_GTDFRr_SET
#define GTDFRr_GET BCM53324_A0_GTDFRr_GET
#define READ_GTDFRr BCM53324_A0_READ_GTDFRr
#define WRITE_GTDFRr BCM53324_A0_WRITE_GTDFRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTDFRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTEDF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multiple Deferral Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTEDFr 0x00000025

#define BCM53324_A0_GTEDFr_SIZE 4

/*
 * This structure should be used to declare and program GTEDF.
 *
 */
typedef union BCM53324_A0_GTEDFr_s {
	uint32_t v[1];
	uint32_t gtedf[1];
	uint32_t _gtedf;
} BCM53324_A0_GTEDFr_t;

#define BCM53324_A0_GTEDFr_CLR(r) (r).gtedf[0] = 0
#define BCM53324_A0_GTEDFr_SET(r,d) (r).gtedf[0] = d
#define BCM53324_A0_GTEDFr_GET(r) (r).gtedf[0]


/*
 * These macros can be used to access GTEDF.
 *
 */
#define BCM53324_A0_READ_GTEDFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTEDFr,(r._gtedf))
#define BCM53324_A0_WRITE_GTEDFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTEDFr,&(r._gtedf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTEDFr BCM53324_A0_GTEDFr
#define GTEDFr_SIZE BCM53324_A0_GTEDFr_SIZE
typedef BCM53324_A0_GTEDFr_t GTEDFr_t;
#define GTEDFr_CLR BCM53324_A0_GTEDFr_CLR
#define GTEDFr_SET BCM53324_A0_GTEDFr_SET
#define GTEDFr_GET BCM53324_A0_GTEDFr_GET
#define READ_GTEDFr BCM53324_A0_READ_GTEDFr
#define WRITE_GTEDFr BCM53324_A0_WRITE_GTEDFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTEDFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTFCS
 * BLOCKS:   GPORT0
 * DESC:     Transmit FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTFCSr 0x00000021

#define BCM53324_A0_GTFCSr_SIZE 4

/*
 * This structure should be used to declare and program GTFCS.
 *
 */
typedef union BCM53324_A0_GTFCSr_s {
	uint32_t v[1];
	uint32_t gtfcs[1];
	uint32_t _gtfcs;
} BCM53324_A0_GTFCSr_t;

#define BCM53324_A0_GTFCSr_CLR(r) (r).gtfcs[0] = 0
#define BCM53324_A0_GTFCSr_SET(r,d) (r).gtfcs[0] = d
#define BCM53324_A0_GTFCSr_GET(r) (r).gtfcs[0]


/*
 * These macros can be used to access GTFCS.
 *
 */
#define BCM53324_A0_READ_GTFCSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTFCSr,(r._gtfcs))
#define BCM53324_A0_WRITE_GTFCSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTFCSr,&(r._gtfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTFCSr BCM53324_A0_GTFCSr
#define GTFCSr_SIZE BCM53324_A0_GTFCSr_SIZE
typedef BCM53324_A0_GTFCSr_t GTFCSr_t;
#define GTFCSr_CLR BCM53324_A0_GTFCSr_CLR
#define GTFCSr_SET BCM53324_A0_GTFCSr_SET
#define GTFCSr_GET BCM53324_A0_GTFCSr_GET
#define READ_GTFCSr BCM53324_A0_READ_GTFCSr
#define WRITE_GTFCSr BCM53324_A0_WRITE_GTFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTFRG
 * BLOCKS:   GPORT0
 * DESC:     Transmit Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTFRGr 0x0000002a

#define BCM53324_A0_GTFRGr_SIZE 4

/*
 * This structure should be used to declare and program GTFRG.
 *
 */
typedef union BCM53324_A0_GTFRGr_s {
	uint32_t v[1];
	uint32_t gtfrg[1];
	uint32_t _gtfrg;
} BCM53324_A0_GTFRGr_t;

#define BCM53324_A0_GTFRGr_CLR(r) (r).gtfrg[0] = 0
#define BCM53324_A0_GTFRGr_SET(r,d) (r).gtfrg[0] = d
#define BCM53324_A0_GTFRGr_GET(r) (r).gtfrg[0]


/*
 * These macros can be used to access GTFRG.
 *
 */
#define BCM53324_A0_READ_GTFRGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTFRGr,(r._gtfrg))
#define BCM53324_A0_WRITE_GTFRGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTFRGr,&(r._gtfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTFRGr BCM53324_A0_GTFRGr
#define GTFRGr_SIZE BCM53324_A0_GTFRGr_SIZE
typedef BCM53324_A0_GTFRGr_t GTFRGr_t;
#define GTFRGr_CLR BCM53324_A0_GTFRGr_CLR
#define GTFRGr_SET BCM53324_A0_GTFRGr_SET
#define GTFRGr_GET BCM53324_A0_GTFRGr_GET
#define READ_GTFRGr BCM53324_A0_READ_GTFRGr
#define WRITE_GTFRGr BCM53324_A0_WRITE_GTFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTJBR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Jabber Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTJBRr 0x00000020

#define BCM53324_A0_GTJBRr_SIZE 4

/*
 * This structure should be used to declare and program GTJBR.
 *
 */
typedef union BCM53324_A0_GTJBRr_s {
	uint32_t v[1];
	uint32_t gtjbr[1];
	uint32_t _gtjbr;
} BCM53324_A0_GTJBRr_t;

#define BCM53324_A0_GTJBRr_CLR(r) (r).gtjbr[0] = 0
#define BCM53324_A0_GTJBRr_SET(r,d) (r).gtjbr[0] = d
#define BCM53324_A0_GTJBRr_GET(r) (r).gtjbr[0]


/*
 * These macros can be used to access GTJBR.
 *
 */
#define BCM53324_A0_READ_GTJBRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTJBRr,(r._gtjbr))
#define BCM53324_A0_WRITE_GTJBRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTJBRr,&(r._gtjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTJBRr BCM53324_A0_GTJBRr
#define GTJBRr_SIZE BCM53324_A0_GTJBRr_SIZE
typedef BCM53324_A0_GTJBRr_t GTJBRr_t;
#define GTJBRr_CLR BCM53324_A0_GTJBRr_CLR
#define GTJBRr_SET BCM53324_A0_GTJBRr_SET
#define GTJBRr_GET BCM53324_A0_GTJBRr_GET
#define READ_GTJBRr BCM53324_A0_READ_GTJBRr
#define WRITE_GTJBRr BCM53324_A0_WRITE_GTJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTLCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Late Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTLCLr 0x00000028

#define BCM53324_A0_GTLCLr_SIZE 4

/*
 * This structure should be used to declare and program GTLCL.
 *
 */
typedef union BCM53324_A0_GTLCLr_s {
	uint32_t v[1];
	uint32_t gtlcl[1];
	uint32_t _gtlcl;
} BCM53324_A0_GTLCLr_t;

#define BCM53324_A0_GTLCLr_CLR(r) (r).gtlcl[0] = 0
#define BCM53324_A0_GTLCLr_SET(r,d) (r).gtlcl[0] = d
#define BCM53324_A0_GTLCLr_GET(r) (r).gtlcl[0]


/*
 * These macros can be used to access GTLCL.
 *
 */
#define BCM53324_A0_READ_GTLCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTLCLr,(r._gtlcl))
#define BCM53324_A0_WRITE_GTLCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTLCLr,&(r._gtlcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTLCLr BCM53324_A0_GTLCLr
#define GTLCLr_SIZE BCM53324_A0_GTLCLr_SIZE
typedef BCM53324_A0_GTLCLr_t GTLCLr_t;
#define GTLCLr_CLR BCM53324_A0_GTLCLr_CLR
#define GTLCLr_SET BCM53324_A0_GTLCLr_SET
#define GTLCLr_GET BCM53324_A0_GTLCLr_GET
#define READ_GTLCLr BCM53324_A0_READ_GTLCLr
#define WRITE_GTLCLr BCM53324_A0_WRITE_GTLCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTLCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTMCA
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTMCAr 0x0000002c

#define BCM53324_A0_GTMCAr_SIZE 4

/*
 * This structure should be used to declare and program GTMCA.
 *
 */
typedef union BCM53324_A0_GTMCAr_s {
	uint32_t v[1];
	uint32_t gtmca[1];
	uint32_t _gtmca;
} BCM53324_A0_GTMCAr_t;

#define BCM53324_A0_GTMCAr_CLR(r) (r).gtmca[0] = 0
#define BCM53324_A0_GTMCAr_SET(r,d) (r).gtmca[0] = d
#define BCM53324_A0_GTMCAr_GET(r) (r).gtmca[0]


/*
 * These macros can be used to access GTMCA.
 *
 */
#define BCM53324_A0_READ_GTMCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTMCAr,(r._gtmca))
#define BCM53324_A0_WRITE_GTMCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTMCAr,&(r._gtmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMCAr BCM53324_A0_GTMCAr
#define GTMCAr_SIZE BCM53324_A0_GTMCAr_SIZE
typedef BCM53324_A0_GTMCAr_t GTMCAr_t;
#define GTMCAr_CLR BCM53324_A0_GTMCAr_CLR
#define GTMCAr_SET BCM53324_A0_GTMCAr_SET
#define GTMCAr_GET BCM53324_A0_GTMCAr_GET
#define READ_GTMCAr BCM53324_A0_READ_GTMCAr
#define WRITE_GTMCAr BCM53324_A0_WRITE_GTMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTMCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Multiple Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTMCLr 0x00000027

#define BCM53324_A0_GTMCLr_SIZE 4

/*
 * This structure should be used to declare and program GTMCL.
 *
 */
typedef union BCM53324_A0_GTMCLr_s {
	uint32_t v[1];
	uint32_t gtmcl[1];
	uint32_t _gtmcl;
} BCM53324_A0_GTMCLr_t;

#define BCM53324_A0_GTMCLr_CLR(r) (r).gtmcl[0] = 0
#define BCM53324_A0_GTMCLr_SET(r,d) (r).gtmcl[0] = d
#define BCM53324_A0_GTMCLr_GET(r) (r).gtmcl[0]


/*
 * These macros can be used to access GTMCL.
 *
 */
#define BCM53324_A0_READ_GTMCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTMCLr,(r._gtmcl))
#define BCM53324_A0_WRITE_GTMCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTMCLr,&(r._gtmcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMCLr BCM53324_A0_GTMCLr
#define GTMCLr_SIZE BCM53324_A0_GTMCLr_SIZE
typedef BCM53324_A0_GTMCLr_t GTMCLr_t;
#define GTMCLr_CLR BCM53324_A0_GTMCLr_CLR
#define GTMCLr_SET BCM53324_A0_GTMCLr_SET
#define GTMCLr_GET BCM53324_A0_GTMCLr_GET
#define READ_GTMCLr BCM53324_A0_READ_GTMCLr
#define WRITE_GTMCLr BCM53324_A0_WRITE_GTMCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTMCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTMGV
 * BLOCKS:   GPORT0
 * DESC:     Transmit 1519 to 1522 Byte Good VLAN Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTMGVr 0x00000034

#define BCM53324_A0_GTMGVr_SIZE 4

/*
 * This structure should be used to declare and program GTMGV.
 *
 */
typedef union BCM53324_A0_GTMGVr_s {
	uint32_t v[1];
	uint32_t gtmgv[1];
	uint32_t _gtmgv;
} BCM53324_A0_GTMGVr_t;

#define BCM53324_A0_GTMGVr_CLR(r) (r).gtmgv[0] = 0
#define BCM53324_A0_GTMGVr_SET(r,d) (r).gtmgv[0] = d
#define BCM53324_A0_GTMGVr_GET(r) (r).gtmgv[0]


/*
 * These macros can be used to access GTMGV.
 *
 */
#define BCM53324_A0_READ_GTMGVr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTMGVr,(r._gtmgv))
#define BCM53324_A0_WRITE_GTMGVr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTMGVr,&(r._gtmgv))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMGVr BCM53324_A0_GTMGVr
#define GTMGVr_SIZE BCM53324_A0_GTMGVr_SIZE
typedef BCM53324_A0_GTMGVr_t GTMGVr_t;
#define GTMGVr_CLR BCM53324_A0_GTMGVr_CLR
#define GTMGVr_SET BCM53324_A0_GTMGVr_SET
#define GTMGVr_GET BCM53324_A0_GTMGVr_GET
#define READ_GTMGVr BCM53324_A0_READ_GTMGVr
#define WRITE_GTMGVr BCM53324_A0_WRITE_GTMGVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTMGVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTNCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Total Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTNCLr 0x0000002b

#define BCM53324_A0_GTNCLr_SIZE 4

/*
 * This structure should be used to declare and program GTNCL.
 *
 */
typedef union BCM53324_A0_GTNCLr_s {
	uint32_t v[1];
	uint32_t gtncl[1];
	uint32_t _gtncl;
} BCM53324_A0_GTNCLr_t;

#define BCM53324_A0_GTNCLr_CLR(r) (r).gtncl[0] = 0
#define BCM53324_A0_GTNCLr_SET(r,d) (r).gtncl[0] = d
#define BCM53324_A0_GTNCLr_GET(r) (r).gtncl[0]


/*
 * These macros can be used to access GTNCL.
 *
 */
#define BCM53324_A0_READ_GTNCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTNCLr,(r._gtncl))
#define BCM53324_A0_WRITE_GTNCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTNCLr,&(r._gtncl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTNCLr BCM53324_A0_GTNCLr
#define GTNCLr_SIZE BCM53324_A0_GTNCLr_SIZE
typedef BCM53324_A0_GTNCLr_t GTNCLr_t;
#define GTNCLr_CLR BCM53324_A0_GTNCLr_CLR
#define GTNCLr_SET BCM53324_A0_GTNCLr_SET
#define GTNCLr_GET BCM53324_A0_GTNCLr_GET
#define READ_GTNCLr BCM53324_A0_READ_GTNCLr
#define WRITE_GTNCLr BCM53324_A0_WRITE_GTNCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTNCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTOVR
 * BLOCKS:   GPORT0
 * DESC:     Transmit Oversize Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTOVRr 0x00000023

#define BCM53324_A0_GTOVRr_SIZE 4

/*
 * This structure should be used to declare and program GTOVR.
 *
 */
typedef union BCM53324_A0_GTOVRr_s {
	uint32_t v[1];
	uint32_t gtovr[1];
	uint32_t _gtovr;
} BCM53324_A0_GTOVRr_t;

#define BCM53324_A0_GTOVRr_CLR(r) (r).gtovr[0] = 0
#define BCM53324_A0_GTOVRr_SET(r,d) (r).gtovr[0] = d
#define BCM53324_A0_GTOVRr_GET(r) (r).gtovr[0]


/*
 * These macros can be used to access GTOVR.
 *
 */
#define BCM53324_A0_READ_GTOVRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTOVRr,(r._gtovr))
#define BCM53324_A0_WRITE_GTOVRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTOVRr,&(r._gtovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTOVRr BCM53324_A0_GTOVRr
#define GTOVRr_SIZE BCM53324_A0_GTOVRr_SIZE
typedef BCM53324_A0_GTOVRr_t GTOVRr_t;
#define GTOVRr_CLR BCM53324_A0_GTOVRr_CLR
#define GTOVRr_SET BCM53324_A0_GTOVRr_SET
#define GTOVRr_GET BCM53324_A0_GTOVRr_GET
#define READ_GTOVRr BCM53324_A0_READ_GTOVRr
#define WRITE_GTOVRr BCM53324_A0_WRITE_GTOVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTOVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTPKT
 * BLOCKS:   GPORT0
 * DESC:     Transmit frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTPKTr 0x00000038

#define BCM53324_A0_GTPKTr_SIZE 4

/*
 * This structure should be used to declare and program GTPKT.
 *
 */
typedef union BCM53324_A0_GTPKTr_s {
	uint32_t v[1];
	uint32_t gtpkt[1];
	uint32_t _gtpkt;
} BCM53324_A0_GTPKTr_t;

#define BCM53324_A0_GTPKTr_CLR(r) (r).gtpkt[0] = 0
#define BCM53324_A0_GTPKTr_SET(r,d) (r).gtpkt[0] = d
#define BCM53324_A0_GTPKTr_GET(r) (r).gtpkt[0]


/*
 * These macros can be used to access GTPKT.
 *
 */
#define BCM53324_A0_READ_GTPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTPKTr,(r._gtpkt))
#define BCM53324_A0_WRITE_GTPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTPKTr,&(r._gtpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTPKTr BCM53324_A0_GTPKTr
#define GTPKTr_SIZE BCM53324_A0_GTPKTr_SIZE
typedef BCM53324_A0_GTPKTr_t GTPKTr_t;
#define GTPKTr_CLR BCM53324_A0_GTPKTr_CLR
#define GTPKTr_SET BCM53324_A0_GTPKTr_SET
#define GTPKTr_GET BCM53324_A0_GTPKTr_GET
#define READ_GTPKTr BCM53324_A0_READ_GTPKTr
#define WRITE_GTPKTr BCM53324_A0_WRITE_GTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTPOK
 * BLOCKS:   GPORT0
 * DESC:     Transmitted Packets OK Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTPOKr 0x0000003b

#define BCM53324_A0_GTPOKr_SIZE 4

/*
 * This structure should be used to declare and program GTPOK.
 *
 */
typedef union BCM53324_A0_GTPOKr_s {
	uint32_t v[1];
	uint32_t gtpok[1];
	uint32_t _gtpok;
} BCM53324_A0_GTPOKr_t;

#define BCM53324_A0_GTPOKr_CLR(r) (r).gtpok[0] = 0
#define BCM53324_A0_GTPOKr_SET(r,d) (r).gtpok[0] = d
#define BCM53324_A0_GTPOKr_GET(r) (r).gtpok[0]


/*
 * These macros can be used to access GTPOK.
 *
 */
#define BCM53324_A0_READ_GTPOKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTPOKr,(r._gtpok))
#define BCM53324_A0_WRITE_GTPOKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTPOKr,&(r._gtpok))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTPOKr BCM53324_A0_GTPOKr
#define GTPOKr_SIZE BCM53324_A0_GTPOKr_SIZE
typedef BCM53324_A0_GTPOKr_t GTPOKr_t;
#define GTPOKr_CLR BCM53324_A0_GTPOKr_CLR
#define GTPOKr_SET BCM53324_A0_GTPOKr_SET
#define GTPOKr_GET BCM53324_A0_GTPOKr_GET
#define READ_GTPOKr BCM53324_A0_READ_GTPOKr
#define WRITE_GTPOKr BCM53324_A0_WRITE_GTPOKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTPOKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTSCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Single Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTSCLr 0x00000026

#define BCM53324_A0_GTSCLr_SIZE 4

/*
 * This structure should be used to declare and program GTSCL.
 *
 */
typedef union BCM53324_A0_GTSCLr_s {
	uint32_t v[1];
	uint32_t gtscl[1];
	uint32_t _gtscl;
} BCM53324_A0_GTSCLr_t;

#define BCM53324_A0_GTSCLr_CLR(r) (r).gtscl[0] = 0
#define BCM53324_A0_GTSCLr_SET(r,d) (r).gtscl[0] = d
#define BCM53324_A0_GTSCLr_GET(r) (r).gtscl[0]


/*
 * These macros can be used to access GTSCL.
 *
 */
#define BCM53324_A0_READ_GTSCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTSCLr,(r._gtscl))
#define BCM53324_A0_WRITE_GTSCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTSCLr,&(r._gtscl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTSCLr BCM53324_A0_GTSCLr
#define GTSCLr_SIZE BCM53324_A0_GTSCLr_SIZE
typedef BCM53324_A0_GTSCLr_t GTSCLr_t;
#define GTSCLr_CLR BCM53324_A0_GTSCLr_CLR
#define GTSCLr_SET BCM53324_A0_GTSCLr_SET
#define GTSCLr_GET BCM53324_A0_GTSCLr_GET
#define READ_GTSCLr BCM53324_A0_READ_GTSCLr
#define WRITE_GTSCLr BCM53324_A0_WRITE_GTSCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTSCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTUC
 * BLOCKS:   GPORT0
 * DESC:     Transmit Unicast Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTUCr 0x0000003a

#define BCM53324_A0_GTUCr_SIZE 4

/*
 * This structure should be used to declare and program GTUC.
 *
 */
typedef union BCM53324_A0_GTUCr_s {
	uint32_t v[1];
	uint32_t gtuc[1];
	uint32_t _gtuc;
} BCM53324_A0_GTUCr_t;

#define BCM53324_A0_GTUCr_CLR(r) (r).gtuc[0] = 0
#define BCM53324_A0_GTUCr_SET(r,d) (r).gtuc[0] = d
#define BCM53324_A0_GTUCr_GET(r) (r).gtuc[0]


/*
 * These macros can be used to access GTUC.
 *
 */
#define BCM53324_A0_READ_GTUCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTUCr,(r._gtuc))
#define BCM53324_A0_WRITE_GTUCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTUCr,&(r._gtuc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTUCr BCM53324_A0_GTUCr
#define GTUCr_SIZE BCM53324_A0_GTUCr_SIZE
typedef BCM53324_A0_GTUCr_t GTUCr_t;
#define GTUCr_CLR BCM53324_A0_GTUCr_CLR
#define GTUCr_SET BCM53324_A0_GTUCr_SET
#define GTUCr_GET BCM53324_A0_GTUCr_GET
#define READ_GTUCr BCM53324_A0_READ_GTUCr
#define WRITE_GTUCr BCM53324_A0_WRITE_GTUCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTUCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTXCF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTXCFr 0x00000022

#define BCM53324_A0_GTXCFr_SIZE 4

/*
 * This structure should be used to declare and program GTXCF.
 *
 */
typedef union BCM53324_A0_GTXCFr_s {
	uint32_t v[1];
	uint32_t gtxcf[1];
	uint32_t _gtxcf;
} BCM53324_A0_GTXCFr_t;

#define BCM53324_A0_GTXCFr_CLR(r) (r).gtxcf[0] = 0
#define BCM53324_A0_GTXCFr_SET(r,d) (r).gtxcf[0] = d
#define BCM53324_A0_GTXCFr_GET(r) (r).gtxcf[0]


/*
 * These macros can be used to access GTXCF.
 *
 */
#define BCM53324_A0_READ_GTXCFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTXCFr,(r._gtxcf))
#define BCM53324_A0_WRITE_GTXCFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTXCFr,&(r._gtxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXCFr BCM53324_A0_GTXCFr
#define GTXCFr_SIZE BCM53324_A0_GTXCFr_SIZE
typedef BCM53324_A0_GTXCFr_t GTXCFr_t;
#define GTXCFr_CLR BCM53324_A0_GTXCFr_CLR
#define GTXCFr_SET BCM53324_A0_GTXCFr_SET
#define GTXCFr_GET BCM53324_A0_GTXCFr_GET
#define READ_GTXCFr BCM53324_A0_READ_GTXCFr
#define WRITE_GTXCFr BCM53324_A0_WRITE_GTXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTXCL
 * BLOCKS:   GPORT0
 * DESC:     Transmit Excessive Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTXCLr 0x00000029

#define BCM53324_A0_GTXCLr_SIZE 4

/*
 * This structure should be used to declare and program GTXCL.
 *
 */
typedef union BCM53324_A0_GTXCLr_s {
	uint32_t v[1];
	uint32_t gtxcl[1];
	uint32_t _gtxcl;
} BCM53324_A0_GTXCLr_t;

#define BCM53324_A0_GTXCLr_CLR(r) (r).gtxcl[0] = 0
#define BCM53324_A0_GTXCLr_SET(r,d) (r).gtxcl[0] = d
#define BCM53324_A0_GTXCLr_GET(r) (r).gtxcl[0]


/*
 * These macros can be used to access GTXCL.
 *
 */
#define BCM53324_A0_READ_GTXCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTXCLr,(r._gtxcl))
#define BCM53324_A0_WRITE_GTXCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTXCLr,&(r._gtxcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXCLr BCM53324_A0_GTXCLr
#define GTXCLr_SIZE BCM53324_A0_GTXCLr_SIZE
typedef BCM53324_A0_GTXCLr_t GTXCLr_t;
#define GTXCLr_CLR BCM53324_A0_GTXCLr_CLR
#define GTXCLr_SET BCM53324_A0_GTXCLr_SET
#define GTXCLr_GET BCM53324_A0_GTXCLr_GET
#define READ_GTXCLr BCM53324_A0_READ_GTXCLr
#define WRITE_GTXCLr BCM53324_A0_WRITE_GTXCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTXCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  GTXPF
 * BLOCKS:   GPORT0
 * DESC:     Transmit Pause Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_GTXPFr 0x0000001f

#define BCM53324_A0_GTXPFr_SIZE 4

/*
 * This structure should be used to declare and program GTXPF.
 *
 */
typedef union BCM53324_A0_GTXPFr_s {
	uint32_t v[1];
	uint32_t gtxpf[1];
	uint32_t _gtxpf;
} BCM53324_A0_GTXPFr_t;

#define BCM53324_A0_GTXPFr_CLR(r) (r).gtxpf[0] = 0
#define BCM53324_A0_GTXPFr_SET(r,d) (r).gtxpf[0] = d
#define BCM53324_A0_GTXPFr_GET(r) (r).gtxpf[0]


/*
 * These macros can be used to access GTXPF.
 *
 */
#define BCM53324_A0_READ_GTXPFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_GTXPFr,(r._gtxpf))
#define BCM53324_A0_WRITE_GTXPFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_GTXPFr,&(r._gtxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXPFr BCM53324_A0_GTXPFr
#define GTXPFr_SIZE BCM53324_A0_GTXPFr_SIZE
typedef BCM53324_A0_GTXPFr_t GTXPFr_t;
#define GTXPFr_CLR BCM53324_A0_GTXPFr_CLR
#define GTXPFr_SET BCM53324_A0_GTXPFr_SET
#define GTXPFr_GET BCM53324_A0_GTXPFr_GET
#define READ_GTXPFr BCM53324_A0_READ_GTXPFr
#define WRITE_GTXPFr BCM53324_A0_WRITE_GTXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_GTXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Hash Control Register
 * SIZE:     32
 * FIELDS:
 *     NON_UC_TRUNK_HASH_MOD_PORT_ENABLE Enables factoring modid/port into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_SRC_ENABLE Enables factoring source MAC or source IP into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_DST_ENABLE Enables factoring dest MAC or dest IP into non-unicast trunk block mask hashing
 *     UC_TRUNK_HASH_USE_SRC_PORT Use src port in unicast trunk hash
 *     ECMP_HASH_UDF    ECMP hash offset
 *     ECMP_HASH_USE_DIP Use DIP for ECMP hashing
 *     ECMP_HASH_SEL    Selects ECMP hashing algorithm
 *     L2_AND_VLAN_MAC_HASH_SELECT Selects hashing algorithm used for L2 table lookups
 *     RESERVED0        Reserved bits
 *     ENABLE_DRACO1_5_HASH Enable using Draco 1.5 hashing for unicast trunking
 *     USE_TCP_UDP_PORTS Use TCP/UDP ports for ECMP/unicast trunk hashing
 *     L3_HASH_SELECT   Selects hashing algorithm used for L3 table lookups
 *
 ******************************************************************************/
#define BCM53324_A0_HASH_CONTROLr 0x01780004

#define BCM53324_A0_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program HASH_CONTROL.
 *
 */
typedef union BCM53324_A0_HASH_CONTROLr_s {
	uint32_t v[1];
	uint32_t hash_control[1];
	uint32_t _hash_control;
} BCM53324_A0_HASH_CONTROLr_t;

#define BCM53324_A0_HASH_CONTROLr_CLR(r) (r).hash_control[0] = 0
#define BCM53324_A0_HASH_CONTROLr_SET(r,d) (r).hash_control[0] = d
#define BCM53324_A0_HASH_CONTROLr_GET(r) (r).hash_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET(r) (((r).hash_control[0]) & 0x1)
#define BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET(r) ((((r).hash_control[0]) >> 1) & 0x1)
#define BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET(r) ((((r).hash_control[0]) >> 2) & 0x1)
#define BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET(r) ((((r).hash_control[0]) >> 3) & 0x1)
#define BCM53324_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_HASH_CONTROLr_ECMP_HASH_UDFf_GET(r) ((((r).hash_control[0]) >> 4) & 0xff)
#define BCM53324_A0_HASH_CONTROLr_ECMP_HASH_UDFf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4))
#define BCM53324_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET(r) ((((r).hash_control[0]) >> 12) & 0x1)
#define BCM53324_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_HASH_CONTROLr_ECMP_HASH_SELf_GET(r) ((((r).hash_control[0]) >> 13) & 0x3)
#define BCM53324_A0_HASH_CONTROLr_ECMP_HASH_SELf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53324_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 15) & 0x7)
#define BCM53324_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53324_A0_HASH_CONTROLr_RESERVED0f_GET(r) ((((r).hash_control[0]) >> 18) & 0x7)
#define BCM53324_A0_HASH_CONTROLr_RESERVED0f_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53324_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET(r) ((((r).hash_control[0]) >> 21) & 0x1)
#define BCM53324_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET(r) ((((r).hash_control[0]) >> 22) & 0x1)
#define BCM53324_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_HASH_CONTROLr_L3_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 23) & 0x7)
#define BCM53324_A0_HASH_CONTROLr_L3_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))

/*
 * These macros can be used to access HASH_CONTROL.
 *
 */
#define BCM53324_A0_READ_HASH_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HASH_CONTROLr,(r._hash_control))
#define BCM53324_A0_WRITE_HASH_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HASH_CONTROLr,&(r._hash_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HASH_CONTROLr BCM53324_A0_HASH_CONTROLr
#define HASH_CONTROLr_SIZE BCM53324_A0_HASH_CONTROLr_SIZE
typedef BCM53324_A0_HASH_CONTROLr_t HASH_CONTROLr_t;
#define HASH_CONTROLr_CLR BCM53324_A0_HASH_CONTROLr_CLR
#define HASH_CONTROLr_SET BCM53324_A0_HASH_CONTROLr_SET
#define HASH_CONTROLr_GET BCM53324_A0_HASH_CONTROLr_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET BCM53324_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET BCM53324_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET BCM53324_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET
#define HASH_CONTROLr_ECMP_HASH_UDFf_GET BCM53324_A0_HASH_CONTROLr_ECMP_HASH_UDFf_GET
#define HASH_CONTROLr_ECMP_HASH_UDFf_SET BCM53324_A0_HASH_CONTROLr_ECMP_HASH_UDFf_SET
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET BCM53324_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET BCM53324_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET
#define HASH_CONTROLr_ECMP_HASH_SELf_GET BCM53324_A0_HASH_CONTROLr_ECMP_HASH_SELf_GET
#define HASH_CONTROLr_ECMP_HASH_SELf_SET BCM53324_A0_HASH_CONTROLr_ECMP_HASH_SELf_SET
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET BCM53324_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET BCM53324_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET
#define HASH_CONTROLr_RESERVED0f_GET BCM53324_A0_HASH_CONTROLr_RESERVED0f_GET
#define HASH_CONTROLr_RESERVED0f_SET BCM53324_A0_HASH_CONTROLr_RESERVED0f_SET
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET BCM53324_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET BCM53324_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET BCM53324_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET BCM53324_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET
#define HASH_CONTROLr_L3_HASH_SELECTf_GET BCM53324_A0_HASH_CONTROLr_L3_HASH_SELECTf_GET
#define HASH_CONTROLr_L3_HASH_SELECTf_SET BCM53324_A0_HASH_CONTROLr_L3_HASH_SELECTf_SET
#define READ_HASH_CONTROLr BCM53324_A0_READ_HASH_CONTROLr
#define WRITE_HASH_CONTROLr BCM53324_A0_WRITE_HASH_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HASH_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLCOS0MINXQCNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     HOLCOSMINXQCNT   Hawkeye supports dynamic sharing of a port XQ (descriptor queue) across 4 COSs (2 COS for unmanaged mode) of a port.value in this register is guranted/reserved space for the COSn. This register is required to avoidstarvation. If other COSn have consumed all dynamic XQ space, Traffic should keep flowing for this COS. Value in this register should be programmed more than skid_marker. Default value is programmed to -	* Managed mode (for all priority) - 8 (Decimal)	* Unmanaged mode -		High priority(COS1)  	- 12 (Decimal)		Low priority(COS0)	- 4 (Decimal)		Unused queue (COS3-2)	- 8 (Decimal)Unmanaged mode settings are the default. For managed mode, s/w has to reporgram these registers.
 *
 ******************************************************************************/
#define BCM53324_A0_HOLCOS0MINXQCNTr 0x00600017

#define BCM53324_A0_HOLCOS0MINXQCNTr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOS0MINXQCNT.
 *
 */
typedef union BCM53324_A0_HOLCOS0MINXQCNTr_s {
	uint32_t v[1];
	uint32_t holcos0minxqcnt[1];
	uint32_t _holcos0minxqcnt;
} BCM53324_A0_HOLCOS0MINXQCNTr_t;

#define BCM53324_A0_HOLCOS0MINXQCNTr_CLR(r) (r).holcos0minxqcnt[0] = 0
#define BCM53324_A0_HOLCOS0MINXQCNTr_SET(r,d) (r).holcos0minxqcnt[0] = d
#define BCM53324_A0_HOLCOS0MINXQCNTr_GET(r) (r).holcos0minxqcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLCOS0MINXQCNTr_HOLCOSMINXQCNTf_GET(r) (((r).holcos0minxqcnt[0]) & 0x7ff)
#define BCM53324_A0_HOLCOS0MINXQCNTr_HOLCOSMINXQCNTf_SET(r,f) (r).holcos0minxqcnt[0]=(((r).holcos0minxqcnt[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access HOLCOS0MINXQCNT.
 *
 */
#define BCM53324_A0_READ_HOLCOS0MINXQCNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_HOLCOS0MINXQCNTr,(r._holcos0minxqcnt))
#define BCM53324_A0_WRITE_HOLCOS0MINXQCNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_HOLCOS0MINXQCNTr,&(r._holcos0minxqcnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOS0MINXQCNTr BCM53324_A0_HOLCOS0MINXQCNTr
#define HOLCOS0MINXQCNTr_SIZE BCM53324_A0_HOLCOS0MINXQCNTr_SIZE
typedef BCM53324_A0_HOLCOS0MINXQCNTr_t HOLCOS0MINXQCNTr_t;
#define HOLCOS0MINXQCNTr_CLR BCM53324_A0_HOLCOS0MINXQCNTr_CLR
#define HOLCOS0MINXQCNTr_SET BCM53324_A0_HOLCOS0MINXQCNTr_SET
#define HOLCOS0MINXQCNTr_GET BCM53324_A0_HOLCOS0MINXQCNTr_GET
#define HOLCOS0MINXQCNTr_HOLCOSMINXQCNTf_GET BCM53324_A0_HOLCOS0MINXQCNTr_HOLCOSMINXQCNTf_GET
#define HOLCOS0MINXQCNTr_HOLCOSMINXQCNTf_SET BCM53324_A0_HOLCOS0MINXQCNTr_HOLCOSMINXQCNTf_SET
#define READ_HOLCOS0MINXQCNTr BCM53324_A0_READ_HOLCOS0MINXQCNTr
#define WRITE_HOLCOS0MINXQCNTr BCM53324_A0_WRITE_HOLCOS0MINXQCNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLCOS0MINXQCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLCOS1MINXQCNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     HOLCOSMINXQCNT   Hawkeye supports dynamic sharing of a port XQ (descriptor queue) across 4 COSs (2 COS for unmanaged mode) of a port.value in this register is guranted/reserved space for the COSn. This register is required to avoidstarvation. If other COSn have consumed all dynamic XQ space, Traffic should keep flowing for this COS. Value in this register should be programmed more than skid_marker. Default value is programmed to -	* Managed mode (for all priority) - 8 (Decimal)	* Unmanaged mode -		High priority(COS1)  	- 12 (Decimal)		Low priority(COS0)	- 4 (Decimal)		Unused queue (COS3-2)	- 8 (Decimal)Unmanaged mode settings are the default. For managed mode, s/w has to reporgram these registers.
 *
 ******************************************************************************/
#define BCM53324_A0_HOLCOS1MINXQCNTr 0x00600018

#define BCM53324_A0_HOLCOS1MINXQCNTr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOS1MINXQCNT.
 *
 */
typedef union BCM53324_A0_HOLCOS1MINXQCNTr_s {
	uint32_t v[1];
	uint32_t holcos1minxqcnt[1];
	uint32_t _holcos1minxqcnt;
} BCM53324_A0_HOLCOS1MINXQCNTr_t;

#define BCM53324_A0_HOLCOS1MINXQCNTr_CLR(r) (r).holcos1minxqcnt[0] = 0
#define BCM53324_A0_HOLCOS1MINXQCNTr_SET(r,d) (r).holcos1minxqcnt[0] = d
#define BCM53324_A0_HOLCOS1MINXQCNTr_GET(r) (r).holcos1minxqcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLCOS1MINXQCNTr_HOLCOSMINXQCNTf_GET(r) (((r).holcos1minxqcnt[0]) & 0x7ff)
#define BCM53324_A0_HOLCOS1MINXQCNTr_HOLCOSMINXQCNTf_SET(r,f) (r).holcos1minxqcnt[0]=(((r).holcos1minxqcnt[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access HOLCOS1MINXQCNT.
 *
 */
#define BCM53324_A0_READ_HOLCOS1MINXQCNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_HOLCOS1MINXQCNTr,(r._holcos1minxqcnt))
#define BCM53324_A0_WRITE_HOLCOS1MINXQCNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_HOLCOS1MINXQCNTr,&(r._holcos1minxqcnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOS1MINXQCNTr BCM53324_A0_HOLCOS1MINXQCNTr
#define HOLCOS1MINXQCNTr_SIZE BCM53324_A0_HOLCOS1MINXQCNTr_SIZE
typedef BCM53324_A0_HOLCOS1MINXQCNTr_t HOLCOS1MINXQCNTr_t;
#define HOLCOS1MINXQCNTr_CLR BCM53324_A0_HOLCOS1MINXQCNTr_CLR
#define HOLCOS1MINXQCNTr_SET BCM53324_A0_HOLCOS1MINXQCNTr_SET
#define HOLCOS1MINXQCNTr_GET BCM53324_A0_HOLCOS1MINXQCNTr_GET
#define HOLCOS1MINXQCNTr_HOLCOSMINXQCNTf_GET BCM53324_A0_HOLCOS1MINXQCNTr_HOLCOSMINXQCNTf_GET
#define HOLCOS1MINXQCNTr_HOLCOSMINXQCNTf_SET BCM53324_A0_HOLCOS1MINXQCNTr_HOLCOSMINXQCNTf_SET
#define READ_HOLCOS1MINXQCNTr BCM53324_A0_READ_HOLCOS1MINXQCNTr
#define WRITE_HOLCOS1MINXQCNTr BCM53324_A0_WRITE_HOLCOS1MINXQCNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLCOS1MINXQCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLCOS2MINXQCNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     HOLCOSMINXQCNT   Hawkeye supports dynamic sharing of a port XQ (descriptor queue) across 4 COSs (2 COS for unmanaged mode) of a port.value in this register is guranted/reserved space for the COSn. This register is required to avoidstarvation. If other COSn have consumed all dynamic XQ space, Traffic should keep flowing for this COS. Value in this register should be programmed more than skid_marker. Default value is programmed to -	* Managed mode (for all priority) - 8 (Decimal)	* Unmanaged mode -		High priority(COS1)  	- 12 (Decimal)		Low priority(COS0)	- 4 (Decimal)		Unused queue (COS3-2)	- 8 (Decimal)Unmanaged mode settings are the default. For managed mode, s/w has to reporgram these registers.
 *
 ******************************************************************************/
#define BCM53324_A0_HOLCOS2MINXQCNTr 0x00600019

#define BCM53324_A0_HOLCOS2MINXQCNTr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOS2MINXQCNT.
 *
 */
typedef union BCM53324_A0_HOLCOS2MINXQCNTr_s {
	uint32_t v[1];
	uint32_t holcos2minxqcnt[1];
	uint32_t _holcos2minxqcnt;
} BCM53324_A0_HOLCOS2MINXQCNTr_t;

#define BCM53324_A0_HOLCOS2MINXQCNTr_CLR(r) (r).holcos2minxqcnt[0] = 0
#define BCM53324_A0_HOLCOS2MINXQCNTr_SET(r,d) (r).holcos2minxqcnt[0] = d
#define BCM53324_A0_HOLCOS2MINXQCNTr_GET(r) (r).holcos2minxqcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLCOS2MINXQCNTr_HOLCOSMINXQCNTf_GET(r) (((r).holcos2minxqcnt[0]) & 0x7ff)
#define BCM53324_A0_HOLCOS2MINXQCNTr_HOLCOSMINXQCNTf_SET(r,f) (r).holcos2minxqcnt[0]=(((r).holcos2minxqcnt[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access HOLCOS2MINXQCNT.
 *
 */
#define BCM53324_A0_READ_HOLCOS2MINXQCNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_HOLCOS2MINXQCNTr,(r._holcos2minxqcnt))
#define BCM53324_A0_WRITE_HOLCOS2MINXQCNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_HOLCOS2MINXQCNTr,&(r._holcos2minxqcnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOS2MINXQCNTr BCM53324_A0_HOLCOS2MINXQCNTr
#define HOLCOS2MINXQCNTr_SIZE BCM53324_A0_HOLCOS2MINXQCNTr_SIZE
typedef BCM53324_A0_HOLCOS2MINXQCNTr_t HOLCOS2MINXQCNTr_t;
#define HOLCOS2MINXQCNTr_CLR BCM53324_A0_HOLCOS2MINXQCNTr_CLR
#define HOLCOS2MINXQCNTr_SET BCM53324_A0_HOLCOS2MINXQCNTr_SET
#define HOLCOS2MINXQCNTr_GET BCM53324_A0_HOLCOS2MINXQCNTr_GET
#define HOLCOS2MINXQCNTr_HOLCOSMINXQCNTf_GET BCM53324_A0_HOLCOS2MINXQCNTr_HOLCOSMINXQCNTf_GET
#define HOLCOS2MINXQCNTr_HOLCOSMINXQCNTf_SET BCM53324_A0_HOLCOS2MINXQCNTr_HOLCOSMINXQCNTf_SET
#define READ_HOLCOS2MINXQCNTr BCM53324_A0_READ_HOLCOS2MINXQCNTr
#define WRITE_HOLCOS2MINXQCNTr BCM53324_A0_WRITE_HOLCOS2MINXQCNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLCOS2MINXQCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLCOS3MINXQCNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     HOLCOSMINXQCNT   Hawkeye supports dynamic sharing of a port XQ (descriptor queue) across 4 COSs (2 COS for unmanaged mode) of a port.value in this register is guranted/reserved space for the COSn. This register is required to avoidstarvation. If other COSn have consumed all dynamic XQ space, Traffic should keep flowing for this COS. Value in this register should be programmed more than skid_marker. Default value is programmed to -	* Managed mode (for all priority) - 8 (Decimal)	* Unmanaged mode -		High priority(COS1)  	- 12 (Decimal)		Low priority(COS0)	- 4 (Decimal)		Unused queue (COS3-2)	- 8 (Decimal)Unmanaged mode settings are the default. For managed mode, s/w has to reporgram these registers.
 *
 ******************************************************************************/
#define BCM53324_A0_HOLCOS3MINXQCNTr 0x0060001a

#define BCM53324_A0_HOLCOS3MINXQCNTr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOS3MINXQCNT.
 *
 */
typedef union BCM53324_A0_HOLCOS3MINXQCNTr_s {
	uint32_t v[1];
	uint32_t holcos3minxqcnt[1];
	uint32_t _holcos3minxqcnt;
} BCM53324_A0_HOLCOS3MINXQCNTr_t;

#define BCM53324_A0_HOLCOS3MINXQCNTr_CLR(r) (r).holcos3minxqcnt[0] = 0
#define BCM53324_A0_HOLCOS3MINXQCNTr_SET(r,d) (r).holcos3minxqcnt[0] = d
#define BCM53324_A0_HOLCOS3MINXQCNTr_GET(r) (r).holcos3minxqcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLCOS3MINXQCNTr_HOLCOSMINXQCNTf_GET(r) (((r).holcos3minxqcnt[0]) & 0x7ff)
#define BCM53324_A0_HOLCOS3MINXQCNTr_HOLCOSMINXQCNTf_SET(r,f) (r).holcos3minxqcnt[0]=(((r).holcos3minxqcnt[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access HOLCOS3MINXQCNT.
 *
 */
#define BCM53324_A0_READ_HOLCOS3MINXQCNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_HOLCOS3MINXQCNTr,(r._holcos3minxqcnt))
#define BCM53324_A0_WRITE_HOLCOS3MINXQCNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_HOLCOS3MINXQCNTr,&(r._holcos3minxqcnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOS3MINXQCNTr BCM53324_A0_HOLCOS3MINXQCNTr
#define HOLCOS3MINXQCNTr_SIZE BCM53324_A0_HOLCOS3MINXQCNTr_SIZE
typedef BCM53324_A0_HOLCOS3MINXQCNTr_t HOLCOS3MINXQCNTr_t;
#define HOLCOS3MINXQCNTr_CLR BCM53324_A0_HOLCOS3MINXQCNTr_CLR
#define HOLCOS3MINXQCNTr_SET BCM53324_A0_HOLCOS3MINXQCNTr_SET
#define HOLCOS3MINXQCNTr_GET BCM53324_A0_HOLCOS3MINXQCNTr_GET
#define HOLCOS3MINXQCNTr_HOLCOSMINXQCNTf_GET BCM53324_A0_HOLCOS3MINXQCNTr_HOLCOSMINXQCNTf_GET
#define HOLCOS3MINXQCNTr_HOLCOSMINXQCNTf_SET BCM53324_A0_HOLCOS3MINXQCNTr_HOLCOSMINXQCNTf_SET
#define READ_HOLCOS3MINXQCNTr BCM53324_A0_READ_HOLCOS3MINXQCNTr
#define WRITE_HOLCOS3MINXQCNTr BCM53324_A0_WRITE_HOLCOS3MINXQCNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLCOS3MINXQCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLCOSCELLMAXLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLMAXLIMIT     A queue can be put into HOL drop state when the HOL cell count reaches the value set in this register.
 *     CELLMAXRESUMELIMIT A queue can be brought out of HOL drop state due to reaching the max cell limit, when the HOL cell count goes below the value set in this register.
 *
 ******************************************************************************/
#define BCM53324_A0_HOLCOSCELLMAXLIMITr 0x006000a5

#define BCM53324_A0_HOLCOSCELLMAXLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSCELLMAXLIMIT.
 *
 */
typedef union BCM53324_A0_HOLCOSCELLMAXLIMITr_s {
	uint32_t v[1];
	uint32_t holcoscellmaxlimit[1];
	uint32_t _holcoscellmaxlimit;
} BCM53324_A0_HOLCOSCELLMAXLIMITr_t;

#define BCM53324_A0_HOLCOSCELLMAXLIMITr_CLR(r) (r).holcoscellmaxlimit[0] = 0
#define BCM53324_A0_HOLCOSCELLMAXLIMITr_SET(r,d) (r).holcoscellmaxlimit[0] = d
#define BCM53324_A0_HOLCOSCELLMAXLIMITr_GET(r) (r).holcoscellmaxlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_GET(r) (((r).holcoscellmaxlimit[0]) & 0xfff)
#define BCM53324_A0_HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_SET(r,f) (r).holcoscellmaxlimit[0]=(((r).holcoscellmaxlimit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_GET(r) ((((r).holcoscellmaxlimit[0]) >> 12) & 0xfff)
#define BCM53324_A0_HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_SET(r,f) (r).holcoscellmaxlimit[0]=(((r).holcoscellmaxlimit[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access HOLCOSCELLMAXLIMIT.
 *
 */
#define BCM53324_A0_READ_HOLCOSCELLMAXLIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_HOLCOSCELLMAXLIMITr+(i),(r._holcoscellmaxlimit))
#define BCM53324_A0_WRITE_HOLCOSCELLMAXLIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_HOLCOSCELLMAXLIMITr+(i),&(r._holcoscellmaxlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSCELLMAXLIMITr BCM53324_A0_HOLCOSCELLMAXLIMITr
#define HOLCOSCELLMAXLIMITr_SIZE BCM53324_A0_HOLCOSCELLMAXLIMITr_SIZE
typedef BCM53324_A0_HOLCOSCELLMAXLIMITr_t HOLCOSCELLMAXLIMITr_t;
#define HOLCOSCELLMAXLIMITr_CLR BCM53324_A0_HOLCOSCELLMAXLIMITr_CLR
#define HOLCOSCELLMAXLIMITr_SET BCM53324_A0_HOLCOSCELLMAXLIMITr_SET
#define HOLCOSCELLMAXLIMITr_GET BCM53324_A0_HOLCOSCELLMAXLIMITr_GET
#define HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_GET BCM53324_A0_HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_GET
#define HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_SET BCM53324_A0_HOLCOSCELLMAXLIMITr_CELLMAXLIMITf_SET
#define HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_GET BCM53324_A0_HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_GET
#define HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_SET BCM53324_A0_HOLCOSCELLMAXLIMITr_CELLMAXRESUMELIMITf_SET
#define READ_HOLCOSCELLMAXLIMITr BCM53324_A0_READ_HOLCOSCELLMAXLIMITr
#define WRITE_HOLCOSCELLMAXLIMITr BCM53324_A0_WRITE_HOLCOSCELLMAXLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLCOSCELLMAXLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLCOSPKTRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTRESETLIMIT    HOL for a COSn will be de-activated when packet count for COSn is smallerthan value in this register. Default value is half of packet set limitModifying this register during the traffic is an legal opreation, Reset default is programmed to a value equal to DYNXQCNTPORT + HOLCOSMINXQCNT(high priority) -	* Managed mode - 475 (Decimal) 	* Unmanaged mode - 495 (Decimal)Unmanaged mode settings are the default. For managed mode, s/w has to reporgram these registers.
 *
 ******************************************************************************/
#define BCM53324_A0_HOLCOSPKTRESETLIMITr 0x0060000f

#define BCM53324_A0_HOLCOSPKTRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTRESETLIMIT.
 *
 */
typedef union BCM53324_A0_HOLCOSPKTRESETLIMITr_s {
	uint32_t v[1];
	uint32_t holcospktresetlimit[1];
	uint32_t _holcospktresetlimit;
} BCM53324_A0_HOLCOSPKTRESETLIMITr_t;

#define BCM53324_A0_HOLCOSPKTRESETLIMITr_CLR(r) (r).holcospktresetlimit[0] = 0
#define BCM53324_A0_HOLCOSPKTRESETLIMITr_SET(r,d) (r).holcospktresetlimit[0] = d
#define BCM53324_A0_HOLCOSPKTRESETLIMITr_GET(r) (r).holcospktresetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_GET(r) (((r).holcospktresetlimit[0]) & 0x7ff)
#define BCM53324_A0_HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_SET(r,f) (r).holcospktresetlimit[0]=(((r).holcospktresetlimit[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access HOLCOSPKTRESETLIMIT.
 *
 */
#define BCM53324_A0_READ_HOLCOSPKTRESETLIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_HOLCOSPKTRESETLIMITr+(i),(r._holcospktresetlimit))
#define BCM53324_A0_WRITE_HOLCOSPKTRESETLIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_HOLCOSPKTRESETLIMITr+(i),&(r._holcospktresetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSPKTRESETLIMITr BCM53324_A0_HOLCOSPKTRESETLIMITr
#define HOLCOSPKTRESETLIMITr_SIZE BCM53324_A0_HOLCOSPKTRESETLIMITr_SIZE
typedef BCM53324_A0_HOLCOSPKTRESETLIMITr_t HOLCOSPKTRESETLIMITr_t;
#define HOLCOSPKTRESETLIMITr_CLR BCM53324_A0_HOLCOSPKTRESETLIMITr_CLR
#define HOLCOSPKTRESETLIMITr_SET BCM53324_A0_HOLCOSPKTRESETLIMITr_SET
#define HOLCOSPKTRESETLIMITr_GET BCM53324_A0_HOLCOSPKTRESETLIMITr_GET
#define HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_GET BCM53324_A0_HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_GET
#define HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_SET BCM53324_A0_HOLCOSPKTRESETLIMITr_PKTRESETLIMITf_SET
#define READ_HOLCOSPKTRESETLIMITr BCM53324_A0_READ_HOLCOSPKTRESETLIMITr
#define WRITE_HOLCOSPKTRESETLIMITr BCM53324_A0_WRITE_HOLCOSPKTRESETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLCOSPKTRESETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLCOSPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      HOL Packet high threshold for cos size of egress XQ COS n.The COS n HOL status will be generated when packet count is over this setlimit. there are 2 other conditionto for HOL generation. If this set limit is programed to 0, The correspondingcos will be disabled. Default value is 128.Modifying this register during the traffic is an legal opreation, Reset default is programmed to a value equal to DYNXQCNTPORT + HOLCOSMINXQCNT(high priority) -	* Managed mode - 479 (Decimal) 	* Unmanaged mode - 499 (Decimal)Unmanaged mode settings are the default. For managed mode, s/w has to reporgram these registers.
 *
 ******************************************************************************/
#define BCM53324_A0_HOLCOSPKTSETLIMITr 0x00600007

#define BCM53324_A0_HOLCOSPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSPKTSETLIMIT.
 *
 */
typedef union BCM53324_A0_HOLCOSPKTSETLIMITr_s {
	uint32_t v[1];
	uint32_t holcospktsetlimit[1];
	uint32_t _holcospktsetlimit;
} BCM53324_A0_HOLCOSPKTSETLIMITr_t;

#define BCM53324_A0_HOLCOSPKTSETLIMITr_CLR(r) (r).holcospktsetlimit[0] = 0
#define BCM53324_A0_HOLCOSPKTSETLIMITr_SET(r,d) (r).holcospktsetlimit[0] = d
#define BCM53324_A0_HOLCOSPKTSETLIMITr_GET(r) (r).holcospktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).holcospktsetlimit[0]) & 0x7ff)
#define BCM53324_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).holcospktsetlimit[0]=(((r).holcospktsetlimit[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access HOLCOSPKTSETLIMIT.
 *
 */
#define BCM53324_A0_READ_HOLCOSPKTSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_HOLCOSPKTSETLIMITr+(i),(r._holcospktsetlimit))
#define BCM53324_A0_WRITE_HOLCOSPKTSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_HOLCOSPKTSETLIMITr+(i),&(r._holcospktsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSPKTSETLIMITr BCM53324_A0_HOLCOSPKTSETLIMITr
#define HOLCOSPKTSETLIMITr_SIZE BCM53324_A0_HOLCOSPKTSETLIMITr_SIZE
typedef BCM53324_A0_HOLCOSPKTSETLIMITr_t HOLCOSPKTSETLIMITr_t;
#define HOLCOSPKTSETLIMITr_CLR BCM53324_A0_HOLCOSPKTSETLIMITr_CLR
#define HOLCOSPKTSETLIMITr_SET BCM53324_A0_HOLCOSPKTSETLIMITr_SET
#define HOLCOSPKTSETLIMITr_GET BCM53324_A0_HOLCOSPKTSETLIMITr_GET
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET BCM53324_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_GET
#define HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET BCM53324_A0_HOLCOSPKTSETLIMITr_PKTSETLIMITf_SET
#define READ_HOLCOSPKTSETLIMITr BCM53324_A0_READ_HOLCOSPKTSETLIMITr
#define WRITE_HOLCOSPKTSETLIMITr BCM53324_A0_WRITE_HOLCOSPKTSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLCOSPKTSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLCOSSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current COS n HOL Cell status
 *
 ******************************************************************************/
#define BCM53324_A0_HOLCOSSTATUSr 0x00680005

#define BCM53324_A0_HOLCOSSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program HOLCOSSTATUS.
 *
 */
typedef union BCM53324_A0_HOLCOSSTATUSr_s {
	uint32_t v[1];
	uint32_t holcosstatus[1];
	uint32_t _holcosstatus;
} BCM53324_A0_HOLCOSSTATUSr_t;

#define BCM53324_A0_HOLCOSSTATUSr_CLR(r) (r).holcosstatus[0] = 0
#define BCM53324_A0_HOLCOSSTATUSr_SET(r,d) (r).holcosstatus[0] = d
#define BCM53324_A0_HOLCOSSTATUSr_GET(r) (r).holcosstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLCOSSTATUSr_PORT_BITMAPf_GET(r) (((r).holcosstatus[0]) & 0x1ffffff)
#define BCM53324_A0_HOLCOSSTATUSr_PORT_BITMAPf_SET(r,f) (r).holcosstatus[0]=(((r).holcosstatus[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access HOLCOSSTATUS.
 *
 */
#define BCM53324_A0_READ_HOLCOSSTATUSr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLCOSSTATUSr+(i),(r._holcosstatus))
#define BCM53324_A0_WRITE_HOLCOSSTATUSr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLCOSSTATUSr+(i),&(r._holcosstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLCOSSTATUSr BCM53324_A0_HOLCOSSTATUSr
#define HOLCOSSTATUSr_SIZE BCM53324_A0_HOLCOSSTATUSr_SIZE
typedef BCM53324_A0_HOLCOSSTATUSr_t HOLCOSSTATUSr_t;
#define HOLCOSSTATUSr_CLR BCM53324_A0_HOLCOSSTATUSr_CLR
#define HOLCOSSTATUSr_SET BCM53324_A0_HOLCOSSTATUSr_SET
#define HOLCOSSTATUSr_GET BCM53324_A0_HOLCOSSTATUSr_GET
#define HOLCOSSTATUSr_PORT_BITMAPf_GET BCM53324_A0_HOLCOSSTATUSr_PORT_BITMAPf_GET
#define HOLCOSSTATUSr_PORT_BITMAPf_SET BCM53324_A0_HOLCOSSTATUSr_PORT_BITMAPf_SET
#define READ_HOLCOSSTATUSr BCM53324_A0_READ_HOLCOSSTATUSr
#define WRITE_HOLCOSSTATUSr BCM53324_A0_WRITE_HOLCOSSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLCOSSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD
 * BLOCKS:   IPIPE
 * DESC:     Egress per port HOL Drop Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_HOLDr 0x0f700014

#define BCM53324_A0_HOLDr_SIZE 4

/*
 * This structure should be used to declare and program HOLD.
 *
 */
typedef union BCM53324_A0_HOLDr_s {
	uint32_t v[1];
	uint32_t hold[1];
	uint32_t _hold;
} BCM53324_A0_HOLDr_t;

#define BCM53324_A0_HOLDr_CLR(r) (r).hold[0] = 0
#define BCM53324_A0_HOLDr_SET(r,d) (r).hold[0] = d
#define BCM53324_A0_HOLDr_GET(r) (r).hold[0]


/*
 * These macros can be used to access HOLD.
 *
 */
#define BCM53324_A0_READ_HOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_HOLDr,(r._hold))
#define BCM53324_A0_WRITE_HOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_HOLDr,&(r._hold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLDr BCM53324_A0_HOLDr
#define HOLDr_SIZE BCM53324_A0_HOLDr_SIZE
typedef BCM53324_A0_HOLDr_t HOLDr_t;
#define HOLDr_CLR BCM53324_A0_HOLDr_CLR
#define HOLDr_SET BCM53324_A0_HOLDr_SET
#define HOLDr_GET BCM53324_A0_HOLDr_GET
#define READ_HOLDr BCM53324_A0_READ_HOLDr
#define WRITE_HOLDr BCM53324_A0_WRITE_HOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS0
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS0 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS0r 0x0f780015

#define BCM53324_A0_HOLD_COS0r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS0.
 *
 */
typedef union BCM53324_A0_HOLD_COS0r_s {
	uint32_t v[1];
	uint32_t hold_cos0[1];
	uint32_t _hold_cos0;
} BCM53324_A0_HOLD_COS0r_t;

#define BCM53324_A0_HOLD_COS0r_CLR(r) (r).hold_cos0[0] = 0
#define BCM53324_A0_HOLD_COS0r_SET(r,d) (r).hold_cos0[0] = d
#define BCM53324_A0_HOLD_COS0r_GET(r) (r).hold_cos0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS0r_COUNTf_GET(r) (((r).hold_cos0[0]) & 0x3ffffff)
#define BCM53324_A0_HOLD_COS0r_COUNTf_SET(r,f) (r).hold_cos0[0]=(((r).hold_cos0[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS0.
 *
 */
#define BCM53324_A0_READ_HOLD_COS0r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS0r,(r._hold_cos0))
#define BCM53324_A0_WRITE_HOLD_COS0r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS0r,&(r._hold_cos0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS0r BCM53324_A0_HOLD_COS0r
#define HOLD_COS0r_SIZE BCM53324_A0_HOLD_COS0r_SIZE
typedef BCM53324_A0_HOLD_COS0r_t HOLD_COS0r_t;
#define HOLD_COS0r_CLR BCM53324_A0_HOLD_COS0r_CLR
#define HOLD_COS0r_SET BCM53324_A0_HOLD_COS0r_SET
#define HOLD_COS0r_GET BCM53324_A0_HOLD_COS0r_GET
#define HOLD_COS0r_COUNTf_GET BCM53324_A0_HOLD_COS0r_COUNTf_GET
#define HOLD_COS0r_COUNTf_SET BCM53324_A0_HOLD_COS0r_COUNTf_SET
#define READ_HOLD_COS0r BCM53324_A0_READ_HOLD_COS0r
#define WRITE_HOLD_COS0r BCM53324_A0_WRITE_HOLD_COS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS1
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS1 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS1r 0x0f780016

#define BCM53324_A0_HOLD_COS1r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS1.
 *
 */
typedef union BCM53324_A0_HOLD_COS1r_s {
	uint32_t v[1];
	uint32_t hold_cos1[1];
	uint32_t _hold_cos1;
} BCM53324_A0_HOLD_COS1r_t;

#define BCM53324_A0_HOLD_COS1r_CLR(r) (r).hold_cos1[0] = 0
#define BCM53324_A0_HOLD_COS1r_SET(r,d) (r).hold_cos1[0] = d
#define BCM53324_A0_HOLD_COS1r_GET(r) (r).hold_cos1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS1r_COUNTf_GET(r) (((r).hold_cos1[0]) & 0x3ffffff)
#define BCM53324_A0_HOLD_COS1r_COUNTf_SET(r,f) (r).hold_cos1[0]=(((r).hold_cos1[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS1.
 *
 */
#define BCM53324_A0_READ_HOLD_COS1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS1r,(r._hold_cos1))
#define BCM53324_A0_WRITE_HOLD_COS1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS1r,&(r._hold_cos1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS1r BCM53324_A0_HOLD_COS1r
#define HOLD_COS1r_SIZE BCM53324_A0_HOLD_COS1r_SIZE
typedef BCM53324_A0_HOLD_COS1r_t HOLD_COS1r_t;
#define HOLD_COS1r_CLR BCM53324_A0_HOLD_COS1r_CLR
#define HOLD_COS1r_SET BCM53324_A0_HOLD_COS1r_SET
#define HOLD_COS1r_GET BCM53324_A0_HOLD_COS1r_GET
#define HOLD_COS1r_COUNTf_GET BCM53324_A0_HOLD_COS1r_COUNTf_GET
#define HOLD_COS1r_COUNTf_SET BCM53324_A0_HOLD_COS1r_COUNTf_SET
#define READ_HOLD_COS1r BCM53324_A0_READ_HOLD_COS1r
#define WRITE_HOLD_COS1r BCM53324_A0_WRITE_HOLD_COS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS2
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS2 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS2r 0x0f780017

#define BCM53324_A0_HOLD_COS2r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS2.
 *
 */
typedef union BCM53324_A0_HOLD_COS2r_s {
	uint32_t v[1];
	uint32_t hold_cos2[1];
	uint32_t _hold_cos2;
} BCM53324_A0_HOLD_COS2r_t;

#define BCM53324_A0_HOLD_COS2r_CLR(r) (r).hold_cos2[0] = 0
#define BCM53324_A0_HOLD_COS2r_SET(r,d) (r).hold_cos2[0] = d
#define BCM53324_A0_HOLD_COS2r_GET(r) (r).hold_cos2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS2r_COUNTf_GET(r) (((r).hold_cos2[0]) & 0x3ffffff)
#define BCM53324_A0_HOLD_COS2r_COUNTf_SET(r,f) (r).hold_cos2[0]=(((r).hold_cos2[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS2.
 *
 */
#define BCM53324_A0_READ_HOLD_COS2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS2r,(r._hold_cos2))
#define BCM53324_A0_WRITE_HOLD_COS2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS2r,&(r._hold_cos2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS2r BCM53324_A0_HOLD_COS2r
#define HOLD_COS2r_SIZE BCM53324_A0_HOLD_COS2r_SIZE
typedef BCM53324_A0_HOLD_COS2r_t HOLD_COS2r_t;
#define HOLD_COS2r_CLR BCM53324_A0_HOLD_COS2r_CLR
#define HOLD_COS2r_SET BCM53324_A0_HOLD_COS2r_SET
#define HOLD_COS2r_GET BCM53324_A0_HOLD_COS2r_GET
#define HOLD_COS2r_COUNTf_GET BCM53324_A0_HOLD_COS2r_COUNTf_GET
#define HOLD_COS2r_COUNTf_SET BCM53324_A0_HOLD_COS2r_COUNTf_SET
#define READ_HOLD_COS2r BCM53324_A0_READ_HOLD_COS2r
#define WRITE_HOLD_COS2r BCM53324_A0_WRITE_HOLD_COS2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS3
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS3 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS3r 0x0f780018

#define BCM53324_A0_HOLD_COS3r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS3.
 *
 */
typedef union BCM53324_A0_HOLD_COS3r_s {
	uint32_t v[1];
	uint32_t hold_cos3[1];
	uint32_t _hold_cos3;
} BCM53324_A0_HOLD_COS3r_t;

#define BCM53324_A0_HOLD_COS3r_CLR(r) (r).hold_cos3[0] = 0
#define BCM53324_A0_HOLD_COS3r_SET(r,d) (r).hold_cos3[0] = d
#define BCM53324_A0_HOLD_COS3r_GET(r) (r).hold_cos3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS3r_COUNTf_GET(r) (((r).hold_cos3[0]) & 0x3ffffff)
#define BCM53324_A0_HOLD_COS3r_COUNTf_SET(r,f) (r).hold_cos3[0]=(((r).hold_cos3[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS3.
 *
 */
#define BCM53324_A0_READ_HOLD_COS3r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS3r,(r._hold_cos3))
#define BCM53324_A0_WRITE_HOLD_COS3r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS3r,&(r._hold_cos3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS3r BCM53324_A0_HOLD_COS3r
#define HOLD_COS3r_SIZE BCM53324_A0_HOLD_COS3r_SIZE
typedef BCM53324_A0_HOLD_COS3r_t HOLD_COS3r_t;
#define HOLD_COS3r_CLR BCM53324_A0_HOLD_COS3r_CLR
#define HOLD_COS3r_SET BCM53324_A0_HOLD_COS3r_SET
#define HOLD_COS3r_GET BCM53324_A0_HOLD_COS3r_GET
#define HOLD_COS3r_COUNTf_GET BCM53324_A0_HOLD_COS3r_COUNTf_GET
#define HOLD_COS3r_COUNTf_SET BCM53324_A0_HOLD_COS3r_COUNTf_SET
#define READ_HOLD_COS3r BCM53324_A0_READ_HOLD_COS3r
#define WRITE_HOLD_COS3r BCM53324_A0_WRITE_HOLD_COS3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS4
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS4 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS4r 0x0f780019

#define BCM53324_A0_HOLD_COS4r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS4.
 *
 */
typedef union BCM53324_A0_HOLD_COS4r_s {
	uint32_t v[1];
	uint32_t hold_cos4[1];
	uint32_t _hold_cos4;
} BCM53324_A0_HOLD_COS4r_t;

#define BCM53324_A0_HOLD_COS4r_CLR(r) (r).hold_cos4[0] = 0
#define BCM53324_A0_HOLD_COS4r_SET(r,d) (r).hold_cos4[0] = d
#define BCM53324_A0_HOLD_COS4r_GET(r) (r).hold_cos4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS4r_COUNTf_GET(r) (((r).hold_cos4[0]) & 0x3ffffff)
#define BCM53324_A0_HOLD_COS4r_COUNTf_SET(r,f) (r).hold_cos4[0]=(((r).hold_cos4[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS4.
 *
 */
#define BCM53324_A0_READ_HOLD_COS4r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS4r,(r._hold_cos4))
#define BCM53324_A0_WRITE_HOLD_COS4r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS4r,&(r._hold_cos4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS4r BCM53324_A0_HOLD_COS4r
#define HOLD_COS4r_SIZE BCM53324_A0_HOLD_COS4r_SIZE
typedef BCM53324_A0_HOLD_COS4r_t HOLD_COS4r_t;
#define HOLD_COS4r_CLR BCM53324_A0_HOLD_COS4r_CLR
#define HOLD_COS4r_SET BCM53324_A0_HOLD_COS4r_SET
#define HOLD_COS4r_GET BCM53324_A0_HOLD_COS4r_GET
#define HOLD_COS4r_COUNTf_GET BCM53324_A0_HOLD_COS4r_COUNTf_GET
#define HOLD_COS4r_COUNTf_SET BCM53324_A0_HOLD_COS4r_COUNTf_SET
#define READ_HOLD_COS4r BCM53324_A0_READ_HOLD_COS4r
#define WRITE_HOLD_COS4r BCM53324_A0_WRITE_HOLD_COS4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS5
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS5 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS5r 0x0f78001a

#define BCM53324_A0_HOLD_COS5r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS5.
 *
 */
typedef union BCM53324_A0_HOLD_COS5r_s {
	uint32_t v[1];
	uint32_t hold_cos5[1];
	uint32_t _hold_cos5;
} BCM53324_A0_HOLD_COS5r_t;

#define BCM53324_A0_HOLD_COS5r_CLR(r) (r).hold_cos5[0] = 0
#define BCM53324_A0_HOLD_COS5r_SET(r,d) (r).hold_cos5[0] = d
#define BCM53324_A0_HOLD_COS5r_GET(r) (r).hold_cos5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS5r_COUNTf_GET(r) (((r).hold_cos5[0]) & 0x3ffffff)
#define BCM53324_A0_HOLD_COS5r_COUNTf_SET(r,f) (r).hold_cos5[0]=(((r).hold_cos5[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS5.
 *
 */
#define BCM53324_A0_READ_HOLD_COS5r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS5r,(r._hold_cos5))
#define BCM53324_A0_WRITE_HOLD_COS5r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS5r,&(r._hold_cos5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS5r BCM53324_A0_HOLD_COS5r
#define HOLD_COS5r_SIZE BCM53324_A0_HOLD_COS5r_SIZE
typedef BCM53324_A0_HOLD_COS5r_t HOLD_COS5r_t;
#define HOLD_COS5r_CLR BCM53324_A0_HOLD_COS5r_CLR
#define HOLD_COS5r_SET BCM53324_A0_HOLD_COS5r_SET
#define HOLD_COS5r_GET BCM53324_A0_HOLD_COS5r_GET
#define HOLD_COS5r_COUNTf_GET BCM53324_A0_HOLD_COS5r_COUNTf_GET
#define HOLD_COS5r_COUNTf_SET BCM53324_A0_HOLD_COS5r_COUNTf_SET
#define READ_HOLD_COS5r BCM53324_A0_READ_HOLD_COS5r
#define WRITE_HOLD_COS5r BCM53324_A0_WRITE_HOLD_COS5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS6
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS6 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS6r 0x0f78001b

#define BCM53324_A0_HOLD_COS6r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS6.
 *
 */
typedef union BCM53324_A0_HOLD_COS6r_s {
	uint32_t v[1];
	uint32_t hold_cos6[1];
	uint32_t _hold_cos6;
} BCM53324_A0_HOLD_COS6r_t;

#define BCM53324_A0_HOLD_COS6r_CLR(r) (r).hold_cos6[0] = 0
#define BCM53324_A0_HOLD_COS6r_SET(r,d) (r).hold_cos6[0] = d
#define BCM53324_A0_HOLD_COS6r_GET(r) (r).hold_cos6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS6r_COUNTf_GET(r) (((r).hold_cos6[0]) & 0x3ffffff)
#define BCM53324_A0_HOLD_COS6r_COUNTf_SET(r,f) (r).hold_cos6[0]=(((r).hold_cos6[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS6.
 *
 */
#define BCM53324_A0_READ_HOLD_COS6r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS6r,(r._hold_cos6))
#define BCM53324_A0_WRITE_HOLD_COS6r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS6r,&(r._hold_cos6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS6r BCM53324_A0_HOLD_COS6r
#define HOLD_COS6r_SIZE BCM53324_A0_HOLD_COS6r_SIZE
typedef BCM53324_A0_HOLD_COS6r_t HOLD_COS6r_t;
#define HOLD_COS6r_CLR BCM53324_A0_HOLD_COS6r_CLR
#define HOLD_COS6r_SET BCM53324_A0_HOLD_COS6r_SET
#define HOLD_COS6r_GET BCM53324_A0_HOLD_COS6r_GET
#define HOLD_COS6r_COUNTf_GET BCM53324_A0_HOLD_COS6r_COUNTf_GET
#define HOLD_COS6r_COUNTf_SET BCM53324_A0_HOLD_COS6r_COUNTf_SET
#define READ_HOLD_COS6r BCM53324_A0_READ_HOLD_COS6r
#define WRITE_HOLD_COS6r BCM53324_A0_WRITE_HOLD_COS6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS7
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS7 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS7r 0x0f78001c

#define BCM53324_A0_HOLD_COS7r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS7.
 *
 */
typedef union BCM53324_A0_HOLD_COS7r_s {
	uint32_t v[1];
	uint32_t hold_cos7[1];
	uint32_t _hold_cos7;
} BCM53324_A0_HOLD_COS7r_t;

#define BCM53324_A0_HOLD_COS7r_CLR(r) (r).hold_cos7[0] = 0
#define BCM53324_A0_HOLD_COS7r_SET(r,d) (r).hold_cos7[0] = d
#define BCM53324_A0_HOLD_COS7r_GET(r) (r).hold_cos7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS7r_COUNTf_GET(r) (((r).hold_cos7[0]) & 0x3ffffff)
#define BCM53324_A0_HOLD_COS7r_COUNTf_SET(r,f) (r).hold_cos7[0]=(((r).hold_cos7[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS7.
 *
 */
#define BCM53324_A0_READ_HOLD_COS7r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS7r,(r._hold_cos7))
#define BCM53324_A0_WRITE_HOLD_COS7r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS7r,&(r._hold_cos7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS7r BCM53324_A0_HOLD_COS7r
#define HOLD_COS7r_SIZE BCM53324_A0_HOLD_COS7r_SIZE
typedef BCM53324_A0_HOLD_COS7r_t HOLD_COS7r_t;
#define HOLD_COS7r_CLR BCM53324_A0_HOLD_COS7r_CLR
#define HOLD_COS7r_SET BCM53324_A0_HOLD_COS7r_SET
#define HOLD_COS7r_GET BCM53324_A0_HOLD_COS7r_GET
#define HOLD_COS7r_COUNTf_GET BCM53324_A0_HOLD_COS7r_COUNTf_GET
#define HOLD_COS7r_COUNTf_SET BCM53324_A0_HOLD_COS7r_COUNTf_SET
#define READ_HOLD_COS7r BCM53324_A0_READ_HOLD_COS7r
#define WRITE_HOLD_COS7r BCM53324_A0_WRITE_HOLD_COS7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOLD_COS_PORT_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS Counter Port Select Register
 * SIZE:     32
 * FIELDS:
 *     PORT_NUM         Port number
 *
 ******************************************************************************/
#define BCM53324_A0_HOLD_COS_PORT_SELECTr 0x0f780128

#define BCM53324_A0_HOLD_COS_PORT_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_PORT_SELECT.
 *
 */
typedef union BCM53324_A0_HOLD_COS_PORT_SELECTr_s {
	uint32_t v[1];
	uint32_t hold_cos_port_select[1];
	uint32_t _hold_cos_port_select;
} BCM53324_A0_HOLD_COS_PORT_SELECTr_t;

#define BCM53324_A0_HOLD_COS_PORT_SELECTr_CLR(r) (r).hold_cos_port_select[0] = 0
#define BCM53324_A0_HOLD_COS_PORT_SELECTr_SET(r,d) (r).hold_cos_port_select[0] = d
#define BCM53324_A0_HOLD_COS_PORT_SELECTr_GET(r) (r).hold_cos_port_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_GET(r) (((r).hold_cos_port_select[0]) & 0x3f)
#define BCM53324_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_SET(r,f) (r).hold_cos_port_select[0]=(((r).hold_cos_port_select[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access HOLD_COS_PORT_SELECT.
 *
 */
#define BCM53324_A0_READ_HOLD_COS_PORT_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOLD_COS_PORT_SELECTr,(r._hold_cos_port_select))
#define BCM53324_A0_WRITE_HOLD_COS_PORT_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOLD_COS_PORT_SELECTr,&(r._hold_cos_port_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_PORT_SELECTr BCM53324_A0_HOLD_COS_PORT_SELECTr
#define HOLD_COS_PORT_SELECTr_SIZE BCM53324_A0_HOLD_COS_PORT_SELECTr_SIZE
typedef BCM53324_A0_HOLD_COS_PORT_SELECTr_t HOLD_COS_PORT_SELECTr_t;
#define HOLD_COS_PORT_SELECTr_CLR BCM53324_A0_HOLD_COS_PORT_SELECTr_CLR
#define HOLD_COS_PORT_SELECTr_SET BCM53324_A0_HOLD_COS_PORT_SELECTr_SET
#define HOLD_COS_PORT_SELECTr_GET BCM53324_A0_HOLD_COS_PORT_SELECTr_GET
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_GET BCM53324_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_GET
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_SET BCM53324_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_SET
#define READ_HOLD_COS_PORT_SELECTr BCM53324_A0_READ_HOLD_COS_PORT_SELECTr
#define WRITE_HOLD_COS_PORT_SELECTr BCM53324_A0_WRITE_HOLD_COS_PORT_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOLD_COS_PORT_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  HOL_STAT_BMAP
 * BLOCKS:   IPIPE
 * DESC:     HOL Status Register  Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      HOL status port bitmap 
 *
 ******************************************************************************/
#define BCM53324_A0_HOL_STAT_BMAPr 0x0f780114

#define BCM53324_A0_HOL_STAT_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program HOL_STAT_BMAP.
 *
 */
typedef union BCM53324_A0_HOL_STAT_BMAPr_s {
	uint32_t v[1];
	uint32_t hol_stat_bmap[1];
	uint32_t _hol_stat_bmap;
} BCM53324_A0_HOL_STAT_BMAPr_t;

#define BCM53324_A0_HOL_STAT_BMAPr_CLR(r) (r).hol_stat_bmap[0] = 0
#define BCM53324_A0_HOL_STAT_BMAPr_SET(r,d) (r).hol_stat_bmap[0] = d
#define BCM53324_A0_HOL_STAT_BMAPr_GET(r) (r).hol_stat_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_HOL_STAT_BMAPr_PORT_BITMAPf_GET(r) (((r).hol_stat_bmap[0]) & 0x1ffffff)
#define BCM53324_A0_HOL_STAT_BMAPr_PORT_BITMAPf_SET(r,f) (r).hol_stat_bmap[0]=(((r).hol_stat_bmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access HOL_STAT_BMAP.
 *
 */
#define BCM53324_A0_READ_HOL_STAT_BMAPr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_HOL_STAT_BMAPr+(i),(r._hol_stat_bmap))
#define BCM53324_A0_WRITE_HOL_STAT_BMAPr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_HOL_STAT_BMAPr+(i),&(r._hol_stat_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOL_STAT_BMAPr BCM53324_A0_HOL_STAT_BMAPr
#define HOL_STAT_BMAPr_SIZE BCM53324_A0_HOL_STAT_BMAPr_SIZE
typedef BCM53324_A0_HOL_STAT_BMAPr_t HOL_STAT_BMAPr_t;
#define HOL_STAT_BMAPr_CLR BCM53324_A0_HOL_STAT_BMAPr_CLR
#define HOL_STAT_BMAPr_SET BCM53324_A0_HOL_STAT_BMAPr_SET
#define HOL_STAT_BMAPr_GET BCM53324_A0_HOL_STAT_BMAPr_GET
#define HOL_STAT_BMAPr_PORT_BITMAPf_GET BCM53324_A0_HOL_STAT_BMAPr_PORT_BITMAPf_GET
#define HOL_STAT_BMAPr_PORT_BITMAPf_SET BCM53324_A0_HOL_STAT_BMAPr_PORT_BITMAPf_SET
#define READ_HOL_STAT_BMAPr BCM53324_A0_READ_HOL_STAT_BMAPr
#define WRITE_HOL_STAT_BMAPr BCM53324_A0_WRITE_HOL_STAT_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_HOL_STAT_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IBPBKPSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure warning status
 *
 ******************************************************************************/
#define BCM53324_A0_IBPBKPSTATUSr 0x00680001

#define BCM53324_A0_IBPBKPSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program IBPBKPSTATUS.
 *
 */
typedef union BCM53324_A0_IBPBKPSTATUSr_s {
	uint32_t v[1];
	uint32_t ibpbkpstatus[1];
	uint32_t _ibpbkpstatus;
} BCM53324_A0_IBPBKPSTATUSr_t;

#define BCM53324_A0_IBPBKPSTATUSr_CLR(r) (r).ibpbkpstatus[0] = 0
#define BCM53324_A0_IBPBKPSTATUSr_SET(r,d) (r).ibpbkpstatus[0] = d
#define BCM53324_A0_IBPBKPSTATUSr_GET(r) (r).ibpbkpstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IBPBKPSTATUSr_PORT_BITMAPf_GET(r) (((r).ibpbkpstatus[0]) & 0x1ffffff)
#define BCM53324_A0_IBPBKPSTATUSr_PORT_BITMAPf_SET(r,f) (r).ibpbkpstatus[0]=(((r).ibpbkpstatus[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access IBPBKPSTATUS.
 *
 */
#define BCM53324_A0_READ_IBPBKPSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IBPBKPSTATUSr,(r._ibpbkpstatus))
#define BCM53324_A0_WRITE_IBPBKPSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IBPBKPSTATUSr,&(r._ibpbkpstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPBKPSTATUSr BCM53324_A0_IBPBKPSTATUSr
#define IBPBKPSTATUSr_SIZE BCM53324_A0_IBPBKPSTATUSr_SIZE
typedef BCM53324_A0_IBPBKPSTATUSr_t IBPBKPSTATUSr_t;
#define IBPBKPSTATUSr_CLR BCM53324_A0_IBPBKPSTATUSr_CLR
#define IBPBKPSTATUSr_SET BCM53324_A0_IBPBKPSTATUSr_SET
#define IBPBKPSTATUSr_GET BCM53324_A0_IBPBKPSTATUSr_GET
#define IBPBKPSTATUSr_PORT_BITMAPf_GET BCM53324_A0_IBPBKPSTATUSr_PORT_BITMAPf_GET
#define IBPBKPSTATUSr_PORT_BITMAPf_SET BCM53324_A0_IBPBKPSTATUSr_PORT_BITMAPf_SET
#define READ_IBPBKPSTATUSr BCM53324_A0_READ_IBPBKPSTATUSr
#define WRITE_IBPBKPSTATUSr BCM53324_A0_WRITE_IBPBKPSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IBPBKPSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IBPCELLCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLCOUNT        Ingress cell count for all local ingress ports.Number of cells stored per ingress port in CBP Memory. It is status register.
 *
 ******************************************************************************/
#define BCM53324_A0_IBPCELLCOUNTr 0x00600004

#define BCM53324_A0_IBPCELLCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program IBPCELLCOUNT.
 *
 */
typedef union BCM53324_A0_IBPCELLCOUNTr_s {
	uint32_t v[1];
	uint32_t ibpcellcount[1];
	uint32_t _ibpcellcount;
} BCM53324_A0_IBPCELLCOUNTr_t;

#define BCM53324_A0_IBPCELLCOUNTr_CLR(r) (r).ibpcellcount[0] = 0
#define BCM53324_A0_IBPCELLCOUNTr_SET(r,d) (r).ibpcellcount[0] = d
#define BCM53324_A0_IBPCELLCOUNTr_GET(r) (r).ibpcellcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IBPCELLCOUNTr_CELLCOUNTf_GET(r) (((r).ibpcellcount[0]) & 0xfff)
#define BCM53324_A0_IBPCELLCOUNTr_CELLCOUNTf_SET(r,f) (r).ibpcellcount[0]=(((r).ibpcellcount[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access IBPCELLCOUNT.
 *
 */
#define BCM53324_A0_READ_IBPCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IBPCELLCOUNTr,(r._ibpcellcount))
#define BCM53324_A0_WRITE_IBPCELLCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IBPCELLCOUNTr,&(r._ibpcellcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPCELLCOUNTr BCM53324_A0_IBPCELLCOUNTr
#define IBPCELLCOUNTr_SIZE BCM53324_A0_IBPCELLCOUNTr_SIZE
typedef BCM53324_A0_IBPCELLCOUNTr_t IBPCELLCOUNTr_t;
#define IBPCELLCOUNTr_CLR BCM53324_A0_IBPCELLCOUNTr_CLR
#define IBPCELLCOUNTr_SET BCM53324_A0_IBPCELLCOUNTr_SET
#define IBPCELLCOUNTr_GET BCM53324_A0_IBPCELLCOUNTr_GET
#define IBPCELLCOUNTr_CELLCOUNTf_GET BCM53324_A0_IBPCELLCOUNTr_CELLCOUNTf_GET
#define IBPCELLCOUNTr_CELLCOUNTf_SET BCM53324_A0_IBPCELLCOUNTr_CELLCOUNTf_SET
#define READ_IBPCELLCOUNTr BCM53324_A0_READ_IBPCELLCOUNTr
#define WRITE_IBPCELLCOUNTr BCM53324_A0_WRITE_IBPCELLCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IBPCELLCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IBPCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     Back Pressure cell high threshold for all local ingress ports\' cell counts. Unit is the number of cells per port. Default value is 820 cells. Defaultvalue assumes 3 times oversubscirption on 8K cells. Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU. 
 *     RESETLIMITSEL    IBP Cell Reset Threshold for all local ingress ports.When Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. 2'b00: 75.0% of IBP Cell Set Limit.2'b01: 50.0% of IBP Cell Set Limit.    2'b10: 25.0% of IBP Cell Set Limit.    2'b11: 100% of IBP Cell Set Limit.    Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM53324_A0_IBPCELLSETLIMITr 0x00600002

#define BCM53324_A0_IBPCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPCELLSETLIMIT.
 *
 */
typedef union BCM53324_A0_IBPCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibpcellsetlimit[1];
	uint32_t _ibpcellsetlimit;
} BCM53324_A0_IBPCELLSETLIMITr_t;

#define BCM53324_A0_IBPCELLSETLIMITr_CLR(r) (r).ibpcellsetlimit[0] = 0
#define BCM53324_A0_IBPCELLSETLIMITr_SET(r,d) (r).ibpcellsetlimit[0] = d
#define BCM53324_A0_IBPCELLSETLIMITr_GET(r) (r).ibpcellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IBPCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).ibpcellsetlimit[0]) & 0xfff)
#define BCM53324_A0_IBPCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).ibpcellsetlimit[0]=(((r).ibpcellsetlimit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_IBPCELLSETLIMITr_RESETLIMITSELf_GET(r) ((((r).ibpcellsetlimit[0]) >> 12) & 0x3)
#define BCM53324_A0_IBPCELLSETLIMITr_RESETLIMITSELf_SET(r,f) (r).ibpcellsetlimit[0]=(((r).ibpcellsetlimit[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))

/*
 * These macros can be used to access IBPCELLSETLIMIT.
 *
 */
#define BCM53324_A0_READ_IBPCELLSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IBPCELLSETLIMITr,(r._ibpcellsetlimit))
#define BCM53324_A0_WRITE_IBPCELLSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IBPCELLSETLIMITr,&(r._ibpcellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPCELLSETLIMITr BCM53324_A0_IBPCELLSETLIMITr
#define IBPCELLSETLIMITr_SIZE BCM53324_A0_IBPCELLSETLIMITr_SIZE
typedef BCM53324_A0_IBPCELLSETLIMITr_t IBPCELLSETLIMITr_t;
#define IBPCELLSETLIMITr_CLR BCM53324_A0_IBPCELLSETLIMITr_CLR
#define IBPCELLSETLIMITr_SET BCM53324_A0_IBPCELLSETLIMITr_SET
#define IBPCELLSETLIMITr_GET BCM53324_A0_IBPCELLSETLIMITr_GET
#define IBPCELLSETLIMITr_CELLSETLIMITf_GET BCM53324_A0_IBPCELLSETLIMITr_CELLSETLIMITf_GET
#define IBPCELLSETLIMITr_CELLSETLIMITf_SET BCM53324_A0_IBPCELLSETLIMITr_CELLSETLIMITf_SET
#define IBPCELLSETLIMITr_RESETLIMITSELf_GET BCM53324_A0_IBPCELLSETLIMITr_RESETLIMITSELf_GET
#define IBPCELLSETLIMITr_RESETLIMITSELf_SET BCM53324_A0_IBPCELLSETLIMITr_RESETLIMITSELf_SET
#define READ_IBPCELLSETLIMITr BCM53324_A0_READ_IBPCELLSETLIMITr
#define WRITE_IBPCELLSETLIMITr BCM53324_A0_WRITE_IBPCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IBPCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IBPDISCARDSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DISCARDSETLIMIT  Back Pressure Discard threshold for all local ingress ports cell counts.When an ingress port\'s cell count is above Discard Set Limit, all of incoming packet from this port are discarded. Discard Limit must be set above than IBPCELLSETLIMIT to prevent unexpected behavior. Default value is 25% higher then IBPCELLSETLIMIT. This limit represents an absolute value and is not related to IBPCELLSETLIMIT. Unit is the number of cells per port.
 *
 ******************************************************************************/
#define BCM53324_A0_IBPDISCARDSETLIMITr 0x00600003

#define BCM53324_A0_IBPDISCARDSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPDISCARDSETLIMIT.
 *
 */
typedef union BCM53324_A0_IBPDISCARDSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibpdiscardsetlimit[1];
	uint32_t _ibpdiscardsetlimit;
} BCM53324_A0_IBPDISCARDSETLIMITr_t;

#define BCM53324_A0_IBPDISCARDSETLIMITr_CLR(r) (r).ibpdiscardsetlimit[0] = 0
#define BCM53324_A0_IBPDISCARDSETLIMITr_SET(r,d) (r).ibpdiscardsetlimit[0] = d
#define BCM53324_A0_IBPDISCARDSETLIMITr_GET(r) (r).ibpdiscardsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET(r) (((r).ibpdiscardsetlimit[0]) & 0xfff)
#define BCM53324_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET(r,f) (r).ibpdiscardsetlimit[0]=(((r).ibpdiscardsetlimit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access IBPDISCARDSETLIMIT.
 *
 */
#define BCM53324_A0_READ_IBPDISCARDSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IBPDISCARDSETLIMITr,(r._ibpdiscardsetlimit))
#define BCM53324_A0_WRITE_IBPDISCARDSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IBPDISCARDSETLIMITr,&(r._ibpdiscardsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPDISCARDSETLIMITr BCM53324_A0_IBPDISCARDSETLIMITr
#define IBPDISCARDSETLIMITr_SIZE BCM53324_A0_IBPDISCARDSETLIMITr_SIZE
typedef BCM53324_A0_IBPDISCARDSETLIMITr_t IBPDISCARDSETLIMITr_t;
#define IBPDISCARDSETLIMITr_CLR BCM53324_A0_IBPDISCARDSETLIMITr_CLR
#define IBPDISCARDSETLIMITr_SET BCM53324_A0_IBPDISCARDSETLIMITr_SET
#define IBPDISCARDSETLIMITr_GET BCM53324_A0_IBPDISCARDSETLIMITr_GET
#define IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET BCM53324_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_GET
#define IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET BCM53324_A0_IBPDISCARDSETLIMITr_DISCARDSETLIMITf_SET
#define READ_IBPDISCARDSETLIMITr BCM53324_A0_READ_IBPDISCARDSETLIMITr
#define WRITE_IBPDISCARDSETLIMITr BCM53324_A0_WRITE_IBPDISCARDSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IBPDISCARDSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IBPDISCSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current IBP discard status
 *
 ******************************************************************************/
#define BCM53324_A0_IBPDISCSTATUSr 0x00680003

#define BCM53324_A0_IBPDISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program IBPDISCSTATUS.
 *
 */
typedef union BCM53324_A0_IBPDISCSTATUSr_s {
	uint32_t v[1];
	uint32_t ibpdiscstatus[1];
	uint32_t _ibpdiscstatus;
} BCM53324_A0_IBPDISCSTATUSr_t;

#define BCM53324_A0_IBPDISCSTATUSr_CLR(r) (r).ibpdiscstatus[0] = 0
#define BCM53324_A0_IBPDISCSTATUSr_SET(r,d) (r).ibpdiscstatus[0] = d
#define BCM53324_A0_IBPDISCSTATUSr_GET(r) (r).ibpdiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IBPDISCSTATUSr_PORT_BITMAPf_GET(r) (((r).ibpdiscstatus[0]) & 0x1ffffff)
#define BCM53324_A0_IBPDISCSTATUSr_PORT_BITMAPf_SET(r,f) (r).ibpdiscstatus[0]=(((r).ibpdiscstatus[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access IBPDISCSTATUS.
 *
 */
#define BCM53324_A0_READ_IBPDISCSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IBPDISCSTATUSr,(r._ibpdiscstatus))
#define BCM53324_A0_WRITE_IBPDISCSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IBPDISCSTATUSr,&(r._ibpdiscstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPDISCSTATUSr BCM53324_A0_IBPDISCSTATUSr
#define IBPDISCSTATUSr_SIZE BCM53324_A0_IBPDISCSTATUSr_SIZE
typedef BCM53324_A0_IBPDISCSTATUSr_t IBPDISCSTATUSr_t;
#define IBPDISCSTATUSr_CLR BCM53324_A0_IBPDISCSTATUSr_CLR
#define IBPDISCSTATUSr_SET BCM53324_A0_IBPDISCSTATUSr_SET
#define IBPDISCSTATUSr_GET BCM53324_A0_IBPDISCSTATUSr_GET
#define IBPDISCSTATUSr_PORT_BITMAPf_GET BCM53324_A0_IBPDISCSTATUSr_PORT_BITMAPf_GET
#define IBPDISCSTATUSr_PORT_BITMAPf_SET BCM53324_A0_IBPDISCSTATUSr_PORT_BITMAPf_SET
#define READ_IBPDISCSTATUSr BCM53324_A0_READ_IBPDISCSTATUSr
#define WRITE_IBPDISCSTATUSr BCM53324_A0_WRITE_IBPDISCSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IBPDISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IBPPKTCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTCOUNT         Ingress packet count for all local ingress ports.Number of packets stored per ingress port in XQ memories. It is statusregister.
 *
 ******************************************************************************/
#define BCM53324_A0_IBPPKTCOUNTr 0x00600001

#define BCM53324_A0_IBPPKTCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program IBPPKTCOUNT.
 *
 */
typedef union BCM53324_A0_IBPPKTCOUNTr_s {
	uint32_t v[1];
	uint32_t ibppktcount[1];
	uint32_t _ibppktcount;
} BCM53324_A0_IBPPKTCOUNTr_t;

#define BCM53324_A0_IBPPKTCOUNTr_CLR(r) (r).ibppktcount[0] = 0
#define BCM53324_A0_IBPPKTCOUNTr_SET(r,d) (r).ibppktcount[0] = d
#define BCM53324_A0_IBPPKTCOUNTr_GET(r) (r).ibppktcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IBPPKTCOUNTr_PKTCOUNTf_GET(r) (((r).ibppktcount[0]) & 0xfff)
#define BCM53324_A0_IBPPKTCOUNTr_PKTCOUNTf_SET(r,f) (r).ibppktcount[0]=(((r).ibppktcount[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access IBPPKTCOUNT.
 *
 */
#define BCM53324_A0_READ_IBPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IBPPKTCOUNTr,(r._ibppktcount))
#define BCM53324_A0_WRITE_IBPPKTCOUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IBPPKTCOUNTr,&(r._ibppktcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPPKTCOUNTr BCM53324_A0_IBPPKTCOUNTr
#define IBPPKTCOUNTr_SIZE BCM53324_A0_IBPPKTCOUNTr_SIZE
typedef BCM53324_A0_IBPPKTCOUNTr_t IBPPKTCOUNTr_t;
#define IBPPKTCOUNTr_CLR BCM53324_A0_IBPPKTCOUNTr_CLR
#define IBPPKTCOUNTr_SET BCM53324_A0_IBPPKTCOUNTr_SET
#define IBPPKTCOUNTr_GET BCM53324_A0_IBPPKTCOUNTr_GET
#define IBPPKTCOUNTr_PKTCOUNTf_GET BCM53324_A0_IBPPKTCOUNTr_PKTCOUNTf_GET
#define IBPPKTCOUNTr_PKTCOUNTf_SET BCM53324_A0_IBPPKTCOUNTr_PKTCOUNTf_SET
#define READ_IBPPKTCOUNTr BCM53324_A0_READ_IBPPKTCOUNTr
#define WRITE_IBPPKTCOUNTr BCM53324_A0_WRITE_IBPPKTCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IBPPKTCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IBPPKTSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PKTSETLIMIT      Back Pressure packet high threshold for all local ingress ports packet counts. Unit is the number of packets per port. Default value is 800 packetsModify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU. 
 *     RESETLIMITSEL    IBP Packet Reset Threshold Select opions for all local ingress ports.When Back pressure status is set, packet counts have to fall below Reset Threshold in order to clear BKP status. 2'b00: 75.0% of IBP Packet Set Limit.2'b01: 50.0% of IBP Packet Set Limit.  2'b10: 25.0% of IBP Packet Set Limit.  2'b11: 100% of IBP Packet Set Limit.  Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM53324_A0_IBPPKTSETLIMITr 0x00600000

#define BCM53324_A0_IBPPKTSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program IBPPKTSETLIMIT.
 *
 */
typedef union BCM53324_A0_IBPPKTSETLIMITr_s {
	uint32_t v[1];
	uint32_t ibppktsetlimit[1];
	uint32_t _ibppktsetlimit;
} BCM53324_A0_IBPPKTSETLIMITr_t;

#define BCM53324_A0_IBPPKTSETLIMITr_CLR(r) (r).ibppktsetlimit[0] = 0
#define BCM53324_A0_IBPPKTSETLIMITr_SET(r,d) (r).ibppktsetlimit[0] = d
#define BCM53324_A0_IBPPKTSETLIMITr_GET(r) (r).ibppktsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IBPPKTSETLIMITr_PKTSETLIMITf_GET(r) (((r).ibppktsetlimit[0]) & 0xfff)
#define BCM53324_A0_IBPPKTSETLIMITr_PKTSETLIMITf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_IBPPKTSETLIMITr_RESETLIMITSELf_GET(r) ((((r).ibppktsetlimit[0]) >> 12) & 0x3)
#define BCM53324_A0_IBPPKTSETLIMITr_RESETLIMITSELf_SET(r,f) (r).ibppktsetlimit[0]=(((r).ibppktsetlimit[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))

/*
 * These macros can be used to access IBPPKTSETLIMIT.
 *
 */
#define BCM53324_A0_READ_IBPPKTSETLIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IBPPKTSETLIMITr,(r._ibppktsetlimit))
#define BCM53324_A0_WRITE_IBPPKTSETLIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IBPPKTSETLIMITr,&(r._ibppktsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBPPKTSETLIMITr BCM53324_A0_IBPPKTSETLIMITr
#define IBPPKTSETLIMITr_SIZE BCM53324_A0_IBPPKTSETLIMITr_SIZE
typedef BCM53324_A0_IBPPKTSETLIMITr_t IBPPKTSETLIMITr_t;
#define IBPPKTSETLIMITr_CLR BCM53324_A0_IBPPKTSETLIMITr_CLR
#define IBPPKTSETLIMITr_SET BCM53324_A0_IBPPKTSETLIMITr_SET
#define IBPPKTSETLIMITr_GET BCM53324_A0_IBPPKTSETLIMITr_GET
#define IBPPKTSETLIMITr_PKTSETLIMITf_GET BCM53324_A0_IBPPKTSETLIMITr_PKTSETLIMITf_GET
#define IBPPKTSETLIMITr_PKTSETLIMITf_SET BCM53324_A0_IBPPKTSETLIMITr_PKTSETLIMITf_SET
#define IBPPKTSETLIMITr_RESETLIMITSELf_GET BCM53324_A0_IBPPKTSETLIMITr_RESETLIMITSELf_GET
#define IBPPKTSETLIMITr_RESETLIMITSELf_SET BCM53324_A0_IBPPKTSETLIMITr_RESETLIMITSELf_SET
#define READ_IBPPKTSETLIMITr BCM53324_A0_READ_IBPPKTSETLIMITr
#define WRITE_IBPPKTSETLIMITr BCM53324_A0_WRITE_IBPPKTSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IBPPKTSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IGMP_MLD_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Higig control packet's switching bitmap register
 * SIZE:     32
 * FIELDS:
 *     IPV6_MC_ROUTER_ADV_PKT_TO_CPU Copy Multicast Router Advertisement/Solicitation/Termination packets (ICMP types 151, 152, 153) to CPU if set to 1.
 *     IPV6_MC_ROUTER_ADV_PKT_FWD_ACTION Forwarding of Multicast Router Advertisement/Solicitation/Termination  packets (ICMP types 151, 152, 153) 00 - Forward based on MAC-DA, 01 - Drop the packet, 10 - Flood the packet to the VLAN members, 11 - Reserved.
 *     IPV4_MC_ROUTER_ADV_PKT_TO_CPU Copy Multicast Router Advertisement/Solicitation/Termination packets (ICMP types 151, 152, 153) to CPU if set to 1
 *     IPV4_MC_ROUTER_ADV_PKT_FWD_ACTION Forwarding of Multicast Router Advertisement/Solicitation/Termination  packets (ICMP types 151, 152, 153): 00 - Forward based on MAC-DA, 01 - Drop the packet., 10 - Flood the packet to the VLAN members, 11 - Reserved.
 *     IPV6_RESVD_MC_PKT_TO_CPU Copy IPv6 reserved multicast packets (DIP = ff0X:0:0:0:0:0:0:0) to CPU if set to 1
 *     IPV6_RESVD_MC_PKT_FWD_ACTION Forwarding of IPv6 reserved multicast packets (DIP = ff0X:0:0:0:0:0:0:0) as shown below:,00 - Forward based on MAC-DA, 01 - Drop the packet, 10 - Flood the packet to the VLAN members,11 - Reserved.
 *     IPV4_RESVD_MC_PKT_TO_CPU Copy IPv4 reserved multicast packets (DIP = 224.0.0.X) to CPU if set to 1.
 *     IPV4_RESVD_MC_PKT_FWD_ACTION Forwarding of IPv4 reserved multicast packets (DIP = 224.0.0.X) as shown below:00 - Forward based on MAC-DA, 01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     MLD_QUERY_TO_CPU Copy MLD Queries to the CPU if set to 1.
 *     MLD_QUERY_FWD_ACTION Forwarding of MLD Query messages as shown below:00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     MLD_REP_DONE_TO_CPU Copy MLD Report (v1, v2,)/Done (v1) msgs to the CPU if set to 1.
 *     MLD_REP_DONE_FWD_ACTION Forwarding of MLD Report(v1,v2,)/Done(v1) messages as shown below: 00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     IGMP_UNKNOWN_MSG_TO_CPU Copy the unknown IGMP msg to CPU if set to 1.
 *     IGMP_UNKNOWN_MSG_FWD_ACTION Forwarding of unknown IGMP messages  (messages that are not recognized as Query/Report/Leave messages) as shown below:00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     IGMP_QUERY_TO_CPU Copy IGMP Query to the CPU if set to 1
 *     IGMP_QUERY_FWD_ACTION Forwarding of IGMP Query messages as shown below: ,00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     IGMP_REP_LEAVE_TO_CPU Copy IGMP Report (v1, v2, v3)/Leave (v2) msgs to the CPU if set to 1.
 *     IGMP_REP_LEAVE_FWD_ACTION Forwarding of IGMP Report(v1,v2,v3)/Leave(v2) messages as shown below: ,00 - Forward based on MAC-DA,01 - Drop the packet.,10 - Flood the packet to the VLAN members,11 - Reserved.
 *     PFM_RULE_APPLY   If this bit is set,, the current PFM rule in place is applied if not set it disables PFM rule check- when IGMP/MLD/ReservedMC/MC Router Adv packets are flooded to VLAN 
 *
 ******************************************************************************/
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr 0x0c700009

#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IGMP_MLD_PKT_CONTROL.
 *
 */
typedef union BCM53324_A0_IGMP_MLD_PKT_CONTROLr_s {
	uint32_t v[1];
	uint32_t igmp_mld_pkt_control[1];
	uint32_t _igmp_mld_pkt_control;
} BCM53324_A0_IGMP_MLD_PKT_CONTROLr_t;

#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_CLR(r) (r).igmp_mld_pkt_control[0] = 0
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_SET(r,d) (r).igmp_mld_pkt_control[0] = d
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_GET(r) (r).igmp_mld_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_GET(r) (((r).igmp_mld_pkt_control[0]) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 1) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 3) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 4) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 6) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 7) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 9) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 10) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 12) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 13) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 15) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 16) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 18) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 19) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 21) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 22) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 24) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 25) & 0x3)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_GET(r) ((((r).igmp_mld_pkt_control[0]) >> 27) & 0x1)
#define BCM53324_A0_IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_SET(r,f) (r).igmp_mld_pkt_control[0]=(((r).igmp_mld_pkt_control[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access IGMP_MLD_PKT_CONTROL.
 *
 */
#define BCM53324_A0_READ_IGMP_MLD_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IGMP_MLD_PKT_CONTROLr,(r._igmp_mld_pkt_control))
#define BCM53324_A0_WRITE_IGMP_MLD_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IGMP_MLD_PKT_CONTROLr,&(r._igmp_mld_pkt_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMP_MLD_PKT_CONTROLr BCM53324_A0_IGMP_MLD_PKT_CONTROLr
#define IGMP_MLD_PKT_CONTROLr_SIZE BCM53324_A0_IGMP_MLD_PKT_CONTROLr_SIZE
typedef BCM53324_A0_IGMP_MLD_PKT_CONTROLr_t IGMP_MLD_PKT_CONTROLr_t;
#define IGMP_MLD_PKT_CONTROLr_CLR BCM53324_A0_IGMP_MLD_PKT_CONTROLr_CLR
#define IGMP_MLD_PKT_CONTROLr_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_SET
#define IGMP_MLD_PKT_CONTROLr_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_MC_ROUTER_ADV_PKT_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV6_RESVD_MC_PKT_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IPV4_RESVD_MC_PKT_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_QUERY_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_MLD_REP_DONE_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_UNKNOWN_MSG_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_QUERY_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_TO_CPUf_SET
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_GET
#define IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_IGMP_REP_LEAVE_FWD_ACTIONf_SET
#define IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_GET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_GET
#define IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_SET BCM53324_A0_IGMP_MLD_PKT_CONTROLr_PFM_RULE_APPLYf_SET
#define READ_IGMP_MLD_PKT_CONTROLr BCM53324_A0_READ_IGMP_MLD_PKT_CONTROLr
#define WRITE_IGMP_MLD_PKT_CONTROLr BCM53324_A0_WRITE_IGMP_MLD_PKT_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IGMP_MLD_PKT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IL2LU_TM_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Test Mode bits for L2LU stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_L2_ENTRY      Test Mode bits for L2_ENTRY memory
 *     TM_L2_HIT        Test Mode bits for L2_HIT memory
 *     TM_L2_USER_ENTRY_DATA Test Mode bits for L2_USER_ENTRY_DATA memory
 *     TM_L2_USER_ENTRY Test Mode bits for L2_USER_ENTRY CAM
 *
 ******************************************************************************/
#define BCM53324_A0_IL2LU_TM_REG_1r 0x0678000d

#define BCM53324_A0_IL2LU_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program IL2LU_TM_REG_1.
 *
 */
typedef union BCM53324_A0_IL2LU_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t il2lu_tm_reg_1[1];
	uint32_t _il2lu_tm_reg_1;
} BCM53324_A0_IL2LU_TM_REG_1r_t;

#define BCM53324_A0_IL2LU_TM_REG_1r_CLR(r) (r).il2lu_tm_reg_1[0] = 0
#define BCM53324_A0_IL2LU_TM_REG_1r_SET(r,d) (r).il2lu_tm_reg_1[0] = d
#define BCM53324_A0_IL2LU_TM_REG_1r_GET(r) (r).il2lu_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_ENTRYf_GET(r) (((r).il2lu_tm_reg_1[0]) & 0xff)
#define BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_ENTRYf_SET(r,f) (r).il2lu_tm_reg_1[0]=(((r).il2lu_tm_reg_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_HITf_GET(r) ((((r).il2lu_tm_reg_1[0]) >> 8) & 0xff)
#define BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_HITf_SET(r,f) (r).il2lu_tm_reg_1[0]=(((r).il2lu_tm_reg_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_USER_ENTRY_DATAf_GET(r) ((((r).il2lu_tm_reg_1[0]) >> 16) & 0xf)
#define BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_USER_ENTRY_DATAf_SET(r,f) (r).il2lu_tm_reg_1[0]=(((r).il2lu_tm_reg_1[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_USER_ENTRYf_GET(r) ((((r).il2lu_tm_reg_1[0]) >> 20) & 0x7ff)
#define BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_USER_ENTRYf_SET(r,f) (r).il2lu_tm_reg_1[0]=(((r).il2lu_tm_reg_1[0] & ~((uint32_t)0x7ff << 20)) | ((((uint32_t)f) & 0x7ff) << 20))

/*
 * These macros can be used to access IL2LU_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_IL2LU_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IL2LU_TM_REG_1r,(r._il2lu_tm_reg_1))
#define BCM53324_A0_WRITE_IL2LU_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IL2LU_TM_REG_1r,&(r._il2lu_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IL2LU_TM_REG_1r BCM53324_A0_IL2LU_TM_REG_1r
#define IL2LU_TM_REG_1r_SIZE BCM53324_A0_IL2LU_TM_REG_1r_SIZE
typedef BCM53324_A0_IL2LU_TM_REG_1r_t IL2LU_TM_REG_1r_t;
#define IL2LU_TM_REG_1r_CLR BCM53324_A0_IL2LU_TM_REG_1r_CLR
#define IL2LU_TM_REG_1r_SET BCM53324_A0_IL2LU_TM_REG_1r_SET
#define IL2LU_TM_REG_1r_GET BCM53324_A0_IL2LU_TM_REG_1r_GET
#define IL2LU_TM_REG_1r_TM_L2_ENTRYf_GET BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_ENTRYf_GET
#define IL2LU_TM_REG_1r_TM_L2_ENTRYf_SET BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_ENTRYf_SET
#define IL2LU_TM_REG_1r_TM_L2_HITf_GET BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_HITf_GET
#define IL2LU_TM_REG_1r_TM_L2_HITf_SET BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_HITf_SET
#define IL2LU_TM_REG_1r_TM_L2_USER_ENTRY_DATAf_GET BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_USER_ENTRY_DATAf_GET
#define IL2LU_TM_REG_1r_TM_L2_USER_ENTRY_DATAf_SET BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_USER_ENTRY_DATAf_SET
#define IL2LU_TM_REG_1r_TM_L2_USER_ENTRYf_GET BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_USER_ENTRYf_GET
#define IL2LU_TM_REG_1r_TM_L2_USER_ENTRYf_SET BCM53324_A0_IL2LU_TM_REG_1r_TM_L2_USER_ENTRYf_SET
#define READ_IL2LU_TM_REG_1r BCM53324_A0_READ_IL2LU_TM_REG_1r
#define WRITE_IL2LU_TM_REG_1r BCM53324_A0_WRITE_IL2LU_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IL2LU_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IL2LU_WW_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Weak Write bits for L2LU stage memories
 * SIZE:     32
 * FIELDS:
 *     WW_L2_ENTRY      Weak Write bit for L2_ENTRY memory
 *     WW_L2_HIT        Weak Write bit for L2_HIT memory
 *     WW_L2_USER_ENTRY_DATA Weak Write bit for L2_USER_ENTRY_DATA memory
 *
 ******************************************************************************/
#define BCM53324_A0_IL2LU_WW_REG_1r 0x0678000f

#define BCM53324_A0_IL2LU_WW_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program IL2LU_WW_REG_1.
 *
 */
typedef union BCM53324_A0_IL2LU_WW_REG_1r_s {
	uint32_t v[1];
	uint32_t il2lu_ww_reg_1[1];
	uint32_t _il2lu_ww_reg_1;
} BCM53324_A0_IL2LU_WW_REG_1r_t;

#define BCM53324_A0_IL2LU_WW_REG_1r_CLR(r) (r).il2lu_ww_reg_1[0] = 0
#define BCM53324_A0_IL2LU_WW_REG_1r_SET(r,d) (r).il2lu_ww_reg_1[0] = d
#define BCM53324_A0_IL2LU_WW_REG_1r_GET(r) (r).il2lu_ww_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_ENTRYf_GET(r) (((r).il2lu_ww_reg_1[0]) & 0x1)
#define BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_ENTRYf_SET(r,f) (r).il2lu_ww_reg_1[0]=(((r).il2lu_ww_reg_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_HITf_GET(r) ((((r).il2lu_ww_reg_1[0]) >> 1) & 0x1)
#define BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_HITf_SET(r,f) (r).il2lu_ww_reg_1[0]=(((r).il2lu_ww_reg_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_USER_ENTRY_DATAf_GET(r) ((((r).il2lu_ww_reg_1[0]) >> 2) & 0x1)
#define BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_USER_ENTRY_DATAf_SET(r,f) (r).il2lu_ww_reg_1[0]=(((r).il2lu_ww_reg_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access IL2LU_WW_REG_1.
 *
 */
#define BCM53324_A0_READ_IL2LU_WW_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IL2LU_WW_REG_1r,(r._il2lu_ww_reg_1))
#define BCM53324_A0_WRITE_IL2LU_WW_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IL2LU_WW_REG_1r,&(r._il2lu_ww_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IL2LU_WW_REG_1r BCM53324_A0_IL2LU_WW_REG_1r
#define IL2LU_WW_REG_1r_SIZE BCM53324_A0_IL2LU_WW_REG_1r_SIZE
typedef BCM53324_A0_IL2LU_WW_REG_1r_t IL2LU_WW_REG_1r_t;
#define IL2LU_WW_REG_1r_CLR BCM53324_A0_IL2LU_WW_REG_1r_CLR
#define IL2LU_WW_REG_1r_SET BCM53324_A0_IL2LU_WW_REG_1r_SET
#define IL2LU_WW_REG_1r_GET BCM53324_A0_IL2LU_WW_REG_1r_GET
#define IL2LU_WW_REG_1r_WW_L2_ENTRYf_GET BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_ENTRYf_GET
#define IL2LU_WW_REG_1r_WW_L2_ENTRYf_SET BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_ENTRYf_SET
#define IL2LU_WW_REG_1r_WW_L2_HITf_GET BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_HITf_GET
#define IL2LU_WW_REG_1r_WW_L2_HITf_SET BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_HITf_SET
#define IL2LU_WW_REG_1r_WW_L2_USER_ENTRY_DATAf_GET BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_USER_ENTRY_DATAf_GET
#define IL2LU_WW_REG_1r_WW_L2_USER_ENTRY_DATAf_SET BCM53324_A0_IL2LU_WW_REG_1r_WW_L2_USER_ENTRY_DATAf_SET
#define READ_IL2LU_WW_REG_1r BCM53324_A0_READ_IL2LU_WW_REG_1r
#define WRITE_IL2LU_WW_REG_1r BCM53324_A0_WRITE_IL2LU_WW_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IL2LU_WW_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IL2MC_TM_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Test Mode  and Weak Write bits for L2MC stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_L2MC          Test Mode bits for L2MC memory
 *     WW_L2MC          Weak Write bit for L2MC memory
 *
 ******************************************************************************/
#define BCM53324_A0_IL2MC_TM_REG_1r 0x07780000

#define BCM53324_A0_IL2MC_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program IL2MC_TM_REG_1.
 *
 */
typedef union BCM53324_A0_IL2MC_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t il2mc_tm_reg_1[1];
	uint32_t _il2mc_tm_reg_1;
} BCM53324_A0_IL2MC_TM_REG_1r_t;

#define BCM53324_A0_IL2MC_TM_REG_1r_CLR(r) (r).il2mc_tm_reg_1[0] = 0
#define BCM53324_A0_IL2MC_TM_REG_1r_SET(r,d) (r).il2mc_tm_reg_1[0] = d
#define BCM53324_A0_IL2MC_TM_REG_1r_GET(r) (r).il2mc_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IL2MC_TM_REG_1r_TM_L2MCf_GET(r) (((r).il2mc_tm_reg_1[0]) & 0xf)
#define BCM53324_A0_IL2MC_TM_REG_1r_TM_L2MCf_SET(r,f) (r).il2mc_tm_reg_1[0]=(((r).il2mc_tm_reg_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_IL2MC_TM_REG_1r_WW_L2MCf_GET(r) ((((r).il2mc_tm_reg_1[0]) >> 4) & 0x1)
#define BCM53324_A0_IL2MC_TM_REG_1r_WW_L2MCf_SET(r,f) (r).il2mc_tm_reg_1[0]=(((r).il2mc_tm_reg_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access IL2MC_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_IL2MC_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IL2MC_TM_REG_1r,(r._il2mc_tm_reg_1))
#define BCM53324_A0_WRITE_IL2MC_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IL2MC_TM_REG_1r,&(r._il2mc_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IL2MC_TM_REG_1r BCM53324_A0_IL2MC_TM_REG_1r
#define IL2MC_TM_REG_1r_SIZE BCM53324_A0_IL2MC_TM_REG_1r_SIZE
typedef BCM53324_A0_IL2MC_TM_REG_1r_t IL2MC_TM_REG_1r_t;
#define IL2MC_TM_REG_1r_CLR BCM53324_A0_IL2MC_TM_REG_1r_CLR
#define IL2MC_TM_REG_1r_SET BCM53324_A0_IL2MC_TM_REG_1r_SET
#define IL2MC_TM_REG_1r_GET BCM53324_A0_IL2MC_TM_REG_1r_GET
#define IL2MC_TM_REG_1r_TM_L2MCf_GET BCM53324_A0_IL2MC_TM_REG_1r_TM_L2MCf_GET
#define IL2MC_TM_REG_1r_TM_L2MCf_SET BCM53324_A0_IL2MC_TM_REG_1r_TM_L2MCf_SET
#define IL2MC_TM_REG_1r_WW_L2MCf_GET BCM53324_A0_IL2MC_TM_REG_1r_WW_L2MCf_GET
#define IL2MC_TM_REG_1r_WW_L2MCf_SET BCM53324_A0_IL2MC_TM_REG_1r_WW_L2MCf_SET
#define READ_IL2MC_TM_REG_1r BCM53324_A0_READ_IL2MC_TM_REG_1r
#define WRITE_IL2MC_TM_REG_1r BCM53324_A0_WRITE_IL2MC_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IL2MC_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IMRP4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 routed multicast packets
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_IMRP4r 0x0f700003

#define BCM53324_A0_IMRP4r_SIZE 4

/*
 * This structure should be used to declare and program IMRP4.
 *
 */
typedef union BCM53324_A0_IMRP4r_s {
	uint32_t v[1];
	uint32_t imrp4[1];
	uint32_t _imrp4;
} BCM53324_A0_IMRP4r_t;

#define BCM53324_A0_IMRP4r_CLR(r) (r).imrp4[0] = 0
#define BCM53324_A0_IMRP4r_SET(r,d) (r).imrp4[0] = d
#define BCM53324_A0_IMRP4r_GET(r) (r).imrp4[0]


/*
 * These macros can be used to access IMRP4.
 *
 */
#define BCM53324_A0_READ_IMRP4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IMRP4r,(r._imrp4))
#define BCM53324_A0_WRITE_IMRP4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IMRP4r,&(r._imrp4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMRP4r BCM53324_A0_IMRP4r
#define IMRP4r_SIZE BCM53324_A0_IMRP4r_SIZE
typedef BCM53324_A0_IMRP4r_t IMRP4r_t;
#define IMRP4r_CLR BCM53324_A0_IMRP4r_CLR
#define IMRP4r_SET BCM53324_A0_IMRP4r_SET
#define IMRP4r_GET BCM53324_A0_IMRP4r_GET
#define READ_IMRP4r BCM53324_A0_READ_IMRP4r
#define WRITE_IMRP4r BCM53324_A0_WRITE_IMRP4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IMRP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IMRP6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 routed multicast packets
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_IMRP6r 0x0f700007

#define BCM53324_A0_IMRP6r_SIZE 4

/*
 * This structure should be used to declare and program IMRP6.
 *
 */
typedef union BCM53324_A0_IMRP6r_s {
	uint32_t v[1];
	uint32_t imrp6[1];
	uint32_t _imrp6;
} BCM53324_A0_IMRP6r_t;

#define BCM53324_A0_IMRP6r_CLR(r) (r).imrp6[0] = 0
#define BCM53324_A0_IMRP6r_SET(r,d) (r).imrp6[0] = d
#define BCM53324_A0_IMRP6r_GET(r) (r).imrp6[0]


/*
 * These macros can be used to access IMRP6.
 *
 */
#define BCM53324_A0_READ_IMRP6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IMRP6r,(r._imrp6))
#define BCM53324_A0_WRITE_IMRP6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IMRP6r,&(r._imrp6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMRP6r BCM53324_A0_IMRP6r
#define IMRP6r_SIZE BCM53324_A0_IMRP6r_SIZE
typedef BCM53324_A0_IMRP6r_t IMRP6r_t;
#define IMRP6r_CLR BCM53324_A0_IMRP6r_CLR
#define IMRP6r_SET BCM53324_A0_IMRP6r_SET
#define IMRP6r_GET BCM53324_A0_IMRP6r_GET
#define READ_IMRP6r BCM53324_A0_READ_IMRP6r
#define WRITE_IMRP6r BCM53324_A0_WRITE_IMRP6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IMRP6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  IM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Ingress Mirror to Port Table. Indexed using the MIRROR_CONTROL.IM_MTP_INDEX
 * SIZE:     11
 * FIELDS:
 *     PORT_TGID        Mirror to port port/TGID
 *     MODULE_ID        Mirror to port module ID. Needs to be Zeros
 *
 ******************************************************************************/
#define BCM53324_A0_IM_MTP_INDEXm 0x0f7a0000

#define BCM53324_A0_IM_MTP_INDEXm_MIN 0
#define BCM53324_A0_IM_MTP_INDEXm_MAX 3
#define BCM53324_A0_IM_MTP_INDEXm_CMAX(u) 3
#define BCM53324_A0_IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program IM_MTP_INDEX.
 *
 */
typedef union BCM53324_A0_IM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t im_mtp_index[1];
	uint32_t _im_mtp_index;
} BCM53324_A0_IM_MTP_INDEXm_t;

#define BCM53324_A0_IM_MTP_INDEXm_CLR(r) (r).im_mtp_index[0] = 0
#define BCM53324_A0_IM_MTP_INDEXm_SET(r,d) (r).im_mtp_index[0] = d
#define BCM53324_A0_IM_MTP_INDEXm_GET(r) (r).im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IM_MTP_INDEXm_PORT_TGIDf_GET(r) (((r).im_mtp_index[0]) & 0x7f)
#define BCM53324_A0_IM_MTP_INDEXm_PORT_TGIDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53324_A0_IM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).im_mtp_index[0]) >> 7) & 0xf)
#define BCM53324_A0_IM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))

/*
 * These macros can be used to access IM_MTP_INDEX.
 *
 */
#define BCM53324_A0_READ_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_IM_MTP_INDEXm,i,(m._im_mtp_index),1)
#define BCM53324_A0_WRITE_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_IM_MTP_INDEXm,i,&(m._im_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IM_MTP_INDEXm BCM53324_A0_IM_MTP_INDEXm
#define IM_MTP_INDEXm_MIN BCM53324_A0_IM_MTP_INDEXm_MIN
#define IM_MTP_INDEXm_MAX BCM53324_A0_IM_MTP_INDEXm_MAX
#define IM_MTP_INDEXm_CMAX(u) BCM53324_A0_IM_MTP_INDEXm_CMAX(u)
#define IM_MTP_INDEXm_SIZE BCM53324_A0_IM_MTP_INDEXm_SIZE
typedef BCM53324_A0_IM_MTP_INDEXm_t IM_MTP_INDEXm_t;
#define IM_MTP_INDEXm_CLR BCM53324_A0_IM_MTP_INDEXm_CLR
#define IM_MTP_INDEXm_SET BCM53324_A0_IM_MTP_INDEXm_SET
#define IM_MTP_INDEXm_GET BCM53324_A0_IM_MTP_INDEXm_GET
#define IM_MTP_INDEXm_PORT_TGIDf_GET BCM53324_A0_IM_MTP_INDEXm_PORT_TGIDf_GET
#define IM_MTP_INDEXm_PORT_TGIDf_SET BCM53324_A0_IM_MTP_INDEXm_PORT_TGIDf_SET
#define IM_MTP_INDEXm_MODULE_IDf_GET BCM53324_A0_IM_MTP_INDEXm_MODULE_IDf_GET
#define IM_MTP_INDEXm_MODULE_IDf_SET BCM53324_A0_IM_MTP_INDEXm_MODULE_IDf_SET
#define READ_IM_MTP_INDEXm BCM53324_A0_READ_IM_MTP_INDEXm
#define WRITE_IM_MTP_INDEXm BCM53324_A0_WRITE_IM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Switch configuration register
 * SIZE:     32
 * FIELDS:
 *     DT_MODE          Enables double tagging mode
 *     TRUNKS128        Indicates if 128 trunk groups are supported
 *     L2DH_EN          If set, L2 table will update its HIT bit on dest lookup
 *     L2DST_HIT_ENABLE If set, L2 table will update its HIT bit on dest lookup
 *     L3SH_EN          If set, L3 table will update its HIT bit on src lookup. Only apply to Unicast packets.
 *     L3SRC_HIT_ENABLE If set, L3 table will update its HIT bit on src lookup. Only apply to Unicast packets.
 *     RESERVED3        Reserevd bit
 *     RESERVED2        Reserved bit
 *     SNAP_OTHER_DECODE_ENABLE Decode SNAP packets with non-zero OUI for protocol-based VLAN
 *     STNMOVE_ON_L2SRC_DISC Perform station movement on L2 source discard packets
 *     FB_A0_COMPATIBLE FB-A0 compatible mode. Used for disabling source modid checks for mirror pkts on HiGig when in FB style of mirroring.
 *     STACK_MODE       Stacking Mode.
 *     RESERVED1        Reserved bits
 *     RESERVED0        Reserved bit
 *     APPLY_EGR_MASK_ON_L2 Apply Egress mask for L2 switched packets
 *     APPLY_EGR_MASK_ON_L3 Apply Egress mask for L3 switched packets
 *     IGNORE_HG_HDR_DONOT_LEARN If set, HiGig hdrs DONOT_LEARN bit will be ignored and will be treated as reserved bit.
 *     DISABLE_COPY_TO_CPU_FOR_CPU_PORT If set, This disables copy to cpu(exceptions) if the packet is from CMIC
 *     IGMP_PKTS_UNICAST_IGNORE Unicast pkts with IGMP Payload(i.e., IP Protoocol = 2) will not be treated as IGMP Pkts
 *     MLD_PKTS_UNICAST_IGNORE Unicast pkts with MLD Payload will not be treated as MLD Pkts
 *     MLD_CHECKS_ENABLE If this bit is set, stricter checks for MLD packets are enabled, that is the packet is checked for TTL=1 and SIP is LINK_LOCAL
 *     IPV6_RESERVED_MC_ADDR_MLD_ENABLE If this bit is set a MLD packet which has a IPV6 reserved multicast address is treated as a MLD packet (not as a IPV6 reserved MC  packet)
 *     IPV4_RESERVED_MC_ADDR_IGMP_ENABLE If this bit is set a IGMP packet which has a IPV4 reserved multicast address is treated as a IGMP packet(not as a IPV4 reserved MC packet)
 *     BLOCKED_PORTS_FP_DISABLE If the ingress port's spanning tree state is in Disable state then FP is disabled, when this control is set to a 1.
 *     IPV4_MC_MACDA_CHECK_ENABLE When enabled, check MACDA and IPV4 DIP address match for IPv4 multicast packets
 *     IPV6_MC_MACDA_CHECK_ENABLE When enabled, check MACDA and IPV6 DIP address match for IPv6 multicast packets
 *
 ******************************************************************************/
#define BCM53324_A0_ING_CONFIGr 0x01780000

#define BCM53324_A0_ING_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_CONFIG.
 *
 */
typedef union BCM53324_A0_ING_CONFIGr_s {
	uint32_t v[1];
	uint32_t ing_config[1];
	uint32_t _ing_config;
} BCM53324_A0_ING_CONFIGr_t;

#define BCM53324_A0_ING_CONFIGr_CLR(r) (r).ing_config[0] = 0
#define BCM53324_A0_ING_CONFIGr_SET(r,d) (r).ing_config[0] = d
#define BCM53324_A0_ING_CONFIGr_GET(r) (r).ing_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_CONFIGr_DT_MODEf_GET(r) (((r).ing_config[0]) & 0x1)
#define BCM53324_A0_ING_CONFIGr_DT_MODEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_ING_CONFIGr_TRUNKS128f_GET(r) ((((r).ing_config[0]) >> 1) & 0x1)
#define BCM53324_A0_ING_CONFIGr_TRUNKS128f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_ING_CONFIGr_L2DH_ENf_GET(r) ((((r).ing_config[0]) >> 2) & 0x1)
#define BCM53324_A0_ING_CONFIGr_L2DH_ENf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_GET(r) ((((r).ing_config[0]) >> 2) & 0x1)
#define BCM53324_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_ING_CONFIGr_L3SH_ENf_GET(r) ((((r).ing_config[0]) >> 3) & 0x1)
#define BCM53324_A0_ING_CONFIGr_L3SH_ENf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_GET(r) ((((r).ing_config[0]) >> 3) & 0x1)
#define BCM53324_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_ING_CONFIGr_RESERVED3f_GET(r) ((((r).ing_config[0]) >> 4) & 0x1)
#define BCM53324_A0_ING_CONFIGr_RESERVED3f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_ING_CONFIGr_RESERVED2f_GET(r) ((((r).ing_config[0]) >> 5) & 0x1)
#define BCM53324_A0_ING_CONFIGr_RESERVED2f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET(r) ((((r).ing_config[0]) >> 6) & 0x1)
#define BCM53324_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET(r) ((((r).ing_config[0]) >> 7) & 0x1)
#define BCM53324_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_GET(r) ((((r).ing_config[0]) >> 8) & 0x1)
#define BCM53324_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_ING_CONFIGr_STACK_MODEf_GET(r) ((((r).ing_config[0]) >> 9) & 0x3)
#define BCM53324_A0_ING_CONFIGr_STACK_MODEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53324_A0_ING_CONFIGr_RESERVED1f_GET(r) ((((r).ing_config[0]) >> 11) & 0x3)
#define BCM53324_A0_ING_CONFIGr_RESERVED1f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53324_A0_ING_CONFIGr_RESERVED0f_GET(r) ((((r).ing_config[0]) >> 13) & 0x1)
#define BCM53324_A0_ING_CONFIGr_RESERVED0f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET(r) ((((r).ing_config[0]) >> 14) & 0x1)
#define BCM53324_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET(r) ((((r).ing_config[0]) >> 15) & 0x1)
#define BCM53324_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET(r) ((((r).ing_config[0]) >> 16) & 0x1)
#define BCM53324_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_GET(r) ((((r).ing_config[0]) >> 17) & 0x1)
#define BCM53324_A0_ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_GET(r) ((((r).ing_config[0]) >> 18) & 0x1)
#define BCM53324_A0_ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_GET(r) ((((r).ing_config[0]) >> 19) & 0x1)
#define BCM53324_A0_ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_ING_CONFIGr_MLD_CHECKS_ENABLEf_GET(r) ((((r).ing_config[0]) >> 20) & 0x1)
#define BCM53324_A0_ING_CONFIGr_MLD_CHECKS_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_GET(r) ((((r).ing_config[0]) >> 21) & 0x1)
#define BCM53324_A0_ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_GET(r) ((((r).ing_config[0]) >> 22) & 0x1)
#define BCM53324_A0_ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_ING_CONFIGr_BLOCKED_PORTS_FP_DISABLEf_GET(r) ((((r).ing_config[0]) >> 23) & 0x1)
#define BCM53324_A0_ING_CONFIGr_BLOCKED_PORTS_FP_DISABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_ING_CONFIGr_IPV4_MC_MACDA_CHECK_ENABLEf_GET(r) ((((r).ing_config[0]) >> 24) & 0x1)
#define BCM53324_A0_ING_CONFIGr_IPV4_MC_MACDA_CHECK_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_ING_CONFIGr_IPV6_MC_MACDA_CHECK_ENABLEf_GET(r) ((((r).ing_config[0]) >> 25) & 0x1)
#define BCM53324_A0_ING_CONFIGr_IPV6_MC_MACDA_CHECK_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access ING_CONFIG.
 *
 */
#define BCM53324_A0_READ_ING_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_CONFIGr,(r._ing_config))
#define BCM53324_A0_WRITE_ING_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_CONFIGr,&(r._ing_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_CONFIGr BCM53324_A0_ING_CONFIGr
#define ING_CONFIGr_SIZE BCM53324_A0_ING_CONFIGr_SIZE
typedef BCM53324_A0_ING_CONFIGr_t ING_CONFIGr_t;
#define ING_CONFIGr_CLR BCM53324_A0_ING_CONFIGr_CLR
#define ING_CONFIGr_SET BCM53324_A0_ING_CONFIGr_SET
#define ING_CONFIGr_GET BCM53324_A0_ING_CONFIGr_GET
#define ING_CONFIGr_DT_MODEf_GET BCM53324_A0_ING_CONFIGr_DT_MODEf_GET
#define ING_CONFIGr_DT_MODEf_SET BCM53324_A0_ING_CONFIGr_DT_MODEf_SET
#define ING_CONFIGr_TRUNKS128f_GET BCM53324_A0_ING_CONFIGr_TRUNKS128f_GET
#define ING_CONFIGr_TRUNKS128f_SET BCM53324_A0_ING_CONFIGr_TRUNKS128f_SET
#define ING_CONFIGr_L2DH_ENf_GET BCM53324_A0_ING_CONFIGr_L2DH_ENf_GET
#define ING_CONFIGr_L2DH_ENf_SET BCM53324_A0_ING_CONFIGr_L2DH_ENf_SET
#define ING_CONFIGr_L2DST_HIT_ENABLEf_GET BCM53324_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_GET
#define ING_CONFIGr_L2DST_HIT_ENABLEf_SET BCM53324_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_SET
#define ING_CONFIGr_L3SH_ENf_GET BCM53324_A0_ING_CONFIGr_L3SH_ENf_GET
#define ING_CONFIGr_L3SH_ENf_SET BCM53324_A0_ING_CONFIGr_L3SH_ENf_SET
#define ING_CONFIGr_L3SRC_HIT_ENABLEf_GET BCM53324_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_GET
#define ING_CONFIGr_L3SRC_HIT_ENABLEf_SET BCM53324_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_SET
#define ING_CONFIGr_RESERVED3f_GET BCM53324_A0_ING_CONFIGr_RESERVED3f_GET
#define ING_CONFIGr_RESERVED3f_SET BCM53324_A0_ING_CONFIGr_RESERVED3f_SET
#define ING_CONFIGr_RESERVED2f_GET BCM53324_A0_ING_CONFIGr_RESERVED2f_GET
#define ING_CONFIGr_RESERVED2f_SET BCM53324_A0_ING_CONFIGr_RESERVED2f_SET
#define ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET BCM53324_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET
#define ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET BCM53324_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET
#define ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET BCM53324_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET
#define ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET BCM53324_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET
#define ING_CONFIGr_FB_A0_COMPATIBLEf_GET BCM53324_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_GET
#define ING_CONFIGr_FB_A0_COMPATIBLEf_SET BCM53324_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_SET
#define ING_CONFIGr_STACK_MODEf_GET BCM53324_A0_ING_CONFIGr_STACK_MODEf_GET
#define ING_CONFIGr_STACK_MODEf_SET BCM53324_A0_ING_CONFIGr_STACK_MODEf_SET
#define ING_CONFIGr_RESERVED1f_GET BCM53324_A0_ING_CONFIGr_RESERVED1f_GET
#define ING_CONFIGr_RESERVED1f_SET BCM53324_A0_ING_CONFIGr_RESERVED1f_SET
#define ING_CONFIGr_RESERVED0f_GET BCM53324_A0_ING_CONFIGr_RESERVED0f_GET
#define ING_CONFIGr_RESERVED0f_SET BCM53324_A0_ING_CONFIGr_RESERVED0f_SET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET BCM53324_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET BCM53324_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET BCM53324_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET BCM53324_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET
#define ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET BCM53324_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET
#define ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET BCM53324_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET
#define ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_GET BCM53324_A0_ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_GET
#define ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_SET BCM53324_A0_ING_CONFIGr_DISABLE_COPY_TO_CPU_FOR_CPU_PORTf_SET
#define ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_GET BCM53324_A0_ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_GET
#define ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_SET BCM53324_A0_ING_CONFIGr_IGMP_PKTS_UNICAST_IGNOREf_SET
#define ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_GET BCM53324_A0_ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_GET
#define ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_SET BCM53324_A0_ING_CONFIGr_MLD_PKTS_UNICAST_IGNOREf_SET
#define ING_CONFIGr_MLD_CHECKS_ENABLEf_GET BCM53324_A0_ING_CONFIGr_MLD_CHECKS_ENABLEf_GET
#define ING_CONFIGr_MLD_CHECKS_ENABLEf_SET BCM53324_A0_ING_CONFIGr_MLD_CHECKS_ENABLEf_SET
#define ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_GET BCM53324_A0_ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_GET
#define ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_SET BCM53324_A0_ING_CONFIGr_IPV6_RESERVED_MC_ADDR_MLD_ENABLEf_SET
#define ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_GET BCM53324_A0_ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_GET
#define ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_SET BCM53324_A0_ING_CONFIGr_IPV4_RESERVED_MC_ADDR_IGMP_ENABLEf_SET
#define ING_CONFIGr_BLOCKED_PORTS_FP_DISABLEf_GET BCM53324_A0_ING_CONFIGr_BLOCKED_PORTS_FP_DISABLEf_GET
#define ING_CONFIGr_BLOCKED_PORTS_FP_DISABLEf_SET BCM53324_A0_ING_CONFIGr_BLOCKED_PORTS_FP_DISABLEf_SET
#define ING_CONFIGr_IPV4_MC_MACDA_CHECK_ENABLEf_GET BCM53324_A0_ING_CONFIGr_IPV4_MC_MACDA_CHECK_ENABLEf_GET
#define ING_CONFIGr_IPV4_MC_MACDA_CHECK_ENABLEf_SET BCM53324_A0_ING_CONFIGr_IPV4_MC_MACDA_CHECK_ENABLEf_SET
#define ING_CONFIGr_IPV6_MC_MACDA_CHECK_ENABLEf_GET BCM53324_A0_ING_CONFIGr_IPV6_MC_MACDA_CHECK_ENABLEf_GET
#define ING_CONFIGr_IPV6_MC_MACDA_CHECK_ENABLEf_SET BCM53324_A0_ING_CONFIGr_IPV6_MC_MACDA_CHECK_ENABLEf_SET
#define READ_ING_CONFIGr BCM53324_A0_READ_ING_CONFIGr
#define WRITE_ING_CONFIGr BCM53324_A0_WRITE_ING_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_EAV_CLASS
 * BLOCKS:   IPIPE
 * DESC:     Ingress EAV Class
 * SIZE:     32
 * FIELDS:
 *     CLASS_A          Ingress EAV Class A
 *     CLASS_B          Ingress EAV Class B
 *
 ******************************************************************************/
#define BCM53324_A0_ING_EAV_CLASSr 0x0f78013b

#define BCM53324_A0_ING_EAV_CLASSr_SIZE 4

/*
 * This structure should be used to declare and program ING_EAV_CLASS.
 *
 */
typedef union BCM53324_A0_ING_EAV_CLASSr_s {
	uint32_t v[1];
	uint32_t ing_eav_class[1];
	uint32_t _ing_eav_class;
} BCM53324_A0_ING_EAV_CLASSr_t;

#define BCM53324_A0_ING_EAV_CLASSr_CLR(r) (r).ing_eav_class[0] = 0
#define BCM53324_A0_ING_EAV_CLASSr_SET(r,d) (r).ing_eav_class[0] = d
#define BCM53324_A0_ING_EAV_CLASSr_GET(r) (r).ing_eav_class[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_EAV_CLASSr_CLASS_Af_GET(r) (((r).ing_eav_class[0]) & 0x7)
#define BCM53324_A0_ING_EAV_CLASSr_CLASS_Af_SET(r,f) (r).ing_eav_class[0]=(((r).ing_eav_class[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_ING_EAV_CLASSr_CLASS_Bf_GET(r) ((((r).ing_eav_class[0]) >> 3) & 0x7)
#define BCM53324_A0_ING_EAV_CLASSr_CLASS_Bf_SET(r,f) (r).ing_eav_class[0]=(((r).ing_eav_class[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))

/*
 * These macros can be used to access ING_EAV_CLASS.
 *
 */
#define BCM53324_A0_READ_ING_EAV_CLASSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_EAV_CLASSr,(r._ing_eav_class))
#define BCM53324_A0_WRITE_ING_EAV_CLASSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_EAV_CLASSr,&(r._ing_eav_class))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EAV_CLASSr BCM53324_A0_ING_EAV_CLASSr
#define ING_EAV_CLASSr_SIZE BCM53324_A0_ING_EAV_CLASSr_SIZE
typedef BCM53324_A0_ING_EAV_CLASSr_t ING_EAV_CLASSr_t;
#define ING_EAV_CLASSr_CLR BCM53324_A0_ING_EAV_CLASSr_CLR
#define ING_EAV_CLASSr_SET BCM53324_A0_ING_EAV_CLASSr_SET
#define ING_EAV_CLASSr_GET BCM53324_A0_ING_EAV_CLASSr_GET
#define ING_EAV_CLASSr_CLASS_Af_GET BCM53324_A0_ING_EAV_CLASSr_CLASS_Af_GET
#define ING_EAV_CLASSr_CLASS_Af_SET BCM53324_A0_ING_EAV_CLASSr_CLASS_Af_SET
#define ING_EAV_CLASSr_CLASS_Bf_GET BCM53324_A0_ING_EAV_CLASSr_CLASS_Bf_GET
#define ING_EAV_CLASSr_CLASS_Bf_SET BCM53324_A0_ING_EAV_CLASSr_CLASS_Bf_SET
#define READ_ING_EAV_CLASSr BCM53324_A0_READ_ING_EAV_CLASSr
#define WRITE_ING_EAV_CLASSr BCM53324_A0_WRITE_ING_EAV_CLASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_EAV_CLASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_EGRMSKBMAP
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of ports to be blocked 0=allow-through, 1=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *     BLK_BITMAP       SW overlay:  Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM53324_A0_ING_EGRMSKBMAPr 0x0f700135

#define BCM53324_A0_ING_EGRMSKBMAPr_SIZE 4

/*
 * This structure should be used to declare and program ING_EGRMSKBMAP.
 *
 */
typedef union BCM53324_A0_ING_EGRMSKBMAPr_s {
	uint32_t v[1];
	uint32_t ing_egrmskbmap[1];
	uint32_t _ing_egrmskbmap;
} BCM53324_A0_ING_EGRMSKBMAPr_t;

#define BCM53324_A0_ING_EGRMSKBMAPr_CLR(r) (r).ing_egrmskbmap[0] = 0
#define BCM53324_A0_ING_EGRMSKBMAPr_SET(r,d) (r).ing_egrmskbmap[0] = d
#define BCM53324_A0_ING_EGRMSKBMAPr_GET(r) (r).ing_egrmskbmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_EGRMSKBMAPr_BITMAPf_GET(r) (((r).ing_egrmskbmap[0]) & 0x1ffffff)
#define BCM53324_A0_ING_EGRMSKBMAPr_BITMAPf_SET(r,f) (r).ing_egrmskbmap[0]=(((r).ing_egrmskbmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_ING_EGRMSKBMAPr_BLK_BITMAPf_GET(r) (((r).ing_egrmskbmap[0]) & 0x1ffffff)
#define BCM53324_A0_ING_EGRMSKBMAPr_BLK_BITMAPf_SET(r,f) (r).ing_egrmskbmap[0]=(((r).ing_egrmskbmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access ING_EGRMSKBMAP.
 *
 */
#define BCM53324_A0_READ_ING_EGRMSKBMAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_ING_EGRMSKBMAPr,(r._ing_egrmskbmap))
#define BCM53324_A0_WRITE_ING_EGRMSKBMAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_ING_EGRMSKBMAPr,&(r._ing_egrmskbmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EGRMSKBMAPr BCM53324_A0_ING_EGRMSKBMAPr
#define ING_EGRMSKBMAPr_SIZE BCM53324_A0_ING_EGRMSKBMAPr_SIZE
typedef BCM53324_A0_ING_EGRMSKBMAPr_t ING_EGRMSKBMAPr_t;
#define ING_EGRMSKBMAPr_CLR BCM53324_A0_ING_EGRMSKBMAPr_CLR
#define ING_EGRMSKBMAPr_SET BCM53324_A0_ING_EGRMSKBMAPr_SET
#define ING_EGRMSKBMAPr_GET BCM53324_A0_ING_EGRMSKBMAPr_GET
#define ING_EGRMSKBMAPr_BITMAPf_GET BCM53324_A0_ING_EGRMSKBMAPr_BITMAPf_GET
#define ING_EGRMSKBMAPr_BITMAPf_SET BCM53324_A0_ING_EGRMSKBMAPr_BITMAPf_SET
#define ING_EGRMSKBMAPr_BLK_BITMAPf_GET BCM53324_A0_ING_EGRMSKBMAPr_BLK_BITMAPf_GET
#define ING_EGRMSKBMAPr_BLK_BITMAPf_SET BCM53324_A0_ING_EGRMSKBMAPr_BLK_BITMAPf_SET
#define READ_ING_EGRMSKBMAPr BCM53324_A0_READ_ING_EGRMSKBMAPr
#define WRITE_ING_EGRMSKBMAPr BCM53324_A0_WRITE_ING_EGRMSKBMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_EGRMSKBMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_EN_EFILTER_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Ingress Enable EFilter Bitmap Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           If bitmap[port] is 0, the VLAN member checks for the port are not performed.  If the bitmap[port] is set to 1, then the VLAN checkers will be applied.
 *
 ******************************************************************************/
#define BCM53324_A0_ING_EN_EFILTER_BITMAPr 0x0c78000d

#define BCM53324_A0_ING_EN_EFILTER_BITMAPr_SIZE 4

/*
 * This structure should be used to declare and program ING_EN_EFILTER_BITMAP.
 *
 */
typedef union BCM53324_A0_ING_EN_EFILTER_BITMAPr_s {
	uint32_t v[1];
	uint32_t ing_en_efilter_bitmap[1];
	uint32_t _ing_en_efilter_bitmap;
} BCM53324_A0_ING_EN_EFILTER_BITMAPr_t;

#define BCM53324_A0_ING_EN_EFILTER_BITMAPr_CLR(r) (r).ing_en_efilter_bitmap[0] = 0
#define BCM53324_A0_ING_EN_EFILTER_BITMAPr_SET(r,d) (r).ing_en_efilter_bitmap[0] = d
#define BCM53324_A0_ING_EN_EFILTER_BITMAPr_GET(r) (r).ing_en_efilter_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_EN_EFILTER_BITMAPr_BITMAPf_GET(r) (((r).ing_en_efilter_bitmap[0]) & 0x1ffffff)
#define BCM53324_A0_ING_EN_EFILTER_BITMAPr_BITMAPf_SET(r,f) (r).ing_en_efilter_bitmap[0]=(((r).ing_en_efilter_bitmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access ING_EN_EFILTER_BITMAP.
 *
 */
#define BCM53324_A0_READ_ING_EN_EFILTER_BITMAPr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_EN_EFILTER_BITMAPr,(r._ing_en_efilter_bitmap))
#define BCM53324_A0_WRITE_ING_EN_EFILTER_BITMAPr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_EN_EFILTER_BITMAPr,&(r._ing_en_efilter_bitmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EN_EFILTER_BITMAPr BCM53324_A0_ING_EN_EFILTER_BITMAPr
#define ING_EN_EFILTER_BITMAPr_SIZE BCM53324_A0_ING_EN_EFILTER_BITMAPr_SIZE
typedef BCM53324_A0_ING_EN_EFILTER_BITMAPr_t ING_EN_EFILTER_BITMAPr_t;
#define ING_EN_EFILTER_BITMAPr_CLR BCM53324_A0_ING_EN_EFILTER_BITMAPr_CLR
#define ING_EN_EFILTER_BITMAPr_SET BCM53324_A0_ING_EN_EFILTER_BITMAPr_SET
#define ING_EN_EFILTER_BITMAPr_GET BCM53324_A0_ING_EN_EFILTER_BITMAPr_GET
#define ING_EN_EFILTER_BITMAPr_BITMAPf_GET BCM53324_A0_ING_EN_EFILTER_BITMAPr_BITMAPf_GET
#define ING_EN_EFILTER_BITMAPr_BITMAPf_SET BCM53324_A0_ING_EN_EFILTER_BITMAPr_BITMAPf_SET
#define READ_ING_EN_EFILTER_BITMAPr BCM53324_A0_READ_ING_EN_EFILTER_BITMAPr
#define WRITE_ING_EN_EFILTER_BITMAPr BCM53324_A0_WRITE_ING_EN_EFILTER_BITMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_EN_EFILTER_BITMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_EVENT_DEBUG
 * BLOCKS:   IPIPE
 * DESC:     Ingress Events Debug Register
 * SIZE:     32
 * FIELDS:
 *     VXLT_MISS        Bit 0 - Packets dropped due to VLAN translation miss
 *     BPDU             Bit 1 - BPDU packet drop
 *     PROTOCOL_PKT     Bit 2 - Protocol packet drop
 *     CML              Bit 3 - Packets dropped due to CML
 *     SRC_ROUTE        Bit 4 - Packets dropped due to source route
 *     L2SRC_DISCARD    Bit 5 - Packets dropped due to L2 source discard
 *     L2SRC_STATIC_MOVE Bit 6 - Packets dropped due to L2 source static movement
 *     L2DST_DISCARD    Bit 7 - Packets dropped due to L2 destination discard
 *     CFI_OR_L3DISABLE Bit 8 - Packets dropped due to CFI or L3 disable
 *     HIGIG_MH_TYPE1   Bit 9 - Packets dropped due to HiGig module header type 1
 *     DISC_STAGE       Bit 10 - Packets dropped in discard stage
 *     INVALID_VLAN     Bit 11 - Packets dropped due to invalid VLAN
 *     PDISC            Bit 12 - Receive policy discard counter - DST_DISCARD, SRC_DISCARD, RATE_CONTROL, etc.
 *     RFILDR           Bit 13 - Packets dropped by FP
 *     RIMDR            Bit 14 - Multicast (L2+L3) packets that are dropped
 *     RDROP            Bit 15 - Port bitmap zero drop condition
 *     IMBP             Bit 16 - Bridged multicast packets
 *     RTUN             Bit 17 - Number of tunnel packets received
 *     VLANDR           Bit 18 - Receive VLAN drop cases
 *     DSL3HE           Bit 19 - DOS L3 header error packets
 *     DSL4HE           Bit 20 - DOS L4 header error packets
 *     DSICMP           Bit 21 - DOS ICMP error packets
 *     DSFRAG           Bit 22 - DOS fragment error packets
 *     RESERVED_2_1     Bit 23 - Reserved
 *     RESERVED_3       Bit 24 - Reserved
 *     RTUNE            Bit 25 - Receive tunnel error packets
 *     MACLMT           Bit 26 - MAC rate limited packet
 *     HGHDRE           Bit 27 - Higig Header error packets
 *     MCIDXE           Bit 28 - Multicast Index error packets
 *     MAC_RATE_LIMIT   Bit 29 - Packet dropped due to MAC RATE LIMITING
 *     RESERVED_4       Bit 30 - Reserved
 *     DSL2HE           Bit 31 - For MAC DA equals SA packets.
 *
 ******************************************************************************/
#define BCM53324_A0_ING_EVENT_DEBUGr 0x0f780131

#define BCM53324_A0_ING_EVENT_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program ING_EVENT_DEBUG.
 *
 */
typedef union BCM53324_A0_ING_EVENT_DEBUGr_s {
	uint32_t v[1];
	uint32_t ing_event_debug[1];
	uint32_t _ing_event_debug;
} BCM53324_A0_ING_EVENT_DEBUGr_t;

#define BCM53324_A0_ING_EVENT_DEBUGr_CLR(r) (r).ing_event_debug[0] = 0
#define BCM53324_A0_ING_EVENT_DEBUGr_SET(r,d) (r).ing_event_debug[0] = d
#define BCM53324_A0_ING_EVENT_DEBUGr_GET(r) (r).ing_event_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_EVENT_DEBUGr_VXLT_MISSf_GET(r) (((r).ing_event_debug[0]) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_VXLT_MISSf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_ING_EVENT_DEBUGr_BPDUf_GET(r) ((((r).ing_event_debug[0]) >> 1) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_BPDUf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET(r) ((((r).ing_event_debug[0]) >> 2) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_ING_EVENT_DEBUGr_CMLf_GET(r) ((((r).ing_event_debug[0]) >> 3) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_CMLf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_GET(r) ((((r).ing_event_debug[0]) >> 4) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET(r) ((((r).ing_event_debug[0]) >> 5) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET(r) ((((r).ing_event_debug[0]) >> 6) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_GET(r) ((((r).ing_event_debug[0]) >> 7) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET(r) ((((r).ing_event_debug[0]) >> 8) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET(r) ((((r).ing_event_debug[0]) >> 9) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_ING_EVENT_DEBUGr_DISC_STAGEf_GET(r) ((((r).ing_event_debug[0]) >> 10) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_DISC_STAGEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_ING_EVENT_DEBUGr_INVALID_VLANf_GET(r) ((((r).ing_event_debug[0]) >> 11) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_INVALID_VLANf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_ING_EVENT_DEBUGr_PDISCf_GET(r) ((((r).ing_event_debug[0]) >> 12) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_PDISCf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_ING_EVENT_DEBUGr_RFILDRf_GET(r) ((((r).ing_event_debug[0]) >> 13) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_RFILDRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_ING_EVENT_DEBUGr_RIMDRf_GET(r) ((((r).ing_event_debug[0]) >> 14) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_RIMDRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_ING_EVENT_DEBUGr_RDROPf_GET(r) ((((r).ing_event_debug[0]) >> 15) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_RDROPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_ING_EVENT_DEBUGr_IMBPf_GET(r) ((((r).ing_event_debug[0]) >> 16) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_IMBPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_ING_EVENT_DEBUGr_RTUNf_GET(r) ((((r).ing_event_debug[0]) >> 17) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_RTUNf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_ING_EVENT_DEBUGr_VLANDRf_GET(r) ((((r).ing_event_debug[0]) >> 18) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_VLANDRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_ING_EVENT_DEBUGr_DSL3HEf_GET(r) ((((r).ing_event_debug[0]) >> 19) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_DSL3HEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_ING_EVENT_DEBUGr_DSL4HEf_GET(r) ((((r).ing_event_debug[0]) >> 20) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_DSL4HEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_ING_EVENT_DEBUGr_DSICMPf_GET(r) ((((r).ing_event_debug[0]) >> 21) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_DSICMPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_ING_EVENT_DEBUGr_DSFRAGf_GET(r) ((((r).ing_event_debug[0]) >> 22) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_DSFRAGf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_2_1f_GET(r) ((((r).ing_event_debug[0]) >> 23) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_2_1f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_3f_GET(r) ((((r).ing_event_debug[0]) >> 24) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_3f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_ING_EVENT_DEBUGr_RTUNEf_GET(r) ((((r).ing_event_debug[0]) >> 25) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_RTUNEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_ING_EVENT_DEBUGr_MACLMTf_GET(r) ((((r).ing_event_debug[0]) >> 26) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_MACLMTf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_ING_EVENT_DEBUGr_HGHDREf_GET(r) ((((r).ing_event_debug[0]) >> 27) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_HGHDREf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_ING_EVENT_DEBUGr_MCIDXEf_GET(r) ((((r).ing_event_debug[0]) >> 28) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_MCIDXEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53324_A0_ING_EVENT_DEBUGr_MAC_RATE_LIMITf_GET(r) ((((r).ing_event_debug[0]) >> 29) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_MAC_RATE_LIMITf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_4f_GET(r) ((((r).ing_event_debug[0]) >> 30) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_4f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_ING_EVENT_DEBUGr_DSL2HEf_GET(r) ((((r).ing_event_debug[0]) >> 31) & 0x1)
#define BCM53324_A0_ING_EVENT_DEBUGr_DSL2HEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ING_EVENT_DEBUG.
 *
 */
#define BCM53324_A0_READ_ING_EVENT_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_EVENT_DEBUGr,(r._ing_event_debug))
#define BCM53324_A0_WRITE_ING_EVENT_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_EVENT_DEBUGr,&(r._ing_event_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EVENT_DEBUGr BCM53324_A0_ING_EVENT_DEBUGr
#define ING_EVENT_DEBUGr_SIZE BCM53324_A0_ING_EVENT_DEBUGr_SIZE
typedef BCM53324_A0_ING_EVENT_DEBUGr_t ING_EVENT_DEBUGr_t;
#define ING_EVENT_DEBUGr_CLR BCM53324_A0_ING_EVENT_DEBUGr_CLR
#define ING_EVENT_DEBUGr_SET BCM53324_A0_ING_EVENT_DEBUGr_SET
#define ING_EVENT_DEBUGr_GET BCM53324_A0_ING_EVENT_DEBUGr_GET
#define ING_EVENT_DEBUGr_VXLT_MISSf_GET BCM53324_A0_ING_EVENT_DEBUGr_VXLT_MISSf_GET
#define ING_EVENT_DEBUGr_VXLT_MISSf_SET BCM53324_A0_ING_EVENT_DEBUGr_VXLT_MISSf_SET
#define ING_EVENT_DEBUGr_BPDUf_GET BCM53324_A0_ING_EVENT_DEBUGr_BPDUf_GET
#define ING_EVENT_DEBUGr_BPDUf_SET BCM53324_A0_ING_EVENT_DEBUGr_BPDUf_SET
#define ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET BCM53324_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET
#define ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET BCM53324_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET
#define ING_EVENT_DEBUGr_CMLf_GET BCM53324_A0_ING_EVENT_DEBUGr_CMLf_GET
#define ING_EVENT_DEBUGr_CMLf_SET BCM53324_A0_ING_EVENT_DEBUGr_CMLf_SET
#define ING_EVENT_DEBUGr_SRC_ROUTEf_GET BCM53324_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_GET
#define ING_EVENT_DEBUGr_SRC_ROUTEf_SET BCM53324_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_SET
#define ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET BCM53324_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET
#define ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET BCM53324_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET
#define ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET BCM53324_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET
#define ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET BCM53324_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET
#define ING_EVENT_DEBUGr_L2DST_DISCARDf_GET BCM53324_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_GET
#define ING_EVENT_DEBUGr_L2DST_DISCARDf_SET BCM53324_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_SET
#define ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET BCM53324_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET
#define ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET BCM53324_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET
#define ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET BCM53324_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET
#define ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET BCM53324_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET
#define ING_EVENT_DEBUGr_DISC_STAGEf_GET BCM53324_A0_ING_EVENT_DEBUGr_DISC_STAGEf_GET
#define ING_EVENT_DEBUGr_DISC_STAGEf_SET BCM53324_A0_ING_EVENT_DEBUGr_DISC_STAGEf_SET
#define ING_EVENT_DEBUGr_INVALID_VLANf_GET BCM53324_A0_ING_EVENT_DEBUGr_INVALID_VLANf_GET
#define ING_EVENT_DEBUGr_INVALID_VLANf_SET BCM53324_A0_ING_EVENT_DEBUGr_INVALID_VLANf_SET
#define ING_EVENT_DEBUGr_PDISCf_GET BCM53324_A0_ING_EVENT_DEBUGr_PDISCf_GET
#define ING_EVENT_DEBUGr_PDISCf_SET BCM53324_A0_ING_EVENT_DEBUGr_PDISCf_SET
#define ING_EVENT_DEBUGr_RFILDRf_GET BCM53324_A0_ING_EVENT_DEBUGr_RFILDRf_GET
#define ING_EVENT_DEBUGr_RFILDRf_SET BCM53324_A0_ING_EVENT_DEBUGr_RFILDRf_SET
#define ING_EVENT_DEBUGr_RIMDRf_GET BCM53324_A0_ING_EVENT_DEBUGr_RIMDRf_GET
#define ING_EVENT_DEBUGr_RIMDRf_SET BCM53324_A0_ING_EVENT_DEBUGr_RIMDRf_SET
#define ING_EVENT_DEBUGr_RDROPf_GET BCM53324_A0_ING_EVENT_DEBUGr_RDROPf_GET
#define ING_EVENT_DEBUGr_RDROPf_SET BCM53324_A0_ING_EVENT_DEBUGr_RDROPf_SET
#define ING_EVENT_DEBUGr_IMBPf_GET BCM53324_A0_ING_EVENT_DEBUGr_IMBPf_GET
#define ING_EVENT_DEBUGr_IMBPf_SET BCM53324_A0_ING_EVENT_DEBUGr_IMBPf_SET
#define ING_EVENT_DEBUGr_RTUNf_GET BCM53324_A0_ING_EVENT_DEBUGr_RTUNf_GET
#define ING_EVENT_DEBUGr_RTUNf_SET BCM53324_A0_ING_EVENT_DEBUGr_RTUNf_SET
#define ING_EVENT_DEBUGr_VLANDRf_GET BCM53324_A0_ING_EVENT_DEBUGr_VLANDRf_GET
#define ING_EVENT_DEBUGr_VLANDRf_SET BCM53324_A0_ING_EVENT_DEBUGr_VLANDRf_SET
#define ING_EVENT_DEBUGr_DSL3HEf_GET BCM53324_A0_ING_EVENT_DEBUGr_DSL3HEf_GET
#define ING_EVENT_DEBUGr_DSL3HEf_SET BCM53324_A0_ING_EVENT_DEBUGr_DSL3HEf_SET
#define ING_EVENT_DEBUGr_DSL4HEf_GET BCM53324_A0_ING_EVENT_DEBUGr_DSL4HEf_GET
#define ING_EVENT_DEBUGr_DSL4HEf_SET BCM53324_A0_ING_EVENT_DEBUGr_DSL4HEf_SET
#define ING_EVENT_DEBUGr_DSICMPf_GET BCM53324_A0_ING_EVENT_DEBUGr_DSICMPf_GET
#define ING_EVENT_DEBUGr_DSICMPf_SET BCM53324_A0_ING_EVENT_DEBUGr_DSICMPf_SET
#define ING_EVENT_DEBUGr_DSFRAGf_GET BCM53324_A0_ING_EVENT_DEBUGr_DSFRAGf_GET
#define ING_EVENT_DEBUGr_DSFRAGf_SET BCM53324_A0_ING_EVENT_DEBUGr_DSFRAGf_SET
#define ING_EVENT_DEBUGr_RESERVED_2_1f_GET BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_2_1f_GET
#define ING_EVENT_DEBUGr_RESERVED_2_1f_SET BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_2_1f_SET
#define ING_EVENT_DEBUGr_RESERVED_3f_GET BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_3f_GET
#define ING_EVENT_DEBUGr_RESERVED_3f_SET BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_3f_SET
#define ING_EVENT_DEBUGr_RTUNEf_GET BCM53324_A0_ING_EVENT_DEBUGr_RTUNEf_GET
#define ING_EVENT_DEBUGr_RTUNEf_SET BCM53324_A0_ING_EVENT_DEBUGr_RTUNEf_SET
#define ING_EVENT_DEBUGr_MACLMTf_GET BCM53324_A0_ING_EVENT_DEBUGr_MACLMTf_GET
#define ING_EVENT_DEBUGr_MACLMTf_SET BCM53324_A0_ING_EVENT_DEBUGr_MACLMTf_SET
#define ING_EVENT_DEBUGr_HGHDREf_GET BCM53324_A0_ING_EVENT_DEBUGr_HGHDREf_GET
#define ING_EVENT_DEBUGr_HGHDREf_SET BCM53324_A0_ING_EVENT_DEBUGr_HGHDREf_SET
#define ING_EVENT_DEBUGr_MCIDXEf_GET BCM53324_A0_ING_EVENT_DEBUGr_MCIDXEf_GET
#define ING_EVENT_DEBUGr_MCIDXEf_SET BCM53324_A0_ING_EVENT_DEBUGr_MCIDXEf_SET
#define ING_EVENT_DEBUGr_MAC_RATE_LIMITf_GET BCM53324_A0_ING_EVENT_DEBUGr_MAC_RATE_LIMITf_GET
#define ING_EVENT_DEBUGr_MAC_RATE_LIMITf_SET BCM53324_A0_ING_EVENT_DEBUGr_MAC_RATE_LIMITf_SET
#define ING_EVENT_DEBUGr_RESERVED_4f_GET BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_4f_GET
#define ING_EVENT_DEBUGr_RESERVED_4f_SET BCM53324_A0_ING_EVENT_DEBUGr_RESERVED_4f_SET
#define ING_EVENT_DEBUGr_DSL2HEf_GET BCM53324_A0_ING_EVENT_DEBUGr_DSL2HEf_GET
#define ING_EVENT_DEBUGr_DSL2HEf_SET BCM53324_A0_ING_EVENT_DEBUGr_DSL2HEf_SET
#define READ_ING_EVENT_DEBUGr BCM53324_A0_READ_ING_EVENT_DEBUGr
#define WRITE_ING_EVENT_DEBUGr BCM53324_A0_WRITE_ING_EVENT_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_EVENT_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_HW_RESET_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #1
 * SIZE:     32
 * FIELDS:
 *     STAGE_NUMBER     IP stage for the memory table
 *     OFFSET           20-bit starting offset of table for memory
 *
 ******************************************************************************/
#define BCM53324_A0_ING_HW_RESET_CONTROL_1r 0x00780001

#define BCM53324_A0_ING_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_1.
 *
 */
typedef union BCM53324_A0_ING_HW_RESET_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_1[1];
	uint32_t _ing_hw_reset_control_1;
} BCM53324_A0_ING_HW_RESET_CONTROL_1r_t;

#define BCM53324_A0_ING_HW_RESET_CONTROL_1r_CLR(r) (r).ing_hw_reset_control_1[0] = 0
#define BCM53324_A0_ING_HW_RESET_CONTROL_1r_SET(r,d) (r).ing_hw_reset_control_1[0] = d
#define BCM53324_A0_ING_HW_RESET_CONTROL_1r_GET(r) (r).ing_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET(r) (((r).ing_hw_reset_control_1[0]) & 0x3f)
#define BCM53324_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_GET(r) ((((r).ing_hw_reset_control_1[0]) >> 6) & 0xfffff)
#define BCM53324_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32_t)0xfffff << 6)) | ((((uint32_t)f) & 0xfffff) << 6))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_1.
 *
 */
#define BCM53324_A0_READ_ING_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_HW_RESET_CONTROL_1r,(r._ing_hw_reset_control_1))
#define BCM53324_A0_WRITE_ING_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_HW_RESET_CONTROL_1r,&(r._ing_hw_reset_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_1r BCM53324_A0_ING_HW_RESET_CONTROL_1r
#define ING_HW_RESET_CONTROL_1r_SIZE BCM53324_A0_ING_HW_RESET_CONTROL_1r_SIZE
typedef BCM53324_A0_ING_HW_RESET_CONTROL_1r_t ING_HW_RESET_CONTROL_1r_t;
#define ING_HW_RESET_CONTROL_1r_CLR BCM53324_A0_ING_HW_RESET_CONTROL_1r_CLR
#define ING_HW_RESET_CONTROL_1r_SET BCM53324_A0_ING_HW_RESET_CONTROL_1r_SET
#define ING_HW_RESET_CONTROL_1r_GET BCM53324_A0_ING_HW_RESET_CONTROL_1r_GET
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET BCM53324_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET BCM53324_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET
#define ING_HW_RESET_CONTROL_1r_OFFSETf_GET BCM53324_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_GET
#define ING_HW_RESET_CONTROL_1r_OFFSETf_SET BCM53324_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_SET
#define READ_ING_HW_RESET_CONTROL_1r BCM53324_A0_READ_ING_HW_RESET_CONTROL_1r
#define WRITE_ING_HW_RESET_CONTROL_1r BCM53324_A0_WRITE_ING_HW_RESET_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_HW_RESET_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_HW_RESET_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #2
 * SIZE:     32
 * FIELDS:
 *     COUNT            Number of entries of memory to initialize
 *     RESET_ALL        Indicates all memories in all stages should be initialized (independent of stage or table number)
 *     VALID            Set by software to trigger memory initialization
 *     DONE             Set by arbiter to indicate memory table writes have completed
 *
 ******************************************************************************/
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r 0x00780002

#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_2.
 *
 */
typedef union BCM53324_A0_ING_HW_RESET_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_2[1];
	uint32_t _ing_hw_reset_control_2;
} BCM53324_A0_ING_HW_RESET_CONTROL_2r_t;

#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_CLR(r) (r).ing_hw_reset_control_2[0] = 0
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_SET(r,d) (r).ing_hw_reset_control_2[0] = d
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_GET(r) (r).ing_hw_reset_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_COUNTf_GET(r) (((r).ing_hw_reset_control_2[0]) & 0xffff)
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_COUNTf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 16) & 0x1)
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_VALIDf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 17) & 0x1)
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_VALIDf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_DONEf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 18) & 0x1)
#define BCM53324_A0_ING_HW_RESET_CONTROL_2r_DONEf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_2.
 *
 */
#define BCM53324_A0_READ_ING_HW_RESET_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_HW_RESET_CONTROL_2r,(r._ing_hw_reset_control_2))
#define BCM53324_A0_WRITE_ING_HW_RESET_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_HW_RESET_CONTROL_2r,&(r._ing_hw_reset_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_2r BCM53324_A0_ING_HW_RESET_CONTROL_2r
#define ING_HW_RESET_CONTROL_2r_SIZE BCM53324_A0_ING_HW_RESET_CONTROL_2r_SIZE
typedef BCM53324_A0_ING_HW_RESET_CONTROL_2r_t ING_HW_RESET_CONTROL_2r_t;
#define ING_HW_RESET_CONTROL_2r_CLR BCM53324_A0_ING_HW_RESET_CONTROL_2r_CLR
#define ING_HW_RESET_CONTROL_2r_SET BCM53324_A0_ING_HW_RESET_CONTROL_2r_SET
#define ING_HW_RESET_CONTROL_2r_GET BCM53324_A0_ING_HW_RESET_CONTROL_2r_GET
#define ING_HW_RESET_CONTROL_2r_COUNTf_GET BCM53324_A0_ING_HW_RESET_CONTROL_2r_COUNTf_GET
#define ING_HW_RESET_CONTROL_2r_COUNTf_SET BCM53324_A0_ING_HW_RESET_CONTROL_2r_COUNTf_SET
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET BCM53324_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET BCM53324_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET
#define ING_HW_RESET_CONTROL_2r_VALIDf_GET BCM53324_A0_ING_HW_RESET_CONTROL_2r_VALIDf_GET
#define ING_HW_RESET_CONTROL_2r_VALIDf_SET BCM53324_A0_ING_HW_RESET_CONTROL_2r_VALIDf_SET
#define ING_HW_RESET_CONTROL_2r_DONEf_GET BCM53324_A0_ING_HW_RESET_CONTROL_2r_DONEf_GET
#define ING_HW_RESET_CONTROL_2r_DONEf_SET BCM53324_A0_ING_HW_RESET_CONTROL_2r_DONEf_SET
#define READ_ING_HW_RESET_CONTROL_2r BCM53324_A0_READ_ING_HW_RESET_CONTROL_2r
#define WRITE_ING_HW_RESET_CONTROL_2r BCM53324_A0_WRITE_ING_HW_RESET_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_HW_RESET_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  ING_L3_NEXT_HOP
 * BLOCKS:   IPIPE
 * DESC:     Ingress L3_NEXT_HOP table.  Used to provide just mod and port/TGID. Indexed with Next Hop Index resolved in previous stages.
 * SIZE:     24
 * FIELDS:
 *     L3UC_TUNNEL_TYPE Tunnel Type - 0 means no encap will be done. 1 means pkt will be l3 encapsulated.
 *     PORT_TGID        Port/TGID of next hop
 *     MODULE_ID        Module ID of next hop
 *     VLAN_ID          VLAN ID of next hop
 *
 ******************************************************************************/
#define BCM53324_A0_ING_L3_NEXT_HOPm 0x0e710000

#define BCM53324_A0_ING_L3_NEXT_HOPm_MIN 0
#define BCM53324_A0_ING_L3_NEXT_HOPm_MAX 15
#define BCM53324_A0_ING_L3_NEXT_HOPm_CMAX(u) 15
#define BCM53324_A0_ING_L3_NEXT_HOPm_SIZE 3

/*
 * This structure should be used to declare and program ING_L3_NEXT_HOP.
 *
 */
typedef union BCM53324_A0_ING_L3_NEXT_HOPm_s {
	uint32_t v[1];
	uint32_t ing_l3_next_hop[1];
	uint32_t _ing_l3_next_hop;
} BCM53324_A0_ING_L3_NEXT_HOPm_t;

#define BCM53324_A0_ING_L3_NEXT_HOPm_CLR(r) (r).ing_l3_next_hop[0] = 0
#define BCM53324_A0_ING_L3_NEXT_HOPm_SET(r,d) (r).ing_l3_next_hop[0] = d
#define BCM53324_A0_ING_L3_NEXT_HOPm_GET(r) (r).ing_l3_next_hop[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET(r) (((r).ing_l3_next_hop[0]) & 0x1)
#define BCM53324_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 1) & 0x7f)
#define BCM53324_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM53324_A0_ING_L3_NEXT_HOPm_MODULE_IDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 8) & 0xf)
#define BCM53324_A0_ING_L3_NEXT_HOPm_MODULE_IDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_ING_L3_NEXT_HOPm_VLAN_IDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 12) & 0xfff)
#define BCM53324_A0_ING_L3_NEXT_HOPm_VLAN_IDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access ING_L3_NEXT_HOP.
 *
 */
#define BCM53324_A0_READ_ING_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_ING_L3_NEXT_HOPm,i,(m._ing_l3_next_hop),1)
#define BCM53324_A0_WRITE_ING_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_ING_L3_NEXT_HOPm,i,&(m._ing_l3_next_hop),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_L3_NEXT_HOPm BCM53324_A0_ING_L3_NEXT_HOPm
#define ING_L3_NEXT_HOPm_MIN BCM53324_A0_ING_L3_NEXT_HOPm_MIN
#define ING_L3_NEXT_HOPm_MAX BCM53324_A0_ING_L3_NEXT_HOPm_MAX
#define ING_L3_NEXT_HOPm_CMAX(u) BCM53324_A0_ING_L3_NEXT_HOPm_CMAX(u)
#define ING_L3_NEXT_HOPm_SIZE BCM53324_A0_ING_L3_NEXT_HOPm_SIZE
typedef BCM53324_A0_ING_L3_NEXT_HOPm_t ING_L3_NEXT_HOPm_t;
#define ING_L3_NEXT_HOPm_CLR BCM53324_A0_ING_L3_NEXT_HOPm_CLR
#define ING_L3_NEXT_HOPm_SET BCM53324_A0_ING_L3_NEXT_HOPm_SET
#define ING_L3_NEXT_HOPm_GET BCM53324_A0_ING_L3_NEXT_HOPm_GET
#define ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET BCM53324_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET
#define ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET BCM53324_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET
#define ING_L3_NEXT_HOPm_PORT_TGIDf_GET BCM53324_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_GET
#define ING_L3_NEXT_HOPm_PORT_TGIDf_SET BCM53324_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_SET
#define ING_L3_NEXT_HOPm_MODULE_IDf_GET BCM53324_A0_ING_L3_NEXT_HOPm_MODULE_IDf_GET
#define ING_L3_NEXT_HOPm_MODULE_IDf_SET BCM53324_A0_ING_L3_NEXT_HOPm_MODULE_IDf_SET
#define ING_L3_NEXT_HOPm_VLAN_IDf_GET BCM53324_A0_ING_L3_NEXT_HOPm_VLAN_IDf_GET
#define ING_L3_NEXT_HOPm_VLAN_IDf_SET BCM53324_A0_ING_L3_NEXT_HOPm_VLAN_IDf_SET
#define READ_ING_L3_NEXT_HOPm BCM53324_A0_READ_ING_L3_NEXT_HOPm
#define WRITE_ING_L3_NEXT_HOPm BCM53324_A0_WRITE_ING_L3_NEXT_HOPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_L3_NEXT_HOPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_MISC_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Configuration bits that are needed in Isw2
 * SIZE:     32
 * FIELDS:
 *     APPLY_EGR_MASK_ON_UC_ONLY If set, apply egress mask on unicast packets only.
 *     APPLY_SRCMOD_BLOCK_ON_UC_ONLY If set, apply source modid block on unicast packets only.
 *     DO_NOT_APPLY_SRCMOD_BLOCK_ON_SC If set, do not apply source modid block on system control packets.
 *     USE_DEST_PORT    Use last 2bits of destination port for Higig trunk
 *     DROP_PACKET_ON_PARITY_ERROR If set, packets must be dropped if there are parity errors in the tables where parity mechanism is newly added,i.e. vlan, l2mc, l3mc, dscp, fp_policy_table, ing_next_hop_table, egr_mask table .
 *     STG_CHECK_ENABLE And Final L2 PBM with SPT bitmap corresponding to incoming VLAN.
 *     USE_EPC_LINK_BMP Control to indicate that link-bmp should be taken from the EPC_LINK register
 *     OUI_BASED_Q_ASSIGNMENT Control for OUI based Queue assignment
 *     TRANSPORT_BASED_Q_ASSIGNMENT Control for TRANSPORT based Queue assignment
 *     DROP_EAV_PKT_ON_NONEAV_PORT If set, EAV packets on non-EAV ports will be dropped
 *     PCP_BASED_Q_ASSIGNMENT Control for PCP based Queue assignment
 *
 ******************************************************************************/
#define BCM53324_A0_ING_MISC_CONFIGr 0x0f78012d

#define BCM53324_A0_ING_MISC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_MISC_CONFIG.
 *
 */
typedef union BCM53324_A0_ING_MISC_CONFIGr_s {
	uint32_t v[1];
	uint32_t ing_misc_config[1];
	uint32_t _ing_misc_config;
} BCM53324_A0_ING_MISC_CONFIGr_t;

#define BCM53324_A0_ING_MISC_CONFIGr_CLR(r) (r).ing_misc_config[0] = 0
#define BCM53324_A0_ING_MISC_CONFIGr_SET(r,d) (r).ing_misc_config[0] = d
#define BCM53324_A0_ING_MISC_CONFIGr_GET(r) (r).ing_misc_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET(r) (((r).ing_misc_config[0]) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET(r) ((((r).ing_misc_config[0]) >> 1) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET(r) ((((r).ing_misc_config[0]) >> 2) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_ING_MISC_CONFIGr_USE_DEST_PORTf_GET(r) ((((r).ing_misc_config[0]) >> 3) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_USE_DEST_PORTf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_ING_MISC_CONFIGr_DROP_PACKET_ON_PARITY_ERRORf_GET(r) ((((r).ing_misc_config[0]) >> 4) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_DROP_PACKET_ON_PARITY_ERRORf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_ING_MISC_CONFIGr_STG_CHECK_ENABLEf_GET(r) ((((r).ing_misc_config[0]) >> 5) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_STG_CHECK_ENABLEf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_ING_MISC_CONFIGr_USE_EPC_LINK_BMPf_GET(r) ((((r).ing_misc_config[0]) >> 6) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_USE_EPC_LINK_BMPf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_ING_MISC_CONFIGr_OUI_BASED_Q_ASSIGNMENTf_GET(r) ((((r).ing_misc_config[0]) >> 7) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_OUI_BASED_Q_ASSIGNMENTf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_ING_MISC_CONFIGr_TRANSPORT_BASED_Q_ASSIGNMENTf_GET(r) ((((r).ing_misc_config[0]) >> 8) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_TRANSPORT_BASED_Q_ASSIGNMENTf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_ING_MISC_CONFIGr_DROP_EAV_PKT_ON_NONEAV_PORTf_GET(r) ((((r).ing_misc_config[0]) >> 9) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_DROP_EAV_PKT_ON_NONEAV_PORTf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_ING_MISC_CONFIGr_PCP_BASED_Q_ASSIGNMENTf_GET(r) ((((r).ing_misc_config[0]) >> 10) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIGr_PCP_BASED_Q_ASSIGNMENTf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))

/*
 * These macros can be used to access ING_MISC_CONFIG.
 *
 */
#define BCM53324_A0_READ_ING_MISC_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_MISC_CONFIGr,(r._ing_misc_config))
#define BCM53324_A0_WRITE_ING_MISC_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_MISC_CONFIGr,&(r._ing_misc_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_MISC_CONFIGr BCM53324_A0_ING_MISC_CONFIGr
#define ING_MISC_CONFIGr_SIZE BCM53324_A0_ING_MISC_CONFIGr_SIZE
typedef BCM53324_A0_ING_MISC_CONFIGr_t ING_MISC_CONFIGr_t;
#define ING_MISC_CONFIGr_CLR BCM53324_A0_ING_MISC_CONFIGr_CLR
#define ING_MISC_CONFIGr_SET BCM53324_A0_ING_MISC_CONFIGr_SET
#define ING_MISC_CONFIGr_GET BCM53324_A0_ING_MISC_CONFIGr_GET
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET BCM53324_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET BCM53324_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET BCM53324_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET BCM53324_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET BCM53324_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET BCM53324_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET
#define ING_MISC_CONFIGr_USE_DEST_PORTf_GET BCM53324_A0_ING_MISC_CONFIGr_USE_DEST_PORTf_GET
#define ING_MISC_CONFIGr_USE_DEST_PORTf_SET BCM53324_A0_ING_MISC_CONFIGr_USE_DEST_PORTf_SET
#define ING_MISC_CONFIGr_DROP_PACKET_ON_PARITY_ERRORf_GET BCM53324_A0_ING_MISC_CONFIGr_DROP_PACKET_ON_PARITY_ERRORf_GET
#define ING_MISC_CONFIGr_DROP_PACKET_ON_PARITY_ERRORf_SET BCM53324_A0_ING_MISC_CONFIGr_DROP_PACKET_ON_PARITY_ERRORf_SET
#define ING_MISC_CONFIGr_STG_CHECK_ENABLEf_GET BCM53324_A0_ING_MISC_CONFIGr_STG_CHECK_ENABLEf_GET
#define ING_MISC_CONFIGr_STG_CHECK_ENABLEf_SET BCM53324_A0_ING_MISC_CONFIGr_STG_CHECK_ENABLEf_SET
#define ING_MISC_CONFIGr_USE_EPC_LINK_BMPf_GET BCM53324_A0_ING_MISC_CONFIGr_USE_EPC_LINK_BMPf_GET
#define ING_MISC_CONFIGr_USE_EPC_LINK_BMPf_SET BCM53324_A0_ING_MISC_CONFIGr_USE_EPC_LINK_BMPf_SET
#define ING_MISC_CONFIGr_OUI_BASED_Q_ASSIGNMENTf_GET BCM53324_A0_ING_MISC_CONFIGr_OUI_BASED_Q_ASSIGNMENTf_GET
#define ING_MISC_CONFIGr_OUI_BASED_Q_ASSIGNMENTf_SET BCM53324_A0_ING_MISC_CONFIGr_OUI_BASED_Q_ASSIGNMENTf_SET
#define ING_MISC_CONFIGr_TRANSPORT_BASED_Q_ASSIGNMENTf_GET BCM53324_A0_ING_MISC_CONFIGr_TRANSPORT_BASED_Q_ASSIGNMENTf_GET
#define ING_MISC_CONFIGr_TRANSPORT_BASED_Q_ASSIGNMENTf_SET BCM53324_A0_ING_MISC_CONFIGr_TRANSPORT_BASED_Q_ASSIGNMENTf_SET
#define ING_MISC_CONFIGr_DROP_EAV_PKT_ON_NONEAV_PORTf_GET BCM53324_A0_ING_MISC_CONFIGr_DROP_EAV_PKT_ON_NONEAV_PORTf_GET
#define ING_MISC_CONFIGr_DROP_EAV_PKT_ON_NONEAV_PORTf_SET BCM53324_A0_ING_MISC_CONFIGr_DROP_EAV_PKT_ON_NONEAV_PORTf_SET
#define ING_MISC_CONFIGr_PCP_BASED_Q_ASSIGNMENTf_GET BCM53324_A0_ING_MISC_CONFIGr_PCP_BASED_Q_ASSIGNMENTf_GET
#define ING_MISC_CONFIGr_PCP_BASED_Q_ASSIGNMENTf_SET BCM53324_A0_ING_MISC_CONFIGr_PCP_BASED_Q_ASSIGNMENTf_SET
#define READ_ING_MISC_CONFIGr BCM53324_A0_READ_ING_MISC_CONFIGr
#define WRITE_ING_MISC_CONFIGr BCM53324_A0_WRITE_ING_MISC_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_MISC_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_MISC_CONFIG2
 * BLOCKS:   IPIPE
 * DESC:     Miscellaneous configuration bits
 * SIZE:     32
 * FIELDS:
 *     MACSA_ALL_ZERO_DROP If this bit is set, packets which have a MAC SA as all zeroes will be dropped
 *     DO_NOT_LEARN_DHCP If set to 1, DHCP packets will not have learning of their MACSA
 *     FP_PORT_FIELD_SEL_MODE If set to 0, the ingress port will be used as the index into the FP_PORT_FIELD_SEL table. If set to 1, the FP_UDF_OFFSET.PORT_FIELD_SEL_INDEX0/1 will be used as the FP_PORT_FIELD_SEL table index.
 *     IPMC_MISS_AS_L2MC For unknown IPMC packets, go through L2MC logic, instead of just flood to VLAN
 *     UNKNOWN_TUNNEL_IPMC_DROP Drop unknown IPMC packets for incoming tunnels
 *     FP_INNER_VLAN_OVERLAY_ENABLE If set to 1, anywhere in the FP_TCAM matching the inner VLAN tag is used will be replaced by VRF_ID[5:0]
 *
 ******************************************************************************/
#define BCM53324_A0_ING_MISC_CONFIG2r 0x0c78000c

#define BCM53324_A0_ING_MISC_CONFIG2r_SIZE 4

/*
 * This structure should be used to declare and program ING_MISC_CONFIG2.
 *
 */
typedef union BCM53324_A0_ING_MISC_CONFIG2r_s {
	uint32_t v[1];
	uint32_t ing_misc_config2[1];
	uint32_t _ing_misc_config2;
} BCM53324_A0_ING_MISC_CONFIG2r_t;

#define BCM53324_A0_ING_MISC_CONFIG2r_CLR(r) (r).ing_misc_config2[0] = 0
#define BCM53324_A0_ING_MISC_CONFIG2r_SET(r,d) (r).ing_misc_config2[0] = d
#define BCM53324_A0_ING_MISC_CONFIG2r_GET(r) (r).ing_misc_config2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_GET(r) (((r).ing_misc_config2[0]) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_SET(r,f) (r).ing_misc_config2[0]=(((r).ing_misc_config2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_ING_MISC_CONFIG2r_DO_NOT_LEARN_DHCPf_GET(r) ((((r).ing_misc_config2[0]) >> 1) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIG2r_DO_NOT_LEARN_DHCPf_SET(r,f) (r).ing_misc_config2[0]=(((r).ing_misc_config2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_ING_MISC_CONFIG2r_FP_PORT_FIELD_SEL_MODEf_GET(r) ((((r).ing_misc_config2[0]) >> 2) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIG2r_FP_PORT_FIELD_SEL_MODEf_SET(r,f) (r).ing_misc_config2[0]=(((r).ing_misc_config2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_ING_MISC_CONFIG2r_IPMC_MISS_AS_L2MCf_GET(r) ((((r).ing_misc_config2[0]) >> 3) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIG2r_IPMC_MISS_AS_L2MCf_SET(r,f) (r).ing_misc_config2[0]=(((r).ing_misc_config2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_ING_MISC_CONFIG2r_UNKNOWN_TUNNEL_IPMC_DROPf_GET(r) ((((r).ing_misc_config2[0]) >> 4) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIG2r_UNKNOWN_TUNNEL_IPMC_DROPf_SET(r,f) (r).ing_misc_config2[0]=(((r).ing_misc_config2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_ING_MISC_CONFIG2r_FP_INNER_VLAN_OVERLAY_ENABLEf_GET(r) ((((r).ing_misc_config2[0]) >> 5) & 0x1)
#define BCM53324_A0_ING_MISC_CONFIG2r_FP_INNER_VLAN_OVERLAY_ENABLEf_SET(r,f) (r).ing_misc_config2[0]=(((r).ing_misc_config2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access ING_MISC_CONFIG2.
 *
 */
#define BCM53324_A0_READ_ING_MISC_CONFIG2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_MISC_CONFIG2r,(r._ing_misc_config2))
#define BCM53324_A0_WRITE_ING_MISC_CONFIG2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_MISC_CONFIG2r,&(r._ing_misc_config2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_MISC_CONFIG2r BCM53324_A0_ING_MISC_CONFIG2r
#define ING_MISC_CONFIG2r_SIZE BCM53324_A0_ING_MISC_CONFIG2r_SIZE
typedef BCM53324_A0_ING_MISC_CONFIG2r_t ING_MISC_CONFIG2r_t;
#define ING_MISC_CONFIG2r_CLR BCM53324_A0_ING_MISC_CONFIG2r_CLR
#define ING_MISC_CONFIG2r_SET BCM53324_A0_ING_MISC_CONFIG2r_SET
#define ING_MISC_CONFIG2r_GET BCM53324_A0_ING_MISC_CONFIG2r_GET
#define ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_GET BCM53324_A0_ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_GET
#define ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_SET BCM53324_A0_ING_MISC_CONFIG2r_MACSA_ALL_ZERO_DROPf_SET
#define ING_MISC_CONFIG2r_DO_NOT_LEARN_DHCPf_GET BCM53324_A0_ING_MISC_CONFIG2r_DO_NOT_LEARN_DHCPf_GET
#define ING_MISC_CONFIG2r_DO_NOT_LEARN_DHCPf_SET BCM53324_A0_ING_MISC_CONFIG2r_DO_NOT_LEARN_DHCPf_SET
#define ING_MISC_CONFIG2r_FP_PORT_FIELD_SEL_MODEf_GET BCM53324_A0_ING_MISC_CONFIG2r_FP_PORT_FIELD_SEL_MODEf_GET
#define ING_MISC_CONFIG2r_FP_PORT_FIELD_SEL_MODEf_SET BCM53324_A0_ING_MISC_CONFIG2r_FP_PORT_FIELD_SEL_MODEf_SET
#define ING_MISC_CONFIG2r_IPMC_MISS_AS_L2MCf_GET BCM53324_A0_ING_MISC_CONFIG2r_IPMC_MISS_AS_L2MCf_GET
#define ING_MISC_CONFIG2r_IPMC_MISS_AS_L2MCf_SET BCM53324_A0_ING_MISC_CONFIG2r_IPMC_MISS_AS_L2MCf_SET
#define ING_MISC_CONFIG2r_UNKNOWN_TUNNEL_IPMC_DROPf_GET BCM53324_A0_ING_MISC_CONFIG2r_UNKNOWN_TUNNEL_IPMC_DROPf_GET
#define ING_MISC_CONFIG2r_UNKNOWN_TUNNEL_IPMC_DROPf_SET BCM53324_A0_ING_MISC_CONFIG2r_UNKNOWN_TUNNEL_IPMC_DROPf_SET
#define ING_MISC_CONFIG2r_FP_INNER_VLAN_OVERLAY_ENABLEf_GET BCM53324_A0_ING_MISC_CONFIG2r_FP_INNER_VLAN_OVERLAY_ENABLEf_GET
#define ING_MISC_CONFIG2r_FP_INNER_VLAN_OVERLAY_ENABLEf_SET BCM53324_A0_ING_MISC_CONFIG2r_FP_INNER_VLAN_OVERLAY_ENABLEf_SET
#define READ_ING_MISC_CONFIG2r BCM53324_A0_READ_ING_MISC_CONFIG2r
#define WRITE_ING_MISC_CONFIG2r BCM53324_A0_WRITE_ING_MISC_CONFIG2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_MISC_CONFIG2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_OUTER_TPID
 * BLOCKS:   IPIPE
 * DESC:     Ingress Outer TPID register
 * SIZE:     32
 * FIELDS:
 *     TPID             Ingress outer TPID field
 *
 ******************************************************************************/
#define BCM53324_A0_ING_OUTER_TPIDr 0x0278000c

#define BCM53324_A0_ING_OUTER_TPIDr_SIZE 4

/*
 * This structure should be used to declare and program ING_OUTER_TPID.
 *
 */
typedef union BCM53324_A0_ING_OUTER_TPIDr_s {
	uint32_t v[1];
	uint32_t ing_outer_tpid[1];
	uint32_t _ing_outer_tpid;
} BCM53324_A0_ING_OUTER_TPIDr_t;

#define BCM53324_A0_ING_OUTER_TPIDr_CLR(r) (r).ing_outer_tpid[0] = 0
#define BCM53324_A0_ING_OUTER_TPIDr_SET(r,d) (r).ing_outer_tpid[0] = d
#define BCM53324_A0_ING_OUTER_TPIDr_GET(r) (r).ing_outer_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_OUTER_TPIDr_TPIDf_GET(r) (((r).ing_outer_tpid[0]) & 0xffff)
#define BCM53324_A0_ING_OUTER_TPIDr_TPIDf_SET(r,f) (r).ing_outer_tpid[0]=(((r).ing_outer_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ING_OUTER_TPID.
 *
 */
#define BCM53324_A0_READ_ING_OUTER_TPIDr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_OUTER_TPIDr+(i),(r._ing_outer_tpid))
#define BCM53324_A0_WRITE_ING_OUTER_TPIDr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_OUTER_TPIDr+(i),&(r._ing_outer_tpid))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_OUTER_TPIDr BCM53324_A0_ING_OUTER_TPIDr
#define ING_OUTER_TPIDr_SIZE BCM53324_A0_ING_OUTER_TPIDr_SIZE
typedef BCM53324_A0_ING_OUTER_TPIDr_t ING_OUTER_TPIDr_t;
#define ING_OUTER_TPIDr_CLR BCM53324_A0_ING_OUTER_TPIDr_CLR
#define ING_OUTER_TPIDr_SET BCM53324_A0_ING_OUTER_TPIDr_SET
#define ING_OUTER_TPIDr_GET BCM53324_A0_ING_OUTER_TPIDr_GET
#define ING_OUTER_TPIDr_TPIDf_GET BCM53324_A0_ING_OUTER_TPIDr_TPIDf_GET
#define ING_OUTER_TPIDr_TPIDf_SET BCM53324_A0_ING_OUTER_TPIDr_TPIDf_SET
#define READ_ING_OUTER_TPIDr BCM53324_A0_READ_ING_OUTER_TPIDr
#define WRITE_ING_OUTER_TPIDr BCM53324_A0_WRITE_ING_OUTER_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_OUTER_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_OUTER_TPID_0
 * BLOCKS:   IPIPE
 * DESC:     Ingress outer TPID matching register #0
 * SIZE:     32
 * FIELDS:
 *     TPID             Outer TPID matching field
 *
 ******************************************************************************/
#define BCM53324_A0_ING_OUTER_TPID_0r 0x0278000c

#define BCM53324_A0_ING_OUTER_TPID_0r_SIZE 4

/*
 * This structure should be used to declare and program ING_OUTER_TPID_0.
 *
 */
typedef union BCM53324_A0_ING_OUTER_TPID_0r_s {
	uint32_t v[1];
	uint32_t ing_outer_tpid_0[1];
	uint32_t _ing_outer_tpid_0;
} BCM53324_A0_ING_OUTER_TPID_0r_t;

#define BCM53324_A0_ING_OUTER_TPID_0r_CLR(r) (r).ing_outer_tpid_0[0] = 0
#define BCM53324_A0_ING_OUTER_TPID_0r_SET(r,d) (r).ing_outer_tpid_0[0] = d
#define BCM53324_A0_ING_OUTER_TPID_0r_GET(r) (r).ing_outer_tpid_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_OUTER_TPID_0r_TPIDf_GET(r) (((r).ing_outer_tpid_0[0]) & 0xffff)
#define BCM53324_A0_ING_OUTER_TPID_0r_TPIDf_SET(r,f) (r).ing_outer_tpid_0[0]=(((r).ing_outer_tpid_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ING_OUTER_TPID_0.
 *
 */
#define BCM53324_A0_READ_ING_OUTER_TPID_0r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_OUTER_TPID_0r,(r._ing_outer_tpid_0))
#define BCM53324_A0_WRITE_ING_OUTER_TPID_0r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_OUTER_TPID_0r,&(r._ing_outer_tpid_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_OUTER_TPID_0r BCM53324_A0_ING_OUTER_TPID_0r
#define ING_OUTER_TPID_0r_SIZE BCM53324_A0_ING_OUTER_TPID_0r_SIZE
typedef BCM53324_A0_ING_OUTER_TPID_0r_t ING_OUTER_TPID_0r_t;
#define ING_OUTER_TPID_0r_CLR BCM53324_A0_ING_OUTER_TPID_0r_CLR
#define ING_OUTER_TPID_0r_SET BCM53324_A0_ING_OUTER_TPID_0r_SET
#define ING_OUTER_TPID_0r_GET BCM53324_A0_ING_OUTER_TPID_0r_GET
#define ING_OUTER_TPID_0r_TPIDf_GET BCM53324_A0_ING_OUTER_TPID_0r_TPIDf_GET
#define ING_OUTER_TPID_0r_TPIDf_SET BCM53324_A0_ING_OUTER_TPID_0r_TPIDf_SET
#define READ_ING_OUTER_TPID_0r BCM53324_A0_READ_ING_OUTER_TPID_0r
#define WRITE_ING_OUTER_TPID_0r BCM53324_A0_WRITE_ING_OUTER_TPID_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_OUTER_TPID_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_OUTER_TPID_1
 * BLOCKS:   IPIPE
 * DESC:     Ingress outer TPID matching register #1
 * SIZE:     32
 * FIELDS:
 *     TPID             Outer TPID matching field
 *
 ******************************************************************************/
#define BCM53324_A0_ING_OUTER_TPID_1r 0x0278000d

#define BCM53324_A0_ING_OUTER_TPID_1r_SIZE 4

/*
 * This structure should be used to declare and program ING_OUTER_TPID_1.
 *
 */
typedef union BCM53324_A0_ING_OUTER_TPID_1r_s {
	uint32_t v[1];
	uint32_t ing_outer_tpid_1[1];
	uint32_t _ing_outer_tpid_1;
} BCM53324_A0_ING_OUTER_TPID_1r_t;

#define BCM53324_A0_ING_OUTER_TPID_1r_CLR(r) (r).ing_outer_tpid_1[0] = 0
#define BCM53324_A0_ING_OUTER_TPID_1r_SET(r,d) (r).ing_outer_tpid_1[0] = d
#define BCM53324_A0_ING_OUTER_TPID_1r_GET(r) (r).ing_outer_tpid_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_OUTER_TPID_1r_TPIDf_GET(r) (((r).ing_outer_tpid_1[0]) & 0xffff)
#define BCM53324_A0_ING_OUTER_TPID_1r_TPIDf_SET(r,f) (r).ing_outer_tpid_1[0]=(((r).ing_outer_tpid_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ING_OUTER_TPID_1.
 *
 */
#define BCM53324_A0_READ_ING_OUTER_TPID_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_OUTER_TPID_1r,(r._ing_outer_tpid_1))
#define BCM53324_A0_WRITE_ING_OUTER_TPID_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_OUTER_TPID_1r,&(r._ing_outer_tpid_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_OUTER_TPID_1r BCM53324_A0_ING_OUTER_TPID_1r
#define ING_OUTER_TPID_1r_SIZE BCM53324_A0_ING_OUTER_TPID_1r_SIZE
typedef BCM53324_A0_ING_OUTER_TPID_1r_t ING_OUTER_TPID_1r_t;
#define ING_OUTER_TPID_1r_CLR BCM53324_A0_ING_OUTER_TPID_1r_CLR
#define ING_OUTER_TPID_1r_SET BCM53324_A0_ING_OUTER_TPID_1r_SET
#define ING_OUTER_TPID_1r_GET BCM53324_A0_ING_OUTER_TPID_1r_GET
#define ING_OUTER_TPID_1r_TPIDf_GET BCM53324_A0_ING_OUTER_TPID_1r_TPIDf_GET
#define ING_OUTER_TPID_1r_TPIDf_SET BCM53324_A0_ING_OUTER_TPID_1r_TPIDf_SET
#define READ_ING_OUTER_TPID_1r BCM53324_A0_READ_ING_OUTER_TPID_1r
#define WRITE_ING_OUTER_TPID_1r BCM53324_A0_WRITE_ING_OUTER_TPID_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_OUTER_TPID_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_OUTER_TPID_2
 * BLOCKS:   IPIPE
 * DESC:     Ingress outer TPID matching register #2
 * SIZE:     32
 * FIELDS:
 *     TPID             Outer TPID matching field
 *
 ******************************************************************************/
#define BCM53324_A0_ING_OUTER_TPID_2r 0x0278000e

#define BCM53324_A0_ING_OUTER_TPID_2r_SIZE 4

/*
 * This structure should be used to declare and program ING_OUTER_TPID_2.
 *
 */
typedef union BCM53324_A0_ING_OUTER_TPID_2r_s {
	uint32_t v[1];
	uint32_t ing_outer_tpid_2[1];
	uint32_t _ing_outer_tpid_2;
} BCM53324_A0_ING_OUTER_TPID_2r_t;

#define BCM53324_A0_ING_OUTER_TPID_2r_CLR(r) (r).ing_outer_tpid_2[0] = 0
#define BCM53324_A0_ING_OUTER_TPID_2r_SET(r,d) (r).ing_outer_tpid_2[0] = d
#define BCM53324_A0_ING_OUTER_TPID_2r_GET(r) (r).ing_outer_tpid_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_OUTER_TPID_2r_TPIDf_GET(r) (((r).ing_outer_tpid_2[0]) & 0xffff)
#define BCM53324_A0_ING_OUTER_TPID_2r_TPIDf_SET(r,f) (r).ing_outer_tpid_2[0]=(((r).ing_outer_tpid_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ING_OUTER_TPID_2.
 *
 */
#define BCM53324_A0_READ_ING_OUTER_TPID_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_OUTER_TPID_2r,(r._ing_outer_tpid_2))
#define BCM53324_A0_WRITE_ING_OUTER_TPID_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_OUTER_TPID_2r,&(r._ing_outer_tpid_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_OUTER_TPID_2r BCM53324_A0_ING_OUTER_TPID_2r
#define ING_OUTER_TPID_2r_SIZE BCM53324_A0_ING_OUTER_TPID_2r_SIZE
typedef BCM53324_A0_ING_OUTER_TPID_2r_t ING_OUTER_TPID_2r_t;
#define ING_OUTER_TPID_2r_CLR BCM53324_A0_ING_OUTER_TPID_2r_CLR
#define ING_OUTER_TPID_2r_SET BCM53324_A0_ING_OUTER_TPID_2r_SET
#define ING_OUTER_TPID_2r_GET BCM53324_A0_ING_OUTER_TPID_2r_GET
#define ING_OUTER_TPID_2r_TPIDf_GET BCM53324_A0_ING_OUTER_TPID_2r_TPIDf_GET
#define ING_OUTER_TPID_2r_TPIDf_SET BCM53324_A0_ING_OUTER_TPID_2r_TPIDf_SET
#define READ_ING_OUTER_TPID_2r BCM53324_A0_READ_ING_OUTER_TPID_2r
#define WRITE_ING_OUTER_TPID_2r BCM53324_A0_WRITE_ING_OUTER_TPID_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_OUTER_TPID_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ING_OUTER_TPID_3
 * BLOCKS:   IPIPE
 * DESC:     Ingress outer TPID matching register #3
 * SIZE:     32
 * FIELDS:
 *     TPID             Outer TPID matching field
 *
 ******************************************************************************/
#define BCM53324_A0_ING_OUTER_TPID_3r 0x0278000f

#define BCM53324_A0_ING_OUTER_TPID_3r_SIZE 4

/*
 * This structure should be used to declare and program ING_OUTER_TPID_3.
 *
 */
typedef union BCM53324_A0_ING_OUTER_TPID_3r_s {
	uint32_t v[1];
	uint32_t ing_outer_tpid_3[1];
	uint32_t _ing_outer_tpid_3;
} BCM53324_A0_ING_OUTER_TPID_3r_t;

#define BCM53324_A0_ING_OUTER_TPID_3r_CLR(r) (r).ing_outer_tpid_3[0] = 0
#define BCM53324_A0_ING_OUTER_TPID_3r_SET(r,d) (r).ing_outer_tpid_3[0] = d
#define BCM53324_A0_ING_OUTER_TPID_3r_GET(r) (r).ing_outer_tpid_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_OUTER_TPID_3r_TPIDf_GET(r) (((r).ing_outer_tpid_3[0]) & 0xffff)
#define BCM53324_A0_ING_OUTER_TPID_3r_TPIDf_SET(r,f) (r).ing_outer_tpid_3[0]=(((r).ing_outer_tpid_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ING_OUTER_TPID_3.
 *
 */
#define BCM53324_A0_READ_ING_OUTER_TPID_3r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ING_OUTER_TPID_3r,(r._ing_outer_tpid_3))
#define BCM53324_A0_WRITE_ING_OUTER_TPID_3r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ING_OUTER_TPID_3r,&(r._ing_outer_tpid_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_OUTER_TPID_3r BCM53324_A0_ING_OUTER_TPID_3r
#define ING_OUTER_TPID_3r_SIZE BCM53324_A0_ING_OUTER_TPID_3r_SIZE
typedef BCM53324_A0_ING_OUTER_TPID_3r_t ING_OUTER_TPID_3r_t;
#define ING_OUTER_TPID_3r_CLR BCM53324_A0_ING_OUTER_TPID_3r_CLR
#define ING_OUTER_TPID_3r_SET BCM53324_A0_ING_OUTER_TPID_3r_SET
#define ING_OUTER_TPID_3r_GET BCM53324_A0_ING_OUTER_TPID_3r_GET
#define ING_OUTER_TPID_3r_TPIDf_GET BCM53324_A0_ING_OUTER_TPID_3r_TPIDf_GET
#define ING_OUTER_TPID_3r_TPIDf_SET BCM53324_A0_ING_OUTER_TPID_3r_TPIDf_SET
#define READ_ING_OUTER_TPID_3r BCM53324_A0_READ_ING_OUTER_TPID_3r
#define WRITE_ING_OUTER_TPID_3r BCM53324_A0_WRITE_ING_OUTER_TPID_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_OUTER_TPID_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  ING_PRI_CNG_MAP
 * BLOCKS:   IPIPE
 * DESC:     Per port ingress priority/CFI mapping table. This table is indexed by {ingress_port, inner_pri_cfi} in case of UNI port and Dt_mode is 1. In case of NNI port or single tagging mode, this is indexed by {ingress_port, outer_pri_cfi} 
 * SIZE:     5
 * FIELDS:
 *     CNG              CNG mapped from incoming packet priority and CFG
 *     PRI              Priority mapped from incoming packet priority and CFI
 *
 ******************************************************************************/
#define BCM53324_A0_ING_PRI_CNG_MAPm 0x04790000

#define BCM53324_A0_ING_PRI_CNG_MAPm_MIN 0
#define BCM53324_A0_ING_PRI_CNG_MAPm_MAX 399
#define BCM53324_A0_ING_PRI_CNG_MAPm_CMAX(u) 399
#define BCM53324_A0_ING_PRI_CNG_MAPm_SIZE 1

/*
 * This structure should be used to declare and program ING_PRI_CNG_MAP.
 *
 */
typedef union BCM53324_A0_ING_PRI_CNG_MAPm_s {
	uint32_t v[1];
	uint32_t ing_pri_cng_map[1];
	uint32_t _ing_pri_cng_map;
} BCM53324_A0_ING_PRI_CNG_MAPm_t;

#define BCM53324_A0_ING_PRI_CNG_MAPm_CLR(r) (r).ing_pri_cng_map[0] = 0
#define BCM53324_A0_ING_PRI_CNG_MAPm_SET(r,d) (r).ing_pri_cng_map[0] = d
#define BCM53324_A0_ING_PRI_CNG_MAPm_GET(r) (r).ing_pri_cng_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ING_PRI_CNG_MAPm_CNGf_GET(r) (((r).ing_pri_cng_map[0]) & 0x3)
#define BCM53324_A0_ING_PRI_CNG_MAPm_CNGf_SET(r,f) (r).ing_pri_cng_map[0]=(((r).ing_pri_cng_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_ING_PRI_CNG_MAPm_PRIf_GET(r) ((((r).ing_pri_cng_map[0]) >> 2) & 0x7)
#define BCM53324_A0_ING_PRI_CNG_MAPm_PRIf_SET(r,f) (r).ing_pri_cng_map[0]=(((r).ing_pri_cng_map[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))

/*
 * These macros can be used to access ING_PRI_CNG_MAP.
 *
 */
#define BCM53324_A0_READ_ING_PRI_CNG_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_ING_PRI_CNG_MAPm,i,(m._ing_pri_cng_map),1)
#define BCM53324_A0_WRITE_ING_PRI_CNG_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_ING_PRI_CNG_MAPm,i,&(m._ing_pri_cng_map),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_PRI_CNG_MAPm BCM53324_A0_ING_PRI_CNG_MAPm
#define ING_PRI_CNG_MAPm_MIN BCM53324_A0_ING_PRI_CNG_MAPm_MIN
#define ING_PRI_CNG_MAPm_MAX BCM53324_A0_ING_PRI_CNG_MAPm_MAX
#define ING_PRI_CNG_MAPm_CMAX(u) BCM53324_A0_ING_PRI_CNG_MAPm_CMAX(u)
#define ING_PRI_CNG_MAPm_SIZE BCM53324_A0_ING_PRI_CNG_MAPm_SIZE
typedef BCM53324_A0_ING_PRI_CNG_MAPm_t ING_PRI_CNG_MAPm_t;
#define ING_PRI_CNG_MAPm_CLR BCM53324_A0_ING_PRI_CNG_MAPm_CLR
#define ING_PRI_CNG_MAPm_SET BCM53324_A0_ING_PRI_CNG_MAPm_SET
#define ING_PRI_CNG_MAPm_GET BCM53324_A0_ING_PRI_CNG_MAPm_GET
#define ING_PRI_CNG_MAPm_CNGf_GET BCM53324_A0_ING_PRI_CNG_MAPm_CNGf_GET
#define ING_PRI_CNG_MAPm_CNGf_SET BCM53324_A0_ING_PRI_CNG_MAPm_CNGf_SET
#define ING_PRI_CNG_MAPm_PRIf_GET BCM53324_A0_ING_PRI_CNG_MAPm_PRIf_GET
#define ING_PRI_CNG_MAPm_PRIf_SET BCM53324_A0_ING_PRI_CNG_MAPm_PRIf_SET
#define READ_ING_PRI_CNG_MAPm BCM53324_A0_READ_ING_PRI_CNG_MAPm
#define WRITE_ING_PRI_CNG_MAPm BCM53324_A0_WRITE_ING_PRI_CNG_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ING_PRI_CNG_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IP0_EP_BISR_RD_DATA
 * BLOCKS:   IPIPE
 * DESC:     Register is written by HW coming from BISR Regs to present data to SW.
 * SIZE:     32
 * FIELDS:
 *     RD_DATA          Data to be written from the BISR regs module for ip0_ep.
 *
 ******************************************************************************/
#define BCM53324_A0_IP0_EP_BISR_RD_DATAr 0x00780008

#define BCM53324_A0_IP0_EP_BISR_RD_DATAr_SIZE 4

/*
 * This structure should be used to declare and program IP0_EP_BISR_RD_DATA.
 *
 */
typedef union BCM53324_A0_IP0_EP_BISR_RD_DATAr_s {
	uint32_t v[1];
	uint32_t ip0_ep_bisr_rd_data[1];
	uint32_t _ip0_ep_bisr_rd_data;
} BCM53324_A0_IP0_EP_BISR_RD_DATAr_t;

#define BCM53324_A0_IP0_EP_BISR_RD_DATAr_CLR(r) (r).ip0_ep_bisr_rd_data[0] = 0
#define BCM53324_A0_IP0_EP_BISR_RD_DATAr_SET(r,d) (r).ip0_ep_bisr_rd_data[0] = d
#define BCM53324_A0_IP0_EP_BISR_RD_DATAr_GET(r) (r).ip0_ep_bisr_rd_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IP0_EP_BISR_RD_DATAr_RD_DATAf_GET(r) ((r).ip0_ep_bisr_rd_data[0])
#define BCM53324_A0_IP0_EP_BISR_RD_DATAr_RD_DATAf_SET(r,f) (r).ip0_ep_bisr_rd_data[0]=((uint32_t)f)

/*
 * These macros can be used to access IP0_EP_BISR_RD_DATA.
 *
 */
#define BCM53324_A0_READ_IP0_EP_BISR_RD_DATAr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IP0_EP_BISR_RD_DATAr,(r._ip0_ep_bisr_rd_data))
#define BCM53324_A0_WRITE_IP0_EP_BISR_RD_DATAr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IP0_EP_BISR_RD_DATAr,&(r._ip0_ep_bisr_rd_data))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IP0_EP_BISR_RD_DATAr BCM53324_A0_IP0_EP_BISR_RD_DATAr
#define IP0_EP_BISR_RD_DATAr_SIZE BCM53324_A0_IP0_EP_BISR_RD_DATAr_SIZE
typedef BCM53324_A0_IP0_EP_BISR_RD_DATAr_t IP0_EP_BISR_RD_DATAr_t;
#define IP0_EP_BISR_RD_DATAr_CLR BCM53324_A0_IP0_EP_BISR_RD_DATAr_CLR
#define IP0_EP_BISR_RD_DATAr_SET BCM53324_A0_IP0_EP_BISR_RD_DATAr_SET
#define IP0_EP_BISR_RD_DATAr_GET BCM53324_A0_IP0_EP_BISR_RD_DATAr_GET
#define IP0_EP_BISR_RD_DATAr_RD_DATAf_GET BCM53324_A0_IP0_EP_BISR_RD_DATAr_RD_DATAf_GET
#define IP0_EP_BISR_RD_DATAr_RD_DATAf_SET BCM53324_A0_IP0_EP_BISR_RD_DATAr_RD_DATAf_SET
#define READ_IP0_EP_BISR_RD_DATAr BCM53324_A0_READ_IP0_EP_BISR_RD_DATAr
#define WRITE_IP0_EP_BISR_RD_DATAr BCM53324_A0_WRITE_IP0_EP_BISR_RD_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IP0_EP_BISR_RD_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IP1_BISR_RD_DATA
 * BLOCKS:   IPIPE
 * DESC:     Register is written by HW coming from BISR Regs to present data to SW.
 * SIZE:     32
 * FIELDS:
 *     RD_DATA          Data to be written from the BISR regs module for ip1.
 *
 ******************************************************************************/
#define BCM53324_A0_IP1_BISR_RD_DATAr 0x0c780012

#define BCM53324_A0_IP1_BISR_RD_DATAr_SIZE 4

/*
 * This structure should be used to declare and program IP1_BISR_RD_DATA.
 *
 */
typedef union BCM53324_A0_IP1_BISR_RD_DATAr_s {
	uint32_t v[1];
	uint32_t ip1_bisr_rd_data[1];
	uint32_t _ip1_bisr_rd_data;
} BCM53324_A0_IP1_BISR_RD_DATAr_t;

#define BCM53324_A0_IP1_BISR_RD_DATAr_CLR(r) (r).ip1_bisr_rd_data[0] = 0
#define BCM53324_A0_IP1_BISR_RD_DATAr_SET(r,d) (r).ip1_bisr_rd_data[0] = d
#define BCM53324_A0_IP1_BISR_RD_DATAr_GET(r) (r).ip1_bisr_rd_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IP1_BISR_RD_DATAr_RD_DATAf_GET(r) ((r).ip1_bisr_rd_data[0])
#define BCM53324_A0_IP1_BISR_RD_DATAr_RD_DATAf_SET(r,f) (r).ip1_bisr_rd_data[0]=((uint32_t)f)

/*
 * These macros can be used to access IP1_BISR_RD_DATA.
 *
 */
#define BCM53324_A0_READ_IP1_BISR_RD_DATAr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IP1_BISR_RD_DATAr,(r._ip1_bisr_rd_data))
#define BCM53324_A0_WRITE_IP1_BISR_RD_DATAr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IP1_BISR_RD_DATAr,&(r._ip1_bisr_rd_data))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IP1_BISR_RD_DATAr BCM53324_A0_IP1_BISR_RD_DATAr
#define IP1_BISR_RD_DATAr_SIZE BCM53324_A0_IP1_BISR_RD_DATAr_SIZE
typedef BCM53324_A0_IP1_BISR_RD_DATAr_t IP1_BISR_RD_DATAr_t;
#define IP1_BISR_RD_DATAr_CLR BCM53324_A0_IP1_BISR_RD_DATAr_CLR
#define IP1_BISR_RD_DATAr_SET BCM53324_A0_IP1_BISR_RD_DATAr_SET
#define IP1_BISR_RD_DATAr_GET BCM53324_A0_IP1_BISR_RD_DATAr_GET
#define IP1_BISR_RD_DATAr_RD_DATAf_GET BCM53324_A0_IP1_BISR_RD_DATAr_RD_DATAf_GET
#define IP1_BISR_RD_DATAr_RD_DATAf_SET BCM53324_A0_IP1_BISR_RD_DATAr_RD_DATAf_SET
#define READ_IP1_BISR_RD_DATAr BCM53324_A0_READ_IP1_BISR_RD_DATAr
#define WRITE_IP1_BISR_RD_DATAr BCM53324_A0_WRITE_IP1_BISR_RD_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IP1_BISR_RD_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IP2_BISR_RD_DATA
 * BLOCKS:   IPIPE
 * DESC:     Register is written by HW coming from BISR Regs to present data to SW.
 * SIZE:     32
 * FIELDS:
 *     RD_DATA          Data to be written from the BISR regs module for ip2.
 *
 ******************************************************************************/
#define BCM53324_A0_IP2_BISR_RD_DATAr 0x0f780138

#define BCM53324_A0_IP2_BISR_RD_DATAr_SIZE 4

/*
 * This structure should be used to declare and program IP2_BISR_RD_DATA.
 *
 */
typedef union BCM53324_A0_IP2_BISR_RD_DATAr_s {
	uint32_t v[1];
	uint32_t ip2_bisr_rd_data[1];
	uint32_t _ip2_bisr_rd_data;
} BCM53324_A0_IP2_BISR_RD_DATAr_t;

#define BCM53324_A0_IP2_BISR_RD_DATAr_CLR(r) (r).ip2_bisr_rd_data[0] = 0
#define BCM53324_A0_IP2_BISR_RD_DATAr_SET(r,d) (r).ip2_bisr_rd_data[0] = d
#define BCM53324_A0_IP2_BISR_RD_DATAr_GET(r) (r).ip2_bisr_rd_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IP2_BISR_RD_DATAr_RD_DATAf_GET(r) ((r).ip2_bisr_rd_data[0])
#define BCM53324_A0_IP2_BISR_RD_DATAr_RD_DATAf_SET(r,f) (r).ip2_bisr_rd_data[0]=((uint32_t)f)

/*
 * These macros can be used to access IP2_BISR_RD_DATA.
 *
 */
#define BCM53324_A0_READ_IP2_BISR_RD_DATAr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IP2_BISR_RD_DATAr,(r._ip2_bisr_rd_data))
#define BCM53324_A0_WRITE_IP2_BISR_RD_DATAr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IP2_BISR_RD_DATAr,&(r._ip2_bisr_rd_data))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IP2_BISR_RD_DATAr BCM53324_A0_IP2_BISR_RD_DATAr
#define IP2_BISR_RD_DATAr_SIZE BCM53324_A0_IP2_BISR_RD_DATAr_SIZE
typedef BCM53324_A0_IP2_BISR_RD_DATAr_t IP2_BISR_RD_DATAr_t;
#define IP2_BISR_RD_DATAr_CLR BCM53324_A0_IP2_BISR_RD_DATAr_CLR
#define IP2_BISR_RD_DATAr_SET BCM53324_A0_IP2_BISR_RD_DATAr_SET
#define IP2_BISR_RD_DATAr_GET BCM53324_A0_IP2_BISR_RD_DATAr_GET
#define IP2_BISR_RD_DATAr_RD_DATAf_GET BCM53324_A0_IP2_BISR_RD_DATAr_RD_DATAf_GET
#define IP2_BISR_RD_DATAr_RD_DATAf_SET BCM53324_A0_IP2_BISR_RD_DATAr_RD_DATAf_SET
#define READ_IP2_BISR_RD_DATAr BCM53324_A0_READ_IP2_BISR_RD_DATAr
#define WRITE_IP2_BISR_RD_DATAr BCM53324_A0_WRITE_IP2_BISR_RD_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IP2_BISR_RD_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IPARS_TM_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Test Mode bits for PARS stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_FP_UDF        Test Mode bits for fp_udf_table memory
 *     TM_SRC_TRUNK     Test Mode bits for src_trunk_table memory
 *     WW_FP_UDF        Weak Write bit for fp_udf_table memory
 *
 ******************************************************************************/
#define BCM53324_A0_IPARS_TM_REG_1r 0x02780010

#define BCM53324_A0_IPARS_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program IPARS_TM_REG_1.
 *
 */
typedef union BCM53324_A0_IPARS_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t ipars_tm_reg_1[1];
	uint32_t _ipars_tm_reg_1;
} BCM53324_A0_IPARS_TM_REG_1r_t;

#define BCM53324_A0_IPARS_TM_REG_1r_CLR(r) (r).ipars_tm_reg_1[0] = 0
#define BCM53324_A0_IPARS_TM_REG_1r_SET(r,d) (r).ipars_tm_reg_1[0] = d
#define BCM53324_A0_IPARS_TM_REG_1r_GET(r) (r).ipars_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IPARS_TM_REG_1r_TM_FP_UDFf_GET(r) (((r).ipars_tm_reg_1[0]) & 0xf)
#define BCM53324_A0_IPARS_TM_REG_1r_TM_FP_UDFf_SET(r,f) (r).ipars_tm_reg_1[0]=(((r).ipars_tm_reg_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_IPARS_TM_REG_1r_TM_SRC_TRUNKf_GET(r) ((((r).ipars_tm_reg_1[0]) >> 4) & 0xf)
#define BCM53324_A0_IPARS_TM_REG_1r_TM_SRC_TRUNKf_SET(r,f) (r).ipars_tm_reg_1[0]=(((r).ipars_tm_reg_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_IPARS_TM_REG_1r_WW_FP_UDFf_GET(r) ((((r).ipars_tm_reg_1[0]) >> 8) & 0x1)
#define BCM53324_A0_IPARS_TM_REG_1r_WW_FP_UDFf_SET(r,f) (r).ipars_tm_reg_1[0]=(((r).ipars_tm_reg_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access IPARS_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_IPARS_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IPARS_TM_REG_1r,(r._ipars_tm_reg_1))
#define BCM53324_A0_WRITE_IPARS_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IPARS_TM_REG_1r,&(r._ipars_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPARS_TM_REG_1r BCM53324_A0_IPARS_TM_REG_1r
#define IPARS_TM_REG_1r_SIZE BCM53324_A0_IPARS_TM_REG_1r_SIZE
typedef BCM53324_A0_IPARS_TM_REG_1r_t IPARS_TM_REG_1r_t;
#define IPARS_TM_REG_1r_CLR BCM53324_A0_IPARS_TM_REG_1r_CLR
#define IPARS_TM_REG_1r_SET BCM53324_A0_IPARS_TM_REG_1r_SET
#define IPARS_TM_REG_1r_GET BCM53324_A0_IPARS_TM_REG_1r_GET
#define IPARS_TM_REG_1r_TM_FP_UDFf_GET BCM53324_A0_IPARS_TM_REG_1r_TM_FP_UDFf_GET
#define IPARS_TM_REG_1r_TM_FP_UDFf_SET BCM53324_A0_IPARS_TM_REG_1r_TM_FP_UDFf_SET
#define IPARS_TM_REG_1r_TM_SRC_TRUNKf_GET BCM53324_A0_IPARS_TM_REG_1r_TM_SRC_TRUNKf_GET
#define IPARS_TM_REG_1r_TM_SRC_TRUNKf_SET BCM53324_A0_IPARS_TM_REG_1r_TM_SRC_TRUNKf_SET
#define IPARS_TM_REG_1r_WW_FP_UDFf_GET BCM53324_A0_IPARS_TM_REG_1r_WW_FP_UDFf_GET
#define IPARS_TM_REG_1r_WW_FP_UDFf_SET BCM53324_A0_IPARS_TM_REG_1r_WW_FP_UDFf_SET
#define READ_IPARS_TM_REG_1r BCM53324_A0_READ_IPARS_TM_REG_1r
#define WRITE_IPARS_TM_REG_1r BCM53324_A0_WRITE_IPARS_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IPARS_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IPG_HD_BKP_CNTL
 * BLOCKS:   GPORT0
 * DESC:     The control register for HD-BackPressure.
 * SIZE:     32
 * FIELDS:
 *     HD_FC_ENA        When cleared (binary 0), enables back-pressure in half-duplex mode. When set (binary 1), disables back-pressure in half-duplex mode.
 *     HD_FC_BKOFF_OK   Register Bit 1 refers to the application of backoff algorithm during HD backpressure.
 *     IPG_CONFIG_RX    The programmable Rx IPG below which the packets received are dropped graciously. The value is in Bytes for 1/2.5G and Nibbles for 10/100M.
 *
 ******************************************************************************/
#define BCM53324_A0_IPG_HD_BKP_CNTLr 0x00000101

#define BCM53324_A0_IPG_HD_BKP_CNTLr_SIZE 4

/*
 * This structure should be used to declare and program IPG_HD_BKP_CNTL.
 *
 */
typedef union BCM53324_A0_IPG_HD_BKP_CNTLr_s {
	uint32_t v[1];
	uint32_t ipg_hd_bkp_cntl[1];
	uint32_t _ipg_hd_bkp_cntl;
} BCM53324_A0_IPG_HD_BKP_CNTLr_t;

#define BCM53324_A0_IPG_HD_BKP_CNTLr_CLR(r) (r).ipg_hd_bkp_cntl[0] = 0
#define BCM53324_A0_IPG_HD_BKP_CNTLr_SET(r,d) (r).ipg_hd_bkp_cntl[0] = d
#define BCM53324_A0_IPG_HD_BKP_CNTLr_GET(r) (r).ipg_hd_bkp_cntl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IPG_HD_BKP_CNTLr_HD_FC_ENAf_GET(r) (((r).ipg_hd_bkp_cntl[0]) & 0x1)
#define BCM53324_A0_IPG_HD_BKP_CNTLr_HD_FC_ENAf_SET(r,f) (r).ipg_hd_bkp_cntl[0]=(((r).ipg_hd_bkp_cntl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_IPG_HD_BKP_CNTLr_HD_FC_BKOFF_OKf_GET(r) ((((r).ipg_hd_bkp_cntl[0]) >> 1) & 0x1)
#define BCM53324_A0_IPG_HD_BKP_CNTLr_HD_FC_BKOFF_OKf_SET(r,f) (r).ipg_hd_bkp_cntl[0]=(((r).ipg_hd_bkp_cntl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_IPG_HD_BKP_CNTLr_IPG_CONFIG_RXf_GET(r) ((((r).ipg_hd_bkp_cntl[0]) >> 2) & 0x1f)
#define BCM53324_A0_IPG_HD_BKP_CNTLr_IPG_CONFIG_RXf_SET(r,f) (r).ipg_hd_bkp_cntl[0]=(((r).ipg_hd_bkp_cntl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))

/*
 * These macros can be used to access IPG_HD_BKP_CNTL.
 *
 */
#define BCM53324_A0_READ_IPG_HD_BKP_CNTLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_IPG_HD_BKP_CNTLr,(r._ipg_hd_bkp_cntl))
#define BCM53324_A0_WRITE_IPG_HD_BKP_CNTLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_IPG_HD_BKP_CNTLr,&(r._ipg_hd_bkp_cntl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPG_HD_BKP_CNTLr BCM53324_A0_IPG_HD_BKP_CNTLr
#define IPG_HD_BKP_CNTLr_SIZE BCM53324_A0_IPG_HD_BKP_CNTLr_SIZE
typedef BCM53324_A0_IPG_HD_BKP_CNTLr_t IPG_HD_BKP_CNTLr_t;
#define IPG_HD_BKP_CNTLr_CLR BCM53324_A0_IPG_HD_BKP_CNTLr_CLR
#define IPG_HD_BKP_CNTLr_SET BCM53324_A0_IPG_HD_BKP_CNTLr_SET
#define IPG_HD_BKP_CNTLr_GET BCM53324_A0_IPG_HD_BKP_CNTLr_GET
#define IPG_HD_BKP_CNTLr_HD_FC_ENAf_GET BCM53324_A0_IPG_HD_BKP_CNTLr_HD_FC_ENAf_GET
#define IPG_HD_BKP_CNTLr_HD_FC_ENAf_SET BCM53324_A0_IPG_HD_BKP_CNTLr_HD_FC_ENAf_SET
#define IPG_HD_BKP_CNTLr_HD_FC_BKOFF_OKf_GET BCM53324_A0_IPG_HD_BKP_CNTLr_HD_FC_BKOFF_OKf_GET
#define IPG_HD_BKP_CNTLr_HD_FC_BKOFF_OKf_SET BCM53324_A0_IPG_HD_BKP_CNTLr_HD_FC_BKOFF_OKf_SET
#define IPG_HD_BKP_CNTLr_IPG_CONFIG_RXf_GET BCM53324_A0_IPG_HD_BKP_CNTLr_IPG_CONFIG_RXf_GET
#define IPG_HD_BKP_CNTLr_IPG_CONFIG_RXf_SET BCM53324_A0_IPG_HD_BKP_CNTLr_IPG_CONFIG_RXf_SET
#define READ_IPG_HD_BKP_CNTLr BCM53324_A0_READ_IPG_HD_BKP_CNTLr
#define WRITE_IPG_HD_BKP_CNTLr BCM53324_A0_WRITE_IPG_HD_BKP_CNTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IPG_HD_BKP_CNTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IRSEL_TM_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Test Mode bits for RSEL stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_L3_ECMP       Test Mode bits for L3_ECMP memory
 *     TM_ING_L3_NEXT_HOP Test Mode bits for ING_L3_NEXT_HOP memory
 *
 ******************************************************************************/
#define BCM53324_A0_IRSEL_TM_REG_1r 0x0e780000

#define BCM53324_A0_IRSEL_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program IRSEL_TM_REG_1.
 *
 */
typedef union BCM53324_A0_IRSEL_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t irsel_tm_reg_1[1];
	uint32_t _irsel_tm_reg_1;
} BCM53324_A0_IRSEL_TM_REG_1r_t;

#define BCM53324_A0_IRSEL_TM_REG_1r_CLR(r) (r).irsel_tm_reg_1[0] = 0
#define BCM53324_A0_IRSEL_TM_REG_1r_SET(r,d) (r).irsel_tm_reg_1[0] = d
#define BCM53324_A0_IRSEL_TM_REG_1r_GET(r) (r).irsel_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IRSEL_TM_REG_1r_TM_L3_ECMPf_GET(r) (((r).irsel_tm_reg_1[0]) & 0xf)
#define BCM53324_A0_IRSEL_TM_REG_1r_TM_L3_ECMPf_SET(r,f) (r).irsel_tm_reg_1[0]=(((r).irsel_tm_reg_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_IRSEL_TM_REG_1r_TM_ING_L3_NEXT_HOPf_GET(r) ((((r).irsel_tm_reg_1[0]) >> 4) & 0xf)
#define BCM53324_A0_IRSEL_TM_REG_1r_TM_ING_L3_NEXT_HOPf_SET(r,f) (r).irsel_tm_reg_1[0]=(((r).irsel_tm_reg_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IRSEL_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_IRSEL_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IRSEL_TM_REG_1r,(r._irsel_tm_reg_1))
#define BCM53324_A0_WRITE_IRSEL_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IRSEL_TM_REG_1r,&(r._irsel_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRSEL_TM_REG_1r BCM53324_A0_IRSEL_TM_REG_1r
#define IRSEL_TM_REG_1r_SIZE BCM53324_A0_IRSEL_TM_REG_1r_SIZE
typedef BCM53324_A0_IRSEL_TM_REG_1r_t IRSEL_TM_REG_1r_t;
#define IRSEL_TM_REG_1r_CLR BCM53324_A0_IRSEL_TM_REG_1r_CLR
#define IRSEL_TM_REG_1r_SET BCM53324_A0_IRSEL_TM_REG_1r_SET
#define IRSEL_TM_REG_1r_GET BCM53324_A0_IRSEL_TM_REG_1r_GET
#define IRSEL_TM_REG_1r_TM_L3_ECMPf_GET BCM53324_A0_IRSEL_TM_REG_1r_TM_L3_ECMPf_GET
#define IRSEL_TM_REG_1r_TM_L3_ECMPf_SET BCM53324_A0_IRSEL_TM_REG_1r_TM_L3_ECMPf_SET
#define IRSEL_TM_REG_1r_TM_ING_L3_NEXT_HOPf_GET BCM53324_A0_IRSEL_TM_REG_1r_TM_ING_L3_NEXT_HOPf_GET
#define IRSEL_TM_REG_1r_TM_ING_L3_NEXT_HOPf_SET BCM53324_A0_IRSEL_TM_REG_1r_TM_ING_L3_NEXT_HOPf_SET
#define READ_IRSEL_TM_REG_1r BCM53324_A0_READ_IRSEL_TM_REG_1r
#define WRITE_IRSEL_TM_REG_1r BCM53324_A0_WRITE_IRSEL_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IRSEL_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ISW1_TM_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Test Mode bits for SW1 stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_L3_HIT        Test Mode bits for L3_HIT memory
 *     TM_DEFIP_HIT     Test Mode bits for DEFIP_HIT memory
 *     TM_FP_PORT_FIELD_SELECT Test Mode bits for FP_PORT_FIELD_SELECT memory
 *     TM_DSCP_TABLE    Test Mode bits for DSCP_TABLE memory
 *     WW_DSCP_TABLE    Weak Write bits for DSCP_TABLE memory
 *
 ******************************************************************************/
#define BCM53324_A0_ISW1_TM_REG_1r 0x0c78000f

#define BCM53324_A0_ISW1_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program ISW1_TM_REG_1.
 *
 */
typedef union BCM53324_A0_ISW1_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t isw1_tm_reg_1[1];
	uint32_t _isw1_tm_reg_1;
} BCM53324_A0_ISW1_TM_REG_1r_t;

#define BCM53324_A0_ISW1_TM_REG_1r_CLR(r) (r).isw1_tm_reg_1[0] = 0
#define BCM53324_A0_ISW1_TM_REG_1r_SET(r,d) (r).isw1_tm_reg_1[0] = d
#define BCM53324_A0_ISW1_TM_REG_1r_GET(r) (r).isw1_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ISW1_TM_REG_1r_TM_L3_HITf_GET(r) (((r).isw1_tm_reg_1[0]) & 0xff)
#define BCM53324_A0_ISW1_TM_REG_1r_TM_L3_HITf_SET(r,f) (r).isw1_tm_reg_1[0]=(((r).isw1_tm_reg_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_ISW1_TM_REG_1r_TM_DEFIP_HITf_GET(r) ((((r).isw1_tm_reg_1[0]) >> 8) & 0xf)
#define BCM53324_A0_ISW1_TM_REG_1r_TM_DEFIP_HITf_SET(r,f) (r).isw1_tm_reg_1[0]=(((r).isw1_tm_reg_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_ISW1_TM_REG_1r_TM_FP_PORT_FIELD_SELECTf_GET(r) ((((r).isw1_tm_reg_1[0]) >> 12) & 0xf)
#define BCM53324_A0_ISW1_TM_REG_1r_TM_FP_PORT_FIELD_SELECTf_SET(r,f) (r).isw1_tm_reg_1[0]=(((r).isw1_tm_reg_1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_ISW1_TM_REG_1r_TM_DSCP_TABLEf_GET(r) ((((r).isw1_tm_reg_1[0]) >> 16) & 0xf)
#define BCM53324_A0_ISW1_TM_REG_1r_TM_DSCP_TABLEf_SET(r,f) (r).isw1_tm_reg_1[0]=(((r).isw1_tm_reg_1[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_ISW1_TM_REG_1r_WW_DSCP_TABLEf_GET(r) ((((r).isw1_tm_reg_1[0]) >> 20) & 0x1)
#define BCM53324_A0_ISW1_TM_REG_1r_WW_DSCP_TABLEf_SET(r,f) (r).isw1_tm_reg_1[0]=(((r).isw1_tm_reg_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access ISW1_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_ISW1_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ISW1_TM_REG_1r,(r._isw1_tm_reg_1))
#define BCM53324_A0_WRITE_ISW1_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ISW1_TM_REG_1r,&(r._isw1_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISW1_TM_REG_1r BCM53324_A0_ISW1_TM_REG_1r
#define ISW1_TM_REG_1r_SIZE BCM53324_A0_ISW1_TM_REG_1r_SIZE
typedef BCM53324_A0_ISW1_TM_REG_1r_t ISW1_TM_REG_1r_t;
#define ISW1_TM_REG_1r_CLR BCM53324_A0_ISW1_TM_REG_1r_CLR
#define ISW1_TM_REG_1r_SET BCM53324_A0_ISW1_TM_REG_1r_SET
#define ISW1_TM_REG_1r_GET BCM53324_A0_ISW1_TM_REG_1r_GET
#define ISW1_TM_REG_1r_TM_L3_HITf_GET BCM53324_A0_ISW1_TM_REG_1r_TM_L3_HITf_GET
#define ISW1_TM_REG_1r_TM_L3_HITf_SET BCM53324_A0_ISW1_TM_REG_1r_TM_L3_HITf_SET
#define ISW1_TM_REG_1r_TM_DEFIP_HITf_GET BCM53324_A0_ISW1_TM_REG_1r_TM_DEFIP_HITf_GET
#define ISW1_TM_REG_1r_TM_DEFIP_HITf_SET BCM53324_A0_ISW1_TM_REG_1r_TM_DEFIP_HITf_SET
#define ISW1_TM_REG_1r_TM_FP_PORT_FIELD_SELECTf_GET BCM53324_A0_ISW1_TM_REG_1r_TM_FP_PORT_FIELD_SELECTf_GET
#define ISW1_TM_REG_1r_TM_FP_PORT_FIELD_SELECTf_SET BCM53324_A0_ISW1_TM_REG_1r_TM_FP_PORT_FIELD_SELECTf_SET
#define ISW1_TM_REG_1r_TM_DSCP_TABLEf_GET BCM53324_A0_ISW1_TM_REG_1r_TM_DSCP_TABLEf_GET
#define ISW1_TM_REG_1r_TM_DSCP_TABLEf_SET BCM53324_A0_ISW1_TM_REG_1r_TM_DSCP_TABLEf_SET
#define ISW1_TM_REG_1r_WW_DSCP_TABLEf_GET BCM53324_A0_ISW1_TM_REG_1r_WW_DSCP_TABLEf_GET
#define ISW1_TM_REG_1r_WW_DSCP_TABLEf_SET BCM53324_A0_ISW1_TM_REG_1r_WW_DSCP_TABLEf_SET
#define READ_ISW1_TM_REG_1r BCM53324_A0_READ_ISW1_TM_REG_1r
#define WRITE_ISW1_TM_REG_1r BCM53324_A0_WRITE_ISW1_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ISW1_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  ISW2_TM_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Test Mode and Weak Write bits for SW2 stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_EGR_MASK      Test Mode bits for EGR_MASK memory
 *     WW_EGR_MASK      Weak Write bit for EGR_MASK memory
 *
 ******************************************************************************/
#define BCM53324_A0_ISW2_TM_REG_1r 0x0f780137

#define BCM53324_A0_ISW2_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program ISW2_TM_REG_1.
 *
 */
typedef union BCM53324_A0_ISW2_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t isw2_tm_reg_1[1];
	uint32_t _isw2_tm_reg_1;
} BCM53324_A0_ISW2_TM_REG_1r_t;

#define BCM53324_A0_ISW2_TM_REG_1r_CLR(r) (r).isw2_tm_reg_1[0] = 0
#define BCM53324_A0_ISW2_TM_REG_1r_SET(r,d) (r).isw2_tm_reg_1[0] = d
#define BCM53324_A0_ISW2_TM_REG_1r_GET(r) (r).isw2_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_ISW2_TM_REG_1r_TM_EGR_MASKf_GET(r) (((r).isw2_tm_reg_1[0]) & 0xf)
#define BCM53324_A0_ISW2_TM_REG_1r_TM_EGR_MASKf_SET(r,f) (r).isw2_tm_reg_1[0]=(((r).isw2_tm_reg_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_ISW2_TM_REG_1r_WW_EGR_MASKf_GET(r) ((((r).isw2_tm_reg_1[0]) >> 4) & 0x1)
#define BCM53324_A0_ISW2_TM_REG_1r_WW_EGR_MASKf_SET(r,f) (r).isw2_tm_reg_1[0]=(((r).isw2_tm_reg_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access ISW2_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_ISW2_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_ISW2_TM_REG_1r,(r._isw2_tm_reg_1))
#define BCM53324_A0_WRITE_ISW2_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_ISW2_TM_REG_1r,&(r._isw2_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISW2_TM_REG_1r BCM53324_A0_ISW2_TM_REG_1r
#define ISW2_TM_REG_1r_SIZE BCM53324_A0_ISW2_TM_REG_1r_SIZE
typedef BCM53324_A0_ISW2_TM_REG_1r_t ISW2_TM_REG_1r_t;
#define ISW2_TM_REG_1r_CLR BCM53324_A0_ISW2_TM_REG_1r_CLR
#define ISW2_TM_REG_1r_SET BCM53324_A0_ISW2_TM_REG_1r_SET
#define ISW2_TM_REG_1r_GET BCM53324_A0_ISW2_TM_REG_1r_GET
#define ISW2_TM_REG_1r_TM_EGR_MASKf_GET BCM53324_A0_ISW2_TM_REG_1r_TM_EGR_MASKf_GET
#define ISW2_TM_REG_1r_TM_EGR_MASKf_SET BCM53324_A0_ISW2_TM_REG_1r_TM_EGR_MASKf_SET
#define ISW2_TM_REG_1r_WW_EGR_MASKf_GET BCM53324_A0_ISW2_TM_REG_1r_WW_EGR_MASKf_GET
#define ISW2_TM_REG_1r_WW_EGR_MASKf_SET BCM53324_A0_ISW2_TM_REG_1r_WW_EGR_MASKf_SET
#define READ_ISW2_TM_REG_1r BCM53324_A0_READ_ISW2_TM_REG_1r
#define WRITE_ISW2_TM_REG_1r BCM53324_A0_WRITE_ISW2_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_ISW2_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IVLAN_TM_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Test Mode and Weak Write bits for VLAN stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_VLAN          Test Mode bits for VLAN memory
 *     TM_VLAN_STG      Test Mode bits for VLAN_STG memory
 *     WW_VLAN          Weak Write bit for VLAN memory
 *     WW_VLAN_STG      Weak Write bit for VLAN_STG memory
 *
 ******************************************************************************/
#define BCM53324_A0_IVLAN_TM_REG_1r 0x05780000

#define BCM53324_A0_IVLAN_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program IVLAN_TM_REG_1.
 *
 */
typedef union BCM53324_A0_IVLAN_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t ivlan_tm_reg_1[1];
	uint32_t _ivlan_tm_reg_1;
} BCM53324_A0_IVLAN_TM_REG_1r_t;

#define BCM53324_A0_IVLAN_TM_REG_1r_CLR(r) (r).ivlan_tm_reg_1[0] = 0
#define BCM53324_A0_IVLAN_TM_REG_1r_SET(r,d) (r).ivlan_tm_reg_1[0] = d
#define BCM53324_A0_IVLAN_TM_REG_1r_GET(r) (r).ivlan_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IVLAN_TM_REG_1r_TM_VLANf_GET(r) (((r).ivlan_tm_reg_1[0]) & 0xf)
#define BCM53324_A0_IVLAN_TM_REG_1r_TM_VLANf_SET(r,f) (r).ivlan_tm_reg_1[0]=(((r).ivlan_tm_reg_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_IVLAN_TM_REG_1r_TM_VLAN_STGf_GET(r) ((((r).ivlan_tm_reg_1[0]) >> 4) & 0xf)
#define BCM53324_A0_IVLAN_TM_REG_1r_TM_VLAN_STGf_SET(r,f) (r).ivlan_tm_reg_1[0]=(((r).ivlan_tm_reg_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_IVLAN_TM_REG_1r_WW_VLANf_GET(r) ((((r).ivlan_tm_reg_1[0]) >> 8) & 0x1)
#define BCM53324_A0_IVLAN_TM_REG_1r_WW_VLANf_SET(r,f) (r).ivlan_tm_reg_1[0]=(((r).ivlan_tm_reg_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_IVLAN_TM_REG_1r_WW_VLAN_STGf_GET(r) ((((r).ivlan_tm_reg_1[0]) >> 9) & 0x1)
#define BCM53324_A0_IVLAN_TM_REG_1r_WW_VLAN_STGf_SET(r,f) (r).ivlan_tm_reg_1[0]=(((r).ivlan_tm_reg_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access IVLAN_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_IVLAN_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IVLAN_TM_REG_1r,(r._ivlan_tm_reg_1))
#define BCM53324_A0_WRITE_IVLAN_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IVLAN_TM_REG_1r,&(r._ivlan_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVLAN_TM_REG_1r BCM53324_A0_IVLAN_TM_REG_1r
#define IVLAN_TM_REG_1r_SIZE BCM53324_A0_IVLAN_TM_REG_1r_SIZE
typedef BCM53324_A0_IVLAN_TM_REG_1r_t IVLAN_TM_REG_1r_t;
#define IVLAN_TM_REG_1r_CLR BCM53324_A0_IVLAN_TM_REG_1r_CLR
#define IVLAN_TM_REG_1r_SET BCM53324_A0_IVLAN_TM_REG_1r_SET
#define IVLAN_TM_REG_1r_GET BCM53324_A0_IVLAN_TM_REG_1r_GET
#define IVLAN_TM_REG_1r_TM_VLANf_GET BCM53324_A0_IVLAN_TM_REG_1r_TM_VLANf_GET
#define IVLAN_TM_REG_1r_TM_VLANf_SET BCM53324_A0_IVLAN_TM_REG_1r_TM_VLANf_SET
#define IVLAN_TM_REG_1r_TM_VLAN_STGf_GET BCM53324_A0_IVLAN_TM_REG_1r_TM_VLAN_STGf_GET
#define IVLAN_TM_REG_1r_TM_VLAN_STGf_SET BCM53324_A0_IVLAN_TM_REG_1r_TM_VLAN_STGf_SET
#define IVLAN_TM_REG_1r_WW_VLANf_GET BCM53324_A0_IVLAN_TM_REG_1r_WW_VLANf_GET
#define IVLAN_TM_REG_1r_WW_VLANf_SET BCM53324_A0_IVLAN_TM_REG_1r_WW_VLANf_SET
#define IVLAN_TM_REG_1r_WW_VLAN_STGf_GET BCM53324_A0_IVLAN_TM_REG_1r_WW_VLAN_STGf_GET
#define IVLAN_TM_REG_1r_WW_VLAN_STGf_SET BCM53324_A0_IVLAN_TM_REG_1r_WW_VLAN_STGf_SET
#define READ_IVLAN_TM_REG_1r BCM53324_A0_READ_IVLAN_TM_REG_1r
#define WRITE_IVLAN_TM_REG_1r BCM53324_A0_WRITE_IVLAN_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IVLAN_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IVXLT_TM_REG_1
 * BLOCKS:   IPIPE
 * DESC:     Test Mode bits for VXLT stage memories
 * SIZE:     32
 * FIELDS:
 *     TM_XLATE_DATA    Test Mode bits for VLAN_XLATE_DATA memory
 *     TM_SUBNET_DATA   Test Mode bits for VLAN_SUBNET_DATA memory
 *     TM_VLAN_MAC      Test Mode bits for VLAN_MAC memory
 *     TM_PROTOCOL_DATA Test Mode bits for VLAN_PROTOCOL_DATA memory
 *     TM_CNG_MAP       Test Mode bits for ING_PRI_CNG_MAP memory
 *     WW_PROTOCOL_DATA Weak Write bits for VLAN_PROTOCOL_DATA memory
 *     WW_CNG_MAP       Weak Write bits for ING_PRI_CNG_MAP memory
 *
 ******************************************************************************/
#define BCM53324_A0_IVXLT_TM_REG_1r 0x04780011

#define BCM53324_A0_IVXLT_TM_REG_1r_SIZE 4

/*
 * This structure should be used to declare and program IVXLT_TM_REG_1.
 *
 */
typedef union BCM53324_A0_IVXLT_TM_REG_1r_s {
	uint32_t v[1];
	uint32_t ivxlt_tm_reg_1[1];
	uint32_t _ivxlt_tm_reg_1;
} BCM53324_A0_IVXLT_TM_REG_1r_t;

#define BCM53324_A0_IVXLT_TM_REG_1r_CLR(r) (r).ivxlt_tm_reg_1[0] = 0
#define BCM53324_A0_IVXLT_TM_REG_1r_SET(r,d) (r).ivxlt_tm_reg_1[0] = d
#define BCM53324_A0_IVXLT_TM_REG_1r_GET(r) (r).ivxlt_tm_reg_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_XLATE_DATAf_GET(r) (((r).ivxlt_tm_reg_1[0]) & 0xf)
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_XLATE_DATAf_SET(r,f) (r).ivxlt_tm_reg_1[0]=(((r).ivxlt_tm_reg_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_SUBNET_DATAf_GET(r) ((((r).ivxlt_tm_reg_1[0]) >> 4) & 0xf)
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_SUBNET_DATAf_SET(r,f) (r).ivxlt_tm_reg_1[0]=(((r).ivxlt_tm_reg_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_VLAN_MACf_GET(r) ((((r).ivxlt_tm_reg_1[0]) >> 8) & 0xf)
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_VLAN_MACf_SET(r,f) (r).ivxlt_tm_reg_1[0]=(((r).ivxlt_tm_reg_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_PROTOCOL_DATAf_GET(r) ((((r).ivxlt_tm_reg_1[0]) >> 12) & 0xf)
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_PROTOCOL_DATAf_SET(r,f) (r).ivxlt_tm_reg_1[0]=(((r).ivxlt_tm_reg_1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_CNG_MAPf_GET(r) ((((r).ivxlt_tm_reg_1[0]) >> 16) & 0xf)
#define BCM53324_A0_IVXLT_TM_REG_1r_TM_CNG_MAPf_SET(r,f) (r).ivxlt_tm_reg_1[0]=(((r).ivxlt_tm_reg_1[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_IVXLT_TM_REG_1r_WW_PROTOCOL_DATAf_GET(r) ((((r).ivxlt_tm_reg_1[0]) >> 20) & 0x1)
#define BCM53324_A0_IVXLT_TM_REG_1r_WW_PROTOCOL_DATAf_SET(r,f) (r).ivxlt_tm_reg_1[0]=(((r).ivxlt_tm_reg_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_IVXLT_TM_REG_1r_WW_CNG_MAPf_GET(r) ((((r).ivxlt_tm_reg_1[0]) >> 21) & 0x1)
#define BCM53324_A0_IVXLT_TM_REG_1r_WW_CNG_MAPf_SET(r,f) (r).ivxlt_tm_reg_1[0]=(((r).ivxlt_tm_reg_1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))

/*
 * These macros can be used to access IVXLT_TM_REG_1.
 *
 */
#define BCM53324_A0_READ_IVXLT_TM_REG_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IVXLT_TM_REG_1r,(r._ivxlt_tm_reg_1))
#define BCM53324_A0_WRITE_IVXLT_TM_REG_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IVXLT_TM_REG_1r,&(r._ivxlt_tm_reg_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVXLT_TM_REG_1r BCM53324_A0_IVXLT_TM_REG_1r
#define IVXLT_TM_REG_1r_SIZE BCM53324_A0_IVXLT_TM_REG_1r_SIZE
typedef BCM53324_A0_IVXLT_TM_REG_1r_t IVXLT_TM_REG_1r_t;
#define IVXLT_TM_REG_1r_CLR BCM53324_A0_IVXLT_TM_REG_1r_CLR
#define IVXLT_TM_REG_1r_SET BCM53324_A0_IVXLT_TM_REG_1r_SET
#define IVXLT_TM_REG_1r_GET BCM53324_A0_IVXLT_TM_REG_1r_GET
#define IVXLT_TM_REG_1r_TM_XLATE_DATAf_GET BCM53324_A0_IVXLT_TM_REG_1r_TM_XLATE_DATAf_GET
#define IVXLT_TM_REG_1r_TM_XLATE_DATAf_SET BCM53324_A0_IVXLT_TM_REG_1r_TM_XLATE_DATAf_SET
#define IVXLT_TM_REG_1r_TM_SUBNET_DATAf_GET BCM53324_A0_IVXLT_TM_REG_1r_TM_SUBNET_DATAf_GET
#define IVXLT_TM_REG_1r_TM_SUBNET_DATAf_SET BCM53324_A0_IVXLT_TM_REG_1r_TM_SUBNET_DATAf_SET
#define IVXLT_TM_REG_1r_TM_VLAN_MACf_GET BCM53324_A0_IVXLT_TM_REG_1r_TM_VLAN_MACf_GET
#define IVXLT_TM_REG_1r_TM_VLAN_MACf_SET BCM53324_A0_IVXLT_TM_REG_1r_TM_VLAN_MACf_SET
#define IVXLT_TM_REG_1r_TM_PROTOCOL_DATAf_GET BCM53324_A0_IVXLT_TM_REG_1r_TM_PROTOCOL_DATAf_GET
#define IVXLT_TM_REG_1r_TM_PROTOCOL_DATAf_SET BCM53324_A0_IVXLT_TM_REG_1r_TM_PROTOCOL_DATAf_SET
#define IVXLT_TM_REG_1r_TM_CNG_MAPf_GET BCM53324_A0_IVXLT_TM_REG_1r_TM_CNG_MAPf_GET
#define IVXLT_TM_REG_1r_TM_CNG_MAPf_SET BCM53324_A0_IVXLT_TM_REG_1r_TM_CNG_MAPf_SET
#define IVXLT_TM_REG_1r_WW_PROTOCOL_DATAf_GET BCM53324_A0_IVXLT_TM_REG_1r_WW_PROTOCOL_DATAf_GET
#define IVXLT_TM_REG_1r_WW_PROTOCOL_DATAf_SET BCM53324_A0_IVXLT_TM_REG_1r_WW_PROTOCOL_DATAf_SET
#define IVXLT_TM_REG_1r_WW_CNG_MAPf_GET BCM53324_A0_IVXLT_TM_REG_1r_WW_CNG_MAPf_GET
#define IVXLT_TM_REG_1r_WW_CNG_MAPf_SET BCM53324_A0_IVXLT_TM_REG_1r_WW_CNG_MAPf_SET
#define READ_IVXLT_TM_REG_1r BCM53324_A0_READ_IVXLT_TM_REG_1r
#define WRITE_IVXLT_TM_REG_1r BCM53324_A0_WRITE_IVXLT_TM_REG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IVXLT_TM_REG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  IVXLT_TM_REG_2
 * BLOCKS:   IPIPE
 * DESC:     Test Mode bits for VXLT stage CAMS
 * SIZE:     32
 * FIELDS:
 *     TM_VLAN_SUBNET_CAM Test Mode bits for VLAN_SUBNET CAM0 AND CAM1
 *     TM_VLAN_XLATE_CAM Test Mode bits for VLAN_xlate cam 
 *
 ******************************************************************************/
#define BCM53324_A0_IVXLT_TM_REG_2r 0x04780012

#define BCM53324_A0_IVXLT_TM_REG_2r_SIZE 4

/*
 * This structure should be used to declare and program IVXLT_TM_REG_2.
 *
 */
typedef union BCM53324_A0_IVXLT_TM_REG_2r_s {
	uint32_t v[1];
	uint32_t ivxlt_tm_reg_2[1];
	uint32_t _ivxlt_tm_reg_2;
} BCM53324_A0_IVXLT_TM_REG_2r_t;

#define BCM53324_A0_IVXLT_TM_REG_2r_CLR(r) (r).ivxlt_tm_reg_2[0] = 0
#define BCM53324_A0_IVXLT_TM_REG_2r_SET(r,d) (r).ivxlt_tm_reg_2[0] = d
#define BCM53324_A0_IVXLT_TM_REG_2r_GET(r) (r).ivxlt_tm_reg_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_IVXLT_TM_REG_2r_TM_VLAN_SUBNET_CAMf_GET(r) (((r).ivxlt_tm_reg_2[0]) & 0x7ff)
#define BCM53324_A0_IVXLT_TM_REG_2r_TM_VLAN_SUBNET_CAMf_SET(r,f) (r).ivxlt_tm_reg_2[0]=(((r).ivxlt_tm_reg_2[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_IVXLT_TM_REG_2r_TM_VLAN_XLATE_CAMf_GET(r) ((((r).ivxlt_tm_reg_2[0]) >> 11) & 0x7ff)
#define BCM53324_A0_IVXLT_TM_REG_2r_TM_VLAN_XLATE_CAMf_SET(r,f) (r).ivxlt_tm_reg_2[0]=(((r).ivxlt_tm_reg_2[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))

/*
 * These macros can be used to access IVXLT_TM_REG_2.
 *
 */
#define BCM53324_A0_READ_IVXLT_TM_REG_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_IVXLT_TM_REG_2r,(r._ivxlt_tm_reg_2))
#define BCM53324_A0_WRITE_IVXLT_TM_REG_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_IVXLT_TM_REG_2r,&(r._ivxlt_tm_reg_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IVXLT_TM_REG_2r BCM53324_A0_IVXLT_TM_REG_2r
#define IVXLT_TM_REG_2r_SIZE BCM53324_A0_IVXLT_TM_REG_2r_SIZE
typedef BCM53324_A0_IVXLT_TM_REG_2r_t IVXLT_TM_REG_2r_t;
#define IVXLT_TM_REG_2r_CLR BCM53324_A0_IVXLT_TM_REG_2r_CLR
#define IVXLT_TM_REG_2r_SET BCM53324_A0_IVXLT_TM_REG_2r_SET
#define IVXLT_TM_REG_2r_GET BCM53324_A0_IVXLT_TM_REG_2r_GET
#define IVXLT_TM_REG_2r_TM_VLAN_SUBNET_CAMf_GET BCM53324_A0_IVXLT_TM_REG_2r_TM_VLAN_SUBNET_CAMf_GET
#define IVXLT_TM_REG_2r_TM_VLAN_SUBNET_CAMf_SET BCM53324_A0_IVXLT_TM_REG_2r_TM_VLAN_SUBNET_CAMf_SET
#define IVXLT_TM_REG_2r_TM_VLAN_XLATE_CAMf_GET BCM53324_A0_IVXLT_TM_REG_2r_TM_VLAN_XLATE_CAMf_GET
#define IVXLT_TM_REG_2r_TM_VLAN_XLATE_CAMf_SET BCM53324_A0_IVXLT_TM_REG_2r_TM_VLAN_XLATE_CAMf_SET
#define READ_IVXLT_TM_REG_2r BCM53324_A0_READ_IVXLT_TM_REG_2r
#define WRITE_IVXLT_TM_REG_2r BCM53324_A0_WRITE_IVXLT_TM_REG_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_IVXLT_TM_REG_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2MC
 * BLOCKS:   IPIPE
 * DESC:     L2 Multicast table. Indexed with mc index obtained from l2 tables.
 * SIZE:     29
 * FIELDS:
 *     PORT_BITMAP      Multicast port membership
 *     PORT_BITMAP_LO   Multicast port membership
 *     VALID            Indicates that the entry is valid
 *     HIGIG_TRUNK_OVERRIDE Higig Trunk Override indication
 *     EVEN_PARITY      Even parity for the L2MC RAM fields
 *
 ******************************************************************************/
#define BCM53324_A0_L2MCm 0x07700000

#define BCM53324_A0_L2MCm_MIN 0
#define BCM53324_A0_L2MCm_MAX 255
#define BCM53324_A0_L2MCm_CMAX(u) 255
#define BCM53324_A0_L2MCm_SIZE 4

/*
 * This structure should be used to declare and program L2MC.
 *
 */
typedef union BCM53324_A0_L2MCm_s {
	uint32_t v[1];
	uint32_t l2mc[1];
	uint32_t _l2mc;
} BCM53324_A0_L2MCm_t;

#define BCM53324_A0_L2MCm_CLR(r) (r).l2mc[0] = 0
#define BCM53324_A0_L2MCm_SET(r,d) (r).l2mc[0] = d
#define BCM53324_A0_L2MCm_GET(r) (r).l2mc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2MCm_PORT_BITMAPf_GET(r) (((r).l2mc[0]) & 0x1ffffff)
#define BCM53324_A0_L2MCm_PORT_BITMAPf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_L2MCm_PORT_BITMAP_LOf_GET(r) (((r).l2mc[0]) & 0x1ffffff)
#define BCM53324_A0_L2MCm_PORT_BITMAP_LOf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_L2MCm_VALIDf_GET(r) ((((r).l2mc[0]) >> 25) & 0x1)
#define BCM53324_A0_L2MCm_VALIDf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).l2mc[0]) >> 26) & 0x3)
#define BCM53324_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53324_A0_L2MCm_EVEN_PARITYf_GET(r) ((((r).l2mc[0]) >> 28) & 0x1)
#define BCM53324_A0_L2MCm_EVEN_PARITYf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access L2MC.
 *
 */
#define BCM53324_A0_READ_L2MCm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2MCm,i,(m._l2mc),1)
#define BCM53324_A0_WRITE_L2MCm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2MCm,i,&(m._l2mc),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MCm BCM53324_A0_L2MCm
#define L2MCm_MIN BCM53324_A0_L2MCm_MIN
#define L2MCm_MAX BCM53324_A0_L2MCm_MAX
#define L2MCm_CMAX(u) BCM53324_A0_L2MCm_CMAX(u)
#define L2MCm_SIZE BCM53324_A0_L2MCm_SIZE
typedef BCM53324_A0_L2MCm_t L2MCm_t;
#define L2MCm_CLR BCM53324_A0_L2MCm_CLR
#define L2MCm_SET BCM53324_A0_L2MCm_SET
#define L2MCm_GET BCM53324_A0_L2MCm_GET
#define L2MCm_PORT_BITMAPf_GET BCM53324_A0_L2MCm_PORT_BITMAPf_GET
#define L2MCm_PORT_BITMAPf_SET BCM53324_A0_L2MCm_PORT_BITMAPf_SET
#define L2MCm_PORT_BITMAP_LOf_GET BCM53324_A0_L2MCm_PORT_BITMAP_LOf_GET
#define L2MCm_PORT_BITMAP_LOf_SET BCM53324_A0_L2MCm_PORT_BITMAP_LOf_SET
#define L2MCm_VALIDf_GET BCM53324_A0_L2MCm_VALIDf_GET
#define L2MCm_VALIDf_SET BCM53324_A0_L2MCm_VALIDf_SET
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_GET BCM53324_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_GET
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_SET BCM53324_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_SET
#define L2MCm_EVEN_PARITYf_GET BCM53324_A0_L2MCm_EVEN_PARITYf_GET
#define L2MCm_EVEN_PARITYf_SET BCM53324_A0_L2MCm_EVEN_PARITYf_SET
#define READ_L2MCm BCM53324_A0_READ_L2MCm
#define WRITE_L2MCm BCM53324_A0_WRITE_L2MCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2MCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  L2MC_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2MC_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is ANDed with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the L2MC table.
 *
 ******************************************************************************/
#define BCM53324_A0_L2MC_PARITY_CONTROLr 0x07780001

#define BCM53324_A0_L2MC_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2MC_PARITY_CONTROL.
 *
 */
typedef union BCM53324_A0_L2MC_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2mc_parity_control[1];
	uint32_t _l2mc_parity_control;
} BCM53324_A0_L2MC_PARITY_CONTROLr_t;

#define BCM53324_A0_L2MC_PARITY_CONTROLr_CLR(r) (r).l2mc_parity_control[0] = 0
#define BCM53324_A0_L2MC_PARITY_CONTROLr_SET(r,d) (r).l2mc_parity_control[0] = d
#define BCM53324_A0_L2MC_PARITY_CONTROLr_GET(r) (r).l2mc_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).l2mc_parity_control[0]) & 0x1)
#define BCM53324_A0_L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).l2mc_parity_control[0]=(((r).l2mc_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2MC_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).l2mc_parity_control[0]) >> 1) & 0x1)
#define BCM53324_A0_L2MC_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).l2mc_parity_control[0]=(((r).l2mc_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2MC_PARITY_CONTROL.
 *
 */
#define BCM53324_A0_READ_L2MC_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_L2MC_PARITY_CONTROLr,(r._l2mc_parity_control))
#define BCM53324_A0_WRITE_L2MC_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_L2MC_PARITY_CONTROLr,&(r._l2mc_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MC_PARITY_CONTROLr BCM53324_A0_L2MC_PARITY_CONTROLr
#define L2MC_PARITY_CONTROLr_SIZE BCM53324_A0_L2MC_PARITY_CONTROLr_SIZE
typedef BCM53324_A0_L2MC_PARITY_CONTROLr_t L2MC_PARITY_CONTROLr_t;
#define L2MC_PARITY_CONTROLr_CLR BCM53324_A0_L2MC_PARITY_CONTROLr_CLR
#define L2MC_PARITY_CONTROLr_SET BCM53324_A0_L2MC_PARITY_CONTROLr_SET
#define L2MC_PARITY_CONTROLr_GET BCM53324_A0_L2MC_PARITY_CONTROLr_GET
#define L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM53324_A0_L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM53324_A0_L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define L2MC_PARITY_CONTROLr_PARITY_ENf_GET BCM53324_A0_L2MC_PARITY_CONTROLr_PARITY_ENf_GET
#define L2MC_PARITY_CONTROLr_PARITY_ENf_SET BCM53324_A0_L2MC_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_L2MC_PARITY_CONTROLr BCM53324_A0_READ_L2MC_PARITY_CONTROLr
#define WRITE_L2MC_PARITY_CONTROLr BCM53324_A0_WRITE_L2MC_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2MC_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  L2MC_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2MC_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ERR_ADDR         This field indicates the address location in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM53324_A0_L2MC_PARITY_STATUSr 0x07780002

#define BCM53324_A0_L2MC_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2MC_PARITY_STATUS.
 *
 */
typedef union BCM53324_A0_L2MC_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t l2mc_parity_status[1];
	uint32_t _l2mc_parity_status;
} BCM53324_A0_L2MC_PARITY_STATUSr_t;

#define BCM53324_A0_L2MC_PARITY_STATUSr_CLR(r) (r).l2mc_parity_status[0] = 0
#define BCM53324_A0_L2MC_PARITY_STATUSr_SET(r,d) (r).l2mc_parity_status[0] = d
#define BCM53324_A0_L2MC_PARITY_STATUSr_GET(r) (r).l2mc_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2MC_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).l2mc_parity_status[0]) & 0x1)
#define BCM53324_A0_L2MC_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).l2mc_parity_status[0]=(((r).l2mc_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2MC_PARITY_STATUSr_ERR_ADDRf_GET(r) ((((r).l2mc_parity_status[0]) >> 1) & 0xfff)
#define BCM53324_A0_L2MC_PARITY_STATUSr_ERR_ADDRf_SET(r,f) (r).l2mc_parity_status[0]=(((r).l2mc_parity_status[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))

/*
 * These macros can be used to access L2MC_PARITY_STATUS.
 *
 */
#define BCM53324_A0_READ_L2MC_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_L2MC_PARITY_STATUSr,(r._l2mc_parity_status))
#define BCM53324_A0_WRITE_L2MC_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_L2MC_PARITY_STATUSr,&(r._l2mc_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MC_PARITY_STATUSr BCM53324_A0_L2MC_PARITY_STATUSr
#define L2MC_PARITY_STATUSr_SIZE BCM53324_A0_L2MC_PARITY_STATUSr_SIZE
typedef BCM53324_A0_L2MC_PARITY_STATUSr_t L2MC_PARITY_STATUSr_t;
#define L2MC_PARITY_STATUSr_CLR BCM53324_A0_L2MC_PARITY_STATUSr_CLR
#define L2MC_PARITY_STATUSr_SET BCM53324_A0_L2MC_PARITY_STATUSr_SET
#define L2MC_PARITY_STATUSr_GET BCM53324_A0_L2MC_PARITY_STATUSr_GET
#define L2MC_PARITY_STATUSr_PARITY_ERRf_GET BCM53324_A0_L2MC_PARITY_STATUSr_PARITY_ERRf_GET
#define L2MC_PARITY_STATUSr_PARITY_ERRf_SET BCM53324_A0_L2MC_PARITY_STATUSr_PARITY_ERRf_SET
#define L2MC_PARITY_STATUSr_ERR_ADDRf_GET BCM53324_A0_L2MC_PARITY_STATUSr_ERR_ADDRf_GET
#define L2MC_PARITY_STATUSr_ERR_ADDRf_SET BCM53324_A0_L2MC_PARITY_STATUSr_ERR_ADDRf_SET
#define READ_L2MC_PARITY_STATUSr BCM53324_A0_READ_L2MC_PARITY_STATUSr
#define WRITE_L2MC_PARITY_STATUSr BCM53324_A0_WRITE_L2MC_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2MC_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2X
 * BLOCKS:   IPIPE
 * DESC:     Combined HW managed L2 entry table.  Includes L2_ENTRY, L2_HITDA, and L2_HITSA. Indexed with the hash calculated on VID and MAC Address
 * SIZE:     93
 * FIELDS:
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     CPU              CPU bit
 *     DST_DISCARD      Dst Discard
 *     SRC_DISCARD      Src Discard
 *     SCP              SCP bit
 *     L2MC_PTR         Overlay of L2MC pointer (8 bits)
 *     PORT_TGID        Port or TGID
 *     TGID_PORT        Port or TGID - old Draco name
 *     TGID             TGID - old Draco name
 *     T                Trunk bit overlay(MSB of port_tgid)
 *     MODULE_ID        Module ID. Needs to be Zeros
 *     REMOTE_TRUNK     Remote Trunk bit indicates HiGig pkt with remote modid(MSB of module_id)
 *     L3               Indicates an L3 entry
 *     MAC_BLOCK_INDEX  MAC Block Index. This index is used to block mask packets based on Packets Mac Address. The index points to a table named, MAC_BLOCK_TABLE, which contains the bitmap to be masked.
 *     STATIC_BIT       Indicates entry is SW programmed and static
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     VALID            Indicates that the entry is valid
 *     SW_BIT           No hw functionality, excusilvely used by sw.
 *     EVEN_PARITY      Odd parity for the L2_ENTRY RAM fields (i.e. excludes HIT bits)
 *     HITDA            Dst hit update bit
 *     HITSA            Src hit update bit
 *
 ******************************************************************************/
#define BCM53324_A0_L2Xm 0x06700000

#define BCM53324_A0_L2Xm_MIN 0
#define BCM53324_A0_L2Xm_MAX 8191
#define BCM53324_A0_L2Xm_CMAX(u) 8191
#define BCM53324_A0_L2Xm_SIZE 12

/*
 * This structure should be used to declare and program L2X.
 *
 */
typedef union BCM53324_A0_L2Xm_s {
	uint32_t v[3];
	uint32_t l2x[3];
	uint32_t _l2x;
} BCM53324_A0_L2Xm_t;

#define BCM53324_A0_L2Xm_CLR(r) CDK_MEMSET(&((r)._l2x), 0, sizeof(BCM53324_A0_L2Xm_t))
#define BCM53324_A0_L2Xm_SET(r,i,d) (r).l2x[i] = d
#define BCM53324_A0_L2Xm_GET(r,i) (r).l2x[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2Xm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2x,0,47,a)
#define BCM53324_A0_L2Xm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2x,0,47,a)
#define BCM53324_A0_L2Xm_VLAN_IDf_GET(r) ((((r).l2x[1]) >> 16) & 0xfff)
#define BCM53324_A0_L2Xm_VLAN_IDf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53324_A0_L2Xm_PRIf_GET(r) ((((r).l2x[1]) >> 28) & 0x7)
#define BCM53324_A0_L2Xm_PRIf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53324_A0_L2Xm_CPUf_GET(r) ((((r).l2x[1]) >> 31) & 0x1)
#define BCM53324_A0_L2Xm_CPUf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53324_A0_L2Xm_DST_DISCARDf_GET(r) (((r).l2x[2]) & 0x1)
#define BCM53324_A0_L2Xm_DST_DISCARDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2Xm_SRC_DISCARDf_GET(r) ((((r).l2x[2]) >> 1) & 0x1)
#define BCM53324_A0_L2Xm_SRC_DISCARDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_L2Xm_SCPf_GET(r) ((((r).l2x[2]) >> 2) & 0x1)
#define BCM53324_A0_L2Xm_SCPf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_L2Xm_L2MC_PTRf_GET(r) ((((r).l2x[2]) >> 3) & 0xff)
#define BCM53324_A0_L2Xm_L2MC_PTRf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCM53324_A0_L2Xm_PORT_TGIDf_GET(r) ((((r).l2x[2]) >> 3) & 0x7f)
#define BCM53324_A0_L2Xm_PORT_TGIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM53324_A0_L2Xm_TGID_PORTf_GET(r) ((((r).l2x[2]) >> 3) & 0x7f)
#define BCM53324_A0_L2Xm_TGID_PORTf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM53324_A0_L2Xm_TGIDf_GET(r) ((((r).l2x[2]) >> 3) & 0x3f)
#define BCM53324_A0_L2Xm_TGIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM53324_A0_L2Xm_Tf_GET(r) ((((r).l2x[2]) >> 9) & 0x1)
#define BCM53324_A0_L2Xm_Tf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_L2Xm_MODULE_IDf_GET(r) ((((r).l2x[2]) >> 10) & 0xf)
#define BCM53324_A0_L2Xm_MODULE_IDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM53324_A0_L2Xm_REMOTE_TRUNKf_GET(r) ((((r).l2x[2]) >> 13) & 0x1)
#define BCM53324_A0_L2Xm_REMOTE_TRUNKf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_L2Xm_L3f_GET(r) ((((r).l2x[2]) >> 14) & 0x1)
#define BCM53324_A0_L2Xm_L3f_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_L2Xm_MAC_BLOCK_INDEXf_GET(r) ((((r).l2x[2]) >> 15) & 0x1f)
#define BCM53324_A0_L2Xm_MAC_BLOCK_INDEXf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM53324_A0_L2Xm_STATIC_BITf_GET(r) ((((r).l2x[2]) >> 21) & 0x1)
#define BCM53324_A0_L2Xm_STATIC_BITf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_L2Xm_RPEf_GET(r) ((((r).l2x[2]) >> 22) & 0x1)
#define BCM53324_A0_L2Xm_RPEf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_L2Xm_MIRRORf_GET(r) ((((r).l2x[2]) >> 23) & 0x1)
#define BCM53324_A0_L2Xm_MIRRORf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_L2Xm_VALIDf_GET(r) ((((r).l2x[2]) >> 24) & 0x1)
#define BCM53324_A0_L2Xm_VALIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_L2Xm_SW_BITf_GET(r) ((((r).l2x[2]) >> 25) & 0x1)
#define BCM53324_A0_L2Xm_SW_BITf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_L2Xm_EVEN_PARITYf_GET(r) ((((r).l2x[2]) >> 26) & 0x1)
#define BCM53324_A0_L2Xm_EVEN_PARITYf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_L2Xm_HITDAf_GET(r) ((((r).l2x[2]) >> 27) & 0x1)
#define BCM53324_A0_L2Xm_HITDAf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_L2Xm_HITSAf_GET(r) ((((r).l2x[2]) >> 28) & 0x1)
#define BCM53324_A0_L2Xm_HITSAf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access L2X.
 *
 */
#define BCM53324_A0_READ_L2Xm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2Xm,i,(m._l2x),3)
#define BCM53324_A0_WRITE_L2Xm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2Xm,i,&(m._l2x),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2Xm BCM53324_A0_L2Xm
#define L2Xm_MIN BCM53324_A0_L2Xm_MIN
#define L2Xm_MAX BCM53324_A0_L2Xm_MAX
#define L2Xm_CMAX(u) BCM53324_A0_L2Xm_CMAX(u)
#define L2Xm_SIZE BCM53324_A0_L2Xm_SIZE
typedef BCM53324_A0_L2Xm_t L2Xm_t;
#define L2Xm_CLR BCM53324_A0_L2Xm_CLR
#define L2Xm_SET BCM53324_A0_L2Xm_SET
#define L2Xm_GET BCM53324_A0_L2Xm_GET
#define L2Xm_MAC_ADDRf_GET BCM53324_A0_L2Xm_MAC_ADDRf_GET
#define L2Xm_MAC_ADDRf_SET BCM53324_A0_L2Xm_MAC_ADDRf_SET
#define L2Xm_VLAN_IDf_GET BCM53324_A0_L2Xm_VLAN_IDf_GET
#define L2Xm_VLAN_IDf_SET BCM53324_A0_L2Xm_VLAN_IDf_SET
#define L2Xm_PRIf_GET BCM53324_A0_L2Xm_PRIf_GET
#define L2Xm_PRIf_SET BCM53324_A0_L2Xm_PRIf_SET
#define L2Xm_CPUf_GET BCM53324_A0_L2Xm_CPUf_GET
#define L2Xm_CPUf_SET BCM53324_A0_L2Xm_CPUf_SET
#define L2Xm_DST_DISCARDf_GET BCM53324_A0_L2Xm_DST_DISCARDf_GET
#define L2Xm_DST_DISCARDf_SET BCM53324_A0_L2Xm_DST_DISCARDf_SET
#define L2Xm_SRC_DISCARDf_GET BCM53324_A0_L2Xm_SRC_DISCARDf_GET
#define L2Xm_SRC_DISCARDf_SET BCM53324_A0_L2Xm_SRC_DISCARDf_SET
#define L2Xm_SCPf_GET BCM53324_A0_L2Xm_SCPf_GET
#define L2Xm_SCPf_SET BCM53324_A0_L2Xm_SCPf_SET
#define L2Xm_L2MC_PTRf_GET BCM53324_A0_L2Xm_L2MC_PTRf_GET
#define L2Xm_L2MC_PTRf_SET BCM53324_A0_L2Xm_L2MC_PTRf_SET
#define L2Xm_PORT_TGIDf_GET BCM53324_A0_L2Xm_PORT_TGIDf_GET
#define L2Xm_PORT_TGIDf_SET BCM53324_A0_L2Xm_PORT_TGIDf_SET
#define L2Xm_TGID_PORTf_GET BCM53324_A0_L2Xm_TGID_PORTf_GET
#define L2Xm_TGID_PORTf_SET BCM53324_A0_L2Xm_TGID_PORTf_SET
#define L2Xm_TGIDf_GET BCM53324_A0_L2Xm_TGIDf_GET
#define L2Xm_TGIDf_SET BCM53324_A0_L2Xm_TGIDf_SET
#define L2Xm_Tf_GET BCM53324_A0_L2Xm_Tf_GET
#define L2Xm_Tf_SET BCM53324_A0_L2Xm_Tf_SET
#define L2Xm_MODULE_IDf_GET BCM53324_A0_L2Xm_MODULE_IDf_GET
#define L2Xm_MODULE_IDf_SET BCM53324_A0_L2Xm_MODULE_IDf_SET
#define L2Xm_REMOTE_TRUNKf_GET BCM53324_A0_L2Xm_REMOTE_TRUNKf_GET
#define L2Xm_REMOTE_TRUNKf_SET BCM53324_A0_L2Xm_REMOTE_TRUNKf_SET
#define L2Xm_L3f_GET BCM53324_A0_L2Xm_L3f_GET
#define L2Xm_L3f_SET BCM53324_A0_L2Xm_L3f_SET
#define L2Xm_MAC_BLOCK_INDEXf_GET BCM53324_A0_L2Xm_MAC_BLOCK_INDEXf_GET
#define L2Xm_MAC_BLOCK_INDEXf_SET BCM53324_A0_L2Xm_MAC_BLOCK_INDEXf_SET
#define L2Xm_STATIC_BITf_GET BCM53324_A0_L2Xm_STATIC_BITf_GET
#define L2Xm_STATIC_BITf_SET BCM53324_A0_L2Xm_STATIC_BITf_SET
#define L2Xm_RPEf_GET BCM53324_A0_L2Xm_RPEf_GET
#define L2Xm_RPEf_SET BCM53324_A0_L2Xm_RPEf_SET
#define L2Xm_MIRRORf_GET BCM53324_A0_L2Xm_MIRRORf_GET
#define L2Xm_MIRRORf_SET BCM53324_A0_L2Xm_MIRRORf_SET
#define L2Xm_VALIDf_GET BCM53324_A0_L2Xm_VALIDf_GET
#define L2Xm_VALIDf_SET BCM53324_A0_L2Xm_VALIDf_SET
#define L2Xm_SW_BITf_GET BCM53324_A0_L2Xm_SW_BITf_GET
#define L2Xm_SW_BITf_SET BCM53324_A0_L2Xm_SW_BITf_SET
#define L2Xm_EVEN_PARITYf_GET BCM53324_A0_L2Xm_EVEN_PARITYf_GET
#define L2Xm_EVEN_PARITYf_SET BCM53324_A0_L2Xm_EVEN_PARITYf_SET
#define L2Xm_HITDAf_GET BCM53324_A0_L2Xm_HITDAf_GET
#define L2Xm_HITDAf_SET BCM53324_A0_L2Xm_HITDAf_SET
#define L2Xm_HITSAf_GET BCM53324_A0_L2Xm_HITSAf_GET
#define L2Xm_HITSAf_SET BCM53324_A0_L2Xm_HITSAf_SET
#define READ_L2Xm BCM53324_A0_READ_L2Xm
#define WRITE_L2Xm BCM53324_A0_WRITE_L2Xm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2Xm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  L2_AGE_TIMER
 * BLOCKS:   IPIPE
 * DESC:     Age Timer Register
 * SIZE:     32
 * FIELDS:
 *     AGE_VAL          Age Limit
 *     AGE_ENA          Age Enable
 *
 ******************************************************************************/
#define BCM53324_A0_L2_AGE_TIMERr 0x00780003

#define BCM53324_A0_L2_AGE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_TIMER.
 *
 */
typedef union BCM53324_A0_L2_AGE_TIMERr_s {
	uint32_t v[1];
	uint32_t l2_age_timer[1];
	uint32_t _l2_age_timer;
} BCM53324_A0_L2_AGE_TIMERr_t;

#define BCM53324_A0_L2_AGE_TIMERr_CLR(r) (r).l2_age_timer[0] = 0
#define BCM53324_A0_L2_AGE_TIMERr_SET(r,d) (r).l2_age_timer[0] = d
#define BCM53324_A0_L2_AGE_TIMERr_GET(r) (r).l2_age_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_AGE_TIMERr_AGE_VALf_GET(r) (((r).l2_age_timer[0]) & 0xfffff)
#define BCM53324_A0_L2_AGE_TIMERr_AGE_VALf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM53324_A0_L2_AGE_TIMERr_AGE_ENAf_GET(r) ((((r).l2_age_timer[0]) >> 20) & 0x1)
#define BCM53324_A0_L2_AGE_TIMERr_AGE_ENAf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_AGE_TIMER.
 *
 */
#define BCM53324_A0_READ_L2_AGE_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_L2_AGE_TIMERr,(r._l2_age_timer))
#define BCM53324_A0_WRITE_L2_AGE_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_L2_AGE_TIMERr,&(r._l2_age_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_AGE_TIMERr BCM53324_A0_L2_AGE_TIMERr
#define L2_AGE_TIMERr_SIZE BCM53324_A0_L2_AGE_TIMERr_SIZE
typedef BCM53324_A0_L2_AGE_TIMERr_t L2_AGE_TIMERr_t;
#define L2_AGE_TIMERr_CLR BCM53324_A0_L2_AGE_TIMERr_CLR
#define L2_AGE_TIMERr_SET BCM53324_A0_L2_AGE_TIMERr_SET
#define L2_AGE_TIMERr_GET BCM53324_A0_L2_AGE_TIMERr_GET
#define L2_AGE_TIMERr_AGE_VALf_GET BCM53324_A0_L2_AGE_TIMERr_AGE_VALf_GET
#define L2_AGE_TIMERr_AGE_VALf_SET BCM53324_A0_L2_AGE_TIMERr_AGE_VALf_SET
#define L2_AGE_TIMERr_AGE_ENAf_GET BCM53324_A0_L2_AGE_TIMERr_AGE_ENAf_GET
#define L2_AGE_TIMERr_AGE_ENAf_SET BCM53324_A0_L2_AGE_TIMERr_AGE_ENAf_SET
#define READ_L2_AGE_TIMERr BCM53324_A0_READ_L2_AGE_TIMERr
#define WRITE_L2_AGE_TIMERr BCM53324_A0_WRITE_L2_AGE_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_AGE_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  L2_AUX_HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_AUX_HASH_CONTROL
 * SIZE:     32
 * FIELDS:
 *     HASH_SELECT      Selects one of the standard hashing modes. HASH_CRC16_UPPER by default
 *     ENABLE           This bit enables dual hashing (if == 1 for the )2_ENTRY table.
 *
 ******************************************************************************/
#define BCM53324_A0_L2_AUX_HASH_CONTROLr 0x0678000c

#define BCM53324_A0_L2_AUX_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_AUX_HASH_CONTROL.
 *
 */
typedef union BCM53324_A0_L2_AUX_HASH_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_aux_hash_control[1];
	uint32_t _l2_aux_hash_control;
} BCM53324_A0_L2_AUX_HASH_CONTROLr_t;

#define BCM53324_A0_L2_AUX_HASH_CONTROLr_CLR(r) (r).l2_aux_hash_control[0] = 0
#define BCM53324_A0_L2_AUX_HASH_CONTROLr_SET(r,d) (r).l2_aux_hash_control[0] = d
#define BCM53324_A0_L2_AUX_HASH_CONTROLr_GET(r) (r).l2_aux_hash_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_AUX_HASH_CONTROLr_HASH_SELECTf_GET(r) (((r).l2_aux_hash_control[0]) & 0x7)
#define BCM53324_A0_L2_AUX_HASH_CONTROLr_HASH_SELECTf_SET(r,f) (r).l2_aux_hash_control[0]=(((r).l2_aux_hash_control[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_L2_AUX_HASH_CONTROLr_ENABLEf_GET(r) ((((r).l2_aux_hash_control[0]) >> 3) & 0x1)
#define BCM53324_A0_L2_AUX_HASH_CONTROLr_ENABLEf_SET(r,f) (r).l2_aux_hash_control[0]=(((r).l2_aux_hash_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access L2_AUX_HASH_CONTROL.
 *
 */
#define BCM53324_A0_READ_L2_AUX_HASH_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_L2_AUX_HASH_CONTROLr,(r._l2_aux_hash_control))
#define BCM53324_A0_WRITE_L2_AUX_HASH_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_L2_AUX_HASH_CONTROLr,&(r._l2_aux_hash_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_AUX_HASH_CONTROLr BCM53324_A0_L2_AUX_HASH_CONTROLr
#define L2_AUX_HASH_CONTROLr_SIZE BCM53324_A0_L2_AUX_HASH_CONTROLr_SIZE
typedef BCM53324_A0_L2_AUX_HASH_CONTROLr_t L2_AUX_HASH_CONTROLr_t;
#define L2_AUX_HASH_CONTROLr_CLR BCM53324_A0_L2_AUX_HASH_CONTROLr_CLR
#define L2_AUX_HASH_CONTROLr_SET BCM53324_A0_L2_AUX_HASH_CONTROLr_SET
#define L2_AUX_HASH_CONTROLr_GET BCM53324_A0_L2_AUX_HASH_CONTROLr_GET
#define L2_AUX_HASH_CONTROLr_HASH_SELECTf_GET BCM53324_A0_L2_AUX_HASH_CONTROLr_HASH_SELECTf_GET
#define L2_AUX_HASH_CONTROLr_HASH_SELECTf_SET BCM53324_A0_L2_AUX_HASH_CONTROLr_HASH_SELECTf_SET
#define L2_AUX_HASH_CONTROLr_ENABLEf_GET BCM53324_A0_L2_AUX_HASH_CONTROLr_ENABLEf_GET
#define L2_AUX_HASH_CONTROLr_ENABLEf_SET BCM53324_A0_L2_AUX_HASH_CONTROLr_ENABLEf_SET
#define READ_L2_AUX_HASH_CONTROLr BCM53324_A0_READ_L2_AUX_HASH_CONTROLr
#define WRITE_L2_AUX_HASH_CONTROLr BCM53324_A0_WRITE_L2_AUX_HASH_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_AUX_HASH_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_ENTRY table only.  Does not include L2_HITSA or L2_HITDA
 * SIZE:     91
 * FIELDS:
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     CPU              CPU bit
 *     DST_DISCARD      Dst Discard
 *     SRC_DISCARD      Src Discard
 *     SCP              SCP bit
 *     L2MC_PTR         Overlay of L2MC pointer (8 bits)
 *     PORT_TGID        Port or TGID
 *     TGID_PORT        Port or TGID - old Draco name
 *     TGID             TGID - old Draco name
 *     T                Trunk bit overlay(MSB of port_tgid)
 *     MODULE_ID        Module ID. Needs to be Zeros
 *     REMOTE_TRUNK     Remote Trunk bit indicates HiGig pkt with remote modid(MSB of module_id)
 *     L3               Indicates an L3 entry
 *     MAC_BLOCK_INDEX  MAC Block Index. This index is used to block mask packets based on Packets Mac Address. The index points to a table named, MAC_BLOCK_TABLE, which contains the bitmap to be masked.
 *     STATIC_BIT       Indicates entry is SW programmed and static
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     VALID            Indicates that the entry is valid
 *     SW_BIT           No hw functionality, excusilvely used by sw.
 *     EVEN_PARITY      Odd parity for the L2_ENTRY RAM fields (i.e. excludes HIT bits)
 *
 ******************************************************************************/
#define BCM53324_A0_L2_ENTRY_ONLYm 0x06710000

#define BCM53324_A0_L2_ENTRY_ONLYm_MIN 0
#define BCM53324_A0_L2_ENTRY_ONLYm_MAX 8191
#define BCM53324_A0_L2_ENTRY_ONLYm_CMAX(u) 8191
#define BCM53324_A0_L2_ENTRY_ONLYm_SIZE 12

/*
 * This structure should be used to declare and program L2_ENTRY_ONLY.
 *
 */
typedef union BCM53324_A0_L2_ENTRY_ONLYm_s {
	uint32_t v[3];
	uint32_t l2_entry_only[3];
	uint32_t _l2_entry_only;
} BCM53324_A0_L2_ENTRY_ONLYm_t;

#define BCM53324_A0_L2_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l2_entry_only), 0, sizeof(BCM53324_A0_L2_ENTRY_ONLYm_t))
#define BCM53324_A0_L2_ENTRY_ONLYm_SET(r,i,d) (r).l2_entry_only[i] = d
#define BCM53324_A0_L2_ENTRY_ONLYm_GET(r,i) (r).l2_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_ENTRY_ONLYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_entry_only,0,47,a)
#define BCM53324_A0_L2_ENTRY_ONLYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_entry_only,0,47,a)
#define BCM53324_A0_L2_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l2_entry_only[1]) >> 16) & 0xfff)
#define BCM53324_A0_L2_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53324_A0_L2_ENTRY_ONLYm_PRIf_GET(r) ((((r).l2_entry_only[1]) >> 28) & 0x7)
#define BCM53324_A0_L2_ENTRY_ONLYm_PRIf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53324_A0_L2_ENTRY_ONLYm_CPUf_GET(r) ((((r).l2_entry_only[1]) >> 31) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_CPUf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53324_A0_L2_ENTRY_ONLYm_DST_DISCARDf_GET(r) (((r).l2_entry_only[2]) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_DST_DISCARDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_GET(r) ((((r).l2_entry_only[2]) >> 1) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_L2_ENTRY_ONLYm_SCPf_GET(r) ((((r).l2_entry_only[2]) >> 2) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_SCPf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_L2_ENTRY_ONLYm_L2MC_PTRf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0xff)
#define BCM53324_A0_L2_ENTRY_ONLYm_L2MC_PTRf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCM53324_A0_L2_ENTRY_ONLYm_PORT_TGIDf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x7f)
#define BCM53324_A0_L2_ENTRY_ONLYm_PORT_TGIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM53324_A0_L2_ENTRY_ONLYm_TGID_PORTf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x7f)
#define BCM53324_A0_L2_ENTRY_ONLYm_TGID_PORTf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM53324_A0_L2_ENTRY_ONLYm_TGIDf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x3f)
#define BCM53324_A0_L2_ENTRY_ONLYm_TGIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM53324_A0_L2_ENTRY_ONLYm_Tf_GET(r) ((((r).l2_entry_only[2]) >> 9) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_Tf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_L2_ENTRY_ONLYm_MODULE_IDf_GET(r) ((((r).l2_entry_only[2]) >> 10) & 0xf)
#define BCM53324_A0_L2_ENTRY_ONLYm_MODULE_IDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM53324_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET(r) ((((r).l2_entry_only[2]) >> 13) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_L2_ENTRY_ONLYm_L3f_GET(r) ((((r).l2_entry_only[2]) >> 14) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_L3f_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry_only[2]) >> 15) & 0x1f)
#define BCM53324_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM53324_A0_L2_ENTRY_ONLYm_STATIC_BITf_GET(r) ((((r).l2_entry_only[2]) >> 21) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_STATIC_BITf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_L2_ENTRY_ONLYm_RPEf_GET(r) ((((r).l2_entry_only[2]) >> 22) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_RPEf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_L2_ENTRY_ONLYm_MIRRORf_GET(r) ((((r).l2_entry_only[2]) >> 23) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_MIRRORf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_L2_ENTRY_ONLYm_VALIDf_GET(r) ((((r).l2_entry_only[2]) >> 24) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_L2_ENTRY_ONLYm_SW_BITf_GET(r) ((((r).l2_entry_only[2]) >> 25) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_SW_BITf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_GET(r) ((((r).l2_entry_only[2]) >> 26) & 0x1)
#define BCM53324_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access L2_ENTRY_ONLY.
 *
 */
#define BCM53324_A0_READ_L2_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2_ENTRY_ONLYm,i,(m._l2_entry_only),3)
#define BCM53324_A0_WRITE_L2_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2_ENTRY_ONLYm,i,&(m._l2_entry_only),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_ONLYm BCM53324_A0_L2_ENTRY_ONLYm
#define L2_ENTRY_ONLYm_MIN BCM53324_A0_L2_ENTRY_ONLYm_MIN
#define L2_ENTRY_ONLYm_MAX BCM53324_A0_L2_ENTRY_ONLYm_MAX
#define L2_ENTRY_ONLYm_CMAX(u) BCM53324_A0_L2_ENTRY_ONLYm_CMAX(u)
#define L2_ENTRY_ONLYm_SIZE BCM53324_A0_L2_ENTRY_ONLYm_SIZE
typedef BCM53324_A0_L2_ENTRY_ONLYm_t L2_ENTRY_ONLYm_t;
#define L2_ENTRY_ONLYm_CLR BCM53324_A0_L2_ENTRY_ONLYm_CLR
#define L2_ENTRY_ONLYm_SET BCM53324_A0_L2_ENTRY_ONLYm_SET
#define L2_ENTRY_ONLYm_GET BCM53324_A0_L2_ENTRY_ONLYm_GET
#define L2_ENTRY_ONLYm_MAC_ADDRf_GET BCM53324_A0_L2_ENTRY_ONLYm_MAC_ADDRf_GET
#define L2_ENTRY_ONLYm_MAC_ADDRf_SET BCM53324_A0_L2_ENTRY_ONLYm_MAC_ADDRf_SET
#define L2_ENTRY_ONLYm_VLAN_IDf_GET BCM53324_A0_L2_ENTRY_ONLYm_VLAN_IDf_GET
#define L2_ENTRY_ONLYm_VLAN_IDf_SET BCM53324_A0_L2_ENTRY_ONLYm_VLAN_IDf_SET
#define L2_ENTRY_ONLYm_PRIf_GET BCM53324_A0_L2_ENTRY_ONLYm_PRIf_GET
#define L2_ENTRY_ONLYm_PRIf_SET BCM53324_A0_L2_ENTRY_ONLYm_PRIf_SET
#define L2_ENTRY_ONLYm_CPUf_GET BCM53324_A0_L2_ENTRY_ONLYm_CPUf_GET
#define L2_ENTRY_ONLYm_CPUf_SET BCM53324_A0_L2_ENTRY_ONLYm_CPUf_SET
#define L2_ENTRY_ONLYm_DST_DISCARDf_GET BCM53324_A0_L2_ENTRY_ONLYm_DST_DISCARDf_GET
#define L2_ENTRY_ONLYm_DST_DISCARDf_SET BCM53324_A0_L2_ENTRY_ONLYm_DST_DISCARDf_SET
#define L2_ENTRY_ONLYm_SRC_DISCARDf_GET BCM53324_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_GET
#define L2_ENTRY_ONLYm_SRC_DISCARDf_SET BCM53324_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_SET
#define L2_ENTRY_ONLYm_SCPf_GET BCM53324_A0_L2_ENTRY_ONLYm_SCPf_GET
#define L2_ENTRY_ONLYm_SCPf_SET BCM53324_A0_L2_ENTRY_ONLYm_SCPf_SET
#define L2_ENTRY_ONLYm_L2MC_PTRf_GET BCM53324_A0_L2_ENTRY_ONLYm_L2MC_PTRf_GET
#define L2_ENTRY_ONLYm_L2MC_PTRf_SET BCM53324_A0_L2_ENTRY_ONLYm_L2MC_PTRf_SET
#define L2_ENTRY_ONLYm_PORT_TGIDf_GET BCM53324_A0_L2_ENTRY_ONLYm_PORT_TGIDf_GET
#define L2_ENTRY_ONLYm_PORT_TGIDf_SET BCM53324_A0_L2_ENTRY_ONLYm_PORT_TGIDf_SET
#define L2_ENTRY_ONLYm_TGID_PORTf_GET BCM53324_A0_L2_ENTRY_ONLYm_TGID_PORTf_GET
#define L2_ENTRY_ONLYm_TGID_PORTf_SET BCM53324_A0_L2_ENTRY_ONLYm_TGID_PORTf_SET
#define L2_ENTRY_ONLYm_TGIDf_GET BCM53324_A0_L2_ENTRY_ONLYm_TGIDf_GET
#define L2_ENTRY_ONLYm_TGIDf_SET BCM53324_A0_L2_ENTRY_ONLYm_TGIDf_SET
#define L2_ENTRY_ONLYm_Tf_GET BCM53324_A0_L2_ENTRY_ONLYm_Tf_GET
#define L2_ENTRY_ONLYm_Tf_SET BCM53324_A0_L2_ENTRY_ONLYm_Tf_SET
#define L2_ENTRY_ONLYm_MODULE_IDf_GET BCM53324_A0_L2_ENTRY_ONLYm_MODULE_IDf_GET
#define L2_ENTRY_ONLYm_MODULE_IDf_SET BCM53324_A0_L2_ENTRY_ONLYm_MODULE_IDf_SET
#define L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET BCM53324_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET
#define L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET BCM53324_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET
#define L2_ENTRY_ONLYm_L3f_GET BCM53324_A0_L2_ENTRY_ONLYm_L3f_GET
#define L2_ENTRY_ONLYm_L3f_SET BCM53324_A0_L2_ENTRY_ONLYm_L3f_SET
#define L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET BCM53324_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET
#define L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET BCM53324_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET
#define L2_ENTRY_ONLYm_STATIC_BITf_GET BCM53324_A0_L2_ENTRY_ONLYm_STATIC_BITf_GET
#define L2_ENTRY_ONLYm_STATIC_BITf_SET BCM53324_A0_L2_ENTRY_ONLYm_STATIC_BITf_SET
#define L2_ENTRY_ONLYm_RPEf_GET BCM53324_A0_L2_ENTRY_ONLYm_RPEf_GET
#define L2_ENTRY_ONLYm_RPEf_SET BCM53324_A0_L2_ENTRY_ONLYm_RPEf_SET
#define L2_ENTRY_ONLYm_MIRRORf_GET BCM53324_A0_L2_ENTRY_ONLYm_MIRRORf_GET
#define L2_ENTRY_ONLYm_MIRRORf_SET BCM53324_A0_L2_ENTRY_ONLYm_MIRRORf_SET
#define L2_ENTRY_ONLYm_VALIDf_GET BCM53324_A0_L2_ENTRY_ONLYm_VALIDf_GET
#define L2_ENTRY_ONLYm_VALIDf_SET BCM53324_A0_L2_ENTRY_ONLYm_VALIDf_SET
#define L2_ENTRY_ONLYm_SW_BITf_GET BCM53324_A0_L2_ENTRY_ONLYm_SW_BITf_GET
#define L2_ENTRY_ONLYm_SW_BITf_SET BCM53324_A0_L2_ENTRY_ONLYm_SW_BITf_SET
#define L2_ENTRY_ONLYm_EVEN_PARITYf_GET BCM53324_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_GET
#define L2_ENTRY_ONLYm_EVEN_PARITYf_SET BCM53324_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_SET
#define READ_L2_ENTRY_ONLYm BCM53324_A0_READ_L2_ENTRY_ONLYm
#define WRITE_L2_ENTRY_ONLYm BCM53324_A0_WRITE_L2_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  L2_ENTRY_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_ENTRY_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the L2_ENTRY table.
 *
 ******************************************************************************/
#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr 0x06780007

#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_PARITY_CONTROL.
 *
 */
typedef union BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_entry_parity_control[1];
	uint32_t _l2_entry_parity_control;
} BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_t;

#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_CLR(r) (r).l2_entry_parity_control[0] = 0
#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_SET(r,d) (r).l2_entry_parity_control[0] = d
#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_GET(r) (r).l2_entry_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).l2_entry_parity_control[0]) & 0x1)
#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).l2_entry_parity_control[0]=(((r).l2_entry_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).l2_entry_parity_control[0]) >> 1) & 0x1)
#define BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).l2_entry_parity_control[0]=(((r).l2_entry_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2_ENTRY_PARITY_CONTROL.
 *
 */
#define BCM53324_A0_READ_L2_ENTRY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_L2_ENTRY_PARITY_CONTROLr,(r._l2_entry_parity_control))
#define BCM53324_A0_WRITE_L2_ENTRY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_L2_ENTRY_PARITY_CONTROLr,&(r._l2_entry_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_PARITY_CONTROLr BCM53324_A0_L2_ENTRY_PARITY_CONTROLr
#define L2_ENTRY_PARITY_CONTROLr_SIZE BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_SIZE
typedef BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_t L2_ENTRY_PARITY_CONTROLr_t;
#define L2_ENTRY_PARITY_CONTROLr_CLR BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_CLR
#define L2_ENTRY_PARITY_CONTROLr_SET BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_SET
#define L2_ENTRY_PARITY_CONTROLr_GET BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET BCM53324_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_L2_ENTRY_PARITY_CONTROLr BCM53324_A0_READ_L2_ENTRY_PARITY_CONTROLr
#define WRITE_L2_ENTRY_PARITY_CONTROLr BCM53324_A0_WRITE_L2_ENTRY_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_ENTRY_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  L2_ENTRY_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_ENTRY_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ENTRY_BM         This bitmap indicates the entries that had parity errors.  Bits 7..0 correspond to entries 7..0.
 *     BUCKET_IDX       This field indicates the index to the bucket in which the parity error was detected.
 *     RESERVED0        Reserved
 *
 ******************************************************************************/
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr 0x06780008

#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_PARITY_STATUS.
 *
 */
typedef union BCM53324_A0_L2_ENTRY_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_entry_parity_status[1];
	uint32_t _l2_entry_parity_status;
} BCM53324_A0_L2_ENTRY_PARITY_STATUSr_t;

#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_CLR(r) (r).l2_entry_parity_status[0] = 0
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_SET(r,d) (r).l2_entry_parity_status[0] = d
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_GET(r) (r).l2_entry_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).l2_entry_parity_status[0]) & 0x1)
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET(r) ((((r).l2_entry_parity_status[0]) >> 1) & 0xff)
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET(r) ((((r).l2_entry_parity_status[0]) >> 9) & 0x3ff)
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0x3ff << 9)) | ((((uint32_t)f) & 0x3ff) << 9))
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_RESERVED0f_GET(r) ((((r).l2_entry_parity_status[0]) >> 19) & 0x1)
#define BCM53324_A0_L2_ENTRY_PARITY_STATUSr_RESERVED0f_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access L2_ENTRY_PARITY_STATUS.
 *
 */
#define BCM53324_A0_READ_L2_ENTRY_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_L2_ENTRY_PARITY_STATUSr,(r._l2_entry_parity_status))
#define BCM53324_A0_WRITE_L2_ENTRY_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_L2_ENTRY_PARITY_STATUSr,&(r._l2_entry_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_PARITY_STATUSr BCM53324_A0_L2_ENTRY_PARITY_STATUSr
#define L2_ENTRY_PARITY_STATUSr_SIZE BCM53324_A0_L2_ENTRY_PARITY_STATUSr_SIZE
typedef BCM53324_A0_L2_ENTRY_PARITY_STATUSr_t L2_ENTRY_PARITY_STATUSr_t;
#define L2_ENTRY_PARITY_STATUSr_CLR BCM53324_A0_L2_ENTRY_PARITY_STATUSr_CLR
#define L2_ENTRY_PARITY_STATUSr_SET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_SET
#define L2_ENTRY_PARITY_STATUSr_GET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_GET
#define L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET
#define L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET
#define L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET
#define L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET
#define L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET
#define L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET
#define L2_ENTRY_PARITY_STATUSr_RESERVED0f_GET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_RESERVED0f_GET
#define L2_ENTRY_PARITY_STATUSr_RESERVED0f_SET BCM53324_A0_L2_ENTRY_PARITY_STATUSr_RESERVED0f_SET
#define READ_L2_ENTRY_PARITY_STATUSr BCM53324_A0_READ_L2_ENTRY_PARITY_STATUSr
#define WRITE_L2_ENTRY_PARITY_STATUSr BCM53324_A0_WRITE_L2_ENTRY_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_ENTRY_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2_HITDA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_HITDA_ONLY table.  Just the DA hit bits.
 * SIZE:     8
 * FIELDS:
 *     HITDA_0          Hit bit set on Destination MAC addrs hits
 *     HITDA_1          Hit bit set on Destination MAC addrs hits
 *     HITDA_2          Hit bit set on Destination MAC addrs hits
 *     HITDA_3          Hit bit set on Destination MAC addrs hits
 *     HITDA_4          Hit bit set on Destination MAC addrs hits
 *     HITDA_5          Hit bit set on Destination MAC addrs hits
 *     HITDA_6          Hit bit set on Destination MAC addrs hits
 *     HITDA_7          Hit bit set on Destination MAC addrs hits
 *
 ******************************************************************************/
#define BCM53324_A0_L2_HITDA_ONLYm 0x06720000

#define BCM53324_A0_L2_HITDA_ONLYm_MIN 0
#define BCM53324_A0_L2_HITDA_ONLYm_MAX 1023
#define BCM53324_A0_L2_HITDA_ONLYm_CMAX(u) 1023
#define BCM53324_A0_L2_HITDA_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L2_HITDA_ONLY.
 *
 */
typedef union BCM53324_A0_L2_HITDA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_hitda_only[1];
	uint32_t _l2_hitda_only;
} BCM53324_A0_L2_HITDA_ONLYm_t;

#define BCM53324_A0_L2_HITDA_ONLYm_CLR(r) (r).l2_hitda_only[0] = 0
#define BCM53324_A0_L2_HITDA_ONLYm_SET(r,d) (r).l2_hitda_only[0] = d
#define BCM53324_A0_L2_HITDA_ONLYm_GET(r) (r).l2_hitda_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_0f_GET(r) (((r).l2_hitda_only[0]) & 0x1)
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_0f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_1f_GET(r) ((((r).l2_hitda_only[0]) >> 1) & 0x1)
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_1f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_2f_GET(r) ((((r).l2_hitda_only[0]) >> 2) & 0x1)
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_2f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_3f_GET(r) ((((r).l2_hitda_only[0]) >> 3) & 0x1)
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_3f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_4f_GET(r) ((((r).l2_hitda_only[0]) >> 4) & 0x1)
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_4f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_5f_GET(r) ((((r).l2_hitda_only[0]) >> 5) & 0x1)
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_5f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_6f_GET(r) ((((r).l2_hitda_only[0]) >> 6) & 0x1)
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_6f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_7f_GET(r) ((((r).l2_hitda_only[0]) >> 7) & 0x1)
#define BCM53324_A0_L2_HITDA_ONLYm_HITDA_7f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L2_HITDA_ONLY.
 *
 */
#define BCM53324_A0_READ_L2_HITDA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2_HITDA_ONLYm,i,(m._l2_hitda_only),1)
#define BCM53324_A0_WRITE_L2_HITDA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2_HITDA_ONLYm,i,&(m._l2_hitda_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HITDA_ONLYm BCM53324_A0_L2_HITDA_ONLYm
#define L2_HITDA_ONLYm_MIN BCM53324_A0_L2_HITDA_ONLYm_MIN
#define L2_HITDA_ONLYm_MAX BCM53324_A0_L2_HITDA_ONLYm_MAX
#define L2_HITDA_ONLYm_CMAX(u) BCM53324_A0_L2_HITDA_ONLYm_CMAX(u)
#define L2_HITDA_ONLYm_SIZE BCM53324_A0_L2_HITDA_ONLYm_SIZE
typedef BCM53324_A0_L2_HITDA_ONLYm_t L2_HITDA_ONLYm_t;
#define L2_HITDA_ONLYm_CLR BCM53324_A0_L2_HITDA_ONLYm_CLR
#define L2_HITDA_ONLYm_SET BCM53324_A0_L2_HITDA_ONLYm_SET
#define L2_HITDA_ONLYm_GET BCM53324_A0_L2_HITDA_ONLYm_GET
#define L2_HITDA_ONLYm_HITDA_0f_GET BCM53324_A0_L2_HITDA_ONLYm_HITDA_0f_GET
#define L2_HITDA_ONLYm_HITDA_0f_SET BCM53324_A0_L2_HITDA_ONLYm_HITDA_0f_SET
#define L2_HITDA_ONLYm_HITDA_1f_GET BCM53324_A0_L2_HITDA_ONLYm_HITDA_1f_GET
#define L2_HITDA_ONLYm_HITDA_1f_SET BCM53324_A0_L2_HITDA_ONLYm_HITDA_1f_SET
#define L2_HITDA_ONLYm_HITDA_2f_GET BCM53324_A0_L2_HITDA_ONLYm_HITDA_2f_GET
#define L2_HITDA_ONLYm_HITDA_2f_SET BCM53324_A0_L2_HITDA_ONLYm_HITDA_2f_SET
#define L2_HITDA_ONLYm_HITDA_3f_GET BCM53324_A0_L2_HITDA_ONLYm_HITDA_3f_GET
#define L2_HITDA_ONLYm_HITDA_3f_SET BCM53324_A0_L2_HITDA_ONLYm_HITDA_3f_SET
#define L2_HITDA_ONLYm_HITDA_4f_GET BCM53324_A0_L2_HITDA_ONLYm_HITDA_4f_GET
#define L2_HITDA_ONLYm_HITDA_4f_SET BCM53324_A0_L2_HITDA_ONLYm_HITDA_4f_SET
#define L2_HITDA_ONLYm_HITDA_5f_GET BCM53324_A0_L2_HITDA_ONLYm_HITDA_5f_GET
#define L2_HITDA_ONLYm_HITDA_5f_SET BCM53324_A0_L2_HITDA_ONLYm_HITDA_5f_SET
#define L2_HITDA_ONLYm_HITDA_6f_GET BCM53324_A0_L2_HITDA_ONLYm_HITDA_6f_GET
#define L2_HITDA_ONLYm_HITDA_6f_SET BCM53324_A0_L2_HITDA_ONLYm_HITDA_6f_SET
#define L2_HITDA_ONLYm_HITDA_7f_GET BCM53324_A0_L2_HITDA_ONLYm_HITDA_7f_GET
#define L2_HITDA_ONLYm_HITDA_7f_SET BCM53324_A0_L2_HITDA_ONLYm_HITDA_7f_SET
#define READ_L2_HITDA_ONLYm BCM53324_A0_READ_L2_HITDA_ONLYm
#define WRITE_L2_HITDA_ONLYm BCM53324_A0_WRITE_L2_HITDA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_HITDA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2_HITSA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_HITSA_ONLY table.  Just the SA hit bits.
 * SIZE:     8
 * FIELDS:
 *     HITSA_0          Hit bit set on Source MAC addrs hits
 *     HITSA_1          Hit bit set on Source MAC addrs hits
 *     HITSA_2          Hit bit set on Source MAC addrs hits
 *     HITSA_3          Hit bit set on Source MAC addrs hits
 *     HITSA_4          Hit bit set on Source MAC addrs hits
 *     HITSA_5          Hit bit set on Source MAC addrs hits
 *     HITSA_6          Hit bit set on Source MAC addrs hits
 *     HITSA_7          Hit bit set on Source MAC addrs hits
 *
 ******************************************************************************/
#define BCM53324_A0_L2_HITSA_ONLYm 0x06730000

#define BCM53324_A0_L2_HITSA_ONLYm_MIN 0
#define BCM53324_A0_L2_HITSA_ONLYm_MAX 1023
#define BCM53324_A0_L2_HITSA_ONLYm_CMAX(u) 1023
#define BCM53324_A0_L2_HITSA_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L2_HITSA_ONLY.
 *
 */
typedef union BCM53324_A0_L2_HITSA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_hitsa_only[1];
	uint32_t _l2_hitsa_only;
} BCM53324_A0_L2_HITSA_ONLYm_t;

#define BCM53324_A0_L2_HITSA_ONLYm_CLR(r) (r).l2_hitsa_only[0] = 0
#define BCM53324_A0_L2_HITSA_ONLYm_SET(r,d) (r).l2_hitsa_only[0] = d
#define BCM53324_A0_L2_HITSA_ONLYm_GET(r) (r).l2_hitsa_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_0f_GET(r) (((r).l2_hitsa_only[0]) & 0x1)
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_0f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_1f_GET(r) ((((r).l2_hitsa_only[0]) >> 1) & 0x1)
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_1f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_2f_GET(r) ((((r).l2_hitsa_only[0]) >> 2) & 0x1)
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_2f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_3f_GET(r) ((((r).l2_hitsa_only[0]) >> 3) & 0x1)
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_3f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_4f_GET(r) ((((r).l2_hitsa_only[0]) >> 4) & 0x1)
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_4f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_5f_GET(r) ((((r).l2_hitsa_only[0]) >> 5) & 0x1)
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_5f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_6f_GET(r) ((((r).l2_hitsa_only[0]) >> 6) & 0x1)
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_6f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_7f_GET(r) ((((r).l2_hitsa_only[0]) >> 7) & 0x1)
#define BCM53324_A0_L2_HITSA_ONLYm_HITSA_7f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L2_HITSA_ONLY.
 *
 */
#define BCM53324_A0_READ_L2_HITSA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2_HITSA_ONLYm,i,(m._l2_hitsa_only),1)
#define BCM53324_A0_WRITE_L2_HITSA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2_HITSA_ONLYm,i,&(m._l2_hitsa_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HITSA_ONLYm BCM53324_A0_L2_HITSA_ONLYm
#define L2_HITSA_ONLYm_MIN BCM53324_A0_L2_HITSA_ONLYm_MIN
#define L2_HITSA_ONLYm_MAX BCM53324_A0_L2_HITSA_ONLYm_MAX
#define L2_HITSA_ONLYm_CMAX(u) BCM53324_A0_L2_HITSA_ONLYm_CMAX(u)
#define L2_HITSA_ONLYm_SIZE BCM53324_A0_L2_HITSA_ONLYm_SIZE
typedef BCM53324_A0_L2_HITSA_ONLYm_t L2_HITSA_ONLYm_t;
#define L2_HITSA_ONLYm_CLR BCM53324_A0_L2_HITSA_ONLYm_CLR
#define L2_HITSA_ONLYm_SET BCM53324_A0_L2_HITSA_ONLYm_SET
#define L2_HITSA_ONLYm_GET BCM53324_A0_L2_HITSA_ONLYm_GET
#define L2_HITSA_ONLYm_HITSA_0f_GET BCM53324_A0_L2_HITSA_ONLYm_HITSA_0f_GET
#define L2_HITSA_ONLYm_HITSA_0f_SET BCM53324_A0_L2_HITSA_ONLYm_HITSA_0f_SET
#define L2_HITSA_ONLYm_HITSA_1f_GET BCM53324_A0_L2_HITSA_ONLYm_HITSA_1f_GET
#define L2_HITSA_ONLYm_HITSA_1f_SET BCM53324_A0_L2_HITSA_ONLYm_HITSA_1f_SET
#define L2_HITSA_ONLYm_HITSA_2f_GET BCM53324_A0_L2_HITSA_ONLYm_HITSA_2f_GET
#define L2_HITSA_ONLYm_HITSA_2f_SET BCM53324_A0_L2_HITSA_ONLYm_HITSA_2f_SET
#define L2_HITSA_ONLYm_HITSA_3f_GET BCM53324_A0_L2_HITSA_ONLYm_HITSA_3f_GET
#define L2_HITSA_ONLYm_HITSA_3f_SET BCM53324_A0_L2_HITSA_ONLYm_HITSA_3f_SET
#define L2_HITSA_ONLYm_HITSA_4f_GET BCM53324_A0_L2_HITSA_ONLYm_HITSA_4f_GET
#define L2_HITSA_ONLYm_HITSA_4f_SET BCM53324_A0_L2_HITSA_ONLYm_HITSA_4f_SET
#define L2_HITSA_ONLYm_HITSA_5f_GET BCM53324_A0_L2_HITSA_ONLYm_HITSA_5f_GET
#define L2_HITSA_ONLYm_HITSA_5f_SET BCM53324_A0_L2_HITSA_ONLYm_HITSA_5f_SET
#define L2_HITSA_ONLYm_HITSA_6f_GET BCM53324_A0_L2_HITSA_ONLYm_HITSA_6f_GET
#define L2_HITSA_ONLYm_HITSA_6f_SET BCM53324_A0_L2_HITSA_ONLYm_HITSA_6f_SET
#define L2_HITSA_ONLYm_HITSA_7f_GET BCM53324_A0_L2_HITSA_ONLYm_HITSA_7f_GET
#define L2_HITSA_ONLYm_HITSA_7f_SET BCM53324_A0_L2_HITSA_ONLYm_HITSA_7f_SET
#define READ_L2_HITSA_ONLYm BCM53324_A0_READ_L2_HITSA_ONLYm
#define WRITE_L2_HITSA_ONLYm BCM53324_A0_WRITE_L2_HITSA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_HITSA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2_MOD_FIFO
 * BLOCKS:   IPIPE
 * DESC:     FIFO for operations that MODify the L2_ENTRY table.
 * SIZE:     107
 * FIELDS:
 *     OPER             Operation type:  11->DELETE, 10->PPA_REPLACE, 00->WRITE, 01->reserved
 *     ENTRY_IDX        Index to the entry of the L2_ENTRY table modified.  Valid only for WRITE operations.
 *     BUCKET_IDX       Index to the bucket of the L2_ENTRY table affected.
 *     RESERVED         Reserved.
 *     WR_DATA          Overlay for WRITE operations.  All the L2_ENTRY fields specified in the L2_ENTRY_ONLY view
 *     WR_DATA_OR_REPL_DEL_BM Overlay for WRITE operation:  All the L2_ENTRY fields specified in the L2_ENTRY_ONLY view; used for L2_INSERT, LEARN, and MEMWR.  ...or...  Bitmap or bucket entries affected for DELETE and PPA_REPLACE operations; only 8 bits are valid for this overlay.
 *     DELETE_OR_REPL_BM Overlay for DELETE or PPA REPLACE operations.  Bitmap for bucket entries affected.
 *
 ******************************************************************************/
#define BCM53324_A0_L2_MOD_FIFOm 0x06770000

#define BCM53324_A0_L2_MOD_FIFOm_MIN 0
#define BCM53324_A0_L2_MOD_FIFOm_MAX 15
#define BCM53324_A0_L2_MOD_FIFOm_CMAX(u) 15
#define BCM53324_A0_L2_MOD_FIFOm_SIZE 14

/*
 * This structure should be used to declare and program L2_MOD_FIFO.
 *
 */
typedef union BCM53324_A0_L2_MOD_FIFOm_s {
	uint32_t v[4];
	uint32_t l2_mod_fifo[4];
	uint32_t _l2_mod_fifo;
} BCM53324_A0_L2_MOD_FIFOm_t;

#define BCM53324_A0_L2_MOD_FIFOm_CLR(r) CDK_MEMSET(&((r)._l2_mod_fifo), 0, sizeof(BCM53324_A0_L2_MOD_FIFOm_t))
#define BCM53324_A0_L2_MOD_FIFOm_SET(r,i,d) (r).l2_mod_fifo[i] = d
#define BCM53324_A0_L2_MOD_FIFOm_GET(r,i) (r).l2_mod_fifo[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_MOD_FIFOm_OPERf_GET(r) (((r).l2_mod_fifo[0]) & 0x3)
#define BCM53324_A0_L2_MOD_FIFOm_OPERf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_L2_MOD_FIFOm_ENTRY_IDXf_GET(r) ((((r).l2_mod_fifo[0]) >> 2) & 0x7)
#define BCM53324_A0_L2_MOD_FIFOm_ENTRY_IDXf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53324_A0_L2_MOD_FIFOm_BUCKET_IDXf_GET(r) ((((r).l2_mod_fifo[0]) >> 5) & 0x3ff)
#define BCM53324_A0_L2_MOD_FIFOm_BUCKET_IDXf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x3ff << 5)) | ((((uint32_t)f) & 0x3ff) << 5))
#define BCM53324_A0_L2_MOD_FIFOm_RESERVEDf_GET(r) ((((r).l2_mod_fifo[0]) >> 15) & 0x1)
#define BCM53324_A0_L2_MOD_FIFOm_RESERVEDf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_L2_MOD_FIFOm_WR_DATAf_GET(r,a) cdk_field_get((r).l2_mod_fifo,16,106,a)
#define BCM53324_A0_L2_MOD_FIFOm_WR_DATAf_SET(r,a) cdk_field_set((r).l2_mod_fifo,16,106,a)
#define BCM53324_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET(r,a) cdk_field_get((r).l2_mod_fifo,16,106,a)
#define BCM53324_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET(r,a) cdk_field_set((r).l2_mod_fifo,16,106,a)
#define BCM53324_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET(r) ((((r).l2_mod_fifo[0]) >> 16) & 0xff)
#define BCM53324_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))

/*
 * These macros can be used to access L2_MOD_FIFO.
 *
 */
#define BCM53324_A0_READ_L2_MOD_FIFOm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2_MOD_FIFOm,i,(m._l2_mod_fifo),4)
#define BCM53324_A0_WRITE_L2_MOD_FIFOm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2_MOD_FIFOm,i,&(m._l2_mod_fifo),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MOD_FIFOm BCM53324_A0_L2_MOD_FIFOm
#define L2_MOD_FIFOm_MIN BCM53324_A0_L2_MOD_FIFOm_MIN
#define L2_MOD_FIFOm_MAX BCM53324_A0_L2_MOD_FIFOm_MAX
#define L2_MOD_FIFOm_CMAX(u) BCM53324_A0_L2_MOD_FIFOm_CMAX(u)
#define L2_MOD_FIFOm_SIZE BCM53324_A0_L2_MOD_FIFOm_SIZE
typedef BCM53324_A0_L2_MOD_FIFOm_t L2_MOD_FIFOm_t;
#define L2_MOD_FIFOm_CLR BCM53324_A0_L2_MOD_FIFOm_CLR
#define L2_MOD_FIFOm_SET BCM53324_A0_L2_MOD_FIFOm_SET
#define L2_MOD_FIFOm_GET BCM53324_A0_L2_MOD_FIFOm_GET
#define L2_MOD_FIFOm_OPERf_GET BCM53324_A0_L2_MOD_FIFOm_OPERf_GET
#define L2_MOD_FIFOm_OPERf_SET BCM53324_A0_L2_MOD_FIFOm_OPERf_SET
#define L2_MOD_FIFOm_ENTRY_IDXf_GET BCM53324_A0_L2_MOD_FIFOm_ENTRY_IDXf_GET
#define L2_MOD_FIFOm_ENTRY_IDXf_SET BCM53324_A0_L2_MOD_FIFOm_ENTRY_IDXf_SET
#define L2_MOD_FIFOm_BUCKET_IDXf_GET BCM53324_A0_L2_MOD_FIFOm_BUCKET_IDXf_GET
#define L2_MOD_FIFOm_BUCKET_IDXf_SET BCM53324_A0_L2_MOD_FIFOm_BUCKET_IDXf_SET
#define L2_MOD_FIFOm_RESERVEDf_GET BCM53324_A0_L2_MOD_FIFOm_RESERVEDf_GET
#define L2_MOD_FIFOm_RESERVEDf_SET BCM53324_A0_L2_MOD_FIFOm_RESERVEDf_SET
#define L2_MOD_FIFOm_WR_DATAf_GET BCM53324_A0_L2_MOD_FIFOm_WR_DATAf_GET
#define L2_MOD_FIFOm_WR_DATAf_SET BCM53324_A0_L2_MOD_FIFOm_WR_DATAf_SET
#define L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET BCM53324_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET
#define L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET BCM53324_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET
#define L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET BCM53324_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET
#define L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET BCM53324_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET
#define READ_L2_MOD_FIFOm BCM53324_A0_READ_L2_MOD_FIFOm
#define WRITE_L2_MOD_FIFOm BCM53324_A0_WRITE_L2_MOD_FIFOm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_MOD_FIFOm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  L2_MOD_FIFO_CNT
 * BLOCKS:   IPIPE
 * DESC:     L2_MOD_FIFO_CNT
 * SIZE:     32
 * FIELDS:
 *     NUM_OF_ENTRIES   A count of the number of entries in the L2_MOD_FIFO.  This is actually the hardware write pointer, so it points to the last entry in the buffer.
 *
 ******************************************************************************/
#define BCM53324_A0_L2_MOD_FIFO_CNTr 0x06780005

#define BCM53324_A0_L2_MOD_FIFO_CNTr_SIZE 4

/*
 * This structure should be used to declare and program L2_MOD_FIFO_CNT.
 *
 */
typedef union BCM53324_A0_L2_MOD_FIFO_CNTr_s {
	uint32_t v[1];
	uint32_t l2_mod_fifo_cnt[1];
	uint32_t _l2_mod_fifo_cnt;
} BCM53324_A0_L2_MOD_FIFO_CNTr_t;

#define BCM53324_A0_L2_MOD_FIFO_CNTr_CLR(r) (r).l2_mod_fifo_cnt[0] = 0
#define BCM53324_A0_L2_MOD_FIFO_CNTr_SET(r,d) (r).l2_mod_fifo_cnt[0] = d
#define BCM53324_A0_L2_MOD_FIFO_CNTr_GET(r) (r).l2_mod_fifo_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET(r) (((r).l2_mod_fifo_cnt[0]) & 0x1f)
#define BCM53324_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET(r,f) (r).l2_mod_fifo_cnt[0]=(((r).l2_mod_fifo_cnt[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access L2_MOD_FIFO_CNT.
 *
 */
#define BCM53324_A0_READ_L2_MOD_FIFO_CNTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_L2_MOD_FIFO_CNTr,(r._l2_mod_fifo_cnt))
#define BCM53324_A0_WRITE_L2_MOD_FIFO_CNTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_L2_MOD_FIFO_CNTr,&(r._l2_mod_fifo_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MOD_FIFO_CNTr BCM53324_A0_L2_MOD_FIFO_CNTr
#define L2_MOD_FIFO_CNTr_SIZE BCM53324_A0_L2_MOD_FIFO_CNTr_SIZE
typedef BCM53324_A0_L2_MOD_FIFO_CNTr_t L2_MOD_FIFO_CNTr_t;
#define L2_MOD_FIFO_CNTr_CLR BCM53324_A0_L2_MOD_FIFO_CNTr_CLR
#define L2_MOD_FIFO_CNTr_SET BCM53324_A0_L2_MOD_FIFO_CNTr_SET
#define L2_MOD_FIFO_CNTr_GET BCM53324_A0_L2_MOD_FIFO_CNTr_GET
#define L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET BCM53324_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET
#define L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET BCM53324_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET
#define READ_L2_MOD_FIFO_CNTr BCM53324_A0_READ_L2_MOD_FIFO_CNTr
#define WRITE_L2_MOD_FIFO_CNTr BCM53324_A0_WRITE_L2_MOD_FIFO_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_MOD_FIFO_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2_USER_ENTRY
 * BLOCKS:   IPIPE
 * DESC:     Combined L2_ENTRY TCAM/Data RAM for guaranteed L2 entries and BPDUs. The Key to lookup in the CAM is {vid, MAC Address}.
 * SIZE:     156
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     RESERVED_KEY     Reserved bits in the Key. Should be programmed as ZEROs for normal operation
 *     MASK             Mask for the {VLAN_ID, MAC_ADDR}
 *     RESERVED_MASK    Reserved bits in the Mask. Should be programmed as ZEROs for normal operation
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID. Needs to be Zeros
 *     BPDU             Indicates entry is a BPDU
 *     DO_NOT_LEARN_MACSA If set to 1, destination hits in the L2_USER_ENTRY will not learn their MACSA
 *
 ******************************************************************************/
#define BCM53324_A0_L2_USER_ENTRYm 0x06740000

#define BCM53324_A0_L2_USER_ENTRYm_MIN 0
#define BCM53324_A0_L2_USER_ENTRYm_MAX 63
#define BCM53324_A0_L2_USER_ENTRYm_CMAX(u) 63
#define BCM53324_A0_L2_USER_ENTRYm_SIZE 20

/*
 * This structure should be used to declare and program L2_USER_ENTRY.
 *
 */
typedef union BCM53324_A0_L2_USER_ENTRYm_s {
	uint32_t v[5];
	uint32_t l2_user_entry[5];
	uint32_t _l2_user_entry;
} BCM53324_A0_L2_USER_ENTRYm_t;

#define BCM53324_A0_L2_USER_ENTRYm_CLR(r) CDK_MEMSET(&((r)._l2_user_entry), 0, sizeof(BCM53324_A0_L2_USER_ENTRYm_t))
#define BCM53324_A0_L2_USER_ENTRYm_SET(r,i,d) (r).l2_user_entry[i] = d
#define BCM53324_A0_L2_USER_ENTRYm_GET(r,i) (r).l2_user_entry[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_USER_ENTRYm_VALIDf_GET(r) (((r).l2_user_entry[0]) & 0x1)
#define BCM53324_A0_L2_USER_ENTRYm_VALIDf_SET(r,f) (r).l2_user_entry[0]=(((r).l2_user_entry[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2_USER_ENTRYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_user_entry,1,48,a)
#define BCM53324_A0_L2_USER_ENTRYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_user_entry,1,48,a)
#define BCM53324_A0_L2_USER_ENTRYm_VLAN_IDf_GET(r) ((((r).l2_user_entry[1]) >> 17) & 0xfff)
#define BCM53324_A0_L2_USER_ENTRYm_VLAN_IDf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32_t)0xfff << 17)) | ((((uint32_t)f) & 0xfff) << 17))
#define BCM53324_A0_L2_USER_ENTRYm_RESERVED_KEYf_GET(r) cdk_field32_get((r).l2_user_entry,61,67)
#define BCM53324_A0_L2_USER_ENTRYm_RESERVED_KEYf_SET(r,f) cdk_field32_set((r).l2_user_entry,61,67,f)
#define BCM53324_A0_L2_USER_ENTRYm_MASKf_GET(r,a) cdk_field_get((r).l2_user_entry,68,127,a)
#define BCM53324_A0_L2_USER_ENTRYm_MASKf_SET(r,a) cdk_field_set((r).l2_user_entry,68,127,a)
#define BCM53324_A0_L2_USER_ENTRYm_RESERVED_MASKf_GET(r) (((r).l2_user_entry[4]) & 0x7f)
#define BCM53324_A0_L2_USER_ENTRYm_RESERVED_MASKf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53324_A0_L2_USER_ENTRYm_PRIf_GET(r) ((((r).l2_user_entry[4]) >> 7) & 0x7)
#define BCM53324_A0_L2_USER_ENTRYm_PRIf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53324_A0_L2_USER_ENTRYm_CPUf_GET(r) ((((r).l2_user_entry[4]) >> 10) & 0x1)
#define BCM53324_A0_L2_USER_ENTRYm_CPUf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_L2_USER_ENTRYm_L3f_GET(r) ((((r).l2_user_entry[4]) >> 11) & 0x1)
#define BCM53324_A0_L2_USER_ENTRYm_L3f_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_L2_USER_ENTRYm_RPEf_GET(r) ((((r).l2_user_entry[4]) >> 12) & 0x1)
#define BCM53324_A0_L2_USER_ENTRYm_RPEf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_L2_USER_ENTRYm_MIRRORf_GET(r) ((((r).l2_user_entry[4]) >> 13) & 0x1)
#define BCM53324_A0_L2_USER_ENTRYm_MIRRORf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_L2_USER_ENTRYm_DST_DISCARDf_GET(r) ((((r).l2_user_entry[4]) >> 14) & 0x1)
#define BCM53324_A0_L2_USER_ENTRYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_L2_USER_ENTRYm_PORT_TGIDf_GET(r) ((((r).l2_user_entry[4]) >> 15) & 0x7f)
#define BCM53324_A0_L2_USER_ENTRYm_PORT_TGIDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x7f << 15)) | ((((uint32_t)f) & 0x7f) << 15))
#define BCM53324_A0_L2_USER_ENTRYm_MODULE_IDf_GET(r) ((((r).l2_user_entry[4]) >> 22) & 0xf)
#define BCM53324_A0_L2_USER_ENTRYm_MODULE_IDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define BCM53324_A0_L2_USER_ENTRYm_BPDUf_GET(r) ((((r).l2_user_entry[4]) >> 26) & 0x1)
#define BCM53324_A0_L2_USER_ENTRYm_BPDUf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_GET(r) ((((r).l2_user_entry[4]) >> 27) & 0x1)
#define BCM53324_A0_L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access L2_USER_ENTRY.
 *
 */
#define BCM53324_A0_READ_L2_USER_ENTRYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2_USER_ENTRYm,i,(m._l2_user_entry),5)
#define BCM53324_A0_WRITE_L2_USER_ENTRYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2_USER_ENTRYm,i,&(m._l2_user_entry),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRYm BCM53324_A0_L2_USER_ENTRYm
#define L2_USER_ENTRYm_MIN BCM53324_A0_L2_USER_ENTRYm_MIN
#define L2_USER_ENTRYm_MAX BCM53324_A0_L2_USER_ENTRYm_MAX
#define L2_USER_ENTRYm_CMAX(u) BCM53324_A0_L2_USER_ENTRYm_CMAX(u)
#define L2_USER_ENTRYm_SIZE BCM53324_A0_L2_USER_ENTRYm_SIZE
typedef BCM53324_A0_L2_USER_ENTRYm_t L2_USER_ENTRYm_t;
#define L2_USER_ENTRYm_CLR BCM53324_A0_L2_USER_ENTRYm_CLR
#define L2_USER_ENTRYm_SET BCM53324_A0_L2_USER_ENTRYm_SET
#define L2_USER_ENTRYm_GET BCM53324_A0_L2_USER_ENTRYm_GET
#define L2_USER_ENTRYm_VALIDf_GET BCM53324_A0_L2_USER_ENTRYm_VALIDf_GET
#define L2_USER_ENTRYm_VALIDf_SET BCM53324_A0_L2_USER_ENTRYm_VALIDf_SET
#define L2_USER_ENTRYm_MAC_ADDRf_GET BCM53324_A0_L2_USER_ENTRYm_MAC_ADDRf_GET
#define L2_USER_ENTRYm_MAC_ADDRf_SET BCM53324_A0_L2_USER_ENTRYm_MAC_ADDRf_SET
#define L2_USER_ENTRYm_VLAN_IDf_GET BCM53324_A0_L2_USER_ENTRYm_VLAN_IDf_GET
#define L2_USER_ENTRYm_VLAN_IDf_SET BCM53324_A0_L2_USER_ENTRYm_VLAN_IDf_SET
#define L2_USER_ENTRYm_RESERVED_KEYf_GET BCM53324_A0_L2_USER_ENTRYm_RESERVED_KEYf_GET
#define L2_USER_ENTRYm_RESERVED_KEYf_SET BCM53324_A0_L2_USER_ENTRYm_RESERVED_KEYf_SET
#define L2_USER_ENTRYm_MASKf_GET BCM53324_A0_L2_USER_ENTRYm_MASKf_GET
#define L2_USER_ENTRYm_MASKf_SET BCM53324_A0_L2_USER_ENTRYm_MASKf_SET
#define L2_USER_ENTRYm_RESERVED_MASKf_GET BCM53324_A0_L2_USER_ENTRYm_RESERVED_MASKf_GET
#define L2_USER_ENTRYm_RESERVED_MASKf_SET BCM53324_A0_L2_USER_ENTRYm_RESERVED_MASKf_SET
#define L2_USER_ENTRYm_PRIf_GET BCM53324_A0_L2_USER_ENTRYm_PRIf_GET
#define L2_USER_ENTRYm_PRIf_SET BCM53324_A0_L2_USER_ENTRYm_PRIf_SET
#define L2_USER_ENTRYm_CPUf_GET BCM53324_A0_L2_USER_ENTRYm_CPUf_GET
#define L2_USER_ENTRYm_CPUf_SET BCM53324_A0_L2_USER_ENTRYm_CPUf_SET
#define L2_USER_ENTRYm_L3f_GET BCM53324_A0_L2_USER_ENTRYm_L3f_GET
#define L2_USER_ENTRYm_L3f_SET BCM53324_A0_L2_USER_ENTRYm_L3f_SET
#define L2_USER_ENTRYm_RPEf_GET BCM53324_A0_L2_USER_ENTRYm_RPEf_GET
#define L2_USER_ENTRYm_RPEf_SET BCM53324_A0_L2_USER_ENTRYm_RPEf_SET
#define L2_USER_ENTRYm_MIRRORf_GET BCM53324_A0_L2_USER_ENTRYm_MIRRORf_GET
#define L2_USER_ENTRYm_MIRRORf_SET BCM53324_A0_L2_USER_ENTRYm_MIRRORf_SET
#define L2_USER_ENTRYm_DST_DISCARDf_GET BCM53324_A0_L2_USER_ENTRYm_DST_DISCARDf_GET
#define L2_USER_ENTRYm_DST_DISCARDf_SET BCM53324_A0_L2_USER_ENTRYm_DST_DISCARDf_SET
#define L2_USER_ENTRYm_PORT_TGIDf_GET BCM53324_A0_L2_USER_ENTRYm_PORT_TGIDf_GET
#define L2_USER_ENTRYm_PORT_TGIDf_SET BCM53324_A0_L2_USER_ENTRYm_PORT_TGIDf_SET
#define L2_USER_ENTRYm_MODULE_IDf_GET BCM53324_A0_L2_USER_ENTRYm_MODULE_IDf_GET
#define L2_USER_ENTRYm_MODULE_IDf_SET BCM53324_A0_L2_USER_ENTRYm_MODULE_IDf_SET
#define L2_USER_ENTRYm_BPDUf_GET BCM53324_A0_L2_USER_ENTRYm_BPDUf_GET
#define L2_USER_ENTRYm_BPDUf_SET BCM53324_A0_L2_USER_ENTRYm_BPDUf_SET
#define L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_GET BCM53324_A0_L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_GET
#define L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_SET BCM53324_A0_L2_USER_ENTRYm_DO_NOT_LEARN_MACSAf_SET
#define READ_L2_USER_ENTRYm BCM53324_A0_READ_L2_USER_ENTRYm
#define WRITE_L2_USER_ENTRYm BCM53324_A0_WRITE_L2_USER_ENTRYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_USER_ENTRYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2_USER_ENTRY_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Data SRAM for L2_USER_ENTRY TCAM.
 * SIZE:     21
 * FIELDS:
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID. Needs to be Zeros
 *     BPDU             Indicates entry is a BPDU
 *     DO_NOT_LEARN_MACSA If set to 1, destination hits in the L2_USER_ENTRY will not learn their MACSA
 *
 ******************************************************************************/
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm 0x06760000

#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MIN 0
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MAX 63
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_CMAX(u) 63
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program L2_USER_ENTRY_DATA_ONLY.
 *
 */
typedef union BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_user_entry_data_only[1];
	uint32_t _l2_user_entry_data_only;
} BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_t;

#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_CLR(r) (r).l2_user_entry_data_only[0] = 0
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_SET(r,d) (r).l2_user_entry_data_only[0] = d
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_GET(r) (r).l2_user_entry_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_GET(r) (((r).l2_user_entry_data_only[0]) & 0x7)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 3) & 0x1)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_GET(r) ((((r).l2_user_entry_data_only[0]) >> 4) & 0x1)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 5) & 0x1)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 6) & 0x1)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 7) & 0x1)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 8) & 0x7f)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 15) & 0xf)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0xf << 15)) | ((((uint32_t)f) & 0xf) << 15))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 19) & 0x1)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_DO_NOT_LEARN_MACSAf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 20) & 0x1)
#define BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_DO_NOT_LEARN_MACSAf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_USER_ENTRY_DATA_ONLY.
 *
 */
#define BCM53324_A0_READ_L2_USER_ENTRY_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm,i,(m._l2_user_entry_data_only),1)
#define BCM53324_A0_WRITE_L2_USER_ENTRY_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm,i,&(m._l2_user_entry_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_DATA_ONLYm BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm
#define L2_USER_ENTRY_DATA_ONLYm_MIN BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MIN
#define L2_USER_ENTRY_DATA_ONLYm_MAX BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MAX
#define L2_USER_ENTRY_DATA_ONLYm_CMAX(u) BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_CMAX(u)
#define L2_USER_ENTRY_DATA_ONLYm_SIZE BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_SIZE
typedef BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_t L2_USER_ENTRY_DATA_ONLYm_t;
#define L2_USER_ENTRY_DATA_ONLYm_CLR BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_CLR
#define L2_USER_ENTRY_DATA_ONLYm_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_SET
#define L2_USER_ENTRY_DATA_ONLYm_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_GET
#define L2_USER_ENTRY_DATA_ONLYm_PRIf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_GET
#define L2_USER_ENTRY_DATA_ONLYm_PRIf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_SET
#define L2_USER_ENTRY_DATA_ONLYm_CPUf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_GET
#define L2_USER_ENTRY_DATA_ONLYm_CPUf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_SET
#define L2_USER_ENTRY_DATA_ONLYm_L3f_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_GET
#define L2_USER_ENTRY_DATA_ONLYm_L3f_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_SET
#define L2_USER_ENTRY_DATA_ONLYm_RPEf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_GET
#define L2_USER_ENTRY_DATA_ONLYm_RPEf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_SET
#define L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET
#define L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET
#define L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET
#define L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET
#define L2_USER_ENTRY_DATA_ONLYm_DO_NOT_LEARN_MACSAf_GET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_DO_NOT_LEARN_MACSAf_GET
#define L2_USER_ENTRY_DATA_ONLYm_DO_NOT_LEARN_MACSAf_SET BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm_DO_NOT_LEARN_MACSAf_SET
#define READ_L2_USER_ENTRY_DATA_ONLYm BCM53324_A0_READ_L2_USER_ENTRY_DATA_ONLYm
#define WRITE_L2_USER_ENTRY_DATA_ONLYm BCM53324_A0_WRITE_L2_USER_ENTRY_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_USER_ENTRY_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  L2_USER_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     TCAM for guaranteed L2 entries and BPDUs.
 * SIZE:     135
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     RESERVED_KEY     Reserved bits in the Key. Should be programmed as ZEROs for normal operation
 *     MASK             Mask for the {VLAN_ID, MAC_ADDR}
 *     RESERVED_MASK    Reserved bits in the Mask. Should be programmed as ZEROs for normal operation
 *
 ******************************************************************************/
#define BCM53324_A0_L2_USER_ENTRY_ONLYm 0x06750000

#define BCM53324_A0_L2_USER_ENTRY_ONLYm_MIN 0
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_MAX 63
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_CMAX(u) 63
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_SIZE 17

/*
 * This structure should be used to declare and program L2_USER_ENTRY_ONLY.
 *
 */
typedef union BCM53324_A0_L2_USER_ENTRY_ONLYm_s {
	uint32_t v[5];
	uint32_t l2_user_entry_only[5];
	uint32_t _l2_user_entry_only;
} BCM53324_A0_L2_USER_ENTRY_ONLYm_t;

#define BCM53324_A0_L2_USER_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l2_user_entry_only), 0, sizeof(BCM53324_A0_L2_USER_ENTRY_ONLYm_t))
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_SET(r,i,d) (r).l2_user_entry_only[i] = d
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_GET(r,i) (r).l2_user_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_VALIDf_GET(r) (((r).l2_user_entry_only[0]) & 0x1)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l2_user_entry_only[0]=(((r).l2_user_entry_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_user_entry_only,1,48,a)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_user_entry_only,1,48,a)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l2_user_entry_only[1]) >> 17) & 0xfff)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l2_user_entry_only[1]=(((r).l2_user_entry_only[1] & ~((uint32_t)0xfff << 17)) | ((((uint32_t)f) & 0xfff) << 17))
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_RESERVED_KEYf_GET(r) cdk_field32_get((r).l2_user_entry_only,61,67)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_RESERVED_KEYf_SET(r,f) cdk_field32_set((r).l2_user_entry_only,61,67,f)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_MASKf_GET(r,a) cdk_field_get((r).l2_user_entry_only,68,127,a)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_MASKf_SET(r,a) cdk_field_set((r).l2_user_entry_only,68,127,a)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_RESERVED_MASKf_GET(r) (((r).l2_user_entry_only[4]) & 0x7f)
#define BCM53324_A0_L2_USER_ENTRY_ONLYm_RESERVED_MASKf_SET(r,f) (r).l2_user_entry_only[4]=(((r).l2_user_entry_only[4] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access L2_USER_ENTRY_ONLY.
 *
 */
#define BCM53324_A0_READ_L2_USER_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_L2_USER_ENTRY_ONLYm,i,(m._l2_user_entry_only),5)
#define BCM53324_A0_WRITE_L2_USER_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_L2_USER_ENTRY_ONLYm,i,&(m._l2_user_entry_only),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_ONLYm BCM53324_A0_L2_USER_ENTRY_ONLYm
#define L2_USER_ENTRY_ONLYm_MIN BCM53324_A0_L2_USER_ENTRY_ONLYm_MIN
#define L2_USER_ENTRY_ONLYm_MAX BCM53324_A0_L2_USER_ENTRY_ONLYm_MAX
#define L2_USER_ENTRY_ONLYm_CMAX(u) BCM53324_A0_L2_USER_ENTRY_ONLYm_CMAX(u)
#define L2_USER_ENTRY_ONLYm_SIZE BCM53324_A0_L2_USER_ENTRY_ONLYm_SIZE
typedef BCM53324_A0_L2_USER_ENTRY_ONLYm_t L2_USER_ENTRY_ONLYm_t;
#define L2_USER_ENTRY_ONLYm_CLR BCM53324_A0_L2_USER_ENTRY_ONLYm_CLR
#define L2_USER_ENTRY_ONLYm_SET BCM53324_A0_L2_USER_ENTRY_ONLYm_SET
#define L2_USER_ENTRY_ONLYm_GET BCM53324_A0_L2_USER_ENTRY_ONLYm_GET
#define L2_USER_ENTRY_ONLYm_VALIDf_GET BCM53324_A0_L2_USER_ENTRY_ONLYm_VALIDf_GET
#define L2_USER_ENTRY_ONLYm_VALIDf_SET BCM53324_A0_L2_USER_ENTRY_ONLYm_VALIDf_SET
#define L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET BCM53324_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET
#define L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET BCM53324_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET
#define L2_USER_ENTRY_ONLYm_VLAN_IDf_GET BCM53324_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_GET
#define L2_USER_ENTRY_ONLYm_VLAN_IDf_SET BCM53324_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_SET
#define L2_USER_ENTRY_ONLYm_RESERVED_KEYf_GET BCM53324_A0_L2_USER_ENTRY_ONLYm_RESERVED_KEYf_GET
#define L2_USER_ENTRY_ONLYm_RESERVED_KEYf_SET BCM53324_A0_L2_USER_ENTRY_ONLYm_RESERVED_KEYf_SET
#define L2_USER_ENTRY_ONLYm_MASKf_GET BCM53324_A0_L2_USER_ENTRY_ONLYm_MASKf_GET
#define L2_USER_ENTRY_ONLYm_MASKf_SET BCM53324_A0_L2_USER_ENTRY_ONLYm_MASKf_SET
#define L2_USER_ENTRY_ONLYm_RESERVED_MASKf_GET BCM53324_A0_L2_USER_ENTRY_ONLYm_RESERVED_MASKf_GET
#define L2_USER_ENTRY_ONLYm_RESERVED_MASKf_SET BCM53324_A0_L2_USER_ENTRY_ONLYm_RESERVED_MASKf_SET
#define READ_L2_USER_ENTRY_ONLYm BCM53324_A0_READ_L2_USER_ENTRY_ONLYm
#define WRITE_L2_USER_ENTRY_ONLYm BCM53324_A0_WRITE_L2_USER_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_L2_USER_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  LOCAL_SW_DISABLE_DEFAULT_PBM
 * BLOCKS:   IPIPE
 * DESC:     Local switching disable default port bitmap, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      If local switching is disabled, packets will be forwarded according to this field.
 *
 ******************************************************************************/
#define BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr 0x0f700136

#define BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE 4

/*
 * This structure should be used to declare and program LOCAL_SW_DISABLE_DEFAULT_PBM.
 *
 */
typedef union BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_s {
	uint32_t v[1];
	uint32_t local_sw_disable_default_pbm[1];
	uint32_t _local_sw_disable_default_pbm;
} BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_t;

#define BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_CLR(r) (r).local_sw_disable_default_pbm[0] = 0
#define BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_SET(r,d) (r).local_sw_disable_default_pbm[0] = d
#define BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_GET(r) (r).local_sw_disable_default_pbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET(r) (((r).local_sw_disable_default_pbm[0]) & 0x1ffffff)
#define BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET(r,f) (r).local_sw_disable_default_pbm[0]=(((r).local_sw_disable_default_pbm[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access LOCAL_SW_DISABLE_DEFAULT_PBM.
 *
 */
#define BCM53324_A0_READ_LOCAL_SW_DISABLE_DEFAULT_PBMr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr,(r._local_sw_disable_default_pbm))
#define BCM53324_A0_WRITE_LOCAL_SW_DISABLE_DEFAULT_PBMr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr,&(r._local_sw_disable_default_pbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LOCAL_SW_DISABLE_DEFAULT_PBMr BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE
typedef BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_t LOCAL_SW_DISABLE_DEFAULT_PBMr_t;
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_CLR BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_CLR
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_SET BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_SET
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_GET BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_GET
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET
#define READ_LOCAL_SW_DISABLE_DEFAULT_PBMr BCM53324_A0_READ_LOCAL_SW_DISABLE_DEFAULT_PBMr
#define WRITE_LOCAL_SW_DISABLE_DEFAULT_PBMr BCM53324_A0_WRITE_LOCAL_SW_DISABLE_DEFAULT_PBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  LWMCOSCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CELLSETLIMIT     In Dynamic Memory mode:This register represents the guaranteed number of CBP cells scheduled for COS n on this egress port. When LCCOUNTcrosses this limit it goes in to dynamiccell area which is shared by other COS and other ports.Dynamic Memory Mode register need to be set for this limit to be in effect.When not in Dynamic Memory Mode, This is the HOL Cell high waterthreshold for egress port packet of COS n, i.e Number of cells per egress port of COS 0.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *     CELLRESETLIMIT   In Dynamic Memory mode:This register is not used.When not in Dynamic Memory Mode, This register is used for resume cell \cell admission when current HOL Cell Count is lower that this reset limit.Modify this register during the traffic is an illeagal opreation, will cause unrecoverable damage on MMU.
 *
 ******************************************************************************/
#define BCM53324_A0_LWMCOSCELLSETLIMITr 0x0060003c

#define BCM53324_A0_LWMCOSCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program LWMCOSCELLSETLIMIT.
 *
 */
typedef union BCM53324_A0_LWMCOSCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t lwmcoscellsetlimit[1];
	uint32_t _lwmcoscellsetlimit;
} BCM53324_A0_LWMCOSCELLSETLIMITr_t;

#define BCM53324_A0_LWMCOSCELLSETLIMITr_CLR(r) (r).lwmcoscellsetlimit[0] = 0
#define BCM53324_A0_LWMCOSCELLSETLIMITr_SET(r,d) (r).lwmcoscellsetlimit[0] = d
#define BCM53324_A0_LWMCOSCELLSETLIMITr_GET(r) (r).lwmcoscellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET(r) (((r).lwmcoscellsetlimit[0]) & 0xfff)
#define BCM53324_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_LWMCOSCELLSETLIMITr_CELLRESETLIMITf_GET(r) ((((r).lwmcoscellsetlimit[0]) >> 12) & 0xfff)
#define BCM53324_A0_LWMCOSCELLSETLIMITr_CELLRESETLIMITf_SET(r,f) (r).lwmcoscellsetlimit[0]=(((r).lwmcoscellsetlimit[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access LWMCOSCELLSETLIMIT.
 *
 */
#define BCM53324_A0_READ_LWMCOSCELLSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_LWMCOSCELLSETLIMITr+(i),(r._lwmcoscellsetlimit))
#define BCM53324_A0_WRITE_LWMCOSCELLSETLIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_LWMCOSCELLSETLIMITr+(i),&(r._lwmcoscellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LWMCOSCELLSETLIMITr BCM53324_A0_LWMCOSCELLSETLIMITr
#define LWMCOSCELLSETLIMITr_SIZE BCM53324_A0_LWMCOSCELLSETLIMITr_SIZE
typedef BCM53324_A0_LWMCOSCELLSETLIMITr_t LWMCOSCELLSETLIMITr_t;
#define LWMCOSCELLSETLIMITr_CLR BCM53324_A0_LWMCOSCELLSETLIMITr_CLR
#define LWMCOSCELLSETLIMITr_SET BCM53324_A0_LWMCOSCELLSETLIMITr_SET
#define LWMCOSCELLSETLIMITr_GET BCM53324_A0_LWMCOSCELLSETLIMITr_GET
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET BCM53324_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_GET
#define LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET BCM53324_A0_LWMCOSCELLSETLIMITr_CELLSETLIMITf_SET
#define LWMCOSCELLSETLIMITr_CELLRESETLIMITf_GET BCM53324_A0_LWMCOSCELLSETLIMITr_CELLRESETLIMITf_GET
#define LWMCOSCELLSETLIMITr_CELLRESETLIMITf_SET BCM53324_A0_LWMCOSCELLSETLIMITr_CELLRESETLIMITf_SET
#define READ_LWMCOSCELLSETLIMITr BCM53324_A0_READ_LWMCOSCELLSETLIMITr
#define WRITE_LWMCOSCELLSETLIMITr BCM53324_A0_WRITE_LWMCOSCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_LWMCOSCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MACSEC_CNTRL
 * BLOCKS:   GPORT0
 * DESC:     Miscellaneous control for MACSEC (GNAT 11599,11600,12078,12198)
 * SIZE:     32
 * FIELDS:
 *     TX_LAUNCH_EN     Set the bit 0 (Tx_Launch_en) logic 0, if the tx_launch function is to be disabled. If set, then the launch_enable signal assertion/deassertion causes the packet transmit enabled/disabled. The launch_enable is per packet basis.
 *     TX_CRC_CORUPT_EN Setting this field enables the CRC corruption on the transmitted packets. The options of how to corrupt, depends onthe field 2 of this register (TX_CRC_PROGRAM). The CRC corruption happens only on the frames for which TXERR is asserted by the system.
 *     TX_CRC_PROGRAM   If CRC corruption feature in enabled (TX_CRC_CORUPT_EN set), then in case where this bit when set, replaces the transmitted FCS with the programmed FCS.When cleared, corrupts the CRC of the transmitted packet internally.
 *
 ******************************************************************************/
#define BCM53324_A0_MACSEC_CNTRLr 0x000001c5

#define BCM53324_A0_MACSEC_CNTRLr_SIZE 4

/*
 * This structure should be used to declare and program MACSEC_CNTRL.
 *
 */
typedef union BCM53324_A0_MACSEC_CNTRLr_s {
	uint32_t v[1];
	uint32_t macsec_cntrl[1];
	uint32_t _macsec_cntrl;
} BCM53324_A0_MACSEC_CNTRLr_t;

#define BCM53324_A0_MACSEC_CNTRLr_CLR(r) (r).macsec_cntrl[0] = 0
#define BCM53324_A0_MACSEC_CNTRLr_SET(r,d) (r).macsec_cntrl[0] = d
#define BCM53324_A0_MACSEC_CNTRLr_GET(r) (r).macsec_cntrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MACSEC_CNTRLr_TX_LAUNCH_ENf_GET(r) (((r).macsec_cntrl[0]) & 0x1)
#define BCM53324_A0_MACSEC_CNTRLr_TX_LAUNCH_ENf_SET(r,f) (r).macsec_cntrl[0]=(((r).macsec_cntrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MACSEC_CNTRLr_TX_CRC_CORUPT_ENf_GET(r) ((((r).macsec_cntrl[0]) >> 1) & 0x1)
#define BCM53324_A0_MACSEC_CNTRLr_TX_CRC_CORUPT_ENf_SET(r,f) (r).macsec_cntrl[0]=(((r).macsec_cntrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MACSEC_CNTRLr_TX_CRC_PROGRAMf_GET(r) ((((r).macsec_cntrl[0]) >> 2) & 0x1)
#define BCM53324_A0_MACSEC_CNTRLr_TX_CRC_PROGRAMf_SET(r,f) (r).macsec_cntrl[0]=(((r).macsec_cntrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access MACSEC_CNTRL.
 *
 */
#define BCM53324_A0_READ_MACSEC_CNTRLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MACSEC_CNTRLr,(r._macsec_cntrl))
#define BCM53324_A0_WRITE_MACSEC_CNTRLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MACSEC_CNTRLr,&(r._macsec_cntrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MACSEC_CNTRLr BCM53324_A0_MACSEC_CNTRLr
#define MACSEC_CNTRLr_SIZE BCM53324_A0_MACSEC_CNTRLr_SIZE
typedef BCM53324_A0_MACSEC_CNTRLr_t MACSEC_CNTRLr_t;
#define MACSEC_CNTRLr_CLR BCM53324_A0_MACSEC_CNTRLr_CLR
#define MACSEC_CNTRLr_SET BCM53324_A0_MACSEC_CNTRLr_SET
#define MACSEC_CNTRLr_GET BCM53324_A0_MACSEC_CNTRLr_GET
#define MACSEC_CNTRLr_TX_LAUNCH_ENf_GET BCM53324_A0_MACSEC_CNTRLr_TX_LAUNCH_ENf_GET
#define MACSEC_CNTRLr_TX_LAUNCH_ENf_SET BCM53324_A0_MACSEC_CNTRLr_TX_LAUNCH_ENf_SET
#define MACSEC_CNTRLr_TX_CRC_CORUPT_ENf_GET BCM53324_A0_MACSEC_CNTRLr_TX_CRC_CORUPT_ENf_GET
#define MACSEC_CNTRLr_TX_CRC_CORUPT_ENf_SET BCM53324_A0_MACSEC_CNTRLr_TX_CRC_CORUPT_ENf_SET
#define MACSEC_CNTRLr_TX_CRC_PROGRAMf_GET BCM53324_A0_MACSEC_CNTRLr_TX_CRC_PROGRAMf_GET
#define MACSEC_CNTRLr_TX_CRC_PROGRAMf_SET BCM53324_A0_MACSEC_CNTRLr_TX_CRC_PROGRAMf_SET
#define READ_MACSEC_CNTRLr BCM53324_A0_READ_MACSEC_CNTRLr
#define WRITE_MACSEC_CNTRLr BCM53324_A0_WRITE_MACSEC_CNTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MACSEC_CNTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MACSEC_PROG_TX_CRC
 * BLOCKS:   GPORT0
 * DESC:     Programmable CRC value to corrupt the Tx CRC to be used in MACSEC (GNAT 12078)
 * SIZE:     32
 * FIELDS:
 *     MACSEC_PROG_TX_CRC The transmitted crc can be corrupted by replacing the FCS of the transmitted frame by the FCS programmed in this register.This is enabled and controlled by MACSEC_CNTRL register. 
 *
 ******************************************************************************/
#define BCM53324_A0_MACSEC_PROG_TX_CRCr 0x000001c4

#define BCM53324_A0_MACSEC_PROG_TX_CRCr_SIZE 4

/*
 * This structure should be used to declare and program MACSEC_PROG_TX_CRC.
 *
 */
typedef union BCM53324_A0_MACSEC_PROG_TX_CRCr_s {
	uint32_t v[1];
	uint32_t macsec_prog_tx_crc[1];
	uint32_t _macsec_prog_tx_crc;
} BCM53324_A0_MACSEC_PROG_TX_CRCr_t;

#define BCM53324_A0_MACSEC_PROG_TX_CRCr_CLR(r) (r).macsec_prog_tx_crc[0] = 0
#define BCM53324_A0_MACSEC_PROG_TX_CRCr_SET(r,d) (r).macsec_prog_tx_crc[0] = d
#define BCM53324_A0_MACSEC_PROG_TX_CRCr_GET(r) (r).macsec_prog_tx_crc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MACSEC_PROG_TX_CRCr_MACSEC_PROG_TX_CRCf_GET(r) ((r).macsec_prog_tx_crc[0])
#define BCM53324_A0_MACSEC_PROG_TX_CRCr_MACSEC_PROG_TX_CRCf_SET(r,f) (r).macsec_prog_tx_crc[0]=((uint32_t)f)

/*
 * These macros can be used to access MACSEC_PROG_TX_CRC.
 *
 */
#define BCM53324_A0_READ_MACSEC_PROG_TX_CRCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MACSEC_PROG_TX_CRCr,(r._macsec_prog_tx_crc))
#define BCM53324_A0_WRITE_MACSEC_PROG_TX_CRCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MACSEC_PROG_TX_CRCr,&(r._macsec_prog_tx_crc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MACSEC_PROG_TX_CRCr BCM53324_A0_MACSEC_PROG_TX_CRCr
#define MACSEC_PROG_TX_CRCr_SIZE BCM53324_A0_MACSEC_PROG_TX_CRCr_SIZE
typedef BCM53324_A0_MACSEC_PROG_TX_CRCr_t MACSEC_PROG_TX_CRCr_t;
#define MACSEC_PROG_TX_CRCr_CLR BCM53324_A0_MACSEC_PROG_TX_CRCr_CLR
#define MACSEC_PROG_TX_CRCr_SET BCM53324_A0_MACSEC_PROG_TX_CRCr_SET
#define MACSEC_PROG_TX_CRCr_GET BCM53324_A0_MACSEC_PROG_TX_CRCr_GET
#define MACSEC_PROG_TX_CRCr_MACSEC_PROG_TX_CRCf_GET BCM53324_A0_MACSEC_PROG_TX_CRCr_MACSEC_PROG_TX_CRCf_GET
#define MACSEC_PROG_TX_CRCr_MACSEC_PROG_TX_CRCf_SET BCM53324_A0_MACSEC_PROG_TX_CRCr_MACSEC_PROG_TX_CRCf_SET
#define READ_MACSEC_PROG_TX_CRCr BCM53324_A0_READ_MACSEC_PROG_TX_CRCr
#define WRITE_MACSEC_PROG_TX_CRCr BCM53324_A0_WRITE_MACSEC_PROG_TX_CRCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MACSEC_PROG_TX_CRCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MAC_0
 * BLOCKS:   GPORT0
 * DESC:     MAC Address 32-Bit Word 0. Core MAC address bit 0 to 31.
 * SIZE:     32
 * FIELDS:
 *     MAC_ADDR0        Register Bit 0 refers to Bit 0 of the MAC address, Bit 1 refers to bit 1 of the MAC address etc.
 *
 ******************************************************************************/
#define BCM53324_A0_MAC_0r 0x00000103

#define BCM53324_A0_MAC_0r_SIZE 4

/*
 * This structure should be used to declare and program MAC_0.
 *
 */
typedef union BCM53324_A0_MAC_0r_s {
	uint32_t v[1];
	uint32_t mac_0[1];
	uint32_t _mac_0;
} BCM53324_A0_MAC_0r_t;

#define BCM53324_A0_MAC_0r_CLR(r) (r).mac_0[0] = 0
#define BCM53324_A0_MAC_0r_SET(r,d) (r).mac_0[0] = d
#define BCM53324_A0_MAC_0r_GET(r) (r).mac_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAC_0r_MAC_ADDR0f_GET(r) ((r).mac_0[0])
#define BCM53324_A0_MAC_0r_MAC_ADDR0f_SET(r,f) (r).mac_0[0]=((uint32_t)f)

/*
 * These macros can be used to access MAC_0.
 *
 */
#define BCM53324_A0_READ_MAC_0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MAC_0r,(r._mac_0))
#define BCM53324_A0_WRITE_MAC_0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MAC_0r,&(r._mac_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_0r BCM53324_A0_MAC_0r
#define MAC_0r_SIZE BCM53324_A0_MAC_0r_SIZE
typedef BCM53324_A0_MAC_0r_t MAC_0r_t;
#define MAC_0r_CLR BCM53324_A0_MAC_0r_CLR
#define MAC_0r_SET BCM53324_A0_MAC_0r_SET
#define MAC_0r_GET BCM53324_A0_MAC_0r_GET
#define MAC_0r_MAC_ADDR0f_GET BCM53324_A0_MAC_0r_MAC_ADDR0f_GET
#define MAC_0r_MAC_ADDR0f_SET BCM53324_A0_MAC_0r_MAC_ADDR0f_SET
#define READ_MAC_0r BCM53324_A0_READ_MAC_0r
#define WRITE_MAC_0r BCM53324_A0_WRITE_MAC_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAC_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MAC_1
 * BLOCKS:   GPORT0
 * DESC:     MAC Address 32-Bit Word 1. Core MAC address bit 32 to 47.
 * SIZE:     32
 * FIELDS:
 *     MAC_ADDR1        Register Bit 0 refers to Bit 32 of the MAC address.Bits 16 to 31 are reserved.
 *
 ******************************************************************************/
#define BCM53324_A0_MAC_1r 0x00000104

#define BCM53324_A0_MAC_1r_SIZE 4

/*
 * This structure should be used to declare and program MAC_1.
 *
 */
typedef union BCM53324_A0_MAC_1r_s {
	uint32_t v[1];
	uint32_t mac_1[1];
	uint32_t _mac_1;
} BCM53324_A0_MAC_1r_t;

#define BCM53324_A0_MAC_1r_CLR(r) (r).mac_1[0] = 0
#define BCM53324_A0_MAC_1r_SET(r,d) (r).mac_1[0] = d
#define BCM53324_A0_MAC_1r_GET(r) (r).mac_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAC_1r_MAC_ADDR1f_GET(r) (((r).mac_1[0]) & 0xffff)
#define BCM53324_A0_MAC_1r_MAC_ADDR1f_SET(r,f) (r).mac_1[0]=(((r).mac_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MAC_1.
 *
 */
#define BCM53324_A0_READ_MAC_1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MAC_1r,(r._mac_1))
#define BCM53324_A0_WRITE_MAC_1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MAC_1r,&(r._mac_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_1r BCM53324_A0_MAC_1r
#define MAC_1r_SIZE BCM53324_A0_MAC_1r_SIZE
typedef BCM53324_A0_MAC_1r_t MAC_1r_t;
#define MAC_1r_CLR BCM53324_A0_MAC_1r_CLR
#define MAC_1r_SET BCM53324_A0_MAC_1r_SET
#define MAC_1r_GET BCM53324_A0_MAC_1r_GET
#define MAC_1r_MAC_ADDR1f_GET BCM53324_A0_MAC_1r_MAC_ADDR1f_GET
#define MAC_1r_MAC_ADDR1f_SET BCM53324_A0_MAC_1r_MAC_ADDR1f_SET
#define READ_MAC_1r BCM53324_A0_READ_MAC_1r
#define WRITE_MAC_1r BCM53324_A0_WRITE_MAC_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAC_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MAC_BLOCK
 * BLOCKS:   IPIPE
 * DESC:     Mac block index from L2 Tables, is used to block mask packets based on Packets Mac Address. That index points to this table, which contains the bitmap to be masked.
 * SIZE:     25
 * FIELDS:
 *     MAC_BLOCK_MASK   MAC block mask
 *     MAC_BLOCK_MASK_LO MAC block mask
 *
 ******************************************************************************/
#define BCM53324_A0_MAC_BLOCKm 0x0f740000

#define BCM53324_A0_MAC_BLOCKm_MIN 0
#define BCM53324_A0_MAC_BLOCKm_MAX 31
#define BCM53324_A0_MAC_BLOCKm_CMAX(u) 31
#define BCM53324_A0_MAC_BLOCKm_SIZE 4

/*
 * This structure should be used to declare and program MAC_BLOCK.
 *
 */
typedef union BCM53324_A0_MAC_BLOCKm_s {
	uint32_t v[1];
	uint32_t mac_block[1];
	uint32_t _mac_block;
} BCM53324_A0_MAC_BLOCKm_t;

#define BCM53324_A0_MAC_BLOCKm_CLR(r) (r).mac_block[0] = 0
#define BCM53324_A0_MAC_BLOCKm_SET(r,d) (r).mac_block[0] = d
#define BCM53324_A0_MAC_BLOCKm_GET(r) (r).mac_block[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_GET(r) (((r).mac_block[0]) & 0x1ffffff)
#define BCM53324_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_SET(r,f) (r).mac_block[0]=(((r).mac_block[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_MAC_BLOCKm_MAC_BLOCK_MASK_LOf_GET(r) (((r).mac_block[0]) & 0x1ffffff)
#define BCM53324_A0_MAC_BLOCKm_MAC_BLOCK_MASK_LOf_SET(r,f) (r).mac_block[0]=(((r).mac_block[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access MAC_BLOCK.
 *
 */
#define BCM53324_A0_READ_MAC_BLOCKm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MAC_BLOCKm,i,(m._mac_block),1)
#define BCM53324_A0_WRITE_MAC_BLOCKm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MAC_BLOCKm,i,&(m._mac_block),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_BLOCKm BCM53324_A0_MAC_BLOCKm
#define MAC_BLOCKm_MIN BCM53324_A0_MAC_BLOCKm_MIN
#define MAC_BLOCKm_MAX BCM53324_A0_MAC_BLOCKm_MAX
#define MAC_BLOCKm_CMAX(u) BCM53324_A0_MAC_BLOCKm_CMAX(u)
#define MAC_BLOCKm_SIZE BCM53324_A0_MAC_BLOCKm_SIZE
typedef BCM53324_A0_MAC_BLOCKm_t MAC_BLOCKm_t;
#define MAC_BLOCKm_CLR BCM53324_A0_MAC_BLOCKm_CLR
#define MAC_BLOCKm_SET BCM53324_A0_MAC_BLOCKm_SET
#define MAC_BLOCKm_GET BCM53324_A0_MAC_BLOCKm_GET
#define MAC_BLOCKm_MAC_BLOCK_MASKf_GET BCM53324_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_GET
#define MAC_BLOCKm_MAC_BLOCK_MASKf_SET BCM53324_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_SET
#define MAC_BLOCKm_MAC_BLOCK_MASK_LOf_GET BCM53324_A0_MAC_BLOCKm_MAC_BLOCK_MASK_LOf_GET
#define MAC_BLOCKm_MAC_BLOCK_MASK_LOf_SET BCM53324_A0_MAC_BLOCKm_MAC_BLOCK_MASK_LOf_SET
#define READ_MAC_BLOCKm BCM53324_A0_READ_MAC_BLOCKm
#define WRITE_MAC_BLOCKm BCM53324_A0_WRITE_MAC_BLOCKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAC_BLOCKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MAC_LIMIT_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     MODID config so that the aging/table update logic can use it to determine local vs remote entries
 * SIZE:     32
 * FIELDS:
 *     MY_MODID         the aging/table update logic can use it to determine local vs remote entries. Needs to be Zeros
 *
 ******************************************************************************/
#define BCM53324_A0_MAC_LIMIT_CONFIGr 0x0678000b

#define BCM53324_A0_MAC_LIMIT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MAC_LIMIT_CONFIG.
 *
 */
typedef union BCM53324_A0_MAC_LIMIT_CONFIGr_s {
	uint32_t v[1];
	uint32_t mac_limit_config[1];
	uint32_t _mac_limit_config;
} BCM53324_A0_MAC_LIMIT_CONFIGr_t;

#define BCM53324_A0_MAC_LIMIT_CONFIGr_CLR(r) (r).mac_limit_config[0] = 0
#define BCM53324_A0_MAC_LIMIT_CONFIGr_SET(r,d) (r).mac_limit_config[0] = d
#define BCM53324_A0_MAC_LIMIT_CONFIGr_GET(r) (r).mac_limit_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAC_LIMIT_CONFIGr_MY_MODIDf_GET(r) (((r).mac_limit_config[0]) & 0xf)
#define BCM53324_A0_MAC_LIMIT_CONFIGr_MY_MODIDf_SET(r,f) (r).mac_limit_config[0]=(((r).mac_limit_config[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access MAC_LIMIT_CONFIG.
 *
 */
#define BCM53324_A0_READ_MAC_LIMIT_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MAC_LIMIT_CONFIGr,(r._mac_limit_config))
#define BCM53324_A0_WRITE_MAC_LIMIT_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MAC_LIMIT_CONFIGr,&(r._mac_limit_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_LIMIT_CONFIGr BCM53324_A0_MAC_LIMIT_CONFIGr
#define MAC_LIMIT_CONFIGr_SIZE BCM53324_A0_MAC_LIMIT_CONFIGr_SIZE
typedef BCM53324_A0_MAC_LIMIT_CONFIGr_t MAC_LIMIT_CONFIGr_t;
#define MAC_LIMIT_CONFIGr_CLR BCM53324_A0_MAC_LIMIT_CONFIGr_CLR
#define MAC_LIMIT_CONFIGr_SET BCM53324_A0_MAC_LIMIT_CONFIGr_SET
#define MAC_LIMIT_CONFIGr_GET BCM53324_A0_MAC_LIMIT_CONFIGr_GET
#define MAC_LIMIT_CONFIGr_MY_MODIDf_GET BCM53324_A0_MAC_LIMIT_CONFIGr_MY_MODIDf_GET
#define MAC_LIMIT_CONFIGr_MY_MODIDf_SET BCM53324_A0_MAC_LIMIT_CONFIGr_MY_MODIDf_SET
#define READ_MAC_LIMIT_CONFIGr BCM53324_A0_READ_MAC_LIMIT_CONFIGr
#define WRITE_MAC_LIMIT_CONFIGr BCM53324_A0_WRITE_MAC_LIMIT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAC_LIMIT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MAC_LIMIT_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     Indicates if Mac Limit feature is enabled or not.
 * SIZE:     32
 * FIELDS:
 *     ENABLE           This bit must be set when enabling the MAC_LIMIT feature. Alongwith this, Limits have to be programmed correctly to enable the feature completely.
 *
 ******************************************************************************/
#define BCM53324_A0_MAC_LIMIT_ENABLEr 0x0178000c

#define BCM53324_A0_MAC_LIMIT_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MAC_LIMIT_ENABLE.
 *
 */
typedef union BCM53324_A0_MAC_LIMIT_ENABLEr_s {
	uint32_t v[1];
	uint32_t mac_limit_enable[1];
	uint32_t _mac_limit_enable;
} BCM53324_A0_MAC_LIMIT_ENABLEr_t;

#define BCM53324_A0_MAC_LIMIT_ENABLEr_CLR(r) (r).mac_limit_enable[0] = 0
#define BCM53324_A0_MAC_LIMIT_ENABLEr_SET(r,d) (r).mac_limit_enable[0] = d
#define BCM53324_A0_MAC_LIMIT_ENABLEr_GET(r) (r).mac_limit_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAC_LIMIT_ENABLEr_ENABLEf_GET(r) (((r).mac_limit_enable[0]) & 0x1)
#define BCM53324_A0_MAC_LIMIT_ENABLEr_ENABLEf_SET(r,f) (r).mac_limit_enable[0]=(((r).mac_limit_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MAC_LIMIT_ENABLE.
 *
 */
#define BCM53324_A0_READ_MAC_LIMIT_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MAC_LIMIT_ENABLEr,(r._mac_limit_enable))
#define BCM53324_A0_WRITE_MAC_LIMIT_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MAC_LIMIT_ENABLEr,&(r._mac_limit_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_LIMIT_ENABLEr BCM53324_A0_MAC_LIMIT_ENABLEr
#define MAC_LIMIT_ENABLEr_SIZE BCM53324_A0_MAC_LIMIT_ENABLEr_SIZE
typedef BCM53324_A0_MAC_LIMIT_ENABLEr_t MAC_LIMIT_ENABLEr_t;
#define MAC_LIMIT_ENABLEr_CLR BCM53324_A0_MAC_LIMIT_ENABLEr_CLR
#define MAC_LIMIT_ENABLEr_SET BCM53324_A0_MAC_LIMIT_ENABLEr_SET
#define MAC_LIMIT_ENABLEr_GET BCM53324_A0_MAC_LIMIT_ENABLEr_GET
#define MAC_LIMIT_ENABLEr_ENABLEf_GET BCM53324_A0_MAC_LIMIT_ENABLEr_ENABLEf_GET
#define MAC_LIMIT_ENABLEr_ENABLEf_SET BCM53324_A0_MAC_LIMIT_ENABLEr_ENABLEf_SET
#define READ_MAC_LIMIT_ENABLEr BCM53324_A0_READ_MAC_LIMIT_ENABLEr
#define WRITE_MAC_LIMIT_ENABLEr BCM53324_A0_WRITE_MAC_LIMIT_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAC_LIMIT_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MAC_LIMIT_PORT_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     TABLE for mapping a INGRESS PORT to a index into MAC_LIMIT_COUNT_TABLE. Indexed using ingress port number
 * SIZE:     6
 * FIELDS:
 *     INDEX            index into MAC_LIMIT_COUNT_TABLE (used for mapping a INGRESS_PORT to a index into MAC_LIMIT_COUNT_TABLE) 
 *
 ******************************************************************************/
#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm 0x06790000

#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_MIN 0
#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_MAX 24
#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_CMAX(u) 24
#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program MAC_LIMIT_PORT_MAP_TABLE.
 *
 */
typedef union BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t mac_limit_port_map_table[1];
	uint32_t _mac_limit_port_map_table;
} BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_t;

#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_CLR(r) (r).mac_limit_port_map_table[0] = 0
#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_SET(r,d) (r).mac_limit_port_map_table[0] = d
#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_GET(r) (r).mac_limit_port_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_GET(r) (((r).mac_limit_port_map_table[0]) & 0x3f)
#define BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_SET(r,f) (r).mac_limit_port_map_table[0]=(((r).mac_limit_port_map_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access MAC_LIMIT_PORT_MAP_TABLE.
 *
 */
#define BCM53324_A0_READ_MAC_LIMIT_PORT_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm,i,(m._mac_limit_port_map_table),1)
#define BCM53324_A0_WRITE_MAC_LIMIT_PORT_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm,i,&(m._mac_limit_port_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_LIMIT_PORT_MAP_TABLEm BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm
#define MAC_LIMIT_PORT_MAP_TABLEm_MIN BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_MIN
#define MAC_LIMIT_PORT_MAP_TABLEm_MAX BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_MAX
#define MAC_LIMIT_PORT_MAP_TABLEm_CMAX(u) BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_CMAX(u)
#define MAC_LIMIT_PORT_MAP_TABLEm_SIZE BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_SIZE
typedef BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_t MAC_LIMIT_PORT_MAP_TABLEm_t;
#define MAC_LIMIT_PORT_MAP_TABLEm_CLR BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_CLR
#define MAC_LIMIT_PORT_MAP_TABLEm_SET BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_SET
#define MAC_LIMIT_PORT_MAP_TABLEm_GET BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_GET
#define MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_GET BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_GET
#define MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_SET BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm_INDEXf_SET
#define READ_MAC_LIMIT_PORT_MAP_TABLEm BCM53324_A0_READ_MAC_LIMIT_PORT_MAP_TABLEm
#define WRITE_MAC_LIMIT_PORT_MAP_TABLEm BCM53324_A0_WRITE_MAC_LIMIT_PORT_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAC_LIMIT_PORT_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MAC_LIMIT_TRUNK_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     TABLE for mapping a TRUNK group to a index into MAC_LIMIT_COUNT_TABLE. Indexed using the Src/Dst TGID.
 * SIZE:     6
 * FIELDS:
 *     INDEX            index into MAC_LIMIT_COUNT_TABLE (used for mapping a TRUNK GROUP to a index into MAC_LIMIT_COUNT_TABLE) 
 *
 ******************************************************************************/
#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm 0x06780000

#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_MIN 0
#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_MAX 7
#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_CMAX(u) 7
#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program MAC_LIMIT_TRUNK_MAP_TABLE.
 *
 */
typedef union BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t mac_limit_trunk_map_table[1];
	uint32_t _mac_limit_trunk_map_table;
} BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_t;

#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_CLR(r) (r).mac_limit_trunk_map_table[0] = 0
#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_SET(r,d) (r).mac_limit_trunk_map_table[0] = d
#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_GET(r) (r).mac_limit_trunk_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_GET(r) (((r).mac_limit_trunk_map_table[0]) & 0x3f)
#define BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_SET(r,f) (r).mac_limit_trunk_map_table[0]=(((r).mac_limit_trunk_map_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access MAC_LIMIT_TRUNK_MAP_TABLE.
 *
 */
#define BCM53324_A0_READ_MAC_LIMIT_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm,i,(m._mac_limit_trunk_map_table),1)
#define BCM53324_A0_WRITE_MAC_LIMIT_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm,i,&(m._mac_limit_trunk_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_LIMIT_TRUNK_MAP_TABLEm BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm
#define MAC_LIMIT_TRUNK_MAP_TABLEm_MIN BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_MIN
#define MAC_LIMIT_TRUNK_MAP_TABLEm_MAX BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_MAX
#define MAC_LIMIT_TRUNK_MAP_TABLEm_CMAX(u) BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_CMAX(u)
#define MAC_LIMIT_TRUNK_MAP_TABLEm_SIZE BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_SIZE
typedef BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_t MAC_LIMIT_TRUNK_MAP_TABLEm_t;
#define MAC_LIMIT_TRUNK_MAP_TABLEm_CLR BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_CLR
#define MAC_LIMIT_TRUNK_MAP_TABLEm_SET BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_SET
#define MAC_LIMIT_TRUNK_MAP_TABLEm_GET BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_GET
#define MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_GET BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_GET
#define MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_SET BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm_INDEXf_SET
#define READ_MAC_LIMIT_TRUNK_MAP_TABLEm BCM53324_A0_READ_MAC_LIMIT_TRUNK_MAP_TABLEm
#define WRITE_MAC_LIMIT_TRUNK_MAP_TABLEm BCM53324_A0_WRITE_MAC_LIMIT_TRUNK_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAC_LIMIT_TRUNK_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MAC_MODE
 * BLOCKS:   GPORT0
 * DESC:     MAC Mode. MAC Speed and Duplex Mode configuration from register COMMAND_CONFIG, when ENA_EXT_CONFIG is set to '0' or from signals set_speed(1:0), set_duplex, tx_pause_en, rx_pause_en and sync_reset.
 * SIZE:     32
 * FIELDS:
 *     MAC_SPEED        MAC Speed. MAC speed configured with the register COMMAND_CONFIG when register bit ENA_EXT_CONFIGis set to '0'. MAC speed configured with signal set_speed(1:0) when register bit ENA_EXT_CONFIG is set to '1':00: 10Mbps Ethernet Mode enabled01: 100Mbps Ethernet Mode enabled10: Gigabit Ethernet Mode enabled11: 2.5Gigabit Ethernet Mode enabled
 *     MAC_DUPLEX       MAC Duplex. MAC duplex configured with the register COMMAND_CONFIG when register bit ENA_EXT_CONFIG is set to '0'. MAC speed configured with signal set_duplex when register bit ENA_EXT_CONFIG is set to '1':0: Full Duplex Mode enabled1: Half Duplex Mode enabled
 *     MAC_RX_PAUSE     MAC Pause Enabled in Receive. MAC Pause Frame termination ability configured with the register COMMAND_CONFIG when register bit ENA_EXT_CONFIG is set to '0'. MAC Pause Frame termination ability configured with signal tx_pause_en when register bit ENA_EXT_CONFIG is set to '1':0: MAC Pause Disabled in Receive1: MAC Pause Enabled in Receive
 *     MAC_TX_PAUSE     MAC Pause Enabled in Transmit. MAC Pause Frame generation ability configured with the register RX_SECTION_EMPTY when register bit ENA_EXT_CONFIG is set to '0'. MAC Pause Frame generation ability configured with signal tx_pause_en when register bit ENA_EXT_CONFIG is set to '1':0: MAC Pause Disabled in Transmit1: MAC Pause Enabled in Transmit
 *     LINK_STATUS      Link Status Indication. Set to '0', when ENA_EXT_CONFIG is set to '0', when the software resetcommand SW_RESET is set to '1', set to '1' when the SW_RESET bit is reset to '0' to indicate thatthe MAC is active.Set to '0', when ENA_EXT_CONFIG is set to '1', when the signal sync_reset is set to '1', set to'1' when the signal sync_reset is set to '0' to indicate that the MAC is active and the link isup.
 *
 ******************************************************************************/
#define BCM53324_A0_MAC_MODEr 0x00000111

#define BCM53324_A0_MAC_MODEr_SIZE 4

/*
 * This structure should be used to declare and program MAC_MODE.
 *
 */
typedef union BCM53324_A0_MAC_MODEr_s {
	uint32_t v[1];
	uint32_t mac_mode[1];
	uint32_t _mac_mode;
} BCM53324_A0_MAC_MODEr_t;

#define BCM53324_A0_MAC_MODEr_CLR(r) (r).mac_mode[0] = 0
#define BCM53324_A0_MAC_MODEr_SET(r,d) (r).mac_mode[0] = d
#define BCM53324_A0_MAC_MODEr_GET(r) (r).mac_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAC_MODEr_MAC_SPEEDf_GET(r) (((r).mac_mode[0]) & 0x3)
#define BCM53324_A0_MAC_MODEr_MAC_SPEEDf_SET(r,f) (r).mac_mode[0]=(((r).mac_mode[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_MAC_MODEr_MAC_DUPLEXf_GET(r) ((((r).mac_mode[0]) >> 2) & 0x1)
#define BCM53324_A0_MAC_MODEr_MAC_DUPLEXf_SET(r,f) (r).mac_mode[0]=(((r).mac_mode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MAC_MODEr_MAC_RX_PAUSEf_GET(r) ((((r).mac_mode[0]) >> 3) & 0x1)
#define BCM53324_A0_MAC_MODEr_MAC_RX_PAUSEf_SET(r,f) (r).mac_mode[0]=(((r).mac_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_MAC_MODEr_MAC_TX_PAUSEf_GET(r) ((((r).mac_mode[0]) >> 4) & 0x1)
#define BCM53324_A0_MAC_MODEr_MAC_TX_PAUSEf_SET(r,f) (r).mac_mode[0]=(((r).mac_mode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_MAC_MODEr_LINK_STATUSf_GET(r) ((((r).mac_mode[0]) >> 5) & 0x1)
#define BCM53324_A0_MAC_MODEr_LINK_STATUSf_SET(r,f) (r).mac_mode[0]=(((r).mac_mode[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MAC_MODE.
 *
 */
#define BCM53324_A0_READ_MAC_MODEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MAC_MODEr,(r._mac_mode))
#define BCM53324_A0_WRITE_MAC_MODEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MAC_MODEr,&(r._mac_mode))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_MODEr BCM53324_A0_MAC_MODEr
#define MAC_MODEr_SIZE BCM53324_A0_MAC_MODEr_SIZE
typedef BCM53324_A0_MAC_MODEr_t MAC_MODEr_t;
#define MAC_MODEr_CLR BCM53324_A0_MAC_MODEr_CLR
#define MAC_MODEr_SET BCM53324_A0_MAC_MODEr_SET
#define MAC_MODEr_GET BCM53324_A0_MAC_MODEr_GET
#define MAC_MODEr_MAC_SPEEDf_GET BCM53324_A0_MAC_MODEr_MAC_SPEEDf_GET
#define MAC_MODEr_MAC_SPEEDf_SET BCM53324_A0_MAC_MODEr_MAC_SPEEDf_SET
#define MAC_MODEr_MAC_DUPLEXf_GET BCM53324_A0_MAC_MODEr_MAC_DUPLEXf_GET
#define MAC_MODEr_MAC_DUPLEXf_SET BCM53324_A0_MAC_MODEr_MAC_DUPLEXf_SET
#define MAC_MODEr_MAC_RX_PAUSEf_GET BCM53324_A0_MAC_MODEr_MAC_RX_PAUSEf_GET
#define MAC_MODEr_MAC_RX_PAUSEf_SET BCM53324_A0_MAC_MODEr_MAC_RX_PAUSEf_SET
#define MAC_MODEr_MAC_TX_PAUSEf_GET BCM53324_A0_MAC_MODEr_MAC_TX_PAUSEf_GET
#define MAC_MODEr_MAC_TX_PAUSEf_SET BCM53324_A0_MAC_MODEr_MAC_TX_PAUSEf_SET
#define MAC_MODEr_LINK_STATUSf_GET BCM53324_A0_MAC_MODEr_LINK_STATUSf_GET
#define MAC_MODEr_LINK_STATUSf_SET BCM53324_A0_MAC_MODEr_LINK_STATUSf_SET
#define READ_MAC_MODEr BCM53324_A0_READ_MAC_MODEr
#define WRITE_MAC_MODEr BCM53324_A0_WRITE_MAC_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAC_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MAXBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MAX_BUCKET       Maximum rate bucket or EAV bucket (COS3 and 2 only) in EAV mode, with each unit representing 0.5 bit.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of maximum rate bucket or EAV bucket (COS3 and 2 only) in EAV mode.1: Out of profile0: In profileDefault value is in profile.
 *
 ******************************************************************************/
#define BCM53324_A0_MAXBUCKETr 0x0060008b

#define BCM53324_A0_MAXBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program MAXBUCKET.
 *
 */
typedef union BCM53324_A0_MAXBUCKETr_s {
	uint32_t v[1];
	uint32_t maxbucket[1];
	uint32_t _maxbucket;
} BCM53324_A0_MAXBUCKETr_t;

#define BCM53324_A0_MAXBUCKETr_CLR(r) (r).maxbucket[0] = 0
#define BCM53324_A0_MAXBUCKETr_SET(r,d) (r).maxbucket[0] = d
#define BCM53324_A0_MAXBUCKETr_GET(r) (r).maxbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAXBUCKETr_MAX_BUCKETf_GET(r) (((r).maxbucket[0]) & 0x1fffffff)
#define BCM53324_A0_MAXBUCKETr_MAX_BUCKETf_SET(r,f) (r).maxbucket[0]=(((r).maxbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53324_A0_MAXBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).maxbucket[0]) >> 29) & 0x1)
#define BCM53324_A0_MAXBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).maxbucket[0]=(((r).maxbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access MAXBUCKET.
 *
 */
#define BCM53324_A0_READ_MAXBUCKETr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MAXBUCKETr+(i),(r._maxbucket))
#define BCM53324_A0_WRITE_MAXBUCKETr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MAXBUCKETr+(i),&(r._maxbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXBUCKETr BCM53324_A0_MAXBUCKETr
#define MAXBUCKETr_SIZE BCM53324_A0_MAXBUCKETr_SIZE
typedef BCM53324_A0_MAXBUCKETr_t MAXBUCKETr_t;
#define MAXBUCKETr_CLR BCM53324_A0_MAXBUCKETr_CLR
#define MAXBUCKETr_SET BCM53324_A0_MAXBUCKETr_SET
#define MAXBUCKETr_GET BCM53324_A0_MAXBUCKETr_GET
#define MAXBUCKETr_MAX_BUCKETf_GET BCM53324_A0_MAXBUCKETr_MAX_BUCKETf_GET
#define MAXBUCKETr_MAX_BUCKETf_SET BCM53324_A0_MAXBUCKETr_MAX_BUCKETf_SET
#define MAXBUCKETr_IN_PROFILE_FLAGf_GET BCM53324_A0_MAXBUCKETr_IN_PROFILE_FLAGf_GET
#define MAXBUCKETr_IN_PROFILE_FLAGf_SET BCM53324_A0_MAXBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_MAXBUCKETr BCM53324_A0_READ_MAXBUCKETr
#define WRITE_MAXBUCKETr BCM53324_A0_WRITE_MAXBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAXBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MAXBUCKETCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Threshold for Maximum Bucket size for MAX Shaping and EAV Shaping. The setting of Threshold determines the size of bucket.The Bucket size is range from 4k Bytes to 16M Bytes with 4k Bytes incrementThe Bucket size is determined by the formula,BucketSize = MAX_THD_SEL * 4KBytesMax/EAV Bucket function is disable when bucket size is 0.
 *     MAX_REFRESH      Refresh count for Maximum Bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set MAX_REFRESH = 7812, Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set MAX_REFRESH = 15624.When EAV is enabled for a port, this register is used to program the rate of the EAV shaper at the same granualrity as a MAX bucket.This EAV setting applies to COS3 and COS2 only in EAV mode.
 *
 ******************************************************************************/
#define BCM53324_A0_MAXBUCKETCONFIGr 0x00600083

#define BCM53324_A0_MAXBUCKETCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MAXBUCKETCONFIG.
 *
 */
typedef union BCM53324_A0_MAXBUCKETCONFIGr_s {
	uint32_t v[1];
	uint32_t maxbucketconfig[1];
	uint32_t _maxbucketconfig;
} BCM53324_A0_MAXBUCKETCONFIGr_t;

#define BCM53324_A0_MAXBUCKETCONFIGr_CLR(r) (r).maxbucketconfig[0] = 0
#define BCM53324_A0_MAXBUCKETCONFIGr_SET(r,d) (r).maxbucketconfig[0] = d
#define BCM53324_A0_MAXBUCKETCONFIGr_GET(r) (r).maxbucketconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_GET(r) (((r).maxbucketconfig[0]) & 0xfff)
#define BCM53324_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_GET(r) ((((r).maxbucketconfig[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access MAXBUCKETCONFIG.
 *
 */
#define BCM53324_A0_READ_MAXBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MAXBUCKETCONFIGr+(i),(r._maxbucketconfig))
#define BCM53324_A0_WRITE_MAXBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MAXBUCKETCONFIGr+(i),&(r._maxbucketconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXBUCKETCONFIGr BCM53324_A0_MAXBUCKETCONFIGr
#define MAXBUCKETCONFIGr_SIZE BCM53324_A0_MAXBUCKETCONFIGr_SIZE
typedef BCM53324_A0_MAXBUCKETCONFIGr_t MAXBUCKETCONFIGr_t;
#define MAXBUCKETCONFIGr_CLR BCM53324_A0_MAXBUCKETCONFIGr_CLR
#define MAXBUCKETCONFIGr_SET BCM53324_A0_MAXBUCKETCONFIGr_SET
#define MAXBUCKETCONFIGr_GET BCM53324_A0_MAXBUCKETCONFIGr_GET
#define MAXBUCKETCONFIGr_MAX_THD_SELf_GET BCM53324_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_GET
#define MAXBUCKETCONFIGr_MAX_THD_SELf_SET BCM53324_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_SET
#define MAXBUCKETCONFIGr_MAX_REFRESHf_GET BCM53324_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_GET
#define MAXBUCKETCONFIGr_MAX_REFRESHf_SET BCM53324_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_SET
#define READ_MAXBUCKETCONFIGr BCM53324_A0_READ_MAXBUCKETCONFIGr
#define WRITE_MAXBUCKETCONFIGr BCM53324_A0_WRITE_MAXBUCKETCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MAXBUCKETCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MCAST_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Multicast Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           Multicast rate control enable
 *
 ******************************************************************************/
#define BCM53324_A0_MCAST_STORM_CONTROLr 0x0c700002

#define BCM53324_A0_MCAST_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MCAST_STORM_CONTROL.
 *
 */
typedef union BCM53324_A0_MCAST_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t mcast_storm_control[1];
	uint32_t _mcast_storm_control;
} BCM53324_A0_MCAST_STORM_CONTROLr_t;

#define BCM53324_A0_MCAST_STORM_CONTROLr_CLR(r) (r).mcast_storm_control[0] = 0
#define BCM53324_A0_MCAST_STORM_CONTROLr_SET(r,d) (r).mcast_storm_control[0] = d
#define BCM53324_A0_MCAST_STORM_CONTROLr_GET(r) (r).mcast_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MCAST_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).mcast_storm_control[0]) & 0x1ffffff)
#define BCM53324_A0_MCAST_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).mcast_storm_control[0]=(((r).mcast_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_MCAST_STORM_CONTROLr_ENABLEf_GET(r) ((((r).mcast_storm_control[0]) >> 25) & 0x1)
#define BCM53324_A0_MCAST_STORM_CONTROLr_ENABLEf_SET(r,f) (r).mcast_storm_control[0]=(((r).mcast_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access MCAST_STORM_CONTROL.
 *
 */
#define BCM53324_A0_READ_MCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MCAST_STORM_CONTROLr,(r._mcast_storm_control))
#define BCM53324_A0_WRITE_MCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MCAST_STORM_CONTROLr,&(r._mcast_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MCAST_STORM_CONTROLr BCM53324_A0_MCAST_STORM_CONTROLr
#define MCAST_STORM_CONTROLr_SIZE BCM53324_A0_MCAST_STORM_CONTROLr_SIZE
typedef BCM53324_A0_MCAST_STORM_CONTROLr_t MCAST_STORM_CONTROLr_t;
#define MCAST_STORM_CONTROLr_CLR BCM53324_A0_MCAST_STORM_CONTROLr_CLR
#define MCAST_STORM_CONTROLr_SET BCM53324_A0_MCAST_STORM_CONTROLr_SET
#define MCAST_STORM_CONTROLr_GET BCM53324_A0_MCAST_STORM_CONTROLr_GET
#define MCAST_STORM_CONTROLr_THRESHOLDf_GET BCM53324_A0_MCAST_STORM_CONTROLr_THRESHOLDf_GET
#define MCAST_STORM_CONTROLr_THRESHOLDf_SET BCM53324_A0_MCAST_STORM_CONTROLr_THRESHOLDf_SET
#define MCAST_STORM_CONTROLr_ENABLEf_GET BCM53324_A0_MCAST_STORM_CONTROLr_ENABLEf_GET
#define MCAST_STORM_CONTROLr_ENABLEf_SET BCM53324_A0_MCAST_STORM_CONTROLr_ENABLEf_SET
#define READ_MCAST_STORM_CONTROLr BCM53324_A0_READ_MCAST_STORM_CONTROLr
#define WRITE_MCAST_STORM_CONTROLr BCM53324_A0_WRITE_MCAST_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MCAST_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MEMFAILINTMASK
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFAILINTMASK  MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt for CFAP memory stack underrun or overrun condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default.Any corruption of this memory can cause CBP memory leak. Hence, this failure is propagated to CMIC by default
 *     SOFTRESETINTMASK MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt for receiving a first cell follow by a first cell without end cell condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. This error wouldn't hamper the operation of the chip. Hence, this failure is not propagated to CMIC by default
 *     CELLNOTIPINTMASK MMU Memfail Interrupt enable bit to enable MMU MemFail Interrupt fordetecting sending out garbage cells not in packet process. ie. Cell after End-Cell without a start bit. or Two Start cell without anEnd Cell in between.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. This error wouldn't hamper the operation of the chip. Hence, this failure is not propagated to CMIC by default
 *     CRCERRORINTMASK  MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt fordetecting a failure of CBP cell data memory crc error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. A CRC error only affects the current packet and wouldn't hamper the operation of the chip. Hence, this failure is not propagated to CMIC by default
 *     CBPPKTHDRPARITYERRORINTMASK MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt fordetecting a failure of CBP packet header memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MmU MemFail Interrupt. Default. A parity error in CBPCellHeader may be due to the corruption of the PKT_PTR. Hence, this failure is propagated to CMIC by default
 *     CBPCELLHDRPARITYERRORINTMASK MMU Memfail Interrupt Mask bit to enable MMU MemFail Interrupt whendetecting a failure of CBP cell header memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. A parity error in CBPCellHeader may be due to the corruption of the NEXT_CELL_POINTER. Hence, this failure is propagated to CMIC by default
 *     XQPARITYERRORINTMASK MMU Memfail Interrupt Mask to enable MMU send out MemFail Interrupt whendetecting a failure of XQ memory parity error condition.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. Any corruption of this memory can corrupt XQ link list. Hence, this failure is propagated to CMIC by default
 *     CFAPPARITYERRORINTMASK MMU CFAP Memory parity fail status for detecting cfap memory parity error. 1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. Any corruption of this memory can cause CBP memory leak. Hence, this failure is propagated to CMIC by default
 *     CCPPARITYERRORINTMASK MMU CCP Memory parity fail interrupt Mask for detecting ccp memory parity error.1: Enable MMU MemFail Interrupt. 0: Disable MMU MemFail Interrupt. Default. Any corruption of this memory can cause CBP memory leak. Hence, this failure is propagated to CMIC by default
 *
 ******************************************************************************/
#define BCM53324_A0_MEMFAILINTMASKr 0x00680027

#define BCM53324_A0_MEMFAILINTMASKr_SIZE 4

/*
 * This structure should be used to declare and program MEMFAILINTMASK.
 *
 */
typedef union BCM53324_A0_MEMFAILINTMASKr_s {
	uint32_t v[1];
	uint32_t memfailintmask[1];
	uint32_t _memfailintmask;
} BCM53324_A0_MEMFAILINTMASKr_t;

#define BCM53324_A0_MEMFAILINTMASKr_CLR(r) (r).memfailintmask[0] = 0
#define BCM53324_A0_MEMFAILINTMASKr_SET(r,d) (r).memfailintmask[0] = d
#define BCM53324_A0_MEMFAILINTMASKr_GET(r) (r).memfailintmask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_GET(r) (((r).memfailintmask[0]) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 1) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 2) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 3) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 4) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 5) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 6) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 7) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET(r) ((((r).memfailintmask[0]) >> 8) & 0x1)
#define BCM53324_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET(r,f) (r).memfailintmask[0]=(((r).memfailintmask[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MEMFAILINTMASK.
 *
 */
#define BCM53324_A0_READ_MEMFAILINTMASKr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MEMFAILINTMASKr,(r._memfailintmask))
#define BCM53324_A0_WRITE_MEMFAILINTMASKr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MEMFAILINTMASKr,&(r._memfailintmask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMFAILINTMASKr BCM53324_A0_MEMFAILINTMASKr
#define MEMFAILINTMASKr_SIZE BCM53324_A0_MEMFAILINTMASKr_SIZE
typedef BCM53324_A0_MEMFAILINTMASKr_t MEMFAILINTMASKr_t;
#define MEMFAILINTMASKr_CLR BCM53324_A0_MEMFAILINTMASKr_CLR
#define MEMFAILINTMASKr_SET BCM53324_A0_MEMFAILINTMASKr_SET
#define MEMFAILINTMASKr_GET BCM53324_A0_MEMFAILINTMASKr_GET
#define MEMFAILINTMASKr_CFAPFAILINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_GET
#define MEMFAILINTMASKr_CFAPFAILINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_CFAPFAILINTMASKf_SET
#define MEMFAILINTMASKr_SOFTRESETINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_GET
#define MEMFAILINTMASKr_SOFTRESETINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_SOFTRESETINTMASKf_SET
#define MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_GET
#define MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_CELLNOTIPINTMASKf_SET
#define MEMFAILINTMASKr_CRCERRORINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_GET
#define MEMFAILINTMASKr_CRCERRORINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_CRCERRORINTMASKf_SET
#define MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_CBPPKTHDRPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_CBPCELLHDRPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_XQPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_CFAPPARITYERRORINTMASKf_SET
#define MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET BCM53324_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_GET
#define MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET BCM53324_A0_MEMFAILINTMASKr_CCPPARITYERRORINTMASKf_SET
#define READ_MEMFAILINTMASKr BCM53324_A0_READ_MEMFAILINTMASKr
#define WRITE_MEMFAILINTMASKr BCM53324_A0_WRITE_MEMFAILINTMASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MEMFAILINTMASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MEMFAILINTSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     CFAPFAILERROR    MMU CFAP Fail Status for CFAP memory stack underrun or overrun condition. 
 *     SOFTRESETERROR   MMU detect software reset error status for receiving a first cell follow by a first cell without end cell condition.
 *     CELLNOTIPERROR   MMU Sending Cell Not In Progress error status for MMU sending out garbage cells not in packet. ie. Cell after End-Cell without a start bit.
 *     CELLCRCERROR     MMU CBP cell data crc fail status for detecting data emory crc error. 
 *     CBPPKTHDRPARITYERROR MMU CBP Packet Header Memory parity fail status for detecting packet header memory parity error. 
 *     CBPCELLHDRPARITYERROR MMU CBP Cell Header Memory parity fail status for detecting cell header memory parity error. CBP Cell Header Memory parity bit [32] covered from bit 0 bit 15. Cell CRC checksum field, bit 16 to bit 31, is not covered by paritycheck. 
 *     XQPARITYERROR    MMU XQ Memory parity fail status for detecting xq memory parity error. 
 *     CFAPPARITYERROR  MMU CFAP Memory parity fail status for detecting cfap memory parity error. 
 *     CCPPARITYERROR   MMU CCP Memory parity fail status for detecting ccp memory parity error. 
 *     MEMFAILINTCOUNT  Mem Fail Message Counter to count mem fail events. 
 *
 ******************************************************************************/
#define BCM53324_A0_MEMFAILINTSTATUSr 0x00680028

#define BCM53324_A0_MEMFAILINTSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program MEMFAILINTSTATUS.
 *
 */
typedef union BCM53324_A0_MEMFAILINTSTATUSr_s {
	uint32_t v[1];
	uint32_t memfailintstatus[1];
	uint32_t _memfailintstatus;
} BCM53324_A0_MEMFAILINTSTATUSr_t;

#define BCM53324_A0_MEMFAILINTSTATUSr_CLR(r) (r).memfailintstatus[0] = 0
#define BCM53324_A0_MEMFAILINTSTATUSr_SET(r,d) (r).memfailintstatus[0] = d
#define BCM53324_A0_MEMFAILINTSTATUSr_GET(r) (r).memfailintstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_GET(r) (((r).memfailintstatus[0]) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_GET(r) ((((r).memfailintstatus[0]) >> 1) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET(r) ((((r).memfailintstatus[0]) >> 2) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_GET(r) ((((r).memfailintstatus[0]) >> 3) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 4) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 5) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 6) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 7) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_GET(r) ((((r).memfailintstatus[0]) >> 8) & 0x1)
#define BCM53324_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET(r) ((((r).memfailintstatus[0]) >> 9) & 0xffff)
#define BCM53324_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET(r,f) (r).memfailintstatus[0]=(((r).memfailintstatus[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))

/*
 * These macros can be used to access MEMFAILINTSTATUS.
 *
 */
#define BCM53324_A0_READ_MEMFAILINTSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MEMFAILINTSTATUSr,(r._memfailintstatus))
#define BCM53324_A0_WRITE_MEMFAILINTSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MEMFAILINTSTATUSr,&(r._memfailintstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMFAILINTSTATUSr BCM53324_A0_MEMFAILINTSTATUSr
#define MEMFAILINTSTATUSr_SIZE BCM53324_A0_MEMFAILINTSTATUSr_SIZE
typedef BCM53324_A0_MEMFAILINTSTATUSr_t MEMFAILINTSTATUSr_t;
#define MEMFAILINTSTATUSr_CLR BCM53324_A0_MEMFAILINTSTATUSr_CLR
#define MEMFAILINTSTATUSr_SET BCM53324_A0_MEMFAILINTSTATUSr_SET
#define MEMFAILINTSTATUSr_GET BCM53324_A0_MEMFAILINTSTATUSr_GET
#define MEMFAILINTSTATUSr_CFAPFAILERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_GET
#define MEMFAILINTSTATUSr_CFAPFAILERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_CFAPFAILERRORf_SET
#define MEMFAILINTSTATUSr_SOFTRESETERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_GET
#define MEMFAILINTSTATUSr_SOFTRESETERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_SOFTRESETERRORf_SET
#define MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_GET
#define MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_CELLNOTIPERRORf_SET
#define MEMFAILINTSTATUSr_CELLCRCERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_GET
#define MEMFAILINTSTATUSr_CELLCRCERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_CELLCRCERRORf_SET
#define MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_CBPPKTHDRPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_CBPCELLHDRPARITYERRORf_SET
#define MEMFAILINTSTATUSr_XQPARITYERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_GET
#define MEMFAILINTSTATUSr_XQPARITYERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_XQPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_CFAPPARITYERRORf_SET
#define MEMFAILINTSTATUSr_CCPPARITYERRORf_GET BCM53324_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_GET
#define MEMFAILINTSTATUSr_CCPPARITYERRORf_SET BCM53324_A0_MEMFAILINTSTATUSr_CCPPARITYERRORf_SET
#define MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET BCM53324_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_GET
#define MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET BCM53324_A0_MEMFAILINTSTATUSr_MEMFAILINTCOUNTf_SET
#define READ_MEMFAILINTSTATUSr BCM53324_A0_READ_MEMFAILINTSTATUSr
#define WRITE_MEMFAILINTSTATUSr BCM53324_A0_WRITE_MEMFAILINTSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MEMFAILINTSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MINBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_BUCKET       Minimum rate bucket with unit is 0.5 bit.
 *     IN_PROFILE_FLAG  IN_PROFILE_FLAG inidcates the current state of minimum rate bucket1: Out profile0: In profileDefault value is out profile.
 *
 ******************************************************************************/
#define BCM53324_A0_MINBUCKETr 0x0060007b

#define BCM53324_A0_MINBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKET.
 *
 */
typedef union BCM53324_A0_MINBUCKETr_s {
	uint32_t v[1];
	uint32_t minbucket[1];
	uint32_t _minbucket;
} BCM53324_A0_MINBUCKETr_t;

#define BCM53324_A0_MINBUCKETr_CLR(r) (r).minbucket[0] = 0
#define BCM53324_A0_MINBUCKETr_SET(r,d) (r).minbucket[0] = d
#define BCM53324_A0_MINBUCKETr_GET(r) (r).minbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MINBUCKETr_MIN_BUCKETf_GET(r) (((r).minbucket[0]) & 0x1fffffff)
#define BCM53324_A0_MINBUCKETr_MIN_BUCKETf_SET(r,f) (r).minbucket[0]=(((r).minbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM53324_A0_MINBUCKETr_IN_PROFILE_FLAGf_GET(r) ((((r).minbucket[0]) >> 29) & 0x1)
#define BCM53324_A0_MINBUCKETr_IN_PROFILE_FLAGf_SET(r,f) (r).minbucket[0]=(((r).minbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access MINBUCKET.
 *
 */
#define BCM53324_A0_READ_MINBUCKETr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MINBUCKETr+(i),(r._minbucket))
#define BCM53324_A0_WRITE_MINBUCKETr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MINBUCKETr+(i),&(r._minbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETr BCM53324_A0_MINBUCKETr
#define MINBUCKETr_SIZE BCM53324_A0_MINBUCKETr_SIZE
typedef BCM53324_A0_MINBUCKETr_t MINBUCKETr_t;
#define MINBUCKETr_CLR BCM53324_A0_MINBUCKETr_CLR
#define MINBUCKETr_SET BCM53324_A0_MINBUCKETr_SET
#define MINBUCKETr_GET BCM53324_A0_MINBUCKETr_GET
#define MINBUCKETr_MIN_BUCKETf_GET BCM53324_A0_MINBUCKETr_MIN_BUCKETf_GET
#define MINBUCKETr_MIN_BUCKETf_SET BCM53324_A0_MINBUCKETr_MIN_BUCKETf_SET
#define MINBUCKETr_IN_PROFILE_FLAGf_GET BCM53324_A0_MINBUCKETr_IN_PROFILE_FLAGf_GET
#define MINBUCKETr_IN_PROFILE_FLAGf_SET BCM53324_A0_MINBUCKETr_IN_PROFILE_FLAGf_SET
#define READ_MINBUCKETr BCM53324_A0_READ_MINBUCKETr
#define WRITE_MINBUCKETr BCM53324_A0_WRITE_MINBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MINBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MINBUCKETCOS0CONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_THD_SEL      Threshold determines the size of Minimum Bucket. This Threshold setting is not related to actual bandwidth rate number.The Bucket size is range from 4k Bytes to 16M Bytes with 4k Bytes incrementThe Bucket size is determined by the formula,BucketSize = MIN_THD_SEL * 4KBytesMin Bucket function is disable when bucket size is 0.<b>The MIN bucket size for COS0(best effort traffic), defaults to 4K bytes for Unmanaged mode</b>
 *     MIN_REFRESH      Refresh count for minimum rate bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set MIN_REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set MIN_REFRESH = 15624.<b> For unmanaged mode, the MIN guaranty is set to 64Kbps for best effort traffic</b>
 *
 ******************************************************************************/
#define BCM53324_A0_MINBUCKETCOS0CONFIGr 0x00600073

#define BCM53324_A0_MINBUCKETCOS0CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKETCOS0CONFIG.
 *
 */
typedef union BCM53324_A0_MINBUCKETCOS0CONFIGr_s {
	uint32_t v[1];
	uint32_t minbucketcos0config[1];
	uint32_t _minbucketcos0config;
} BCM53324_A0_MINBUCKETCOS0CONFIGr_t;

#define BCM53324_A0_MINBUCKETCOS0CONFIGr_CLR(r) (r).minbucketcos0config[0] = 0
#define BCM53324_A0_MINBUCKETCOS0CONFIGr_SET(r,d) (r).minbucketcos0config[0] = d
#define BCM53324_A0_MINBUCKETCOS0CONFIGr_GET(r) (r).minbucketcos0config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MINBUCKETCOS0CONFIGr_MIN_THD_SELf_GET(r) (((r).minbucketcos0config[0]) & 0xfff)
#define BCM53324_A0_MINBUCKETCOS0CONFIGr_MIN_THD_SELf_SET(r,f) (r).minbucketcos0config[0]=(((r).minbucketcos0config[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_MINBUCKETCOS0CONFIGr_MIN_REFRESHf_GET(r) ((((r).minbucketcos0config[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_MINBUCKETCOS0CONFIGr_MIN_REFRESHf_SET(r,f) (r).minbucketcos0config[0]=(((r).minbucketcos0config[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access MINBUCKETCOS0CONFIG.
 *
 */
#define BCM53324_A0_READ_MINBUCKETCOS0CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MINBUCKETCOS0CONFIGr,(r._minbucketcos0config))
#define BCM53324_A0_WRITE_MINBUCKETCOS0CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MINBUCKETCOS0CONFIGr,&(r._minbucketcos0config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETCOS0CONFIGr BCM53324_A0_MINBUCKETCOS0CONFIGr
#define MINBUCKETCOS0CONFIGr_SIZE BCM53324_A0_MINBUCKETCOS0CONFIGr_SIZE
typedef BCM53324_A0_MINBUCKETCOS0CONFIGr_t MINBUCKETCOS0CONFIGr_t;
#define MINBUCKETCOS0CONFIGr_CLR BCM53324_A0_MINBUCKETCOS0CONFIGr_CLR
#define MINBUCKETCOS0CONFIGr_SET BCM53324_A0_MINBUCKETCOS0CONFIGr_SET
#define MINBUCKETCOS0CONFIGr_GET BCM53324_A0_MINBUCKETCOS0CONFIGr_GET
#define MINBUCKETCOS0CONFIGr_MIN_THD_SELf_GET BCM53324_A0_MINBUCKETCOS0CONFIGr_MIN_THD_SELf_GET
#define MINBUCKETCOS0CONFIGr_MIN_THD_SELf_SET BCM53324_A0_MINBUCKETCOS0CONFIGr_MIN_THD_SELf_SET
#define MINBUCKETCOS0CONFIGr_MIN_REFRESHf_GET BCM53324_A0_MINBUCKETCOS0CONFIGr_MIN_REFRESHf_GET
#define MINBUCKETCOS0CONFIGr_MIN_REFRESHf_SET BCM53324_A0_MINBUCKETCOS0CONFIGr_MIN_REFRESHf_SET
#define READ_MINBUCKETCOS0CONFIGr BCM53324_A0_READ_MINBUCKETCOS0CONFIGr
#define WRITE_MINBUCKETCOS0CONFIGr BCM53324_A0_WRITE_MINBUCKETCOS0CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MINBUCKETCOS0CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MINBUCKETCOS1CONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_THD_SEL      Threshold determines the size of Minimum Bucket. This Threshold setting is not related to actual bandwidth rate number.The Bucket size is range from 4k Bytes to 16M Bytes with 4k Bytes incrementThe Bucket size is determined by the formula,BucketSize = MIN_THD_SEL * 4KBytesMin Bucket function is disable when bucket size is 0.<b>The MIN bucket size for COS1(voice traffic), defaults to 16K bytes for Unmanaged mode</b>
 *     MIN_REFRESH      Refresh count for minimum rate bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set MIN_REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set MIN_REFRESH = 15624.<b> For unmanaged mode, the MIN guaranty is set to 64Kbps for voice traffic</b>
 *
 ******************************************************************************/
#define BCM53324_A0_MINBUCKETCOS1CONFIGr 0x00600074

#define BCM53324_A0_MINBUCKETCOS1CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKETCOS1CONFIG.
 *
 */
typedef union BCM53324_A0_MINBUCKETCOS1CONFIGr_s {
	uint32_t v[1];
	uint32_t minbucketcos1config[1];
	uint32_t _minbucketcos1config;
} BCM53324_A0_MINBUCKETCOS1CONFIGr_t;

#define BCM53324_A0_MINBUCKETCOS1CONFIGr_CLR(r) (r).minbucketcos1config[0] = 0
#define BCM53324_A0_MINBUCKETCOS1CONFIGr_SET(r,d) (r).minbucketcos1config[0] = d
#define BCM53324_A0_MINBUCKETCOS1CONFIGr_GET(r) (r).minbucketcos1config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MINBUCKETCOS1CONFIGr_MIN_THD_SELf_GET(r) (((r).minbucketcos1config[0]) & 0xfff)
#define BCM53324_A0_MINBUCKETCOS1CONFIGr_MIN_THD_SELf_SET(r,f) (r).minbucketcos1config[0]=(((r).minbucketcos1config[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_MINBUCKETCOS1CONFIGr_MIN_REFRESHf_GET(r) ((((r).minbucketcos1config[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_MINBUCKETCOS1CONFIGr_MIN_REFRESHf_SET(r,f) (r).minbucketcos1config[0]=(((r).minbucketcos1config[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access MINBUCKETCOS1CONFIG.
 *
 */
#define BCM53324_A0_READ_MINBUCKETCOS1CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MINBUCKETCOS1CONFIGr,(r._minbucketcos1config))
#define BCM53324_A0_WRITE_MINBUCKETCOS1CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MINBUCKETCOS1CONFIGr,&(r._minbucketcos1config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETCOS1CONFIGr BCM53324_A0_MINBUCKETCOS1CONFIGr
#define MINBUCKETCOS1CONFIGr_SIZE BCM53324_A0_MINBUCKETCOS1CONFIGr_SIZE
typedef BCM53324_A0_MINBUCKETCOS1CONFIGr_t MINBUCKETCOS1CONFIGr_t;
#define MINBUCKETCOS1CONFIGr_CLR BCM53324_A0_MINBUCKETCOS1CONFIGr_CLR
#define MINBUCKETCOS1CONFIGr_SET BCM53324_A0_MINBUCKETCOS1CONFIGr_SET
#define MINBUCKETCOS1CONFIGr_GET BCM53324_A0_MINBUCKETCOS1CONFIGr_GET
#define MINBUCKETCOS1CONFIGr_MIN_THD_SELf_GET BCM53324_A0_MINBUCKETCOS1CONFIGr_MIN_THD_SELf_GET
#define MINBUCKETCOS1CONFIGr_MIN_THD_SELf_SET BCM53324_A0_MINBUCKETCOS1CONFIGr_MIN_THD_SELf_SET
#define MINBUCKETCOS1CONFIGr_MIN_REFRESHf_GET BCM53324_A0_MINBUCKETCOS1CONFIGr_MIN_REFRESHf_GET
#define MINBUCKETCOS1CONFIGr_MIN_REFRESHf_SET BCM53324_A0_MINBUCKETCOS1CONFIGr_MIN_REFRESHf_SET
#define READ_MINBUCKETCOS1CONFIGr BCM53324_A0_READ_MINBUCKETCOS1CONFIGr
#define WRITE_MINBUCKETCOS1CONFIGr BCM53324_A0_WRITE_MINBUCKETCOS1CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MINBUCKETCOS1CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MINBUCKETCOS2CONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_THD_SEL      Threshold determines the size of Minimum Bucket. This Threshold setting is not related to actual bandwidth rate number.The Bucket size is range from 4k Bytes to 16M Bytes with 4k Bytes incrementThe Bucket size is determined by the formula,BucketSize = MIN_THD_SEL * 4KBytesMin Bucket function is disable when bucket size is 0.
 *     MIN_REFRESH      Refresh count for minimum rate bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set MIN_REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set MIN_REFRESH = 15624.
 *
 ******************************************************************************/
#define BCM53324_A0_MINBUCKETCOS2CONFIGr 0x00600075

#define BCM53324_A0_MINBUCKETCOS2CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKETCOS2CONFIG.
 *
 */
typedef union BCM53324_A0_MINBUCKETCOS2CONFIGr_s {
	uint32_t v[1];
	uint32_t minbucketcos2config[1];
	uint32_t _minbucketcos2config;
} BCM53324_A0_MINBUCKETCOS2CONFIGr_t;

#define BCM53324_A0_MINBUCKETCOS2CONFIGr_CLR(r) (r).minbucketcos2config[0] = 0
#define BCM53324_A0_MINBUCKETCOS2CONFIGr_SET(r,d) (r).minbucketcos2config[0] = d
#define BCM53324_A0_MINBUCKETCOS2CONFIGr_GET(r) (r).minbucketcos2config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MINBUCKETCOS2CONFIGr_MIN_THD_SELf_GET(r) (((r).minbucketcos2config[0]) & 0xfff)
#define BCM53324_A0_MINBUCKETCOS2CONFIGr_MIN_THD_SELf_SET(r,f) (r).minbucketcos2config[0]=(((r).minbucketcos2config[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_MINBUCKETCOS2CONFIGr_MIN_REFRESHf_GET(r) ((((r).minbucketcos2config[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_MINBUCKETCOS2CONFIGr_MIN_REFRESHf_SET(r,f) (r).minbucketcos2config[0]=(((r).minbucketcos2config[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access MINBUCKETCOS2CONFIG.
 *
 */
#define BCM53324_A0_READ_MINBUCKETCOS2CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MINBUCKETCOS2CONFIGr,(r._minbucketcos2config))
#define BCM53324_A0_WRITE_MINBUCKETCOS2CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MINBUCKETCOS2CONFIGr,&(r._minbucketcos2config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETCOS2CONFIGr BCM53324_A0_MINBUCKETCOS2CONFIGr
#define MINBUCKETCOS2CONFIGr_SIZE BCM53324_A0_MINBUCKETCOS2CONFIGr_SIZE
typedef BCM53324_A0_MINBUCKETCOS2CONFIGr_t MINBUCKETCOS2CONFIGr_t;
#define MINBUCKETCOS2CONFIGr_CLR BCM53324_A0_MINBUCKETCOS2CONFIGr_CLR
#define MINBUCKETCOS2CONFIGr_SET BCM53324_A0_MINBUCKETCOS2CONFIGr_SET
#define MINBUCKETCOS2CONFIGr_GET BCM53324_A0_MINBUCKETCOS2CONFIGr_GET
#define MINBUCKETCOS2CONFIGr_MIN_THD_SELf_GET BCM53324_A0_MINBUCKETCOS2CONFIGr_MIN_THD_SELf_GET
#define MINBUCKETCOS2CONFIGr_MIN_THD_SELf_SET BCM53324_A0_MINBUCKETCOS2CONFIGr_MIN_THD_SELf_SET
#define MINBUCKETCOS2CONFIGr_MIN_REFRESHf_GET BCM53324_A0_MINBUCKETCOS2CONFIGr_MIN_REFRESHf_GET
#define MINBUCKETCOS2CONFIGr_MIN_REFRESHf_SET BCM53324_A0_MINBUCKETCOS2CONFIGr_MIN_REFRESHf_SET
#define READ_MINBUCKETCOS2CONFIGr BCM53324_A0_READ_MINBUCKETCOS2CONFIGr
#define WRITE_MINBUCKETCOS2CONFIGr BCM53324_A0_WRITE_MINBUCKETCOS2CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MINBUCKETCOS2CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MINBUCKETCOS3CONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_THD_SEL      Threshold determines the size of Minimum Bucket. This Threshold setting is not related to actual bandwidth rate number.The Bucket size is range from 4k Bytes to 16M Bytes with 4k Bytes incrementThe Bucket size is determined by the formula,BucketSize = MIN_THD_SEL * 4KBytesMin Bucket function is disable when bucket size is 0.
 *     MIN_REFRESH      Refresh count for minimum rate bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set MIN_REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set MIN_REFRESH = 15624.
 *
 ******************************************************************************/
#define BCM53324_A0_MINBUCKETCOS3CONFIGr 0x00600076

#define BCM53324_A0_MINBUCKETCOS3CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKETCOS3CONFIG.
 *
 */
typedef union BCM53324_A0_MINBUCKETCOS3CONFIGr_s {
	uint32_t v[1];
	uint32_t minbucketcos3config[1];
	uint32_t _minbucketcos3config;
} BCM53324_A0_MINBUCKETCOS3CONFIGr_t;

#define BCM53324_A0_MINBUCKETCOS3CONFIGr_CLR(r) (r).minbucketcos3config[0] = 0
#define BCM53324_A0_MINBUCKETCOS3CONFIGr_SET(r,d) (r).minbucketcos3config[0] = d
#define BCM53324_A0_MINBUCKETCOS3CONFIGr_GET(r) (r).minbucketcos3config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MINBUCKETCOS3CONFIGr_MIN_THD_SELf_GET(r) (((r).minbucketcos3config[0]) & 0xfff)
#define BCM53324_A0_MINBUCKETCOS3CONFIGr_MIN_THD_SELf_SET(r,f) (r).minbucketcos3config[0]=(((r).minbucketcos3config[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_MINBUCKETCOS3CONFIGr_MIN_REFRESHf_GET(r) ((((r).minbucketcos3config[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_MINBUCKETCOS3CONFIGr_MIN_REFRESHf_SET(r,f) (r).minbucketcos3config[0]=(((r).minbucketcos3config[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))

/*
 * These macros can be used to access MINBUCKETCOS3CONFIG.
 *
 */
#define BCM53324_A0_READ_MINBUCKETCOS3CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MINBUCKETCOS3CONFIGr,(r._minbucketcos3config))
#define BCM53324_A0_WRITE_MINBUCKETCOS3CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MINBUCKETCOS3CONFIGr,&(r._minbucketcos3config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETCOS3CONFIGr BCM53324_A0_MINBUCKETCOS3CONFIGr
#define MINBUCKETCOS3CONFIGr_SIZE BCM53324_A0_MINBUCKETCOS3CONFIGr_SIZE
typedef BCM53324_A0_MINBUCKETCOS3CONFIGr_t MINBUCKETCOS3CONFIGr_t;
#define MINBUCKETCOS3CONFIGr_CLR BCM53324_A0_MINBUCKETCOS3CONFIGr_CLR
#define MINBUCKETCOS3CONFIGr_SET BCM53324_A0_MINBUCKETCOS3CONFIGr_SET
#define MINBUCKETCOS3CONFIGr_GET BCM53324_A0_MINBUCKETCOS3CONFIGr_GET
#define MINBUCKETCOS3CONFIGr_MIN_THD_SELf_GET BCM53324_A0_MINBUCKETCOS3CONFIGr_MIN_THD_SELf_GET
#define MINBUCKETCOS3CONFIGr_MIN_THD_SELf_SET BCM53324_A0_MINBUCKETCOS3CONFIGr_MIN_THD_SELf_SET
#define MINBUCKETCOS3CONFIGr_MIN_REFRESHf_GET BCM53324_A0_MINBUCKETCOS3CONFIGr_MIN_REFRESHf_GET
#define MINBUCKETCOS3CONFIGr_MIN_REFRESHf_SET BCM53324_A0_MINBUCKETCOS3CONFIGr_MIN_REFRESHf_SET
#define READ_MINBUCKETCOS3CONFIGr BCM53324_A0_READ_MINBUCKETCOS3CONFIGr
#define WRITE_MINBUCKETCOS3CONFIGr BCM53324_A0_WRITE_MINBUCKETCOS3CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MINBUCKETCOS3CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Mirror control register
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *     SRC_MODID_BLOCK_MIRROR_ONLY_PKT Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=1, MH.MD=0 ports
 *     SRC_MODID_BLOCK_MIRROR_COPY Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=0, MH.MD=0 ports
 *
 ******************************************************************************/
#define BCM53324_A0_MIRROR_CONTROLr 0x0f700108

#define BCM53324_A0_MIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIRROR_CONTROL.
 *
 */
typedef union BCM53324_A0_MIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t mirror_control[1];
	uint32_t _mirror_control;
} BCM53324_A0_MIRROR_CONTROLr_t;

#define BCM53324_A0_MIRROR_CONTROLr_CLR(r) (r).mirror_control[0] = 0
#define BCM53324_A0_MIRROR_CONTROLr_SET(r,d) (r).mirror_control[0] = d
#define BCM53324_A0_MIRROR_CONTROLr_GET(r) (r).mirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).mirror_control[0]) & 0x1)
#define BCM53324_A0_MIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 1) & 0x3)
#define BCM53324_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53324_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 3) & 0x3)
#define BCM53324_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53324_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 5) & 0x3)
#define BCM53324_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53324_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET(r) ((((r).mirror_control[0]) >> 7) & 0x1)
#define BCM53324_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET(r) ((((r).mirror_control[0]) >> 8) & 0x1)
#define BCM53324_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MIRROR_CONTROL.
 *
 */
#define BCM53324_A0_READ_MIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_MIRROR_CONTROLr,(r._mirror_control))
#define BCM53324_A0_WRITE_MIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_MIRROR_CONTROLr,&(r._mirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRROR_CONTROLr BCM53324_A0_MIRROR_CONTROLr
#define MIRROR_CONTROLr_SIZE BCM53324_A0_MIRROR_CONTROLr_SIZE
typedef BCM53324_A0_MIRROR_CONTROLr_t MIRROR_CONTROLr_t;
#define MIRROR_CONTROLr_CLR BCM53324_A0_MIRROR_CONTROLr_CLR
#define MIRROR_CONTROLr_SET BCM53324_A0_MIRROR_CONTROLr_SET
#define MIRROR_CONTROLr_GET BCM53324_A0_MIRROR_CONTROLr_GET
#define MIRROR_CONTROLr_M_ENABLEf_GET BCM53324_A0_MIRROR_CONTROLr_M_ENABLEf_GET
#define MIRROR_CONTROLr_M_ENABLEf_SET BCM53324_A0_MIRROR_CONTROLr_M_ENABLEf_SET
#define MIRROR_CONTROLr_IM_MTP_INDEXf_GET BCM53324_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_IM_MTP_INDEXf_SET BCM53324_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_EM_MTP_INDEXf_GET BCM53324_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_EM_MTP_INDEXf_SET BCM53324_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET BCM53324_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET BCM53324_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET BCM53324_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET BCM53324_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET BCM53324_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET BCM53324_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET
#define READ_MIRROR_CONTROLr BCM53324_A0_READ_MIRROR_CONTROLr
#define WRITE_MIRROR_CONTROLr BCM53324_A0_WRITE_MIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MISCCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls various functions in the MMU
 * SIZE:     32
 * FIELDS:
 *     DYNAMIC_MEMORY_EN Dynamic Memory Mode EnableHOL cell limit behavior (dynamic sharing of CBP):1: Dynamic Memory mode is enabled,0: Dynamic Memory mode is disabled.
 *     CLRDROPCTR       Clear All Drop Packet CountersWhen set to 1, MMU will clear all port counter of the followings:DROPPEDPKTCOUNT, CNG0DROPCOUNT, CNG1DROPCOUNT  & CELLCRCERRCOUNT.Read to this bit will always return 0.
 *     CELLCRCCHECKEN   MMU cell data CRC checking enable to detect MMU internal memory failure during operation. Failure Cell Pointer can be retrieved from CELLCRCERRPOINTER regsiter. Failure pointer count can be retrieved from CELLCRCERRCOUNT register.This crc checking function can detect bith Cell CRC error and CBP Header Parity error.1: Enable sending sbus Memfail message based Cell CRC error and CBP Header Parity error. on CRC error and infroming egree about this error. Currenttransmitting packet will be corrupted. 0: Disable sending sbus Memfail message based on CRC error and not infroming egree       about this error. Default.
 *     SKIDMARKER       SkidMarker for each HOL Packet Counter, reaserved value for for the packetsalready in the transsion to beaccepted by mmu XQ. May need to modify this for RAVEN/HAWKEYE???The values of SkidMarker are:2\'b00: 4 packets,2\'b01: 5 packets, 2\'b10: 6 packets,2\'b11: 7 packets.
 *     HOLMAXTIMER      HOL Maximum Timer for sending periodic HOL COSx and IBP discard status to IngressPipeline. The values of HOL Maximum Timer counts in the unit of micron second.If se to 0 there will be no periodic status send to Ingress Pipeline only sendon the time when status are changed.Default value is disable.
 *     SLAM_MEM         Write 1 into this register will interrupt CFAP & CCP power-on initialization.After write 1 into this register, users are able to slam cfap and ccp memorieswith desired value. When memoryslamming is done, users need to wirte 1 intoCFAPINIT bit in CFAPCONFIG register to complete CFAP & CCP initialzation.This regsiter should not be programmed while the tarffic is on. It may generateunexpected result.
 *     METERING_CLK_EN  METERING_CLK_EN will enable metering 7.8125us refresh tick to flow into egress portmetering, min/max bucket and ingress back pressure metering function.0: disable refresh tick,1: enable refresh tick.
 *     PARITY_CHECK_EN  PARITY_CHECK_EN enable MMU checking the parity of Memory read out data.0: disable memory parity check,1: enable memory parity check.
 *     HOL_CELL_SOP_DROP_EN Only do hol cell drop on sop cell to help TCP performance. This bit is also used to drop packets                               on SOP cell for BKP discard.
 *     DYN_XQ_EN        Dynamic sharing of descriptor queue (XQ) among COSn for a port
 *     CNG_DROP_EN      Set to enable CNG colored packet drop function
 *     MULTIPLE_ACCOUNTING_FIX_EN Set to enable the fix for the accounting logic of the global dynamic space, for a multicast cell
 *
 ******************************************************************************/
#define BCM53324_A0_MISCCONFIGr 0x00680012

#define BCM53324_A0_MISCCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MISCCONFIG.
 *
 */
typedef union BCM53324_A0_MISCCONFIGr_s {
	uint32_t v[1];
	uint32_t miscconfig[1];
	uint32_t _miscconfig;
} BCM53324_A0_MISCCONFIGr_t;

#define BCM53324_A0_MISCCONFIGr_CLR(r) (r).miscconfig[0] = 0
#define BCM53324_A0_MISCCONFIGr_SET(r,d) (r).miscconfig[0] = d
#define BCM53324_A0_MISCCONFIGr_GET(r) (r).miscconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET(r) (((r).miscconfig[0]) & 0x1)
#define BCM53324_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MISCCONFIGr_CLRDROPCTRf_GET(r) ((((r).miscconfig[0]) >> 1) & 0x1)
#define BCM53324_A0_MISCCONFIGr_CLRDROPCTRf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MISCCONFIGr_CELLCRCCHECKENf_GET(r) ((((r).miscconfig[0]) >> 2) & 0x1)
#define BCM53324_A0_MISCCONFIGr_CELLCRCCHECKENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MISCCONFIGr_SKIDMARKERf_GET(r) ((((r).miscconfig[0]) >> 3) & 0x3)
#define BCM53324_A0_MISCCONFIGr_SKIDMARKERf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53324_A0_MISCCONFIGr_HOLMAXTIMERf_GET(r) ((((r).miscconfig[0]) >> 5) & 0x7)
#define BCM53324_A0_MISCCONFIGr_HOLMAXTIMERf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53324_A0_MISCCONFIGr_SLAM_MEMf_GET(r) ((((r).miscconfig[0]) >> 8) & 0x1)
#define BCM53324_A0_MISCCONFIGr_SLAM_MEMf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_MISCCONFIGr_METERING_CLK_ENf_GET(r) ((((r).miscconfig[0]) >> 9) & 0x1)
#define BCM53324_A0_MISCCONFIGr_METERING_CLK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_MISCCONFIGr_PARITY_CHECK_ENf_GET(r) ((((r).miscconfig[0]) >> 10) & 0x1)
#define BCM53324_A0_MISCCONFIGr_PARITY_CHECK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_GET(r) ((((r).miscconfig[0]) >> 11) & 0x1)
#define BCM53324_A0_MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_MISCCONFIGr_DYN_XQ_ENf_GET(r) ((((r).miscconfig[0]) >> 12) & 0x1)
#define BCM53324_A0_MISCCONFIGr_DYN_XQ_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_MISCCONFIGr_CNG_DROP_ENf_GET(r) ((((r).miscconfig[0]) >> 13) & 0x1)
#define BCM53324_A0_MISCCONFIGr_CNG_DROP_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_GET(r) ((((r).miscconfig[0]) >> 14) & 0x1)
#define BCM53324_A0_MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access MISCCONFIG.
 *
 */
#define BCM53324_A0_READ_MISCCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MISCCONFIGr,(r._miscconfig))
#define BCM53324_A0_WRITE_MISCCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MISCCONFIGr,&(r._miscconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MISCCONFIGr BCM53324_A0_MISCCONFIGr
#define MISCCONFIGr_SIZE BCM53324_A0_MISCCONFIGr_SIZE
typedef BCM53324_A0_MISCCONFIGr_t MISCCONFIGr_t;
#define MISCCONFIGr_CLR BCM53324_A0_MISCCONFIGr_CLR
#define MISCCONFIGr_SET BCM53324_A0_MISCCONFIGr_SET
#define MISCCONFIGr_GET BCM53324_A0_MISCCONFIGr_GET
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET BCM53324_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_GET
#define MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET BCM53324_A0_MISCCONFIGr_DYNAMIC_MEMORY_ENf_SET
#define MISCCONFIGr_CLRDROPCTRf_GET BCM53324_A0_MISCCONFIGr_CLRDROPCTRf_GET
#define MISCCONFIGr_CLRDROPCTRf_SET BCM53324_A0_MISCCONFIGr_CLRDROPCTRf_SET
#define MISCCONFIGr_CELLCRCCHECKENf_GET BCM53324_A0_MISCCONFIGr_CELLCRCCHECKENf_GET
#define MISCCONFIGr_CELLCRCCHECKENf_SET BCM53324_A0_MISCCONFIGr_CELLCRCCHECKENf_SET
#define MISCCONFIGr_SKIDMARKERf_GET BCM53324_A0_MISCCONFIGr_SKIDMARKERf_GET
#define MISCCONFIGr_SKIDMARKERf_SET BCM53324_A0_MISCCONFIGr_SKIDMARKERf_SET
#define MISCCONFIGr_HOLMAXTIMERf_GET BCM53324_A0_MISCCONFIGr_HOLMAXTIMERf_GET
#define MISCCONFIGr_HOLMAXTIMERf_SET BCM53324_A0_MISCCONFIGr_HOLMAXTIMERf_SET
#define MISCCONFIGr_SLAM_MEMf_GET BCM53324_A0_MISCCONFIGr_SLAM_MEMf_GET
#define MISCCONFIGr_SLAM_MEMf_SET BCM53324_A0_MISCCONFIGr_SLAM_MEMf_SET
#define MISCCONFIGr_METERING_CLK_ENf_GET BCM53324_A0_MISCCONFIGr_METERING_CLK_ENf_GET
#define MISCCONFIGr_METERING_CLK_ENf_SET BCM53324_A0_MISCCONFIGr_METERING_CLK_ENf_SET
#define MISCCONFIGr_PARITY_CHECK_ENf_GET BCM53324_A0_MISCCONFIGr_PARITY_CHECK_ENf_GET
#define MISCCONFIGr_PARITY_CHECK_ENf_SET BCM53324_A0_MISCCONFIGr_PARITY_CHECK_ENf_SET
#define MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_GET BCM53324_A0_MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_GET
#define MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_SET BCM53324_A0_MISCCONFIGr_HOL_CELL_SOP_DROP_ENf_SET
#define MISCCONFIGr_DYN_XQ_ENf_GET BCM53324_A0_MISCCONFIGr_DYN_XQ_ENf_GET
#define MISCCONFIGr_DYN_XQ_ENf_SET BCM53324_A0_MISCCONFIGr_DYN_XQ_ENf_SET
#define MISCCONFIGr_CNG_DROP_ENf_GET BCM53324_A0_MISCCONFIGr_CNG_DROP_ENf_GET
#define MISCCONFIGr_CNG_DROP_ENf_SET BCM53324_A0_MISCCONFIGr_CNG_DROP_ENf_SET
#define MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_GET BCM53324_A0_MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_GET
#define MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_SET BCM53324_A0_MISCCONFIGr_MULTIPLE_ACCOUNTING_FIX_ENf_SET
#define READ_MISCCONFIGr BCM53324_A0_READ_MISCCONFIGr
#define WRITE_MISCCONFIGr BCM53324_A0_WRITE_MISCCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MISCCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MMRP_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Values for MMRP frame detection
 * SIZE:     32
 * FIELDS:
 *     MAC_DA_LOWER     MAC Address to match for MMRP frame detection
 *
 ******************************************************************************/
#define BCM53324_A0_MMRP_CONTROL_1r 0x02780018

#define BCM53324_A0_MMRP_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program MMRP_CONTROL_1.
 *
 */
typedef union BCM53324_A0_MMRP_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t mmrp_control_1[1];
	uint32_t _mmrp_control_1;
} BCM53324_A0_MMRP_CONTROL_1r_t;

#define BCM53324_A0_MMRP_CONTROL_1r_CLR(r) (r).mmrp_control_1[0] = 0
#define BCM53324_A0_MMRP_CONTROL_1r_SET(r,d) (r).mmrp_control_1[0] = d
#define BCM53324_A0_MMRP_CONTROL_1r_GET(r) (r).mmrp_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMRP_CONTROL_1r_MAC_DA_LOWERf_GET(r) ((r).mmrp_control_1[0])
#define BCM53324_A0_MMRP_CONTROL_1r_MAC_DA_LOWERf_SET(r,f) (r).mmrp_control_1[0]=((uint32_t)f)

/*
 * These macros can be used to access MMRP_CONTROL_1.
 *
 */
#define BCM53324_A0_READ_MMRP_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MMRP_CONTROL_1r,(r._mmrp_control_1))
#define BCM53324_A0_WRITE_MMRP_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MMRP_CONTROL_1r,&(r._mmrp_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMRP_CONTROL_1r BCM53324_A0_MMRP_CONTROL_1r
#define MMRP_CONTROL_1r_SIZE BCM53324_A0_MMRP_CONTROL_1r_SIZE
typedef BCM53324_A0_MMRP_CONTROL_1r_t MMRP_CONTROL_1r_t;
#define MMRP_CONTROL_1r_CLR BCM53324_A0_MMRP_CONTROL_1r_CLR
#define MMRP_CONTROL_1r_SET BCM53324_A0_MMRP_CONTROL_1r_SET
#define MMRP_CONTROL_1r_GET BCM53324_A0_MMRP_CONTROL_1r_GET
#define MMRP_CONTROL_1r_MAC_DA_LOWERf_GET BCM53324_A0_MMRP_CONTROL_1r_MAC_DA_LOWERf_GET
#define MMRP_CONTROL_1r_MAC_DA_LOWERf_SET BCM53324_A0_MMRP_CONTROL_1r_MAC_DA_LOWERf_SET
#define READ_MMRP_CONTROL_1r BCM53324_A0_READ_MMRP_CONTROL_1r
#define WRITE_MMRP_CONTROL_1r BCM53324_A0_WRITE_MMRP_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMRP_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MMRP_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Values for MMRP frame detection
 * SIZE:     32
 * FIELDS:
 *     ETHERTYPE        The bits correspond to the message values in the lower nibble of the TS message
 *     MAC_DA_UPPER     MAC Address to match for MMRP frame detection, Upper 16 bits.
 *
 ******************************************************************************/
#define BCM53324_A0_MMRP_CONTROL_2r 0x02780019

#define BCM53324_A0_MMRP_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program MMRP_CONTROL_2.
 *
 */
typedef union BCM53324_A0_MMRP_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t mmrp_control_2[1];
	uint32_t _mmrp_control_2;
} BCM53324_A0_MMRP_CONTROL_2r_t;

#define BCM53324_A0_MMRP_CONTROL_2r_CLR(r) (r).mmrp_control_2[0] = 0
#define BCM53324_A0_MMRP_CONTROL_2r_SET(r,d) (r).mmrp_control_2[0] = d
#define BCM53324_A0_MMRP_CONTROL_2r_GET(r) (r).mmrp_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMRP_CONTROL_2r_ETHERTYPEf_GET(r) (((r).mmrp_control_2[0]) & 0xffff)
#define BCM53324_A0_MMRP_CONTROL_2r_ETHERTYPEf_SET(r,f) (r).mmrp_control_2[0]=(((r).mmrp_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_MMRP_CONTROL_2r_MAC_DA_UPPERf_GET(r) ((((r).mmrp_control_2[0]) >> 16) & 0xffff)
#define BCM53324_A0_MMRP_CONTROL_2r_MAC_DA_UPPERf_SET(r,f) (r).mmrp_control_2[0]=(((r).mmrp_control_2[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MMRP_CONTROL_2.
 *
 */
#define BCM53324_A0_READ_MMRP_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MMRP_CONTROL_2r,(r._mmrp_control_2))
#define BCM53324_A0_WRITE_MMRP_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MMRP_CONTROL_2r,&(r._mmrp_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMRP_CONTROL_2r BCM53324_A0_MMRP_CONTROL_2r
#define MMRP_CONTROL_2r_SIZE BCM53324_A0_MMRP_CONTROL_2r_SIZE
typedef BCM53324_A0_MMRP_CONTROL_2r_t MMRP_CONTROL_2r_t;
#define MMRP_CONTROL_2r_CLR BCM53324_A0_MMRP_CONTROL_2r_CLR
#define MMRP_CONTROL_2r_SET BCM53324_A0_MMRP_CONTROL_2r_SET
#define MMRP_CONTROL_2r_GET BCM53324_A0_MMRP_CONTROL_2r_GET
#define MMRP_CONTROL_2r_ETHERTYPEf_GET BCM53324_A0_MMRP_CONTROL_2r_ETHERTYPEf_GET
#define MMRP_CONTROL_2r_ETHERTYPEf_SET BCM53324_A0_MMRP_CONTROL_2r_ETHERTYPEf_SET
#define MMRP_CONTROL_2r_MAC_DA_UPPERf_GET BCM53324_A0_MMRP_CONTROL_2r_MAC_DA_UPPERf_GET
#define MMRP_CONTROL_2r_MAC_DA_UPPERf_SET BCM53324_A0_MMRP_CONTROL_2r_MAC_DA_UPPERf_SET
#define READ_MMRP_CONTROL_2r BCM53324_A0_READ_MMRP_CONTROL_2r
#define WRITE_MMRP_CONTROL_2r BCM53324_A0_WRITE_MMRP_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMRP_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MMUEAVENABLE
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ENABLE           Each control bit when asserted, puts the corresponding port in the EAV mode. 
 *
 ******************************************************************************/
#define BCM53324_A0_MMUEAVENABLEr 0x0068004b

#define BCM53324_A0_MMUEAVENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUEAVENABLE.
 *
 */
typedef union BCM53324_A0_MMUEAVENABLEr_s {
	uint32_t v[1];
	uint32_t mmueavenable[1];
	uint32_t _mmueavenable;
} BCM53324_A0_MMUEAVENABLEr_t;

#define BCM53324_A0_MMUEAVENABLEr_CLR(r) (r).mmueavenable[0] = 0
#define BCM53324_A0_MMUEAVENABLEr_SET(r,d) (r).mmueavenable[0] = d
#define BCM53324_A0_MMUEAVENABLEr_GET(r) (r).mmueavenable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMUEAVENABLEr_ENABLEf_GET(r) (((r).mmueavenable[0]) & 0x1ffffff)
#define BCM53324_A0_MMUEAVENABLEr_ENABLEf_SET(r,f) (r).mmueavenable[0]=(((r).mmueavenable[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access MMUEAVENABLE.
 *
 */
#define BCM53324_A0_READ_MMUEAVENABLEr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MMUEAVENABLEr,(r._mmueavenable))
#define BCM53324_A0_WRITE_MMUEAVENABLEr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MMUEAVENABLEr,&(r._mmueavenable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUEAVENABLEr BCM53324_A0_MMUEAVENABLEr
#define MMUEAVENABLEr_SIZE BCM53324_A0_MMUEAVENABLEr_SIZE
typedef BCM53324_A0_MMUEAVENABLEr_t MMUEAVENABLEr_t;
#define MMUEAVENABLEr_CLR BCM53324_A0_MMUEAVENABLEr_CLR
#define MMUEAVENABLEr_SET BCM53324_A0_MMUEAVENABLEr_SET
#define MMUEAVENABLEr_GET BCM53324_A0_MMUEAVENABLEr_GET
#define MMUEAVENABLEr_ENABLEf_GET BCM53324_A0_MMUEAVENABLEr_ENABLEf_GET
#define MMUEAVENABLEr_ENABLEf_SET BCM53324_A0_MMUEAVENABLEr_ENABLEf_SET
#define READ_MMUEAVENABLEr BCM53324_A0_READ_MMUEAVENABLEr
#define WRITE_MMUEAVENABLEr BCM53324_A0_WRITE_MMUEAVENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMUEAVENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MMUFLUSHCONTROL
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Each control bit when asserted, puts the corresponding port in the flush state. When a particular port is in flush state, the packets from the XQ of the port are purged after dequeue. It is expected that once a port is in flush state, there will be no more packets queued so that the queues become empty for that port. Once the port is emplty, flush contrl bit can be deasserted. 
 *
 ******************************************************************************/
#define BCM53324_A0_MMUFLUSHCONTROLr 0x0068004a

#define BCM53324_A0_MMUFLUSHCONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MMUFLUSHCONTROL.
 *
 */
typedef union BCM53324_A0_MMUFLUSHCONTROLr_s {
	uint32_t v[1];
	uint32_t mmuflushcontrol[1];
	uint32_t _mmuflushcontrol;
} BCM53324_A0_MMUFLUSHCONTROLr_t;

#define BCM53324_A0_MMUFLUSHCONTROLr_CLR(r) (r).mmuflushcontrol[0] = 0
#define BCM53324_A0_MMUFLUSHCONTROLr_SET(r,d) (r).mmuflushcontrol[0] = d
#define BCM53324_A0_MMUFLUSHCONTROLr_GET(r) (r).mmuflushcontrol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMUFLUSHCONTROLr_FLUSHf_GET(r) (((r).mmuflushcontrol[0]) & 0x1ffffff)
#define BCM53324_A0_MMUFLUSHCONTROLr_FLUSHf_SET(r,f) (r).mmuflushcontrol[0]=(((r).mmuflushcontrol[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access MMUFLUSHCONTROL.
 *
 */
#define BCM53324_A0_READ_MMUFLUSHCONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MMUFLUSHCONTROLr,(r._mmuflushcontrol))
#define BCM53324_A0_WRITE_MMUFLUSHCONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MMUFLUSHCONTROLr,&(r._mmuflushcontrol))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUFLUSHCONTROLr BCM53324_A0_MMUFLUSHCONTROLr
#define MMUFLUSHCONTROLr_SIZE BCM53324_A0_MMUFLUSHCONTROLr_SIZE
typedef BCM53324_A0_MMUFLUSHCONTROLr_t MMUFLUSHCONTROLr_t;
#define MMUFLUSHCONTROLr_CLR BCM53324_A0_MMUFLUSHCONTROLr_CLR
#define MMUFLUSHCONTROLr_SET BCM53324_A0_MMUFLUSHCONTROLr_SET
#define MMUFLUSHCONTROLr_GET BCM53324_A0_MMUFLUSHCONTROLr_GET
#define MMUFLUSHCONTROLr_FLUSHf_GET BCM53324_A0_MMUFLUSHCONTROLr_FLUSHf_GET
#define MMUFLUSHCONTROLr_FLUSHf_SET BCM53324_A0_MMUFLUSHCONTROLr_FLUSHf_SET
#define READ_MMUFLUSHCONTROLr BCM53324_A0_READ_MMUFLUSHCONTROLr
#define WRITE_MMUFLUSHCONTROLr BCM53324_A0_WRITE_MMUFLUSHCONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMUFLUSHCONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MMUPORTENABLE
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MMUPORTENABLE    MMU port enable is to control which mmu egress port can accept packet
 *
 ******************************************************************************/
#define BCM53324_A0_MMUPORTENABLEr 0x00680016

#define BCM53324_A0_MMUPORTENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTENABLE.
 *
 */
typedef union BCM53324_A0_MMUPORTENABLEr_s {
	uint32_t v[1];
	uint32_t mmuportenable[1];
	uint32_t _mmuportenable;
} BCM53324_A0_MMUPORTENABLEr_t;

#define BCM53324_A0_MMUPORTENABLEr_CLR(r) (r).mmuportenable[0] = 0
#define BCM53324_A0_MMUPORTENABLEr_SET(r,d) (r).mmuportenable[0] = d
#define BCM53324_A0_MMUPORTENABLEr_GET(r) (r).mmuportenable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMUPORTENABLEr_MMUPORTENABLEf_GET(r) (((r).mmuportenable[0]) & 0x1ffffff)
#define BCM53324_A0_MMUPORTENABLEr_MMUPORTENABLEf_SET(r,f) (r).mmuportenable[0]=(((r).mmuportenable[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access MMUPORTENABLE.
 *
 */
#define BCM53324_A0_READ_MMUPORTENABLEr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MMUPORTENABLEr,(r._mmuportenable))
#define BCM53324_A0_WRITE_MMUPORTENABLEr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MMUPORTENABLEr,&(r._mmuportenable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUPORTENABLEr BCM53324_A0_MMUPORTENABLEr
#define MMUPORTENABLEr_SIZE BCM53324_A0_MMUPORTENABLEr_SIZE
typedef BCM53324_A0_MMUPORTENABLEr_t MMUPORTENABLEr_t;
#define MMUPORTENABLEr_CLR BCM53324_A0_MMUPORTENABLEr_CLR
#define MMUPORTENABLEr_SET BCM53324_A0_MMUPORTENABLEr_SET
#define MMUPORTENABLEr_GET BCM53324_A0_MMUPORTENABLEr_GET
#define MMUPORTENABLEr_MMUPORTENABLEf_GET BCM53324_A0_MMUPORTENABLEr_MMUPORTENABLEf_GET
#define MMUPORTENABLEr_MMUPORTENABLEf_SET BCM53324_A0_MMUPORTENABLEr_MMUPORTENABLEf_SET
#define READ_MMUPORTENABLEr BCM53324_A0_READ_MMUPORTENABLEr
#define WRITE_MMUPORTENABLEr BCM53324_A0_WRITE_MMUPORTENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMUPORTENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  MMUPORTTXENABLE
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MMUPORTTXENABLE  MMU port tx enable is to control which mmu egress port (between 31-0) can start transmit packet
 *
 ******************************************************************************/
#define BCM53324_A0_MMUPORTTXENABLEr 0x0068003f

#define BCM53324_A0_MMUPORTTXENABLEr_SIZE 4

/*
 * This structure should be used to declare and program MMUPORTTXENABLE.
 *
 */
typedef union BCM53324_A0_MMUPORTTXENABLEr_s {
	uint32_t v[1];
	uint32_t mmuporttxenable[1];
	uint32_t _mmuporttxenable;
} BCM53324_A0_MMUPORTTXENABLEr_t;

#define BCM53324_A0_MMUPORTTXENABLEr_CLR(r) (r).mmuporttxenable[0] = 0
#define BCM53324_A0_MMUPORTTXENABLEr_SET(r,d) (r).mmuporttxenable[0] = d
#define BCM53324_A0_MMUPORTTXENABLEr_GET(r) (r).mmuporttxenable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMUPORTTXENABLEr_MMUPORTTXENABLEf_GET(r) (((r).mmuporttxenable[0]) & 0x1ffffff)
#define BCM53324_A0_MMUPORTTXENABLEr_MMUPORTTXENABLEf_SET(r,f) (r).mmuporttxenable[0]=(((r).mmuporttxenable[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access MMUPORTTXENABLE.
 *
 */
#define BCM53324_A0_READ_MMUPORTTXENABLEr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_MMUPORTTXENABLEr,(r._mmuporttxenable))
#define BCM53324_A0_WRITE_MMUPORTTXENABLEr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_MMUPORTTXENABLEr,&(r._mmuporttxenable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMUPORTTXENABLEr BCM53324_A0_MMUPORTTXENABLEr
#define MMUPORTTXENABLEr_SIZE BCM53324_A0_MMUPORTTXENABLEr_SIZE
typedef BCM53324_A0_MMUPORTTXENABLEr_t MMUPORTTXENABLEr_t;
#define MMUPORTTXENABLEr_CLR BCM53324_A0_MMUPORTTXENABLEr_CLR
#define MMUPORTTXENABLEr_SET BCM53324_A0_MMUPORTTXENABLEr_SET
#define MMUPORTTXENABLEr_GET BCM53324_A0_MMUPORTTXENABLEr_GET
#define MMUPORTTXENABLEr_MMUPORTTXENABLEf_GET BCM53324_A0_MMUPORTTXENABLEr_MMUPORTTXENABLEf_GET
#define MMUPORTTXENABLEr_MMUPORTTXENABLEf_SET BCM53324_A0_MMUPORTTXENABLEr_MMUPORTTXENABLEf_SET
#define READ_MMUPORTTXENABLEr BCM53324_A0_READ_MMUPORTTXENABLEr
#define WRITE_MMUPORTTXENABLEr BCM53324_A0_WRITE_MMUPORTTXENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMUPORTTXENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_AGING_CTR
 * BLOCKS:   MMU
 * DESC:     Aging Counter RAM
 * SIZE:     24
 * FIELDS:
 *     AGING_CTR        AGING_CTR
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_AGING_CTRm 0x0a658000

#define BCM53324_A0_MMU_AGING_CTRm_MIN 0
#define BCM53324_A0_MMU_AGING_CTRm_MAX 511
#define BCM53324_A0_MMU_AGING_CTRm_CMAX(u) 511
#define BCM53324_A0_MMU_AGING_CTRm_SIZE 3

/*
 * This structure should be used to declare and program MMU_AGING_CTR.
 *
 */
typedef union BCM53324_A0_MMU_AGING_CTRm_s {
	uint32_t v[1];
	uint32_t mmu_aging_ctr[1];
	uint32_t _mmu_aging_ctr;
} BCM53324_A0_MMU_AGING_CTRm_t;

#define BCM53324_A0_MMU_AGING_CTRm_CLR(r) (r).mmu_aging_ctr[0] = 0
#define BCM53324_A0_MMU_AGING_CTRm_SET(r,d) (r).mmu_aging_ctr[0] = d
#define BCM53324_A0_MMU_AGING_CTRm_GET(r) (r).mmu_aging_ctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_AGING_CTRm_AGING_CTRf_GET(r) (((r).mmu_aging_ctr[0]) & 0xffffff)
#define BCM53324_A0_MMU_AGING_CTRm_AGING_CTRf_SET(r,f) (r).mmu_aging_ctr[0]=(((r).mmu_aging_ctr[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access MMU_AGING_CTR.
 *
 */
#define BCM53324_A0_READ_MMU_AGING_CTRm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_AGING_CTRm,i,(m._mmu_aging_ctr),1)
#define BCM53324_A0_WRITE_MMU_AGING_CTRm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_AGING_CTRm,i,&(m._mmu_aging_ctr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_AGING_CTRm BCM53324_A0_MMU_AGING_CTRm
#define MMU_AGING_CTRm_MIN BCM53324_A0_MMU_AGING_CTRm_MIN
#define MMU_AGING_CTRm_MAX BCM53324_A0_MMU_AGING_CTRm_MAX
#define MMU_AGING_CTRm_CMAX(u) BCM53324_A0_MMU_AGING_CTRm_CMAX(u)
#define MMU_AGING_CTRm_SIZE BCM53324_A0_MMU_AGING_CTRm_SIZE
typedef BCM53324_A0_MMU_AGING_CTRm_t MMU_AGING_CTRm_t;
#define MMU_AGING_CTRm_CLR BCM53324_A0_MMU_AGING_CTRm_CLR
#define MMU_AGING_CTRm_SET BCM53324_A0_MMU_AGING_CTRm_SET
#define MMU_AGING_CTRm_GET BCM53324_A0_MMU_AGING_CTRm_GET
#define MMU_AGING_CTRm_AGING_CTRf_GET BCM53324_A0_MMU_AGING_CTRm_AGING_CTRf_GET
#define MMU_AGING_CTRm_AGING_CTRf_SET BCM53324_A0_MMU_AGING_CTRm_AGING_CTRf_SET
#define READ_MMU_AGING_CTRm BCM53324_A0_READ_MMU_AGING_CTRm
#define WRITE_MMU_AGING_CTRm BCM53324_A0_WRITE_MMU_AGING_CTRm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_AGING_CTRm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_AGING_EXP
 * BLOCKS:   MMU
 * DESC:     Aging Expiration Status RAM
 * SIZE:     8
 * FIELDS:
 *     AGING_EXP        AGING_EXP
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_AGING_EXPm 0x0a65c000

#define BCM53324_A0_MMU_AGING_EXPm_MIN 0
#define BCM53324_A0_MMU_AGING_EXPm_MAX 511
#define BCM53324_A0_MMU_AGING_EXPm_CMAX(u) 511
#define BCM53324_A0_MMU_AGING_EXPm_SIZE 1

/*
 * This structure should be used to declare and program MMU_AGING_EXP.
 *
 */
typedef union BCM53324_A0_MMU_AGING_EXPm_s {
	uint32_t v[1];
	uint32_t mmu_aging_exp[1];
	uint32_t _mmu_aging_exp;
} BCM53324_A0_MMU_AGING_EXPm_t;

#define BCM53324_A0_MMU_AGING_EXPm_CLR(r) (r).mmu_aging_exp[0] = 0
#define BCM53324_A0_MMU_AGING_EXPm_SET(r,d) (r).mmu_aging_exp[0] = d
#define BCM53324_A0_MMU_AGING_EXPm_GET(r) (r).mmu_aging_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_AGING_EXPm_AGING_EXPf_GET(r) (((r).mmu_aging_exp[0]) & 0xff)
#define BCM53324_A0_MMU_AGING_EXPm_AGING_EXPf_SET(r,f) (r).mmu_aging_exp[0]=(((r).mmu_aging_exp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MMU_AGING_EXP.
 *
 */
#define BCM53324_A0_READ_MMU_AGING_EXPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_AGING_EXPm,i,(m._mmu_aging_exp),1)
#define BCM53324_A0_WRITE_MMU_AGING_EXPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_AGING_EXPm,i,&(m._mmu_aging_exp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_AGING_EXPm BCM53324_A0_MMU_AGING_EXPm
#define MMU_AGING_EXPm_MIN BCM53324_A0_MMU_AGING_EXPm_MIN
#define MMU_AGING_EXPm_MAX BCM53324_A0_MMU_AGING_EXPm_MAX
#define MMU_AGING_EXPm_CMAX(u) BCM53324_A0_MMU_AGING_EXPm_CMAX(u)
#define MMU_AGING_EXPm_SIZE BCM53324_A0_MMU_AGING_EXPm_SIZE
typedef BCM53324_A0_MMU_AGING_EXPm_t MMU_AGING_EXPm_t;
#define MMU_AGING_EXPm_CLR BCM53324_A0_MMU_AGING_EXPm_CLR
#define MMU_AGING_EXPm_SET BCM53324_A0_MMU_AGING_EXPm_SET
#define MMU_AGING_EXPm_GET BCM53324_A0_MMU_AGING_EXPm_GET
#define MMU_AGING_EXPm_AGING_EXPf_GET BCM53324_A0_MMU_AGING_EXPm_AGING_EXPf_GET
#define MMU_AGING_EXPm_AGING_EXPf_SET BCM53324_A0_MMU_AGING_EXPm_AGING_EXPf_SET
#define READ_MMU_AGING_EXPm BCM53324_A0_READ_MMU_AGING_EXPm
#define WRITE_MMU_AGING_EXPm BCM53324_A0_WRITE_MMU_AGING_EXPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_AGING_EXPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPCellHeader
 * BLOCKS:   MMU
 * DESC:     CBP Header RAM
 * SIZE:     35
 * FIELDS:
 *     PURGE_CELL       How Many copies of this cell are there
 *     END_CELL         End cell flag of a packet
 *     NEXT_CELL_PTR    Next Cell Pointer is valid when END_CELL is 0
 *     CELL_LENGTH      Last Cell Length is valid when END_CELL is 1
 *     CELL_CRC_SUM     Cell CRC Checksum value
 *     CNG              CNG bit
 *     PBI_RESERVED_BIT_2 RESERVED_BIT_2
 *     MC_FLAG          Flags the current cell, as a cell occupying shared buffer space
 *     PARITY           Cell header Parity
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPCELLHEADERm 0x0a648000

#define BCM53324_A0_MMU_CBPCELLHEADERm_MIN 0
#define BCM53324_A0_MMU_CBPCELLHEADERm_MAX 4095
#define BCM53324_A0_MMU_CBPCELLHEADERm_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPCELLHEADERm_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPCellHeader.
 *
 */
typedef union BCM53324_A0_MMU_CBPCELLHEADERm_s {
	uint32_t v[2];
	uint32_t mmu_cbpcellheader[2];
	uint32_t _mmu_cbpcellheader;
} BCM53324_A0_MMU_CBPCELLHEADERm_t;

#define BCM53324_A0_MMU_CBPCELLHEADERm_CLR(r) CDK_MEMSET(&((r)._mmu_cbpcellheader), 0, sizeof(BCM53324_A0_MMU_CBPCELLHEADERm_t))
#define BCM53324_A0_MMU_CBPCELLHEADERm_SET(r,i,d) (r).mmu_cbpcellheader[i] = d
#define BCM53324_A0_MMU_CBPCELLHEADERm_GET(r,i) (r).mmu_cbpcellheader[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_GET(r) (((r).mmu_cbpcellheader[0]) & 0x1)
#define BCM53324_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_CBPCELLHEADERm_END_CELLf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_CBPCELLHEADERm_END_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 2) & 0xfff)
#define BCM53324_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM53324_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 2) & 0xff)
#define BCM53324_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2))
#define BCM53324_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 14) & 0xffff)
#define BCM53324_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xffff << 14)) | ((((uint32_t)f) & 0xffff) << 14))
#define BCM53324_A0_MMU_CBPCELLHEADERm_CNGf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 30) & 0x3)
#define BCM53324_A0_MMU_CBPCELLHEADERm_CNGf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53324_A0_MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_GET(r) (((r).mmu_cbpcellheader[1]) & 0x1)
#define BCM53324_A0_MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_CBPCELLHEADERm_MC_FLAGf_GET(r) ((((r).mmu_cbpcellheader[1]) >> 1) & 0x1)
#define BCM53324_A0_MMU_CBPCELLHEADERm_MC_FLAGf_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_CBPCELLHEADERm_PARITYf_GET(r) ((((r).mmu_cbpcellheader[1]) >> 2) & 0x1)
#define BCM53324_A0_MMU_CBPCELLHEADERm_PARITYf_SET(r,f) (r).mmu_cbpcellheader[1]=(((r).mmu_cbpcellheader[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access MMU_CBPCellHeader.
 *
 */
#define BCM53324_A0_READ_MMU_CBPCELLHEADERm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPCELLHEADERm,i,(m._mmu_cbpcellheader),2)
#define BCM53324_A0_WRITE_MMU_CBPCELLHEADERm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPCELLHEADERm,i,&(m._mmu_cbpcellheader),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPCELLHEADERm BCM53324_A0_MMU_CBPCELLHEADERm
#define MMU_CBPCELLHEADERm_MIN BCM53324_A0_MMU_CBPCELLHEADERm_MIN
#define MMU_CBPCELLHEADERm_MAX BCM53324_A0_MMU_CBPCELLHEADERm_MAX
#define MMU_CBPCELLHEADERm_CMAX(u) BCM53324_A0_MMU_CBPCELLHEADERm_CMAX(u)
#define MMU_CBPCELLHEADERm_SIZE BCM53324_A0_MMU_CBPCELLHEADERm_SIZE
typedef BCM53324_A0_MMU_CBPCELLHEADERm_t MMU_CBPCELLHEADERm_t;
#define MMU_CBPCELLHEADERm_CLR BCM53324_A0_MMU_CBPCELLHEADERm_CLR
#define MMU_CBPCELLHEADERm_SET BCM53324_A0_MMU_CBPCELLHEADERm_SET
#define MMU_CBPCELLHEADERm_GET BCM53324_A0_MMU_CBPCELLHEADERm_GET
#define MMU_CBPCELLHEADERm_PURGE_CELLf_GET BCM53324_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_GET
#define MMU_CBPCELLHEADERm_PURGE_CELLf_SET BCM53324_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_SET
#define MMU_CBPCELLHEADERm_END_CELLf_GET BCM53324_A0_MMU_CBPCELLHEADERm_END_CELLf_GET
#define MMU_CBPCELLHEADERm_END_CELLf_SET BCM53324_A0_MMU_CBPCELLHEADERm_END_CELLf_SET
#define MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET BCM53324_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_GET
#define MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET BCM53324_A0_MMU_CBPCELLHEADERm_NEXT_CELL_PTRf_SET
#define MMU_CBPCELLHEADERm_CELL_LENGTHf_GET BCM53324_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_GET
#define MMU_CBPCELLHEADERm_CELL_LENGTHf_SET BCM53324_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_SET
#define MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET BCM53324_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_GET
#define MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET BCM53324_A0_MMU_CBPCELLHEADERm_CELL_CRC_SUMf_SET
#define MMU_CBPCELLHEADERm_CNGf_GET BCM53324_A0_MMU_CBPCELLHEADERm_CNGf_GET
#define MMU_CBPCELLHEADERm_CNGf_SET BCM53324_A0_MMU_CBPCELLHEADERm_CNGf_SET
#define MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_GET BCM53324_A0_MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_GET
#define MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_SET BCM53324_A0_MMU_CBPCELLHEADERm_PBI_RESERVED_BIT_2f_SET
#define MMU_CBPCELLHEADERm_MC_FLAGf_GET BCM53324_A0_MMU_CBPCELLHEADERm_MC_FLAGf_GET
#define MMU_CBPCELLHEADERm_MC_FLAGf_SET BCM53324_A0_MMU_CBPCELLHEADERm_MC_FLAGf_SET
#define MMU_CBPCELLHEADERm_PARITYf_GET BCM53324_A0_MMU_CBPCELLHEADERm_PARITYf_GET
#define MMU_CBPCELLHEADERm_PARITYf_SET BCM53324_A0_MMU_CBPCELLHEADERm_PARITYf_SET
#define READ_MMU_CBPCELLHEADERm BCM53324_A0_READ_MMU_CBPCELLHEADERm
#define WRITE_MMU_CBPCELLHEADERm BCM53324_A0_WRITE_MMU_CBPCELLHEADERm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPCELLHEADERm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPData0
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 0
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [127:0]
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPDATA0m 0x0a600000

#define BCM53324_A0_MMU_CBPDATA0m_MIN 0
#define BCM53324_A0_MMU_CBPDATA0m_MAX 4095
#define BCM53324_A0_MMU_CBPDATA0m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPDATA0m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData0.
 *
 */
typedef union BCM53324_A0_MMU_CBPDATA0m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata0[4];
	uint32_t _mmu_cbpdata0;
} BCM53324_A0_MMU_CBPDATA0m_t;

#define BCM53324_A0_MMU_CBPDATA0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata0), 0, sizeof(BCM53324_A0_MMU_CBPDATA0m_t))
#define BCM53324_A0_MMU_CBPDATA0m_SET(r,i,d) (r).mmu_cbpdata0[i] = d
#define BCM53324_A0_MMU_CBPDATA0m_GET(r,i) (r).mmu_cbpdata0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPDATA0m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata0,0,127,a)
#define BCM53324_A0_MMU_CBPDATA0m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata0,0,127,a)

/*
 * These macros can be used to access MMU_CBPData0.
 *
 */
#define BCM53324_A0_READ_MMU_CBPDATA0m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPDATA0m,i,(m._mmu_cbpdata0),4)
#define BCM53324_A0_WRITE_MMU_CBPDATA0m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPDATA0m,i,&(m._mmu_cbpdata0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA0m BCM53324_A0_MMU_CBPDATA0m
#define MMU_CBPDATA0m_MIN BCM53324_A0_MMU_CBPDATA0m_MIN
#define MMU_CBPDATA0m_MAX BCM53324_A0_MMU_CBPDATA0m_MAX
#define MMU_CBPDATA0m_CMAX(u) BCM53324_A0_MMU_CBPDATA0m_CMAX(u)
#define MMU_CBPDATA0m_SIZE BCM53324_A0_MMU_CBPDATA0m_SIZE
typedef BCM53324_A0_MMU_CBPDATA0m_t MMU_CBPDATA0m_t;
#define MMU_CBPDATA0m_CLR BCM53324_A0_MMU_CBPDATA0m_CLR
#define MMU_CBPDATA0m_SET BCM53324_A0_MMU_CBPDATA0m_SET
#define MMU_CBPDATA0m_GET BCM53324_A0_MMU_CBPDATA0m_GET
#define MMU_CBPDATA0m_CBPDATAf_GET BCM53324_A0_MMU_CBPDATA0m_CBPDATAf_GET
#define MMU_CBPDATA0m_CBPDATAf_SET BCM53324_A0_MMU_CBPDATA0m_CBPDATAf_SET
#define READ_MMU_CBPDATA0m BCM53324_A0_READ_MMU_CBPDATA0m
#define WRITE_MMU_CBPDATA0m BCM53324_A0_WRITE_MMU_CBPDATA0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPDATA0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPData1
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 1
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [255:128]
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPDATA1m 0x0a604000

#define BCM53324_A0_MMU_CBPDATA1m_MIN 0
#define BCM53324_A0_MMU_CBPDATA1m_MAX 4095
#define BCM53324_A0_MMU_CBPDATA1m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPDATA1m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData1.
 *
 */
typedef union BCM53324_A0_MMU_CBPDATA1m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata1[4];
	uint32_t _mmu_cbpdata1;
} BCM53324_A0_MMU_CBPDATA1m_t;

#define BCM53324_A0_MMU_CBPDATA1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata1), 0, sizeof(BCM53324_A0_MMU_CBPDATA1m_t))
#define BCM53324_A0_MMU_CBPDATA1m_SET(r,i,d) (r).mmu_cbpdata1[i] = d
#define BCM53324_A0_MMU_CBPDATA1m_GET(r,i) (r).mmu_cbpdata1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPDATA1m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata1,0,127,a)
#define BCM53324_A0_MMU_CBPDATA1m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata1,0,127,a)

/*
 * These macros can be used to access MMU_CBPData1.
 *
 */
#define BCM53324_A0_READ_MMU_CBPDATA1m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPDATA1m,i,(m._mmu_cbpdata1),4)
#define BCM53324_A0_WRITE_MMU_CBPDATA1m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPDATA1m,i,&(m._mmu_cbpdata1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA1m BCM53324_A0_MMU_CBPDATA1m
#define MMU_CBPDATA1m_MIN BCM53324_A0_MMU_CBPDATA1m_MIN
#define MMU_CBPDATA1m_MAX BCM53324_A0_MMU_CBPDATA1m_MAX
#define MMU_CBPDATA1m_CMAX(u) BCM53324_A0_MMU_CBPDATA1m_CMAX(u)
#define MMU_CBPDATA1m_SIZE BCM53324_A0_MMU_CBPDATA1m_SIZE
typedef BCM53324_A0_MMU_CBPDATA1m_t MMU_CBPDATA1m_t;
#define MMU_CBPDATA1m_CLR BCM53324_A0_MMU_CBPDATA1m_CLR
#define MMU_CBPDATA1m_SET BCM53324_A0_MMU_CBPDATA1m_SET
#define MMU_CBPDATA1m_GET BCM53324_A0_MMU_CBPDATA1m_GET
#define MMU_CBPDATA1m_CBPDATAf_GET BCM53324_A0_MMU_CBPDATA1m_CBPDATAf_GET
#define MMU_CBPDATA1m_CBPDATAf_SET BCM53324_A0_MMU_CBPDATA1m_CBPDATAf_SET
#define READ_MMU_CBPDATA1m BCM53324_A0_READ_MMU_CBPDATA1m
#define WRITE_MMU_CBPDATA1m BCM53324_A0_WRITE_MMU_CBPDATA1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPDATA1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPData2
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 2
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [383:256]
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPDATA2m 0x0a608000

#define BCM53324_A0_MMU_CBPDATA2m_MIN 0
#define BCM53324_A0_MMU_CBPDATA2m_MAX 4095
#define BCM53324_A0_MMU_CBPDATA2m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPDATA2m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData2.
 *
 */
typedef union BCM53324_A0_MMU_CBPDATA2m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata2[4];
	uint32_t _mmu_cbpdata2;
} BCM53324_A0_MMU_CBPDATA2m_t;

#define BCM53324_A0_MMU_CBPDATA2m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata2), 0, sizeof(BCM53324_A0_MMU_CBPDATA2m_t))
#define BCM53324_A0_MMU_CBPDATA2m_SET(r,i,d) (r).mmu_cbpdata2[i] = d
#define BCM53324_A0_MMU_CBPDATA2m_GET(r,i) (r).mmu_cbpdata2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPDATA2m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata2,0,127,a)
#define BCM53324_A0_MMU_CBPDATA2m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata2,0,127,a)

/*
 * These macros can be used to access MMU_CBPData2.
 *
 */
#define BCM53324_A0_READ_MMU_CBPDATA2m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPDATA2m,i,(m._mmu_cbpdata2),4)
#define BCM53324_A0_WRITE_MMU_CBPDATA2m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPDATA2m,i,&(m._mmu_cbpdata2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA2m BCM53324_A0_MMU_CBPDATA2m
#define MMU_CBPDATA2m_MIN BCM53324_A0_MMU_CBPDATA2m_MIN
#define MMU_CBPDATA2m_MAX BCM53324_A0_MMU_CBPDATA2m_MAX
#define MMU_CBPDATA2m_CMAX(u) BCM53324_A0_MMU_CBPDATA2m_CMAX(u)
#define MMU_CBPDATA2m_SIZE BCM53324_A0_MMU_CBPDATA2m_SIZE
typedef BCM53324_A0_MMU_CBPDATA2m_t MMU_CBPDATA2m_t;
#define MMU_CBPDATA2m_CLR BCM53324_A0_MMU_CBPDATA2m_CLR
#define MMU_CBPDATA2m_SET BCM53324_A0_MMU_CBPDATA2m_SET
#define MMU_CBPDATA2m_GET BCM53324_A0_MMU_CBPDATA2m_GET
#define MMU_CBPDATA2m_CBPDATAf_GET BCM53324_A0_MMU_CBPDATA2m_CBPDATAf_GET
#define MMU_CBPDATA2m_CBPDATAf_SET BCM53324_A0_MMU_CBPDATA2m_CBPDATAf_SET
#define READ_MMU_CBPDATA2m BCM53324_A0_READ_MMU_CBPDATA2m
#define WRITE_MMU_CBPDATA2m BCM53324_A0_WRITE_MMU_CBPDATA2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPDATA2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPData3
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 3
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [511:384]
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPDATA3m 0x0a60c000

#define BCM53324_A0_MMU_CBPDATA3m_MIN 0
#define BCM53324_A0_MMU_CBPDATA3m_MAX 4095
#define BCM53324_A0_MMU_CBPDATA3m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPDATA3m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData3.
 *
 */
typedef union BCM53324_A0_MMU_CBPDATA3m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata3[4];
	uint32_t _mmu_cbpdata3;
} BCM53324_A0_MMU_CBPDATA3m_t;

#define BCM53324_A0_MMU_CBPDATA3m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata3), 0, sizeof(BCM53324_A0_MMU_CBPDATA3m_t))
#define BCM53324_A0_MMU_CBPDATA3m_SET(r,i,d) (r).mmu_cbpdata3[i] = d
#define BCM53324_A0_MMU_CBPDATA3m_GET(r,i) (r).mmu_cbpdata3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPDATA3m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata3,0,127,a)
#define BCM53324_A0_MMU_CBPDATA3m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata3,0,127,a)

/*
 * These macros can be used to access MMU_CBPData3.
 *
 */
#define BCM53324_A0_READ_MMU_CBPDATA3m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPDATA3m,i,(m._mmu_cbpdata3),4)
#define BCM53324_A0_WRITE_MMU_CBPDATA3m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPDATA3m,i,&(m._mmu_cbpdata3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA3m BCM53324_A0_MMU_CBPDATA3m
#define MMU_CBPDATA3m_MIN BCM53324_A0_MMU_CBPDATA3m_MIN
#define MMU_CBPDATA3m_MAX BCM53324_A0_MMU_CBPDATA3m_MAX
#define MMU_CBPDATA3m_CMAX(u) BCM53324_A0_MMU_CBPDATA3m_CMAX(u)
#define MMU_CBPDATA3m_SIZE BCM53324_A0_MMU_CBPDATA3m_SIZE
typedef BCM53324_A0_MMU_CBPDATA3m_t MMU_CBPDATA3m_t;
#define MMU_CBPDATA3m_CLR BCM53324_A0_MMU_CBPDATA3m_CLR
#define MMU_CBPDATA3m_SET BCM53324_A0_MMU_CBPDATA3m_SET
#define MMU_CBPDATA3m_GET BCM53324_A0_MMU_CBPDATA3m_GET
#define MMU_CBPDATA3m_CBPDATAf_GET BCM53324_A0_MMU_CBPDATA3m_CBPDATAf_GET
#define MMU_CBPDATA3m_CBPDATAf_SET BCM53324_A0_MMU_CBPDATA3m_CBPDATAf_SET
#define READ_MMU_CBPDATA3m BCM53324_A0_READ_MMU_CBPDATA3m
#define WRITE_MMU_CBPDATA3m BCM53324_A0_WRITE_MMU_CBPDATA3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPDATA3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPData4
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 4
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [539:512]
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPDATA4m 0x0a610000

#define BCM53324_A0_MMU_CBPDATA4m_MIN 0
#define BCM53324_A0_MMU_CBPDATA4m_MAX 4095
#define BCM53324_A0_MMU_CBPDATA4m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPDATA4m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData4.
 *
 */
typedef union BCM53324_A0_MMU_CBPDATA4m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata4[4];
	uint32_t _mmu_cbpdata4;
} BCM53324_A0_MMU_CBPDATA4m_t;

#define BCM53324_A0_MMU_CBPDATA4m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata4), 0, sizeof(BCM53324_A0_MMU_CBPDATA4m_t))
#define BCM53324_A0_MMU_CBPDATA4m_SET(r,i,d) (r).mmu_cbpdata4[i] = d
#define BCM53324_A0_MMU_CBPDATA4m_GET(r,i) (r).mmu_cbpdata4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPDATA4m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata4,0,127,a)
#define BCM53324_A0_MMU_CBPDATA4m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata4,0,127,a)

/*
 * These macros can be used to access MMU_CBPData4.
 *
 */
#define BCM53324_A0_READ_MMU_CBPDATA4m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPDATA4m,i,(m._mmu_cbpdata4),4)
#define BCM53324_A0_WRITE_MMU_CBPDATA4m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPDATA4m,i,&(m._mmu_cbpdata4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA4m BCM53324_A0_MMU_CBPDATA4m
#define MMU_CBPDATA4m_MIN BCM53324_A0_MMU_CBPDATA4m_MIN
#define MMU_CBPDATA4m_MAX BCM53324_A0_MMU_CBPDATA4m_MAX
#define MMU_CBPDATA4m_CMAX(u) BCM53324_A0_MMU_CBPDATA4m_CMAX(u)
#define MMU_CBPDATA4m_SIZE BCM53324_A0_MMU_CBPDATA4m_SIZE
typedef BCM53324_A0_MMU_CBPDATA4m_t MMU_CBPDATA4m_t;
#define MMU_CBPDATA4m_CLR BCM53324_A0_MMU_CBPDATA4m_CLR
#define MMU_CBPDATA4m_SET BCM53324_A0_MMU_CBPDATA4m_SET
#define MMU_CBPDATA4m_GET BCM53324_A0_MMU_CBPDATA4m_GET
#define MMU_CBPDATA4m_CBPDATAf_GET BCM53324_A0_MMU_CBPDATA4m_CBPDATAf_GET
#define MMU_CBPDATA4m_CBPDATAf_SET BCM53324_A0_MMU_CBPDATA4m_CBPDATAf_SET
#define READ_MMU_CBPDATA4m BCM53324_A0_READ_MMU_CBPDATA4m
#define WRITE_MMU_CBPDATA4m BCM53324_A0_WRITE_MMU_CBPDATA4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPDATA4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPData5
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 5
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [767:540]
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPDATA5m 0x0a614000

#define BCM53324_A0_MMU_CBPDATA5m_MIN 0
#define BCM53324_A0_MMU_CBPDATA5m_MAX 4095
#define BCM53324_A0_MMU_CBPDATA5m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPDATA5m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData5.
 *
 */
typedef union BCM53324_A0_MMU_CBPDATA5m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata5[4];
	uint32_t _mmu_cbpdata5;
} BCM53324_A0_MMU_CBPDATA5m_t;

#define BCM53324_A0_MMU_CBPDATA5m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata5), 0, sizeof(BCM53324_A0_MMU_CBPDATA5m_t))
#define BCM53324_A0_MMU_CBPDATA5m_SET(r,i,d) (r).mmu_cbpdata5[i] = d
#define BCM53324_A0_MMU_CBPDATA5m_GET(r,i) (r).mmu_cbpdata5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPDATA5m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata5,0,127,a)
#define BCM53324_A0_MMU_CBPDATA5m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata5,0,127,a)

/*
 * These macros can be used to access MMU_CBPData5.
 *
 */
#define BCM53324_A0_READ_MMU_CBPDATA5m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPDATA5m,i,(m._mmu_cbpdata5),4)
#define BCM53324_A0_WRITE_MMU_CBPDATA5m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPDATA5m,i,&(m._mmu_cbpdata5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA5m BCM53324_A0_MMU_CBPDATA5m
#define MMU_CBPDATA5m_MIN BCM53324_A0_MMU_CBPDATA5m_MIN
#define MMU_CBPDATA5m_MAX BCM53324_A0_MMU_CBPDATA5m_MAX
#define MMU_CBPDATA5m_CMAX(u) BCM53324_A0_MMU_CBPDATA5m_CMAX(u)
#define MMU_CBPDATA5m_SIZE BCM53324_A0_MMU_CBPDATA5m_SIZE
typedef BCM53324_A0_MMU_CBPDATA5m_t MMU_CBPDATA5m_t;
#define MMU_CBPDATA5m_CLR BCM53324_A0_MMU_CBPDATA5m_CLR
#define MMU_CBPDATA5m_SET BCM53324_A0_MMU_CBPDATA5m_SET
#define MMU_CBPDATA5m_GET BCM53324_A0_MMU_CBPDATA5m_GET
#define MMU_CBPDATA5m_CBPDATAf_GET BCM53324_A0_MMU_CBPDATA5m_CBPDATAf_GET
#define MMU_CBPDATA5m_CBPDATAf_SET BCM53324_A0_MMU_CBPDATA5m_CBPDATAf_SET
#define READ_MMU_CBPDATA5m BCM53324_A0_READ_MMU_CBPDATA5m
#define WRITE_MMU_CBPDATA5m BCM53324_A0_WRITE_MMU_CBPDATA5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPDATA5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPData6
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 6
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [895:768]
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPDATA6m 0x0a618000

#define BCM53324_A0_MMU_CBPDATA6m_MIN 0
#define BCM53324_A0_MMU_CBPDATA6m_MAX 4095
#define BCM53324_A0_MMU_CBPDATA6m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPDATA6m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData6.
 *
 */
typedef union BCM53324_A0_MMU_CBPDATA6m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata6[4];
	uint32_t _mmu_cbpdata6;
} BCM53324_A0_MMU_CBPDATA6m_t;

#define BCM53324_A0_MMU_CBPDATA6m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata6), 0, sizeof(BCM53324_A0_MMU_CBPDATA6m_t))
#define BCM53324_A0_MMU_CBPDATA6m_SET(r,i,d) (r).mmu_cbpdata6[i] = d
#define BCM53324_A0_MMU_CBPDATA6m_GET(r,i) (r).mmu_cbpdata6[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPDATA6m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata6,0,127,a)
#define BCM53324_A0_MMU_CBPDATA6m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata6,0,127,a)

/*
 * These macros can be used to access MMU_CBPData6.
 *
 */
#define BCM53324_A0_READ_MMU_CBPDATA6m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPDATA6m,i,(m._mmu_cbpdata6),4)
#define BCM53324_A0_WRITE_MMU_CBPDATA6m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPDATA6m,i,&(m._mmu_cbpdata6),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA6m BCM53324_A0_MMU_CBPDATA6m
#define MMU_CBPDATA6m_MIN BCM53324_A0_MMU_CBPDATA6m_MIN
#define MMU_CBPDATA6m_MAX BCM53324_A0_MMU_CBPDATA6m_MAX
#define MMU_CBPDATA6m_CMAX(u) BCM53324_A0_MMU_CBPDATA6m_CMAX(u)
#define MMU_CBPDATA6m_SIZE BCM53324_A0_MMU_CBPDATA6m_SIZE
typedef BCM53324_A0_MMU_CBPDATA6m_t MMU_CBPDATA6m_t;
#define MMU_CBPDATA6m_CLR BCM53324_A0_MMU_CBPDATA6m_CLR
#define MMU_CBPDATA6m_SET BCM53324_A0_MMU_CBPDATA6m_SET
#define MMU_CBPDATA6m_GET BCM53324_A0_MMU_CBPDATA6m_GET
#define MMU_CBPDATA6m_CBPDATAf_GET BCM53324_A0_MMU_CBPDATA6m_CBPDATAf_GET
#define MMU_CBPDATA6m_CBPDATAf_SET BCM53324_A0_MMU_CBPDATA6m_CBPDATAf_SET
#define READ_MMU_CBPDATA6m BCM53324_A0_READ_MMU_CBPDATA6m
#define WRITE_MMU_CBPDATA6m BCM53324_A0_WRITE_MMU_CBPDATA6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPDATA6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPData7
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 7
 * SIZE:     128
 * FIELDS:
 *     CBPDATA          CBPData [1025:896]
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPDATA7m 0x0a61c000

#define BCM53324_A0_MMU_CBPDATA7m_MIN 0
#define BCM53324_A0_MMU_CBPDATA7m_MAX 4095
#define BCM53324_A0_MMU_CBPDATA7m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPDATA7m_SIZE 16

/*
 * This structure should be used to declare and program MMU_CBPData7.
 *
 */
typedef union BCM53324_A0_MMU_CBPDATA7m_s {
	uint32_t v[4];
	uint32_t mmu_cbpdata7[4];
	uint32_t _mmu_cbpdata7;
} BCM53324_A0_MMU_CBPDATA7m_t;

#define BCM53324_A0_MMU_CBPDATA7m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata7), 0, sizeof(BCM53324_A0_MMU_CBPDATA7m_t))
#define BCM53324_A0_MMU_CBPDATA7m_SET(r,i,d) (r).mmu_cbpdata7[i] = d
#define BCM53324_A0_MMU_CBPDATA7m_GET(r,i) (r).mmu_cbpdata7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPDATA7m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata7,0,127,a)
#define BCM53324_A0_MMU_CBPDATA7m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata7,0,127,a)

/*
 * These macros can be used to access MMU_CBPData7.
 *
 */
#define BCM53324_A0_READ_MMU_CBPDATA7m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPDATA7m,i,(m._mmu_cbpdata7),4)
#define BCM53324_A0_WRITE_MMU_CBPDATA7m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPDATA7m,i,&(m._mmu_cbpdata7),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA7m BCM53324_A0_MMU_CBPDATA7m
#define MMU_CBPDATA7m_MIN BCM53324_A0_MMU_CBPDATA7m_MIN
#define MMU_CBPDATA7m_MAX BCM53324_A0_MMU_CBPDATA7m_MAX
#define MMU_CBPDATA7m_CMAX(u) BCM53324_A0_MMU_CBPDATA7m_CMAX(u)
#define MMU_CBPDATA7m_SIZE BCM53324_A0_MMU_CBPDATA7m_SIZE
typedef BCM53324_A0_MMU_CBPDATA7m_t MMU_CBPDATA7m_t;
#define MMU_CBPDATA7m_CLR BCM53324_A0_MMU_CBPDATA7m_CLR
#define MMU_CBPDATA7m_SET BCM53324_A0_MMU_CBPDATA7m_SET
#define MMU_CBPDATA7m_GET BCM53324_A0_MMU_CBPDATA7m_GET
#define MMU_CBPDATA7m_CBPDATAf_GET BCM53324_A0_MMU_CBPDATA7m_CBPDATAf_GET
#define MMU_CBPDATA7m_CBPDATAf_SET BCM53324_A0_MMU_CBPDATA7m_CBPDATAf_SET
#define READ_MMU_CBPDATA7m BCM53324_A0_READ_MMU_CBPDATA7m
#define WRITE_MMU_CBPDATA7m BCM53324_A0_WRITE_MMU_CBPDATA7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPDATA7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPPktHeader0
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 0
 * SIZE:     34
 * FIELDS:
 *     EAV_DATA_PKT     Indicates EAV data packet to EP. This bit is not modified in MMU
 *     PBI_RESERVED_BIT_0 pbi reserved bit 0. Reserved for future use
 *     SRC_PORT_NUM     Source Port Number
 *     NHOP_INDEX       Next HOP Index
 *     DSCP             New DSCP
 *     COPY_COUNT       How Many copies of this cell are there
 *     L3UC             L3 unicast bit
 *     PARITY_0         Parity bit
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPPKTHEADER0m 0x0a640000

#define BCM53324_A0_MMU_CBPPKTHEADER0m_MIN 0
#define BCM53324_A0_MMU_CBPPKTHEADER0m_MAX 4095
#define BCM53324_A0_MMU_CBPPKTHEADER0m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPPKTHEADER0m_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeader0.
 *
 */
typedef union BCM53324_A0_MMU_CBPPKTHEADER0m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader0[2];
	uint32_t _mmu_cbppktheader0;
} BCM53324_A0_MMU_CBPPKTHEADER0m_t;

#define BCM53324_A0_MMU_CBPPKTHEADER0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader0), 0, sizeof(BCM53324_A0_MMU_CBPPKTHEADER0m_t))
#define BCM53324_A0_MMU_CBPPKTHEADER0m_SET(r,i,d) (r).mmu_cbppktheader0[i] = d
#define BCM53324_A0_MMU_CBPPKTHEADER0m_GET(r,i) (r).mmu_cbppktheader0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPPKTHEADER0m_EAV_DATA_PKTf_GET(r) (((r).mmu_cbppktheader0[0]) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER0m_EAV_DATA_PKTf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_GET(r) ((((r).mmu_cbppktheader0[0]) >> 1) & 0x7f)
#define BCM53324_A0_MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM53324_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 8) & 0x3f)
#define BCM53324_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 14) & 0x3f)
#define BCM53324_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM53324_A0_MMU_CBPPKTHEADER0m_DSCPf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 20) & 0x3f)
#define BCM53324_A0_MMU_CBPPKTHEADER0m_DSCPf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM53324_A0_MMU_CBPPKTHEADER0m_COPY_COUNTf_GET(r) ((((r).mmu_cbppktheader0[0]) >> 26) & 0x3f)
#define BCM53324_A0_MMU_CBPPKTHEADER0m_COPY_COUNTf_SET(r,f) (r).mmu_cbppktheader0[0]=(((r).mmu_cbppktheader0[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define BCM53324_A0_MMU_CBPPKTHEADER0m_L3UCf_GET(r) (((r).mmu_cbppktheader0[1]) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER0m_L3UCf_SET(r,f) (r).mmu_cbppktheader0[1]=(((r).mmu_cbppktheader0[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_CBPPKTHEADER0m_PARITY_0f_GET(r) ((((r).mmu_cbppktheader0[1]) >> 1) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER0m_PARITY_0f_SET(r,f) (r).mmu_cbppktheader0[1]=(((r).mmu_cbppktheader0[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access MMU_CBPPktHeader0.
 *
 */
#define BCM53324_A0_READ_MMU_CBPPKTHEADER0m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPPKTHEADER0m,i,(m._mmu_cbppktheader0),2)
#define BCM53324_A0_WRITE_MMU_CBPPKTHEADER0m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPPKTHEADER0m,i,&(m._mmu_cbppktheader0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER0m BCM53324_A0_MMU_CBPPKTHEADER0m
#define MMU_CBPPKTHEADER0m_MIN BCM53324_A0_MMU_CBPPKTHEADER0m_MIN
#define MMU_CBPPKTHEADER0m_MAX BCM53324_A0_MMU_CBPPKTHEADER0m_MAX
#define MMU_CBPPKTHEADER0m_CMAX(u) BCM53324_A0_MMU_CBPPKTHEADER0m_CMAX(u)
#define MMU_CBPPKTHEADER0m_SIZE BCM53324_A0_MMU_CBPPKTHEADER0m_SIZE
typedef BCM53324_A0_MMU_CBPPKTHEADER0m_t MMU_CBPPKTHEADER0m_t;
#define MMU_CBPPKTHEADER0m_CLR BCM53324_A0_MMU_CBPPKTHEADER0m_CLR
#define MMU_CBPPKTHEADER0m_SET BCM53324_A0_MMU_CBPPKTHEADER0m_SET
#define MMU_CBPPKTHEADER0m_GET BCM53324_A0_MMU_CBPPKTHEADER0m_GET
#define MMU_CBPPKTHEADER0m_EAV_DATA_PKTf_GET BCM53324_A0_MMU_CBPPKTHEADER0m_EAV_DATA_PKTf_GET
#define MMU_CBPPKTHEADER0m_EAV_DATA_PKTf_SET BCM53324_A0_MMU_CBPPKTHEADER0m_EAV_DATA_PKTf_SET
#define MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_GET BCM53324_A0_MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_GET
#define MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_SET BCM53324_A0_MMU_CBPPKTHEADER0m_PBI_RESERVED_BIT_0f_SET
#define MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET BCM53324_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_GET
#define MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET BCM53324_A0_MMU_CBPPKTHEADER0m_SRC_PORT_NUMf_SET
#define MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET BCM53324_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_GET
#define MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET BCM53324_A0_MMU_CBPPKTHEADER0m_NHOP_INDEXf_SET
#define MMU_CBPPKTHEADER0m_DSCPf_GET BCM53324_A0_MMU_CBPPKTHEADER0m_DSCPf_GET
#define MMU_CBPPKTHEADER0m_DSCPf_SET BCM53324_A0_MMU_CBPPKTHEADER0m_DSCPf_SET
#define MMU_CBPPKTHEADER0m_COPY_COUNTf_GET BCM53324_A0_MMU_CBPPKTHEADER0m_COPY_COUNTf_GET
#define MMU_CBPPKTHEADER0m_COPY_COUNTf_SET BCM53324_A0_MMU_CBPPKTHEADER0m_COPY_COUNTf_SET
#define MMU_CBPPKTHEADER0m_L3UCf_GET BCM53324_A0_MMU_CBPPKTHEADER0m_L3UCf_GET
#define MMU_CBPPKTHEADER0m_L3UCf_SET BCM53324_A0_MMU_CBPPKTHEADER0m_L3UCf_SET
#define MMU_CBPPKTHEADER0m_PARITY_0f_GET BCM53324_A0_MMU_CBPPKTHEADER0m_PARITY_0f_GET
#define MMU_CBPPKTHEADER0m_PARITY_0f_SET BCM53324_A0_MMU_CBPPKTHEADER0m_PARITY_0f_SET
#define READ_MMU_CBPPKTHEADER0m BCM53324_A0_READ_MMU_CBPPKTHEADER0m
#define WRITE_MMU_CBPPKTHEADER0m BCM53324_A0_WRITE_MMU_CBPPKTHEADER0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPPKTHEADER0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CBPPktHeader1
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 1
 * SIZE:     34
 * FIELDS:
 *     PKT_PRI          Insert Priority
 *     PKT_VID          Insert Vlan ID
 *     ADD_VID          VLAN ID Added
 *     PKT_CFI          Insert Vlan ID
 *     INGRESS_TAGGED   Ingress Packet Tagged
 *     PBI_RESERVED_BIT_1 PBI reserved bit 1
 *     SOBMH            sobmh
 *     PBI_RESERVED_BIT_3 PBI reserved bit 3
 *     DO_NOT_CHANGE_TTL PBI reserved bit 1
 *     ECN              PBI reserved bit 1
 *     BPDU             BPDU bit
 *     TS_PKT           Time-stamp packet flag
 *     RESERVED         reserved
 *     PARITY_1         Parity for CBP Packet Header
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CBPPKTHEADER1m 0x0a644000

#define BCM53324_A0_MMU_CBPPKTHEADER1m_MIN 0
#define BCM53324_A0_MMU_CBPPKTHEADER1m_MAX 4095
#define BCM53324_A0_MMU_CBPPKTHEADER1m_CMAX(u) 4095
#define BCM53324_A0_MMU_CBPPKTHEADER1m_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeader1.
 *
 */
typedef union BCM53324_A0_MMU_CBPPKTHEADER1m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader1[2];
	uint32_t _mmu_cbppktheader1;
} BCM53324_A0_MMU_CBPPKTHEADER1m_t;

#define BCM53324_A0_MMU_CBPPKTHEADER1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader1), 0, sizeof(BCM53324_A0_MMU_CBPPKTHEADER1m_t))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_SET(r,i,d) (r).mmu_cbppktheader1[i] = d
#define BCM53324_A0_MMU_CBPPKTHEADER1m_GET(r,i) (r).mmu_cbppktheader1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_GET(r) (((r).mmu_cbppktheader1[0]) & 0x7)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 17) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_GET(r) ((((r).mmu_cbppktheader1[0]) >> 18) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_SOBMHf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 19) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_SOBMHf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_GET(r) ((((r).mmu_cbppktheader1[0]) >> 20) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 21) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_ECNf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 22) & 0x3)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_ECNf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_BPDUf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 24) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_BPDUf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_TS_PKTf_GET(r) ((((r).mmu_cbppktheader1[0]) >> 25) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_TS_PKTf_SET(r,f) (r).mmu_cbppktheader1[0]=(((r).mmu_cbppktheader1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_MMU_CBPPKTHEADER1m_RESERVEDf_GET(r) cdk_field32_get((r).mmu_cbppktheader1,26,32)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_RESERVEDf_SET(r,f) cdk_field32_set((r).mmu_cbppktheader1,26,32,f)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PARITY_1f_GET(r) ((((r).mmu_cbppktheader1[1]) >> 1) & 0x1)
#define BCM53324_A0_MMU_CBPPKTHEADER1m_PARITY_1f_SET(r,f) (r).mmu_cbppktheader1[1]=(((r).mmu_cbppktheader1[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access MMU_CBPPktHeader1.
 *
 */
#define BCM53324_A0_READ_MMU_CBPPKTHEADER1m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CBPPKTHEADER1m,i,(m._mmu_cbppktheader1),2)
#define BCM53324_A0_WRITE_MMU_CBPPKTHEADER1m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CBPPKTHEADER1m,i,&(m._mmu_cbppktheader1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER1m BCM53324_A0_MMU_CBPPKTHEADER1m
#define MMU_CBPPKTHEADER1m_MIN BCM53324_A0_MMU_CBPPKTHEADER1m_MIN
#define MMU_CBPPKTHEADER1m_MAX BCM53324_A0_MMU_CBPPKTHEADER1m_MAX
#define MMU_CBPPKTHEADER1m_CMAX(u) BCM53324_A0_MMU_CBPPKTHEADER1m_CMAX(u)
#define MMU_CBPPKTHEADER1m_SIZE BCM53324_A0_MMU_CBPPKTHEADER1m_SIZE
typedef BCM53324_A0_MMU_CBPPKTHEADER1m_t MMU_CBPPKTHEADER1m_t;
#define MMU_CBPPKTHEADER1m_CLR BCM53324_A0_MMU_CBPPKTHEADER1m_CLR
#define MMU_CBPPKTHEADER1m_SET BCM53324_A0_MMU_CBPPKTHEADER1m_SET
#define MMU_CBPPKTHEADER1m_GET BCM53324_A0_MMU_CBPPKTHEADER1m_GET
#define MMU_CBPPKTHEADER1m_PKT_PRIf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_GET
#define MMU_CBPPKTHEADER1m_PKT_PRIf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_PRIf_SET
#define MMU_CBPPKTHEADER1m_PKT_VIDf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_GET
#define MMU_CBPPKTHEADER1m_PKT_VIDf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_VIDf_SET
#define MMU_CBPPKTHEADER1m_ADD_VIDf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_GET
#define MMU_CBPPKTHEADER1m_ADD_VIDf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_ADD_VIDf_SET
#define MMU_CBPPKTHEADER1m_PKT_CFIf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_GET
#define MMU_CBPPKTHEADER1m_PKT_CFIf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_PKT_CFIf_SET
#define MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_GET
#define MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_INGRESS_TAGGEDf_SET
#define MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_GET BCM53324_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_GET
#define MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_SET BCM53324_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_1f_SET
#define MMU_CBPPKTHEADER1m_SOBMHf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_SOBMHf_GET
#define MMU_CBPPKTHEADER1m_SOBMHf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_SOBMHf_SET
#define MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_GET BCM53324_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_GET
#define MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_SET BCM53324_A0_MMU_CBPPKTHEADER1m_PBI_RESERVED_BIT_3f_SET
#define MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_GET
#define MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_DO_NOT_CHANGE_TTLf_SET
#define MMU_CBPPKTHEADER1m_ECNf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_ECNf_GET
#define MMU_CBPPKTHEADER1m_ECNf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_ECNf_SET
#define MMU_CBPPKTHEADER1m_BPDUf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_BPDUf_GET
#define MMU_CBPPKTHEADER1m_BPDUf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_BPDUf_SET
#define MMU_CBPPKTHEADER1m_TS_PKTf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_TS_PKTf_GET
#define MMU_CBPPKTHEADER1m_TS_PKTf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_TS_PKTf_SET
#define MMU_CBPPKTHEADER1m_RESERVEDf_GET BCM53324_A0_MMU_CBPPKTHEADER1m_RESERVEDf_GET
#define MMU_CBPPKTHEADER1m_RESERVEDf_SET BCM53324_A0_MMU_CBPPKTHEADER1m_RESERVEDf_SET
#define MMU_CBPPKTHEADER1m_PARITY_1f_GET BCM53324_A0_MMU_CBPPKTHEADER1m_PARITY_1f_GET
#define MMU_CBPPKTHEADER1m_PARITY_1f_SET BCM53324_A0_MMU_CBPPKTHEADER1m_PARITY_1f_SET
#define READ_MMU_CBPPKTHEADER1m BCM53324_A0_READ_MMU_CBPPKTHEADER1m
#define WRITE_MMU_CBPPKTHEADER1m BCM53324_A0_WRITE_MMU_CBPPKTHEADER1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CBPPKTHEADER1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CCP
 * BLOCKS:   MMU
 * DESC:     Copy Count Pool RAM
 * SIZE:     6
 * FIELDS:
 *     CCP              Packet's copy count
 *     PARITY           Packet's copy count parity
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CCPm 0x0a654000

#define BCM53324_A0_MMU_CCPm_MIN 0
#define BCM53324_A0_MMU_CCPm_MAX 4095
#define BCM53324_A0_MMU_CCPm_CMAX(u) 4095
#define BCM53324_A0_MMU_CCPm_SIZE 1

/*
 * This structure should be used to declare and program MMU_CCP.
 *
 */
typedef union BCM53324_A0_MMU_CCPm_s {
	uint32_t v[1];
	uint32_t mmu_ccp[1];
	uint32_t _mmu_ccp;
} BCM53324_A0_MMU_CCPm_t;

#define BCM53324_A0_MMU_CCPm_CLR(r) (r).mmu_ccp[0] = 0
#define BCM53324_A0_MMU_CCPm_SET(r,d) (r).mmu_ccp[0] = d
#define BCM53324_A0_MMU_CCPm_GET(r) (r).mmu_ccp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CCPm_CCPf_GET(r) (((r).mmu_ccp[0]) & 0x1f)
#define BCM53324_A0_MMU_CCPm_CCPf_SET(r,f) (r).mmu_ccp[0]=(((r).mmu_ccp[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53324_A0_MMU_CCPm_PARITYf_GET(r) ((((r).mmu_ccp[0]) >> 5) & 0x1)
#define BCM53324_A0_MMU_CCPm_PARITYf_SET(r,f) (r).mmu_ccp[0]=(((r).mmu_ccp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MMU_CCP.
 *
 */
#define BCM53324_A0_READ_MMU_CCPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CCPm,i,(m._mmu_ccp),1)
#define BCM53324_A0_WRITE_MMU_CCPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CCPm,i,&(m._mmu_ccp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CCPm BCM53324_A0_MMU_CCPm
#define MMU_CCPm_MIN BCM53324_A0_MMU_CCPm_MIN
#define MMU_CCPm_MAX BCM53324_A0_MMU_CCPm_MAX
#define MMU_CCPm_CMAX(u) BCM53324_A0_MMU_CCPm_CMAX(u)
#define MMU_CCPm_SIZE BCM53324_A0_MMU_CCPm_SIZE
typedef BCM53324_A0_MMU_CCPm_t MMU_CCPm_t;
#define MMU_CCPm_CLR BCM53324_A0_MMU_CCPm_CLR
#define MMU_CCPm_SET BCM53324_A0_MMU_CCPm_SET
#define MMU_CCPm_GET BCM53324_A0_MMU_CCPm_GET
#define MMU_CCPm_CCPf_GET BCM53324_A0_MMU_CCPm_CCPf_GET
#define MMU_CCPm_CCPf_SET BCM53324_A0_MMU_CCPm_CCPf_SET
#define MMU_CCPm_PARITYf_GET BCM53324_A0_MMU_CCPm_PARITYf_GET
#define MMU_CCPm_PARITYf_SET BCM53324_A0_MMU_CCPm_PARITYf_SET
#define READ_MMU_CCPm BCM53324_A0_READ_MMU_CCPm
#define WRITE_MMU_CCPm BCM53324_A0_WRITE_MMU_CCPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CCPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_CFAP
 * BLOCKS:   MMU
 * DESC:     CBP Free Address Pool RAM
 * SIZE:     13
 * FIELDS:
 *     FREE_PTR         CBP Free Address
 *     PARITY           CBP Free Address Parity
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_CFAPm 0x0a650000

#define BCM53324_A0_MMU_CFAPm_MIN 0
#define BCM53324_A0_MMU_CFAPm_MAX 4095
#define BCM53324_A0_MMU_CFAPm_CMAX(u) 4095
#define BCM53324_A0_MMU_CFAPm_SIZE 2

/*
 * This structure should be used to declare and program MMU_CFAP.
 *
 */
typedef union BCM53324_A0_MMU_CFAPm_s {
	uint32_t v[1];
	uint32_t mmu_cfap[1];
	uint32_t _mmu_cfap;
} BCM53324_A0_MMU_CFAPm_t;

#define BCM53324_A0_MMU_CFAPm_CLR(r) (r).mmu_cfap[0] = 0
#define BCM53324_A0_MMU_CFAPm_SET(r,d) (r).mmu_cfap[0] = d
#define BCM53324_A0_MMU_CFAPm_GET(r) (r).mmu_cfap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_CFAPm_FREE_PTRf_GET(r) (((r).mmu_cfap[0]) & 0xfff)
#define BCM53324_A0_MMU_CFAPm_FREE_PTRf_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_MMU_CFAPm_PARITYf_GET(r) ((((r).mmu_cfap[0]) >> 12) & 0x1)
#define BCM53324_A0_MMU_CFAPm_PARITYf_SET(r,f) (r).mmu_cfap[0]=(((r).mmu_cfap[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access MMU_CFAP.
 *
 */
#define BCM53324_A0_READ_MMU_CFAPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_CFAPm,i,(m._mmu_cfap),1)
#define BCM53324_A0_WRITE_MMU_CFAPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_CFAPm,i,&(m._mmu_cfap),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CFAPm BCM53324_A0_MMU_CFAPm
#define MMU_CFAPm_MIN BCM53324_A0_MMU_CFAPm_MIN
#define MMU_CFAPm_MAX BCM53324_A0_MMU_CFAPm_MAX
#define MMU_CFAPm_CMAX(u) BCM53324_A0_MMU_CFAPm_CMAX(u)
#define MMU_CFAPm_SIZE BCM53324_A0_MMU_CFAPm_SIZE
typedef BCM53324_A0_MMU_CFAPm_t MMU_CFAPm_t;
#define MMU_CFAPm_CLR BCM53324_A0_MMU_CFAPm_CLR
#define MMU_CFAPm_SET BCM53324_A0_MMU_CFAPm_SET
#define MMU_CFAPm_GET BCM53324_A0_MMU_CFAPm_GET
#define MMU_CFAPm_FREE_PTRf_GET BCM53324_A0_MMU_CFAPm_FREE_PTRf_GET
#define MMU_CFAPm_FREE_PTRf_SET BCM53324_A0_MMU_CFAPm_FREE_PTRf_SET
#define MMU_CFAPm_PARITYf_GET BCM53324_A0_MMU_CFAPm_PARITYf_GET
#define MMU_CFAPm_PARITYf_SET BCM53324_A0_MMU_CFAPm_PARITYf_SET
#define READ_MMU_CFAPm BCM53324_A0_READ_MMU_CFAPm
#define WRITE_MMU_CFAPm BCM53324_A0_WRITE_MMU_CFAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_CFAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_MAX_BUCKET_GPORT
 * BLOCKS:   MMU
 * DESC:     MMU_MAX_BUCKET_GPORT
 * SIZE:     60
 * FIELDS:
 *     THD_SEL          MAX Shaping Bucket Size.
 *     REFRESH          MAX Shaping Bucket Refresh Count.
 *     BUCKET           MAX Shaping Bucket.
 *     RESERVED         Reserved bit
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm 0x0a674000

#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_MIN 0
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_MAX 95
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_CMAX(u) 95
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_SIZE 8

/*
 * This structure should be used to declare and program MMU_MAX_BUCKET_GPORT.
 *
 */
typedef union BCM53324_A0_MMU_MAX_BUCKET_GPORTm_s {
	uint32_t v[2];
	uint32_t mmu_max_bucket_gport[2];
	uint32_t _mmu_max_bucket_gport;
} BCM53324_A0_MMU_MAX_BUCKET_GPORTm_t;

#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_CLR(r) CDK_MEMSET(&((r)._mmu_max_bucket_gport), 0, sizeof(BCM53324_A0_MMU_MAX_BUCKET_GPORTm_t))
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_SET(r,i,d) (r).mmu_max_bucket_gport[i] = d
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_GET(r,i) (r).mmu_max_bucket_gport[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_THD_SELf_GET(r) (((r).mmu_max_bucket_gport[0]) & 0xfff)
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_THD_SELf_SET(r,f) (r).mmu_max_bucket_gport[0]=(((r).mmu_max_bucket_gport[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_REFRESHf_GET(r) ((((r).mmu_max_bucket_gport[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_REFRESHf_SET(r,f) (r).mmu_max_bucket_gport[0]=(((r).mmu_max_bucket_gport[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_BUCKETf_GET(r) cdk_field32_get((r).mmu_max_bucket_gport,30,58)
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_BUCKETf_SET(r,f) cdk_field32_set((r).mmu_max_bucket_gport,30,58,f)
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_RESERVEDf_GET(r) ((((r).mmu_max_bucket_gport[1]) >> 27) & 0x1)
#define BCM53324_A0_MMU_MAX_BUCKET_GPORTm_RESERVEDf_SET(r,f) (r).mmu_max_bucket_gport[1]=(((r).mmu_max_bucket_gport[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access MMU_MAX_BUCKET_GPORT.
 *
 */
#define BCM53324_A0_READ_MMU_MAX_BUCKET_GPORTm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_MAX_BUCKET_GPORTm,i,(m._mmu_max_bucket_gport),2)
#define BCM53324_A0_WRITE_MMU_MAX_BUCKET_GPORTm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_MAX_BUCKET_GPORTm,i,&(m._mmu_max_bucket_gport),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_MAX_BUCKET_GPORTm BCM53324_A0_MMU_MAX_BUCKET_GPORTm
#define MMU_MAX_BUCKET_GPORTm_MIN BCM53324_A0_MMU_MAX_BUCKET_GPORTm_MIN
#define MMU_MAX_BUCKET_GPORTm_MAX BCM53324_A0_MMU_MAX_BUCKET_GPORTm_MAX
#define MMU_MAX_BUCKET_GPORTm_CMAX(u) BCM53324_A0_MMU_MAX_BUCKET_GPORTm_CMAX(u)
#define MMU_MAX_BUCKET_GPORTm_SIZE BCM53324_A0_MMU_MAX_BUCKET_GPORTm_SIZE
typedef BCM53324_A0_MMU_MAX_BUCKET_GPORTm_t MMU_MAX_BUCKET_GPORTm_t;
#define MMU_MAX_BUCKET_GPORTm_CLR BCM53324_A0_MMU_MAX_BUCKET_GPORTm_CLR
#define MMU_MAX_BUCKET_GPORTm_SET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_SET
#define MMU_MAX_BUCKET_GPORTm_GET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_GET
#define MMU_MAX_BUCKET_GPORTm_THD_SELf_GET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_THD_SELf_GET
#define MMU_MAX_BUCKET_GPORTm_THD_SELf_SET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_THD_SELf_SET
#define MMU_MAX_BUCKET_GPORTm_REFRESHf_GET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_REFRESHf_GET
#define MMU_MAX_BUCKET_GPORTm_REFRESHf_SET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_REFRESHf_SET
#define MMU_MAX_BUCKET_GPORTm_BUCKETf_GET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_BUCKETf_GET
#define MMU_MAX_BUCKET_GPORTm_BUCKETf_SET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_BUCKETf_SET
#define MMU_MAX_BUCKET_GPORTm_RESERVEDf_GET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_RESERVEDf_GET
#define MMU_MAX_BUCKET_GPORTm_RESERVEDf_SET BCM53324_A0_MMU_MAX_BUCKET_GPORTm_RESERVEDf_SET
#define READ_MMU_MAX_BUCKET_GPORTm BCM53324_A0_READ_MMU_MAX_BUCKET_GPORTm
#define WRITE_MMU_MAX_BUCKET_GPORTm BCM53324_A0_WRITE_MMU_MAX_BUCKET_GPORTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_MAX_BUCKET_GPORTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_MIN_BUCKET_GPORT
 * BLOCKS:   MMU
 * DESC:     MMU_MIN_BUCKET_GPORT
 * SIZE:     60
 * FIELDS:
 *     THD_SEL          MIN Shaping Bucket Size.
 *     REFRESH          MIN Shaping Bucket Refresh Count.
 *     BUCKET           MIN Shaping Bucket.
 *     RESERVED         Reserved bit
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm 0x0a670000

#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_MIN 0
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_MAX 95
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_CMAX(u) 95
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_SIZE 8

/*
 * This structure should be used to declare and program MMU_MIN_BUCKET_GPORT.
 *
 */
typedef union BCM53324_A0_MMU_MIN_BUCKET_GPORTm_s {
	uint32_t v[2];
	uint32_t mmu_min_bucket_gport[2];
	uint32_t _mmu_min_bucket_gport;
} BCM53324_A0_MMU_MIN_BUCKET_GPORTm_t;

#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_CLR(r) CDK_MEMSET(&((r)._mmu_min_bucket_gport), 0, sizeof(BCM53324_A0_MMU_MIN_BUCKET_GPORTm_t))
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_SET(r,i,d) (r).mmu_min_bucket_gport[i] = d
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_GET(r,i) (r).mmu_min_bucket_gport[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_THD_SELf_GET(r) (((r).mmu_min_bucket_gport[0]) & 0xfff)
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_THD_SELf_SET(r,f) (r).mmu_min_bucket_gport[0]=(((r).mmu_min_bucket_gport[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_REFRESHf_GET(r) ((((r).mmu_min_bucket_gport[0]) >> 12) & 0x3ffff)
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_REFRESHf_SET(r,f) (r).mmu_min_bucket_gport[0]=(((r).mmu_min_bucket_gport[0] & ~((uint32_t)0x3ffff << 12)) | ((((uint32_t)f) & 0x3ffff) << 12))
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_BUCKETf_GET(r) cdk_field32_get((r).mmu_min_bucket_gport,30,58)
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_BUCKETf_SET(r,f) cdk_field32_set((r).mmu_min_bucket_gport,30,58,f)
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_RESERVEDf_GET(r) ((((r).mmu_min_bucket_gport[1]) >> 27) & 0x1)
#define BCM53324_A0_MMU_MIN_BUCKET_GPORTm_RESERVEDf_SET(r,f) (r).mmu_min_bucket_gport[1]=(((r).mmu_min_bucket_gport[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access MMU_MIN_BUCKET_GPORT.
 *
 */
#define BCM53324_A0_READ_MMU_MIN_BUCKET_GPORTm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_MIN_BUCKET_GPORTm,i,(m._mmu_min_bucket_gport),2)
#define BCM53324_A0_WRITE_MMU_MIN_BUCKET_GPORTm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_MIN_BUCKET_GPORTm,i,&(m._mmu_min_bucket_gport),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_MIN_BUCKET_GPORTm BCM53324_A0_MMU_MIN_BUCKET_GPORTm
#define MMU_MIN_BUCKET_GPORTm_MIN BCM53324_A0_MMU_MIN_BUCKET_GPORTm_MIN
#define MMU_MIN_BUCKET_GPORTm_MAX BCM53324_A0_MMU_MIN_BUCKET_GPORTm_MAX
#define MMU_MIN_BUCKET_GPORTm_CMAX(u) BCM53324_A0_MMU_MIN_BUCKET_GPORTm_CMAX(u)
#define MMU_MIN_BUCKET_GPORTm_SIZE BCM53324_A0_MMU_MIN_BUCKET_GPORTm_SIZE
typedef BCM53324_A0_MMU_MIN_BUCKET_GPORTm_t MMU_MIN_BUCKET_GPORTm_t;
#define MMU_MIN_BUCKET_GPORTm_CLR BCM53324_A0_MMU_MIN_BUCKET_GPORTm_CLR
#define MMU_MIN_BUCKET_GPORTm_SET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_SET
#define MMU_MIN_BUCKET_GPORTm_GET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_GET
#define MMU_MIN_BUCKET_GPORTm_THD_SELf_GET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_THD_SELf_GET
#define MMU_MIN_BUCKET_GPORTm_THD_SELf_SET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_THD_SELf_SET
#define MMU_MIN_BUCKET_GPORTm_REFRESHf_GET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_REFRESHf_GET
#define MMU_MIN_BUCKET_GPORTm_REFRESHf_SET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_REFRESHf_SET
#define MMU_MIN_BUCKET_GPORTm_BUCKETf_GET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_BUCKETf_GET
#define MMU_MIN_BUCKET_GPORTm_BUCKETf_SET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_BUCKETf_SET
#define MMU_MIN_BUCKET_GPORTm_RESERVEDf_GET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_RESERVEDf_GET
#define MMU_MIN_BUCKET_GPORTm_RESERVEDf_SET BCM53324_A0_MMU_MIN_BUCKET_GPORTm_RESERVEDf_SET
#define READ_MMU_MIN_BUCKET_GPORTm BCM53324_A0_READ_MMU_MIN_BUCKET_GPORTm
#define WRITE_MMU_MIN_BUCKET_GPORTm BCM53324_A0_WRITE_MMU_MIN_BUCKET_GPORTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_MIN_BUCKET_GPORTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ0
 * BLOCKS:   MMU
 * DESC:     XQ0
 * SIZE:     79
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY0_DATA     parity0 data
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     RESERVED_0       reserved for future use
 *     MATCHED_RULE     Matched Rule Number to help out the CPU
 *     CPU_OPCODE       CPU OPCode to help out the CPU. Extra 2-bit added for EAV/TS application
 *     COS              Packet COS
 *     L3_MTU_FAILED    Packet COS
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ .
 *     NEXT_XQ_POINTER  pointer to next entry in XQ .
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ0m 0x0b600000

#define BCM53324_A0_MMU_XQ0m_MIN 0
#define BCM53324_A0_MMU_XQ0m_MAX 511
#define BCM53324_A0_MMU_XQ0m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ0m_SIZE 10

/*
 * This structure should be used to declare and program MMU_XQ0.
 *
 */
typedef union BCM53324_A0_MMU_XQ0m_s {
	uint32_t v[3];
	uint32_t mmu_xq0[3];
	uint32_t _mmu_xq0;
} BCM53324_A0_MMU_XQ0m_t;

#define BCM53324_A0_MMU_XQ0m_CLR(r) CDK_MEMSET(&((r)._mmu_xq0), 0, sizeof(BCM53324_A0_MMU_XQ0m_t))
#define BCM53324_A0_MMU_XQ0m_SET(r,i,d) (r).mmu_xq0[i] = d
#define BCM53324_A0_MMU_XQ0m_GET(r,i) (r).mmu_xq0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ0m_DATAf_GET(r,a) cdk_field_get((r).mmu_xq0,0,64,a)
#define BCM53324_A0_MMU_XQ0m_DATAf_SET(r,a) cdk_field_set((r).mmu_xq0,0,64,a)
#define BCM53324_A0_MMU_XQ0m_PARITY_0f_GET(r) (((r).mmu_xq0[0]) & 0x1)
#define BCM53324_A0_MMU_XQ0m_PARITY_0f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ0m_PARITY0_DATAf_GET(r,a) cdk_field_get((r).mmu_xq0,1,64,a)
#define BCM53324_A0_MMU_XQ0m_PARITY0_DATAf_SET(r,a) cdk_field_set((r).mmu_xq0,1,64,a)
#define BCM53324_A0_MMU_XQ0m_L2f_GET(r) ((((r).mmu_xq0[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ0m_L2f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ0m_PURGEf_GET(r) ((((r).mmu_xq0[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ0m_PURGEf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ0m_PKT_PTRf_GET(r) ((((r).mmu_xq0[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ0m_PKT_PTRf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ0m_IMIRRORf_GET(r) ((((r).mmu_xq0[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ0m_IMIRRORf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ0m_EMIRRORf_GET(r) ((((r).mmu_xq0[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ0m_EMIRRORf_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ0m_RESERVED_0f_GET(r) ((((r).mmu_xq0[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ0m_RESERVED_0f_SET(r,f) (r).mmu_xq0[0]=(((r).mmu_xq0[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ0m_MATCHED_RULEf_GET(r) cdk_field32_get((r).mmu_xq0,22,32)
#define BCM53324_A0_MMU_XQ0m_MATCHED_RULEf_SET(r,f) cdk_field32_set((r).mmu_xq0,22,32,f)
#define BCM53324_A0_MMU_XQ0m_CPU_OPCODEf_GET(r) ((((r).mmu_xq0[1]) >> 1) & 0xfffffff)
#define BCM53324_A0_MMU_XQ0m_CPU_OPCODEf_SET(r,f) (r).mmu_xq0[1]=(((r).mmu_xq0[1] & ~((uint32_t)0xfffffff << 1)) | ((((uint32_t)f) & 0xfffffff) << 1))
#define BCM53324_A0_MMU_XQ0m_COSf_GET(r) ((((r).mmu_xq0[1]) >> 29) & 0x7)
#define BCM53324_A0_MMU_XQ0m_COSf_SET(r,f) (r).mmu_xq0[1]=(((r).mmu_xq0[1] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))
#define BCM53324_A0_MMU_XQ0m_L3_MTU_FAILEDf_GET(r) (((r).mmu_xq0[2]) & 0x1)
#define BCM53324_A0_MMU_XQ0m_L3_MTU_FAILEDf_SET(r,f) (r).mmu_xq0[2]=(((r).mmu_xq0[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ0m_NEXT_POINTERf_GET(r) ((((r).mmu_xq0[2]) >> 1) & 0x3fff)
#define BCM53324_A0_MMU_XQ0m_NEXT_POINTERf_SET(r,f) (r).mmu_xq0[2]=(((r).mmu_xq0[2] & ~((uint32_t)0x3fff << 1)) | ((((uint32_t)f) & 0x3fff) << 1))
#define BCM53324_A0_MMU_XQ0m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq0[2]) >> 1) & 0x1f)
#define BCM53324_A0_MMU_XQ0m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq0[2]=(((r).mmu_xq0[2] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM53324_A0_MMU_XQ0m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq0[2]) >> 6) & 0x1ff)
#define BCM53324_A0_MMU_XQ0m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq0[2]=(((r).mmu_xq0[2] & ~((uint32_t)0x1ff << 6)) | ((((uint32_t)f) & 0x1ff) << 6))

/*
 * These macros can be used to access MMU_XQ0.
 *
 */
#define BCM53324_A0_READ_MMU_XQ0m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ0m,i,(m._mmu_xq0),3)
#define BCM53324_A0_WRITE_MMU_XQ0m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ0m,i,&(m._mmu_xq0),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ0m BCM53324_A0_MMU_XQ0m
#define MMU_XQ0m_MIN BCM53324_A0_MMU_XQ0m_MIN
#define MMU_XQ0m_MAX BCM53324_A0_MMU_XQ0m_MAX
#define MMU_XQ0m_CMAX(u) BCM53324_A0_MMU_XQ0m_CMAX(u)
#define MMU_XQ0m_SIZE BCM53324_A0_MMU_XQ0m_SIZE
typedef BCM53324_A0_MMU_XQ0m_t MMU_XQ0m_t;
#define MMU_XQ0m_CLR BCM53324_A0_MMU_XQ0m_CLR
#define MMU_XQ0m_SET BCM53324_A0_MMU_XQ0m_SET
#define MMU_XQ0m_GET BCM53324_A0_MMU_XQ0m_GET
#define MMU_XQ0m_DATAf_GET BCM53324_A0_MMU_XQ0m_DATAf_GET
#define MMU_XQ0m_DATAf_SET BCM53324_A0_MMU_XQ0m_DATAf_SET
#define MMU_XQ0m_PARITY_0f_GET BCM53324_A0_MMU_XQ0m_PARITY_0f_GET
#define MMU_XQ0m_PARITY_0f_SET BCM53324_A0_MMU_XQ0m_PARITY_0f_SET
#define MMU_XQ0m_PARITY0_DATAf_GET BCM53324_A0_MMU_XQ0m_PARITY0_DATAf_GET
#define MMU_XQ0m_PARITY0_DATAf_SET BCM53324_A0_MMU_XQ0m_PARITY0_DATAf_SET
#define MMU_XQ0m_L2f_GET BCM53324_A0_MMU_XQ0m_L2f_GET
#define MMU_XQ0m_L2f_SET BCM53324_A0_MMU_XQ0m_L2f_SET
#define MMU_XQ0m_PURGEf_GET BCM53324_A0_MMU_XQ0m_PURGEf_GET
#define MMU_XQ0m_PURGEf_SET BCM53324_A0_MMU_XQ0m_PURGEf_SET
#define MMU_XQ0m_PKT_PTRf_GET BCM53324_A0_MMU_XQ0m_PKT_PTRf_GET
#define MMU_XQ0m_PKT_PTRf_SET BCM53324_A0_MMU_XQ0m_PKT_PTRf_SET
#define MMU_XQ0m_IMIRRORf_GET BCM53324_A0_MMU_XQ0m_IMIRRORf_GET
#define MMU_XQ0m_IMIRRORf_SET BCM53324_A0_MMU_XQ0m_IMIRRORf_SET
#define MMU_XQ0m_EMIRRORf_GET BCM53324_A0_MMU_XQ0m_EMIRRORf_GET
#define MMU_XQ0m_EMIRRORf_SET BCM53324_A0_MMU_XQ0m_EMIRRORf_SET
#define MMU_XQ0m_RESERVED_0f_GET BCM53324_A0_MMU_XQ0m_RESERVED_0f_GET
#define MMU_XQ0m_RESERVED_0f_SET BCM53324_A0_MMU_XQ0m_RESERVED_0f_SET
#define MMU_XQ0m_MATCHED_RULEf_GET BCM53324_A0_MMU_XQ0m_MATCHED_RULEf_GET
#define MMU_XQ0m_MATCHED_RULEf_SET BCM53324_A0_MMU_XQ0m_MATCHED_RULEf_SET
#define MMU_XQ0m_CPU_OPCODEf_GET BCM53324_A0_MMU_XQ0m_CPU_OPCODEf_GET
#define MMU_XQ0m_CPU_OPCODEf_SET BCM53324_A0_MMU_XQ0m_CPU_OPCODEf_SET
#define MMU_XQ0m_COSf_GET BCM53324_A0_MMU_XQ0m_COSf_GET
#define MMU_XQ0m_COSf_SET BCM53324_A0_MMU_XQ0m_COSf_SET
#define MMU_XQ0m_L3_MTU_FAILEDf_GET BCM53324_A0_MMU_XQ0m_L3_MTU_FAILEDf_GET
#define MMU_XQ0m_L3_MTU_FAILEDf_SET BCM53324_A0_MMU_XQ0m_L3_MTU_FAILEDf_SET
#define MMU_XQ0m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ0m_NEXT_POINTERf_GET
#define MMU_XQ0m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ0m_NEXT_POINTERf_SET
#define MMU_XQ0m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ0m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ0m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ0m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ0m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ0m_NEXT_XQ_POINTERf_GET
#define MMU_XQ0m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ0m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ0m BCM53324_A0_READ_MMU_XQ0m
#define WRITE_MMU_XQ0m BCM53324_A0_WRITE_MMU_XQ0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ1
 * BLOCKS:   MMU
 * DESC:     XQ1
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ1m 0x0b604000

#define BCM53324_A0_MMU_XQ1m_MIN 0
#define BCM53324_A0_MMU_XQ1m_MAX 511
#define BCM53324_A0_MMU_XQ1m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ1m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ1.
 *
 */
typedef union BCM53324_A0_MMU_XQ1m_s {
	uint32_t v[1];
	uint32_t mmu_xq1[1];
	uint32_t _mmu_xq1;
} BCM53324_A0_MMU_XQ1m_t;

#define BCM53324_A0_MMU_XQ1m_CLR(r) (r).mmu_xq1[0] = 0
#define BCM53324_A0_MMU_XQ1m_SET(r,d) (r).mmu_xq1[0] = d
#define BCM53324_A0_MMU_XQ1m_GET(r) (r).mmu_xq1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ1m_DATAf_GET(r) (((r).mmu_xq1[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ1m_DATAf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ1m_PARITY_0f_GET(r) (((r).mmu_xq1[0]) & 0x1)
#define BCM53324_A0_MMU_XQ1m_PARITY_0f_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ1m_PARITY_DATAf_GET(r) ((((r).mmu_xq1[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ1m_PARITY_DATAf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ1m_L2f_GET(r) ((((r).mmu_xq1[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ1m_L2f_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ1m_PURGEf_GET(r) ((((r).mmu_xq1[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ1m_PURGEf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ1m_PKT_PTRf_GET(r) ((((r).mmu_xq1[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ1m_PKT_PTRf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ1m_IMIRRORf_GET(r) ((((r).mmu_xq1[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ1m_IMIRRORf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ1m_EMIRRORf_GET(r) ((((r).mmu_xq1[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ1m_EMIRRORf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ1m_NEXT_POINTERf_GET(r) ((((r).mmu_xq1[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ1m_NEXT_POINTERf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ1m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq1[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ1m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ1m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq1[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ1m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq1[0]=(((r).mmu_xq1[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ1.
 *
 */
#define BCM53324_A0_READ_MMU_XQ1m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ1m,i,(m._mmu_xq1),1)
#define BCM53324_A0_WRITE_MMU_XQ1m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ1m,i,&(m._mmu_xq1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ1m BCM53324_A0_MMU_XQ1m
#define MMU_XQ1m_MIN BCM53324_A0_MMU_XQ1m_MIN
#define MMU_XQ1m_MAX BCM53324_A0_MMU_XQ1m_MAX
#define MMU_XQ1m_CMAX(u) BCM53324_A0_MMU_XQ1m_CMAX(u)
#define MMU_XQ1m_SIZE BCM53324_A0_MMU_XQ1m_SIZE
typedef BCM53324_A0_MMU_XQ1m_t MMU_XQ1m_t;
#define MMU_XQ1m_CLR BCM53324_A0_MMU_XQ1m_CLR
#define MMU_XQ1m_SET BCM53324_A0_MMU_XQ1m_SET
#define MMU_XQ1m_GET BCM53324_A0_MMU_XQ1m_GET
#define MMU_XQ1m_DATAf_GET BCM53324_A0_MMU_XQ1m_DATAf_GET
#define MMU_XQ1m_DATAf_SET BCM53324_A0_MMU_XQ1m_DATAf_SET
#define MMU_XQ1m_PARITY_0f_GET BCM53324_A0_MMU_XQ1m_PARITY_0f_GET
#define MMU_XQ1m_PARITY_0f_SET BCM53324_A0_MMU_XQ1m_PARITY_0f_SET
#define MMU_XQ1m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ1m_PARITY_DATAf_GET
#define MMU_XQ1m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ1m_PARITY_DATAf_SET
#define MMU_XQ1m_L2f_GET BCM53324_A0_MMU_XQ1m_L2f_GET
#define MMU_XQ1m_L2f_SET BCM53324_A0_MMU_XQ1m_L2f_SET
#define MMU_XQ1m_PURGEf_GET BCM53324_A0_MMU_XQ1m_PURGEf_GET
#define MMU_XQ1m_PURGEf_SET BCM53324_A0_MMU_XQ1m_PURGEf_SET
#define MMU_XQ1m_PKT_PTRf_GET BCM53324_A0_MMU_XQ1m_PKT_PTRf_GET
#define MMU_XQ1m_PKT_PTRf_SET BCM53324_A0_MMU_XQ1m_PKT_PTRf_SET
#define MMU_XQ1m_IMIRRORf_GET BCM53324_A0_MMU_XQ1m_IMIRRORf_GET
#define MMU_XQ1m_IMIRRORf_SET BCM53324_A0_MMU_XQ1m_IMIRRORf_SET
#define MMU_XQ1m_EMIRRORf_GET BCM53324_A0_MMU_XQ1m_EMIRRORf_GET
#define MMU_XQ1m_EMIRRORf_SET BCM53324_A0_MMU_XQ1m_EMIRRORf_SET
#define MMU_XQ1m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ1m_NEXT_POINTERf_GET
#define MMU_XQ1m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ1m_NEXT_POINTERf_SET
#define MMU_XQ1m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ1m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ1m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ1m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ1m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ1m_NEXT_XQ_POINTERf_GET
#define MMU_XQ1m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ1m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ1m BCM53324_A0_READ_MMU_XQ1m
#define WRITE_MMU_XQ1m BCM53324_A0_WRITE_MMU_XQ1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ10
 * BLOCKS:   MMU
 * DESC:     XQ10
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ10m 0x0b628000

#define BCM53324_A0_MMU_XQ10m_MIN 0
#define BCM53324_A0_MMU_XQ10m_MAX 511
#define BCM53324_A0_MMU_XQ10m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ10m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ10.
 *
 */
typedef union BCM53324_A0_MMU_XQ10m_s {
	uint32_t v[1];
	uint32_t mmu_xq10[1];
	uint32_t _mmu_xq10;
} BCM53324_A0_MMU_XQ10m_t;

#define BCM53324_A0_MMU_XQ10m_CLR(r) (r).mmu_xq10[0] = 0
#define BCM53324_A0_MMU_XQ10m_SET(r,d) (r).mmu_xq10[0] = d
#define BCM53324_A0_MMU_XQ10m_GET(r) (r).mmu_xq10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ10m_DATAf_GET(r) (((r).mmu_xq10[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ10m_DATAf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ10m_PARITY_0f_GET(r) (((r).mmu_xq10[0]) & 0x1)
#define BCM53324_A0_MMU_XQ10m_PARITY_0f_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ10m_PARITY_DATAf_GET(r) ((((r).mmu_xq10[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ10m_PARITY_DATAf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ10m_L2f_GET(r) ((((r).mmu_xq10[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ10m_L2f_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ10m_PURGEf_GET(r) ((((r).mmu_xq10[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ10m_PURGEf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ10m_PKT_PTRf_GET(r) ((((r).mmu_xq10[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ10m_PKT_PTRf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ10m_IMIRRORf_GET(r) ((((r).mmu_xq10[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ10m_IMIRRORf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ10m_EMIRRORf_GET(r) ((((r).mmu_xq10[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ10m_EMIRRORf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ10m_NEXT_POINTERf_GET(r) ((((r).mmu_xq10[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ10m_NEXT_POINTERf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ10m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq10[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ10m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ10m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq10[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ10m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq10[0]=(((r).mmu_xq10[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ10.
 *
 */
#define BCM53324_A0_READ_MMU_XQ10m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ10m,i,(m._mmu_xq10),1)
#define BCM53324_A0_WRITE_MMU_XQ10m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ10m,i,&(m._mmu_xq10),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ10m BCM53324_A0_MMU_XQ10m
#define MMU_XQ10m_MIN BCM53324_A0_MMU_XQ10m_MIN
#define MMU_XQ10m_MAX BCM53324_A0_MMU_XQ10m_MAX
#define MMU_XQ10m_CMAX(u) BCM53324_A0_MMU_XQ10m_CMAX(u)
#define MMU_XQ10m_SIZE BCM53324_A0_MMU_XQ10m_SIZE
typedef BCM53324_A0_MMU_XQ10m_t MMU_XQ10m_t;
#define MMU_XQ10m_CLR BCM53324_A0_MMU_XQ10m_CLR
#define MMU_XQ10m_SET BCM53324_A0_MMU_XQ10m_SET
#define MMU_XQ10m_GET BCM53324_A0_MMU_XQ10m_GET
#define MMU_XQ10m_DATAf_GET BCM53324_A0_MMU_XQ10m_DATAf_GET
#define MMU_XQ10m_DATAf_SET BCM53324_A0_MMU_XQ10m_DATAf_SET
#define MMU_XQ10m_PARITY_0f_GET BCM53324_A0_MMU_XQ10m_PARITY_0f_GET
#define MMU_XQ10m_PARITY_0f_SET BCM53324_A0_MMU_XQ10m_PARITY_0f_SET
#define MMU_XQ10m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ10m_PARITY_DATAf_GET
#define MMU_XQ10m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ10m_PARITY_DATAf_SET
#define MMU_XQ10m_L2f_GET BCM53324_A0_MMU_XQ10m_L2f_GET
#define MMU_XQ10m_L2f_SET BCM53324_A0_MMU_XQ10m_L2f_SET
#define MMU_XQ10m_PURGEf_GET BCM53324_A0_MMU_XQ10m_PURGEf_GET
#define MMU_XQ10m_PURGEf_SET BCM53324_A0_MMU_XQ10m_PURGEf_SET
#define MMU_XQ10m_PKT_PTRf_GET BCM53324_A0_MMU_XQ10m_PKT_PTRf_GET
#define MMU_XQ10m_PKT_PTRf_SET BCM53324_A0_MMU_XQ10m_PKT_PTRf_SET
#define MMU_XQ10m_IMIRRORf_GET BCM53324_A0_MMU_XQ10m_IMIRRORf_GET
#define MMU_XQ10m_IMIRRORf_SET BCM53324_A0_MMU_XQ10m_IMIRRORf_SET
#define MMU_XQ10m_EMIRRORf_GET BCM53324_A0_MMU_XQ10m_EMIRRORf_GET
#define MMU_XQ10m_EMIRRORf_SET BCM53324_A0_MMU_XQ10m_EMIRRORf_SET
#define MMU_XQ10m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ10m_NEXT_POINTERf_GET
#define MMU_XQ10m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ10m_NEXT_POINTERf_SET
#define MMU_XQ10m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ10m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ10m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ10m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ10m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ10m_NEXT_XQ_POINTERf_GET
#define MMU_XQ10m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ10m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ10m BCM53324_A0_READ_MMU_XQ10m
#define WRITE_MMU_XQ10m BCM53324_A0_WRITE_MMU_XQ10m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ10m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ11
 * BLOCKS:   MMU
 * DESC:     XQ11
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ11m 0x0b62c000

#define BCM53324_A0_MMU_XQ11m_MIN 0
#define BCM53324_A0_MMU_XQ11m_MAX 511
#define BCM53324_A0_MMU_XQ11m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ11m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ11.
 *
 */
typedef union BCM53324_A0_MMU_XQ11m_s {
	uint32_t v[1];
	uint32_t mmu_xq11[1];
	uint32_t _mmu_xq11;
} BCM53324_A0_MMU_XQ11m_t;

#define BCM53324_A0_MMU_XQ11m_CLR(r) (r).mmu_xq11[0] = 0
#define BCM53324_A0_MMU_XQ11m_SET(r,d) (r).mmu_xq11[0] = d
#define BCM53324_A0_MMU_XQ11m_GET(r) (r).mmu_xq11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ11m_DATAf_GET(r) (((r).mmu_xq11[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ11m_DATAf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ11m_PARITY_0f_GET(r) (((r).mmu_xq11[0]) & 0x1)
#define BCM53324_A0_MMU_XQ11m_PARITY_0f_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ11m_PARITY_DATAf_GET(r) ((((r).mmu_xq11[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ11m_PARITY_DATAf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ11m_L2f_GET(r) ((((r).mmu_xq11[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ11m_L2f_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ11m_PURGEf_GET(r) ((((r).mmu_xq11[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ11m_PURGEf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ11m_PKT_PTRf_GET(r) ((((r).mmu_xq11[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ11m_PKT_PTRf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ11m_IMIRRORf_GET(r) ((((r).mmu_xq11[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ11m_IMIRRORf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ11m_EMIRRORf_GET(r) ((((r).mmu_xq11[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ11m_EMIRRORf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ11m_NEXT_POINTERf_GET(r) ((((r).mmu_xq11[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ11m_NEXT_POINTERf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ11m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq11[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ11m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ11m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq11[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ11m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq11[0]=(((r).mmu_xq11[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ11.
 *
 */
#define BCM53324_A0_READ_MMU_XQ11m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ11m,i,(m._mmu_xq11),1)
#define BCM53324_A0_WRITE_MMU_XQ11m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ11m,i,&(m._mmu_xq11),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ11m BCM53324_A0_MMU_XQ11m
#define MMU_XQ11m_MIN BCM53324_A0_MMU_XQ11m_MIN
#define MMU_XQ11m_MAX BCM53324_A0_MMU_XQ11m_MAX
#define MMU_XQ11m_CMAX(u) BCM53324_A0_MMU_XQ11m_CMAX(u)
#define MMU_XQ11m_SIZE BCM53324_A0_MMU_XQ11m_SIZE
typedef BCM53324_A0_MMU_XQ11m_t MMU_XQ11m_t;
#define MMU_XQ11m_CLR BCM53324_A0_MMU_XQ11m_CLR
#define MMU_XQ11m_SET BCM53324_A0_MMU_XQ11m_SET
#define MMU_XQ11m_GET BCM53324_A0_MMU_XQ11m_GET
#define MMU_XQ11m_DATAf_GET BCM53324_A0_MMU_XQ11m_DATAf_GET
#define MMU_XQ11m_DATAf_SET BCM53324_A0_MMU_XQ11m_DATAf_SET
#define MMU_XQ11m_PARITY_0f_GET BCM53324_A0_MMU_XQ11m_PARITY_0f_GET
#define MMU_XQ11m_PARITY_0f_SET BCM53324_A0_MMU_XQ11m_PARITY_0f_SET
#define MMU_XQ11m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ11m_PARITY_DATAf_GET
#define MMU_XQ11m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ11m_PARITY_DATAf_SET
#define MMU_XQ11m_L2f_GET BCM53324_A0_MMU_XQ11m_L2f_GET
#define MMU_XQ11m_L2f_SET BCM53324_A0_MMU_XQ11m_L2f_SET
#define MMU_XQ11m_PURGEf_GET BCM53324_A0_MMU_XQ11m_PURGEf_GET
#define MMU_XQ11m_PURGEf_SET BCM53324_A0_MMU_XQ11m_PURGEf_SET
#define MMU_XQ11m_PKT_PTRf_GET BCM53324_A0_MMU_XQ11m_PKT_PTRf_GET
#define MMU_XQ11m_PKT_PTRf_SET BCM53324_A0_MMU_XQ11m_PKT_PTRf_SET
#define MMU_XQ11m_IMIRRORf_GET BCM53324_A0_MMU_XQ11m_IMIRRORf_GET
#define MMU_XQ11m_IMIRRORf_SET BCM53324_A0_MMU_XQ11m_IMIRRORf_SET
#define MMU_XQ11m_EMIRRORf_GET BCM53324_A0_MMU_XQ11m_EMIRRORf_GET
#define MMU_XQ11m_EMIRRORf_SET BCM53324_A0_MMU_XQ11m_EMIRRORf_SET
#define MMU_XQ11m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ11m_NEXT_POINTERf_GET
#define MMU_XQ11m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ11m_NEXT_POINTERf_SET
#define MMU_XQ11m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ11m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ11m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ11m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ11m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ11m_NEXT_XQ_POINTERf_GET
#define MMU_XQ11m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ11m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ11m BCM53324_A0_READ_MMU_XQ11m
#define WRITE_MMU_XQ11m BCM53324_A0_WRITE_MMU_XQ11m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ11m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ12
 * BLOCKS:   MMU
 * DESC:     XQ12
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ12m 0x0b630000

#define BCM53324_A0_MMU_XQ12m_MIN 0
#define BCM53324_A0_MMU_XQ12m_MAX 511
#define BCM53324_A0_MMU_XQ12m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ12m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ12.
 *
 */
typedef union BCM53324_A0_MMU_XQ12m_s {
	uint32_t v[1];
	uint32_t mmu_xq12[1];
	uint32_t _mmu_xq12;
} BCM53324_A0_MMU_XQ12m_t;

#define BCM53324_A0_MMU_XQ12m_CLR(r) (r).mmu_xq12[0] = 0
#define BCM53324_A0_MMU_XQ12m_SET(r,d) (r).mmu_xq12[0] = d
#define BCM53324_A0_MMU_XQ12m_GET(r) (r).mmu_xq12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ12m_DATAf_GET(r) (((r).mmu_xq12[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ12m_DATAf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ12m_PARITY_0f_GET(r) (((r).mmu_xq12[0]) & 0x1)
#define BCM53324_A0_MMU_XQ12m_PARITY_0f_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ12m_PARITY_DATAf_GET(r) ((((r).mmu_xq12[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ12m_PARITY_DATAf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ12m_L2f_GET(r) ((((r).mmu_xq12[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ12m_L2f_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ12m_PURGEf_GET(r) ((((r).mmu_xq12[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ12m_PURGEf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ12m_PKT_PTRf_GET(r) ((((r).mmu_xq12[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ12m_PKT_PTRf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ12m_IMIRRORf_GET(r) ((((r).mmu_xq12[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ12m_IMIRRORf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ12m_EMIRRORf_GET(r) ((((r).mmu_xq12[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ12m_EMIRRORf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ12m_NEXT_POINTERf_GET(r) ((((r).mmu_xq12[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ12m_NEXT_POINTERf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ12m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq12[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ12m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ12m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq12[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ12m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq12[0]=(((r).mmu_xq12[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ12.
 *
 */
#define BCM53324_A0_READ_MMU_XQ12m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ12m,i,(m._mmu_xq12),1)
#define BCM53324_A0_WRITE_MMU_XQ12m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ12m,i,&(m._mmu_xq12),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ12m BCM53324_A0_MMU_XQ12m
#define MMU_XQ12m_MIN BCM53324_A0_MMU_XQ12m_MIN
#define MMU_XQ12m_MAX BCM53324_A0_MMU_XQ12m_MAX
#define MMU_XQ12m_CMAX(u) BCM53324_A0_MMU_XQ12m_CMAX(u)
#define MMU_XQ12m_SIZE BCM53324_A0_MMU_XQ12m_SIZE
typedef BCM53324_A0_MMU_XQ12m_t MMU_XQ12m_t;
#define MMU_XQ12m_CLR BCM53324_A0_MMU_XQ12m_CLR
#define MMU_XQ12m_SET BCM53324_A0_MMU_XQ12m_SET
#define MMU_XQ12m_GET BCM53324_A0_MMU_XQ12m_GET
#define MMU_XQ12m_DATAf_GET BCM53324_A0_MMU_XQ12m_DATAf_GET
#define MMU_XQ12m_DATAf_SET BCM53324_A0_MMU_XQ12m_DATAf_SET
#define MMU_XQ12m_PARITY_0f_GET BCM53324_A0_MMU_XQ12m_PARITY_0f_GET
#define MMU_XQ12m_PARITY_0f_SET BCM53324_A0_MMU_XQ12m_PARITY_0f_SET
#define MMU_XQ12m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ12m_PARITY_DATAf_GET
#define MMU_XQ12m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ12m_PARITY_DATAf_SET
#define MMU_XQ12m_L2f_GET BCM53324_A0_MMU_XQ12m_L2f_GET
#define MMU_XQ12m_L2f_SET BCM53324_A0_MMU_XQ12m_L2f_SET
#define MMU_XQ12m_PURGEf_GET BCM53324_A0_MMU_XQ12m_PURGEf_GET
#define MMU_XQ12m_PURGEf_SET BCM53324_A0_MMU_XQ12m_PURGEf_SET
#define MMU_XQ12m_PKT_PTRf_GET BCM53324_A0_MMU_XQ12m_PKT_PTRf_GET
#define MMU_XQ12m_PKT_PTRf_SET BCM53324_A0_MMU_XQ12m_PKT_PTRf_SET
#define MMU_XQ12m_IMIRRORf_GET BCM53324_A0_MMU_XQ12m_IMIRRORf_GET
#define MMU_XQ12m_IMIRRORf_SET BCM53324_A0_MMU_XQ12m_IMIRRORf_SET
#define MMU_XQ12m_EMIRRORf_GET BCM53324_A0_MMU_XQ12m_EMIRRORf_GET
#define MMU_XQ12m_EMIRRORf_SET BCM53324_A0_MMU_XQ12m_EMIRRORf_SET
#define MMU_XQ12m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ12m_NEXT_POINTERf_GET
#define MMU_XQ12m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ12m_NEXT_POINTERf_SET
#define MMU_XQ12m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ12m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ12m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ12m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ12m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ12m_NEXT_XQ_POINTERf_GET
#define MMU_XQ12m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ12m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ12m BCM53324_A0_READ_MMU_XQ12m
#define WRITE_MMU_XQ12m BCM53324_A0_WRITE_MMU_XQ12m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ12m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ13
 * BLOCKS:   MMU
 * DESC:     XQ13
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ13m 0x0b634000

#define BCM53324_A0_MMU_XQ13m_MIN 0
#define BCM53324_A0_MMU_XQ13m_MAX 511
#define BCM53324_A0_MMU_XQ13m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ13m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ13.
 *
 */
typedef union BCM53324_A0_MMU_XQ13m_s {
	uint32_t v[1];
	uint32_t mmu_xq13[1];
	uint32_t _mmu_xq13;
} BCM53324_A0_MMU_XQ13m_t;

#define BCM53324_A0_MMU_XQ13m_CLR(r) (r).mmu_xq13[0] = 0
#define BCM53324_A0_MMU_XQ13m_SET(r,d) (r).mmu_xq13[0] = d
#define BCM53324_A0_MMU_XQ13m_GET(r) (r).mmu_xq13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ13m_DATAf_GET(r) (((r).mmu_xq13[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ13m_DATAf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ13m_PARITY_0f_GET(r) (((r).mmu_xq13[0]) & 0x1)
#define BCM53324_A0_MMU_XQ13m_PARITY_0f_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ13m_PARITY_DATAf_GET(r) ((((r).mmu_xq13[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ13m_PARITY_DATAf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ13m_L2f_GET(r) ((((r).mmu_xq13[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ13m_L2f_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ13m_PURGEf_GET(r) ((((r).mmu_xq13[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ13m_PURGEf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ13m_PKT_PTRf_GET(r) ((((r).mmu_xq13[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ13m_PKT_PTRf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ13m_IMIRRORf_GET(r) ((((r).mmu_xq13[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ13m_IMIRRORf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ13m_EMIRRORf_GET(r) ((((r).mmu_xq13[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ13m_EMIRRORf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ13m_NEXT_POINTERf_GET(r) ((((r).mmu_xq13[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ13m_NEXT_POINTERf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ13m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq13[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ13m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ13m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq13[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ13m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq13[0]=(((r).mmu_xq13[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ13.
 *
 */
#define BCM53324_A0_READ_MMU_XQ13m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ13m,i,(m._mmu_xq13),1)
#define BCM53324_A0_WRITE_MMU_XQ13m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ13m,i,&(m._mmu_xq13),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ13m BCM53324_A0_MMU_XQ13m
#define MMU_XQ13m_MIN BCM53324_A0_MMU_XQ13m_MIN
#define MMU_XQ13m_MAX BCM53324_A0_MMU_XQ13m_MAX
#define MMU_XQ13m_CMAX(u) BCM53324_A0_MMU_XQ13m_CMAX(u)
#define MMU_XQ13m_SIZE BCM53324_A0_MMU_XQ13m_SIZE
typedef BCM53324_A0_MMU_XQ13m_t MMU_XQ13m_t;
#define MMU_XQ13m_CLR BCM53324_A0_MMU_XQ13m_CLR
#define MMU_XQ13m_SET BCM53324_A0_MMU_XQ13m_SET
#define MMU_XQ13m_GET BCM53324_A0_MMU_XQ13m_GET
#define MMU_XQ13m_DATAf_GET BCM53324_A0_MMU_XQ13m_DATAf_GET
#define MMU_XQ13m_DATAf_SET BCM53324_A0_MMU_XQ13m_DATAf_SET
#define MMU_XQ13m_PARITY_0f_GET BCM53324_A0_MMU_XQ13m_PARITY_0f_GET
#define MMU_XQ13m_PARITY_0f_SET BCM53324_A0_MMU_XQ13m_PARITY_0f_SET
#define MMU_XQ13m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ13m_PARITY_DATAf_GET
#define MMU_XQ13m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ13m_PARITY_DATAf_SET
#define MMU_XQ13m_L2f_GET BCM53324_A0_MMU_XQ13m_L2f_GET
#define MMU_XQ13m_L2f_SET BCM53324_A0_MMU_XQ13m_L2f_SET
#define MMU_XQ13m_PURGEf_GET BCM53324_A0_MMU_XQ13m_PURGEf_GET
#define MMU_XQ13m_PURGEf_SET BCM53324_A0_MMU_XQ13m_PURGEf_SET
#define MMU_XQ13m_PKT_PTRf_GET BCM53324_A0_MMU_XQ13m_PKT_PTRf_GET
#define MMU_XQ13m_PKT_PTRf_SET BCM53324_A0_MMU_XQ13m_PKT_PTRf_SET
#define MMU_XQ13m_IMIRRORf_GET BCM53324_A0_MMU_XQ13m_IMIRRORf_GET
#define MMU_XQ13m_IMIRRORf_SET BCM53324_A0_MMU_XQ13m_IMIRRORf_SET
#define MMU_XQ13m_EMIRRORf_GET BCM53324_A0_MMU_XQ13m_EMIRRORf_GET
#define MMU_XQ13m_EMIRRORf_SET BCM53324_A0_MMU_XQ13m_EMIRRORf_SET
#define MMU_XQ13m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ13m_NEXT_POINTERf_GET
#define MMU_XQ13m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ13m_NEXT_POINTERf_SET
#define MMU_XQ13m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ13m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ13m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ13m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ13m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ13m_NEXT_XQ_POINTERf_GET
#define MMU_XQ13m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ13m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ13m BCM53324_A0_READ_MMU_XQ13m
#define WRITE_MMU_XQ13m BCM53324_A0_WRITE_MMU_XQ13m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ13m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ14
 * BLOCKS:   MMU
 * DESC:     XQ14
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ14m 0x0b638000

#define BCM53324_A0_MMU_XQ14m_MIN 0
#define BCM53324_A0_MMU_XQ14m_MAX 511
#define BCM53324_A0_MMU_XQ14m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ14m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ14.
 *
 */
typedef union BCM53324_A0_MMU_XQ14m_s {
	uint32_t v[1];
	uint32_t mmu_xq14[1];
	uint32_t _mmu_xq14;
} BCM53324_A0_MMU_XQ14m_t;

#define BCM53324_A0_MMU_XQ14m_CLR(r) (r).mmu_xq14[0] = 0
#define BCM53324_A0_MMU_XQ14m_SET(r,d) (r).mmu_xq14[0] = d
#define BCM53324_A0_MMU_XQ14m_GET(r) (r).mmu_xq14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ14m_DATAf_GET(r) (((r).mmu_xq14[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ14m_DATAf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ14m_PARITY_0f_GET(r) (((r).mmu_xq14[0]) & 0x1)
#define BCM53324_A0_MMU_XQ14m_PARITY_0f_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ14m_PARITY_DATAf_GET(r) ((((r).mmu_xq14[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ14m_PARITY_DATAf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ14m_L2f_GET(r) ((((r).mmu_xq14[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ14m_L2f_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ14m_PURGEf_GET(r) ((((r).mmu_xq14[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ14m_PURGEf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ14m_PKT_PTRf_GET(r) ((((r).mmu_xq14[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ14m_PKT_PTRf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ14m_IMIRRORf_GET(r) ((((r).mmu_xq14[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ14m_IMIRRORf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ14m_EMIRRORf_GET(r) ((((r).mmu_xq14[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ14m_EMIRRORf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ14m_NEXT_POINTERf_GET(r) ((((r).mmu_xq14[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ14m_NEXT_POINTERf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ14m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq14[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ14m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ14m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq14[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ14m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq14[0]=(((r).mmu_xq14[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ14.
 *
 */
#define BCM53324_A0_READ_MMU_XQ14m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ14m,i,(m._mmu_xq14),1)
#define BCM53324_A0_WRITE_MMU_XQ14m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ14m,i,&(m._mmu_xq14),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ14m BCM53324_A0_MMU_XQ14m
#define MMU_XQ14m_MIN BCM53324_A0_MMU_XQ14m_MIN
#define MMU_XQ14m_MAX BCM53324_A0_MMU_XQ14m_MAX
#define MMU_XQ14m_CMAX(u) BCM53324_A0_MMU_XQ14m_CMAX(u)
#define MMU_XQ14m_SIZE BCM53324_A0_MMU_XQ14m_SIZE
typedef BCM53324_A0_MMU_XQ14m_t MMU_XQ14m_t;
#define MMU_XQ14m_CLR BCM53324_A0_MMU_XQ14m_CLR
#define MMU_XQ14m_SET BCM53324_A0_MMU_XQ14m_SET
#define MMU_XQ14m_GET BCM53324_A0_MMU_XQ14m_GET
#define MMU_XQ14m_DATAf_GET BCM53324_A0_MMU_XQ14m_DATAf_GET
#define MMU_XQ14m_DATAf_SET BCM53324_A0_MMU_XQ14m_DATAf_SET
#define MMU_XQ14m_PARITY_0f_GET BCM53324_A0_MMU_XQ14m_PARITY_0f_GET
#define MMU_XQ14m_PARITY_0f_SET BCM53324_A0_MMU_XQ14m_PARITY_0f_SET
#define MMU_XQ14m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ14m_PARITY_DATAf_GET
#define MMU_XQ14m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ14m_PARITY_DATAf_SET
#define MMU_XQ14m_L2f_GET BCM53324_A0_MMU_XQ14m_L2f_GET
#define MMU_XQ14m_L2f_SET BCM53324_A0_MMU_XQ14m_L2f_SET
#define MMU_XQ14m_PURGEf_GET BCM53324_A0_MMU_XQ14m_PURGEf_GET
#define MMU_XQ14m_PURGEf_SET BCM53324_A0_MMU_XQ14m_PURGEf_SET
#define MMU_XQ14m_PKT_PTRf_GET BCM53324_A0_MMU_XQ14m_PKT_PTRf_GET
#define MMU_XQ14m_PKT_PTRf_SET BCM53324_A0_MMU_XQ14m_PKT_PTRf_SET
#define MMU_XQ14m_IMIRRORf_GET BCM53324_A0_MMU_XQ14m_IMIRRORf_GET
#define MMU_XQ14m_IMIRRORf_SET BCM53324_A0_MMU_XQ14m_IMIRRORf_SET
#define MMU_XQ14m_EMIRRORf_GET BCM53324_A0_MMU_XQ14m_EMIRRORf_GET
#define MMU_XQ14m_EMIRRORf_SET BCM53324_A0_MMU_XQ14m_EMIRRORf_SET
#define MMU_XQ14m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ14m_NEXT_POINTERf_GET
#define MMU_XQ14m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ14m_NEXT_POINTERf_SET
#define MMU_XQ14m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ14m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ14m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ14m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ14m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ14m_NEXT_XQ_POINTERf_GET
#define MMU_XQ14m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ14m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ14m BCM53324_A0_READ_MMU_XQ14m
#define WRITE_MMU_XQ14m BCM53324_A0_WRITE_MMU_XQ14m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ14m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ15
 * BLOCKS:   MMU
 * DESC:     XQ15
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ15m 0x0b63c000

#define BCM53324_A0_MMU_XQ15m_MIN 0
#define BCM53324_A0_MMU_XQ15m_MAX 511
#define BCM53324_A0_MMU_XQ15m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ15m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ15.
 *
 */
typedef union BCM53324_A0_MMU_XQ15m_s {
	uint32_t v[1];
	uint32_t mmu_xq15[1];
	uint32_t _mmu_xq15;
} BCM53324_A0_MMU_XQ15m_t;

#define BCM53324_A0_MMU_XQ15m_CLR(r) (r).mmu_xq15[0] = 0
#define BCM53324_A0_MMU_XQ15m_SET(r,d) (r).mmu_xq15[0] = d
#define BCM53324_A0_MMU_XQ15m_GET(r) (r).mmu_xq15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ15m_DATAf_GET(r) (((r).mmu_xq15[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ15m_DATAf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ15m_PARITY_0f_GET(r) (((r).mmu_xq15[0]) & 0x1)
#define BCM53324_A0_MMU_XQ15m_PARITY_0f_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ15m_PARITY_DATAf_GET(r) ((((r).mmu_xq15[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ15m_PARITY_DATAf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ15m_L2f_GET(r) ((((r).mmu_xq15[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ15m_L2f_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ15m_PURGEf_GET(r) ((((r).mmu_xq15[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ15m_PURGEf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ15m_PKT_PTRf_GET(r) ((((r).mmu_xq15[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ15m_PKT_PTRf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ15m_IMIRRORf_GET(r) ((((r).mmu_xq15[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ15m_IMIRRORf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ15m_EMIRRORf_GET(r) ((((r).mmu_xq15[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ15m_EMIRRORf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ15m_NEXT_POINTERf_GET(r) ((((r).mmu_xq15[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ15m_NEXT_POINTERf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ15m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq15[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ15m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ15m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq15[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ15m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq15[0]=(((r).mmu_xq15[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ15.
 *
 */
#define BCM53324_A0_READ_MMU_XQ15m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ15m,i,(m._mmu_xq15),1)
#define BCM53324_A0_WRITE_MMU_XQ15m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ15m,i,&(m._mmu_xq15),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ15m BCM53324_A0_MMU_XQ15m
#define MMU_XQ15m_MIN BCM53324_A0_MMU_XQ15m_MIN
#define MMU_XQ15m_MAX BCM53324_A0_MMU_XQ15m_MAX
#define MMU_XQ15m_CMAX(u) BCM53324_A0_MMU_XQ15m_CMAX(u)
#define MMU_XQ15m_SIZE BCM53324_A0_MMU_XQ15m_SIZE
typedef BCM53324_A0_MMU_XQ15m_t MMU_XQ15m_t;
#define MMU_XQ15m_CLR BCM53324_A0_MMU_XQ15m_CLR
#define MMU_XQ15m_SET BCM53324_A0_MMU_XQ15m_SET
#define MMU_XQ15m_GET BCM53324_A0_MMU_XQ15m_GET
#define MMU_XQ15m_DATAf_GET BCM53324_A0_MMU_XQ15m_DATAf_GET
#define MMU_XQ15m_DATAf_SET BCM53324_A0_MMU_XQ15m_DATAf_SET
#define MMU_XQ15m_PARITY_0f_GET BCM53324_A0_MMU_XQ15m_PARITY_0f_GET
#define MMU_XQ15m_PARITY_0f_SET BCM53324_A0_MMU_XQ15m_PARITY_0f_SET
#define MMU_XQ15m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ15m_PARITY_DATAf_GET
#define MMU_XQ15m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ15m_PARITY_DATAf_SET
#define MMU_XQ15m_L2f_GET BCM53324_A0_MMU_XQ15m_L2f_GET
#define MMU_XQ15m_L2f_SET BCM53324_A0_MMU_XQ15m_L2f_SET
#define MMU_XQ15m_PURGEf_GET BCM53324_A0_MMU_XQ15m_PURGEf_GET
#define MMU_XQ15m_PURGEf_SET BCM53324_A0_MMU_XQ15m_PURGEf_SET
#define MMU_XQ15m_PKT_PTRf_GET BCM53324_A0_MMU_XQ15m_PKT_PTRf_GET
#define MMU_XQ15m_PKT_PTRf_SET BCM53324_A0_MMU_XQ15m_PKT_PTRf_SET
#define MMU_XQ15m_IMIRRORf_GET BCM53324_A0_MMU_XQ15m_IMIRRORf_GET
#define MMU_XQ15m_IMIRRORf_SET BCM53324_A0_MMU_XQ15m_IMIRRORf_SET
#define MMU_XQ15m_EMIRRORf_GET BCM53324_A0_MMU_XQ15m_EMIRRORf_GET
#define MMU_XQ15m_EMIRRORf_SET BCM53324_A0_MMU_XQ15m_EMIRRORf_SET
#define MMU_XQ15m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ15m_NEXT_POINTERf_GET
#define MMU_XQ15m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ15m_NEXT_POINTERf_SET
#define MMU_XQ15m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ15m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ15m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ15m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ15m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ15m_NEXT_XQ_POINTERf_GET
#define MMU_XQ15m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ15m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ15m BCM53324_A0_READ_MMU_XQ15m
#define WRITE_MMU_XQ15m BCM53324_A0_WRITE_MMU_XQ15m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ15m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ16
 * BLOCKS:   MMU
 * DESC:     XQ16
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ16m 0x0b640000

#define BCM53324_A0_MMU_XQ16m_MIN 0
#define BCM53324_A0_MMU_XQ16m_MAX 511
#define BCM53324_A0_MMU_XQ16m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ16m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ16.
 *
 */
typedef union BCM53324_A0_MMU_XQ16m_s {
	uint32_t v[1];
	uint32_t mmu_xq16[1];
	uint32_t _mmu_xq16;
} BCM53324_A0_MMU_XQ16m_t;

#define BCM53324_A0_MMU_XQ16m_CLR(r) (r).mmu_xq16[0] = 0
#define BCM53324_A0_MMU_XQ16m_SET(r,d) (r).mmu_xq16[0] = d
#define BCM53324_A0_MMU_XQ16m_GET(r) (r).mmu_xq16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ16m_DATAf_GET(r) (((r).mmu_xq16[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ16m_DATAf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ16m_PARITY_0f_GET(r) (((r).mmu_xq16[0]) & 0x1)
#define BCM53324_A0_MMU_XQ16m_PARITY_0f_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ16m_PARITY_DATAf_GET(r) ((((r).mmu_xq16[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ16m_PARITY_DATAf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ16m_L2f_GET(r) ((((r).mmu_xq16[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ16m_L2f_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ16m_PURGEf_GET(r) ((((r).mmu_xq16[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ16m_PURGEf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ16m_PKT_PTRf_GET(r) ((((r).mmu_xq16[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ16m_PKT_PTRf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ16m_IMIRRORf_GET(r) ((((r).mmu_xq16[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ16m_IMIRRORf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ16m_EMIRRORf_GET(r) ((((r).mmu_xq16[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ16m_EMIRRORf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ16m_NEXT_POINTERf_GET(r) ((((r).mmu_xq16[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ16m_NEXT_POINTERf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ16m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq16[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ16m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ16m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq16[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ16m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq16[0]=(((r).mmu_xq16[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ16.
 *
 */
#define BCM53324_A0_READ_MMU_XQ16m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ16m,i,(m._mmu_xq16),1)
#define BCM53324_A0_WRITE_MMU_XQ16m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ16m,i,&(m._mmu_xq16),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ16m BCM53324_A0_MMU_XQ16m
#define MMU_XQ16m_MIN BCM53324_A0_MMU_XQ16m_MIN
#define MMU_XQ16m_MAX BCM53324_A0_MMU_XQ16m_MAX
#define MMU_XQ16m_CMAX(u) BCM53324_A0_MMU_XQ16m_CMAX(u)
#define MMU_XQ16m_SIZE BCM53324_A0_MMU_XQ16m_SIZE
typedef BCM53324_A0_MMU_XQ16m_t MMU_XQ16m_t;
#define MMU_XQ16m_CLR BCM53324_A0_MMU_XQ16m_CLR
#define MMU_XQ16m_SET BCM53324_A0_MMU_XQ16m_SET
#define MMU_XQ16m_GET BCM53324_A0_MMU_XQ16m_GET
#define MMU_XQ16m_DATAf_GET BCM53324_A0_MMU_XQ16m_DATAf_GET
#define MMU_XQ16m_DATAf_SET BCM53324_A0_MMU_XQ16m_DATAf_SET
#define MMU_XQ16m_PARITY_0f_GET BCM53324_A0_MMU_XQ16m_PARITY_0f_GET
#define MMU_XQ16m_PARITY_0f_SET BCM53324_A0_MMU_XQ16m_PARITY_0f_SET
#define MMU_XQ16m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ16m_PARITY_DATAf_GET
#define MMU_XQ16m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ16m_PARITY_DATAf_SET
#define MMU_XQ16m_L2f_GET BCM53324_A0_MMU_XQ16m_L2f_GET
#define MMU_XQ16m_L2f_SET BCM53324_A0_MMU_XQ16m_L2f_SET
#define MMU_XQ16m_PURGEf_GET BCM53324_A0_MMU_XQ16m_PURGEf_GET
#define MMU_XQ16m_PURGEf_SET BCM53324_A0_MMU_XQ16m_PURGEf_SET
#define MMU_XQ16m_PKT_PTRf_GET BCM53324_A0_MMU_XQ16m_PKT_PTRf_GET
#define MMU_XQ16m_PKT_PTRf_SET BCM53324_A0_MMU_XQ16m_PKT_PTRf_SET
#define MMU_XQ16m_IMIRRORf_GET BCM53324_A0_MMU_XQ16m_IMIRRORf_GET
#define MMU_XQ16m_IMIRRORf_SET BCM53324_A0_MMU_XQ16m_IMIRRORf_SET
#define MMU_XQ16m_EMIRRORf_GET BCM53324_A0_MMU_XQ16m_EMIRRORf_GET
#define MMU_XQ16m_EMIRRORf_SET BCM53324_A0_MMU_XQ16m_EMIRRORf_SET
#define MMU_XQ16m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ16m_NEXT_POINTERf_GET
#define MMU_XQ16m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ16m_NEXT_POINTERf_SET
#define MMU_XQ16m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ16m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ16m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ16m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ16m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ16m_NEXT_XQ_POINTERf_GET
#define MMU_XQ16m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ16m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ16m BCM53324_A0_READ_MMU_XQ16m
#define WRITE_MMU_XQ16m BCM53324_A0_WRITE_MMU_XQ16m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ16m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ17
 * BLOCKS:   MMU
 * DESC:     XQ17
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ17m 0x0b644000

#define BCM53324_A0_MMU_XQ17m_MIN 0
#define BCM53324_A0_MMU_XQ17m_MAX 511
#define BCM53324_A0_MMU_XQ17m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ17m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ17.
 *
 */
typedef union BCM53324_A0_MMU_XQ17m_s {
	uint32_t v[1];
	uint32_t mmu_xq17[1];
	uint32_t _mmu_xq17;
} BCM53324_A0_MMU_XQ17m_t;

#define BCM53324_A0_MMU_XQ17m_CLR(r) (r).mmu_xq17[0] = 0
#define BCM53324_A0_MMU_XQ17m_SET(r,d) (r).mmu_xq17[0] = d
#define BCM53324_A0_MMU_XQ17m_GET(r) (r).mmu_xq17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ17m_DATAf_GET(r) (((r).mmu_xq17[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ17m_DATAf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ17m_PARITY_0f_GET(r) (((r).mmu_xq17[0]) & 0x1)
#define BCM53324_A0_MMU_XQ17m_PARITY_0f_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ17m_PARITY_DATAf_GET(r) ((((r).mmu_xq17[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ17m_PARITY_DATAf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ17m_L2f_GET(r) ((((r).mmu_xq17[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ17m_L2f_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ17m_PURGEf_GET(r) ((((r).mmu_xq17[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ17m_PURGEf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ17m_PKT_PTRf_GET(r) ((((r).mmu_xq17[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ17m_PKT_PTRf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ17m_IMIRRORf_GET(r) ((((r).mmu_xq17[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ17m_IMIRRORf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ17m_EMIRRORf_GET(r) ((((r).mmu_xq17[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ17m_EMIRRORf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ17m_NEXT_POINTERf_GET(r) ((((r).mmu_xq17[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ17m_NEXT_POINTERf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ17m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq17[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ17m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ17m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq17[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ17m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq17[0]=(((r).mmu_xq17[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ17.
 *
 */
#define BCM53324_A0_READ_MMU_XQ17m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ17m,i,(m._mmu_xq17),1)
#define BCM53324_A0_WRITE_MMU_XQ17m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ17m,i,&(m._mmu_xq17),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ17m BCM53324_A0_MMU_XQ17m
#define MMU_XQ17m_MIN BCM53324_A0_MMU_XQ17m_MIN
#define MMU_XQ17m_MAX BCM53324_A0_MMU_XQ17m_MAX
#define MMU_XQ17m_CMAX(u) BCM53324_A0_MMU_XQ17m_CMAX(u)
#define MMU_XQ17m_SIZE BCM53324_A0_MMU_XQ17m_SIZE
typedef BCM53324_A0_MMU_XQ17m_t MMU_XQ17m_t;
#define MMU_XQ17m_CLR BCM53324_A0_MMU_XQ17m_CLR
#define MMU_XQ17m_SET BCM53324_A0_MMU_XQ17m_SET
#define MMU_XQ17m_GET BCM53324_A0_MMU_XQ17m_GET
#define MMU_XQ17m_DATAf_GET BCM53324_A0_MMU_XQ17m_DATAf_GET
#define MMU_XQ17m_DATAf_SET BCM53324_A0_MMU_XQ17m_DATAf_SET
#define MMU_XQ17m_PARITY_0f_GET BCM53324_A0_MMU_XQ17m_PARITY_0f_GET
#define MMU_XQ17m_PARITY_0f_SET BCM53324_A0_MMU_XQ17m_PARITY_0f_SET
#define MMU_XQ17m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ17m_PARITY_DATAf_GET
#define MMU_XQ17m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ17m_PARITY_DATAf_SET
#define MMU_XQ17m_L2f_GET BCM53324_A0_MMU_XQ17m_L2f_GET
#define MMU_XQ17m_L2f_SET BCM53324_A0_MMU_XQ17m_L2f_SET
#define MMU_XQ17m_PURGEf_GET BCM53324_A0_MMU_XQ17m_PURGEf_GET
#define MMU_XQ17m_PURGEf_SET BCM53324_A0_MMU_XQ17m_PURGEf_SET
#define MMU_XQ17m_PKT_PTRf_GET BCM53324_A0_MMU_XQ17m_PKT_PTRf_GET
#define MMU_XQ17m_PKT_PTRf_SET BCM53324_A0_MMU_XQ17m_PKT_PTRf_SET
#define MMU_XQ17m_IMIRRORf_GET BCM53324_A0_MMU_XQ17m_IMIRRORf_GET
#define MMU_XQ17m_IMIRRORf_SET BCM53324_A0_MMU_XQ17m_IMIRRORf_SET
#define MMU_XQ17m_EMIRRORf_GET BCM53324_A0_MMU_XQ17m_EMIRRORf_GET
#define MMU_XQ17m_EMIRRORf_SET BCM53324_A0_MMU_XQ17m_EMIRRORf_SET
#define MMU_XQ17m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ17m_NEXT_POINTERf_GET
#define MMU_XQ17m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ17m_NEXT_POINTERf_SET
#define MMU_XQ17m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ17m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ17m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ17m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ17m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ17m_NEXT_XQ_POINTERf_GET
#define MMU_XQ17m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ17m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ17m BCM53324_A0_READ_MMU_XQ17m
#define WRITE_MMU_XQ17m BCM53324_A0_WRITE_MMU_XQ17m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ17m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ18
 * BLOCKS:   MMU
 * DESC:     XQ18
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ18m 0x0b648000

#define BCM53324_A0_MMU_XQ18m_MIN 0
#define BCM53324_A0_MMU_XQ18m_MAX 511
#define BCM53324_A0_MMU_XQ18m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ18m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ18.
 *
 */
typedef union BCM53324_A0_MMU_XQ18m_s {
	uint32_t v[1];
	uint32_t mmu_xq18[1];
	uint32_t _mmu_xq18;
} BCM53324_A0_MMU_XQ18m_t;

#define BCM53324_A0_MMU_XQ18m_CLR(r) (r).mmu_xq18[0] = 0
#define BCM53324_A0_MMU_XQ18m_SET(r,d) (r).mmu_xq18[0] = d
#define BCM53324_A0_MMU_XQ18m_GET(r) (r).mmu_xq18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ18m_DATAf_GET(r) (((r).mmu_xq18[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ18m_DATAf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ18m_PARITY_0f_GET(r) (((r).mmu_xq18[0]) & 0x1)
#define BCM53324_A0_MMU_XQ18m_PARITY_0f_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ18m_PARITY_DATAf_GET(r) ((((r).mmu_xq18[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ18m_PARITY_DATAf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ18m_L2f_GET(r) ((((r).mmu_xq18[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ18m_L2f_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ18m_PURGEf_GET(r) ((((r).mmu_xq18[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ18m_PURGEf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ18m_PKT_PTRf_GET(r) ((((r).mmu_xq18[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ18m_PKT_PTRf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ18m_IMIRRORf_GET(r) ((((r).mmu_xq18[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ18m_IMIRRORf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ18m_EMIRRORf_GET(r) ((((r).mmu_xq18[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ18m_EMIRRORf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ18m_NEXT_POINTERf_GET(r) ((((r).mmu_xq18[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ18m_NEXT_POINTERf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ18m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq18[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ18m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ18m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq18[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ18m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq18[0]=(((r).mmu_xq18[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ18.
 *
 */
#define BCM53324_A0_READ_MMU_XQ18m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ18m,i,(m._mmu_xq18),1)
#define BCM53324_A0_WRITE_MMU_XQ18m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ18m,i,&(m._mmu_xq18),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ18m BCM53324_A0_MMU_XQ18m
#define MMU_XQ18m_MIN BCM53324_A0_MMU_XQ18m_MIN
#define MMU_XQ18m_MAX BCM53324_A0_MMU_XQ18m_MAX
#define MMU_XQ18m_CMAX(u) BCM53324_A0_MMU_XQ18m_CMAX(u)
#define MMU_XQ18m_SIZE BCM53324_A0_MMU_XQ18m_SIZE
typedef BCM53324_A0_MMU_XQ18m_t MMU_XQ18m_t;
#define MMU_XQ18m_CLR BCM53324_A0_MMU_XQ18m_CLR
#define MMU_XQ18m_SET BCM53324_A0_MMU_XQ18m_SET
#define MMU_XQ18m_GET BCM53324_A0_MMU_XQ18m_GET
#define MMU_XQ18m_DATAf_GET BCM53324_A0_MMU_XQ18m_DATAf_GET
#define MMU_XQ18m_DATAf_SET BCM53324_A0_MMU_XQ18m_DATAf_SET
#define MMU_XQ18m_PARITY_0f_GET BCM53324_A0_MMU_XQ18m_PARITY_0f_GET
#define MMU_XQ18m_PARITY_0f_SET BCM53324_A0_MMU_XQ18m_PARITY_0f_SET
#define MMU_XQ18m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ18m_PARITY_DATAf_GET
#define MMU_XQ18m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ18m_PARITY_DATAf_SET
#define MMU_XQ18m_L2f_GET BCM53324_A0_MMU_XQ18m_L2f_GET
#define MMU_XQ18m_L2f_SET BCM53324_A0_MMU_XQ18m_L2f_SET
#define MMU_XQ18m_PURGEf_GET BCM53324_A0_MMU_XQ18m_PURGEf_GET
#define MMU_XQ18m_PURGEf_SET BCM53324_A0_MMU_XQ18m_PURGEf_SET
#define MMU_XQ18m_PKT_PTRf_GET BCM53324_A0_MMU_XQ18m_PKT_PTRf_GET
#define MMU_XQ18m_PKT_PTRf_SET BCM53324_A0_MMU_XQ18m_PKT_PTRf_SET
#define MMU_XQ18m_IMIRRORf_GET BCM53324_A0_MMU_XQ18m_IMIRRORf_GET
#define MMU_XQ18m_IMIRRORf_SET BCM53324_A0_MMU_XQ18m_IMIRRORf_SET
#define MMU_XQ18m_EMIRRORf_GET BCM53324_A0_MMU_XQ18m_EMIRRORf_GET
#define MMU_XQ18m_EMIRRORf_SET BCM53324_A0_MMU_XQ18m_EMIRRORf_SET
#define MMU_XQ18m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ18m_NEXT_POINTERf_GET
#define MMU_XQ18m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ18m_NEXT_POINTERf_SET
#define MMU_XQ18m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ18m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ18m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ18m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ18m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ18m_NEXT_XQ_POINTERf_GET
#define MMU_XQ18m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ18m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ18m BCM53324_A0_READ_MMU_XQ18m
#define WRITE_MMU_XQ18m BCM53324_A0_WRITE_MMU_XQ18m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ18m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ19
 * BLOCKS:   MMU
 * DESC:     XQ19
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ19m 0x0b64c000

#define BCM53324_A0_MMU_XQ19m_MIN 0
#define BCM53324_A0_MMU_XQ19m_MAX 511
#define BCM53324_A0_MMU_XQ19m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ19m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ19.
 *
 */
typedef union BCM53324_A0_MMU_XQ19m_s {
	uint32_t v[1];
	uint32_t mmu_xq19[1];
	uint32_t _mmu_xq19;
} BCM53324_A0_MMU_XQ19m_t;

#define BCM53324_A0_MMU_XQ19m_CLR(r) (r).mmu_xq19[0] = 0
#define BCM53324_A0_MMU_XQ19m_SET(r,d) (r).mmu_xq19[0] = d
#define BCM53324_A0_MMU_XQ19m_GET(r) (r).mmu_xq19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ19m_DATAf_GET(r) (((r).mmu_xq19[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ19m_DATAf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ19m_PARITY_0f_GET(r) (((r).mmu_xq19[0]) & 0x1)
#define BCM53324_A0_MMU_XQ19m_PARITY_0f_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ19m_PARITY_DATAf_GET(r) ((((r).mmu_xq19[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ19m_PARITY_DATAf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ19m_L2f_GET(r) ((((r).mmu_xq19[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ19m_L2f_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ19m_PURGEf_GET(r) ((((r).mmu_xq19[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ19m_PURGEf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ19m_PKT_PTRf_GET(r) ((((r).mmu_xq19[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ19m_PKT_PTRf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ19m_IMIRRORf_GET(r) ((((r).mmu_xq19[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ19m_IMIRRORf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ19m_EMIRRORf_GET(r) ((((r).mmu_xq19[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ19m_EMIRRORf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ19m_NEXT_POINTERf_GET(r) ((((r).mmu_xq19[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ19m_NEXT_POINTERf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ19m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq19[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ19m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ19m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq19[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ19m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq19[0]=(((r).mmu_xq19[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ19.
 *
 */
#define BCM53324_A0_READ_MMU_XQ19m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ19m,i,(m._mmu_xq19),1)
#define BCM53324_A0_WRITE_MMU_XQ19m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ19m,i,&(m._mmu_xq19),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ19m BCM53324_A0_MMU_XQ19m
#define MMU_XQ19m_MIN BCM53324_A0_MMU_XQ19m_MIN
#define MMU_XQ19m_MAX BCM53324_A0_MMU_XQ19m_MAX
#define MMU_XQ19m_CMAX(u) BCM53324_A0_MMU_XQ19m_CMAX(u)
#define MMU_XQ19m_SIZE BCM53324_A0_MMU_XQ19m_SIZE
typedef BCM53324_A0_MMU_XQ19m_t MMU_XQ19m_t;
#define MMU_XQ19m_CLR BCM53324_A0_MMU_XQ19m_CLR
#define MMU_XQ19m_SET BCM53324_A0_MMU_XQ19m_SET
#define MMU_XQ19m_GET BCM53324_A0_MMU_XQ19m_GET
#define MMU_XQ19m_DATAf_GET BCM53324_A0_MMU_XQ19m_DATAf_GET
#define MMU_XQ19m_DATAf_SET BCM53324_A0_MMU_XQ19m_DATAf_SET
#define MMU_XQ19m_PARITY_0f_GET BCM53324_A0_MMU_XQ19m_PARITY_0f_GET
#define MMU_XQ19m_PARITY_0f_SET BCM53324_A0_MMU_XQ19m_PARITY_0f_SET
#define MMU_XQ19m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ19m_PARITY_DATAf_GET
#define MMU_XQ19m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ19m_PARITY_DATAf_SET
#define MMU_XQ19m_L2f_GET BCM53324_A0_MMU_XQ19m_L2f_GET
#define MMU_XQ19m_L2f_SET BCM53324_A0_MMU_XQ19m_L2f_SET
#define MMU_XQ19m_PURGEf_GET BCM53324_A0_MMU_XQ19m_PURGEf_GET
#define MMU_XQ19m_PURGEf_SET BCM53324_A0_MMU_XQ19m_PURGEf_SET
#define MMU_XQ19m_PKT_PTRf_GET BCM53324_A0_MMU_XQ19m_PKT_PTRf_GET
#define MMU_XQ19m_PKT_PTRf_SET BCM53324_A0_MMU_XQ19m_PKT_PTRf_SET
#define MMU_XQ19m_IMIRRORf_GET BCM53324_A0_MMU_XQ19m_IMIRRORf_GET
#define MMU_XQ19m_IMIRRORf_SET BCM53324_A0_MMU_XQ19m_IMIRRORf_SET
#define MMU_XQ19m_EMIRRORf_GET BCM53324_A0_MMU_XQ19m_EMIRRORf_GET
#define MMU_XQ19m_EMIRRORf_SET BCM53324_A0_MMU_XQ19m_EMIRRORf_SET
#define MMU_XQ19m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ19m_NEXT_POINTERf_GET
#define MMU_XQ19m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ19m_NEXT_POINTERf_SET
#define MMU_XQ19m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ19m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ19m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ19m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ19m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ19m_NEXT_XQ_POINTERf_GET
#define MMU_XQ19m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ19m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ19m BCM53324_A0_READ_MMU_XQ19m
#define WRITE_MMU_XQ19m BCM53324_A0_WRITE_MMU_XQ19m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ19m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ2
 * BLOCKS:   MMU
 * DESC:     XQ2
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ2m 0x0b608000

#define BCM53324_A0_MMU_XQ2m_MIN 0
#define BCM53324_A0_MMU_XQ2m_MAX 511
#define BCM53324_A0_MMU_XQ2m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ2m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ2.
 *
 */
typedef union BCM53324_A0_MMU_XQ2m_s {
	uint32_t v[1];
	uint32_t mmu_xq2[1];
	uint32_t _mmu_xq2;
} BCM53324_A0_MMU_XQ2m_t;

#define BCM53324_A0_MMU_XQ2m_CLR(r) (r).mmu_xq2[0] = 0
#define BCM53324_A0_MMU_XQ2m_SET(r,d) (r).mmu_xq2[0] = d
#define BCM53324_A0_MMU_XQ2m_GET(r) (r).mmu_xq2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ2m_DATAf_GET(r) (((r).mmu_xq2[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ2m_DATAf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ2m_PARITY_0f_GET(r) (((r).mmu_xq2[0]) & 0x1)
#define BCM53324_A0_MMU_XQ2m_PARITY_0f_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ2m_PARITY_DATAf_GET(r) ((((r).mmu_xq2[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ2m_PARITY_DATAf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ2m_L2f_GET(r) ((((r).mmu_xq2[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ2m_L2f_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ2m_PURGEf_GET(r) ((((r).mmu_xq2[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ2m_PURGEf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ2m_PKT_PTRf_GET(r) ((((r).mmu_xq2[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ2m_PKT_PTRf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ2m_IMIRRORf_GET(r) ((((r).mmu_xq2[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ2m_IMIRRORf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ2m_EMIRRORf_GET(r) ((((r).mmu_xq2[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ2m_EMIRRORf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ2m_NEXT_POINTERf_GET(r) ((((r).mmu_xq2[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ2m_NEXT_POINTERf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ2m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq2[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ2m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ2m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq2[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ2m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq2[0]=(((r).mmu_xq2[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ2.
 *
 */
#define BCM53324_A0_READ_MMU_XQ2m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ2m,i,(m._mmu_xq2),1)
#define BCM53324_A0_WRITE_MMU_XQ2m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ2m,i,&(m._mmu_xq2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ2m BCM53324_A0_MMU_XQ2m
#define MMU_XQ2m_MIN BCM53324_A0_MMU_XQ2m_MIN
#define MMU_XQ2m_MAX BCM53324_A0_MMU_XQ2m_MAX
#define MMU_XQ2m_CMAX(u) BCM53324_A0_MMU_XQ2m_CMAX(u)
#define MMU_XQ2m_SIZE BCM53324_A0_MMU_XQ2m_SIZE
typedef BCM53324_A0_MMU_XQ2m_t MMU_XQ2m_t;
#define MMU_XQ2m_CLR BCM53324_A0_MMU_XQ2m_CLR
#define MMU_XQ2m_SET BCM53324_A0_MMU_XQ2m_SET
#define MMU_XQ2m_GET BCM53324_A0_MMU_XQ2m_GET
#define MMU_XQ2m_DATAf_GET BCM53324_A0_MMU_XQ2m_DATAf_GET
#define MMU_XQ2m_DATAf_SET BCM53324_A0_MMU_XQ2m_DATAf_SET
#define MMU_XQ2m_PARITY_0f_GET BCM53324_A0_MMU_XQ2m_PARITY_0f_GET
#define MMU_XQ2m_PARITY_0f_SET BCM53324_A0_MMU_XQ2m_PARITY_0f_SET
#define MMU_XQ2m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ2m_PARITY_DATAf_GET
#define MMU_XQ2m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ2m_PARITY_DATAf_SET
#define MMU_XQ2m_L2f_GET BCM53324_A0_MMU_XQ2m_L2f_GET
#define MMU_XQ2m_L2f_SET BCM53324_A0_MMU_XQ2m_L2f_SET
#define MMU_XQ2m_PURGEf_GET BCM53324_A0_MMU_XQ2m_PURGEf_GET
#define MMU_XQ2m_PURGEf_SET BCM53324_A0_MMU_XQ2m_PURGEf_SET
#define MMU_XQ2m_PKT_PTRf_GET BCM53324_A0_MMU_XQ2m_PKT_PTRf_GET
#define MMU_XQ2m_PKT_PTRf_SET BCM53324_A0_MMU_XQ2m_PKT_PTRf_SET
#define MMU_XQ2m_IMIRRORf_GET BCM53324_A0_MMU_XQ2m_IMIRRORf_GET
#define MMU_XQ2m_IMIRRORf_SET BCM53324_A0_MMU_XQ2m_IMIRRORf_SET
#define MMU_XQ2m_EMIRRORf_GET BCM53324_A0_MMU_XQ2m_EMIRRORf_GET
#define MMU_XQ2m_EMIRRORf_SET BCM53324_A0_MMU_XQ2m_EMIRRORf_SET
#define MMU_XQ2m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ2m_NEXT_POINTERf_GET
#define MMU_XQ2m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ2m_NEXT_POINTERf_SET
#define MMU_XQ2m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ2m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ2m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ2m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ2m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ2m_NEXT_XQ_POINTERf_GET
#define MMU_XQ2m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ2m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ2m BCM53324_A0_READ_MMU_XQ2m
#define WRITE_MMU_XQ2m BCM53324_A0_WRITE_MMU_XQ2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ20
 * BLOCKS:   MMU
 * DESC:     XQ20
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ20m 0x0b650000

#define BCM53324_A0_MMU_XQ20m_MIN 0
#define BCM53324_A0_MMU_XQ20m_MAX 511
#define BCM53324_A0_MMU_XQ20m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ20m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ20.
 *
 */
typedef union BCM53324_A0_MMU_XQ20m_s {
	uint32_t v[1];
	uint32_t mmu_xq20[1];
	uint32_t _mmu_xq20;
} BCM53324_A0_MMU_XQ20m_t;

#define BCM53324_A0_MMU_XQ20m_CLR(r) (r).mmu_xq20[0] = 0
#define BCM53324_A0_MMU_XQ20m_SET(r,d) (r).mmu_xq20[0] = d
#define BCM53324_A0_MMU_XQ20m_GET(r) (r).mmu_xq20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ20m_DATAf_GET(r) (((r).mmu_xq20[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ20m_DATAf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ20m_PARITY_0f_GET(r) (((r).mmu_xq20[0]) & 0x1)
#define BCM53324_A0_MMU_XQ20m_PARITY_0f_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ20m_PARITY_DATAf_GET(r) ((((r).mmu_xq20[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ20m_PARITY_DATAf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ20m_L2f_GET(r) ((((r).mmu_xq20[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ20m_L2f_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ20m_PURGEf_GET(r) ((((r).mmu_xq20[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ20m_PURGEf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ20m_PKT_PTRf_GET(r) ((((r).mmu_xq20[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ20m_PKT_PTRf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ20m_IMIRRORf_GET(r) ((((r).mmu_xq20[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ20m_IMIRRORf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ20m_EMIRRORf_GET(r) ((((r).mmu_xq20[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ20m_EMIRRORf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ20m_NEXT_POINTERf_GET(r) ((((r).mmu_xq20[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ20m_NEXT_POINTERf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ20m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq20[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ20m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ20m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq20[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ20m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq20[0]=(((r).mmu_xq20[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ20.
 *
 */
#define BCM53324_A0_READ_MMU_XQ20m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ20m,i,(m._mmu_xq20),1)
#define BCM53324_A0_WRITE_MMU_XQ20m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ20m,i,&(m._mmu_xq20),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ20m BCM53324_A0_MMU_XQ20m
#define MMU_XQ20m_MIN BCM53324_A0_MMU_XQ20m_MIN
#define MMU_XQ20m_MAX BCM53324_A0_MMU_XQ20m_MAX
#define MMU_XQ20m_CMAX(u) BCM53324_A0_MMU_XQ20m_CMAX(u)
#define MMU_XQ20m_SIZE BCM53324_A0_MMU_XQ20m_SIZE
typedef BCM53324_A0_MMU_XQ20m_t MMU_XQ20m_t;
#define MMU_XQ20m_CLR BCM53324_A0_MMU_XQ20m_CLR
#define MMU_XQ20m_SET BCM53324_A0_MMU_XQ20m_SET
#define MMU_XQ20m_GET BCM53324_A0_MMU_XQ20m_GET
#define MMU_XQ20m_DATAf_GET BCM53324_A0_MMU_XQ20m_DATAf_GET
#define MMU_XQ20m_DATAf_SET BCM53324_A0_MMU_XQ20m_DATAf_SET
#define MMU_XQ20m_PARITY_0f_GET BCM53324_A0_MMU_XQ20m_PARITY_0f_GET
#define MMU_XQ20m_PARITY_0f_SET BCM53324_A0_MMU_XQ20m_PARITY_0f_SET
#define MMU_XQ20m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ20m_PARITY_DATAf_GET
#define MMU_XQ20m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ20m_PARITY_DATAf_SET
#define MMU_XQ20m_L2f_GET BCM53324_A0_MMU_XQ20m_L2f_GET
#define MMU_XQ20m_L2f_SET BCM53324_A0_MMU_XQ20m_L2f_SET
#define MMU_XQ20m_PURGEf_GET BCM53324_A0_MMU_XQ20m_PURGEf_GET
#define MMU_XQ20m_PURGEf_SET BCM53324_A0_MMU_XQ20m_PURGEf_SET
#define MMU_XQ20m_PKT_PTRf_GET BCM53324_A0_MMU_XQ20m_PKT_PTRf_GET
#define MMU_XQ20m_PKT_PTRf_SET BCM53324_A0_MMU_XQ20m_PKT_PTRf_SET
#define MMU_XQ20m_IMIRRORf_GET BCM53324_A0_MMU_XQ20m_IMIRRORf_GET
#define MMU_XQ20m_IMIRRORf_SET BCM53324_A0_MMU_XQ20m_IMIRRORf_SET
#define MMU_XQ20m_EMIRRORf_GET BCM53324_A0_MMU_XQ20m_EMIRRORf_GET
#define MMU_XQ20m_EMIRRORf_SET BCM53324_A0_MMU_XQ20m_EMIRRORf_SET
#define MMU_XQ20m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ20m_NEXT_POINTERf_GET
#define MMU_XQ20m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ20m_NEXT_POINTERf_SET
#define MMU_XQ20m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ20m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ20m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ20m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ20m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ20m_NEXT_XQ_POINTERf_GET
#define MMU_XQ20m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ20m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ20m BCM53324_A0_READ_MMU_XQ20m
#define WRITE_MMU_XQ20m BCM53324_A0_WRITE_MMU_XQ20m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ20m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ21
 * BLOCKS:   MMU
 * DESC:     XQ21
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ21m 0x0b654000

#define BCM53324_A0_MMU_XQ21m_MIN 0
#define BCM53324_A0_MMU_XQ21m_MAX 511
#define BCM53324_A0_MMU_XQ21m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ21m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ21.
 *
 */
typedef union BCM53324_A0_MMU_XQ21m_s {
	uint32_t v[1];
	uint32_t mmu_xq21[1];
	uint32_t _mmu_xq21;
} BCM53324_A0_MMU_XQ21m_t;

#define BCM53324_A0_MMU_XQ21m_CLR(r) (r).mmu_xq21[0] = 0
#define BCM53324_A0_MMU_XQ21m_SET(r,d) (r).mmu_xq21[0] = d
#define BCM53324_A0_MMU_XQ21m_GET(r) (r).mmu_xq21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ21m_DATAf_GET(r) (((r).mmu_xq21[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ21m_DATAf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ21m_PARITY_0f_GET(r) (((r).mmu_xq21[0]) & 0x1)
#define BCM53324_A0_MMU_XQ21m_PARITY_0f_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ21m_PARITY_DATAf_GET(r) ((((r).mmu_xq21[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ21m_PARITY_DATAf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ21m_L2f_GET(r) ((((r).mmu_xq21[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ21m_L2f_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ21m_PURGEf_GET(r) ((((r).mmu_xq21[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ21m_PURGEf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ21m_PKT_PTRf_GET(r) ((((r).mmu_xq21[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ21m_PKT_PTRf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ21m_IMIRRORf_GET(r) ((((r).mmu_xq21[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ21m_IMIRRORf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ21m_EMIRRORf_GET(r) ((((r).mmu_xq21[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ21m_EMIRRORf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ21m_NEXT_POINTERf_GET(r) ((((r).mmu_xq21[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ21m_NEXT_POINTERf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ21m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq21[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ21m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ21m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq21[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ21m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq21[0]=(((r).mmu_xq21[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ21.
 *
 */
#define BCM53324_A0_READ_MMU_XQ21m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ21m,i,(m._mmu_xq21),1)
#define BCM53324_A0_WRITE_MMU_XQ21m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ21m,i,&(m._mmu_xq21),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ21m BCM53324_A0_MMU_XQ21m
#define MMU_XQ21m_MIN BCM53324_A0_MMU_XQ21m_MIN
#define MMU_XQ21m_MAX BCM53324_A0_MMU_XQ21m_MAX
#define MMU_XQ21m_CMAX(u) BCM53324_A0_MMU_XQ21m_CMAX(u)
#define MMU_XQ21m_SIZE BCM53324_A0_MMU_XQ21m_SIZE
typedef BCM53324_A0_MMU_XQ21m_t MMU_XQ21m_t;
#define MMU_XQ21m_CLR BCM53324_A0_MMU_XQ21m_CLR
#define MMU_XQ21m_SET BCM53324_A0_MMU_XQ21m_SET
#define MMU_XQ21m_GET BCM53324_A0_MMU_XQ21m_GET
#define MMU_XQ21m_DATAf_GET BCM53324_A0_MMU_XQ21m_DATAf_GET
#define MMU_XQ21m_DATAf_SET BCM53324_A0_MMU_XQ21m_DATAf_SET
#define MMU_XQ21m_PARITY_0f_GET BCM53324_A0_MMU_XQ21m_PARITY_0f_GET
#define MMU_XQ21m_PARITY_0f_SET BCM53324_A0_MMU_XQ21m_PARITY_0f_SET
#define MMU_XQ21m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ21m_PARITY_DATAf_GET
#define MMU_XQ21m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ21m_PARITY_DATAf_SET
#define MMU_XQ21m_L2f_GET BCM53324_A0_MMU_XQ21m_L2f_GET
#define MMU_XQ21m_L2f_SET BCM53324_A0_MMU_XQ21m_L2f_SET
#define MMU_XQ21m_PURGEf_GET BCM53324_A0_MMU_XQ21m_PURGEf_GET
#define MMU_XQ21m_PURGEf_SET BCM53324_A0_MMU_XQ21m_PURGEf_SET
#define MMU_XQ21m_PKT_PTRf_GET BCM53324_A0_MMU_XQ21m_PKT_PTRf_GET
#define MMU_XQ21m_PKT_PTRf_SET BCM53324_A0_MMU_XQ21m_PKT_PTRf_SET
#define MMU_XQ21m_IMIRRORf_GET BCM53324_A0_MMU_XQ21m_IMIRRORf_GET
#define MMU_XQ21m_IMIRRORf_SET BCM53324_A0_MMU_XQ21m_IMIRRORf_SET
#define MMU_XQ21m_EMIRRORf_GET BCM53324_A0_MMU_XQ21m_EMIRRORf_GET
#define MMU_XQ21m_EMIRRORf_SET BCM53324_A0_MMU_XQ21m_EMIRRORf_SET
#define MMU_XQ21m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ21m_NEXT_POINTERf_GET
#define MMU_XQ21m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ21m_NEXT_POINTERf_SET
#define MMU_XQ21m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ21m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ21m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ21m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ21m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ21m_NEXT_XQ_POINTERf_GET
#define MMU_XQ21m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ21m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ21m BCM53324_A0_READ_MMU_XQ21m
#define WRITE_MMU_XQ21m BCM53324_A0_WRITE_MMU_XQ21m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ21m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ22
 * BLOCKS:   MMU
 * DESC:     XQ22
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ22m 0x0b658000

#define BCM53324_A0_MMU_XQ22m_MIN 0
#define BCM53324_A0_MMU_XQ22m_MAX 511
#define BCM53324_A0_MMU_XQ22m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ22m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ22.
 *
 */
typedef union BCM53324_A0_MMU_XQ22m_s {
	uint32_t v[1];
	uint32_t mmu_xq22[1];
	uint32_t _mmu_xq22;
} BCM53324_A0_MMU_XQ22m_t;

#define BCM53324_A0_MMU_XQ22m_CLR(r) (r).mmu_xq22[0] = 0
#define BCM53324_A0_MMU_XQ22m_SET(r,d) (r).mmu_xq22[0] = d
#define BCM53324_A0_MMU_XQ22m_GET(r) (r).mmu_xq22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ22m_DATAf_GET(r) (((r).mmu_xq22[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ22m_DATAf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ22m_PARITY_0f_GET(r) (((r).mmu_xq22[0]) & 0x1)
#define BCM53324_A0_MMU_XQ22m_PARITY_0f_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ22m_PARITY_DATAf_GET(r) ((((r).mmu_xq22[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ22m_PARITY_DATAf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ22m_L2f_GET(r) ((((r).mmu_xq22[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ22m_L2f_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ22m_PURGEf_GET(r) ((((r).mmu_xq22[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ22m_PURGEf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ22m_PKT_PTRf_GET(r) ((((r).mmu_xq22[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ22m_PKT_PTRf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ22m_IMIRRORf_GET(r) ((((r).mmu_xq22[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ22m_IMIRRORf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ22m_EMIRRORf_GET(r) ((((r).mmu_xq22[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ22m_EMIRRORf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ22m_NEXT_POINTERf_GET(r) ((((r).mmu_xq22[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ22m_NEXT_POINTERf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ22m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq22[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ22m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ22m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq22[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ22m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq22[0]=(((r).mmu_xq22[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ22.
 *
 */
#define BCM53324_A0_READ_MMU_XQ22m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ22m,i,(m._mmu_xq22),1)
#define BCM53324_A0_WRITE_MMU_XQ22m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ22m,i,&(m._mmu_xq22),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ22m BCM53324_A0_MMU_XQ22m
#define MMU_XQ22m_MIN BCM53324_A0_MMU_XQ22m_MIN
#define MMU_XQ22m_MAX BCM53324_A0_MMU_XQ22m_MAX
#define MMU_XQ22m_CMAX(u) BCM53324_A0_MMU_XQ22m_CMAX(u)
#define MMU_XQ22m_SIZE BCM53324_A0_MMU_XQ22m_SIZE
typedef BCM53324_A0_MMU_XQ22m_t MMU_XQ22m_t;
#define MMU_XQ22m_CLR BCM53324_A0_MMU_XQ22m_CLR
#define MMU_XQ22m_SET BCM53324_A0_MMU_XQ22m_SET
#define MMU_XQ22m_GET BCM53324_A0_MMU_XQ22m_GET
#define MMU_XQ22m_DATAf_GET BCM53324_A0_MMU_XQ22m_DATAf_GET
#define MMU_XQ22m_DATAf_SET BCM53324_A0_MMU_XQ22m_DATAf_SET
#define MMU_XQ22m_PARITY_0f_GET BCM53324_A0_MMU_XQ22m_PARITY_0f_GET
#define MMU_XQ22m_PARITY_0f_SET BCM53324_A0_MMU_XQ22m_PARITY_0f_SET
#define MMU_XQ22m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ22m_PARITY_DATAf_GET
#define MMU_XQ22m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ22m_PARITY_DATAf_SET
#define MMU_XQ22m_L2f_GET BCM53324_A0_MMU_XQ22m_L2f_GET
#define MMU_XQ22m_L2f_SET BCM53324_A0_MMU_XQ22m_L2f_SET
#define MMU_XQ22m_PURGEf_GET BCM53324_A0_MMU_XQ22m_PURGEf_GET
#define MMU_XQ22m_PURGEf_SET BCM53324_A0_MMU_XQ22m_PURGEf_SET
#define MMU_XQ22m_PKT_PTRf_GET BCM53324_A0_MMU_XQ22m_PKT_PTRf_GET
#define MMU_XQ22m_PKT_PTRf_SET BCM53324_A0_MMU_XQ22m_PKT_PTRf_SET
#define MMU_XQ22m_IMIRRORf_GET BCM53324_A0_MMU_XQ22m_IMIRRORf_GET
#define MMU_XQ22m_IMIRRORf_SET BCM53324_A0_MMU_XQ22m_IMIRRORf_SET
#define MMU_XQ22m_EMIRRORf_GET BCM53324_A0_MMU_XQ22m_EMIRRORf_GET
#define MMU_XQ22m_EMIRRORf_SET BCM53324_A0_MMU_XQ22m_EMIRRORf_SET
#define MMU_XQ22m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ22m_NEXT_POINTERf_GET
#define MMU_XQ22m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ22m_NEXT_POINTERf_SET
#define MMU_XQ22m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ22m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ22m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ22m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ22m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ22m_NEXT_XQ_POINTERf_GET
#define MMU_XQ22m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ22m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ22m BCM53324_A0_READ_MMU_XQ22m
#define WRITE_MMU_XQ22m BCM53324_A0_WRITE_MMU_XQ22m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ22m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ23
 * BLOCKS:   MMU
 * DESC:     XQ23
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ23m 0x0b65c000

#define BCM53324_A0_MMU_XQ23m_MIN 0
#define BCM53324_A0_MMU_XQ23m_MAX 511
#define BCM53324_A0_MMU_XQ23m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ23m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ23.
 *
 */
typedef union BCM53324_A0_MMU_XQ23m_s {
	uint32_t v[1];
	uint32_t mmu_xq23[1];
	uint32_t _mmu_xq23;
} BCM53324_A0_MMU_XQ23m_t;

#define BCM53324_A0_MMU_XQ23m_CLR(r) (r).mmu_xq23[0] = 0
#define BCM53324_A0_MMU_XQ23m_SET(r,d) (r).mmu_xq23[0] = d
#define BCM53324_A0_MMU_XQ23m_GET(r) (r).mmu_xq23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ23m_DATAf_GET(r) (((r).mmu_xq23[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ23m_DATAf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ23m_PARITY_0f_GET(r) (((r).mmu_xq23[0]) & 0x1)
#define BCM53324_A0_MMU_XQ23m_PARITY_0f_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ23m_PARITY_DATAf_GET(r) ((((r).mmu_xq23[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ23m_PARITY_DATAf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ23m_L2f_GET(r) ((((r).mmu_xq23[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ23m_L2f_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ23m_PURGEf_GET(r) ((((r).mmu_xq23[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ23m_PURGEf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ23m_PKT_PTRf_GET(r) ((((r).mmu_xq23[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ23m_PKT_PTRf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ23m_IMIRRORf_GET(r) ((((r).mmu_xq23[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ23m_IMIRRORf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ23m_EMIRRORf_GET(r) ((((r).mmu_xq23[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ23m_EMIRRORf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ23m_NEXT_POINTERf_GET(r) ((((r).mmu_xq23[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ23m_NEXT_POINTERf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ23m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq23[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ23m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ23m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq23[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ23m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq23[0]=(((r).mmu_xq23[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ23.
 *
 */
#define BCM53324_A0_READ_MMU_XQ23m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ23m,i,(m._mmu_xq23),1)
#define BCM53324_A0_WRITE_MMU_XQ23m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ23m,i,&(m._mmu_xq23),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ23m BCM53324_A0_MMU_XQ23m
#define MMU_XQ23m_MIN BCM53324_A0_MMU_XQ23m_MIN
#define MMU_XQ23m_MAX BCM53324_A0_MMU_XQ23m_MAX
#define MMU_XQ23m_CMAX(u) BCM53324_A0_MMU_XQ23m_CMAX(u)
#define MMU_XQ23m_SIZE BCM53324_A0_MMU_XQ23m_SIZE
typedef BCM53324_A0_MMU_XQ23m_t MMU_XQ23m_t;
#define MMU_XQ23m_CLR BCM53324_A0_MMU_XQ23m_CLR
#define MMU_XQ23m_SET BCM53324_A0_MMU_XQ23m_SET
#define MMU_XQ23m_GET BCM53324_A0_MMU_XQ23m_GET
#define MMU_XQ23m_DATAf_GET BCM53324_A0_MMU_XQ23m_DATAf_GET
#define MMU_XQ23m_DATAf_SET BCM53324_A0_MMU_XQ23m_DATAf_SET
#define MMU_XQ23m_PARITY_0f_GET BCM53324_A0_MMU_XQ23m_PARITY_0f_GET
#define MMU_XQ23m_PARITY_0f_SET BCM53324_A0_MMU_XQ23m_PARITY_0f_SET
#define MMU_XQ23m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ23m_PARITY_DATAf_GET
#define MMU_XQ23m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ23m_PARITY_DATAf_SET
#define MMU_XQ23m_L2f_GET BCM53324_A0_MMU_XQ23m_L2f_GET
#define MMU_XQ23m_L2f_SET BCM53324_A0_MMU_XQ23m_L2f_SET
#define MMU_XQ23m_PURGEf_GET BCM53324_A0_MMU_XQ23m_PURGEf_GET
#define MMU_XQ23m_PURGEf_SET BCM53324_A0_MMU_XQ23m_PURGEf_SET
#define MMU_XQ23m_PKT_PTRf_GET BCM53324_A0_MMU_XQ23m_PKT_PTRf_GET
#define MMU_XQ23m_PKT_PTRf_SET BCM53324_A0_MMU_XQ23m_PKT_PTRf_SET
#define MMU_XQ23m_IMIRRORf_GET BCM53324_A0_MMU_XQ23m_IMIRRORf_GET
#define MMU_XQ23m_IMIRRORf_SET BCM53324_A0_MMU_XQ23m_IMIRRORf_SET
#define MMU_XQ23m_EMIRRORf_GET BCM53324_A0_MMU_XQ23m_EMIRRORf_GET
#define MMU_XQ23m_EMIRRORf_SET BCM53324_A0_MMU_XQ23m_EMIRRORf_SET
#define MMU_XQ23m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ23m_NEXT_POINTERf_GET
#define MMU_XQ23m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ23m_NEXT_POINTERf_SET
#define MMU_XQ23m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ23m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ23m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ23m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ23m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ23m_NEXT_XQ_POINTERf_GET
#define MMU_XQ23m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ23m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ23m BCM53324_A0_READ_MMU_XQ23m
#define WRITE_MMU_XQ23m BCM53324_A0_WRITE_MMU_XQ23m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ23m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ24
 * BLOCKS:   MMU
 * DESC:     XQ24
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ24m 0x0b660000

#define BCM53324_A0_MMU_XQ24m_MIN 0
#define BCM53324_A0_MMU_XQ24m_MAX 511
#define BCM53324_A0_MMU_XQ24m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ24m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ24.
 *
 */
typedef union BCM53324_A0_MMU_XQ24m_s {
	uint32_t v[1];
	uint32_t mmu_xq24[1];
	uint32_t _mmu_xq24;
} BCM53324_A0_MMU_XQ24m_t;

#define BCM53324_A0_MMU_XQ24m_CLR(r) (r).mmu_xq24[0] = 0
#define BCM53324_A0_MMU_XQ24m_SET(r,d) (r).mmu_xq24[0] = d
#define BCM53324_A0_MMU_XQ24m_GET(r) (r).mmu_xq24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ24m_DATAf_GET(r) (((r).mmu_xq24[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ24m_DATAf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ24m_PARITY_0f_GET(r) (((r).mmu_xq24[0]) & 0x1)
#define BCM53324_A0_MMU_XQ24m_PARITY_0f_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ24m_PARITY_DATAf_GET(r) ((((r).mmu_xq24[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ24m_PARITY_DATAf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ24m_L2f_GET(r) ((((r).mmu_xq24[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ24m_L2f_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ24m_PURGEf_GET(r) ((((r).mmu_xq24[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ24m_PURGEf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ24m_PKT_PTRf_GET(r) ((((r).mmu_xq24[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ24m_PKT_PTRf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ24m_IMIRRORf_GET(r) ((((r).mmu_xq24[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ24m_IMIRRORf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ24m_EMIRRORf_GET(r) ((((r).mmu_xq24[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ24m_EMIRRORf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ24m_NEXT_POINTERf_GET(r) ((((r).mmu_xq24[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ24m_NEXT_POINTERf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ24m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq24[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ24m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ24m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq24[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ24m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq24[0]=(((r).mmu_xq24[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ24.
 *
 */
#define BCM53324_A0_READ_MMU_XQ24m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ24m,i,(m._mmu_xq24),1)
#define BCM53324_A0_WRITE_MMU_XQ24m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ24m,i,&(m._mmu_xq24),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ24m BCM53324_A0_MMU_XQ24m
#define MMU_XQ24m_MIN BCM53324_A0_MMU_XQ24m_MIN
#define MMU_XQ24m_MAX BCM53324_A0_MMU_XQ24m_MAX
#define MMU_XQ24m_CMAX(u) BCM53324_A0_MMU_XQ24m_CMAX(u)
#define MMU_XQ24m_SIZE BCM53324_A0_MMU_XQ24m_SIZE
typedef BCM53324_A0_MMU_XQ24m_t MMU_XQ24m_t;
#define MMU_XQ24m_CLR BCM53324_A0_MMU_XQ24m_CLR
#define MMU_XQ24m_SET BCM53324_A0_MMU_XQ24m_SET
#define MMU_XQ24m_GET BCM53324_A0_MMU_XQ24m_GET
#define MMU_XQ24m_DATAf_GET BCM53324_A0_MMU_XQ24m_DATAf_GET
#define MMU_XQ24m_DATAf_SET BCM53324_A0_MMU_XQ24m_DATAf_SET
#define MMU_XQ24m_PARITY_0f_GET BCM53324_A0_MMU_XQ24m_PARITY_0f_GET
#define MMU_XQ24m_PARITY_0f_SET BCM53324_A0_MMU_XQ24m_PARITY_0f_SET
#define MMU_XQ24m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ24m_PARITY_DATAf_GET
#define MMU_XQ24m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ24m_PARITY_DATAf_SET
#define MMU_XQ24m_L2f_GET BCM53324_A0_MMU_XQ24m_L2f_GET
#define MMU_XQ24m_L2f_SET BCM53324_A0_MMU_XQ24m_L2f_SET
#define MMU_XQ24m_PURGEf_GET BCM53324_A0_MMU_XQ24m_PURGEf_GET
#define MMU_XQ24m_PURGEf_SET BCM53324_A0_MMU_XQ24m_PURGEf_SET
#define MMU_XQ24m_PKT_PTRf_GET BCM53324_A0_MMU_XQ24m_PKT_PTRf_GET
#define MMU_XQ24m_PKT_PTRf_SET BCM53324_A0_MMU_XQ24m_PKT_PTRf_SET
#define MMU_XQ24m_IMIRRORf_GET BCM53324_A0_MMU_XQ24m_IMIRRORf_GET
#define MMU_XQ24m_IMIRRORf_SET BCM53324_A0_MMU_XQ24m_IMIRRORf_SET
#define MMU_XQ24m_EMIRRORf_GET BCM53324_A0_MMU_XQ24m_EMIRRORf_GET
#define MMU_XQ24m_EMIRRORf_SET BCM53324_A0_MMU_XQ24m_EMIRRORf_SET
#define MMU_XQ24m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ24m_NEXT_POINTERf_GET
#define MMU_XQ24m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ24m_NEXT_POINTERf_SET
#define MMU_XQ24m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ24m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ24m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ24m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ24m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ24m_NEXT_XQ_POINTERf_GET
#define MMU_XQ24m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ24m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ24m BCM53324_A0_READ_MMU_XQ24m
#define WRITE_MMU_XQ24m BCM53324_A0_WRITE_MMU_XQ24m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ24m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ3
 * BLOCKS:   MMU
 * DESC:     XQ3
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ3m 0x0b60c000

#define BCM53324_A0_MMU_XQ3m_MIN 0
#define BCM53324_A0_MMU_XQ3m_MAX 511
#define BCM53324_A0_MMU_XQ3m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ3m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ3.
 *
 */
typedef union BCM53324_A0_MMU_XQ3m_s {
	uint32_t v[1];
	uint32_t mmu_xq3[1];
	uint32_t _mmu_xq3;
} BCM53324_A0_MMU_XQ3m_t;

#define BCM53324_A0_MMU_XQ3m_CLR(r) (r).mmu_xq3[0] = 0
#define BCM53324_A0_MMU_XQ3m_SET(r,d) (r).mmu_xq3[0] = d
#define BCM53324_A0_MMU_XQ3m_GET(r) (r).mmu_xq3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ3m_DATAf_GET(r) (((r).mmu_xq3[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ3m_DATAf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ3m_PARITY_0f_GET(r) (((r).mmu_xq3[0]) & 0x1)
#define BCM53324_A0_MMU_XQ3m_PARITY_0f_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ3m_PARITY_DATAf_GET(r) ((((r).mmu_xq3[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ3m_PARITY_DATAf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ3m_L2f_GET(r) ((((r).mmu_xq3[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ3m_L2f_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ3m_PURGEf_GET(r) ((((r).mmu_xq3[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ3m_PURGEf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ3m_PKT_PTRf_GET(r) ((((r).mmu_xq3[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ3m_PKT_PTRf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ3m_IMIRRORf_GET(r) ((((r).mmu_xq3[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ3m_IMIRRORf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ3m_EMIRRORf_GET(r) ((((r).mmu_xq3[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ3m_EMIRRORf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ3m_NEXT_POINTERf_GET(r) ((((r).mmu_xq3[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ3m_NEXT_POINTERf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ3m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq3[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ3m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ3m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq3[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ3m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq3[0]=(((r).mmu_xq3[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ3.
 *
 */
#define BCM53324_A0_READ_MMU_XQ3m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ3m,i,(m._mmu_xq3),1)
#define BCM53324_A0_WRITE_MMU_XQ3m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ3m,i,&(m._mmu_xq3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ3m BCM53324_A0_MMU_XQ3m
#define MMU_XQ3m_MIN BCM53324_A0_MMU_XQ3m_MIN
#define MMU_XQ3m_MAX BCM53324_A0_MMU_XQ3m_MAX
#define MMU_XQ3m_CMAX(u) BCM53324_A0_MMU_XQ3m_CMAX(u)
#define MMU_XQ3m_SIZE BCM53324_A0_MMU_XQ3m_SIZE
typedef BCM53324_A0_MMU_XQ3m_t MMU_XQ3m_t;
#define MMU_XQ3m_CLR BCM53324_A0_MMU_XQ3m_CLR
#define MMU_XQ3m_SET BCM53324_A0_MMU_XQ3m_SET
#define MMU_XQ3m_GET BCM53324_A0_MMU_XQ3m_GET
#define MMU_XQ3m_DATAf_GET BCM53324_A0_MMU_XQ3m_DATAf_GET
#define MMU_XQ3m_DATAf_SET BCM53324_A0_MMU_XQ3m_DATAf_SET
#define MMU_XQ3m_PARITY_0f_GET BCM53324_A0_MMU_XQ3m_PARITY_0f_GET
#define MMU_XQ3m_PARITY_0f_SET BCM53324_A0_MMU_XQ3m_PARITY_0f_SET
#define MMU_XQ3m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ3m_PARITY_DATAf_GET
#define MMU_XQ3m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ3m_PARITY_DATAf_SET
#define MMU_XQ3m_L2f_GET BCM53324_A0_MMU_XQ3m_L2f_GET
#define MMU_XQ3m_L2f_SET BCM53324_A0_MMU_XQ3m_L2f_SET
#define MMU_XQ3m_PURGEf_GET BCM53324_A0_MMU_XQ3m_PURGEf_GET
#define MMU_XQ3m_PURGEf_SET BCM53324_A0_MMU_XQ3m_PURGEf_SET
#define MMU_XQ3m_PKT_PTRf_GET BCM53324_A0_MMU_XQ3m_PKT_PTRf_GET
#define MMU_XQ3m_PKT_PTRf_SET BCM53324_A0_MMU_XQ3m_PKT_PTRf_SET
#define MMU_XQ3m_IMIRRORf_GET BCM53324_A0_MMU_XQ3m_IMIRRORf_GET
#define MMU_XQ3m_IMIRRORf_SET BCM53324_A0_MMU_XQ3m_IMIRRORf_SET
#define MMU_XQ3m_EMIRRORf_GET BCM53324_A0_MMU_XQ3m_EMIRRORf_GET
#define MMU_XQ3m_EMIRRORf_SET BCM53324_A0_MMU_XQ3m_EMIRRORf_SET
#define MMU_XQ3m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ3m_NEXT_POINTERf_GET
#define MMU_XQ3m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ3m_NEXT_POINTERf_SET
#define MMU_XQ3m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ3m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ3m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ3m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ3m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ3m_NEXT_XQ_POINTERf_GET
#define MMU_XQ3m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ3m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ3m BCM53324_A0_READ_MMU_XQ3m
#define WRITE_MMU_XQ3m BCM53324_A0_WRITE_MMU_XQ3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ4
 * BLOCKS:   MMU
 * DESC:     XQ4
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ4m 0x0b610000

#define BCM53324_A0_MMU_XQ4m_MIN 0
#define BCM53324_A0_MMU_XQ4m_MAX 511
#define BCM53324_A0_MMU_XQ4m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ4m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ4.
 *
 */
typedef union BCM53324_A0_MMU_XQ4m_s {
	uint32_t v[1];
	uint32_t mmu_xq4[1];
	uint32_t _mmu_xq4;
} BCM53324_A0_MMU_XQ4m_t;

#define BCM53324_A0_MMU_XQ4m_CLR(r) (r).mmu_xq4[0] = 0
#define BCM53324_A0_MMU_XQ4m_SET(r,d) (r).mmu_xq4[0] = d
#define BCM53324_A0_MMU_XQ4m_GET(r) (r).mmu_xq4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ4m_DATAf_GET(r) (((r).mmu_xq4[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ4m_DATAf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ4m_PARITY_0f_GET(r) (((r).mmu_xq4[0]) & 0x1)
#define BCM53324_A0_MMU_XQ4m_PARITY_0f_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ4m_PARITY_DATAf_GET(r) ((((r).mmu_xq4[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ4m_PARITY_DATAf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ4m_L2f_GET(r) ((((r).mmu_xq4[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ4m_L2f_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ4m_PURGEf_GET(r) ((((r).mmu_xq4[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ4m_PURGEf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ4m_PKT_PTRf_GET(r) ((((r).mmu_xq4[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ4m_PKT_PTRf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ4m_IMIRRORf_GET(r) ((((r).mmu_xq4[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ4m_IMIRRORf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ4m_EMIRRORf_GET(r) ((((r).mmu_xq4[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ4m_EMIRRORf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ4m_NEXT_POINTERf_GET(r) ((((r).mmu_xq4[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ4m_NEXT_POINTERf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ4m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq4[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ4m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ4m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq4[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ4m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq4[0]=(((r).mmu_xq4[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ4.
 *
 */
#define BCM53324_A0_READ_MMU_XQ4m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ4m,i,(m._mmu_xq4),1)
#define BCM53324_A0_WRITE_MMU_XQ4m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ4m,i,&(m._mmu_xq4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ4m BCM53324_A0_MMU_XQ4m
#define MMU_XQ4m_MIN BCM53324_A0_MMU_XQ4m_MIN
#define MMU_XQ4m_MAX BCM53324_A0_MMU_XQ4m_MAX
#define MMU_XQ4m_CMAX(u) BCM53324_A0_MMU_XQ4m_CMAX(u)
#define MMU_XQ4m_SIZE BCM53324_A0_MMU_XQ4m_SIZE
typedef BCM53324_A0_MMU_XQ4m_t MMU_XQ4m_t;
#define MMU_XQ4m_CLR BCM53324_A0_MMU_XQ4m_CLR
#define MMU_XQ4m_SET BCM53324_A0_MMU_XQ4m_SET
#define MMU_XQ4m_GET BCM53324_A0_MMU_XQ4m_GET
#define MMU_XQ4m_DATAf_GET BCM53324_A0_MMU_XQ4m_DATAf_GET
#define MMU_XQ4m_DATAf_SET BCM53324_A0_MMU_XQ4m_DATAf_SET
#define MMU_XQ4m_PARITY_0f_GET BCM53324_A0_MMU_XQ4m_PARITY_0f_GET
#define MMU_XQ4m_PARITY_0f_SET BCM53324_A0_MMU_XQ4m_PARITY_0f_SET
#define MMU_XQ4m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ4m_PARITY_DATAf_GET
#define MMU_XQ4m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ4m_PARITY_DATAf_SET
#define MMU_XQ4m_L2f_GET BCM53324_A0_MMU_XQ4m_L2f_GET
#define MMU_XQ4m_L2f_SET BCM53324_A0_MMU_XQ4m_L2f_SET
#define MMU_XQ4m_PURGEf_GET BCM53324_A0_MMU_XQ4m_PURGEf_GET
#define MMU_XQ4m_PURGEf_SET BCM53324_A0_MMU_XQ4m_PURGEf_SET
#define MMU_XQ4m_PKT_PTRf_GET BCM53324_A0_MMU_XQ4m_PKT_PTRf_GET
#define MMU_XQ4m_PKT_PTRf_SET BCM53324_A0_MMU_XQ4m_PKT_PTRf_SET
#define MMU_XQ4m_IMIRRORf_GET BCM53324_A0_MMU_XQ4m_IMIRRORf_GET
#define MMU_XQ4m_IMIRRORf_SET BCM53324_A0_MMU_XQ4m_IMIRRORf_SET
#define MMU_XQ4m_EMIRRORf_GET BCM53324_A0_MMU_XQ4m_EMIRRORf_GET
#define MMU_XQ4m_EMIRRORf_SET BCM53324_A0_MMU_XQ4m_EMIRRORf_SET
#define MMU_XQ4m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ4m_NEXT_POINTERf_GET
#define MMU_XQ4m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ4m_NEXT_POINTERf_SET
#define MMU_XQ4m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ4m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ4m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ4m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ4m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ4m_NEXT_XQ_POINTERf_GET
#define MMU_XQ4m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ4m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ4m BCM53324_A0_READ_MMU_XQ4m
#define WRITE_MMU_XQ4m BCM53324_A0_WRITE_MMU_XQ4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ5
 * BLOCKS:   MMU
 * DESC:     XQ5
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ5m 0x0b614000

#define BCM53324_A0_MMU_XQ5m_MIN 0
#define BCM53324_A0_MMU_XQ5m_MAX 511
#define BCM53324_A0_MMU_XQ5m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ5m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ5.
 *
 */
typedef union BCM53324_A0_MMU_XQ5m_s {
	uint32_t v[1];
	uint32_t mmu_xq5[1];
	uint32_t _mmu_xq5;
} BCM53324_A0_MMU_XQ5m_t;

#define BCM53324_A0_MMU_XQ5m_CLR(r) (r).mmu_xq5[0] = 0
#define BCM53324_A0_MMU_XQ5m_SET(r,d) (r).mmu_xq5[0] = d
#define BCM53324_A0_MMU_XQ5m_GET(r) (r).mmu_xq5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ5m_DATAf_GET(r) (((r).mmu_xq5[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ5m_DATAf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ5m_PARITY_0f_GET(r) (((r).mmu_xq5[0]) & 0x1)
#define BCM53324_A0_MMU_XQ5m_PARITY_0f_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ5m_PARITY_DATAf_GET(r) ((((r).mmu_xq5[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ5m_PARITY_DATAf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ5m_L2f_GET(r) ((((r).mmu_xq5[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ5m_L2f_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ5m_PURGEf_GET(r) ((((r).mmu_xq5[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ5m_PURGEf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ5m_PKT_PTRf_GET(r) ((((r).mmu_xq5[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ5m_PKT_PTRf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ5m_IMIRRORf_GET(r) ((((r).mmu_xq5[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ5m_IMIRRORf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ5m_EMIRRORf_GET(r) ((((r).mmu_xq5[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ5m_EMIRRORf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ5m_NEXT_POINTERf_GET(r) ((((r).mmu_xq5[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ5m_NEXT_POINTERf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ5m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq5[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ5m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ5m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq5[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ5m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq5[0]=(((r).mmu_xq5[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ5.
 *
 */
#define BCM53324_A0_READ_MMU_XQ5m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ5m,i,(m._mmu_xq5),1)
#define BCM53324_A0_WRITE_MMU_XQ5m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ5m,i,&(m._mmu_xq5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ5m BCM53324_A0_MMU_XQ5m
#define MMU_XQ5m_MIN BCM53324_A0_MMU_XQ5m_MIN
#define MMU_XQ5m_MAX BCM53324_A0_MMU_XQ5m_MAX
#define MMU_XQ5m_CMAX(u) BCM53324_A0_MMU_XQ5m_CMAX(u)
#define MMU_XQ5m_SIZE BCM53324_A0_MMU_XQ5m_SIZE
typedef BCM53324_A0_MMU_XQ5m_t MMU_XQ5m_t;
#define MMU_XQ5m_CLR BCM53324_A0_MMU_XQ5m_CLR
#define MMU_XQ5m_SET BCM53324_A0_MMU_XQ5m_SET
#define MMU_XQ5m_GET BCM53324_A0_MMU_XQ5m_GET
#define MMU_XQ5m_DATAf_GET BCM53324_A0_MMU_XQ5m_DATAf_GET
#define MMU_XQ5m_DATAf_SET BCM53324_A0_MMU_XQ5m_DATAf_SET
#define MMU_XQ5m_PARITY_0f_GET BCM53324_A0_MMU_XQ5m_PARITY_0f_GET
#define MMU_XQ5m_PARITY_0f_SET BCM53324_A0_MMU_XQ5m_PARITY_0f_SET
#define MMU_XQ5m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ5m_PARITY_DATAf_GET
#define MMU_XQ5m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ5m_PARITY_DATAf_SET
#define MMU_XQ5m_L2f_GET BCM53324_A0_MMU_XQ5m_L2f_GET
#define MMU_XQ5m_L2f_SET BCM53324_A0_MMU_XQ5m_L2f_SET
#define MMU_XQ5m_PURGEf_GET BCM53324_A0_MMU_XQ5m_PURGEf_GET
#define MMU_XQ5m_PURGEf_SET BCM53324_A0_MMU_XQ5m_PURGEf_SET
#define MMU_XQ5m_PKT_PTRf_GET BCM53324_A0_MMU_XQ5m_PKT_PTRf_GET
#define MMU_XQ5m_PKT_PTRf_SET BCM53324_A0_MMU_XQ5m_PKT_PTRf_SET
#define MMU_XQ5m_IMIRRORf_GET BCM53324_A0_MMU_XQ5m_IMIRRORf_GET
#define MMU_XQ5m_IMIRRORf_SET BCM53324_A0_MMU_XQ5m_IMIRRORf_SET
#define MMU_XQ5m_EMIRRORf_GET BCM53324_A0_MMU_XQ5m_EMIRRORf_GET
#define MMU_XQ5m_EMIRRORf_SET BCM53324_A0_MMU_XQ5m_EMIRRORf_SET
#define MMU_XQ5m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ5m_NEXT_POINTERf_GET
#define MMU_XQ5m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ5m_NEXT_POINTERf_SET
#define MMU_XQ5m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ5m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ5m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ5m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ5m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ5m_NEXT_XQ_POINTERf_GET
#define MMU_XQ5m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ5m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ5m BCM53324_A0_READ_MMU_XQ5m
#define WRITE_MMU_XQ5m BCM53324_A0_WRITE_MMU_XQ5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ6
 * BLOCKS:   MMU
 * DESC:     XQ6
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ6m 0x0b618000

#define BCM53324_A0_MMU_XQ6m_MIN 0
#define BCM53324_A0_MMU_XQ6m_MAX 511
#define BCM53324_A0_MMU_XQ6m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ6m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ6.
 *
 */
typedef union BCM53324_A0_MMU_XQ6m_s {
	uint32_t v[1];
	uint32_t mmu_xq6[1];
	uint32_t _mmu_xq6;
} BCM53324_A0_MMU_XQ6m_t;

#define BCM53324_A0_MMU_XQ6m_CLR(r) (r).mmu_xq6[0] = 0
#define BCM53324_A0_MMU_XQ6m_SET(r,d) (r).mmu_xq6[0] = d
#define BCM53324_A0_MMU_XQ6m_GET(r) (r).mmu_xq6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ6m_DATAf_GET(r) (((r).mmu_xq6[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ6m_DATAf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ6m_PARITY_0f_GET(r) (((r).mmu_xq6[0]) & 0x1)
#define BCM53324_A0_MMU_XQ6m_PARITY_0f_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ6m_PARITY_DATAf_GET(r) ((((r).mmu_xq6[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ6m_PARITY_DATAf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ6m_L2f_GET(r) ((((r).mmu_xq6[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ6m_L2f_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ6m_PURGEf_GET(r) ((((r).mmu_xq6[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ6m_PURGEf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ6m_PKT_PTRf_GET(r) ((((r).mmu_xq6[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ6m_PKT_PTRf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ6m_IMIRRORf_GET(r) ((((r).mmu_xq6[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ6m_IMIRRORf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ6m_EMIRRORf_GET(r) ((((r).mmu_xq6[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ6m_EMIRRORf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ6m_NEXT_POINTERf_GET(r) ((((r).mmu_xq6[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ6m_NEXT_POINTERf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ6m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq6[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ6m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ6m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq6[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ6m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq6[0]=(((r).mmu_xq6[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ6.
 *
 */
#define BCM53324_A0_READ_MMU_XQ6m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ6m,i,(m._mmu_xq6),1)
#define BCM53324_A0_WRITE_MMU_XQ6m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ6m,i,&(m._mmu_xq6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ6m BCM53324_A0_MMU_XQ6m
#define MMU_XQ6m_MIN BCM53324_A0_MMU_XQ6m_MIN
#define MMU_XQ6m_MAX BCM53324_A0_MMU_XQ6m_MAX
#define MMU_XQ6m_CMAX(u) BCM53324_A0_MMU_XQ6m_CMAX(u)
#define MMU_XQ6m_SIZE BCM53324_A0_MMU_XQ6m_SIZE
typedef BCM53324_A0_MMU_XQ6m_t MMU_XQ6m_t;
#define MMU_XQ6m_CLR BCM53324_A0_MMU_XQ6m_CLR
#define MMU_XQ6m_SET BCM53324_A0_MMU_XQ6m_SET
#define MMU_XQ6m_GET BCM53324_A0_MMU_XQ6m_GET
#define MMU_XQ6m_DATAf_GET BCM53324_A0_MMU_XQ6m_DATAf_GET
#define MMU_XQ6m_DATAf_SET BCM53324_A0_MMU_XQ6m_DATAf_SET
#define MMU_XQ6m_PARITY_0f_GET BCM53324_A0_MMU_XQ6m_PARITY_0f_GET
#define MMU_XQ6m_PARITY_0f_SET BCM53324_A0_MMU_XQ6m_PARITY_0f_SET
#define MMU_XQ6m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ6m_PARITY_DATAf_GET
#define MMU_XQ6m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ6m_PARITY_DATAf_SET
#define MMU_XQ6m_L2f_GET BCM53324_A0_MMU_XQ6m_L2f_GET
#define MMU_XQ6m_L2f_SET BCM53324_A0_MMU_XQ6m_L2f_SET
#define MMU_XQ6m_PURGEf_GET BCM53324_A0_MMU_XQ6m_PURGEf_GET
#define MMU_XQ6m_PURGEf_SET BCM53324_A0_MMU_XQ6m_PURGEf_SET
#define MMU_XQ6m_PKT_PTRf_GET BCM53324_A0_MMU_XQ6m_PKT_PTRf_GET
#define MMU_XQ6m_PKT_PTRf_SET BCM53324_A0_MMU_XQ6m_PKT_PTRf_SET
#define MMU_XQ6m_IMIRRORf_GET BCM53324_A0_MMU_XQ6m_IMIRRORf_GET
#define MMU_XQ6m_IMIRRORf_SET BCM53324_A0_MMU_XQ6m_IMIRRORf_SET
#define MMU_XQ6m_EMIRRORf_GET BCM53324_A0_MMU_XQ6m_EMIRRORf_GET
#define MMU_XQ6m_EMIRRORf_SET BCM53324_A0_MMU_XQ6m_EMIRRORf_SET
#define MMU_XQ6m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ6m_NEXT_POINTERf_GET
#define MMU_XQ6m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ6m_NEXT_POINTERf_SET
#define MMU_XQ6m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ6m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ6m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ6m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ6m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ6m_NEXT_XQ_POINTERf_GET
#define MMU_XQ6m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ6m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ6m BCM53324_A0_READ_MMU_XQ6m
#define WRITE_MMU_XQ6m BCM53324_A0_WRITE_MMU_XQ6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ7
 * BLOCKS:   MMU
 * DESC:     XQ7
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ7m 0x0b61c000

#define BCM53324_A0_MMU_XQ7m_MIN 0
#define BCM53324_A0_MMU_XQ7m_MAX 511
#define BCM53324_A0_MMU_XQ7m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ7m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ7.
 *
 */
typedef union BCM53324_A0_MMU_XQ7m_s {
	uint32_t v[1];
	uint32_t mmu_xq7[1];
	uint32_t _mmu_xq7;
} BCM53324_A0_MMU_XQ7m_t;

#define BCM53324_A0_MMU_XQ7m_CLR(r) (r).mmu_xq7[0] = 0
#define BCM53324_A0_MMU_XQ7m_SET(r,d) (r).mmu_xq7[0] = d
#define BCM53324_A0_MMU_XQ7m_GET(r) (r).mmu_xq7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ7m_DATAf_GET(r) (((r).mmu_xq7[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ7m_DATAf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ7m_PARITY_0f_GET(r) (((r).mmu_xq7[0]) & 0x1)
#define BCM53324_A0_MMU_XQ7m_PARITY_0f_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ7m_PARITY_DATAf_GET(r) ((((r).mmu_xq7[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ7m_PARITY_DATAf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ7m_L2f_GET(r) ((((r).mmu_xq7[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ7m_L2f_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ7m_PURGEf_GET(r) ((((r).mmu_xq7[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ7m_PURGEf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ7m_PKT_PTRf_GET(r) ((((r).mmu_xq7[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ7m_PKT_PTRf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ7m_IMIRRORf_GET(r) ((((r).mmu_xq7[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ7m_IMIRRORf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ7m_EMIRRORf_GET(r) ((((r).mmu_xq7[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ7m_EMIRRORf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ7m_NEXT_POINTERf_GET(r) ((((r).mmu_xq7[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ7m_NEXT_POINTERf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ7m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq7[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ7m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ7m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq7[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ7m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq7[0]=(((r).mmu_xq7[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ7.
 *
 */
#define BCM53324_A0_READ_MMU_XQ7m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ7m,i,(m._mmu_xq7),1)
#define BCM53324_A0_WRITE_MMU_XQ7m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ7m,i,&(m._mmu_xq7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ7m BCM53324_A0_MMU_XQ7m
#define MMU_XQ7m_MIN BCM53324_A0_MMU_XQ7m_MIN
#define MMU_XQ7m_MAX BCM53324_A0_MMU_XQ7m_MAX
#define MMU_XQ7m_CMAX(u) BCM53324_A0_MMU_XQ7m_CMAX(u)
#define MMU_XQ7m_SIZE BCM53324_A0_MMU_XQ7m_SIZE
typedef BCM53324_A0_MMU_XQ7m_t MMU_XQ7m_t;
#define MMU_XQ7m_CLR BCM53324_A0_MMU_XQ7m_CLR
#define MMU_XQ7m_SET BCM53324_A0_MMU_XQ7m_SET
#define MMU_XQ7m_GET BCM53324_A0_MMU_XQ7m_GET
#define MMU_XQ7m_DATAf_GET BCM53324_A0_MMU_XQ7m_DATAf_GET
#define MMU_XQ7m_DATAf_SET BCM53324_A0_MMU_XQ7m_DATAf_SET
#define MMU_XQ7m_PARITY_0f_GET BCM53324_A0_MMU_XQ7m_PARITY_0f_GET
#define MMU_XQ7m_PARITY_0f_SET BCM53324_A0_MMU_XQ7m_PARITY_0f_SET
#define MMU_XQ7m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ7m_PARITY_DATAf_GET
#define MMU_XQ7m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ7m_PARITY_DATAf_SET
#define MMU_XQ7m_L2f_GET BCM53324_A0_MMU_XQ7m_L2f_GET
#define MMU_XQ7m_L2f_SET BCM53324_A0_MMU_XQ7m_L2f_SET
#define MMU_XQ7m_PURGEf_GET BCM53324_A0_MMU_XQ7m_PURGEf_GET
#define MMU_XQ7m_PURGEf_SET BCM53324_A0_MMU_XQ7m_PURGEf_SET
#define MMU_XQ7m_PKT_PTRf_GET BCM53324_A0_MMU_XQ7m_PKT_PTRf_GET
#define MMU_XQ7m_PKT_PTRf_SET BCM53324_A0_MMU_XQ7m_PKT_PTRf_SET
#define MMU_XQ7m_IMIRRORf_GET BCM53324_A0_MMU_XQ7m_IMIRRORf_GET
#define MMU_XQ7m_IMIRRORf_SET BCM53324_A0_MMU_XQ7m_IMIRRORf_SET
#define MMU_XQ7m_EMIRRORf_GET BCM53324_A0_MMU_XQ7m_EMIRRORf_GET
#define MMU_XQ7m_EMIRRORf_SET BCM53324_A0_MMU_XQ7m_EMIRRORf_SET
#define MMU_XQ7m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ7m_NEXT_POINTERf_GET
#define MMU_XQ7m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ7m_NEXT_POINTERf_SET
#define MMU_XQ7m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ7m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ7m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ7m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ7m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ7m_NEXT_XQ_POINTERf_GET
#define MMU_XQ7m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ7m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ7m BCM53324_A0_READ_MMU_XQ7m
#define WRITE_MMU_XQ7m BCM53324_A0_WRITE_MMU_XQ7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ8
 * BLOCKS:   MMU
 * DESC:     XQ8
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ8m 0x0b620000

#define BCM53324_A0_MMU_XQ8m_MIN 0
#define BCM53324_A0_MMU_XQ8m_MAX 511
#define BCM53324_A0_MMU_XQ8m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ8m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ8.
 *
 */
typedef union BCM53324_A0_MMU_XQ8m_s {
	uint32_t v[1];
	uint32_t mmu_xq8[1];
	uint32_t _mmu_xq8;
} BCM53324_A0_MMU_XQ8m_t;

#define BCM53324_A0_MMU_XQ8m_CLR(r) (r).mmu_xq8[0] = 0
#define BCM53324_A0_MMU_XQ8m_SET(r,d) (r).mmu_xq8[0] = d
#define BCM53324_A0_MMU_XQ8m_GET(r) (r).mmu_xq8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ8m_DATAf_GET(r) (((r).mmu_xq8[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ8m_DATAf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ8m_PARITY_0f_GET(r) (((r).mmu_xq8[0]) & 0x1)
#define BCM53324_A0_MMU_XQ8m_PARITY_0f_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ8m_PARITY_DATAf_GET(r) ((((r).mmu_xq8[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ8m_PARITY_DATAf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ8m_L2f_GET(r) ((((r).mmu_xq8[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ8m_L2f_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ8m_PURGEf_GET(r) ((((r).mmu_xq8[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ8m_PURGEf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ8m_PKT_PTRf_GET(r) ((((r).mmu_xq8[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ8m_PKT_PTRf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ8m_IMIRRORf_GET(r) ((((r).mmu_xq8[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ8m_IMIRRORf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ8m_EMIRRORf_GET(r) ((((r).mmu_xq8[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ8m_EMIRRORf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ8m_NEXT_POINTERf_GET(r) ((((r).mmu_xq8[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ8m_NEXT_POINTERf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ8m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq8[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ8m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ8m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq8[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ8m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq8[0]=(((r).mmu_xq8[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ8.
 *
 */
#define BCM53324_A0_READ_MMU_XQ8m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ8m,i,(m._mmu_xq8),1)
#define BCM53324_A0_WRITE_MMU_XQ8m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ8m,i,&(m._mmu_xq8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ8m BCM53324_A0_MMU_XQ8m
#define MMU_XQ8m_MIN BCM53324_A0_MMU_XQ8m_MIN
#define MMU_XQ8m_MAX BCM53324_A0_MMU_XQ8m_MAX
#define MMU_XQ8m_CMAX(u) BCM53324_A0_MMU_XQ8m_CMAX(u)
#define MMU_XQ8m_SIZE BCM53324_A0_MMU_XQ8m_SIZE
typedef BCM53324_A0_MMU_XQ8m_t MMU_XQ8m_t;
#define MMU_XQ8m_CLR BCM53324_A0_MMU_XQ8m_CLR
#define MMU_XQ8m_SET BCM53324_A0_MMU_XQ8m_SET
#define MMU_XQ8m_GET BCM53324_A0_MMU_XQ8m_GET
#define MMU_XQ8m_DATAf_GET BCM53324_A0_MMU_XQ8m_DATAf_GET
#define MMU_XQ8m_DATAf_SET BCM53324_A0_MMU_XQ8m_DATAf_SET
#define MMU_XQ8m_PARITY_0f_GET BCM53324_A0_MMU_XQ8m_PARITY_0f_GET
#define MMU_XQ8m_PARITY_0f_SET BCM53324_A0_MMU_XQ8m_PARITY_0f_SET
#define MMU_XQ8m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ8m_PARITY_DATAf_GET
#define MMU_XQ8m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ8m_PARITY_DATAf_SET
#define MMU_XQ8m_L2f_GET BCM53324_A0_MMU_XQ8m_L2f_GET
#define MMU_XQ8m_L2f_SET BCM53324_A0_MMU_XQ8m_L2f_SET
#define MMU_XQ8m_PURGEf_GET BCM53324_A0_MMU_XQ8m_PURGEf_GET
#define MMU_XQ8m_PURGEf_SET BCM53324_A0_MMU_XQ8m_PURGEf_SET
#define MMU_XQ8m_PKT_PTRf_GET BCM53324_A0_MMU_XQ8m_PKT_PTRf_GET
#define MMU_XQ8m_PKT_PTRf_SET BCM53324_A0_MMU_XQ8m_PKT_PTRf_SET
#define MMU_XQ8m_IMIRRORf_GET BCM53324_A0_MMU_XQ8m_IMIRRORf_GET
#define MMU_XQ8m_IMIRRORf_SET BCM53324_A0_MMU_XQ8m_IMIRRORf_SET
#define MMU_XQ8m_EMIRRORf_GET BCM53324_A0_MMU_XQ8m_EMIRRORf_GET
#define MMU_XQ8m_EMIRRORf_SET BCM53324_A0_MMU_XQ8m_EMIRRORf_SET
#define MMU_XQ8m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ8m_NEXT_POINTERf_GET
#define MMU_XQ8m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ8m_NEXT_POINTERf_SET
#define MMU_XQ8m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ8m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ8m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ8m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ8m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ8m_NEXT_XQ_POINTERf_GET
#define MMU_XQ8m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ8m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ8m BCM53324_A0_READ_MMU_XQ8m
#define WRITE_MMU_XQ8m BCM53324_A0_WRITE_MMU_XQ8m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ8m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  MMU_XQ9
 * BLOCKS:   MMU
 * DESC:     XQ9
 * SIZE:     31
 * FIELDS:
 *     DATA             DATA FIELD 
 *     PARITY_0         Parity bit
 *     PARITY_DATA      Parity 0 Data 
 *     L2               Packet L2 Switched bit
 *     PURGE            Packet Purged bit
 *     PKT_PTR          Address point to first cell of a packet
 *     IMIRROR          Ingress Mirrored bit
 *     EMIRROR          Egress Mirrored  bit
 *     NEXT_POINTER     NEXT POINTER FIELD 
 *     NEXT_XQ_POINTER_ECC pointer to next entry in XQ. 
 *     NEXT_XQ_POINTER  pointer to next entry in XQ 
 *
 ******************************************************************************/
#define BCM53324_A0_MMU_XQ9m 0x0b624000

#define BCM53324_A0_MMU_XQ9m_MIN 0
#define BCM53324_A0_MMU_XQ9m_MAX 511
#define BCM53324_A0_MMU_XQ9m_CMAX(u) 511
#define BCM53324_A0_MMU_XQ9m_SIZE 4

/*
 * This structure should be used to declare and program MMU_XQ9.
 *
 */
typedef union BCM53324_A0_MMU_XQ9m_s {
	uint32_t v[1];
	uint32_t mmu_xq9[1];
	uint32_t _mmu_xq9;
} BCM53324_A0_MMU_XQ9m_t;

#define BCM53324_A0_MMU_XQ9m_CLR(r) (r).mmu_xq9[0] = 0
#define BCM53324_A0_MMU_XQ9m_SET(r,d) (r).mmu_xq9[0] = d
#define BCM53324_A0_MMU_XQ9m_GET(r) (r).mmu_xq9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_MMU_XQ9m_DATAf_GET(r) (((r).mmu_xq9[0]) & 0x1ffff)
#define BCM53324_A0_MMU_XQ9m_DATAf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_MMU_XQ9m_PARITY_0f_GET(r) (((r).mmu_xq9[0]) & 0x1)
#define BCM53324_A0_MMU_XQ9m_PARITY_0f_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_MMU_XQ9m_PARITY_DATAf_GET(r) ((((r).mmu_xq9[0]) >> 1) & 0xffff)
#define BCM53324_A0_MMU_XQ9m_PARITY_DATAf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0xffff << 1)) | ((((uint32_t)f) & 0xffff) << 1))
#define BCM53324_A0_MMU_XQ9m_L2f_GET(r) ((((r).mmu_xq9[0]) >> 1) & 0x1)
#define BCM53324_A0_MMU_XQ9m_L2f_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_MMU_XQ9m_PURGEf_GET(r) ((((r).mmu_xq9[0]) >> 2) & 0x1)
#define BCM53324_A0_MMU_XQ9m_PURGEf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_MMU_XQ9m_PKT_PTRf_GET(r) ((((r).mmu_xq9[0]) >> 3) & 0xfff)
#define BCM53324_A0_MMU_XQ9m_PKT_PTRf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM53324_A0_MMU_XQ9m_IMIRRORf_GET(r) ((((r).mmu_xq9[0]) >> 15) & 0x1)
#define BCM53324_A0_MMU_XQ9m_IMIRRORf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_MMU_XQ9m_EMIRRORf_GET(r) ((((r).mmu_xq9[0]) >> 16) & 0x1)
#define BCM53324_A0_MMU_XQ9m_EMIRRORf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_MMU_XQ9m_NEXT_POINTERf_GET(r) ((((r).mmu_xq9[0]) >> 17) & 0x3fff)
#define BCM53324_A0_MMU_XQ9m_NEXT_POINTERf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53324_A0_MMU_XQ9m_NEXT_XQ_POINTER_ECCf_GET(r) ((((r).mmu_xq9[0]) >> 17) & 0x1f)
#define BCM53324_A0_MMU_XQ9m_NEXT_XQ_POINTER_ECCf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM53324_A0_MMU_XQ9m_NEXT_XQ_POINTERf_GET(r) ((((r).mmu_xq9[0]) >> 22) & 0x1ff)
#define BCM53324_A0_MMU_XQ9m_NEXT_XQ_POINTERf_SET(r,f) (r).mmu_xq9[0]=(((r).mmu_xq9[0] & ~((uint32_t)0x1ff << 22)) | ((((uint32_t)f) & 0x1ff) << 22))

/*
 * These macros can be used to access MMU_XQ9.
 *
 */
#define BCM53324_A0_READ_MMU_XQ9m(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_MMU_XQ9m,i,(m._mmu_xq9),1)
#define BCM53324_A0_WRITE_MMU_XQ9m(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_MMU_XQ9m,i,&(m._mmu_xq9),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_XQ9m BCM53324_A0_MMU_XQ9m
#define MMU_XQ9m_MIN BCM53324_A0_MMU_XQ9m_MIN
#define MMU_XQ9m_MAX BCM53324_A0_MMU_XQ9m_MAX
#define MMU_XQ9m_CMAX(u) BCM53324_A0_MMU_XQ9m_CMAX(u)
#define MMU_XQ9m_SIZE BCM53324_A0_MMU_XQ9m_SIZE
typedef BCM53324_A0_MMU_XQ9m_t MMU_XQ9m_t;
#define MMU_XQ9m_CLR BCM53324_A0_MMU_XQ9m_CLR
#define MMU_XQ9m_SET BCM53324_A0_MMU_XQ9m_SET
#define MMU_XQ9m_GET BCM53324_A0_MMU_XQ9m_GET
#define MMU_XQ9m_DATAf_GET BCM53324_A0_MMU_XQ9m_DATAf_GET
#define MMU_XQ9m_DATAf_SET BCM53324_A0_MMU_XQ9m_DATAf_SET
#define MMU_XQ9m_PARITY_0f_GET BCM53324_A0_MMU_XQ9m_PARITY_0f_GET
#define MMU_XQ9m_PARITY_0f_SET BCM53324_A0_MMU_XQ9m_PARITY_0f_SET
#define MMU_XQ9m_PARITY_DATAf_GET BCM53324_A0_MMU_XQ9m_PARITY_DATAf_GET
#define MMU_XQ9m_PARITY_DATAf_SET BCM53324_A0_MMU_XQ9m_PARITY_DATAf_SET
#define MMU_XQ9m_L2f_GET BCM53324_A0_MMU_XQ9m_L2f_GET
#define MMU_XQ9m_L2f_SET BCM53324_A0_MMU_XQ9m_L2f_SET
#define MMU_XQ9m_PURGEf_GET BCM53324_A0_MMU_XQ9m_PURGEf_GET
#define MMU_XQ9m_PURGEf_SET BCM53324_A0_MMU_XQ9m_PURGEf_SET
#define MMU_XQ9m_PKT_PTRf_GET BCM53324_A0_MMU_XQ9m_PKT_PTRf_GET
#define MMU_XQ9m_PKT_PTRf_SET BCM53324_A0_MMU_XQ9m_PKT_PTRf_SET
#define MMU_XQ9m_IMIRRORf_GET BCM53324_A0_MMU_XQ9m_IMIRRORf_GET
#define MMU_XQ9m_IMIRRORf_SET BCM53324_A0_MMU_XQ9m_IMIRRORf_SET
#define MMU_XQ9m_EMIRRORf_GET BCM53324_A0_MMU_XQ9m_EMIRRORf_GET
#define MMU_XQ9m_EMIRRORf_SET BCM53324_A0_MMU_XQ9m_EMIRRORf_SET
#define MMU_XQ9m_NEXT_POINTERf_GET BCM53324_A0_MMU_XQ9m_NEXT_POINTERf_GET
#define MMU_XQ9m_NEXT_POINTERf_SET BCM53324_A0_MMU_XQ9m_NEXT_POINTERf_SET
#define MMU_XQ9m_NEXT_XQ_POINTER_ECCf_GET BCM53324_A0_MMU_XQ9m_NEXT_XQ_POINTER_ECCf_GET
#define MMU_XQ9m_NEXT_XQ_POINTER_ECCf_SET BCM53324_A0_MMU_XQ9m_NEXT_XQ_POINTER_ECCf_SET
#define MMU_XQ9m_NEXT_XQ_POINTERf_GET BCM53324_A0_MMU_XQ9m_NEXT_XQ_POINTERf_GET
#define MMU_XQ9m_NEXT_XQ_POINTERf_SET BCM53324_A0_MMU_XQ9m_NEXT_XQ_POINTERf_SET
#define READ_MMU_XQ9m BCM53324_A0_READ_MMU_XQ9m
#define WRITE_MMU_XQ9m BCM53324_A0_WRITE_MMU_XQ9m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_MMU_XQ9m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  NONUCAST_TRUNK_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Multicast and Broadcast Trunk Block Mask Table. Index is constructed in Sw1 from packet fields.
 * SIZE:     25
 * FIELDS:
 *     BLOCK_MASK       Multicast/broadcast trunk block mask
 *     BLOCK_MASK_LO    Multicast/broadcast trunk block mask
 *
 ******************************************************************************/
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm 0x0f790000

#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_MIN 0
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_MAX 15
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) 15
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_SIZE 4

/*
 * This structure should be used to declare and program NONUCAST_TRUNK_BLOCK_MASK.
 *
 */
typedef union BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_s {
	uint32_t v[1];
	uint32_t nonucast_trunk_block_mask[1];
	uint32_t _nonucast_trunk_block_mask;
} BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_t;

#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_CLR(r) (r).nonucast_trunk_block_mask[0] = 0
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_SET(r,d) (r).nonucast_trunk_block_mask[0] = d
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_GET(r) (r).nonucast_trunk_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET(r) (((r).nonucast_trunk_block_mask[0]) & 0x1ffffff)
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET(r,f) (r).nonucast_trunk_block_mask[0]=(((r).nonucast_trunk_block_mask[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_GET(r) (((r).nonucast_trunk_block_mask[0]) & 0x1ffffff)
#define BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_SET(r,f) (r).nonucast_trunk_block_mask[0]=(((r).nonucast_trunk_block_mask[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access NONUCAST_TRUNK_BLOCK_MASK.
 *
 */
#define BCM53324_A0_READ_NONUCAST_TRUNK_BLOCK_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm,i,(m._nonucast_trunk_block_mask),1)
#define BCM53324_A0_WRITE_NONUCAST_TRUNK_BLOCK_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm,i,&(m._nonucast_trunk_block_mask),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NONUCAST_TRUNK_BLOCK_MASKm BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm
#define NONUCAST_TRUNK_BLOCK_MASKm_MIN BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_MIN
#define NONUCAST_TRUNK_BLOCK_MASKm_MAX BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_MAX
#define NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u)
#define NONUCAST_TRUNK_BLOCK_MASKm_SIZE BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_SIZE
typedef BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_t NONUCAST_TRUNK_BLOCK_MASKm_t;
#define NONUCAST_TRUNK_BLOCK_MASKm_CLR BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_CLR
#define NONUCAST_TRUNK_BLOCK_MASKm_SET BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_SET
#define NONUCAST_TRUNK_BLOCK_MASKm_GET BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_GET BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_SET BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASK_LOf_SET
#define READ_NONUCAST_TRUNK_BLOCK_MASKm BCM53324_A0_READ_NONUCAST_TRUNK_BLOCK_MASKm
#define WRITE_NONUCAST_TRUNK_BLOCK_MASKm BCM53324_A0_WRITE_NONUCAST_TRUNK_BLOCK_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_NONUCAST_TRUNK_BLOCK_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PAUSE_CONTROL
 * BLOCKS:   GPORT0
 * DESC:     PAUSE frame timer control register
 * SIZE:     32
 * FIELDS:
 *     VALUE            Each bit in this register represents 512 bit times independent of the port speed. Values of 0 and 1 are illegal.
 *     ENABLE           Enable Extra Pause Frames.
 *
 ******************************************************************************/
#define BCM53324_A0_PAUSE_CONTROLr 0x000001cc

#define BCM53324_A0_PAUSE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CONTROL.
 *
 */
typedef union BCM53324_A0_PAUSE_CONTROLr_s {
	uint32_t v[1];
	uint32_t pause_control[1];
	uint32_t _pause_control;
} BCM53324_A0_PAUSE_CONTROLr_t;

#define BCM53324_A0_PAUSE_CONTROLr_CLR(r) (r).pause_control[0] = 0
#define BCM53324_A0_PAUSE_CONTROLr_SET(r,d) (r).pause_control[0] = d
#define BCM53324_A0_PAUSE_CONTROLr_GET(r) (r).pause_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PAUSE_CONTROLr_VALUEf_GET(r) (((r).pause_control[0]) & 0x1ffff)
#define BCM53324_A0_PAUSE_CONTROLr_VALUEf_SET(r,f) (r).pause_control[0]=(((r).pause_control[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM53324_A0_PAUSE_CONTROLr_ENABLEf_GET(r) ((((r).pause_control[0]) >> 17) & 0x1)
#define BCM53324_A0_PAUSE_CONTROLr_ENABLEf_SET(r,f) (r).pause_control[0]=(((r).pause_control[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))

/*
 * These macros can be used to access PAUSE_CONTROL.
 *
 */
#define BCM53324_A0_READ_PAUSE_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_PAUSE_CONTROLr,(r._pause_control))
#define BCM53324_A0_WRITE_PAUSE_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_PAUSE_CONTROLr,&(r._pause_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CONTROLr BCM53324_A0_PAUSE_CONTROLr
#define PAUSE_CONTROLr_SIZE BCM53324_A0_PAUSE_CONTROLr_SIZE
typedef BCM53324_A0_PAUSE_CONTROLr_t PAUSE_CONTROLr_t;
#define PAUSE_CONTROLr_CLR BCM53324_A0_PAUSE_CONTROLr_CLR
#define PAUSE_CONTROLr_SET BCM53324_A0_PAUSE_CONTROLr_SET
#define PAUSE_CONTROLr_GET BCM53324_A0_PAUSE_CONTROLr_GET
#define PAUSE_CONTROLr_VALUEf_GET BCM53324_A0_PAUSE_CONTROLr_VALUEf_GET
#define PAUSE_CONTROLr_VALUEf_SET BCM53324_A0_PAUSE_CONTROLr_VALUEf_SET
#define PAUSE_CONTROLr_ENABLEf_GET BCM53324_A0_PAUSE_CONTROLr_ENABLEf_GET
#define PAUSE_CONTROLr_ENABLEf_SET BCM53324_A0_PAUSE_CONTROLr_ENABLEf_SET
#define READ_PAUSE_CONTROLr BCM53324_A0_READ_PAUSE_CONTROLr
#define WRITE_PAUSE_CONTROLr BCM53324_A0_WRITE_PAUSE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PAUSE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PAUSE_QUANT
 * BLOCKS:   GPORT0
 * DESC:     Receive Pause Quanta.
 * SIZE:     32
 * FIELDS:
 *     STAD2            16-Bit value, sets, in increment of 512 Ethernet bit times, the pause quanta used in each Pause Frame sent to the remote Ethernet device.
 *
 ******************************************************************************/
#define BCM53324_A0_PAUSE_QUANTr 0x00000106

#define BCM53324_A0_PAUSE_QUANTr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_QUANT.
 *
 */
typedef union BCM53324_A0_PAUSE_QUANTr_s {
	uint32_t v[1];
	uint32_t pause_quant[1];
	uint32_t _pause_quant;
} BCM53324_A0_PAUSE_QUANTr_t;

#define BCM53324_A0_PAUSE_QUANTr_CLR(r) (r).pause_quant[0] = 0
#define BCM53324_A0_PAUSE_QUANTr_SET(r,d) (r).pause_quant[0] = d
#define BCM53324_A0_PAUSE_QUANTr_GET(r) (r).pause_quant[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PAUSE_QUANTr_STAD2f_GET(r) (((r).pause_quant[0]) & 0xffff)
#define BCM53324_A0_PAUSE_QUANTr_STAD2f_SET(r,f) (r).pause_quant[0]=(((r).pause_quant[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PAUSE_QUANT.
 *
 */
#define BCM53324_A0_READ_PAUSE_QUANTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_PAUSE_QUANTr,(r._pause_quant))
#define BCM53324_A0_WRITE_PAUSE_QUANTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_PAUSE_QUANTr,&(r._pause_quant))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_QUANTr BCM53324_A0_PAUSE_QUANTr
#define PAUSE_QUANTr_SIZE BCM53324_A0_PAUSE_QUANTr_SIZE
typedef BCM53324_A0_PAUSE_QUANTr_t PAUSE_QUANTr_t;
#define PAUSE_QUANTr_CLR BCM53324_A0_PAUSE_QUANTr_CLR
#define PAUSE_QUANTr_SET BCM53324_A0_PAUSE_QUANTr_SET
#define PAUSE_QUANTr_GET BCM53324_A0_PAUSE_QUANTr_GET
#define PAUSE_QUANTr_STAD2f_GET BCM53324_A0_PAUSE_QUANTr_STAD2f_GET
#define PAUSE_QUANTr_STAD2f_SET BCM53324_A0_PAUSE_QUANTr_STAD2f_SET
#define READ_PAUSE_QUANTr BCM53324_A0_READ_PAUSE_QUANTr
#define WRITE_PAUSE_QUANTr BCM53324_A0_WRITE_PAUSE_QUANTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PAUSE_QUANTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PER_PORT_AGE_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Per Port Aging Control Register
 * SIZE:     32
 * FIELDS:
 *     TGID_PORT        trunk group or port number
 *     MODULE_ID        module id. Needs to be Zeros
 *     VLAN_ID          vlan id
 *     PPA_MODE         indicates selection criteria, deletion versus replacement
 *     EXCL_STATIC      exclude static entries from deletion and replacement
 *     START            initiate per port aging
 *     COMPLETE         signal per port aging is complete
 *
 ******************************************************************************/
#define BCM53324_A0_PER_PORT_AGE_CONTROLr 0x00780004

#define BCM53324_A0_PER_PORT_AGE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PER_PORT_AGE_CONTROL.
 *
 */
typedef union BCM53324_A0_PER_PORT_AGE_CONTROLr_s {
	uint32_t v[1];
	uint32_t per_port_age_control[1];
	uint32_t _per_port_age_control;
} BCM53324_A0_PER_PORT_AGE_CONTROLr_t;

#define BCM53324_A0_PER_PORT_AGE_CONTROLr_CLR(r) (r).per_port_age_control[0] = 0
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_SET(r,d) (r).per_port_age_control[0] = d
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_GET(r) (r).per_port_age_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_GET(r) (((r).per_port_age_control[0]) & 0x7f)
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_GET(r) ((((r).per_port_age_control[0]) >> 7) & 0xf)
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_GET(r) ((((r).per_port_age_control[0]) >> 11) & 0xfff)
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0xfff << 11)) | ((((uint32_t)f) & 0xfff) << 11))
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_GET(r) ((((r).per_port_age_control[0]) >> 23) & 0x7)
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x7 << 23)) | ((((uint32_t)f) & 0x7) << 23))
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET(r) ((((r).per_port_age_control[0]) >> 26) & 0x1)
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_STARTf_GET(r) ((((r).per_port_age_control[0]) >> 27) & 0x1)
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_STARTf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_GET(r) ((((r).per_port_age_control[0]) >> 28) & 0x1)
#define BCM53324_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access PER_PORT_AGE_CONTROL.
 *
 */
#define BCM53324_A0_READ_PER_PORT_AGE_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_PER_PORT_AGE_CONTROLr,(r._per_port_age_control))
#define BCM53324_A0_WRITE_PER_PORT_AGE_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_PER_PORT_AGE_CONTROLr,&(r._per_port_age_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PER_PORT_AGE_CONTROLr BCM53324_A0_PER_PORT_AGE_CONTROLr
#define PER_PORT_AGE_CONTROLr_SIZE BCM53324_A0_PER_PORT_AGE_CONTROLr_SIZE
typedef BCM53324_A0_PER_PORT_AGE_CONTROLr_t PER_PORT_AGE_CONTROLr_t;
#define PER_PORT_AGE_CONTROLr_CLR BCM53324_A0_PER_PORT_AGE_CONTROLr_CLR
#define PER_PORT_AGE_CONTROLr_SET BCM53324_A0_PER_PORT_AGE_CONTROLr_SET
#define PER_PORT_AGE_CONTROLr_GET BCM53324_A0_PER_PORT_AGE_CONTROLr_GET
#define PER_PORT_AGE_CONTROLr_TGID_PORTf_GET BCM53324_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_GET
#define PER_PORT_AGE_CONTROLr_TGID_PORTf_SET BCM53324_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_SET
#define PER_PORT_AGE_CONTROLr_MODULE_IDf_GET BCM53324_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_GET
#define PER_PORT_AGE_CONTROLr_MODULE_IDf_SET BCM53324_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_SET
#define PER_PORT_AGE_CONTROLr_VLAN_IDf_GET BCM53324_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_GET
#define PER_PORT_AGE_CONTROLr_VLAN_IDf_SET BCM53324_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_SET
#define PER_PORT_AGE_CONTROLr_PPA_MODEf_GET BCM53324_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_GET
#define PER_PORT_AGE_CONTROLr_PPA_MODEf_SET BCM53324_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_SET
#define PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET BCM53324_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET
#define PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET BCM53324_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET
#define PER_PORT_AGE_CONTROLr_STARTf_GET BCM53324_A0_PER_PORT_AGE_CONTROLr_STARTf_GET
#define PER_PORT_AGE_CONTROLr_STARTf_SET BCM53324_A0_PER_PORT_AGE_CONTROLr_STARTf_SET
#define PER_PORT_AGE_CONTROLr_COMPLETEf_GET BCM53324_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_GET
#define PER_PORT_AGE_CONTROLr_COMPLETEf_SET BCM53324_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_SET
#define READ_PER_PORT_AGE_CONTROLr BCM53324_A0_READ_PER_PORT_AGE_CONTROLr
#define WRITE_PER_PORT_AGE_CONTROLr BCM53324_A0_WRITE_PER_PORT_AGE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PER_PORT_AGE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PER_PORT_REPL_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Per-Port-Aging Replacement Register
 * SIZE:     32
 * FIELDS:
 *     PORT_TGID        Port_TGID value to be used in replacment.
 *     MODULE_ID        Module_Id value to be used in replacement.
 *
 ******************************************************************************/
#define BCM53324_A0_PER_PORT_REPL_CONTROLr 0x06780000

#define BCM53324_A0_PER_PORT_REPL_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PER_PORT_REPL_CONTROL.
 *
 */
typedef union BCM53324_A0_PER_PORT_REPL_CONTROLr_s {
	uint32_t v[1];
	uint32_t per_port_repl_control[1];
	uint32_t _per_port_repl_control;
} BCM53324_A0_PER_PORT_REPL_CONTROLr_t;

#define BCM53324_A0_PER_PORT_REPL_CONTROLr_CLR(r) (r).per_port_repl_control[0] = 0
#define BCM53324_A0_PER_PORT_REPL_CONTROLr_SET(r,d) (r).per_port_repl_control[0] = d
#define BCM53324_A0_PER_PORT_REPL_CONTROLr_GET(r) (r).per_port_repl_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET(r) (((r).per_port_repl_control[0]) & 0x7f)
#define BCM53324_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET(r,f) (r).per_port_repl_control[0]=(((r).per_port_repl_control[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53324_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_GET(r) ((((r).per_port_repl_control[0]) >> 7) & 0xf)
#define BCM53324_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_SET(r,f) (r).per_port_repl_control[0]=(((r).per_port_repl_control[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))

/*
 * These macros can be used to access PER_PORT_REPL_CONTROL.
 *
 */
#define BCM53324_A0_READ_PER_PORT_REPL_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_PER_PORT_REPL_CONTROLr,(r._per_port_repl_control))
#define BCM53324_A0_WRITE_PER_PORT_REPL_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_PER_PORT_REPL_CONTROLr,&(r._per_port_repl_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PER_PORT_REPL_CONTROLr BCM53324_A0_PER_PORT_REPL_CONTROLr
#define PER_PORT_REPL_CONTROLr_SIZE BCM53324_A0_PER_PORT_REPL_CONTROLr_SIZE
typedef BCM53324_A0_PER_PORT_REPL_CONTROLr_t PER_PORT_REPL_CONTROLr_t;
#define PER_PORT_REPL_CONTROLr_CLR BCM53324_A0_PER_PORT_REPL_CONTROLr_CLR
#define PER_PORT_REPL_CONTROLr_SET BCM53324_A0_PER_PORT_REPL_CONTROLr_SET
#define PER_PORT_REPL_CONTROLr_GET BCM53324_A0_PER_PORT_REPL_CONTROLr_GET
#define PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET BCM53324_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET
#define PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET BCM53324_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET
#define PER_PORT_REPL_CONTROLr_MODULE_IDf_GET BCM53324_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_GET
#define PER_PORT_REPL_CONTROLr_MODULE_IDf_SET BCM53324_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_SET
#define READ_PER_PORT_REPL_CONTROLr BCM53324_A0_READ_PER_PORT_REPL_CONTROLr
#define WRITE_PER_PORT_REPL_CONTROLr BCM53324_A0_WRITE_PER_PORT_REPL_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PER_PORT_REPL_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PKTAGINGLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     AGINGLIMITCOS0   Package aging timer limit for cos 0.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS1   Package aging timer limit for cos 1.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS2   Package aging timer limit for cos 2.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *     AGINGLIMITCOS3   Package aging timer limit for cos 3.Valid number from 0 to 5 to select durations stay in switch. Do not set value to 6 or 7 this may cause packet early aging. 
 *
 ******************************************************************************/
#define BCM53324_A0_PKTAGINGLIMITr 0x00680011

#define BCM53324_A0_PKTAGINGLIMITr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGLIMIT.
 *
 */
typedef union BCM53324_A0_PKTAGINGLIMITr_s {
	uint32_t v[1];
	uint32_t pktaginglimit[1];
	uint32_t _pktaginglimit;
} BCM53324_A0_PKTAGINGLIMITr_t;

#define BCM53324_A0_PKTAGINGLIMITr_CLR(r) (r).pktaginglimit[0] = 0
#define BCM53324_A0_PKTAGINGLIMITr_SET(r,d) (r).pktaginglimit[0] = d
#define BCM53324_A0_PKTAGINGLIMITr_GET(r) (r).pktaginglimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_GET(r) (((r).pktaginglimit[0]) & 0x7)
#define BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_GET(r) ((((r).pktaginglimit[0]) >> 3) & 0x7)
#define BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_GET(r) ((((r).pktaginglimit[0]) >> 6) & 0x7)
#define BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_GET(r) ((((r).pktaginglimit[0]) >> 9) & 0x7)
#define BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))

/*
 * These macros can be used to access PKTAGINGLIMIT.
 *
 */
#define BCM53324_A0_READ_PKTAGINGLIMITr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_PKTAGINGLIMITr,(r._pktaginglimit))
#define BCM53324_A0_WRITE_PKTAGINGLIMITr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_PKTAGINGLIMITr,&(r._pktaginglimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTAGINGLIMITr BCM53324_A0_PKTAGINGLIMITr
#define PKTAGINGLIMITr_SIZE BCM53324_A0_PKTAGINGLIMITr_SIZE
typedef BCM53324_A0_PKTAGINGLIMITr_t PKTAGINGLIMITr_t;
#define PKTAGINGLIMITr_CLR BCM53324_A0_PKTAGINGLIMITr_CLR
#define PKTAGINGLIMITr_SET BCM53324_A0_PKTAGINGLIMITr_SET
#define PKTAGINGLIMITr_GET BCM53324_A0_PKTAGINGLIMITr_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS0f_GET BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS0f_SET BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS1f_GET BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS1f_SET BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS2f_GET BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS2f_SET BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS3f_GET BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS3f_SET BCM53324_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_SET
#define READ_PKTAGINGLIMITr BCM53324_A0_READ_PKTAGINGLIMITr
#define WRITE_PKTAGINGLIMITr BCM53324_A0_WRITE_PKTAGINGLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PKTAGINGLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PKTAGINGTIMER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     DURATIONSELECT   13 bits aging interval duration select registers. Duration select determines the interval at which the age timergets incremented. After DURATIONSELECT number of clock timer ticks (pulses) the age timer will be incremented by 1.Packet aging function is disabled when set this register to 0.Packet aging function is disabled by default after power-on reset.
 *     AGINGTICKSEL     Select Aging tick clock source.0: 125us clock pulse.1: 500ms clock pulse
 *
 ******************************************************************************/
#define BCM53324_A0_PKTAGINGTIMERr 0x00680010

#define BCM53324_A0_PKTAGINGTIMERr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGTIMER.
 *
 */
typedef union BCM53324_A0_PKTAGINGTIMERr_s {
	uint32_t v[1];
	uint32_t pktagingtimer[1];
	uint32_t _pktagingtimer;
} BCM53324_A0_PKTAGINGTIMERr_t;

#define BCM53324_A0_PKTAGINGTIMERr_CLR(r) (r).pktagingtimer[0] = 0
#define BCM53324_A0_PKTAGINGTIMERr_SET(r,d) (r).pktagingtimer[0] = d
#define BCM53324_A0_PKTAGINGTIMERr_GET(r) (r).pktagingtimer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PKTAGINGTIMERr_DURATIONSELECTf_GET(r) (((r).pktagingtimer[0]) & 0x1fff)
#define BCM53324_A0_PKTAGINGTIMERr_DURATIONSELECTf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM53324_A0_PKTAGINGTIMERr_AGINGTICKSELf_GET(r) ((((r).pktagingtimer[0]) >> 13) & 0x1)
#define BCM53324_A0_PKTAGINGTIMERr_AGINGTICKSELf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access PKTAGINGTIMER.
 *
 */
#define BCM53324_A0_READ_PKTAGINGTIMERr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_PKTAGINGTIMERr,(r._pktagingtimer))
#define BCM53324_A0_WRITE_PKTAGINGTIMERr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_PKTAGINGTIMERr,&(r._pktagingtimer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTAGINGTIMERr BCM53324_A0_PKTAGINGTIMERr
#define PKTAGINGTIMERr_SIZE BCM53324_A0_PKTAGINGTIMERr_SIZE
typedef BCM53324_A0_PKTAGINGTIMERr_t PKTAGINGTIMERr_t;
#define PKTAGINGTIMERr_CLR BCM53324_A0_PKTAGINGTIMERr_CLR
#define PKTAGINGTIMERr_SET BCM53324_A0_PKTAGINGTIMERr_SET
#define PKTAGINGTIMERr_GET BCM53324_A0_PKTAGINGTIMERr_GET
#define PKTAGINGTIMERr_DURATIONSELECTf_GET BCM53324_A0_PKTAGINGTIMERr_DURATIONSELECTf_GET
#define PKTAGINGTIMERr_DURATIONSELECTf_SET BCM53324_A0_PKTAGINGTIMERr_DURATIONSELECTf_SET
#define PKTAGINGTIMERr_AGINGTICKSELf_GET BCM53324_A0_PKTAGINGTIMERr_AGINGTICKSELf_GET
#define PKTAGINGTIMERr_AGINGTICKSELf_SET BCM53324_A0_PKTAGINGTIMERr_AGINGTICKSELf_SET
#define READ_PKTAGINGTIMERr BCM53324_A0_READ_PKTAGINGTIMERr
#define WRITE_PKTAGINGTIMERr BCM53324_A0_WRITE_PKTAGINGTIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PKTAGINGTIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PORT_BRIDGE_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Bitmap of ports with port_bridge enabled
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of all XGE ports with port_bridge enabled. DO NOT include HiGig ports
 *
 ******************************************************************************/
#define BCM53324_A0_PORT_BRIDGE_BMAPr 0x0f78012b

#define BCM53324_A0_PORT_BRIDGE_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program PORT_BRIDGE_BMAP.
 *
 */
typedef union BCM53324_A0_PORT_BRIDGE_BMAPr_s {
	uint32_t v[1];
	uint32_t port_bridge_bmap[1];
	uint32_t _port_bridge_bmap;
} BCM53324_A0_PORT_BRIDGE_BMAPr_t;

#define BCM53324_A0_PORT_BRIDGE_BMAPr_CLR(r) (r).port_bridge_bmap[0] = 0
#define BCM53324_A0_PORT_BRIDGE_BMAPr_SET(r,d) (r).port_bridge_bmap[0] = d
#define BCM53324_A0_PORT_BRIDGE_BMAPr_GET(r) (r).port_bridge_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PORT_BRIDGE_BMAPr_BITMAPf_GET(r) (((r).port_bridge_bmap[0]) & 0x1ffffff)
#define BCM53324_A0_PORT_BRIDGE_BMAPr_BITMAPf_SET(r,f) (r).port_bridge_bmap[0]=(((r).port_bridge_bmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access PORT_BRIDGE_BMAP.
 *
 */
#define BCM53324_A0_READ_PORT_BRIDGE_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_PORT_BRIDGE_BMAPr,(r._port_bridge_bmap))
#define BCM53324_A0_WRITE_PORT_BRIDGE_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_PORT_BRIDGE_BMAPr,&(r._port_bridge_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_BRIDGE_BMAPr BCM53324_A0_PORT_BRIDGE_BMAPr
#define PORT_BRIDGE_BMAPr_SIZE BCM53324_A0_PORT_BRIDGE_BMAPr_SIZE
typedef BCM53324_A0_PORT_BRIDGE_BMAPr_t PORT_BRIDGE_BMAPr_t;
#define PORT_BRIDGE_BMAPr_CLR BCM53324_A0_PORT_BRIDGE_BMAPr_CLR
#define PORT_BRIDGE_BMAPr_SET BCM53324_A0_PORT_BRIDGE_BMAPr_SET
#define PORT_BRIDGE_BMAPr_GET BCM53324_A0_PORT_BRIDGE_BMAPr_GET
#define PORT_BRIDGE_BMAPr_BITMAPf_GET BCM53324_A0_PORT_BRIDGE_BMAPr_BITMAPf_GET
#define PORT_BRIDGE_BMAPr_BITMAPf_SET BCM53324_A0_PORT_BRIDGE_BMAPr_BITMAPf_SET
#define READ_PORT_BRIDGE_BMAPr BCM53324_A0_READ_PORT_BRIDGE_BMAPr
#define WRITE_PORT_BRIDGE_BMAPr BCM53324_A0_WRITE_PORT_BRIDGE_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PORT_BRIDGE_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  PORT_OR_TRUNK_MAC_ACTION
 * BLOCKS:   IPIPE
 * DESC:     Contains actions for Mac Limit Feature. Indexed with the indicies from MAC_LIMIT_TRUNK_MAP_TABLE or MAC_LIMIT_PORT_MAP_TABLE
 * SIZE:     2
 * FIELDS:
 *     OVER_LIMIT_TOCPU the copy to CPU action control bit used when the PORT_TRUNK_MAC_COUNT exceeds the PORT_TRUNK_MAC_LIMIT
 *     OVER_LIMIT_DROP  the drop action control bit used when the PORT_TRUNK_MAC_COUNT exceeds the PORT_TRUNK_MAC_LIMIT
 *
 ******************************************************************************/
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm 0x0c720000

#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_MIN 0
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_MAX 32
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_CMAX(u) 32
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_SIZE 1

/*
 * This structure should be used to declare and program PORT_OR_TRUNK_MAC_ACTION.
 *
 */
typedef union BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_s {
	uint32_t v[1];
	uint32_t port_or_trunk_mac_action[1];
	uint32_t _port_or_trunk_mac_action;
} BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_t;

#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_CLR(r) (r).port_or_trunk_mac_action[0] = 0
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_SET(r,d) (r).port_or_trunk_mac_action[0] = d
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_GET(r) (r).port_or_trunk_mac_action[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_GET(r) (((r).port_or_trunk_mac_action[0]) & 0x1)
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_SET(r,f) (r).port_or_trunk_mac_action[0]=(((r).port_or_trunk_mac_action[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_GET(r) ((((r).port_or_trunk_mac_action[0]) >> 1) & 0x1)
#define BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_SET(r,f) (r).port_or_trunk_mac_action[0]=(((r).port_or_trunk_mac_action[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access PORT_OR_TRUNK_MAC_ACTION.
 *
 */
#define BCM53324_A0_READ_PORT_OR_TRUNK_MAC_ACTIONm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm,i,(m._port_or_trunk_mac_action),1)
#define BCM53324_A0_WRITE_PORT_OR_TRUNK_MAC_ACTIONm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm,i,&(m._port_or_trunk_mac_action),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_OR_TRUNK_MAC_ACTIONm BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm
#define PORT_OR_TRUNK_MAC_ACTIONm_MIN BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_MIN
#define PORT_OR_TRUNK_MAC_ACTIONm_MAX BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_MAX
#define PORT_OR_TRUNK_MAC_ACTIONm_CMAX(u) BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_CMAX(u)
#define PORT_OR_TRUNK_MAC_ACTIONm_SIZE BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_SIZE
typedef BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_t PORT_OR_TRUNK_MAC_ACTIONm_t;
#define PORT_OR_TRUNK_MAC_ACTIONm_CLR BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_CLR
#define PORT_OR_TRUNK_MAC_ACTIONm_SET BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_SET
#define PORT_OR_TRUNK_MAC_ACTIONm_GET BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_GET
#define PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_GET BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_GET
#define PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_SET BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_TOCPUf_SET
#define PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_GET BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_GET
#define PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_SET BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm_OVER_LIMIT_DROPf_SET
#define READ_PORT_OR_TRUNK_MAC_ACTIONm BCM53324_A0_READ_PORT_OR_TRUNK_MAC_ACTIONm
#define WRITE_PORT_OR_TRUNK_MAC_ACTIONm BCM53324_A0_WRITE_PORT_OR_TRUNK_MAC_ACTIONm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PORT_OR_TRUNK_MAC_ACTIONm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  PORT_OR_TRUNK_MAC_COUNT
 * BLOCKS:   IPIPE
 * DESC:     TABLE for per port /LAG MAC counts . Indexed using values obtained from Mapping Tables.
 * SIZE:     14
 * FIELDS:
 *     PORT_TRUNK_MAC_COUNT Table which has the per port/LAG MAC COUNTs that are updated by the H/W. Instead of having seperate counts/limits on per port and per LAG (TRUNK GROUP) basis, Raptor implements one set of 54 counts/limits. Each ingress port and TRUNK Group can be mapped to one of the 54 counts/limits using TRUNK/PORT mapping tables
 *
 ******************************************************************************/
#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm 0x067a0000

#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_MIN 0
#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_MAX 32
#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_CMAX(u) 32
#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_SIZE 2

/*
 * This structure should be used to declare and program PORT_OR_TRUNK_MAC_COUNT.
 *
 */
typedef union BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_s {
	uint32_t v[1];
	uint32_t port_or_trunk_mac_count[1];
	uint32_t _port_or_trunk_mac_count;
} BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_t;

#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_CLR(r) (r).port_or_trunk_mac_count[0] = 0
#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_SET(r,d) (r).port_or_trunk_mac_count[0] = d
#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_GET(r) (r).port_or_trunk_mac_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_GET(r) (((r).port_or_trunk_mac_count[0]) & 0x3fff)
#define BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_SET(r,f) (r).port_or_trunk_mac_count[0]=(((r).port_or_trunk_mac_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PORT_OR_TRUNK_MAC_COUNT.
 *
 */
#define BCM53324_A0_READ_PORT_OR_TRUNK_MAC_COUNTm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm,i,(m._port_or_trunk_mac_count),1)
#define BCM53324_A0_WRITE_PORT_OR_TRUNK_MAC_COUNTm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm,i,&(m._port_or_trunk_mac_count),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_OR_TRUNK_MAC_COUNTm BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm
#define PORT_OR_TRUNK_MAC_COUNTm_MIN BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_MIN
#define PORT_OR_TRUNK_MAC_COUNTm_MAX BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_MAX
#define PORT_OR_TRUNK_MAC_COUNTm_CMAX(u) BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_CMAX(u)
#define PORT_OR_TRUNK_MAC_COUNTm_SIZE BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_SIZE
typedef BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_t PORT_OR_TRUNK_MAC_COUNTm_t;
#define PORT_OR_TRUNK_MAC_COUNTm_CLR BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_CLR
#define PORT_OR_TRUNK_MAC_COUNTm_SET BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_SET
#define PORT_OR_TRUNK_MAC_COUNTm_GET BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_GET
#define PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_GET BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_GET
#define PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_SET BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm_PORT_TRUNK_MAC_COUNTf_SET
#define READ_PORT_OR_TRUNK_MAC_COUNTm BCM53324_A0_READ_PORT_OR_TRUNK_MAC_COUNTm
#define WRITE_PORT_OR_TRUNK_MAC_COUNTm BCM53324_A0_WRITE_PORT_OR_TRUNK_MAC_COUNTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PORT_OR_TRUNK_MAC_COUNTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  PORT_OR_TRUNK_MAC_LIMIT
 * BLOCKS:   IPIPE
 * DESC:     the system MAC count limit value. Indexed using values obtained from Mapping Tables.
 * SIZE:     14
 * FIELDS:
 *     PORT_TRUNK_MAC_LIMIT The system MAC count limit value that needs to be programmed by the user
 *
 ******************************************************************************/
#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm 0x067b0000

#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_MIN 0
#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_MAX 32
#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_CMAX(u) 32
#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_SIZE 2

/*
 * This structure should be used to declare and program PORT_OR_TRUNK_MAC_LIMIT.
 *
 */
typedef union BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_s {
	uint32_t v[1];
	uint32_t port_or_trunk_mac_limit[1];
	uint32_t _port_or_trunk_mac_limit;
} BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_t;

#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_CLR(r) (r).port_or_trunk_mac_limit[0] = 0
#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_SET(r,d) (r).port_or_trunk_mac_limit[0] = d
#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_GET(r) (r).port_or_trunk_mac_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_GET(r) (((r).port_or_trunk_mac_limit[0]) & 0x3fff)
#define BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_SET(r,f) (r).port_or_trunk_mac_limit[0]=(((r).port_or_trunk_mac_limit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PORT_OR_TRUNK_MAC_LIMIT.
 *
 */
#define BCM53324_A0_READ_PORT_OR_TRUNK_MAC_LIMITm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm,i,(m._port_or_trunk_mac_limit),1)
#define BCM53324_A0_WRITE_PORT_OR_TRUNK_MAC_LIMITm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm,i,&(m._port_or_trunk_mac_limit),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_OR_TRUNK_MAC_LIMITm BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm
#define PORT_OR_TRUNK_MAC_LIMITm_MIN BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_MIN
#define PORT_OR_TRUNK_MAC_LIMITm_MAX BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_MAX
#define PORT_OR_TRUNK_MAC_LIMITm_CMAX(u) BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_CMAX(u)
#define PORT_OR_TRUNK_MAC_LIMITm_SIZE BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_SIZE
typedef BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_t PORT_OR_TRUNK_MAC_LIMITm_t;
#define PORT_OR_TRUNK_MAC_LIMITm_CLR BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_CLR
#define PORT_OR_TRUNK_MAC_LIMITm_SET BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_SET
#define PORT_OR_TRUNK_MAC_LIMITm_GET BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_GET
#define PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_GET BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_GET
#define PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_SET BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm_PORT_TRUNK_MAC_LIMITf_SET
#define READ_PORT_OR_TRUNK_MAC_LIMITm BCM53324_A0_READ_PORT_OR_TRUNK_MAC_LIMITm
#define WRITE_PORT_OR_TRUNK_MAC_LIMITm BCM53324_A0_WRITE_PORT_OR_TRUNK_MAC_LIMITm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PORT_OR_TRUNK_MAC_LIMITm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  PORT_TAB
 * BLOCKS:   IPIPE
 * DESC:     Port Table. Indexed with Ingress Port Number.
 * SIZE:     74
 * FIELDS:
 *     FILTER_ENABLE    Enable Filtering
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable
 *     CML              CPU managed learning
 *     PORT_PRI         Port default priority
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     PORT_VID         Port VLAN
 *     HIGIG_PACKET     Port is HiGig port. THIS FIELD MUST BE PROGRAMMED to 0 \(ZERO\) for Hawk_Eye device
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module. THIS MUST BE PROGRAMMED to 0 (ZERO) for Hawk_Eye device
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs)
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     MODPORT_TABLE_SEL To Select results from multiple modport tables
 *     IGNORE_MODID_LKUPS To ignore the look up results from the module id based tables. This is used for passthru pkts with modid greater than 16.
 *     REMOVE_HG_HDR_SRC_PORT If set to 1, do not forward the pkt to the non-trunk (i.e., not LAG) source port in module header when the MH.SRC_MODID is same as ING_CONFIG.MY_MODID. NOTE: If module header's source port is a trunk (LAG) port, the pkts are not forwarded to its LAG members irrespective of this control bit
 *     ALLOW_SRC_MOD    When set, packets whose source modid is equal to my_modid are not dropped
 *     CFI_AS_CNG       Indicates for ING_OUTER_TPID[3] to ING_OUTER_TPID[0] if the CFI bit in thepacket indicates CNG
 *     USE_INNER_PRI    If set, use the packet's inner priority (only applicable to UNI ports)
 *     OUTER_TPID_ENABLE Indicates for ING_OUTER_TPID[3] to ING_OUTER_TPID[0] if the TPID field should be used for parsing
 *     OUTER_TPID_VERIFY If set, indicates to verify the packet's outer TPID matches the VLAN tables TPID value
 *     USE_INCOMING_DOT1P If set, preserve incoming 802.1p priority in the packet
 *     TRUST_INCOMING_VID If set, trust incoming outer and inner VLAN tags.  NOTE: If VT_ENABLE is set, the incoming outer and inner VLAN tags are trusted regardless of the setting of this bit.
 *     VT_MISS_DROP     VLAN translation miss drop
 *     VT_ENABLE        VLAN translation enable
 *     LOCAL_SW_DISABLE When set, local switching is disabled
 *     FP_PORT_SELECT_TYPE Controls whether PORT_FIELD_SEL_INDEX1 or PORT_FIELD_SEL_INDEX0 is selected as the input into the FP_PORT_FIELD_SELECT table
 *     IPMC_DO_VLAN     used for SGV Lookup
 *     V6IPMC_ENABLE    IPv6 IPMC enable
 *     V4IPMC_ENABLE    IPv4 IPMC enable
 *     V6IPMC_L2_ENABLE IPv6 IPMC L2 enable
 *     V4IPMC_L2_ENABLE IPv4 IPMC L2 enable
 *     VRF_ID           VRF_ID used if port-based VRF ID assignment is enabled
 *     VRF_PORT_ENABLE  The VRF_ID from the PORT_TABLE table will be used instead of the VRF_ID from the VLAN table
 *     IEEE_802_1AS_ENABLE All the EAV processing will be qualified with this bit. Symantically similar as Time Stamping enable TS_ENABLE
 *
 ******************************************************************************/
#define BCM53324_A0_PORT_TABm 0x01700000

#define BCM53324_A0_PORT_TABm_MIN 0
#define BCM53324_A0_PORT_TABm_MAX 24
#define BCM53324_A0_PORT_TABm_CMAX(u) 24
#define BCM53324_A0_PORT_TABm_SIZE 10

/*
 * This structure should be used to declare and program PORT_TAB.
 *
 */
typedef union BCM53324_A0_PORT_TABm_s {
	uint32_t v[3];
	uint32_t port_tab[3];
	uint32_t _port_tab;
} BCM53324_A0_PORT_TABm_t;

#define BCM53324_A0_PORT_TABm_CLR(r) CDK_MEMSET(&((r)._port_tab), 0, sizeof(BCM53324_A0_PORT_TABm_t))
#define BCM53324_A0_PORT_TABm_SET(r,i,d) (r).port_tab[i] = d
#define BCM53324_A0_PORT_TABm_GET(r,i) (r).port_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PORT_TABm_FILTER_ENABLEf_GET(r) (((r).port_tab[0]) & 0x1)
#define BCM53324_A0_PORT_TABm_FILTER_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_PORT_TABm_TRUST_DSCP_V4f_GET(r) ((((r).port_tab[0]) >> 1) & 0x1)
#define BCM53324_A0_PORT_TABm_TRUST_DSCP_V4f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_PORT_TABm_TRUST_DSCP_V6f_GET(r) ((((r).port_tab[0]) >> 2) & 0x1)
#define BCM53324_A0_PORT_TABm_TRUST_DSCP_V6f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_PORT_TABm_EN_IFILTERf_GET(r) ((((r).port_tab[0]) >> 3) & 0x1)
#define BCM53324_A0_PORT_TABm_EN_IFILTERf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_PORT_TABm_MIRRORf_GET(r) ((((r).port_tab[0]) >> 4) & 0x1)
#define BCM53324_A0_PORT_TABm_MIRRORf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_PORT_TABm_CMLf_GET(r) ((((r).port_tab[0]) >> 5) & 0x7)
#define BCM53324_A0_PORT_TABm_CMLf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53324_A0_PORT_TABm_PORT_PRIf_GET(r) ((((r).port_tab[0]) >> 8) & 0x7)
#define BCM53324_A0_PORT_TABm_PORT_PRIf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53324_A0_PORT_TABm_V6L3_ENABLEf_GET(r) ((((r).port_tab[0]) >> 11) & 0x1)
#define BCM53324_A0_PORT_TABm_V6L3_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_PORT_TABm_V4L3_ENABLEf_GET(r) ((((r).port_tab[0]) >> 12) & 0x1)
#define BCM53324_A0_PORT_TABm_V4L3_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_PORT_TABm_DROP_BPDUf_GET(r) ((((r).port_tab[0]) >> 13) & 0x1)
#define BCM53324_A0_PORT_TABm_DROP_BPDUf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_PORT_TABm_PORT_DIS_TAGf_GET(r) ((((r).port_tab[0]) >> 14) & 0x1)
#define BCM53324_A0_PORT_TABm_PORT_DIS_TAGf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_PORT_TABm_PORT_DIS_UNTAGf_GET(r) ((((r).port_tab[0]) >> 15) & 0x1)
#define BCM53324_A0_PORT_TABm_PORT_DIS_UNTAGf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_PORT_TABm_PASS_CONTROL_FRAMESf_GET(r) ((((r).port_tab[0]) >> 16) & 0x1)
#define BCM53324_A0_PORT_TABm_PASS_CONTROL_FRAMESf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).port_tab[0]) >> 17) & 0x1)
#define BCM53324_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).port_tab[0]) >> 18) & 0x1)
#define BCM53324_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_PORT_TABm_PORT_VIDf_GET(r) ((((r).port_tab[0]) >> 19) & 0xfff)
#define BCM53324_A0_PORT_TABm_PORT_VIDf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0xfff << 19)) | ((((uint32_t)f) & 0xfff) << 19))
#define BCM53324_A0_PORT_TABm_HIGIG_PACKETf_GET(r) ((((r).port_tab[0]) >> 31) & 0x1)
#define BCM53324_A0_PORT_TABm_HIGIG_PACKETf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53324_A0_PORT_TABm_NNI_PORTf_GET(r) (((r).port_tab[1]) & 0x1)
#define BCM53324_A0_PORT_TABm_NNI_PORTf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).port_tab[1]) >> 1) & 0x1)
#define BCM53324_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_PORT_TABm_MY_MODIDf_GET(r) ((((r).port_tab[1]) >> 2) & 0xf)
#define BCM53324_A0_PORT_TABm_MY_MODIDf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM53324_A0_PORT_TABm_VLAN_PRECEDENCEf_GET(r) ((((r).port_tab[1]) >> 6) & 0x1)
#define BCM53324_A0_PORT_TABm_VLAN_PRECEDENCEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_PORT_TABm_PORT_BRIDGEf_GET(r) ((((r).port_tab[1]) >> 7) & 0x1)
#define BCM53324_A0_PORT_TABm_PORT_BRIDGEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_PORT_TABm_MODPORT_TABLE_SELf_GET(r) ((((r).port_tab[1]) >> 8) & 0x3)
#define BCM53324_A0_PORT_TABm_MODPORT_TABLE_SELf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53324_A0_PORT_TABm_IGNORE_MODID_LKUPSf_GET(r) ((((r).port_tab[1]) >> 10) & 0x1)
#define BCM53324_A0_PORT_TABm_IGNORE_MODID_LKUPSf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET(r) ((((r).port_tab[1]) >> 11) & 0x1)
#define BCM53324_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_PORT_TABm_ALLOW_SRC_MODf_GET(r) ((((r).port_tab[1]) >> 12) & 0x1)
#define BCM53324_A0_PORT_TABm_ALLOW_SRC_MODf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_PORT_TABm_CFI_AS_CNGf_GET(r) ((((r).port_tab[1]) >> 13) & 0xf)
#define BCM53324_A0_PORT_TABm_CFI_AS_CNGf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0xf << 13)) | ((((uint32_t)f) & 0xf) << 13))
#define BCM53324_A0_PORT_TABm_USE_INNER_PRIf_GET(r) ((((r).port_tab[1]) >> 17) & 0x1)
#define BCM53324_A0_PORT_TABm_USE_INNER_PRIf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_PORT_TABm_OUTER_TPID_ENABLEf_GET(r) ((((r).port_tab[1]) >> 18) & 0xf)
#define BCM53324_A0_PORT_TABm_OUTER_TPID_ENABLEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0xf << 18)) | ((((uint32_t)f) & 0xf) << 18))
#define BCM53324_A0_PORT_TABm_OUTER_TPID_VERIFYf_GET(r) ((((r).port_tab[1]) >> 22) & 0x1)
#define BCM53324_A0_PORT_TABm_OUTER_TPID_VERIFYf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_PORT_TABm_USE_INCOMING_DOT1Pf_GET(r) ((((r).port_tab[1]) >> 23) & 0x1)
#define BCM53324_A0_PORT_TABm_USE_INCOMING_DOT1Pf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_PORT_TABm_TRUST_INCOMING_VIDf_GET(r) ((((r).port_tab[1]) >> 24) & 0x1)
#define BCM53324_A0_PORT_TABm_TRUST_INCOMING_VIDf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_PORT_TABm_VT_MISS_DROPf_GET(r) ((((r).port_tab[1]) >> 25) & 0x1)
#define BCM53324_A0_PORT_TABm_VT_MISS_DROPf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_PORT_TABm_VT_ENABLEf_GET(r) ((((r).port_tab[1]) >> 26) & 0x1)
#define BCM53324_A0_PORT_TABm_VT_ENABLEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_PORT_TABm_LOCAL_SW_DISABLEf_GET(r) ((((r).port_tab[1]) >> 27) & 0x1)
#define BCM53324_A0_PORT_TABm_LOCAL_SW_DISABLEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_PORT_TABm_FP_PORT_SELECT_TYPEf_GET(r) ((((r).port_tab[1]) >> 28) & 0x1)
#define BCM53324_A0_PORT_TABm_FP_PORT_SELECT_TYPEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53324_A0_PORT_TABm_IPMC_DO_VLANf_GET(r) ((((r).port_tab[1]) >> 29) & 0x1)
#define BCM53324_A0_PORT_TABm_IPMC_DO_VLANf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_PORT_TABm_V6IPMC_ENABLEf_GET(r) ((((r).port_tab[1]) >> 30) & 0x1)
#define BCM53324_A0_PORT_TABm_V6IPMC_ENABLEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_PORT_TABm_V4IPMC_ENABLEf_GET(r) ((((r).port_tab[1]) >> 31) & 0x1)
#define BCM53324_A0_PORT_TABm_V4IPMC_ENABLEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53324_A0_PORT_TABm_V6IPMC_L2_ENABLEf_GET(r) (((r).port_tab[2]) & 0x1)
#define BCM53324_A0_PORT_TABm_V6IPMC_L2_ENABLEf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_PORT_TABm_V4IPMC_L2_ENABLEf_GET(r) ((((r).port_tab[2]) >> 1) & 0x1)
#define BCM53324_A0_PORT_TABm_V4IPMC_L2_ENABLEf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_PORT_TABm_VRF_IDf_GET(r) ((((r).port_tab[2]) >> 2) & 0x3f)
#define BCM53324_A0_PORT_TABm_VRF_IDf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM53324_A0_PORT_TABm_VRF_PORT_ENABLEf_GET(r) ((((r).port_tab[2]) >> 8) & 0x1)
#define BCM53324_A0_PORT_TABm_VRF_PORT_ENABLEf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_PORT_TABm_IEEE_802_1AS_ENABLEf_GET(r) ((((r).port_tab[2]) >> 9) & 0x1)
#define BCM53324_A0_PORT_TABm_IEEE_802_1AS_ENABLEf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access PORT_TAB.
 *
 */
#define BCM53324_A0_READ_PORT_TABm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_PORT_TABm,i,(m._port_tab),3)
#define BCM53324_A0_WRITE_PORT_TABm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_PORT_TABm,i,&(m._port_tab),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_TABm BCM53324_A0_PORT_TABm
#define PORT_TABm_MIN BCM53324_A0_PORT_TABm_MIN
#define PORT_TABm_MAX BCM53324_A0_PORT_TABm_MAX
#define PORT_TABm_CMAX(u) BCM53324_A0_PORT_TABm_CMAX(u)
#define PORT_TABm_SIZE BCM53324_A0_PORT_TABm_SIZE
typedef BCM53324_A0_PORT_TABm_t PORT_TABm_t;
#define PORT_TABm_CLR BCM53324_A0_PORT_TABm_CLR
#define PORT_TABm_SET BCM53324_A0_PORT_TABm_SET
#define PORT_TABm_GET BCM53324_A0_PORT_TABm_GET
#define PORT_TABm_FILTER_ENABLEf_GET BCM53324_A0_PORT_TABm_FILTER_ENABLEf_GET
#define PORT_TABm_FILTER_ENABLEf_SET BCM53324_A0_PORT_TABm_FILTER_ENABLEf_SET
#define PORT_TABm_TRUST_DSCP_V4f_GET BCM53324_A0_PORT_TABm_TRUST_DSCP_V4f_GET
#define PORT_TABm_TRUST_DSCP_V4f_SET BCM53324_A0_PORT_TABm_TRUST_DSCP_V4f_SET
#define PORT_TABm_TRUST_DSCP_V6f_GET BCM53324_A0_PORT_TABm_TRUST_DSCP_V6f_GET
#define PORT_TABm_TRUST_DSCP_V6f_SET BCM53324_A0_PORT_TABm_TRUST_DSCP_V6f_SET
#define PORT_TABm_EN_IFILTERf_GET BCM53324_A0_PORT_TABm_EN_IFILTERf_GET
#define PORT_TABm_EN_IFILTERf_SET BCM53324_A0_PORT_TABm_EN_IFILTERf_SET
#define PORT_TABm_MIRRORf_GET BCM53324_A0_PORT_TABm_MIRRORf_GET
#define PORT_TABm_MIRRORf_SET BCM53324_A0_PORT_TABm_MIRRORf_SET
#define PORT_TABm_CMLf_GET BCM53324_A0_PORT_TABm_CMLf_GET
#define PORT_TABm_CMLf_SET BCM53324_A0_PORT_TABm_CMLf_SET
#define PORT_TABm_PORT_PRIf_GET BCM53324_A0_PORT_TABm_PORT_PRIf_GET
#define PORT_TABm_PORT_PRIf_SET BCM53324_A0_PORT_TABm_PORT_PRIf_SET
#define PORT_TABm_V6L3_ENABLEf_GET BCM53324_A0_PORT_TABm_V6L3_ENABLEf_GET
#define PORT_TABm_V6L3_ENABLEf_SET BCM53324_A0_PORT_TABm_V6L3_ENABLEf_SET
#define PORT_TABm_V4L3_ENABLEf_GET BCM53324_A0_PORT_TABm_V4L3_ENABLEf_GET
#define PORT_TABm_V4L3_ENABLEf_SET BCM53324_A0_PORT_TABm_V4L3_ENABLEf_SET
#define PORT_TABm_DROP_BPDUf_GET BCM53324_A0_PORT_TABm_DROP_BPDUf_GET
#define PORT_TABm_DROP_BPDUf_SET BCM53324_A0_PORT_TABm_DROP_BPDUf_SET
#define PORT_TABm_PORT_DIS_TAGf_GET BCM53324_A0_PORT_TABm_PORT_DIS_TAGf_GET
#define PORT_TABm_PORT_DIS_TAGf_SET BCM53324_A0_PORT_TABm_PORT_DIS_TAGf_SET
#define PORT_TABm_PORT_DIS_UNTAGf_GET BCM53324_A0_PORT_TABm_PORT_DIS_UNTAGf_GET
#define PORT_TABm_PORT_DIS_UNTAGf_SET BCM53324_A0_PORT_TABm_PORT_DIS_UNTAGf_SET
#define PORT_TABm_PASS_CONTROL_FRAMESf_GET BCM53324_A0_PORT_TABm_PASS_CONTROL_FRAMESf_GET
#define PORT_TABm_PASS_CONTROL_FRAMESf_SET BCM53324_A0_PORT_TABm_PASS_CONTROL_FRAMESf_SET
#define PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET BCM53324_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET
#define PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET BCM53324_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET
#define PORT_TABm_MAC_BASED_VID_ENABLEf_GET BCM53324_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_GET
#define PORT_TABm_MAC_BASED_VID_ENABLEf_SET BCM53324_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_SET
#define PORT_TABm_PORT_VIDf_GET BCM53324_A0_PORT_TABm_PORT_VIDf_GET
#define PORT_TABm_PORT_VIDf_SET BCM53324_A0_PORT_TABm_PORT_VIDf_SET
#define PORT_TABm_HIGIG_PACKETf_GET BCM53324_A0_PORT_TABm_HIGIG_PACKETf_GET
#define PORT_TABm_HIGIG_PACKETf_SET BCM53324_A0_PORT_TABm_HIGIG_PACKETf_SET
#define PORT_TABm_NNI_PORTf_GET BCM53324_A0_PORT_TABm_NNI_PORTf_GET
#define PORT_TABm_NNI_PORTf_SET BCM53324_A0_PORT_TABm_NNI_PORTf_SET
#define PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET BCM53324_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET
#define PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET BCM53324_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET
#define PORT_TABm_MY_MODIDf_GET BCM53324_A0_PORT_TABm_MY_MODIDf_GET
#define PORT_TABm_MY_MODIDf_SET BCM53324_A0_PORT_TABm_MY_MODIDf_SET
#define PORT_TABm_VLAN_PRECEDENCEf_GET BCM53324_A0_PORT_TABm_VLAN_PRECEDENCEf_GET
#define PORT_TABm_VLAN_PRECEDENCEf_SET BCM53324_A0_PORT_TABm_VLAN_PRECEDENCEf_SET
#define PORT_TABm_PORT_BRIDGEf_GET BCM53324_A0_PORT_TABm_PORT_BRIDGEf_GET
#define PORT_TABm_PORT_BRIDGEf_SET BCM53324_A0_PORT_TABm_PORT_BRIDGEf_SET
#define PORT_TABm_MODPORT_TABLE_SELf_GET BCM53324_A0_PORT_TABm_MODPORT_TABLE_SELf_GET
#define PORT_TABm_MODPORT_TABLE_SELf_SET BCM53324_A0_PORT_TABm_MODPORT_TABLE_SELf_SET
#define PORT_TABm_IGNORE_MODID_LKUPSf_GET BCM53324_A0_PORT_TABm_IGNORE_MODID_LKUPSf_GET
#define PORT_TABm_IGNORE_MODID_LKUPSf_SET BCM53324_A0_PORT_TABm_IGNORE_MODID_LKUPSf_SET
#define PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET BCM53324_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET
#define PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET BCM53324_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET
#define PORT_TABm_ALLOW_SRC_MODf_GET BCM53324_A0_PORT_TABm_ALLOW_SRC_MODf_GET
#define PORT_TABm_ALLOW_SRC_MODf_SET BCM53324_A0_PORT_TABm_ALLOW_SRC_MODf_SET
#define PORT_TABm_CFI_AS_CNGf_GET BCM53324_A0_PORT_TABm_CFI_AS_CNGf_GET
#define PORT_TABm_CFI_AS_CNGf_SET BCM53324_A0_PORT_TABm_CFI_AS_CNGf_SET
#define PORT_TABm_USE_INNER_PRIf_GET BCM53324_A0_PORT_TABm_USE_INNER_PRIf_GET
#define PORT_TABm_USE_INNER_PRIf_SET BCM53324_A0_PORT_TABm_USE_INNER_PRIf_SET
#define PORT_TABm_OUTER_TPID_ENABLEf_GET BCM53324_A0_PORT_TABm_OUTER_TPID_ENABLEf_GET
#define PORT_TABm_OUTER_TPID_ENABLEf_SET BCM53324_A0_PORT_TABm_OUTER_TPID_ENABLEf_SET
#define PORT_TABm_OUTER_TPID_VERIFYf_GET BCM53324_A0_PORT_TABm_OUTER_TPID_VERIFYf_GET
#define PORT_TABm_OUTER_TPID_VERIFYf_SET BCM53324_A0_PORT_TABm_OUTER_TPID_VERIFYf_SET
#define PORT_TABm_USE_INCOMING_DOT1Pf_GET BCM53324_A0_PORT_TABm_USE_INCOMING_DOT1Pf_GET
#define PORT_TABm_USE_INCOMING_DOT1Pf_SET BCM53324_A0_PORT_TABm_USE_INCOMING_DOT1Pf_SET
#define PORT_TABm_TRUST_INCOMING_VIDf_GET BCM53324_A0_PORT_TABm_TRUST_INCOMING_VIDf_GET
#define PORT_TABm_TRUST_INCOMING_VIDf_SET BCM53324_A0_PORT_TABm_TRUST_INCOMING_VIDf_SET
#define PORT_TABm_VT_MISS_DROPf_GET BCM53324_A0_PORT_TABm_VT_MISS_DROPf_GET
#define PORT_TABm_VT_MISS_DROPf_SET BCM53324_A0_PORT_TABm_VT_MISS_DROPf_SET
#define PORT_TABm_VT_ENABLEf_GET BCM53324_A0_PORT_TABm_VT_ENABLEf_GET
#define PORT_TABm_VT_ENABLEf_SET BCM53324_A0_PORT_TABm_VT_ENABLEf_SET
#define PORT_TABm_LOCAL_SW_DISABLEf_GET BCM53324_A0_PORT_TABm_LOCAL_SW_DISABLEf_GET
#define PORT_TABm_LOCAL_SW_DISABLEf_SET BCM53324_A0_PORT_TABm_LOCAL_SW_DISABLEf_SET
#define PORT_TABm_FP_PORT_SELECT_TYPEf_GET BCM53324_A0_PORT_TABm_FP_PORT_SELECT_TYPEf_GET
#define PORT_TABm_FP_PORT_SELECT_TYPEf_SET BCM53324_A0_PORT_TABm_FP_PORT_SELECT_TYPEf_SET
#define PORT_TABm_IPMC_DO_VLANf_GET BCM53324_A0_PORT_TABm_IPMC_DO_VLANf_GET
#define PORT_TABm_IPMC_DO_VLANf_SET BCM53324_A0_PORT_TABm_IPMC_DO_VLANf_SET
#define PORT_TABm_V6IPMC_ENABLEf_GET BCM53324_A0_PORT_TABm_V6IPMC_ENABLEf_GET
#define PORT_TABm_V6IPMC_ENABLEf_SET BCM53324_A0_PORT_TABm_V6IPMC_ENABLEf_SET
#define PORT_TABm_V4IPMC_ENABLEf_GET BCM53324_A0_PORT_TABm_V4IPMC_ENABLEf_GET
#define PORT_TABm_V4IPMC_ENABLEf_SET BCM53324_A0_PORT_TABm_V4IPMC_ENABLEf_SET
#define PORT_TABm_V6IPMC_L2_ENABLEf_GET BCM53324_A0_PORT_TABm_V6IPMC_L2_ENABLEf_GET
#define PORT_TABm_V6IPMC_L2_ENABLEf_SET BCM53324_A0_PORT_TABm_V6IPMC_L2_ENABLEf_SET
#define PORT_TABm_V4IPMC_L2_ENABLEf_GET BCM53324_A0_PORT_TABm_V4IPMC_L2_ENABLEf_GET
#define PORT_TABm_V4IPMC_L2_ENABLEf_SET BCM53324_A0_PORT_TABm_V4IPMC_L2_ENABLEf_SET
#define PORT_TABm_VRF_IDf_GET BCM53324_A0_PORT_TABm_VRF_IDf_GET
#define PORT_TABm_VRF_IDf_SET BCM53324_A0_PORT_TABm_VRF_IDf_SET
#define PORT_TABm_VRF_PORT_ENABLEf_GET BCM53324_A0_PORT_TABm_VRF_PORT_ENABLEf_GET
#define PORT_TABm_VRF_PORT_ENABLEf_SET BCM53324_A0_PORT_TABm_VRF_PORT_ENABLEf_SET
#define PORT_TABm_IEEE_802_1AS_ENABLEf_GET BCM53324_A0_PORT_TABm_IEEE_802_1AS_ENABLEf_GET
#define PORT_TABm_IEEE_802_1AS_ENABLEf_SET BCM53324_A0_PORT_TABm_IEEE_802_1AS_ENABLEf_SET
#define READ_PORT_TABm BCM53324_A0_READ_PORT_TABm
#define WRITE_PORT_TABm BCM53324_A0_WRITE_PORT_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PORT_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PPPEMPTYSTATUS
 * BLOCKS:   MMU
 * DESC:     Displays the PPP Empty status
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      PPP for port is empty
 *
 ******************************************************************************/
#define BCM53324_A0_PPPEMPTYSTATUSr 0x00680000

#define BCM53324_A0_PPPEMPTYSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program PPPEMPTYSTATUS.
 *
 */
typedef union BCM53324_A0_PPPEMPTYSTATUSr_s {
	uint32_t v[1];
	uint32_t pppemptystatus[1];
	uint32_t _pppemptystatus;
} BCM53324_A0_PPPEMPTYSTATUSr_t;

#define BCM53324_A0_PPPEMPTYSTATUSr_CLR(r) (r).pppemptystatus[0] = 0
#define BCM53324_A0_PPPEMPTYSTATUSr_SET(r,d) (r).pppemptystatus[0] = d
#define BCM53324_A0_PPPEMPTYSTATUSr_GET(r) (r).pppemptystatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_GET(r) (((r).pppemptystatus[0]) & 0x1ffffff)
#define BCM53324_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_SET(r,f) (r).pppemptystatus[0]=(((r).pppemptystatus[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access PPPEMPTYSTATUS.
 *
 */
#define BCM53324_A0_READ_PPPEMPTYSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_PPPEMPTYSTATUSr,(r._pppemptystatus))
#define BCM53324_A0_WRITE_PPPEMPTYSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_PPPEMPTYSTATUSr,&(r._pppemptystatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PPPEMPTYSTATUSr BCM53324_A0_PPPEMPTYSTATUSr
#define PPPEMPTYSTATUSr_SIZE BCM53324_A0_PPPEMPTYSTATUSr_SIZE
typedef BCM53324_A0_PPPEMPTYSTATUSr_t PPPEMPTYSTATUSr_t;
#define PPPEMPTYSTATUSr_CLR BCM53324_A0_PPPEMPTYSTATUSr_CLR
#define PPPEMPTYSTATUSr_SET BCM53324_A0_PPPEMPTYSTATUSr_SET
#define PPPEMPTYSTATUSr_GET BCM53324_A0_PPPEMPTYSTATUSr_GET
#define PPPEMPTYSTATUSr_PORT_BITMAPf_GET BCM53324_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_GET
#define PPPEMPTYSTATUSr_PORT_BITMAPf_SET BCM53324_A0_PPPEMPTYSTATUSr_PORT_BITMAPf_SET
#define READ_PPPEMPTYSTATUSr BCM53324_A0_READ_PPPEMPTYSTATUSr
#define WRITE_PPPEMPTYSTATUSr BCM53324_A0_WRITE_PPPEMPTYSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PPPEMPTYSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PPP_CTRL
 * BLOCKS:   GPORT0
 * DESC:     PPP control register
 * SIZE:     32
 * FIELDS:
 *     PPP_EN_TX        Enables the PPP-Tx functionality .
 *     PPP_EN_RX        Enables the PPP-Rx functionality.
 *     FORCE_PPP_XON    Instructs MAC to send xon message to all classes of service.
 *
 ******************************************************************************/
#define BCM53324_A0_PPP_CTRLr 0x000001d0

#define BCM53324_A0_PPP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PPP_CTRL.
 *
 */
typedef union BCM53324_A0_PPP_CTRLr_s {
	uint32_t v[1];
	uint32_t ppp_ctrl[1];
	uint32_t _ppp_ctrl;
} BCM53324_A0_PPP_CTRLr_t;

#define BCM53324_A0_PPP_CTRLr_CLR(r) (r).ppp_ctrl[0] = 0
#define BCM53324_A0_PPP_CTRLr_SET(r,d) (r).ppp_ctrl[0] = d
#define BCM53324_A0_PPP_CTRLr_GET(r) (r).ppp_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PPP_CTRLr_PPP_EN_TXf_GET(r) (((r).ppp_ctrl[0]) & 0x1)
#define BCM53324_A0_PPP_CTRLr_PPP_EN_TXf_SET(r,f) (r).ppp_ctrl[0]=(((r).ppp_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_PPP_CTRLr_PPP_EN_RXf_GET(r) ((((r).ppp_ctrl[0]) >> 1) & 0x1)
#define BCM53324_A0_PPP_CTRLr_PPP_EN_RXf_SET(r,f) (r).ppp_ctrl[0]=(((r).ppp_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_PPP_CTRLr_FORCE_PPP_XONf_GET(r) ((((r).ppp_ctrl[0]) >> 2) & 0x1)
#define BCM53324_A0_PPP_CTRLr_FORCE_PPP_XONf_SET(r,f) (r).ppp_ctrl[0]=(((r).ppp_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access PPP_CTRL.
 *
 */
#define BCM53324_A0_READ_PPP_CTRLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_PPP_CTRLr,(r._ppp_ctrl))
#define BCM53324_A0_WRITE_PPP_CTRLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_PPP_CTRLr,&(r._ppp_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PPP_CTRLr BCM53324_A0_PPP_CTRLr
#define PPP_CTRLr_SIZE BCM53324_A0_PPP_CTRLr_SIZE
typedef BCM53324_A0_PPP_CTRLr_t PPP_CTRLr_t;
#define PPP_CTRLr_CLR BCM53324_A0_PPP_CTRLr_CLR
#define PPP_CTRLr_SET BCM53324_A0_PPP_CTRLr_SET
#define PPP_CTRLr_GET BCM53324_A0_PPP_CTRLr_GET
#define PPP_CTRLr_PPP_EN_TXf_GET BCM53324_A0_PPP_CTRLr_PPP_EN_TXf_GET
#define PPP_CTRLr_PPP_EN_TXf_SET BCM53324_A0_PPP_CTRLr_PPP_EN_TXf_SET
#define PPP_CTRLr_PPP_EN_RXf_GET BCM53324_A0_PPP_CTRLr_PPP_EN_RXf_GET
#define PPP_CTRLr_PPP_EN_RXf_SET BCM53324_A0_PPP_CTRLr_PPP_EN_RXf_SET
#define PPP_CTRLr_FORCE_PPP_XONf_GET BCM53324_A0_PPP_CTRLr_FORCE_PPP_XONf_GET
#define PPP_CTRLr_FORCE_PPP_XONf_SET BCM53324_A0_PPP_CTRLr_FORCE_PPP_XONf_SET
#define READ_PPP_CTRLr BCM53324_A0_READ_PPP_CTRLr
#define WRITE_PPP_CTRLr BCM53324_A0_WRITE_PPP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PPP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PPP_REFRESH_CTRL
 * BLOCKS:   GPORT0
 * DESC:     PPP refresh control register
 * SIZE:     32
 * FIELDS:
 *     PPP_REFRESH_EN   Enables the PPP refresh functionality on the Tx side. When enabled, the MAC sends xoff on refresh counter becoming 0
 *     PPP_REFRESH_TIMER PPP refresh counter value.
 *
 ******************************************************************************/
#define BCM53324_A0_PPP_REFRESH_CTRLr 0x000001d1

#define BCM53324_A0_PPP_REFRESH_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program PPP_REFRESH_CTRL.
 *
 */
typedef union BCM53324_A0_PPP_REFRESH_CTRLr_s {
	uint32_t v[1];
	uint32_t ppp_refresh_ctrl[1];
	uint32_t _ppp_refresh_ctrl;
} BCM53324_A0_PPP_REFRESH_CTRLr_t;

#define BCM53324_A0_PPP_REFRESH_CTRLr_CLR(r) (r).ppp_refresh_ctrl[0] = 0
#define BCM53324_A0_PPP_REFRESH_CTRLr_SET(r,d) (r).ppp_refresh_ctrl[0] = d
#define BCM53324_A0_PPP_REFRESH_CTRLr_GET(r) (r).ppp_refresh_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PPP_REFRESH_CTRLr_PPP_REFRESH_ENf_GET(r) (((r).ppp_refresh_ctrl[0]) & 0x1)
#define BCM53324_A0_PPP_REFRESH_CTRLr_PPP_REFRESH_ENf_SET(r,f) (r).ppp_refresh_ctrl[0]=(((r).ppp_refresh_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_PPP_REFRESH_CTRLr_PPP_REFRESH_TIMERf_GET(r) ((((r).ppp_refresh_ctrl[0]) >> 16) & 0xffff)
#define BCM53324_A0_PPP_REFRESH_CTRLr_PPP_REFRESH_TIMERf_SET(r,f) (r).ppp_refresh_ctrl[0]=(((r).ppp_refresh_ctrl[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access PPP_REFRESH_CTRL.
 *
 */
#define BCM53324_A0_READ_PPP_REFRESH_CTRLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_PPP_REFRESH_CTRLr,(r._ppp_refresh_ctrl))
#define BCM53324_A0_WRITE_PPP_REFRESH_CTRLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_PPP_REFRESH_CTRLr,&(r._ppp_refresh_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PPP_REFRESH_CTRLr BCM53324_A0_PPP_REFRESH_CTRLr
#define PPP_REFRESH_CTRLr_SIZE BCM53324_A0_PPP_REFRESH_CTRLr_SIZE
typedef BCM53324_A0_PPP_REFRESH_CTRLr_t PPP_REFRESH_CTRLr_t;
#define PPP_REFRESH_CTRLr_CLR BCM53324_A0_PPP_REFRESH_CTRLr_CLR
#define PPP_REFRESH_CTRLr_SET BCM53324_A0_PPP_REFRESH_CTRLr_SET
#define PPP_REFRESH_CTRLr_GET BCM53324_A0_PPP_REFRESH_CTRLr_GET
#define PPP_REFRESH_CTRLr_PPP_REFRESH_ENf_GET BCM53324_A0_PPP_REFRESH_CTRLr_PPP_REFRESH_ENf_GET
#define PPP_REFRESH_CTRLr_PPP_REFRESH_ENf_SET BCM53324_A0_PPP_REFRESH_CTRLr_PPP_REFRESH_ENf_SET
#define PPP_REFRESH_CTRLr_PPP_REFRESH_TIMERf_GET BCM53324_A0_PPP_REFRESH_CTRLr_PPP_REFRESH_TIMERf_GET
#define PPP_REFRESH_CTRLr_PPP_REFRESH_TIMERf_SET BCM53324_A0_PPP_REFRESH_CTRLr_PPP_REFRESH_TIMERf_SET
#define READ_PPP_REFRESH_CTRLr BCM53324_A0_READ_PPP_REFRESH_CTRLr
#define WRITE_PPP_REFRESH_CTRLr BCM53324_A0_WRITE_PPP_REFRESH_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PPP_REFRESH_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PRIORITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Register that controls the generation of various priorities
 * SIZE:     32
 * FIELDS:
 *     SC_CPU_PRI_MODE  Specifies how the CPU priority of HiGig+ and HiGig2 system control packets will be generated.
 *     ALWAYS_APPLY_CPU_PRI_SEL If set, the internal priority of both the unicast and non-unicast packets will go through CPU_PRI_SEL mapping. If not set, the internal priority of only the non-unicast packets will go through CPU_PRI_SEL mapping.
 *
 ******************************************************************************/
#define BCM53324_A0_PRIORITY_CONTROLr 0x0f780133

#define BCM53324_A0_PRIORITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PRIORITY_CONTROL.
 *
 */
typedef union BCM53324_A0_PRIORITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t priority_control[1];
	uint32_t _priority_control;
} BCM53324_A0_PRIORITY_CONTROLr_t;

#define BCM53324_A0_PRIORITY_CONTROLr_CLR(r) (r).priority_control[0] = 0
#define BCM53324_A0_PRIORITY_CONTROLr_SET(r,d) (r).priority_control[0] = d
#define BCM53324_A0_PRIORITY_CONTROLr_GET(r) (r).priority_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET(r) (((r).priority_control[0]) & 0x1)
#define BCM53324_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET(r) ((((r).priority_control[0]) >> 1) & 0x1)
#define BCM53324_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access PRIORITY_CONTROL.
 *
 */
#define BCM53324_A0_READ_PRIORITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_PRIORITY_CONTROLr,(r._priority_control))
#define BCM53324_A0_WRITE_PRIORITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_PRIORITY_CONTROLr,&(r._priority_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRIORITY_CONTROLr BCM53324_A0_PRIORITY_CONTROLr
#define PRIORITY_CONTROLr_SIZE BCM53324_A0_PRIORITY_CONTROLr_SIZE
typedef BCM53324_A0_PRIORITY_CONTROLr_t PRIORITY_CONTROLr_t;
#define PRIORITY_CONTROLr_CLR BCM53324_A0_PRIORITY_CONTROLr_CLR
#define PRIORITY_CONTROLr_SET BCM53324_A0_PRIORITY_CONTROLr_SET
#define PRIORITY_CONTROLr_GET BCM53324_A0_PRIORITY_CONTROLr_GET
#define PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET BCM53324_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET
#define PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET BCM53324_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET
#define PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET BCM53324_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET
#define PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET BCM53324_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET
#define READ_PRIORITY_CONTROLr BCM53324_A0_READ_PRIORITY_CONTROLr
#define WRITE_PRIORITY_CONTROLr BCM53324_A0_WRITE_PRIORITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PRIORITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  PROTOCOL_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Protocol Packet Control Register
 * SIZE:     32
 * FIELDS:
 *     DHCP_PKT_TO_CPU  Send DHCP Packets to the CPU
 *     DHCP_PKT_DROP    Drop DHCP Packets
 *     ND_PKT_TO_CPU    Send ND Packets to the CPU
 *     ND_PKT_DROP      Drop ND Packets
 *     ARP_REQUEST_TO_CPU Send ARP Request Packets to the CPU
 *     ARP_REQUEST_DROP Drop ARP Request Packets
 *     ARP_REPLY_TO_CPU Send ARP Reply Packets to the CPU
 *     ARP_REPLY_DROP   Drop ARP Reply Packets
 *     TS_PKT_TO_CPU    Copy TS packets to CPU port if this bit is set.
 *     TS_FWD_ACTION    Forwarding of TS pkts as shown below: ,00 - Forward based on MAC-DA,01 - Dr op the packet.,10 - Flood the packet to the VLAN members,11 - Reserved)
 *     SRP_PKT_TO_CPU   Copy SRP packets to CPU port if this bit is set.
 *     SRP_FWD_ACTION   Forwarding of SRP pkts as shown below: ,00 - Forward based on MAC-DA,01 - Dr op the packet.,10 - Flood the packet to the VLAN members,11 - Reserved)
 *     MMRP_PKT_TO_CPU  Copy MMRP packets to CPU port if this bit is set.
 *     MMRP_FWD_ACTION  Forwarding of MMRP pkts as shown below: ,00 - Forward based on MAC-DA,01 - Dr op the packet.,10 - Flood the packet to the VLAN members,11 - Reserved)
 *
 ******************************************************************************/
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr 0x0c700006

#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PROTOCOL_PKT_CONTROL.
 *
 */
typedef union BCM53324_A0_PROTOCOL_PKT_CONTROLr_s {
	uint32_t v[1];
	uint32_t protocol_pkt_control[1];
	uint32_t _protocol_pkt_control;
} BCM53324_A0_PROTOCOL_PKT_CONTROLr_t;

#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_CLR(r) (r).protocol_pkt_control[0] = 0
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_SET(r,d) (r).protocol_pkt_control[0] = d
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_GET(r) (r).protocol_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET(r) (((r).protocol_pkt_control[0]) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 1) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 2) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 3) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 4) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 5) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 6) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 7) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_TS_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 8) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_TS_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_TS_FWD_ACTIONf_GET(r) ((((r).protocol_pkt_control[0]) >> 9) & 0x3)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_TS_FWD_ACTIONf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_SRP_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 11) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_SRP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_SRP_FWD_ACTIONf_GET(r) ((((r).protocol_pkt_control[0]) >> 12) & 0x3)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_SRP_FWD_ACTIONf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_MMRP_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 14) & 0x1)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_MMRP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_MMRP_FWD_ACTIONf_GET(r) ((((r).protocol_pkt_control[0]) >> 15) & 0x3)
#define BCM53324_A0_PROTOCOL_PKT_CONTROLr_MMRP_FWD_ACTIONf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x3 << 15)) | ((((uint32_t)f) & 0x3) << 15))

/*
 * These macros can be used to access PROTOCOL_PKT_CONTROL.
 *
 */
#define BCM53324_A0_READ_PROTOCOL_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_PROTOCOL_PKT_CONTROLr,(r._protocol_pkt_control))
#define BCM53324_A0_WRITE_PROTOCOL_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_PROTOCOL_PKT_CONTROLr,&(r._protocol_pkt_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTOCOL_PKT_CONTROLr BCM53324_A0_PROTOCOL_PKT_CONTROLr
#define PROTOCOL_PKT_CONTROLr_SIZE BCM53324_A0_PROTOCOL_PKT_CONTROLr_SIZE
typedef BCM53324_A0_PROTOCOL_PKT_CONTROLr_t PROTOCOL_PKT_CONTROLr_t;
#define PROTOCOL_PKT_CONTROLr_CLR BCM53324_A0_PROTOCOL_PKT_CONTROLr_CLR
#define PROTOCOL_PKT_CONTROLr_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_SET
#define PROTOCOL_PKT_CONTROLr_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_TS_PKT_TO_CPUf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_TS_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_TS_PKT_TO_CPUf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_TS_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_TS_FWD_ACTIONf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_TS_FWD_ACTIONf_GET
#define PROTOCOL_PKT_CONTROLr_TS_FWD_ACTIONf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_TS_FWD_ACTIONf_SET
#define PROTOCOL_PKT_CONTROLr_SRP_PKT_TO_CPUf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_SRP_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_SRP_PKT_TO_CPUf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_SRP_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_SRP_FWD_ACTIONf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_SRP_FWD_ACTIONf_GET
#define PROTOCOL_PKT_CONTROLr_SRP_FWD_ACTIONf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_SRP_FWD_ACTIONf_SET
#define PROTOCOL_PKT_CONTROLr_MMRP_PKT_TO_CPUf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_MMRP_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_MMRP_PKT_TO_CPUf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_MMRP_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_MMRP_FWD_ACTIONf_GET BCM53324_A0_PROTOCOL_PKT_CONTROLr_MMRP_FWD_ACTIONf_GET
#define PROTOCOL_PKT_CONTROLr_MMRP_FWD_ACTIONf_SET BCM53324_A0_PROTOCOL_PKT_CONTROLr_MMRP_FWD_ACTIONf_SET
#define READ_PROTOCOL_PKT_CONTROLr BCM53324_A0_READ_PROTOCOL_PKT_CONTROLr
#define WRITE_PROTOCOL_PKT_CONTROLr BCM53324_A0_WRITE_PROTOCOL_PKT_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_PROTOCOL_PKT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC0
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #0
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC0r 0x0f70000b

#define BCM53324_A0_RDBGC0r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC0.
 *
 */
typedef union BCM53324_A0_RDBGC0r_s {
	uint32_t v[1];
	uint32_t rdbgc0[1];
	uint32_t _rdbgc0;
} BCM53324_A0_RDBGC0r_t;

#define BCM53324_A0_RDBGC0r_CLR(r) (r).rdbgc0[0] = 0
#define BCM53324_A0_RDBGC0r_SET(r,d) (r).rdbgc0[0] = d
#define BCM53324_A0_RDBGC0r_GET(r) (r).rdbgc0[0]


/*
 * These macros can be used to access RDBGC0.
 *
 */
#define BCM53324_A0_READ_RDBGC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC0r,(r._rdbgc0))
#define BCM53324_A0_WRITE_RDBGC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC0r,&(r._rdbgc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC0r BCM53324_A0_RDBGC0r
#define RDBGC0r_SIZE BCM53324_A0_RDBGC0r_SIZE
typedef BCM53324_A0_RDBGC0r_t RDBGC0r_t;
#define RDBGC0r_CLR BCM53324_A0_RDBGC0r_CLR
#define RDBGC0r_SET BCM53324_A0_RDBGC0r_SET
#define RDBGC0r_GET BCM53324_A0_RDBGC0r_GET
#define READ_RDBGC0r BCM53324_A0_READ_RDBGC0r
#define WRITE_RDBGC0r BCM53324_A0_WRITE_RDBGC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC0_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #0 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC0_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC0_SELECTr 0x0f780020

#define BCM53324_A0_RDBGC0_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC0_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC0_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc0_select[1];
	uint32_t _rdbgc0_select;
} BCM53324_A0_RDBGC0_SELECTr_t;

#define BCM53324_A0_RDBGC0_SELECTr_CLR(r) (r).rdbgc0_select[0] = 0
#define BCM53324_A0_RDBGC0_SELECTr_SET(r,d) (r).rdbgc0_select[0] = d
#define BCM53324_A0_RDBGC0_SELECTr_GET(r) (r).rdbgc0_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC0_SELECTr_BITMAPf_GET(r) (((r).rdbgc0_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC0_SELECTr_BITMAPf_SET(r,f) (r).rdbgc0_select[0]=(((r).rdbgc0_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC0_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC0_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC0_SELECTr,(r._rdbgc0_select))
#define BCM53324_A0_WRITE_RDBGC0_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC0_SELECTr,&(r._rdbgc0_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC0_SELECTr BCM53324_A0_RDBGC0_SELECTr
#define RDBGC0_SELECTr_SIZE BCM53324_A0_RDBGC0_SELECTr_SIZE
typedef BCM53324_A0_RDBGC0_SELECTr_t RDBGC0_SELECTr_t;
#define RDBGC0_SELECTr_CLR BCM53324_A0_RDBGC0_SELECTr_CLR
#define RDBGC0_SELECTr_SET BCM53324_A0_RDBGC0_SELECTr_SET
#define RDBGC0_SELECTr_GET BCM53324_A0_RDBGC0_SELECTr_GET
#define RDBGC0_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC0_SELECTr_BITMAPf_GET
#define RDBGC0_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC0_SELECTr_BITMAPf_SET
#define READ_RDBGC0_SELECTr BCM53324_A0_READ_RDBGC0_SELECTr
#define WRITE_RDBGC0_SELECTr BCM53324_A0_WRITE_RDBGC0_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC0_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC1
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #1
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC1r 0x0f70000c

#define BCM53324_A0_RDBGC1r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC1.
 *
 */
typedef union BCM53324_A0_RDBGC1r_s {
	uint32_t v[1];
	uint32_t rdbgc1[1];
	uint32_t _rdbgc1;
} BCM53324_A0_RDBGC1r_t;

#define BCM53324_A0_RDBGC1r_CLR(r) (r).rdbgc1[0] = 0
#define BCM53324_A0_RDBGC1r_SET(r,d) (r).rdbgc1[0] = d
#define BCM53324_A0_RDBGC1r_GET(r) (r).rdbgc1[0]


/*
 * These macros can be used to access RDBGC1.
 *
 */
#define BCM53324_A0_READ_RDBGC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC1r,(r._rdbgc1))
#define BCM53324_A0_WRITE_RDBGC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC1r,&(r._rdbgc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC1r BCM53324_A0_RDBGC1r
#define RDBGC1r_SIZE BCM53324_A0_RDBGC1r_SIZE
typedef BCM53324_A0_RDBGC1r_t RDBGC1r_t;
#define RDBGC1r_CLR BCM53324_A0_RDBGC1r_CLR
#define RDBGC1r_SET BCM53324_A0_RDBGC1r_SET
#define RDBGC1r_GET BCM53324_A0_RDBGC1r_GET
#define READ_RDBGC1r BCM53324_A0_READ_RDBGC1r
#define WRITE_RDBGC1r BCM53324_A0_WRITE_RDBGC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC1_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #1 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC1_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC1_SELECTr 0x0f780021

#define BCM53324_A0_RDBGC1_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC1_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC1_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc1_select[1];
	uint32_t _rdbgc1_select;
} BCM53324_A0_RDBGC1_SELECTr_t;

#define BCM53324_A0_RDBGC1_SELECTr_CLR(r) (r).rdbgc1_select[0] = 0
#define BCM53324_A0_RDBGC1_SELECTr_SET(r,d) (r).rdbgc1_select[0] = d
#define BCM53324_A0_RDBGC1_SELECTr_GET(r) (r).rdbgc1_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC1_SELECTr_BITMAPf_GET(r) (((r).rdbgc1_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC1_SELECTr_BITMAPf_SET(r,f) (r).rdbgc1_select[0]=(((r).rdbgc1_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC1_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC1_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC1_SELECTr,(r._rdbgc1_select))
#define BCM53324_A0_WRITE_RDBGC1_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC1_SELECTr,&(r._rdbgc1_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC1_SELECTr BCM53324_A0_RDBGC1_SELECTr
#define RDBGC1_SELECTr_SIZE BCM53324_A0_RDBGC1_SELECTr_SIZE
typedef BCM53324_A0_RDBGC1_SELECTr_t RDBGC1_SELECTr_t;
#define RDBGC1_SELECTr_CLR BCM53324_A0_RDBGC1_SELECTr_CLR
#define RDBGC1_SELECTr_SET BCM53324_A0_RDBGC1_SELECTr_SET
#define RDBGC1_SELECTr_GET BCM53324_A0_RDBGC1_SELECTr_GET
#define RDBGC1_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC1_SELECTr_BITMAPf_GET
#define RDBGC1_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC1_SELECTr_BITMAPf_SET
#define READ_RDBGC1_SELECTr BCM53324_A0_READ_RDBGC1_SELECTr
#define WRITE_RDBGC1_SELECTr BCM53324_A0_WRITE_RDBGC1_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC1_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC2
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #2
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC2r 0x0f70000d

#define BCM53324_A0_RDBGC2r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC2.
 *
 */
typedef union BCM53324_A0_RDBGC2r_s {
	uint32_t v[1];
	uint32_t rdbgc2[1];
	uint32_t _rdbgc2;
} BCM53324_A0_RDBGC2r_t;

#define BCM53324_A0_RDBGC2r_CLR(r) (r).rdbgc2[0] = 0
#define BCM53324_A0_RDBGC2r_SET(r,d) (r).rdbgc2[0] = d
#define BCM53324_A0_RDBGC2r_GET(r) (r).rdbgc2[0]


/*
 * These macros can be used to access RDBGC2.
 *
 */
#define BCM53324_A0_READ_RDBGC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC2r,(r._rdbgc2))
#define BCM53324_A0_WRITE_RDBGC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC2r,&(r._rdbgc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC2r BCM53324_A0_RDBGC2r
#define RDBGC2r_SIZE BCM53324_A0_RDBGC2r_SIZE
typedef BCM53324_A0_RDBGC2r_t RDBGC2r_t;
#define RDBGC2r_CLR BCM53324_A0_RDBGC2r_CLR
#define RDBGC2r_SET BCM53324_A0_RDBGC2r_SET
#define RDBGC2r_GET BCM53324_A0_RDBGC2r_GET
#define READ_RDBGC2r BCM53324_A0_READ_RDBGC2r
#define WRITE_RDBGC2r BCM53324_A0_WRITE_RDBGC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC2_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #2 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC2_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC2_SELECTr 0x0f780022

#define BCM53324_A0_RDBGC2_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC2_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC2_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc2_select[1];
	uint32_t _rdbgc2_select;
} BCM53324_A0_RDBGC2_SELECTr_t;

#define BCM53324_A0_RDBGC2_SELECTr_CLR(r) (r).rdbgc2_select[0] = 0
#define BCM53324_A0_RDBGC2_SELECTr_SET(r,d) (r).rdbgc2_select[0] = d
#define BCM53324_A0_RDBGC2_SELECTr_GET(r) (r).rdbgc2_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC2_SELECTr_BITMAPf_GET(r) (((r).rdbgc2_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC2_SELECTr_BITMAPf_SET(r,f) (r).rdbgc2_select[0]=(((r).rdbgc2_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC2_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC2_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC2_SELECTr,(r._rdbgc2_select))
#define BCM53324_A0_WRITE_RDBGC2_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC2_SELECTr,&(r._rdbgc2_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC2_SELECTr BCM53324_A0_RDBGC2_SELECTr
#define RDBGC2_SELECTr_SIZE BCM53324_A0_RDBGC2_SELECTr_SIZE
typedef BCM53324_A0_RDBGC2_SELECTr_t RDBGC2_SELECTr_t;
#define RDBGC2_SELECTr_CLR BCM53324_A0_RDBGC2_SELECTr_CLR
#define RDBGC2_SELECTr_SET BCM53324_A0_RDBGC2_SELECTr_SET
#define RDBGC2_SELECTr_GET BCM53324_A0_RDBGC2_SELECTr_GET
#define RDBGC2_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC2_SELECTr_BITMAPf_GET
#define RDBGC2_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC2_SELECTr_BITMAPf_SET
#define READ_RDBGC2_SELECTr BCM53324_A0_READ_RDBGC2_SELECTr
#define WRITE_RDBGC2_SELECTr BCM53324_A0_WRITE_RDBGC2_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC2_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC3
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #3
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC3r 0x0f70000e

#define BCM53324_A0_RDBGC3r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC3.
 *
 */
typedef union BCM53324_A0_RDBGC3r_s {
	uint32_t v[1];
	uint32_t rdbgc3[1];
	uint32_t _rdbgc3;
} BCM53324_A0_RDBGC3r_t;

#define BCM53324_A0_RDBGC3r_CLR(r) (r).rdbgc3[0] = 0
#define BCM53324_A0_RDBGC3r_SET(r,d) (r).rdbgc3[0] = d
#define BCM53324_A0_RDBGC3r_GET(r) (r).rdbgc3[0]


/*
 * These macros can be used to access RDBGC3.
 *
 */
#define BCM53324_A0_READ_RDBGC3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC3r,(r._rdbgc3))
#define BCM53324_A0_WRITE_RDBGC3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC3r,&(r._rdbgc3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC3r BCM53324_A0_RDBGC3r
#define RDBGC3r_SIZE BCM53324_A0_RDBGC3r_SIZE
typedef BCM53324_A0_RDBGC3r_t RDBGC3r_t;
#define RDBGC3r_CLR BCM53324_A0_RDBGC3r_CLR
#define RDBGC3r_SET BCM53324_A0_RDBGC3r_SET
#define RDBGC3r_GET BCM53324_A0_RDBGC3r_GET
#define READ_RDBGC3r BCM53324_A0_READ_RDBGC3r
#define WRITE_RDBGC3r BCM53324_A0_WRITE_RDBGC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC3_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #3 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC3_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC3_SELECTr 0x0f780023

#define BCM53324_A0_RDBGC3_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC3_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC3_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc3_select[1];
	uint32_t _rdbgc3_select;
} BCM53324_A0_RDBGC3_SELECTr_t;

#define BCM53324_A0_RDBGC3_SELECTr_CLR(r) (r).rdbgc3_select[0] = 0
#define BCM53324_A0_RDBGC3_SELECTr_SET(r,d) (r).rdbgc3_select[0] = d
#define BCM53324_A0_RDBGC3_SELECTr_GET(r) (r).rdbgc3_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC3_SELECTr_BITMAPf_GET(r) (((r).rdbgc3_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC3_SELECTr_BITMAPf_SET(r,f) (r).rdbgc3_select[0]=(((r).rdbgc3_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC3_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC3_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC3_SELECTr,(r._rdbgc3_select))
#define BCM53324_A0_WRITE_RDBGC3_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC3_SELECTr,&(r._rdbgc3_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC3_SELECTr BCM53324_A0_RDBGC3_SELECTr
#define RDBGC3_SELECTr_SIZE BCM53324_A0_RDBGC3_SELECTr_SIZE
typedef BCM53324_A0_RDBGC3_SELECTr_t RDBGC3_SELECTr_t;
#define RDBGC3_SELECTr_CLR BCM53324_A0_RDBGC3_SELECTr_CLR
#define RDBGC3_SELECTr_SET BCM53324_A0_RDBGC3_SELECTr_SET
#define RDBGC3_SELECTr_GET BCM53324_A0_RDBGC3_SELECTr_GET
#define RDBGC3_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC3_SELECTr_BITMAPf_GET
#define RDBGC3_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC3_SELECTr_BITMAPf_SET
#define READ_RDBGC3_SELECTr BCM53324_A0_READ_RDBGC3_SELECTr
#define WRITE_RDBGC3_SELECTr BCM53324_A0_WRITE_RDBGC3_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC3_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC4
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #4
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC4r 0x0f70000f

#define BCM53324_A0_RDBGC4r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC4.
 *
 */
typedef union BCM53324_A0_RDBGC4r_s {
	uint32_t v[1];
	uint32_t rdbgc4[1];
	uint32_t _rdbgc4;
} BCM53324_A0_RDBGC4r_t;

#define BCM53324_A0_RDBGC4r_CLR(r) (r).rdbgc4[0] = 0
#define BCM53324_A0_RDBGC4r_SET(r,d) (r).rdbgc4[0] = d
#define BCM53324_A0_RDBGC4r_GET(r) (r).rdbgc4[0]


/*
 * These macros can be used to access RDBGC4.
 *
 */
#define BCM53324_A0_READ_RDBGC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC4r,(r._rdbgc4))
#define BCM53324_A0_WRITE_RDBGC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC4r,&(r._rdbgc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC4r BCM53324_A0_RDBGC4r
#define RDBGC4r_SIZE BCM53324_A0_RDBGC4r_SIZE
typedef BCM53324_A0_RDBGC4r_t RDBGC4r_t;
#define RDBGC4r_CLR BCM53324_A0_RDBGC4r_CLR
#define RDBGC4r_SET BCM53324_A0_RDBGC4r_SET
#define RDBGC4r_GET BCM53324_A0_RDBGC4r_GET
#define READ_RDBGC4r BCM53324_A0_READ_RDBGC4r
#define WRITE_RDBGC4r BCM53324_A0_WRITE_RDBGC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC4_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #4 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC4_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC4_SELECTr 0x0f780024

#define BCM53324_A0_RDBGC4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC4_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC4_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc4_select[1];
	uint32_t _rdbgc4_select;
} BCM53324_A0_RDBGC4_SELECTr_t;

#define BCM53324_A0_RDBGC4_SELECTr_CLR(r) (r).rdbgc4_select[0] = 0
#define BCM53324_A0_RDBGC4_SELECTr_SET(r,d) (r).rdbgc4_select[0] = d
#define BCM53324_A0_RDBGC4_SELECTr_GET(r) (r).rdbgc4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC4_SELECTr_BITMAPf_GET(r) (((r).rdbgc4_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC4_SELECTr_BITMAPf_SET(r,f) (r).rdbgc4_select[0]=(((r).rdbgc4_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC4_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC4_SELECTr,(r._rdbgc4_select))
#define BCM53324_A0_WRITE_RDBGC4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC4_SELECTr,&(r._rdbgc4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC4_SELECTr BCM53324_A0_RDBGC4_SELECTr
#define RDBGC4_SELECTr_SIZE BCM53324_A0_RDBGC4_SELECTr_SIZE
typedef BCM53324_A0_RDBGC4_SELECTr_t RDBGC4_SELECTr_t;
#define RDBGC4_SELECTr_CLR BCM53324_A0_RDBGC4_SELECTr_CLR
#define RDBGC4_SELECTr_SET BCM53324_A0_RDBGC4_SELECTr_SET
#define RDBGC4_SELECTr_GET BCM53324_A0_RDBGC4_SELECTr_GET
#define RDBGC4_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC4_SELECTr_BITMAPf_GET
#define RDBGC4_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC4_SELECTr_BITMAPf_SET
#define READ_RDBGC4_SELECTr BCM53324_A0_READ_RDBGC4_SELECTr
#define WRITE_RDBGC4_SELECTr BCM53324_A0_WRITE_RDBGC4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC5
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #5
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC5r 0x0f700010

#define BCM53324_A0_RDBGC5r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC5.
 *
 */
typedef union BCM53324_A0_RDBGC5r_s {
	uint32_t v[1];
	uint32_t rdbgc5[1];
	uint32_t _rdbgc5;
} BCM53324_A0_RDBGC5r_t;

#define BCM53324_A0_RDBGC5r_CLR(r) (r).rdbgc5[0] = 0
#define BCM53324_A0_RDBGC5r_SET(r,d) (r).rdbgc5[0] = d
#define BCM53324_A0_RDBGC5r_GET(r) (r).rdbgc5[0]


/*
 * These macros can be used to access RDBGC5.
 *
 */
#define BCM53324_A0_READ_RDBGC5r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC5r,(r._rdbgc5))
#define BCM53324_A0_WRITE_RDBGC5r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC5r,&(r._rdbgc5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC5r BCM53324_A0_RDBGC5r
#define RDBGC5r_SIZE BCM53324_A0_RDBGC5r_SIZE
typedef BCM53324_A0_RDBGC5r_t RDBGC5r_t;
#define RDBGC5r_CLR BCM53324_A0_RDBGC5r_CLR
#define RDBGC5r_SET BCM53324_A0_RDBGC5r_SET
#define RDBGC5r_GET BCM53324_A0_RDBGC5r_GET
#define READ_RDBGC5r BCM53324_A0_READ_RDBGC5r
#define WRITE_RDBGC5r BCM53324_A0_WRITE_RDBGC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC5_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #5 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC5_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC5_SELECTr 0x0f780025

#define BCM53324_A0_RDBGC5_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC5_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC5_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc5_select[1];
	uint32_t _rdbgc5_select;
} BCM53324_A0_RDBGC5_SELECTr_t;

#define BCM53324_A0_RDBGC5_SELECTr_CLR(r) (r).rdbgc5_select[0] = 0
#define BCM53324_A0_RDBGC5_SELECTr_SET(r,d) (r).rdbgc5_select[0] = d
#define BCM53324_A0_RDBGC5_SELECTr_GET(r) (r).rdbgc5_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC5_SELECTr_BITMAPf_GET(r) (((r).rdbgc5_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC5_SELECTr_BITMAPf_SET(r,f) (r).rdbgc5_select[0]=(((r).rdbgc5_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC5_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC5_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC5_SELECTr,(r._rdbgc5_select))
#define BCM53324_A0_WRITE_RDBGC5_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC5_SELECTr,&(r._rdbgc5_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC5_SELECTr BCM53324_A0_RDBGC5_SELECTr
#define RDBGC5_SELECTr_SIZE BCM53324_A0_RDBGC5_SELECTr_SIZE
typedef BCM53324_A0_RDBGC5_SELECTr_t RDBGC5_SELECTr_t;
#define RDBGC5_SELECTr_CLR BCM53324_A0_RDBGC5_SELECTr_CLR
#define RDBGC5_SELECTr_SET BCM53324_A0_RDBGC5_SELECTr_SET
#define RDBGC5_SELECTr_GET BCM53324_A0_RDBGC5_SELECTr_GET
#define RDBGC5_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC5_SELECTr_BITMAPf_GET
#define RDBGC5_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC5_SELECTr_BITMAPf_SET
#define READ_RDBGC5_SELECTr BCM53324_A0_READ_RDBGC5_SELECTr
#define WRITE_RDBGC5_SELECTr BCM53324_A0_WRITE_RDBGC5_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC5_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC6
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #6
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC6r 0x0f700011

#define BCM53324_A0_RDBGC6r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC6.
 *
 */
typedef union BCM53324_A0_RDBGC6r_s {
	uint32_t v[1];
	uint32_t rdbgc6[1];
	uint32_t _rdbgc6;
} BCM53324_A0_RDBGC6r_t;

#define BCM53324_A0_RDBGC6r_CLR(r) (r).rdbgc6[0] = 0
#define BCM53324_A0_RDBGC6r_SET(r,d) (r).rdbgc6[0] = d
#define BCM53324_A0_RDBGC6r_GET(r) (r).rdbgc6[0]


/*
 * These macros can be used to access RDBGC6.
 *
 */
#define BCM53324_A0_READ_RDBGC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC6r,(r._rdbgc6))
#define BCM53324_A0_WRITE_RDBGC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC6r,&(r._rdbgc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC6r BCM53324_A0_RDBGC6r
#define RDBGC6r_SIZE BCM53324_A0_RDBGC6r_SIZE
typedef BCM53324_A0_RDBGC6r_t RDBGC6r_t;
#define RDBGC6r_CLR BCM53324_A0_RDBGC6r_CLR
#define RDBGC6r_SET BCM53324_A0_RDBGC6r_SET
#define RDBGC6r_GET BCM53324_A0_RDBGC6r_GET
#define READ_RDBGC6r BCM53324_A0_READ_RDBGC6r
#define WRITE_RDBGC6r BCM53324_A0_WRITE_RDBGC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC6_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #6 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC6_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC6_SELECTr 0x0f780026

#define BCM53324_A0_RDBGC6_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC6_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC6_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc6_select[1];
	uint32_t _rdbgc6_select;
} BCM53324_A0_RDBGC6_SELECTr_t;

#define BCM53324_A0_RDBGC6_SELECTr_CLR(r) (r).rdbgc6_select[0] = 0
#define BCM53324_A0_RDBGC6_SELECTr_SET(r,d) (r).rdbgc6_select[0] = d
#define BCM53324_A0_RDBGC6_SELECTr_GET(r) (r).rdbgc6_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC6_SELECTr_BITMAPf_GET(r) (((r).rdbgc6_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC6_SELECTr_BITMAPf_SET(r,f) (r).rdbgc6_select[0]=(((r).rdbgc6_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC6_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC6_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC6_SELECTr,(r._rdbgc6_select))
#define BCM53324_A0_WRITE_RDBGC6_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC6_SELECTr,&(r._rdbgc6_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC6_SELECTr BCM53324_A0_RDBGC6_SELECTr
#define RDBGC6_SELECTr_SIZE BCM53324_A0_RDBGC6_SELECTr_SIZE
typedef BCM53324_A0_RDBGC6_SELECTr_t RDBGC6_SELECTr_t;
#define RDBGC6_SELECTr_CLR BCM53324_A0_RDBGC6_SELECTr_CLR
#define RDBGC6_SELECTr_SET BCM53324_A0_RDBGC6_SELECTr_SET
#define RDBGC6_SELECTr_GET BCM53324_A0_RDBGC6_SELECTr_GET
#define RDBGC6_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC6_SELECTr_BITMAPf_GET
#define RDBGC6_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC6_SELECTr_BITMAPf_SET
#define READ_RDBGC6_SELECTr BCM53324_A0_READ_RDBGC6_SELECTr
#define WRITE_RDBGC6_SELECTr BCM53324_A0_WRITE_RDBGC6_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC6_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC7
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #7
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC7r 0x0f700012

#define BCM53324_A0_RDBGC7r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC7.
 *
 */
typedef union BCM53324_A0_RDBGC7r_s {
	uint32_t v[1];
	uint32_t rdbgc7[1];
	uint32_t _rdbgc7;
} BCM53324_A0_RDBGC7r_t;

#define BCM53324_A0_RDBGC7r_CLR(r) (r).rdbgc7[0] = 0
#define BCM53324_A0_RDBGC7r_SET(r,d) (r).rdbgc7[0] = d
#define BCM53324_A0_RDBGC7r_GET(r) (r).rdbgc7[0]


/*
 * These macros can be used to access RDBGC7.
 *
 */
#define BCM53324_A0_READ_RDBGC7r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC7r,(r._rdbgc7))
#define BCM53324_A0_WRITE_RDBGC7r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC7r,&(r._rdbgc7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC7r BCM53324_A0_RDBGC7r
#define RDBGC7r_SIZE BCM53324_A0_RDBGC7r_SIZE
typedef BCM53324_A0_RDBGC7r_t RDBGC7r_t;
#define RDBGC7r_CLR BCM53324_A0_RDBGC7r_CLR
#define RDBGC7r_SET BCM53324_A0_RDBGC7r_SET
#define RDBGC7r_GET BCM53324_A0_RDBGC7r_GET
#define READ_RDBGC7r BCM53324_A0_READ_RDBGC7r
#define WRITE_RDBGC7r BCM53324_A0_WRITE_RDBGC7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC7_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #7 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC7_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC7_SELECTr 0x0f780027

#define BCM53324_A0_RDBGC7_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC7_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC7_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc7_select[1];
	uint32_t _rdbgc7_select;
} BCM53324_A0_RDBGC7_SELECTr_t;

#define BCM53324_A0_RDBGC7_SELECTr_CLR(r) (r).rdbgc7_select[0] = 0
#define BCM53324_A0_RDBGC7_SELECTr_SET(r,d) (r).rdbgc7_select[0] = d
#define BCM53324_A0_RDBGC7_SELECTr_GET(r) (r).rdbgc7_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC7_SELECTr_BITMAPf_GET(r) (((r).rdbgc7_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC7_SELECTr_BITMAPf_SET(r,f) (r).rdbgc7_select[0]=(((r).rdbgc7_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC7_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC7_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC7_SELECTr,(r._rdbgc7_select))
#define BCM53324_A0_WRITE_RDBGC7_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC7_SELECTr,&(r._rdbgc7_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC7_SELECTr BCM53324_A0_RDBGC7_SELECTr
#define RDBGC7_SELECTr_SIZE BCM53324_A0_RDBGC7_SELECTr_SIZE
typedef BCM53324_A0_RDBGC7_SELECTr_t RDBGC7_SELECTr_t;
#define RDBGC7_SELECTr_CLR BCM53324_A0_RDBGC7_SELECTr_CLR
#define RDBGC7_SELECTr_SET BCM53324_A0_RDBGC7_SELECTr_SET
#define RDBGC7_SELECTr_GET BCM53324_A0_RDBGC7_SELECTr_GET
#define RDBGC7_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC7_SELECTr_BITMAPf_GET
#define RDBGC7_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC7_SELECTr_BITMAPf_SET
#define READ_RDBGC7_SELECTr BCM53324_A0_READ_RDBGC7_SELECTr
#define WRITE_RDBGC7_SELECTr BCM53324_A0_WRITE_RDBGC7_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC7_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC8
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #8
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC8r 0x0f700013

#define BCM53324_A0_RDBGC8r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC8.
 *
 */
typedef union BCM53324_A0_RDBGC8r_s {
	uint32_t v[1];
	uint32_t rdbgc8[1];
	uint32_t _rdbgc8;
} BCM53324_A0_RDBGC8r_t;

#define BCM53324_A0_RDBGC8r_CLR(r) (r).rdbgc8[0] = 0
#define BCM53324_A0_RDBGC8r_SET(r,d) (r).rdbgc8[0] = d
#define BCM53324_A0_RDBGC8r_GET(r) (r).rdbgc8[0]


/*
 * These macros can be used to access RDBGC8.
 *
 */
#define BCM53324_A0_READ_RDBGC8r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDBGC8r,(r._rdbgc8))
#define BCM53324_A0_WRITE_RDBGC8r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDBGC8r,&(r._rdbgc8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC8r BCM53324_A0_RDBGC8r
#define RDBGC8r_SIZE BCM53324_A0_RDBGC8r_SIZE
typedef BCM53324_A0_RDBGC8r_t RDBGC8r_t;
#define RDBGC8r_CLR BCM53324_A0_RDBGC8r_CLR
#define RDBGC8r_SET BCM53324_A0_RDBGC8r_SET
#define RDBGC8r_GET BCM53324_A0_RDBGC8r_GET
#define READ_RDBGC8r BCM53324_A0_READ_RDBGC8r
#define WRITE_RDBGC8r BCM53324_A0_WRITE_RDBGC8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDBGC8_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #8 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC8_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_RDBGC8_SELECTr 0x0f780028

#define BCM53324_A0_RDBGC8_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC8_SELECT.
 *
 */
typedef union BCM53324_A0_RDBGC8_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc8_select[1];
	uint32_t _rdbgc8_select;
} BCM53324_A0_RDBGC8_SELECTr_t;

#define BCM53324_A0_RDBGC8_SELECTr_CLR(r) (r).rdbgc8_select[0] = 0
#define BCM53324_A0_RDBGC8_SELECTr_SET(r,d) (r).rdbgc8_select[0] = d
#define BCM53324_A0_RDBGC8_SELECTr_GET(r) (r).rdbgc8_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RDBGC8_SELECTr_BITMAPf_GET(r) (((r).rdbgc8_select[0]) & 0x7fffffff)
#define BCM53324_A0_RDBGC8_SELECTr_BITMAPf_SET(r,f) (r).rdbgc8_select[0]=(((r).rdbgc8_select[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RDBGC8_SELECT.
 *
 */
#define BCM53324_A0_READ_RDBGC8_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_RDBGC8_SELECTr,(r._rdbgc8_select))
#define BCM53324_A0_WRITE_RDBGC8_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_RDBGC8_SELECTr,&(r._rdbgc8_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC8_SELECTr BCM53324_A0_RDBGC8_SELECTr
#define RDBGC8_SELECTr_SIZE BCM53324_A0_RDBGC8_SELECTr_SIZE
typedef BCM53324_A0_RDBGC8_SELECTr_t RDBGC8_SELECTr_t;
#define RDBGC8_SELECTr_CLR BCM53324_A0_RDBGC8_SELECTr_CLR
#define RDBGC8_SELECTr_SET BCM53324_A0_RDBGC8_SELECTr_SET
#define RDBGC8_SELECTr_GET BCM53324_A0_RDBGC8_SELECTr_GET
#define RDBGC8_SELECTr_BITMAPf_GET BCM53324_A0_RDBGC8_SELECTr_BITMAPf_GET
#define RDBGC8_SELECTr_BITMAPf_SET BCM53324_A0_RDBGC8_SELECTr_BITMAPf_SET
#define READ_RDBGC8_SELECTr BCM53324_A0_READ_RDBGC8_SELECTr
#define WRITE_RDBGC8_SELECTr BCM53324_A0_WRITE_RDBGC8_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDBGC8_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RDISC
 * BLOCKS:   IPIPE
 * DESC:     Receive Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RDISCr 0x0f700008

#define BCM53324_A0_RDISCr_SIZE 4

/*
 * This structure should be used to declare and program RDISC.
 *
 */
typedef union BCM53324_A0_RDISCr_s {
	uint32_t v[1];
	uint32_t rdisc[1];
	uint32_t _rdisc;
} BCM53324_A0_RDISCr_t;

#define BCM53324_A0_RDISCr_CLR(r) (r).rdisc[0] = 0
#define BCM53324_A0_RDISCr_SET(r,d) (r).rdisc[0] = d
#define BCM53324_A0_RDISCr_GET(r) (r).rdisc[0]


/*
 * These macros can be used to access RDISC.
 *
 */
#define BCM53324_A0_READ_RDISCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RDISCr,(r._rdisc))
#define BCM53324_A0_WRITE_RDISCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RDISCr,&(r._rdisc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDISCr BCM53324_A0_RDISCr
#define RDISCr_SIZE BCM53324_A0_RDISCr_SIZE
typedef BCM53324_A0_RDISCr_t RDISCr_t;
#define RDISCr_CLR BCM53324_A0_RDISCr_CLR
#define RDISCr_SET BCM53324_A0_RDISCr_SET
#define RDISCr_GET BCM53324_A0_RDISCr_GET
#define READ_RDISCr BCM53324_A0_READ_RDISCr
#define WRITE_RDISCr BCM53324_A0_WRITE_RDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RIPC4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 Unicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RIPC4r 0x0f700001

#define BCM53324_A0_RIPC4r_SIZE 4

/*
 * This structure should be used to declare and program RIPC4.
 *
 */
typedef union BCM53324_A0_RIPC4r_s {
	uint32_t v[1];
	uint32_t ripc4[1];
	uint32_t _ripc4;
} BCM53324_A0_RIPC4r_t;

#define BCM53324_A0_RIPC4r_CLR(r) (r).ripc4[0] = 0
#define BCM53324_A0_RIPC4r_SET(r,d) (r).ripc4[0] = d
#define BCM53324_A0_RIPC4r_GET(r) (r).ripc4[0]


/*
 * These macros can be used to access RIPC4.
 *
 */
#define BCM53324_A0_READ_RIPC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RIPC4r,(r._ripc4))
#define BCM53324_A0_WRITE_RIPC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RIPC4r,&(r._ripc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPC4r BCM53324_A0_RIPC4r
#define RIPC4r_SIZE BCM53324_A0_RIPC4r_SIZE
typedef BCM53324_A0_RIPC4r_t RIPC4r_t;
#define RIPC4r_CLR BCM53324_A0_RIPC4r_CLR
#define RIPC4r_SET BCM53324_A0_RIPC4r_SET
#define RIPC4r_GET BCM53324_A0_RIPC4r_GET
#define READ_RIPC4r BCM53324_A0_READ_RIPC4r
#define WRITE_RIPC4r BCM53324_A0_WRITE_RIPC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RIPC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RIPC6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 Unicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RIPC6r 0x0f700005

#define BCM53324_A0_RIPC6r_SIZE 4

/*
 * This structure should be used to declare and program RIPC6.
 *
 */
typedef union BCM53324_A0_RIPC6r_s {
	uint32_t v[1];
	uint32_t ripc6[1];
	uint32_t _ripc6;
} BCM53324_A0_RIPC6r_t;

#define BCM53324_A0_RIPC6r_CLR(r) (r).ripc6[0] = 0
#define BCM53324_A0_RIPC6r_SET(r,d) (r).ripc6[0] = d
#define BCM53324_A0_RIPC6r_GET(r) (r).ripc6[0]


/*
 * These macros can be used to access RIPC6.
 *
 */
#define BCM53324_A0_READ_RIPC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RIPC6r,(r._ripc6))
#define BCM53324_A0_WRITE_RIPC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RIPC6r,&(r._ripc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPC6r BCM53324_A0_RIPC6r
#define RIPC6r_SIZE BCM53324_A0_RIPC6r_SIZE
typedef BCM53324_A0_RIPC6r_t RIPC6r_t;
#define RIPC6r_CLR BCM53324_A0_RIPC6r_CLR
#define RIPC6r_SET BCM53324_A0_RIPC6r_SET
#define RIPC6r_GET BCM53324_A0_RIPC6r_GET
#define READ_RIPC6r BCM53324_A0_READ_RIPC6r
#define WRITE_RIPC6r BCM53324_A0_WRITE_RIPC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RIPC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RIPD4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RIPD4r 0x0f700000

#define BCM53324_A0_RIPD4r_SIZE 4

/*
 * This structure should be used to declare and program RIPD4.
 *
 */
typedef union BCM53324_A0_RIPD4r_s {
	uint32_t v[1];
	uint32_t ripd4[1];
	uint32_t _ripd4;
} BCM53324_A0_RIPD4r_t;

#define BCM53324_A0_RIPD4r_CLR(r) (r).ripd4[0] = 0
#define BCM53324_A0_RIPD4r_SET(r,d) (r).ripd4[0] = d
#define BCM53324_A0_RIPD4r_GET(r) (r).ripd4[0]


/*
 * These macros can be used to access RIPD4.
 *
 */
#define BCM53324_A0_READ_RIPD4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RIPD4r,(r._ripd4))
#define BCM53324_A0_WRITE_RIPD4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RIPD4r,&(r._ripd4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPD4r BCM53324_A0_RIPD4r
#define RIPD4r_SIZE BCM53324_A0_RIPD4r_SIZE
typedef BCM53324_A0_RIPD4r_t RIPD4r_t;
#define RIPD4r_CLR BCM53324_A0_RIPD4r_CLR
#define RIPD4r_SET BCM53324_A0_RIPD4r_SET
#define RIPD4r_GET BCM53324_A0_RIPD4r_GET
#define READ_RIPD4r BCM53324_A0_READ_RIPD4r
#define WRITE_RIPD4r BCM53324_A0_WRITE_RIPD4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RIPD4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RIPD6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RIPD6r 0x0f700004

#define BCM53324_A0_RIPD6r_SIZE 4

/*
 * This structure should be used to declare and program RIPD6.
 *
 */
typedef union BCM53324_A0_RIPD6r_s {
	uint32_t v[1];
	uint32_t ripd6[1];
	uint32_t _ripd6;
} BCM53324_A0_RIPD6r_t;

#define BCM53324_A0_RIPD6r_CLR(r) (r).ripd6[0] = 0
#define BCM53324_A0_RIPD6r_SET(r,d) (r).ripd6[0] = d
#define BCM53324_A0_RIPD6r_GET(r) (r).ripd6[0]


/*
 * These macros can be used to access RIPD6.
 *
 */
#define BCM53324_A0_READ_RIPD6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RIPD6r,(r._ripd6))
#define BCM53324_A0_WRITE_RIPD6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RIPD6r,&(r._ripd6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPD6r BCM53324_A0_RIPD6r
#define RIPD6r_SIZE BCM53324_A0_RIPD6r_SIZE
typedef BCM53324_A0_RIPD6r_t RIPD6r_t;
#define RIPD6r_CLR BCM53324_A0_RIPD6r_CLR
#define RIPD6r_SET BCM53324_A0_RIPD6r_SET
#define RIPD6r_GET BCM53324_A0_RIPD6r_GET
#define READ_RIPD6r BCM53324_A0_READ_RIPD6r
#define WRITE_RIPD6r BCM53324_A0_WRITE_RIPD6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RIPD6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RIPHE4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 IP Header Error Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RIPHE4r 0x0f700002

#define BCM53324_A0_RIPHE4r_SIZE 4

/*
 * This structure should be used to declare and program RIPHE4.
 *
 */
typedef union BCM53324_A0_RIPHE4r_s {
	uint32_t v[1];
	uint32_t riphe4[1];
	uint32_t _riphe4;
} BCM53324_A0_RIPHE4r_t;

#define BCM53324_A0_RIPHE4r_CLR(r) (r).riphe4[0] = 0
#define BCM53324_A0_RIPHE4r_SET(r,d) (r).riphe4[0] = d
#define BCM53324_A0_RIPHE4r_GET(r) (r).riphe4[0]


/*
 * These macros can be used to access RIPHE4.
 *
 */
#define BCM53324_A0_READ_RIPHE4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RIPHE4r,(r._riphe4))
#define BCM53324_A0_WRITE_RIPHE4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RIPHE4r,&(r._riphe4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPHE4r BCM53324_A0_RIPHE4r
#define RIPHE4r_SIZE BCM53324_A0_RIPHE4r_SIZE
typedef BCM53324_A0_RIPHE4r_t RIPHE4r_t;
#define RIPHE4r_CLR BCM53324_A0_RIPHE4r_CLR
#define RIPHE4r_SET BCM53324_A0_RIPHE4r_SET
#define RIPHE4r_GET BCM53324_A0_RIPHE4r_GET
#define READ_RIPHE4r BCM53324_A0_READ_RIPHE4r
#define WRITE_RIPHE4r BCM53324_A0_WRITE_RIPHE4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RIPHE4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RIPHE6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 IP Header Error Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RIPHE6r 0x0f700006

#define BCM53324_A0_RIPHE6r_SIZE 4

/*
 * This structure should be used to declare and program RIPHE6.
 *
 */
typedef union BCM53324_A0_RIPHE6r_s {
	uint32_t v[1];
	uint32_t riphe6[1];
	uint32_t _riphe6;
} BCM53324_A0_RIPHE6r_t;

#define BCM53324_A0_RIPHE6r_CLR(r) (r).riphe6[0] = 0
#define BCM53324_A0_RIPHE6r_SET(r,d) (r).riphe6[0] = d
#define BCM53324_A0_RIPHE6r_GET(r) (r).riphe6[0]


/*
 * These macros can be used to access RIPHE6.
 *
 */
#define BCM53324_A0_READ_RIPHE6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RIPHE6r,(r._riphe6))
#define BCM53324_A0_WRITE_RIPHE6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RIPHE6r,&(r._riphe6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPHE6r BCM53324_A0_RIPHE6r
#define RIPHE6r_SIZE BCM53324_A0_RIPHE6r_SIZE
typedef BCM53324_A0_RIPHE6r_t RIPHE6r_t;
#define RIPHE6r_CLR BCM53324_A0_RIPHE6r_CLR
#define RIPHE6r_SET BCM53324_A0_RIPHE6r_SET
#define RIPHE6r_GET BCM53324_A0_RIPHE6r_GET
#define READ_RIPHE6r BCM53324_A0_READ_RIPHE6r
#define WRITE_RIPHE6r BCM53324_A0_WRITE_RIPHE6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RIPHE6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RPORTD
 * BLOCKS:   IPIPE
 * DESC:     PortInDiscard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RPORTDr 0x0f70000a

#define BCM53324_A0_RPORTDr_SIZE 4

/*
 * This structure should be used to declare and program RPORTD.
 *
 */
typedef union BCM53324_A0_RPORTDr_s {
	uint32_t v[1];
	uint32_t rportd[1];
	uint32_t _rportd;
} BCM53324_A0_RPORTDr_t;

#define BCM53324_A0_RPORTDr_CLR(r) (r).rportd[0] = 0
#define BCM53324_A0_RPORTDr_SET(r,d) (r).rportd[0] = d
#define BCM53324_A0_RPORTDr_GET(r) (r).rportd[0]


/*
 * These macros can be used to access RPORTD.
 *
 */
#define BCM53324_A0_READ_RPORTDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RPORTDr,(r._rportd))
#define BCM53324_A0_WRITE_RPORTDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RPORTDr,&(r._rportd))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RPORTDr BCM53324_A0_RPORTDr
#define RPORTDr_SIZE BCM53324_A0_RPORTDr_SIZE
typedef BCM53324_A0_RPORTDr_t RPORTDr_t;
#define RPORTDr_CLR BCM53324_A0_RPORTDr_CLR
#define RPORTDr_SET BCM53324_A0_RPORTDr_SET
#define RPORTDr_GET BCM53324_A0_RPORTDr_GET
#define READ_RPORTDr BCM53324_A0_READ_RPORTDr
#define WRITE_RPORTDr BCM53324_A0_WRITE_RPORTDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RPORTDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RRBYT
 * BLOCKS:   GPORT0
 * DESC:     Receive Runt Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RRBYTr 0x0000000e

#define BCM53324_A0_RRBYTr_SIZE 4

/*
 * This structure should be used to declare and program RRBYT.
 *
 */
typedef union BCM53324_A0_RRBYTr_s {
	uint32_t v[1];
	uint32_t rrbyt[1];
	uint32_t _rrbyt;
} BCM53324_A0_RRBYTr_t;

#define BCM53324_A0_RRBYTr_CLR(r) (r).rrbyt[0] = 0
#define BCM53324_A0_RRBYTr_SET(r,d) (r).rrbyt[0] = d
#define BCM53324_A0_RRBYTr_GET(r) (r).rrbyt[0]


/*
 * These macros can be used to access RRBYT.
 *
 */
#define BCM53324_A0_READ_RRBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RRBYTr,(r._rrbyt))
#define BCM53324_A0_WRITE_RRBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RRBYTr,&(r._rrbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RRBYTr BCM53324_A0_RRBYTr
#define RRBYTr_SIZE BCM53324_A0_RRBYTr_SIZE
typedef BCM53324_A0_RRBYTr_t RRBYTr_t;
#define RRBYTr_CLR BCM53324_A0_RRBYTr_CLR
#define RRBYTr_SET BCM53324_A0_RRBYTr_SET
#define RRBYTr_GET BCM53324_A0_RRBYTr_GET
#define READ_RRBYTr BCM53324_A0_READ_RRBYTr
#define WRITE_RRBYTr BCM53324_A0_WRITE_RRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RRPKT
 * BLOCKS:   GPORT0
 * DESC:     Receive RUNT Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RRPKTr 0x0000000b

#define BCM53324_A0_RRPKTr_SIZE 4

/*
 * This structure should be used to declare and program RRPKT.
 *
 */
typedef union BCM53324_A0_RRPKTr_s {
	uint32_t v[1];
	uint32_t rrpkt[1];
	uint32_t _rrpkt;
} BCM53324_A0_RRPKTr_t;

#define BCM53324_A0_RRPKTr_CLR(r) (r).rrpkt[0] = 0
#define BCM53324_A0_RRPKTr_SET(r,d) (r).rrpkt[0] = d
#define BCM53324_A0_RRPKTr_GET(r) (r).rrpkt[0]


/*
 * These macros can be used to access RRPKT.
 *
 */
#define BCM53324_A0_READ_RRPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RRPKTr,(r._rrpkt))
#define BCM53324_A0_WRITE_RRPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RRPKTr,&(r._rrpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RRPKTr BCM53324_A0_RRPKTr
#define RRPKTr_SIZE BCM53324_A0_RRPKTr_SIZE
typedef BCM53324_A0_RRPKTr_t RRPKTr_t;
#define RRPKTr_CLR BCM53324_A0_RRPKTr_CLR
#define RRPKTr_SET BCM53324_A0_RRPKTr_SET
#define RRPKTr_GET BCM53324_A0_RRPKTr_GET
#define READ_RRPKTr BCM53324_A0_READ_RRPKTr
#define WRITE_RRPKTr BCM53324_A0_WRITE_RRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RUC
 * BLOCKS:   IPIPE
 * DESC:     Receive Unicast Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RUCr 0x0f700009

#define BCM53324_A0_RUCr_SIZE 4

/*
 * This structure should be used to declare and program RUC.
 *
 */
typedef union BCM53324_A0_RUCr_s {
	uint32_t v[1];
	uint32_t ruc[1];
	uint32_t _ruc;
} BCM53324_A0_RUCr_t;

#define BCM53324_A0_RUCr_CLR(r) (r).ruc[0] = 0
#define BCM53324_A0_RUCr_SET(r,d) (r).ruc[0] = d
#define BCM53324_A0_RUCr_GET(r) (r).ruc[0]


/*
 * These macros can be used to access RUC.
 *
 */
#define BCM53324_A0_READ_RUCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RUCr,(r._ruc))
#define BCM53324_A0_WRITE_RUCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RUCr,&(r._ruc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RUCr BCM53324_A0_RUCr
#define RUCr_SIZE BCM53324_A0_RUCr_SIZE
typedef BCM53324_A0_RUCr_t RUCr_t;
#define RUCr_CLR BCM53324_A0_RUCr_CLR
#define RUCr_SET BCM53324_A0_RUCr_SET
#define RUCr_GET BCM53324_A0_RUCr_GET
#define READ_RUCr BCM53324_A0_READ_RUCr
#define WRITE_RUCr BCM53324_A0_WRITE_RUCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RUCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RXFIFO_STAT
 * BLOCKS:   GPORT0
 * DESC:     RXFIFO status register
 * SIZE:     32
 * FIELDS:
 *     RXFIFO_UNDERRUN  RXFIFO Underrun occurred.
 *     RXFIFO_OVERRUN   RXFIFO Overrun occurred.
 *
 ******************************************************************************/
#define BCM53324_A0_RXFIFO_STATr 0x000001ce

#define BCM53324_A0_RXFIFO_STATr_SIZE 4

/*
 * This structure should be used to declare and program RXFIFO_STAT.
 *
 */
typedef union BCM53324_A0_RXFIFO_STATr_s {
	uint32_t v[1];
	uint32_t rxfifo_stat[1];
	uint32_t _rxfifo_stat;
} BCM53324_A0_RXFIFO_STATr_t;

#define BCM53324_A0_RXFIFO_STATr_CLR(r) (r).rxfifo_stat[0] = 0
#define BCM53324_A0_RXFIFO_STATr_SET(r,d) (r).rxfifo_stat[0] = d
#define BCM53324_A0_RXFIFO_STATr_GET(r) (r).rxfifo_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RXFIFO_STATr_RXFIFO_UNDERRUNf_GET(r) (((r).rxfifo_stat[0]) & 0x1)
#define BCM53324_A0_RXFIFO_STATr_RXFIFO_UNDERRUNf_SET(r,f) (r).rxfifo_stat[0]=(((r).rxfifo_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_RXFIFO_STATr_RXFIFO_OVERRUNf_GET(r) ((((r).rxfifo_stat[0]) >> 1) & 0x1)
#define BCM53324_A0_RXFIFO_STATr_RXFIFO_OVERRUNf_SET(r,f) (r).rxfifo_stat[0]=(((r).rxfifo_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access RXFIFO_STAT.
 *
 */
#define BCM53324_A0_READ_RXFIFO_STATr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RXFIFO_STATr,(r._rxfifo_stat))
#define BCM53324_A0_WRITE_RXFIFO_STATr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RXFIFO_STATr,&(r._rxfifo_stat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFIFO_STATr BCM53324_A0_RXFIFO_STATr
#define RXFIFO_STATr_SIZE BCM53324_A0_RXFIFO_STATr_SIZE
typedef BCM53324_A0_RXFIFO_STATr_t RXFIFO_STATr_t;
#define RXFIFO_STATr_CLR BCM53324_A0_RXFIFO_STATr_CLR
#define RXFIFO_STATr_SET BCM53324_A0_RXFIFO_STATr_SET
#define RXFIFO_STATr_GET BCM53324_A0_RXFIFO_STATr_GET
#define RXFIFO_STATr_RXFIFO_UNDERRUNf_GET BCM53324_A0_RXFIFO_STATr_RXFIFO_UNDERRUNf_GET
#define RXFIFO_STATr_RXFIFO_UNDERRUNf_SET BCM53324_A0_RXFIFO_STATr_RXFIFO_UNDERRUNf_SET
#define RXFIFO_STATr_RXFIFO_OVERRUNf_GET BCM53324_A0_RXFIFO_STATr_RXFIFO_OVERRUNf_GET
#define RXFIFO_STATr_RXFIFO_OVERRUNf_SET BCM53324_A0_RXFIFO_STATr_RXFIFO_OVERRUNf_SET
#define READ_RXFIFO_STATr BCM53324_A0_READ_RXFIFO_STATr
#define WRITE_RXFIFO_STATr BCM53324_A0_WRITE_RXFIFO_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RXFIFO_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * SWFORMAT:  RX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     352
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     END_BIT          Descriptor is for last (or only) packet fragment.
 *     START_BIT        Descriptor is for first (or only) packet fragment.
 *     ERROR            Internal RX error encountered.
 *     DONE             Descriptor done.
 *     COS              COS
 *     ADD_INNER_VLAN   Add inner vlan id
 *     DECAP_IPTUNNEL   Decap IP Tunneling Packet
 *     PKT_WAS_UNTAGGED Pkt came into EP as untagged.
 *     OUTER_VID        VID which came from MMU.
 *     OUTER_CFI        CFI which was constructed in EP based on CNG mapping.
 *     OUTER_PRI        Priority which came from MMU.
 *     SRC_PORT         Source Port Number
 *     DSCP             New DSCP
 *     NHOP_INDEX       Next HOP Index
 *     MATCHED_RULE     Matched Rule
 *     CHANGE_DSCP      DSCP Changed
 *     CELL_ERROR       Falg for a Cell CRC Checksum Error Detected
 *     REASON           CPU opcode, reason the packet was copied to the CPU.Bit27 - Indication of EAV data packet.Bit26 - Indication of RX_TS packet.Bit22 - If Mac Limit Counters have exceeded.Bit24 - Parity error in L2/L3 tablesBit23 - non-zero HiGig+ Hdr errors such as non-zero Extn Len, higig hdr modids > 127Bit22 - L3 MTU check failedBit21 - Parity error on IP tablesBit20 - L3 slow path CPU processed packetsBit19 - ICMP Redirect copy to CPUBit18 - L3 MTU check fail to CPUBit17 - Tunnel error trap to CPUBit16 - Martian address trap to CPUBit15 - DOS attack trap to CPUBit14 - Protocol PacketBit13 - L3 header  - IP options, TTL=0, !IPv4 etc.Bit12 - FFP Action - copy to CPUBit11 - IPMC miss - {SIP, DIP} miss or DIP missBit10 - MC miss Bit9 - Station Movement - L3Bit8 - L3 DIP MissBit7 - L3 SIP MissBit6 - sFlow - DstBit5 - sFlow - SrcBit4 - L2_TABLE - copy to CPUBit3- Station Movement - L2Bit2 - DLF, Bit1 - SLFBit0- CPU Learn bit is set in PTABLE and SA is learnt; unknown VLAN; VID = 0xfff 
 *     CPU_COS          CPU COS
 *     IPMC_INTF_NUM    IPMC interface number
 *     REGEN_CRC        Regenrate the crc for this packet
 *     SWITCH           flag to indicate this is a switched packet
 *     SRC_HG           Source is Higig
 *     PURGE_CELL       Packet is marked Purged
 *     PKT_AGED         Pkt is Aged
 *     MTP_INDEX        Mirror-to-Port Index
 *     L3UC             L3 Unicast Packet Flag
 *     L3ONLY           L3ONLY is set by MMU if  aport appears in PBI.L3_PBM but not in PBI.L2_PBM.
 *     L3IPMC           Indicates if pkt needs to be L3mc treated by EP.
 *     IMIRROR          Ingress Mirroring
 *     EMIRROR          Egress Mirroring
 *     BPDU             BPDU Packet
 *     ADD_VID          VLAN ID Added
 *     DO_NOT_CHANGE_TTL Forces TTL to not be changed
 *     MODULE_HEADER    Module Header indormation to the CPU port, same as higig module header format.
 *     TIME_STAMP       Time-Stamp value for TS packets
 *     BYTE_COUNT       Maximum number of bytes for this transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet may continue in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     ADDR             Physical memory address for the transfer.
 *
 ******************************************************************************/
#define BCM53324_A0_RX_DCB 0x00000000

#define BCM53324_A0_RX_DCB_SIZE 44

/*
 * This structure should be used to declare and program RX_DCB.
 *
 */
typedef union BCM53324_A0_RX_DCB_s {
	uint32_t v[11];
	uint32_t rx_dcb[11];
	uint32_t _rx_dcb;
} BCM53324_A0_RX_DCB_t;

#define BCM53324_A0_RX_DCB_CLR(r) CDK_MEMSET(&((r)._rx_dcb), 0, sizeof(BCM53324_A0_RX_DCB_t))
#define BCM53324_A0_RX_DCB_SET(r,i,d) (r).rx_dcb[i] = d
#define BCM53324_A0_RX_DCB_GET(r,i) (r).rx_dcb[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_RX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).rx_dcb[10]) & 0xffff)
#define BCM53324_A0_RX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_RX_DCB_END_BITf_GET(r) ((((r).rx_dcb[10]) >> 16) & 0x1)
#define BCM53324_A0_RX_DCB_END_BITf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_RX_DCB_START_BITf_GET(r) ((((r).rx_dcb[10]) >> 17) & 0x1)
#define BCM53324_A0_RX_DCB_START_BITf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_RX_DCB_ERRORf_GET(r) ((((r).rx_dcb[10]) >> 18) & 0x1)
#define BCM53324_A0_RX_DCB_ERRORf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_RX_DCB_DONEf_GET(r) ((((r).rx_dcb[10]) >> 31) & 0x1)
#define BCM53324_A0_RX_DCB_DONEf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53324_A0_RX_DCB_COSf_GET(r) ((((r).rx_dcb[9]) >> 5) & 0x7)
#define BCM53324_A0_RX_DCB_COSf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53324_A0_RX_DCB_ADD_INNER_VLANf_GET(r) ((((r).rx_dcb[9]) >> 8) & 0x1)
#define BCM53324_A0_RX_DCB_ADD_INNER_VLANf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_RX_DCB_DECAP_IPTUNNELf_GET(r) ((((r).rx_dcb[9]) >> 9) & 0x1)
#define BCM53324_A0_RX_DCB_DECAP_IPTUNNELf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_RX_DCB_PKT_WAS_UNTAGGEDf_GET(r) ((((r).rx_dcb[9]) >> 10) & 0x1)
#define BCM53324_A0_RX_DCB_PKT_WAS_UNTAGGEDf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_RX_DCB_OUTER_VIDf_GET(r) ((((r).rx_dcb[9]) >> 11) & 0xfff)
#define BCM53324_A0_RX_DCB_OUTER_VIDf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0xfff << 11)) | ((((uint32_t)f) & 0xfff) << 11))
#define BCM53324_A0_RX_DCB_OUTER_CFIf_GET(r) ((((r).rx_dcb[9]) >> 23) & 0x1)
#define BCM53324_A0_RX_DCB_OUTER_CFIf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53324_A0_RX_DCB_OUTER_PRIf_GET(r) ((((r).rx_dcb[9]) >> 24) & 0x7)
#define BCM53324_A0_RX_DCB_OUTER_PRIf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53324_A0_RX_DCB_SRC_PORTf_GET(r) ((((r).rx_dcb[9]) >> 27) & 0x1f)
#define BCM53324_A0_RX_DCB_SRC_PORTf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))
#define BCM53324_A0_RX_DCB_DSCPf_GET(r) (((r).rx_dcb[8]) & 0xff)
#define BCM53324_A0_RX_DCB_DSCPf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_RX_DCB_NHOP_INDEXf_GET(r) ((((r).rx_dcb[8]) >> 8) & 0x7ff)
#define BCM53324_A0_RX_DCB_NHOP_INDEXf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x7ff << 8)) | ((((uint32_t)f) & 0x7ff) << 8))
#define BCM53324_A0_RX_DCB_MATCHED_RULEf_GET(r) ((((r).rx_dcb[8]) >> 19) & 0x7ff)
#define BCM53324_A0_RX_DCB_MATCHED_RULEf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x7ff << 19)) | ((((uint32_t)f) & 0x7ff) << 19))
#define BCM53324_A0_RX_DCB_CHANGE_DSCPf_GET(r) ((((r).rx_dcb[8]) >> 30) & 0x1)
#define BCM53324_A0_RX_DCB_CHANGE_DSCPf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_RX_DCB_CELL_ERRORf_GET(r) ((((r).rx_dcb[8]) >> 31) & 0x1)
#define BCM53324_A0_RX_DCB_CELL_ERRORf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53324_A0_RX_DCB_REASONf_GET(r) (((r).rx_dcb[7]) & 0xfffffff)
#define BCM53324_A0_RX_DCB_REASONf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))
#define BCM53324_A0_RX_DCB_CPU_COSf_GET(r) ((((r).rx_dcb[7]) >> 29) & 0x7)
#define BCM53324_A0_RX_DCB_CPU_COSf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))
#define BCM53324_A0_RX_DCB_IPMC_INTF_NUMf_GET(r) (((r).rx_dcb[6]) & 0xfff)
#define BCM53324_A0_RX_DCB_IPMC_INTF_NUMf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_RX_DCB_REGEN_CRCf_GET(r) ((((r).rx_dcb[6]) >> 12) & 0x1)
#define BCM53324_A0_RX_DCB_REGEN_CRCf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_RX_DCB_SWITCHf_GET(r) ((((r).rx_dcb[6]) >> 13) & 0x1)
#define BCM53324_A0_RX_DCB_SWITCHf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53324_A0_RX_DCB_SRC_HGf_GET(r) ((((r).rx_dcb[6]) >> 14) & 0x1)
#define BCM53324_A0_RX_DCB_SRC_HGf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53324_A0_RX_DCB_PURGE_CELLf_GET(r) ((((r).rx_dcb[6]) >> 15) & 0x1)
#define BCM53324_A0_RX_DCB_PURGE_CELLf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_RX_DCB_PKT_AGEDf_GET(r) ((((r).rx_dcb[6]) >> 16) & 0x1)
#define BCM53324_A0_RX_DCB_PKT_AGEDf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_RX_DCB_MTP_INDEXf_GET(r) ((((r).rx_dcb[6]) >> 17) & 0x7f)
#define BCM53324_A0_RX_DCB_MTP_INDEXf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x7f << 17)) | ((((uint32_t)f) & 0x7f) << 17))
#define BCM53324_A0_RX_DCB_L3UCf_GET(r) ((((r).rx_dcb[6]) >> 24) & 0x1)
#define BCM53324_A0_RX_DCB_L3UCf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53324_A0_RX_DCB_L3ONLYf_GET(r) ((((r).rx_dcb[6]) >> 25) & 0x1)
#define BCM53324_A0_RX_DCB_L3ONLYf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_RX_DCB_L3IPMCf_GET(r) ((((r).rx_dcb[6]) >> 26) & 0x1)
#define BCM53324_A0_RX_DCB_L3IPMCf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53324_A0_RX_DCB_IMIRRORf_GET(r) ((((r).rx_dcb[6]) >> 27) & 0x1)
#define BCM53324_A0_RX_DCB_IMIRRORf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53324_A0_RX_DCB_EMIRRORf_GET(r) ((((r).rx_dcb[6]) >> 28) & 0x1)
#define BCM53324_A0_RX_DCB_EMIRRORf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53324_A0_RX_DCB_BPDUf_GET(r) ((((r).rx_dcb[6]) >> 29) & 0x1)
#define BCM53324_A0_RX_DCB_BPDUf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53324_A0_RX_DCB_ADD_VIDf_GET(r) ((((r).rx_dcb[6]) >> 30) & 0x1)
#define BCM53324_A0_RX_DCB_ADD_VIDf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53324_A0_RX_DCB_DO_NOT_CHANGE_TTLf_GET(r) ((((r).rx_dcb[6]) >> 31) & 0x1)
#define BCM53324_A0_RX_DCB_DO_NOT_CHANGE_TTLf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53324_A0_RX_DCB_MODULE_HEADERf_GET(r,a) cdk_field_be_get((r).rx_dcb,11,160,287,a)
#define BCM53324_A0_RX_DCB_MODULE_HEADERf_SET(r,a) cdk_field_be_set((r).rx_dcb,11,160,287,a)
#define BCM53324_A0_RX_DCB_MODULE_HEADERf_PTR(r) ((void*)&(r).rx_dcb[2])
#define BCM53324_A0_RX_DCB_TIME_STAMPf_GET(r) ((r).rx_dcb[3])
#define BCM53324_A0_RX_DCB_TIME_STAMPf_SET(r,f) (r).rx_dcb[3]=((uint32_t)f)
#define BCM53324_A0_RX_DCB_BYTE_COUNTf_GET(r) (((r).rx_dcb[1]) & 0xffff)
#define BCM53324_A0_RX_DCB_BYTE_COUNTf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_RX_DCB_CHAINf_GET(r) ((((r).rx_dcb[1]) >> 16) & 0x1)
#define BCM53324_A0_RX_DCB_CHAINf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_RX_DCB_SGf_GET(r) ((((r).rx_dcb[1]) >> 17) & 0x1)
#define BCM53324_A0_RX_DCB_SGf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_RX_DCB_RELOADf_GET(r) ((((r).rx_dcb[1]) >> 18) & 0x1)
#define BCM53324_A0_RX_DCB_RELOADf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_RX_DCB_ADDRf_GET(r) ((r).rx_dcb[0])
#define BCM53324_A0_RX_DCB_ADDRf_SET(r,f) (r).rx_dcb[0]=((uint32_t)f)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_DCB BCM53324_A0_RX_DCB
#define RX_DCB_SIZE BCM53324_A0_RX_DCB_SIZE
typedef BCM53324_A0_RX_DCB_t RX_DCB_t;
#define RX_DCB_CLR BCM53324_A0_RX_DCB_CLR
#define RX_DCB_SET BCM53324_A0_RX_DCB_SET
#define RX_DCB_GET BCM53324_A0_RX_DCB_GET
#define RX_DCB_BYTES_TRANSFERREDf_GET BCM53324_A0_RX_DCB_BYTES_TRANSFERREDf_GET
#define RX_DCB_BYTES_TRANSFERREDf_SET BCM53324_A0_RX_DCB_BYTES_TRANSFERREDf_SET
#define RX_DCB_END_BITf_GET BCM53324_A0_RX_DCB_END_BITf_GET
#define RX_DCB_END_BITf_SET BCM53324_A0_RX_DCB_END_BITf_SET
#define RX_DCB_START_BITf_GET BCM53324_A0_RX_DCB_START_BITf_GET
#define RX_DCB_START_BITf_SET BCM53324_A0_RX_DCB_START_BITf_SET
#define RX_DCB_ERRORf_GET BCM53324_A0_RX_DCB_ERRORf_GET
#define RX_DCB_ERRORf_SET BCM53324_A0_RX_DCB_ERRORf_SET
#define RX_DCB_DONEf_GET BCM53324_A0_RX_DCB_DONEf_GET
#define RX_DCB_DONEf_SET BCM53324_A0_RX_DCB_DONEf_SET
#define RX_DCB_COSf_GET BCM53324_A0_RX_DCB_COSf_GET
#define RX_DCB_COSf_SET BCM53324_A0_RX_DCB_COSf_SET
#define RX_DCB_ADD_INNER_VLANf_GET BCM53324_A0_RX_DCB_ADD_INNER_VLANf_GET
#define RX_DCB_ADD_INNER_VLANf_SET BCM53324_A0_RX_DCB_ADD_INNER_VLANf_SET
#define RX_DCB_DECAP_IPTUNNELf_GET BCM53324_A0_RX_DCB_DECAP_IPTUNNELf_GET
#define RX_DCB_DECAP_IPTUNNELf_SET BCM53324_A0_RX_DCB_DECAP_IPTUNNELf_SET
#define RX_DCB_PKT_WAS_UNTAGGEDf_GET BCM53324_A0_RX_DCB_PKT_WAS_UNTAGGEDf_GET
#define RX_DCB_PKT_WAS_UNTAGGEDf_SET BCM53324_A0_RX_DCB_PKT_WAS_UNTAGGEDf_SET
#define RX_DCB_OUTER_VIDf_GET BCM53324_A0_RX_DCB_OUTER_VIDf_GET
#define RX_DCB_OUTER_VIDf_SET BCM53324_A0_RX_DCB_OUTER_VIDf_SET
#define RX_DCB_OUTER_CFIf_GET BCM53324_A0_RX_DCB_OUTER_CFIf_GET
#define RX_DCB_OUTER_CFIf_SET BCM53324_A0_RX_DCB_OUTER_CFIf_SET
#define RX_DCB_OUTER_PRIf_GET BCM53324_A0_RX_DCB_OUTER_PRIf_GET
#define RX_DCB_OUTER_PRIf_SET BCM53324_A0_RX_DCB_OUTER_PRIf_SET
#define RX_DCB_SRC_PORTf_GET BCM53324_A0_RX_DCB_SRC_PORTf_GET
#define RX_DCB_SRC_PORTf_SET BCM53324_A0_RX_DCB_SRC_PORTf_SET
#define RX_DCB_DSCPf_GET BCM53324_A0_RX_DCB_DSCPf_GET
#define RX_DCB_DSCPf_SET BCM53324_A0_RX_DCB_DSCPf_SET
#define RX_DCB_NHOP_INDEXf_GET BCM53324_A0_RX_DCB_NHOP_INDEXf_GET
#define RX_DCB_NHOP_INDEXf_SET BCM53324_A0_RX_DCB_NHOP_INDEXf_SET
#define RX_DCB_MATCHED_RULEf_GET BCM53324_A0_RX_DCB_MATCHED_RULEf_GET
#define RX_DCB_MATCHED_RULEf_SET BCM53324_A0_RX_DCB_MATCHED_RULEf_SET
#define RX_DCB_CHANGE_DSCPf_GET BCM53324_A0_RX_DCB_CHANGE_DSCPf_GET
#define RX_DCB_CHANGE_DSCPf_SET BCM53324_A0_RX_DCB_CHANGE_DSCPf_SET
#define RX_DCB_CELL_ERRORf_GET BCM53324_A0_RX_DCB_CELL_ERRORf_GET
#define RX_DCB_CELL_ERRORf_SET BCM53324_A0_RX_DCB_CELL_ERRORf_SET
#define RX_DCB_REASONf_GET BCM53324_A0_RX_DCB_REASONf_GET
#define RX_DCB_REASONf_SET BCM53324_A0_RX_DCB_REASONf_SET
#define RX_DCB_CPU_COSf_GET BCM53324_A0_RX_DCB_CPU_COSf_GET
#define RX_DCB_CPU_COSf_SET BCM53324_A0_RX_DCB_CPU_COSf_SET
#define RX_DCB_IPMC_INTF_NUMf_GET BCM53324_A0_RX_DCB_IPMC_INTF_NUMf_GET
#define RX_DCB_IPMC_INTF_NUMf_SET BCM53324_A0_RX_DCB_IPMC_INTF_NUMf_SET
#define RX_DCB_REGEN_CRCf_GET BCM53324_A0_RX_DCB_REGEN_CRCf_GET
#define RX_DCB_REGEN_CRCf_SET BCM53324_A0_RX_DCB_REGEN_CRCf_SET
#define RX_DCB_SWITCHf_GET BCM53324_A0_RX_DCB_SWITCHf_GET
#define RX_DCB_SWITCHf_SET BCM53324_A0_RX_DCB_SWITCHf_SET
#define RX_DCB_SRC_HGf_GET BCM53324_A0_RX_DCB_SRC_HGf_GET
#define RX_DCB_SRC_HGf_SET BCM53324_A0_RX_DCB_SRC_HGf_SET
#define RX_DCB_PURGE_CELLf_GET BCM53324_A0_RX_DCB_PURGE_CELLf_GET
#define RX_DCB_PURGE_CELLf_SET BCM53324_A0_RX_DCB_PURGE_CELLf_SET
#define RX_DCB_PKT_AGEDf_GET BCM53324_A0_RX_DCB_PKT_AGEDf_GET
#define RX_DCB_PKT_AGEDf_SET BCM53324_A0_RX_DCB_PKT_AGEDf_SET
#define RX_DCB_MTP_INDEXf_GET BCM53324_A0_RX_DCB_MTP_INDEXf_GET
#define RX_DCB_MTP_INDEXf_SET BCM53324_A0_RX_DCB_MTP_INDEXf_SET
#define RX_DCB_L3UCf_GET BCM53324_A0_RX_DCB_L3UCf_GET
#define RX_DCB_L3UCf_SET BCM53324_A0_RX_DCB_L3UCf_SET
#define RX_DCB_L3ONLYf_GET BCM53324_A0_RX_DCB_L3ONLYf_GET
#define RX_DCB_L3ONLYf_SET BCM53324_A0_RX_DCB_L3ONLYf_SET
#define RX_DCB_L3IPMCf_GET BCM53324_A0_RX_DCB_L3IPMCf_GET
#define RX_DCB_L3IPMCf_SET BCM53324_A0_RX_DCB_L3IPMCf_SET
#define RX_DCB_IMIRRORf_GET BCM53324_A0_RX_DCB_IMIRRORf_GET
#define RX_DCB_IMIRRORf_SET BCM53324_A0_RX_DCB_IMIRRORf_SET
#define RX_DCB_EMIRRORf_GET BCM53324_A0_RX_DCB_EMIRRORf_GET
#define RX_DCB_EMIRRORf_SET BCM53324_A0_RX_DCB_EMIRRORf_SET
#define RX_DCB_BPDUf_GET BCM53324_A0_RX_DCB_BPDUf_GET
#define RX_DCB_BPDUf_SET BCM53324_A0_RX_DCB_BPDUf_SET
#define RX_DCB_ADD_VIDf_GET BCM53324_A0_RX_DCB_ADD_VIDf_GET
#define RX_DCB_ADD_VIDf_SET BCM53324_A0_RX_DCB_ADD_VIDf_SET
#define RX_DCB_DO_NOT_CHANGE_TTLf_GET BCM53324_A0_RX_DCB_DO_NOT_CHANGE_TTLf_GET
#define RX_DCB_DO_NOT_CHANGE_TTLf_SET BCM53324_A0_RX_DCB_DO_NOT_CHANGE_TTLf_SET
#define RX_DCB_MODULE_HEADERf_GET BCM53324_A0_RX_DCB_MODULE_HEADERf_GET
#define RX_DCB_MODULE_HEADERf_SET BCM53324_A0_RX_DCB_MODULE_HEADERf_SET
#define RX_DCB_MODULE_HEADERf_PTR BCM53324_A0_RX_DCB_MODULE_HEADERf_PTR
#define RX_DCB_TIME_STAMPf_GET BCM53324_A0_RX_DCB_TIME_STAMPf_GET
#define RX_DCB_TIME_STAMPf_SET BCM53324_A0_RX_DCB_TIME_STAMPf_SET
#define RX_DCB_BYTE_COUNTf_GET BCM53324_A0_RX_DCB_BYTE_COUNTf_GET
#define RX_DCB_BYTE_COUNTf_SET BCM53324_A0_RX_DCB_BYTE_COUNTf_SET
#define RX_DCB_CHAINf_GET BCM53324_A0_RX_DCB_CHAINf_GET
#define RX_DCB_CHAINf_SET BCM53324_A0_RX_DCB_CHAINf_SET
#define RX_DCB_SGf_GET BCM53324_A0_RX_DCB_SGf_GET
#define RX_DCB_SGf_SET BCM53324_A0_RX_DCB_SGf_SET
#define RX_DCB_RELOADf_GET BCM53324_A0_RX_DCB_RELOADf_GET
#define RX_DCB_RELOADf_SET BCM53324_A0_RX_DCB_RELOADf_SET
#define RX_DCB_ADDRf_GET BCM53324_A0_RX_DCB_ADDRf_GET
#define RX_DCB_ADDRf_SET BCM53324_A0_RX_DCB_ADDRf_SET
#define READ_RX_DCB BCM53324_A0_READ_RX_DCB
#define WRITE_RX_DCB BCM53324_A0_WRITE_RX_DCB

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RX_DCB'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   GPORT0
 * DESC:     RX EEE LPI Duration Counter.
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr 0x0000003d

#define BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program RX_EEE_LPI_DURATION_COUNTER.
 *
 */
typedef union BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_s {
	uint32_t v[1];
	uint32_t rx_eee_lpi_duration_counter[1];
	uint32_t _rx_eee_lpi_duration_counter;
} BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_t;

#define BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_CLR(r) (r).rx_eee_lpi_duration_counter[0] = 0
#define BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_SET(r,d) (r).rx_eee_lpi_duration_counter[0] = d
#define BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_GET(r) (r).rx_eee_lpi_duration_counter[0]


/*
 * These macros can be used to access RX_EEE_LPI_DURATION_COUNTER.
 *
 */
#define BCM53324_A0_READ_RX_EEE_LPI_DURATION_COUNTERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr,(r._rx_eee_lpi_duration_counter))
#define BCM53324_A0_WRITE_RX_EEE_LPI_DURATION_COUNTERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr,&(r._rx_eee_lpi_duration_counter))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_EEE_LPI_DURATION_COUNTERr BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr
#define RX_EEE_LPI_DURATION_COUNTERr_SIZE BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_SIZE
typedef BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_t RX_EEE_LPI_DURATION_COUNTERr_t;
#define RX_EEE_LPI_DURATION_COUNTERr_CLR BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_CLR
#define RX_EEE_LPI_DURATION_COUNTERr_SET BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_SET
#define RX_EEE_LPI_DURATION_COUNTERr_GET BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr_GET
#define READ_RX_EEE_LPI_DURATION_COUNTERr BCM53324_A0_READ_RX_EEE_LPI_DURATION_COUNTERr
#define WRITE_RX_EEE_LPI_DURATION_COUNTERr BCM53324_A0_WRITE_RX_EEE_LPI_DURATION_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RX_EEE_LPI_DURATION_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  RX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   GPORT0
 * DESC:     RX EEE LPI Event Counter.
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr 0x0000003c

#define BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program RX_EEE_LPI_EVENT_COUNTER.
 *
 */
typedef union BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_s {
	uint32_t v[1];
	uint32_t rx_eee_lpi_event_counter[1];
	uint32_t _rx_eee_lpi_event_counter;
} BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_t;

#define BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_CLR(r) (r).rx_eee_lpi_event_counter[0] = 0
#define BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_SET(r,d) (r).rx_eee_lpi_event_counter[0] = d
#define BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_GET(r) (r).rx_eee_lpi_event_counter[0]


/*
 * These macros can be used to access RX_EEE_LPI_EVENT_COUNTER.
 *
 */
#define BCM53324_A0_READ_RX_EEE_LPI_EVENT_COUNTERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr,(r._rx_eee_lpi_event_counter))
#define BCM53324_A0_WRITE_RX_EEE_LPI_EVENT_COUNTERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr,&(r._rx_eee_lpi_event_counter))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_EEE_LPI_EVENT_COUNTERr BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr
#define RX_EEE_LPI_EVENT_COUNTERr_SIZE BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_SIZE
typedef BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_t RX_EEE_LPI_EVENT_COUNTERr_t;
#define RX_EEE_LPI_EVENT_COUNTERr_CLR BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_CLR
#define RX_EEE_LPI_EVENT_COUNTERr_SET BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_SET
#define RX_EEE_LPI_EVENT_COUNTERr_GET BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr_GET
#define READ_RX_EEE_LPI_EVENT_COUNTERr BCM53324_A0_READ_RX_EEE_LPI_EVENT_COUNTERr
#define WRITE_RX_EEE_LPI_EVENT_COUNTERr BCM53324_A0_WRITE_RX_EEE_LPI_EVENT_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_RX_EEE_LPI_EVENT_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SC_BYTE_METER_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Byte Based Metering Control Register
 * SIZE:     32
 * FIELDS:
 *     DLFBC_ENABLE     DLF byte based storm rate control enable
 *     MCAST_ENABLE     Multicast byte based storm rate control enable
 *     BCAST_ENABLE     Broadcast byte based storm rate control enable
 *
 ******************************************************************************/
#define BCM53324_A0_SC_BYTE_METER_CONFIGr 0x0c70000b

#define BCM53324_A0_SC_BYTE_METER_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SC_BYTE_METER_CONFIG.
 *
 */
typedef union BCM53324_A0_SC_BYTE_METER_CONFIGr_s {
	uint32_t v[1];
	uint32_t sc_byte_meter_config[1];
	uint32_t _sc_byte_meter_config;
} BCM53324_A0_SC_BYTE_METER_CONFIGr_t;

#define BCM53324_A0_SC_BYTE_METER_CONFIGr_CLR(r) (r).sc_byte_meter_config[0] = 0
#define BCM53324_A0_SC_BYTE_METER_CONFIGr_SET(r,d) (r).sc_byte_meter_config[0] = d
#define BCM53324_A0_SC_BYTE_METER_CONFIGr_GET(r) (r).sc_byte_meter_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_GET(r) (((r).sc_byte_meter_config[0]) & 0x1)
#define BCM53324_A0_SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_SET(r,f) (r).sc_byte_meter_config[0]=(((r).sc_byte_meter_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_GET(r) ((((r).sc_byte_meter_config[0]) >> 1) & 0x1)
#define BCM53324_A0_SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_SET(r,f) (r).sc_byte_meter_config[0]=(((r).sc_byte_meter_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_GET(r) ((((r).sc_byte_meter_config[0]) >> 2) & 0x1)
#define BCM53324_A0_SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_SET(r,f) (r).sc_byte_meter_config[0]=(((r).sc_byte_meter_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access SC_BYTE_METER_CONFIG.
 *
 */
#define BCM53324_A0_READ_SC_BYTE_METER_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_SC_BYTE_METER_CONFIGr,(r._sc_byte_meter_config))
#define BCM53324_A0_WRITE_SC_BYTE_METER_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_SC_BYTE_METER_CONFIGr,&(r._sc_byte_meter_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SC_BYTE_METER_CONFIGr BCM53324_A0_SC_BYTE_METER_CONFIGr
#define SC_BYTE_METER_CONFIGr_SIZE BCM53324_A0_SC_BYTE_METER_CONFIGr_SIZE
typedef BCM53324_A0_SC_BYTE_METER_CONFIGr_t SC_BYTE_METER_CONFIGr_t;
#define SC_BYTE_METER_CONFIGr_CLR BCM53324_A0_SC_BYTE_METER_CONFIGr_CLR
#define SC_BYTE_METER_CONFIGr_SET BCM53324_A0_SC_BYTE_METER_CONFIGr_SET
#define SC_BYTE_METER_CONFIGr_GET BCM53324_A0_SC_BYTE_METER_CONFIGr_GET
#define SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_GET BCM53324_A0_SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_GET
#define SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_SET BCM53324_A0_SC_BYTE_METER_CONFIGr_DLFBC_ENABLEf_SET
#define SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_GET BCM53324_A0_SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_GET
#define SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_SET BCM53324_A0_SC_BYTE_METER_CONFIGr_MCAST_ENABLEf_SET
#define SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_GET BCM53324_A0_SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_GET
#define SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_SET BCM53324_A0_SC_BYTE_METER_CONFIGr_BCAST_ENABLEf_SET
#define READ_SC_BYTE_METER_CONFIGr BCM53324_A0_READ_SC_BYTE_METER_CONFIGr
#define WRITE_SC_BYTE_METER_CONFIGr BCM53324_A0_WRITE_SC_BYTE_METER_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SC_BYTE_METER_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SFD_OFFSET
 * BLOCKS:   GPORT0
 * DESC:     EFM Preamble Length.
 * SIZE:     32
 * FIELDS:
 *     SFD_OFFSET       Defines the length of the EFM preamble between 5 and 15 Bytes. When set to 0, 1, 2, 3 or 4,the Preamble EFM length is set to 5 Bytes.
 *
 ******************************************************************************/
#define BCM53324_A0_SFD_OFFSETr 0x00000110

#define BCM53324_A0_SFD_OFFSETr_SIZE 4

/*
 * This structure should be used to declare and program SFD_OFFSET.
 *
 */
typedef union BCM53324_A0_SFD_OFFSETr_s {
	uint32_t v[1];
	uint32_t sfd_offset[1];
	uint32_t _sfd_offset;
} BCM53324_A0_SFD_OFFSETr_t;

#define BCM53324_A0_SFD_OFFSETr_CLR(r) (r).sfd_offset[0] = 0
#define BCM53324_A0_SFD_OFFSETr_SET(r,d) (r).sfd_offset[0] = d
#define BCM53324_A0_SFD_OFFSETr_GET(r) (r).sfd_offset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SFD_OFFSETr_SFD_OFFSETf_GET(r) (((r).sfd_offset[0]) & 0xf)
#define BCM53324_A0_SFD_OFFSETr_SFD_OFFSETf_SET(r,f) (r).sfd_offset[0]=(((r).sfd_offset[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access SFD_OFFSET.
 *
 */
#define BCM53324_A0_READ_SFD_OFFSETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_SFD_OFFSETr,(r._sfd_offset))
#define BCM53324_A0_WRITE_SFD_OFFSETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_SFD_OFFSETr,&(r._sfd_offset))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFD_OFFSETr BCM53324_A0_SFD_OFFSETr
#define SFD_OFFSETr_SIZE BCM53324_A0_SFD_OFFSETr_SIZE
typedef BCM53324_A0_SFD_OFFSETr_t SFD_OFFSETr_t;
#define SFD_OFFSETr_CLR BCM53324_A0_SFD_OFFSETr_CLR
#define SFD_OFFSETr_SET BCM53324_A0_SFD_OFFSETr_SET
#define SFD_OFFSETr_GET BCM53324_A0_SFD_OFFSETr_GET
#define SFD_OFFSETr_SFD_OFFSETf_GET BCM53324_A0_SFD_OFFSETr_SFD_OFFSETf_GET
#define SFD_OFFSETr_SFD_OFFSETf_SET BCM53324_A0_SFD_OFFSETr_SFD_OFFSETf_SET
#define READ_SFD_OFFSETr BCM53324_A0_READ_SFD_OFFSETr
#define WRITE_SFD_OFFSETr BCM53324_A0_WRITE_SFD_OFFSETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SFD_OFFSETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SFLOW_EGR_RAND_SEED
 * BLOCKS:   IPIPE
 * DESC:     sFlow Egress Random Number Generator Seed Register
 * SIZE:     32
 * FIELDS:
 *     SEED             Seed for sFlow Egress Random Number Generator
 *
 ******************************************************************************/
#define BCM53324_A0_SFLOW_EGR_RAND_SEEDr 0x0f780127

#define BCM53324_A0_SFLOW_EGR_RAND_SEEDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_EGR_RAND_SEED.
 *
 */
typedef union BCM53324_A0_SFLOW_EGR_RAND_SEEDr_s {
	uint32_t v[1];
	uint32_t sflow_egr_rand_seed[1];
	uint32_t _sflow_egr_rand_seed;
} BCM53324_A0_SFLOW_EGR_RAND_SEEDr_t;

#define BCM53324_A0_SFLOW_EGR_RAND_SEEDr_CLR(r) (r).sflow_egr_rand_seed[0] = 0
#define BCM53324_A0_SFLOW_EGR_RAND_SEEDr_SET(r,d) (r).sflow_egr_rand_seed[0] = d
#define BCM53324_A0_SFLOW_EGR_RAND_SEEDr_GET(r) (r).sflow_egr_rand_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_GET(r) (((r).sflow_egr_rand_seed[0]) & 0x1ffffff)
#define BCM53324_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_SET(r,f) (r).sflow_egr_rand_seed[0]=(((r).sflow_egr_rand_seed[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SFLOW_EGR_RAND_SEED.
 *
 */
#define BCM53324_A0_READ_SFLOW_EGR_RAND_SEEDr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_SFLOW_EGR_RAND_SEEDr,(r._sflow_egr_rand_seed))
#define BCM53324_A0_WRITE_SFLOW_EGR_RAND_SEEDr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_SFLOW_EGR_RAND_SEEDr,&(r._sflow_egr_rand_seed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_EGR_RAND_SEEDr BCM53324_A0_SFLOW_EGR_RAND_SEEDr
#define SFLOW_EGR_RAND_SEEDr_SIZE BCM53324_A0_SFLOW_EGR_RAND_SEEDr_SIZE
typedef BCM53324_A0_SFLOW_EGR_RAND_SEEDr_t SFLOW_EGR_RAND_SEEDr_t;
#define SFLOW_EGR_RAND_SEEDr_CLR BCM53324_A0_SFLOW_EGR_RAND_SEEDr_CLR
#define SFLOW_EGR_RAND_SEEDr_SET BCM53324_A0_SFLOW_EGR_RAND_SEEDr_SET
#define SFLOW_EGR_RAND_SEEDr_GET BCM53324_A0_SFLOW_EGR_RAND_SEEDr_GET
#define SFLOW_EGR_RAND_SEEDr_SEEDf_GET BCM53324_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_GET
#define SFLOW_EGR_RAND_SEEDr_SEEDf_SET BCM53324_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_SET
#define READ_SFLOW_EGR_RAND_SEEDr BCM53324_A0_READ_SFLOW_EGR_RAND_SEEDr
#define WRITE_SFLOW_EGR_RAND_SEEDr BCM53324_A0_WRITE_SFLOW_EGR_RAND_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SFLOW_EGR_RAND_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SFLOW_EGR_THRESHOLD
 * BLOCKS:   IPIPE
 * DESC:     sFlow Egress Threshold Register
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        sFlow Egress Threshold Value
 *     ENABLE           Enable sFlow Egress
 *
 ******************************************************************************/
#define BCM53324_A0_SFLOW_EGR_THRESHOLDr 0x0f70010c

#define BCM53324_A0_SFLOW_EGR_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_EGR_THRESHOLD.
 *
 */
typedef union BCM53324_A0_SFLOW_EGR_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t sflow_egr_threshold[1];
	uint32_t _sflow_egr_threshold;
} BCM53324_A0_SFLOW_EGR_THRESHOLDr_t;

#define BCM53324_A0_SFLOW_EGR_THRESHOLDr_CLR(r) (r).sflow_egr_threshold[0] = 0
#define BCM53324_A0_SFLOW_EGR_THRESHOLDr_SET(r,d) (r).sflow_egr_threshold[0] = d
#define BCM53324_A0_SFLOW_EGR_THRESHOLDr_GET(r) (r).sflow_egr_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET(r) (((r).sflow_egr_threshold[0]) & 0xffff)
#define BCM53324_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET(r,f) (r).sflow_egr_threshold[0]=(((r).sflow_egr_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_GET(r) ((((r).sflow_egr_threshold[0]) >> 16) & 0x1)
#define BCM53324_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_SET(r,f) (r).sflow_egr_threshold[0]=(((r).sflow_egr_threshold[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access SFLOW_EGR_THRESHOLD.
 *
 */
#define BCM53324_A0_READ_SFLOW_EGR_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_SFLOW_EGR_THRESHOLDr,(r._sflow_egr_threshold))
#define BCM53324_A0_WRITE_SFLOW_EGR_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_SFLOW_EGR_THRESHOLDr,&(r._sflow_egr_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_EGR_THRESHOLDr BCM53324_A0_SFLOW_EGR_THRESHOLDr
#define SFLOW_EGR_THRESHOLDr_SIZE BCM53324_A0_SFLOW_EGR_THRESHOLDr_SIZE
typedef BCM53324_A0_SFLOW_EGR_THRESHOLDr_t SFLOW_EGR_THRESHOLDr_t;
#define SFLOW_EGR_THRESHOLDr_CLR BCM53324_A0_SFLOW_EGR_THRESHOLDr_CLR
#define SFLOW_EGR_THRESHOLDr_SET BCM53324_A0_SFLOW_EGR_THRESHOLDr_SET
#define SFLOW_EGR_THRESHOLDr_GET BCM53324_A0_SFLOW_EGR_THRESHOLDr_GET
#define SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET BCM53324_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET
#define SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET BCM53324_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET
#define SFLOW_EGR_THRESHOLDr_ENABLEf_GET BCM53324_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_GET
#define SFLOW_EGR_THRESHOLDr_ENABLEf_SET BCM53324_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_SET
#define READ_SFLOW_EGR_THRESHOLDr BCM53324_A0_READ_SFLOW_EGR_THRESHOLDr
#define WRITE_SFLOW_EGR_THRESHOLDr BCM53324_A0_WRITE_SFLOW_EGR_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SFLOW_EGR_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SFLOW_ING_RAND_SEED
 * BLOCKS:   IPIPE
 * DESC:     sFlow Ingress Random Number Generator Seed Register
 * SIZE:     32
 * FIELDS:
 *     SEED             Seed for sFlow Ingress Random Number Generator
 *
 ******************************************************************************/
#define BCM53324_A0_SFLOW_ING_RAND_SEEDr 0x0f780126

#define BCM53324_A0_SFLOW_ING_RAND_SEEDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_ING_RAND_SEED.
 *
 */
typedef union BCM53324_A0_SFLOW_ING_RAND_SEEDr_s {
	uint32_t v[1];
	uint32_t sflow_ing_rand_seed[1];
	uint32_t _sflow_ing_rand_seed;
} BCM53324_A0_SFLOW_ING_RAND_SEEDr_t;

#define BCM53324_A0_SFLOW_ING_RAND_SEEDr_CLR(r) (r).sflow_ing_rand_seed[0] = 0
#define BCM53324_A0_SFLOW_ING_RAND_SEEDr_SET(r,d) (r).sflow_ing_rand_seed[0] = d
#define BCM53324_A0_SFLOW_ING_RAND_SEEDr_GET(r) (r).sflow_ing_rand_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SFLOW_ING_RAND_SEEDr_SEEDf_GET(r) (((r).sflow_ing_rand_seed[0]) & 0x1ffffff)
#define BCM53324_A0_SFLOW_ING_RAND_SEEDr_SEEDf_SET(r,f) (r).sflow_ing_rand_seed[0]=(((r).sflow_ing_rand_seed[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SFLOW_ING_RAND_SEED.
 *
 */
#define BCM53324_A0_READ_SFLOW_ING_RAND_SEEDr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_SFLOW_ING_RAND_SEEDr,(r._sflow_ing_rand_seed))
#define BCM53324_A0_WRITE_SFLOW_ING_RAND_SEEDr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_SFLOW_ING_RAND_SEEDr,&(r._sflow_ing_rand_seed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_ING_RAND_SEEDr BCM53324_A0_SFLOW_ING_RAND_SEEDr
#define SFLOW_ING_RAND_SEEDr_SIZE BCM53324_A0_SFLOW_ING_RAND_SEEDr_SIZE
typedef BCM53324_A0_SFLOW_ING_RAND_SEEDr_t SFLOW_ING_RAND_SEEDr_t;
#define SFLOW_ING_RAND_SEEDr_CLR BCM53324_A0_SFLOW_ING_RAND_SEEDr_CLR
#define SFLOW_ING_RAND_SEEDr_SET BCM53324_A0_SFLOW_ING_RAND_SEEDr_SET
#define SFLOW_ING_RAND_SEEDr_GET BCM53324_A0_SFLOW_ING_RAND_SEEDr_GET
#define SFLOW_ING_RAND_SEEDr_SEEDf_GET BCM53324_A0_SFLOW_ING_RAND_SEEDr_SEEDf_GET
#define SFLOW_ING_RAND_SEEDr_SEEDf_SET BCM53324_A0_SFLOW_ING_RAND_SEEDr_SEEDf_SET
#define READ_SFLOW_ING_RAND_SEEDr BCM53324_A0_READ_SFLOW_ING_RAND_SEEDr
#define WRITE_SFLOW_ING_RAND_SEEDr BCM53324_A0_WRITE_SFLOW_ING_RAND_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SFLOW_ING_RAND_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SFLOW_ING_THRESHOLD
 * BLOCKS:   IPIPE
 * DESC:     sFlow Ingress Threshold Register
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        sFlow Ingress Threshold Value
 *     ENABLE           Enable sFlow Ingress
 *
 ******************************************************************************/
#define BCM53324_A0_SFLOW_ING_THRESHOLDr 0x0f70010b

#define BCM53324_A0_SFLOW_ING_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_ING_THRESHOLD.
 *
 */
typedef union BCM53324_A0_SFLOW_ING_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t sflow_ing_threshold[1];
	uint32_t _sflow_ing_threshold;
} BCM53324_A0_SFLOW_ING_THRESHOLDr_t;

#define BCM53324_A0_SFLOW_ING_THRESHOLDr_CLR(r) (r).sflow_ing_threshold[0] = 0
#define BCM53324_A0_SFLOW_ING_THRESHOLDr_SET(r,d) (r).sflow_ing_threshold[0] = d
#define BCM53324_A0_SFLOW_ING_THRESHOLDr_GET(r) (r).sflow_ing_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_GET(r) (((r).sflow_ing_threshold[0]) & 0xffff)
#define BCM53324_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_SET(r,f) (r).sflow_ing_threshold[0]=(((r).sflow_ing_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_SFLOW_ING_THRESHOLDr_ENABLEf_GET(r) ((((r).sflow_ing_threshold[0]) >> 16) & 0x1)
#define BCM53324_A0_SFLOW_ING_THRESHOLDr_ENABLEf_SET(r,f) (r).sflow_ing_threshold[0]=(((r).sflow_ing_threshold[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access SFLOW_ING_THRESHOLD.
 *
 */
#define BCM53324_A0_READ_SFLOW_ING_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_SFLOW_ING_THRESHOLDr,(r._sflow_ing_threshold))
#define BCM53324_A0_WRITE_SFLOW_ING_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_SFLOW_ING_THRESHOLDr,&(r._sflow_ing_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_ING_THRESHOLDr BCM53324_A0_SFLOW_ING_THRESHOLDr
#define SFLOW_ING_THRESHOLDr_SIZE BCM53324_A0_SFLOW_ING_THRESHOLDr_SIZE
typedef BCM53324_A0_SFLOW_ING_THRESHOLDr_t SFLOW_ING_THRESHOLDr_t;
#define SFLOW_ING_THRESHOLDr_CLR BCM53324_A0_SFLOW_ING_THRESHOLDr_CLR
#define SFLOW_ING_THRESHOLDr_SET BCM53324_A0_SFLOW_ING_THRESHOLDr_SET
#define SFLOW_ING_THRESHOLDr_GET BCM53324_A0_SFLOW_ING_THRESHOLDr_GET
#define SFLOW_ING_THRESHOLDr_THRESHOLDf_GET BCM53324_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_GET
#define SFLOW_ING_THRESHOLDr_THRESHOLDf_SET BCM53324_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_SET
#define SFLOW_ING_THRESHOLDr_ENABLEf_GET BCM53324_A0_SFLOW_ING_THRESHOLDr_ENABLEf_GET
#define SFLOW_ING_THRESHOLDr_ENABLEf_SET BCM53324_A0_SFLOW_ING_THRESHOLDr_ENABLEf_SET
#define READ_SFLOW_ING_THRESHOLDr BCM53324_A0_READ_SFLOW_ING_THRESHOLDr
#define WRITE_SFLOW_ING_THRESHOLDr BCM53324_A0_WRITE_SFLOW_ING_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SFLOW_ING_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SIMPLEREDCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     COS0THDMODE      To choose congestion threshold semantics for applying Simple RED drop probability for COS 0 on packet admission.0: Use HOLCOS0PKTLIMIT for 100% drop of all packets,   Use CNGCOS0PKTSETLIMIT0 for Red colored packets and   Use CNGCOS0PKTSETLIMIT1 for yellow colored packets.1: Use HOLCOS0PKTLIMIT for 100% drop of all packets,   Use CNGCOS0PKTSETLIMIT0 for Red and Yellow colored packets and   Use CNGCOS0PKTSETLIMIT1 for Green colored packets   
 *     COS1THDMODE      To choose congestion threshold semantics for applying Simple RED drop probability for COS 1 on packet admission.0: Use HOLCOS1PKTLIMIT for 100% drop of all packets,   Use CNGCOS1PKTSETLIMIT0 for Red colored packets and   Use CNGCOS1PKTSETLIMIT1 for Yellow colored packets.1: Use HOLCOS1PKTLIMIT for 100% drop of all packets,   Use CNGCOS1PKTSETLIMIT0 for Red and Yellow colored packets and   Use CNGCOS1PKTSETLIMIT1 for Green colored packets   
 *     COS2THDMODE      To choose congestion threshold semantics for applying Simple RED drop probability for COS 2 on packet admission.0: Use HOLCOS2PKTLIMIT for 100% drop of all packets,   Use CNGCOS2PKTSETLIMIT0 for Red colored packets and   Use CNGCOS2PKTSETLIMIT1 for Yellow colored packets.1: Use HOLCOS2PKTLIMIT for 100% drop of all packets,   Use CNGCOS2PKTSETLIMIT0 for Red and Yellow colored packets and   Use CNGCOS2PKTSETLIMIT1 for Green colored packets   
 *     COS3THDMODE      To choose congestion threshold semantics for applying Simple RED drop probability for COS 3 on packet admission.0: Use HOLCOS3PKTLIMIT for 100% drop of all packets,   Use CNGCOS3PKTSETLIMIT0 for Red colored packets and   Use CNGCOS3PKTSETLIMIT1 for yellow colored packets.1: Use HOLCOS3PKTLIMIT for 100% drop of all packets,   Use CNGCOS3PKTSETLIMIT0 for Red and Yellow colored packets and   Use CNGCOS3PKTSETLIMIT1 for Green colored packets   
 *
 ******************************************************************************/
#define BCM53324_A0_SIMPLEREDCONFIGr 0x00600093

#define BCM53324_A0_SIMPLEREDCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program SIMPLEREDCONFIG.
 *
 */
typedef union BCM53324_A0_SIMPLEREDCONFIGr_s {
	uint32_t v[1];
	uint32_t simpleredconfig[1];
	uint32_t _simpleredconfig;
} BCM53324_A0_SIMPLEREDCONFIGr_t;

#define BCM53324_A0_SIMPLEREDCONFIGr_CLR(r) (r).simpleredconfig[0] = 0
#define BCM53324_A0_SIMPLEREDCONFIGr_SET(r,d) (r).simpleredconfig[0] = d
#define BCM53324_A0_SIMPLEREDCONFIGr_GET(r) (r).simpleredconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SIMPLEREDCONFIGr_COS0THDMODEf_GET(r) (((r).simpleredconfig[0]) & 0x1)
#define BCM53324_A0_SIMPLEREDCONFIGr_COS0THDMODEf_SET(r,f) (r).simpleredconfig[0]=(((r).simpleredconfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_SIMPLEREDCONFIGr_COS1THDMODEf_GET(r) ((((r).simpleredconfig[0]) >> 1) & 0x1)
#define BCM53324_A0_SIMPLEREDCONFIGr_COS1THDMODEf_SET(r,f) (r).simpleredconfig[0]=(((r).simpleredconfig[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_SIMPLEREDCONFIGr_COS2THDMODEf_GET(r) ((((r).simpleredconfig[0]) >> 2) & 0x1)
#define BCM53324_A0_SIMPLEREDCONFIGr_COS2THDMODEf_SET(r,f) (r).simpleredconfig[0]=(((r).simpleredconfig[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_SIMPLEREDCONFIGr_COS3THDMODEf_GET(r) ((((r).simpleredconfig[0]) >> 3) & 0x1)
#define BCM53324_A0_SIMPLEREDCONFIGr_COS3THDMODEf_SET(r,f) (r).simpleredconfig[0]=(((r).simpleredconfig[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access SIMPLEREDCONFIG.
 *
 */
#define BCM53324_A0_READ_SIMPLEREDCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_SIMPLEREDCONFIGr,(r._simpleredconfig))
#define BCM53324_A0_WRITE_SIMPLEREDCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_SIMPLEREDCONFIGr,&(r._simpleredconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SIMPLEREDCONFIGr BCM53324_A0_SIMPLEREDCONFIGr
#define SIMPLEREDCONFIGr_SIZE BCM53324_A0_SIMPLEREDCONFIGr_SIZE
typedef BCM53324_A0_SIMPLEREDCONFIGr_t SIMPLEREDCONFIGr_t;
#define SIMPLEREDCONFIGr_CLR BCM53324_A0_SIMPLEREDCONFIGr_CLR
#define SIMPLEREDCONFIGr_SET BCM53324_A0_SIMPLEREDCONFIGr_SET
#define SIMPLEREDCONFIGr_GET BCM53324_A0_SIMPLEREDCONFIGr_GET
#define SIMPLEREDCONFIGr_COS0THDMODEf_GET BCM53324_A0_SIMPLEREDCONFIGr_COS0THDMODEf_GET
#define SIMPLEREDCONFIGr_COS0THDMODEf_SET BCM53324_A0_SIMPLEREDCONFIGr_COS0THDMODEf_SET
#define SIMPLEREDCONFIGr_COS1THDMODEf_GET BCM53324_A0_SIMPLEREDCONFIGr_COS1THDMODEf_GET
#define SIMPLEREDCONFIGr_COS1THDMODEf_SET BCM53324_A0_SIMPLEREDCONFIGr_COS1THDMODEf_SET
#define SIMPLEREDCONFIGr_COS2THDMODEf_GET BCM53324_A0_SIMPLEREDCONFIGr_COS2THDMODEf_GET
#define SIMPLEREDCONFIGr_COS2THDMODEf_SET BCM53324_A0_SIMPLEREDCONFIGr_COS2THDMODEf_SET
#define SIMPLEREDCONFIGr_COS3THDMODEf_GET BCM53324_A0_SIMPLEREDCONFIGr_COS3THDMODEf_GET
#define SIMPLEREDCONFIGr_COS3THDMODEf_SET BCM53324_A0_SIMPLEREDCONFIGr_COS3THDMODEf_SET
#define READ_SIMPLEREDCONFIGr BCM53324_A0_READ_SIMPLEREDCONFIGr
#define WRITE_SIMPLEREDCONFIGr BCM53324_A0_WRITE_SIMPLEREDCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SIMPLEREDCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SOFTRESETPBM
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     SOFTRESETPBM     Ingress Port Bitmap indicats which Ingress Port is generating software reset error. 
 *
 ******************************************************************************/
#define BCM53324_A0_SOFTRESETPBMr 0x0068002c

#define BCM53324_A0_SOFTRESETPBMr_SIZE 4

/*
 * This structure should be used to declare and program SOFTRESETPBM.
 *
 */
typedef union BCM53324_A0_SOFTRESETPBMr_s {
	uint32_t v[1];
	uint32_t softresetpbm[1];
	uint32_t _softresetpbm;
} BCM53324_A0_SOFTRESETPBMr_t;

#define BCM53324_A0_SOFTRESETPBMr_CLR(r) (r).softresetpbm[0] = 0
#define BCM53324_A0_SOFTRESETPBMr_SET(r,d) (r).softresetpbm[0] = d
#define BCM53324_A0_SOFTRESETPBMr_GET(r) (r).softresetpbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SOFTRESETPBMr_SOFTRESETPBMf_GET(r) (((r).softresetpbm[0]) & 0x1ffffff)
#define BCM53324_A0_SOFTRESETPBMr_SOFTRESETPBMf_SET(r,f) (r).softresetpbm[0]=(((r).softresetpbm[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SOFTRESETPBM.
 *
 */
#define BCM53324_A0_READ_SOFTRESETPBMr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_SOFTRESETPBMr,(r._softresetpbm))
#define BCM53324_A0_WRITE_SOFTRESETPBMr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_SOFTRESETPBMr,&(r._softresetpbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTRESETPBMr BCM53324_A0_SOFTRESETPBMr
#define SOFTRESETPBMr_SIZE BCM53324_A0_SOFTRESETPBMr_SIZE
typedef BCM53324_A0_SOFTRESETPBMr_t SOFTRESETPBMr_t;
#define SOFTRESETPBMr_CLR BCM53324_A0_SOFTRESETPBMr_CLR
#define SOFTRESETPBMr_SET BCM53324_A0_SOFTRESETPBMr_SET
#define SOFTRESETPBMr_GET BCM53324_A0_SOFTRESETPBMr_GET
#define SOFTRESETPBMr_SOFTRESETPBMf_GET BCM53324_A0_SOFTRESETPBMr_SOFTRESETPBMf_GET
#define SOFTRESETPBMr_SOFTRESETPBMf_SET BCM53324_A0_SOFTRESETPBMr_SOFTRESETPBMf_SET
#define READ_SOFTRESETPBMr BCM53324_A0_READ_SOFTRESETPBMr
#define WRITE_SOFTRESETPBMr BCM53324_A0_WRITE_SOFTRESETPBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SOFTRESETPBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     7
 * FIELDS:
 *     CMIC             Software Block Flag for CMIC
 *     EPIPE            Software Block Flag for EPIPE
 *     EPIPE_HI         Software Block Flag for EPIPE_HI
 *     GPORT            Software Block Flag for GPORT
 *     IPIPE            Software Block Flag for IPIPE
 *     IPIPE_HI         Software Block Flag for IPIPE_HI
 *     MMU              Software Block Flag for MMU
 *
 ******************************************************************************/
#define BCM53324_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM53324_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM53324_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM53324_A0_SOFTWARE_BLOCKMAP_t;

#define BCM53324_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM53324_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM53324_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SOFTWARE_BLOCKMAP_CMICf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM53324_A0_SOFTWARE_BLOCKMAP_CMICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_SOFTWARE_BLOCKMAP_EPIPEf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM53324_A0_SOFTWARE_BLOCKMAP_EPIPEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM53324_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_SOFTWARE_BLOCKMAP_GPORTf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM53324_A0_SOFTWARE_BLOCKMAP_GPORTf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_SOFTWARE_BLOCKMAP_IPIPEf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM53324_A0_SOFTWARE_BLOCKMAP_IPIPEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_GET(r) ((((r).software_blockmap[0]) >> 5) & 0x1)
#define BCM53324_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_SOFTWARE_BLOCKMAP_MMUf_GET(r) ((((r).software_blockmap[0]) >> 6) & 0x1)
#define BCM53324_A0_SOFTWARE_BLOCKMAP_MMUf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM53324_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM53324_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM53324_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM53324_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM53324_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM53324_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_CMICf_GET BCM53324_A0_SOFTWARE_BLOCKMAP_CMICf_GET
#define SOFTWARE_BLOCKMAP_CMICf_SET BCM53324_A0_SOFTWARE_BLOCKMAP_CMICf_SET
#define SOFTWARE_BLOCKMAP_EPIPEf_GET BCM53324_A0_SOFTWARE_BLOCKMAP_EPIPEf_GET
#define SOFTWARE_BLOCKMAP_EPIPEf_SET BCM53324_A0_SOFTWARE_BLOCKMAP_EPIPEf_SET
#define SOFTWARE_BLOCKMAP_EPIPE_HIf_GET BCM53324_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_GET
#define SOFTWARE_BLOCKMAP_EPIPE_HIf_SET BCM53324_A0_SOFTWARE_BLOCKMAP_EPIPE_HIf_SET
#define SOFTWARE_BLOCKMAP_GPORTf_GET BCM53324_A0_SOFTWARE_BLOCKMAP_GPORTf_GET
#define SOFTWARE_BLOCKMAP_GPORTf_SET BCM53324_A0_SOFTWARE_BLOCKMAP_GPORTf_SET
#define SOFTWARE_BLOCKMAP_IPIPEf_GET BCM53324_A0_SOFTWARE_BLOCKMAP_IPIPEf_GET
#define SOFTWARE_BLOCKMAP_IPIPEf_SET BCM53324_A0_SOFTWARE_BLOCKMAP_IPIPEf_SET
#define SOFTWARE_BLOCKMAP_IPIPE_HIf_GET BCM53324_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_GET
#define SOFTWARE_BLOCKMAP_IPIPE_HIf_SET BCM53324_A0_SOFTWARE_BLOCKMAP_IPIPE_HIf_SET
#define SOFTWARE_BLOCKMAP_MMUf_GET BCM53324_A0_SOFTWARE_BLOCKMAP_MMUf_GET
#define SOFTWARE_BLOCKMAP_MMUf_SET BCM53324_A0_SOFTWARE_BLOCKMAP_MMUf_SET
#define READ_SOFTWARE_BLOCKMAP BCM53324_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM53324_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  SOURCE_TRUNK_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Map Table, Indexed by {mh_src_mod_id[3:0], mh_src_port_tgid[5:0]} for higig packet, else indexed by {my_modid[3:0], ingress_port}
 * SIZE:     7
 * FIELDS:
 *     PORT_TYPE        Indicates source port type
 *     TGID             Source port TGID (32 tgid support only)
 *
 ******************************************************************************/
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm 0x02710000

#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_MIN 0
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_MAX 63
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_CMAX(u) 63
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program SOURCE_TRUNK_MAP_TABLE.
 *
 */
typedef union BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t source_trunk_map_table[1];
	uint32_t _source_trunk_map_table;
} BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_t;

#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_CLR(r) (r).source_trunk_map_table[0] = 0
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_SET(r,d) (r).source_trunk_map_table[0] = d
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_GET(r) (r).source_trunk_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET(r) (((r).source_trunk_map_table[0]) & 0x3)
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET(r,f) (r).source_trunk_map_table[0]=(((r).source_trunk_map_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET(r) ((((r).source_trunk_map_table[0]) >> 2) & 0x1f)
#define BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET(r,f) (r).source_trunk_map_table[0]=(((r).source_trunk_map_table[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))

/*
 * These macros can be used to access SOURCE_TRUNK_MAP_TABLE.
 *
 */
#define BCM53324_A0_READ_SOURCE_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm,i,(m._source_trunk_map_table),1)
#define BCM53324_A0_WRITE_SOURCE_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm,i,&(m._source_trunk_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOURCE_TRUNK_MAP_TABLEm BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm
#define SOURCE_TRUNK_MAP_TABLEm_MIN BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_MIN
#define SOURCE_TRUNK_MAP_TABLEm_MAX BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_MAX
#define SOURCE_TRUNK_MAP_TABLEm_CMAX(u) BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_CMAX(u)
#define SOURCE_TRUNK_MAP_TABLEm_SIZE BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_SIZE
typedef BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_t SOURCE_TRUNK_MAP_TABLEm_t;
#define SOURCE_TRUNK_MAP_TABLEm_CLR BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_CLR
#define SOURCE_TRUNK_MAP_TABLEm_SET BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_SET
#define SOURCE_TRUNK_MAP_TABLEm_GET BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_GET
#define SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET
#define SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET
#define SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET
#define SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET
#define READ_SOURCE_TRUNK_MAP_TABLEm BCM53324_A0_READ_SOURCE_TRUNK_MAP_TABLEm
#define WRITE_SOURCE_TRUNK_MAP_TABLEm BCM53324_A0_WRITE_SOURCE_TRUNK_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SOURCE_TRUNK_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SRP_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Values for SRP frame detection
 * SIZE:     32
 * FIELDS:
 *     MAC_DA_LOWER     MAC Address to match for SRP frame detection
 *
 ******************************************************************************/
#define BCM53324_A0_SRP_CONTROL_1r 0x0278001a

#define BCM53324_A0_SRP_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program SRP_CONTROL_1.
 *
 */
typedef union BCM53324_A0_SRP_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t srp_control_1[1];
	uint32_t _srp_control_1;
} BCM53324_A0_SRP_CONTROL_1r_t;

#define BCM53324_A0_SRP_CONTROL_1r_CLR(r) (r).srp_control_1[0] = 0
#define BCM53324_A0_SRP_CONTROL_1r_SET(r,d) (r).srp_control_1[0] = d
#define BCM53324_A0_SRP_CONTROL_1r_GET(r) (r).srp_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SRP_CONTROL_1r_MAC_DA_LOWERf_GET(r) ((r).srp_control_1[0])
#define BCM53324_A0_SRP_CONTROL_1r_MAC_DA_LOWERf_SET(r,f) (r).srp_control_1[0]=((uint32_t)f)

/*
 * These macros can be used to access SRP_CONTROL_1.
 *
 */
#define BCM53324_A0_READ_SRP_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_SRP_CONTROL_1r,(r._srp_control_1))
#define BCM53324_A0_WRITE_SRP_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_SRP_CONTROL_1r,&(r._srp_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRP_CONTROL_1r BCM53324_A0_SRP_CONTROL_1r
#define SRP_CONTROL_1r_SIZE BCM53324_A0_SRP_CONTROL_1r_SIZE
typedef BCM53324_A0_SRP_CONTROL_1r_t SRP_CONTROL_1r_t;
#define SRP_CONTROL_1r_CLR BCM53324_A0_SRP_CONTROL_1r_CLR
#define SRP_CONTROL_1r_SET BCM53324_A0_SRP_CONTROL_1r_SET
#define SRP_CONTROL_1r_GET BCM53324_A0_SRP_CONTROL_1r_GET
#define SRP_CONTROL_1r_MAC_DA_LOWERf_GET BCM53324_A0_SRP_CONTROL_1r_MAC_DA_LOWERf_GET
#define SRP_CONTROL_1r_MAC_DA_LOWERf_SET BCM53324_A0_SRP_CONTROL_1r_MAC_DA_LOWERf_SET
#define READ_SRP_CONTROL_1r BCM53324_A0_READ_SRP_CONTROL_1r
#define WRITE_SRP_CONTROL_1r BCM53324_A0_WRITE_SRP_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SRP_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SRP_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Values for SRP frame detection
 * SIZE:     32
 * FIELDS:
 *     ETHERTYPE        The bits correspond to the message values in the lower nibble of the TS message
 *     MAC_DA_UPPER     MAC Address to match for SRP frame detection
 *
 ******************************************************************************/
#define BCM53324_A0_SRP_CONTROL_2r 0x0278001b

#define BCM53324_A0_SRP_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program SRP_CONTROL_2.
 *
 */
typedef union BCM53324_A0_SRP_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t srp_control_2[1];
	uint32_t _srp_control_2;
} BCM53324_A0_SRP_CONTROL_2r_t;

#define BCM53324_A0_SRP_CONTROL_2r_CLR(r) (r).srp_control_2[0] = 0
#define BCM53324_A0_SRP_CONTROL_2r_SET(r,d) (r).srp_control_2[0] = d
#define BCM53324_A0_SRP_CONTROL_2r_GET(r) (r).srp_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SRP_CONTROL_2r_ETHERTYPEf_GET(r) (((r).srp_control_2[0]) & 0xffff)
#define BCM53324_A0_SRP_CONTROL_2r_ETHERTYPEf_SET(r,f) (r).srp_control_2[0]=(((r).srp_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_SRP_CONTROL_2r_MAC_DA_UPPERf_GET(r) ((((r).srp_control_2[0]) >> 16) & 0xffff)
#define BCM53324_A0_SRP_CONTROL_2r_MAC_DA_UPPERf_SET(r,f) (r).srp_control_2[0]=(((r).srp_control_2[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access SRP_CONTROL_2.
 *
 */
#define BCM53324_A0_READ_SRP_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_SRP_CONTROL_2r,(r._srp_control_2))
#define BCM53324_A0_WRITE_SRP_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_SRP_CONTROL_2r,&(r._srp_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRP_CONTROL_2r BCM53324_A0_SRP_CONTROL_2r
#define SRP_CONTROL_2r_SIZE BCM53324_A0_SRP_CONTROL_2r_SIZE
typedef BCM53324_A0_SRP_CONTROL_2r_t SRP_CONTROL_2r_t;
#define SRP_CONTROL_2r_CLR BCM53324_A0_SRP_CONTROL_2r_CLR
#define SRP_CONTROL_2r_SET BCM53324_A0_SRP_CONTROL_2r_SET
#define SRP_CONTROL_2r_GET BCM53324_A0_SRP_CONTROL_2r_GET
#define SRP_CONTROL_2r_ETHERTYPEf_GET BCM53324_A0_SRP_CONTROL_2r_ETHERTYPEf_GET
#define SRP_CONTROL_2r_ETHERTYPEf_SET BCM53324_A0_SRP_CONTROL_2r_ETHERTYPEf_SET
#define SRP_CONTROL_2r_MAC_DA_UPPERf_GET BCM53324_A0_SRP_CONTROL_2r_MAC_DA_UPPERf_GET
#define SRP_CONTROL_2r_MAC_DA_UPPERf_SET BCM53324_A0_SRP_CONTROL_2r_MAC_DA_UPPERf_SET
#define READ_SRP_CONTROL_2r BCM53324_A0_READ_SRP_CONTROL_2r
#define WRITE_SRP_CONTROL_2r BCM53324_A0_WRITE_SRP_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SRP_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  STG_TAB
 * BLOCKS:   IPIPE
 * DESC:     Spanning Tree Group state table. Indexed by the Spanning Tree Group ID field from the VLAN Table
 * SIZE:     50
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for port 0
 *     SP_TREE_PORT1    Spanning Tree State for port 1
 *     SP_TREE_PORT2    Spanning Tree State for port 2
 *     SP_TREE_PORT3    Spanning Tree State for port 3
 *     SP_TREE_PORT4    Spanning Tree State for port 4
 *     SP_TREE_PORT5    Spanning Tree State for port 5
 *     SP_TREE_PORT6    Spanning Tree State for port 6
 *     SP_TREE_PORT7    Spanning Tree State for port 7
 *     SP_TREE_PORT8    Spanning Tree State for port 8
 *     SP_TREE_PORT9    Spanning Tree State for port 9
 *     SP_TREE_PORT10   Spanning Tree State for port 10
 *     SP_TREE_PORT11   Spanning Tree State for port 11
 *     SP_TREE_PORT12   Spanning Tree State for port 12
 *     SP_TREE_PORT13   Spanning Tree State for port 13
 *     SP_TREE_PORT14   Spanning Tree State for port 14
 *     SP_TREE_PORT15   Spanning Tree State for port 15
 *     SP_TREE_PORT16   Spanning Tree State for port 16
 *     SP_TREE_PORT17   Spanning Tree State for port 17
 *     SP_TREE_PORT18   Spanning Tree State for port 18
 *     SP_TREE_PORT19   Spanning Tree State for port 19
 *     SP_TREE_PORT20   Spanning Tree State for port 20
 *     SP_TREE_PORT21   Spanning Tree State for port 21
 *     SP_TREE_PORT22   Spanning Tree State for port 22
 *     SP_TREE_PORT23   Spanning Tree State for port 23
 *     SP_TREE_PORT24   Spanning Tree State for port 24
 *
 ******************************************************************************/
#define BCM53324_A0_STG_TABm 0x05710000

#define BCM53324_A0_STG_TABm_MIN 0
#define BCM53324_A0_STG_TABm_MAX 63
#define BCM53324_A0_STG_TABm_CMAX(u) 63
#define BCM53324_A0_STG_TABm_SIZE 7

/*
 * This structure should be used to declare and program STG_TAB.
 *
 */
typedef union BCM53324_A0_STG_TABm_s {
	uint32_t v[2];
	uint32_t stg_tab[2];
	uint32_t _stg_tab;
} BCM53324_A0_STG_TABm_t;

#define BCM53324_A0_STG_TABm_CLR(r) CDK_MEMSET(&((r)._stg_tab), 0, sizeof(BCM53324_A0_STG_TABm_t))
#define BCM53324_A0_STG_TABm_SET(r,i,d) (r).stg_tab[i] = d
#define BCM53324_A0_STG_TABm_GET(r,i) (r).stg_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_STG_TABm_SP_TREE_PORT0f_GET(r) (((r).stg_tab[0]) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT0f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT1f_GET(r) ((((r).stg_tab[0]) >> 2) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT1f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT2f_GET(r) ((((r).stg_tab[0]) >> 4) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT2f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT3f_GET(r) ((((r).stg_tab[0]) >> 6) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT3f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT4f_GET(r) ((((r).stg_tab[0]) >> 8) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT4f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT5f_GET(r) ((((r).stg_tab[0]) >> 10) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT5f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT6f_GET(r) ((((r).stg_tab[0]) >> 12) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT6f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT7f_GET(r) ((((r).stg_tab[0]) >> 14) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT7f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT8f_GET(r) ((((r).stg_tab[0]) >> 16) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT8f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT9f_GET(r) ((((r).stg_tab[0]) >> 18) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT9f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT10f_GET(r) ((((r).stg_tab[0]) >> 20) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT10f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT11f_GET(r) ((((r).stg_tab[0]) >> 22) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT11f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT12f_GET(r) ((((r).stg_tab[0]) >> 24) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT12f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT13f_GET(r) ((((r).stg_tab[0]) >> 26) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT13f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT14f_GET(r) ((((r).stg_tab[0]) >> 28) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT14f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT15f_GET(r) ((((r).stg_tab[0]) >> 30) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT15f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT16f_GET(r) (((r).stg_tab[1]) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT16f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT17f_GET(r) ((((r).stg_tab[1]) >> 2) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT17f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT18f_GET(r) ((((r).stg_tab[1]) >> 4) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT18f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT19f_GET(r) ((((r).stg_tab[1]) >> 6) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT19f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT20f_GET(r) ((((r).stg_tab[1]) >> 8) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT20f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT21f_GET(r) ((((r).stg_tab[1]) >> 10) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT21f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT22f_GET(r) ((((r).stg_tab[1]) >> 12) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT22f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT23f_GET(r) ((((r).stg_tab[1]) >> 14) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT23f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53324_A0_STG_TABm_SP_TREE_PORT24f_GET(r) ((((r).stg_tab[1]) >> 16) & 0x3)
#define BCM53324_A0_STG_TABm_SP_TREE_PORT24f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))

/*
 * These macros can be used to access STG_TAB.
 *
 */
#define BCM53324_A0_READ_STG_TABm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_STG_TABm,i,(m._stg_tab),2)
#define BCM53324_A0_WRITE_STG_TABm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_STG_TABm,i,&(m._stg_tab),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STG_TABm BCM53324_A0_STG_TABm
#define STG_TABm_MIN BCM53324_A0_STG_TABm_MIN
#define STG_TABm_MAX BCM53324_A0_STG_TABm_MAX
#define STG_TABm_CMAX(u) BCM53324_A0_STG_TABm_CMAX(u)
#define STG_TABm_SIZE BCM53324_A0_STG_TABm_SIZE
typedef BCM53324_A0_STG_TABm_t STG_TABm_t;
#define STG_TABm_CLR BCM53324_A0_STG_TABm_CLR
#define STG_TABm_SET BCM53324_A0_STG_TABm_SET
#define STG_TABm_GET BCM53324_A0_STG_TABm_GET
#define STG_TABm_SP_TREE_PORT0f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT0f_GET
#define STG_TABm_SP_TREE_PORT0f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT0f_SET
#define STG_TABm_SP_TREE_PORT1f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT1f_GET
#define STG_TABm_SP_TREE_PORT1f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT1f_SET
#define STG_TABm_SP_TREE_PORT2f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT2f_GET
#define STG_TABm_SP_TREE_PORT2f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT2f_SET
#define STG_TABm_SP_TREE_PORT3f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT3f_GET
#define STG_TABm_SP_TREE_PORT3f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT3f_SET
#define STG_TABm_SP_TREE_PORT4f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT4f_GET
#define STG_TABm_SP_TREE_PORT4f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT4f_SET
#define STG_TABm_SP_TREE_PORT5f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT5f_GET
#define STG_TABm_SP_TREE_PORT5f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT5f_SET
#define STG_TABm_SP_TREE_PORT6f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT6f_GET
#define STG_TABm_SP_TREE_PORT6f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT6f_SET
#define STG_TABm_SP_TREE_PORT7f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT7f_GET
#define STG_TABm_SP_TREE_PORT7f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT7f_SET
#define STG_TABm_SP_TREE_PORT8f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT8f_GET
#define STG_TABm_SP_TREE_PORT8f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT8f_SET
#define STG_TABm_SP_TREE_PORT9f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT9f_GET
#define STG_TABm_SP_TREE_PORT9f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT9f_SET
#define STG_TABm_SP_TREE_PORT10f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT10f_GET
#define STG_TABm_SP_TREE_PORT10f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT10f_SET
#define STG_TABm_SP_TREE_PORT11f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT11f_GET
#define STG_TABm_SP_TREE_PORT11f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT11f_SET
#define STG_TABm_SP_TREE_PORT12f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT12f_GET
#define STG_TABm_SP_TREE_PORT12f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT12f_SET
#define STG_TABm_SP_TREE_PORT13f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT13f_GET
#define STG_TABm_SP_TREE_PORT13f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT13f_SET
#define STG_TABm_SP_TREE_PORT14f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT14f_GET
#define STG_TABm_SP_TREE_PORT14f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT14f_SET
#define STG_TABm_SP_TREE_PORT15f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT15f_GET
#define STG_TABm_SP_TREE_PORT15f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT15f_SET
#define STG_TABm_SP_TREE_PORT16f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT16f_GET
#define STG_TABm_SP_TREE_PORT16f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT16f_SET
#define STG_TABm_SP_TREE_PORT17f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT17f_GET
#define STG_TABm_SP_TREE_PORT17f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT17f_SET
#define STG_TABm_SP_TREE_PORT18f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT18f_GET
#define STG_TABm_SP_TREE_PORT18f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT18f_SET
#define STG_TABm_SP_TREE_PORT19f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT19f_GET
#define STG_TABm_SP_TREE_PORT19f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT19f_SET
#define STG_TABm_SP_TREE_PORT20f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT20f_GET
#define STG_TABm_SP_TREE_PORT20f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT20f_SET
#define STG_TABm_SP_TREE_PORT21f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT21f_GET
#define STG_TABm_SP_TREE_PORT21f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT21f_SET
#define STG_TABm_SP_TREE_PORT22f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT22f_GET
#define STG_TABm_SP_TREE_PORT22f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT22f_SET
#define STG_TABm_SP_TREE_PORT23f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT23f_GET
#define STG_TABm_SP_TREE_PORT23f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT23f_SET
#define STG_TABm_SP_TREE_PORT24f_GET BCM53324_A0_STG_TABm_SP_TREE_PORT24f_GET
#define STG_TABm_SP_TREE_PORT24f_SET BCM53324_A0_STG_TABm_SP_TREE_PORT24f_SET
#define READ_STG_TABm BCM53324_A0_READ_STG_TABm
#define WRITE_STG_TABm BCM53324_A0_WRITE_STG_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_STG_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SYS_MAC_ACTION
 * BLOCKS:   IPIPE
 * DESC:     Actions control when the MAC_COUNT exceeds the LIMIT
 * SIZE:     32
 * FIELDS:
 *     MAC_LIMIT_USE_SYS_ACTION  The action priority control bit that is used when both port/LAG & System MAC limits are exceeded.
 *     OVER_LIMIT_TOCPU The copy to CPU action control bit used when the count exceeds the SYS_MAC_LIMIT 
 *     OVER_LIMIT_DROP  The drop action control bit used when the SYS_MAC_COUNT exceeds the SYS_MAC_LIMIT
 *
 ******************************************************************************/
#define BCM53324_A0_SYS_MAC_ACTIONr 0x0c78000a

#define BCM53324_A0_SYS_MAC_ACTIONr_SIZE 4

/*
 * This structure should be used to declare and program SYS_MAC_ACTION.
 *
 */
typedef union BCM53324_A0_SYS_MAC_ACTIONr_s {
	uint32_t v[1];
	uint32_t sys_mac_action[1];
	uint32_t _sys_mac_action;
} BCM53324_A0_SYS_MAC_ACTIONr_t;

#define BCM53324_A0_SYS_MAC_ACTIONr_CLR(r) (r).sys_mac_action[0] = 0
#define BCM53324_A0_SYS_MAC_ACTIONr_SET(r,d) (r).sys_mac_action[0] = d
#define BCM53324_A0_SYS_MAC_ACTIONr_GET(r) (r).sys_mac_action[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_GET(r) (((r).sys_mac_action[0]) & 0x1)
#define BCM53324_A0_SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_SET(r,f) (r).sys_mac_action[0]=(((r).sys_mac_action[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_GET(r) ((((r).sys_mac_action[0]) >> 1) & 0x1)
#define BCM53324_A0_SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_SET(r,f) (r).sys_mac_action[0]=(((r).sys_mac_action[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_GET(r) ((((r).sys_mac_action[0]) >> 2) & 0x1)
#define BCM53324_A0_SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_SET(r,f) (r).sys_mac_action[0]=(((r).sys_mac_action[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access SYS_MAC_ACTION.
 *
 */
#define BCM53324_A0_READ_SYS_MAC_ACTIONr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_SYS_MAC_ACTIONr,(r._sys_mac_action))
#define BCM53324_A0_WRITE_SYS_MAC_ACTIONr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_SYS_MAC_ACTIONr,&(r._sys_mac_action))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SYS_MAC_ACTIONr BCM53324_A0_SYS_MAC_ACTIONr
#define SYS_MAC_ACTIONr_SIZE BCM53324_A0_SYS_MAC_ACTIONr_SIZE
typedef BCM53324_A0_SYS_MAC_ACTIONr_t SYS_MAC_ACTIONr_t;
#define SYS_MAC_ACTIONr_CLR BCM53324_A0_SYS_MAC_ACTIONr_CLR
#define SYS_MAC_ACTIONr_SET BCM53324_A0_SYS_MAC_ACTIONr_SET
#define SYS_MAC_ACTIONr_GET BCM53324_A0_SYS_MAC_ACTIONr_GET
#define SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_GET BCM53324_A0_SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_GET
#define SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_SET BCM53324_A0_SYS_MAC_ACTIONr_MAC_LIMIT_USE_SYS_ACTIONf_SET
#define SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_GET BCM53324_A0_SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_GET
#define SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_SET BCM53324_A0_SYS_MAC_ACTIONr_OVER_LIMIT_TOCPUf_SET
#define SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_GET BCM53324_A0_SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_GET
#define SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_SET BCM53324_A0_SYS_MAC_ACTIONr_OVER_LIMIT_DROPf_SET
#define READ_SYS_MAC_ACTIONr BCM53324_A0_READ_SYS_MAC_ACTIONr
#define WRITE_SYS_MAC_ACTIONr BCM53324_A0_WRITE_SYS_MAC_ACTIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SYS_MAC_ACTIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SYS_MAC_COUNT
 * BLOCKS:   IPIPE
 * DESC:     sytem MAC counts update by the H/W
 * SIZE:     32
 * FIELDS:
 *     SYS_MAC_COUNT    This register has the sytem MAC counts update by the H/W. 
 *
 ******************************************************************************/
#define BCM53324_A0_SYS_MAC_COUNTr 0x06780009

#define BCM53324_A0_SYS_MAC_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program SYS_MAC_COUNT.
 *
 */
typedef union BCM53324_A0_SYS_MAC_COUNTr_s {
	uint32_t v[1];
	uint32_t sys_mac_count[1];
	uint32_t _sys_mac_count;
} BCM53324_A0_SYS_MAC_COUNTr_t;

#define BCM53324_A0_SYS_MAC_COUNTr_CLR(r) (r).sys_mac_count[0] = 0
#define BCM53324_A0_SYS_MAC_COUNTr_SET(r,d) (r).sys_mac_count[0] = d
#define BCM53324_A0_SYS_MAC_COUNTr_GET(r) (r).sys_mac_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SYS_MAC_COUNTr_SYS_MAC_COUNTf_GET(r) (((r).sys_mac_count[0]) & 0x3fff)
#define BCM53324_A0_SYS_MAC_COUNTr_SYS_MAC_COUNTf_SET(r,f) (r).sys_mac_count[0]=(((r).sys_mac_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access SYS_MAC_COUNT.
 *
 */
#define BCM53324_A0_READ_SYS_MAC_COUNTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_SYS_MAC_COUNTr,(r._sys_mac_count))
#define BCM53324_A0_WRITE_SYS_MAC_COUNTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_SYS_MAC_COUNTr,&(r._sys_mac_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SYS_MAC_COUNTr BCM53324_A0_SYS_MAC_COUNTr
#define SYS_MAC_COUNTr_SIZE BCM53324_A0_SYS_MAC_COUNTr_SIZE
typedef BCM53324_A0_SYS_MAC_COUNTr_t SYS_MAC_COUNTr_t;
#define SYS_MAC_COUNTr_CLR BCM53324_A0_SYS_MAC_COUNTr_CLR
#define SYS_MAC_COUNTr_SET BCM53324_A0_SYS_MAC_COUNTr_SET
#define SYS_MAC_COUNTr_GET BCM53324_A0_SYS_MAC_COUNTr_GET
#define SYS_MAC_COUNTr_SYS_MAC_COUNTf_GET BCM53324_A0_SYS_MAC_COUNTr_SYS_MAC_COUNTf_GET
#define SYS_MAC_COUNTr_SYS_MAC_COUNTf_SET BCM53324_A0_SYS_MAC_COUNTr_SYS_MAC_COUNTf_SET
#define READ_SYS_MAC_COUNTr BCM53324_A0_READ_SYS_MAC_COUNTr
#define WRITE_SYS_MAC_COUNTr BCM53324_A0_WRITE_SYS_MAC_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SYS_MAC_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  SYS_MAC_LIMIT
 * BLOCKS:   IPIPE
 * DESC:     sytem MAC counts limit 
 * SIZE:     32
 * FIELDS:
 *     SYS_MAC_LIMIT    the system MAC count limit value that needs to be programmed by the user.
 *
 ******************************************************************************/
#define BCM53324_A0_SYS_MAC_LIMITr 0x0678000a

#define BCM53324_A0_SYS_MAC_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program SYS_MAC_LIMIT.
 *
 */
typedef union BCM53324_A0_SYS_MAC_LIMITr_s {
	uint32_t v[1];
	uint32_t sys_mac_limit[1];
	uint32_t _sys_mac_limit;
} BCM53324_A0_SYS_MAC_LIMITr_t;

#define BCM53324_A0_SYS_MAC_LIMITr_CLR(r) (r).sys_mac_limit[0] = 0
#define BCM53324_A0_SYS_MAC_LIMITr_SET(r,d) (r).sys_mac_limit[0] = d
#define BCM53324_A0_SYS_MAC_LIMITr_GET(r) (r).sys_mac_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_SYS_MAC_LIMITr_SYS_MAC_LIMITf_GET(r) (((r).sys_mac_limit[0]) & 0x3fff)
#define BCM53324_A0_SYS_MAC_LIMITr_SYS_MAC_LIMITf_SET(r,f) (r).sys_mac_limit[0]=(((r).sys_mac_limit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access SYS_MAC_LIMIT.
 *
 */
#define BCM53324_A0_READ_SYS_MAC_LIMITr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_SYS_MAC_LIMITr,(r._sys_mac_limit))
#define BCM53324_A0_WRITE_SYS_MAC_LIMITr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_SYS_MAC_LIMITr,&(r._sys_mac_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SYS_MAC_LIMITr BCM53324_A0_SYS_MAC_LIMITr
#define SYS_MAC_LIMITr_SIZE BCM53324_A0_SYS_MAC_LIMITr_SIZE
typedef BCM53324_A0_SYS_MAC_LIMITr_t SYS_MAC_LIMITr_t;
#define SYS_MAC_LIMITr_CLR BCM53324_A0_SYS_MAC_LIMITr_CLR
#define SYS_MAC_LIMITr_SET BCM53324_A0_SYS_MAC_LIMITr_SET
#define SYS_MAC_LIMITr_GET BCM53324_A0_SYS_MAC_LIMITr_GET
#define SYS_MAC_LIMITr_SYS_MAC_LIMITf_GET BCM53324_A0_SYS_MAC_LIMITr_SYS_MAC_LIMITf_GET
#define SYS_MAC_LIMITr_SYS_MAC_LIMITf_SET BCM53324_A0_SYS_MAC_LIMITr_SYS_MAC_LIMITf_SET
#define READ_SYS_MAC_LIMITr BCM53324_A0_READ_SYS_MAC_LIMITr
#define WRITE_SYS_MAC_LIMITr BCM53324_A0_WRITE_SYS_MAC_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_SYS_MAC_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TAG_0
 * BLOCKS:   GPORT0
 * DESC:     Programmable vlan outer tag
 * SIZE:     32
 * FIELDS:
 *     FRM_TAG_0        Outer tag of the programmable vlan tag
 *
 ******************************************************************************/
#define BCM53324_A0_TAG_0r 0x00000112

#define BCM53324_A0_TAG_0r_SIZE 4

/*
 * This structure should be used to declare and program TAG_0.
 *
 */
typedef union BCM53324_A0_TAG_0r_s {
	uint32_t v[1];
	uint32_t tag_0[1];
	uint32_t _tag_0;
} BCM53324_A0_TAG_0r_t;

#define BCM53324_A0_TAG_0r_CLR(r) (r).tag_0[0] = 0
#define BCM53324_A0_TAG_0r_SET(r,d) (r).tag_0[0] = d
#define BCM53324_A0_TAG_0r_GET(r) (r).tag_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TAG_0r_FRM_TAG_0f_GET(r) (((r).tag_0[0]) & 0xffff)
#define BCM53324_A0_TAG_0r_FRM_TAG_0f_SET(r,f) (r).tag_0[0]=(((r).tag_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TAG_0.
 *
 */
#define BCM53324_A0_READ_TAG_0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TAG_0r,(r._tag_0))
#define BCM53324_A0_WRITE_TAG_0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TAG_0r,&(r._tag_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TAG_0r BCM53324_A0_TAG_0r
#define TAG_0r_SIZE BCM53324_A0_TAG_0r_SIZE
typedef BCM53324_A0_TAG_0r_t TAG_0r_t;
#define TAG_0r_CLR BCM53324_A0_TAG_0r_CLR
#define TAG_0r_SET BCM53324_A0_TAG_0r_SET
#define TAG_0r_GET BCM53324_A0_TAG_0r_GET
#define TAG_0r_FRM_TAG_0f_GET BCM53324_A0_TAG_0r_FRM_TAG_0f_GET
#define TAG_0r_FRM_TAG_0f_SET BCM53324_A0_TAG_0r_FRM_TAG_0f_SET
#define READ_TAG_0r BCM53324_A0_READ_TAG_0r
#define WRITE_TAG_0r BCM53324_A0_WRITE_TAG_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TAG_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TAG_1
 * BLOCKS:   GPORT0
 * DESC:     Programmable vlan inner tag
 * SIZE:     32
 * FIELDS:
 *     FRM_TAG_1        inner tag of the programmable vlan tag
 *
 ******************************************************************************/
#define BCM53324_A0_TAG_1r 0x00000113

#define BCM53324_A0_TAG_1r_SIZE 4

/*
 * This structure should be used to declare and program TAG_1.
 *
 */
typedef union BCM53324_A0_TAG_1r_s {
	uint32_t v[1];
	uint32_t tag_1[1];
	uint32_t _tag_1;
} BCM53324_A0_TAG_1r_t;

#define BCM53324_A0_TAG_1r_CLR(r) (r).tag_1[0] = 0
#define BCM53324_A0_TAG_1r_SET(r,d) (r).tag_1[0] = d
#define BCM53324_A0_TAG_1r_GET(r) (r).tag_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TAG_1r_FRM_TAG_1f_GET(r) (((r).tag_1[0]) & 0xffff)
#define BCM53324_A0_TAG_1r_FRM_TAG_1f_SET(r,f) (r).tag_1[0]=(((r).tag_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TAG_1.
 *
 */
#define BCM53324_A0_READ_TAG_1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TAG_1r,(r._tag_1))
#define BCM53324_A0_WRITE_TAG_1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TAG_1r,&(r._tag_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TAG_1r BCM53324_A0_TAG_1r
#define TAG_1r_SIZE BCM53324_A0_TAG_1r_SIZE
typedef BCM53324_A0_TAG_1r_t TAG_1r_t;
#define TAG_1r_CLR BCM53324_A0_TAG_1r_CLR
#define TAG_1r_SET BCM53324_A0_TAG_1r_SET
#define TAG_1r_GET BCM53324_A0_TAG_1r_GET
#define TAG_1r_FRM_TAG_1f_GET BCM53324_A0_TAG_1r_FRM_TAG_1f_GET
#define TAG_1r_FRM_TAG_1f_SET BCM53324_A0_TAG_1r_FRM_TAG_1f_SET
#define READ_TAG_1r BCM53324_A0_READ_TAG_1r
#define WRITE_TAG_1r BCM53324_A0_WRITE_TAG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TAG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC0
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #0
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC0r 0x0a900000

#define BCM53324_A0_TDBGC0r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC0.
 *
 */
typedef union BCM53324_A0_TDBGC0r_s {
	uint32_t v[1];
	uint32_t tdbgc0[1];
	uint32_t _tdbgc0;
} BCM53324_A0_TDBGC0r_t;

#define BCM53324_A0_TDBGC0r_CLR(r) (r).tdbgc0[0] = 0
#define BCM53324_A0_TDBGC0r_SET(r,d) (r).tdbgc0[0] = d
#define BCM53324_A0_TDBGC0r_GET(r) (r).tdbgc0[0]


/*
 * These macros can be used to access TDBGC0.
 *
 */
#define BCM53324_A0_READ_TDBGC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC0r,(r._tdbgc0))
#define BCM53324_A0_WRITE_TDBGC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC0r,&(r._tdbgc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC0r BCM53324_A0_TDBGC0r
#define TDBGC0r_SIZE BCM53324_A0_TDBGC0r_SIZE
typedef BCM53324_A0_TDBGC0r_t TDBGC0r_t;
#define TDBGC0r_CLR BCM53324_A0_TDBGC0r_CLR
#define TDBGC0r_SET BCM53324_A0_TDBGC0r_SET
#define TDBGC0r_GET BCM53324_A0_TDBGC0r_GET
#define READ_TDBGC0r BCM53324_A0_READ_TDBGC0r
#define WRITE_TDBGC0r BCM53324_A0_WRITE_TDBGC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC0_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #0 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC0_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC0_SELECTr 0x0a980020

#define BCM53324_A0_TDBGC0_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC0_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC0_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc0_select[1];
	uint32_t _tdbgc0_select;
} BCM53324_A0_TDBGC0_SELECTr_t;

#define BCM53324_A0_TDBGC0_SELECTr_CLR(r) (r).tdbgc0_select[0] = 0
#define BCM53324_A0_TDBGC0_SELECTr_SET(r,d) (r).tdbgc0_select[0] = d
#define BCM53324_A0_TDBGC0_SELECTr_GET(r) (r).tdbgc0_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC0_SELECTr_BITMAPf_GET(r) (((r).tdbgc0_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC0_SELECTr_BITMAPf_SET(r,f) (r).tdbgc0_select[0]=(((r).tdbgc0_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC0_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC0_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC0_SELECTr,(r._tdbgc0_select))
#define BCM53324_A0_WRITE_TDBGC0_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC0_SELECTr,&(r._tdbgc0_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC0_SELECTr BCM53324_A0_TDBGC0_SELECTr
#define TDBGC0_SELECTr_SIZE BCM53324_A0_TDBGC0_SELECTr_SIZE
typedef BCM53324_A0_TDBGC0_SELECTr_t TDBGC0_SELECTr_t;
#define TDBGC0_SELECTr_CLR BCM53324_A0_TDBGC0_SELECTr_CLR
#define TDBGC0_SELECTr_SET BCM53324_A0_TDBGC0_SELECTr_SET
#define TDBGC0_SELECTr_GET BCM53324_A0_TDBGC0_SELECTr_GET
#define TDBGC0_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC0_SELECTr_BITMAPf_GET
#define TDBGC0_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC0_SELECTr_BITMAPf_SET
#define READ_TDBGC0_SELECTr BCM53324_A0_READ_TDBGC0_SELECTr
#define WRITE_TDBGC0_SELECTr BCM53324_A0_WRITE_TDBGC0_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC0_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC1
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #1
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC1r 0x0a900001

#define BCM53324_A0_TDBGC1r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC1.
 *
 */
typedef union BCM53324_A0_TDBGC1r_s {
	uint32_t v[1];
	uint32_t tdbgc1[1];
	uint32_t _tdbgc1;
} BCM53324_A0_TDBGC1r_t;

#define BCM53324_A0_TDBGC1r_CLR(r) (r).tdbgc1[0] = 0
#define BCM53324_A0_TDBGC1r_SET(r,d) (r).tdbgc1[0] = d
#define BCM53324_A0_TDBGC1r_GET(r) (r).tdbgc1[0]


/*
 * These macros can be used to access TDBGC1.
 *
 */
#define BCM53324_A0_READ_TDBGC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC1r,(r._tdbgc1))
#define BCM53324_A0_WRITE_TDBGC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC1r,&(r._tdbgc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC1r BCM53324_A0_TDBGC1r
#define TDBGC1r_SIZE BCM53324_A0_TDBGC1r_SIZE
typedef BCM53324_A0_TDBGC1r_t TDBGC1r_t;
#define TDBGC1r_CLR BCM53324_A0_TDBGC1r_CLR
#define TDBGC1r_SET BCM53324_A0_TDBGC1r_SET
#define TDBGC1r_GET BCM53324_A0_TDBGC1r_GET
#define READ_TDBGC1r BCM53324_A0_READ_TDBGC1r
#define WRITE_TDBGC1r BCM53324_A0_WRITE_TDBGC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC10
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #10
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC10r 0x0a90000a

#define BCM53324_A0_TDBGC10r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC10.
 *
 */
typedef union BCM53324_A0_TDBGC10r_s {
	uint32_t v[1];
	uint32_t tdbgc10[1];
	uint32_t _tdbgc10;
} BCM53324_A0_TDBGC10r_t;

#define BCM53324_A0_TDBGC10r_CLR(r) (r).tdbgc10[0] = 0
#define BCM53324_A0_TDBGC10r_SET(r,d) (r).tdbgc10[0] = d
#define BCM53324_A0_TDBGC10r_GET(r) (r).tdbgc10[0]


/*
 * These macros can be used to access TDBGC10.
 *
 */
#define BCM53324_A0_READ_TDBGC10r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC10r,(r._tdbgc10))
#define BCM53324_A0_WRITE_TDBGC10r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC10r,&(r._tdbgc10))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC10r BCM53324_A0_TDBGC10r
#define TDBGC10r_SIZE BCM53324_A0_TDBGC10r_SIZE
typedef BCM53324_A0_TDBGC10r_t TDBGC10r_t;
#define TDBGC10r_CLR BCM53324_A0_TDBGC10r_CLR
#define TDBGC10r_SET BCM53324_A0_TDBGC10r_SET
#define TDBGC10r_GET BCM53324_A0_TDBGC10r_GET
#define READ_TDBGC10r BCM53324_A0_READ_TDBGC10r
#define WRITE_TDBGC10r BCM53324_A0_WRITE_TDBGC10r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC10_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #10 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC10_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC10_SELECTr 0x0a98002a

#define BCM53324_A0_TDBGC10_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC10_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC10_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc10_select[1];
	uint32_t _tdbgc10_select;
} BCM53324_A0_TDBGC10_SELECTr_t;

#define BCM53324_A0_TDBGC10_SELECTr_CLR(r) (r).tdbgc10_select[0] = 0
#define BCM53324_A0_TDBGC10_SELECTr_SET(r,d) (r).tdbgc10_select[0] = d
#define BCM53324_A0_TDBGC10_SELECTr_GET(r) (r).tdbgc10_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC10_SELECTr_BITMAPf_GET(r) (((r).tdbgc10_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC10_SELECTr_BITMAPf_SET(r,f) (r).tdbgc10_select[0]=(((r).tdbgc10_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC10_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC10_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC10_SELECTr,(r._tdbgc10_select))
#define BCM53324_A0_WRITE_TDBGC10_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC10_SELECTr,&(r._tdbgc10_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC10_SELECTr BCM53324_A0_TDBGC10_SELECTr
#define TDBGC10_SELECTr_SIZE BCM53324_A0_TDBGC10_SELECTr_SIZE
typedef BCM53324_A0_TDBGC10_SELECTr_t TDBGC10_SELECTr_t;
#define TDBGC10_SELECTr_CLR BCM53324_A0_TDBGC10_SELECTr_CLR
#define TDBGC10_SELECTr_SET BCM53324_A0_TDBGC10_SELECTr_SET
#define TDBGC10_SELECTr_GET BCM53324_A0_TDBGC10_SELECTr_GET
#define TDBGC10_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC10_SELECTr_BITMAPf_GET
#define TDBGC10_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC10_SELECTr_BITMAPf_SET
#define READ_TDBGC10_SELECTr BCM53324_A0_READ_TDBGC10_SELECTr
#define WRITE_TDBGC10_SELECTr BCM53324_A0_WRITE_TDBGC10_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC10_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC11
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #11
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC11r 0x0a90000b

#define BCM53324_A0_TDBGC11r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC11.
 *
 */
typedef union BCM53324_A0_TDBGC11r_s {
	uint32_t v[1];
	uint32_t tdbgc11[1];
	uint32_t _tdbgc11;
} BCM53324_A0_TDBGC11r_t;

#define BCM53324_A0_TDBGC11r_CLR(r) (r).tdbgc11[0] = 0
#define BCM53324_A0_TDBGC11r_SET(r,d) (r).tdbgc11[0] = d
#define BCM53324_A0_TDBGC11r_GET(r) (r).tdbgc11[0]


/*
 * These macros can be used to access TDBGC11.
 *
 */
#define BCM53324_A0_READ_TDBGC11r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC11r,(r._tdbgc11))
#define BCM53324_A0_WRITE_TDBGC11r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC11r,&(r._tdbgc11))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC11r BCM53324_A0_TDBGC11r
#define TDBGC11r_SIZE BCM53324_A0_TDBGC11r_SIZE
typedef BCM53324_A0_TDBGC11r_t TDBGC11r_t;
#define TDBGC11r_CLR BCM53324_A0_TDBGC11r_CLR
#define TDBGC11r_SET BCM53324_A0_TDBGC11r_SET
#define TDBGC11r_GET BCM53324_A0_TDBGC11r_GET
#define READ_TDBGC11r BCM53324_A0_READ_TDBGC11r
#define WRITE_TDBGC11r BCM53324_A0_WRITE_TDBGC11r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC11_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #11 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC11_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC11_SELECTr 0x0a98002b

#define BCM53324_A0_TDBGC11_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC11_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC11_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc11_select[1];
	uint32_t _tdbgc11_select;
} BCM53324_A0_TDBGC11_SELECTr_t;

#define BCM53324_A0_TDBGC11_SELECTr_CLR(r) (r).tdbgc11_select[0] = 0
#define BCM53324_A0_TDBGC11_SELECTr_SET(r,d) (r).tdbgc11_select[0] = d
#define BCM53324_A0_TDBGC11_SELECTr_GET(r) (r).tdbgc11_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC11_SELECTr_BITMAPf_GET(r) (((r).tdbgc11_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC11_SELECTr_BITMAPf_SET(r,f) (r).tdbgc11_select[0]=(((r).tdbgc11_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC11_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC11_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC11_SELECTr,(r._tdbgc11_select))
#define BCM53324_A0_WRITE_TDBGC11_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC11_SELECTr,&(r._tdbgc11_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC11_SELECTr BCM53324_A0_TDBGC11_SELECTr
#define TDBGC11_SELECTr_SIZE BCM53324_A0_TDBGC11_SELECTr_SIZE
typedef BCM53324_A0_TDBGC11_SELECTr_t TDBGC11_SELECTr_t;
#define TDBGC11_SELECTr_CLR BCM53324_A0_TDBGC11_SELECTr_CLR
#define TDBGC11_SELECTr_SET BCM53324_A0_TDBGC11_SELECTr_SET
#define TDBGC11_SELECTr_GET BCM53324_A0_TDBGC11_SELECTr_GET
#define TDBGC11_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC11_SELECTr_BITMAPf_GET
#define TDBGC11_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC11_SELECTr_BITMAPf_SET
#define READ_TDBGC11_SELECTr BCM53324_A0_READ_TDBGC11_SELECTr
#define WRITE_TDBGC11_SELECTr BCM53324_A0_WRITE_TDBGC11_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC11_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC1_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #1 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC1_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC1_SELECTr 0x0a980021

#define BCM53324_A0_TDBGC1_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC1_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC1_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc1_select[1];
	uint32_t _tdbgc1_select;
} BCM53324_A0_TDBGC1_SELECTr_t;

#define BCM53324_A0_TDBGC1_SELECTr_CLR(r) (r).tdbgc1_select[0] = 0
#define BCM53324_A0_TDBGC1_SELECTr_SET(r,d) (r).tdbgc1_select[0] = d
#define BCM53324_A0_TDBGC1_SELECTr_GET(r) (r).tdbgc1_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC1_SELECTr_BITMAPf_GET(r) (((r).tdbgc1_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC1_SELECTr_BITMAPf_SET(r,f) (r).tdbgc1_select[0]=(((r).tdbgc1_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC1_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC1_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC1_SELECTr,(r._tdbgc1_select))
#define BCM53324_A0_WRITE_TDBGC1_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC1_SELECTr,&(r._tdbgc1_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC1_SELECTr BCM53324_A0_TDBGC1_SELECTr
#define TDBGC1_SELECTr_SIZE BCM53324_A0_TDBGC1_SELECTr_SIZE
typedef BCM53324_A0_TDBGC1_SELECTr_t TDBGC1_SELECTr_t;
#define TDBGC1_SELECTr_CLR BCM53324_A0_TDBGC1_SELECTr_CLR
#define TDBGC1_SELECTr_SET BCM53324_A0_TDBGC1_SELECTr_SET
#define TDBGC1_SELECTr_GET BCM53324_A0_TDBGC1_SELECTr_GET
#define TDBGC1_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC1_SELECTr_BITMAPf_GET
#define TDBGC1_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC1_SELECTr_BITMAPf_SET
#define READ_TDBGC1_SELECTr BCM53324_A0_READ_TDBGC1_SELECTr
#define WRITE_TDBGC1_SELECTr BCM53324_A0_WRITE_TDBGC1_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC1_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC2
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #2
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC2r 0x0a900002

#define BCM53324_A0_TDBGC2r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC2.
 *
 */
typedef union BCM53324_A0_TDBGC2r_s {
	uint32_t v[1];
	uint32_t tdbgc2[1];
	uint32_t _tdbgc2;
} BCM53324_A0_TDBGC2r_t;

#define BCM53324_A0_TDBGC2r_CLR(r) (r).tdbgc2[0] = 0
#define BCM53324_A0_TDBGC2r_SET(r,d) (r).tdbgc2[0] = d
#define BCM53324_A0_TDBGC2r_GET(r) (r).tdbgc2[0]


/*
 * These macros can be used to access TDBGC2.
 *
 */
#define BCM53324_A0_READ_TDBGC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC2r,(r._tdbgc2))
#define BCM53324_A0_WRITE_TDBGC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC2r,&(r._tdbgc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC2r BCM53324_A0_TDBGC2r
#define TDBGC2r_SIZE BCM53324_A0_TDBGC2r_SIZE
typedef BCM53324_A0_TDBGC2r_t TDBGC2r_t;
#define TDBGC2r_CLR BCM53324_A0_TDBGC2r_CLR
#define TDBGC2r_SET BCM53324_A0_TDBGC2r_SET
#define TDBGC2r_GET BCM53324_A0_TDBGC2r_GET
#define READ_TDBGC2r BCM53324_A0_READ_TDBGC2r
#define WRITE_TDBGC2r BCM53324_A0_WRITE_TDBGC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC2_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #2 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC2_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC2_SELECTr 0x0a980022

#define BCM53324_A0_TDBGC2_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC2_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC2_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc2_select[1];
	uint32_t _tdbgc2_select;
} BCM53324_A0_TDBGC2_SELECTr_t;

#define BCM53324_A0_TDBGC2_SELECTr_CLR(r) (r).tdbgc2_select[0] = 0
#define BCM53324_A0_TDBGC2_SELECTr_SET(r,d) (r).tdbgc2_select[0] = d
#define BCM53324_A0_TDBGC2_SELECTr_GET(r) (r).tdbgc2_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC2_SELECTr_BITMAPf_GET(r) (((r).tdbgc2_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC2_SELECTr_BITMAPf_SET(r,f) (r).tdbgc2_select[0]=(((r).tdbgc2_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC2_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC2_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC2_SELECTr,(r._tdbgc2_select))
#define BCM53324_A0_WRITE_TDBGC2_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC2_SELECTr,&(r._tdbgc2_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC2_SELECTr BCM53324_A0_TDBGC2_SELECTr
#define TDBGC2_SELECTr_SIZE BCM53324_A0_TDBGC2_SELECTr_SIZE
typedef BCM53324_A0_TDBGC2_SELECTr_t TDBGC2_SELECTr_t;
#define TDBGC2_SELECTr_CLR BCM53324_A0_TDBGC2_SELECTr_CLR
#define TDBGC2_SELECTr_SET BCM53324_A0_TDBGC2_SELECTr_SET
#define TDBGC2_SELECTr_GET BCM53324_A0_TDBGC2_SELECTr_GET
#define TDBGC2_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC2_SELECTr_BITMAPf_GET
#define TDBGC2_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC2_SELECTr_BITMAPf_SET
#define READ_TDBGC2_SELECTr BCM53324_A0_READ_TDBGC2_SELECTr
#define WRITE_TDBGC2_SELECTr BCM53324_A0_WRITE_TDBGC2_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC2_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC3
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #3
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC3r 0x0a900003

#define BCM53324_A0_TDBGC3r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC3.
 *
 */
typedef union BCM53324_A0_TDBGC3r_s {
	uint32_t v[1];
	uint32_t tdbgc3[1];
	uint32_t _tdbgc3;
} BCM53324_A0_TDBGC3r_t;

#define BCM53324_A0_TDBGC3r_CLR(r) (r).tdbgc3[0] = 0
#define BCM53324_A0_TDBGC3r_SET(r,d) (r).tdbgc3[0] = d
#define BCM53324_A0_TDBGC3r_GET(r) (r).tdbgc3[0]


/*
 * These macros can be used to access TDBGC3.
 *
 */
#define BCM53324_A0_READ_TDBGC3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC3r,(r._tdbgc3))
#define BCM53324_A0_WRITE_TDBGC3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC3r,&(r._tdbgc3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC3r BCM53324_A0_TDBGC3r
#define TDBGC3r_SIZE BCM53324_A0_TDBGC3r_SIZE
typedef BCM53324_A0_TDBGC3r_t TDBGC3r_t;
#define TDBGC3r_CLR BCM53324_A0_TDBGC3r_CLR
#define TDBGC3r_SET BCM53324_A0_TDBGC3r_SET
#define TDBGC3r_GET BCM53324_A0_TDBGC3r_GET
#define READ_TDBGC3r BCM53324_A0_READ_TDBGC3r
#define WRITE_TDBGC3r BCM53324_A0_WRITE_TDBGC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC3_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #3 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC3_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC3_SELECTr 0x0a980023

#define BCM53324_A0_TDBGC3_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC3_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC3_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc3_select[1];
	uint32_t _tdbgc3_select;
} BCM53324_A0_TDBGC3_SELECTr_t;

#define BCM53324_A0_TDBGC3_SELECTr_CLR(r) (r).tdbgc3_select[0] = 0
#define BCM53324_A0_TDBGC3_SELECTr_SET(r,d) (r).tdbgc3_select[0] = d
#define BCM53324_A0_TDBGC3_SELECTr_GET(r) (r).tdbgc3_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC3_SELECTr_BITMAPf_GET(r) (((r).tdbgc3_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC3_SELECTr_BITMAPf_SET(r,f) (r).tdbgc3_select[0]=(((r).tdbgc3_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC3_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC3_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC3_SELECTr,(r._tdbgc3_select))
#define BCM53324_A0_WRITE_TDBGC3_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC3_SELECTr,&(r._tdbgc3_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC3_SELECTr BCM53324_A0_TDBGC3_SELECTr
#define TDBGC3_SELECTr_SIZE BCM53324_A0_TDBGC3_SELECTr_SIZE
typedef BCM53324_A0_TDBGC3_SELECTr_t TDBGC3_SELECTr_t;
#define TDBGC3_SELECTr_CLR BCM53324_A0_TDBGC3_SELECTr_CLR
#define TDBGC3_SELECTr_SET BCM53324_A0_TDBGC3_SELECTr_SET
#define TDBGC3_SELECTr_GET BCM53324_A0_TDBGC3_SELECTr_GET
#define TDBGC3_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC3_SELECTr_BITMAPf_GET
#define TDBGC3_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC3_SELECTr_BITMAPf_SET
#define READ_TDBGC3_SELECTr BCM53324_A0_READ_TDBGC3_SELECTr
#define WRITE_TDBGC3_SELECTr BCM53324_A0_WRITE_TDBGC3_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC3_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC4
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #4
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC4r 0x0a900004

#define BCM53324_A0_TDBGC4r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC4.
 *
 */
typedef union BCM53324_A0_TDBGC4r_s {
	uint32_t v[1];
	uint32_t tdbgc4[1];
	uint32_t _tdbgc4;
} BCM53324_A0_TDBGC4r_t;

#define BCM53324_A0_TDBGC4r_CLR(r) (r).tdbgc4[0] = 0
#define BCM53324_A0_TDBGC4r_SET(r,d) (r).tdbgc4[0] = d
#define BCM53324_A0_TDBGC4r_GET(r) (r).tdbgc4[0]


/*
 * These macros can be used to access TDBGC4.
 *
 */
#define BCM53324_A0_READ_TDBGC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC4r,(r._tdbgc4))
#define BCM53324_A0_WRITE_TDBGC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC4r,&(r._tdbgc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC4r BCM53324_A0_TDBGC4r
#define TDBGC4r_SIZE BCM53324_A0_TDBGC4r_SIZE
typedef BCM53324_A0_TDBGC4r_t TDBGC4r_t;
#define TDBGC4r_CLR BCM53324_A0_TDBGC4r_CLR
#define TDBGC4r_SET BCM53324_A0_TDBGC4r_SET
#define TDBGC4r_GET BCM53324_A0_TDBGC4r_GET
#define READ_TDBGC4r BCM53324_A0_READ_TDBGC4r
#define WRITE_TDBGC4r BCM53324_A0_WRITE_TDBGC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC4_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #4 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC4_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC4_SELECTr 0x0a980024

#define BCM53324_A0_TDBGC4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC4_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC4_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc4_select[1];
	uint32_t _tdbgc4_select;
} BCM53324_A0_TDBGC4_SELECTr_t;

#define BCM53324_A0_TDBGC4_SELECTr_CLR(r) (r).tdbgc4_select[0] = 0
#define BCM53324_A0_TDBGC4_SELECTr_SET(r,d) (r).tdbgc4_select[0] = d
#define BCM53324_A0_TDBGC4_SELECTr_GET(r) (r).tdbgc4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC4_SELECTr_BITMAPf_GET(r) (((r).tdbgc4_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC4_SELECTr_BITMAPf_SET(r,f) (r).tdbgc4_select[0]=(((r).tdbgc4_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC4_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC4_SELECTr,(r._tdbgc4_select))
#define BCM53324_A0_WRITE_TDBGC4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC4_SELECTr,&(r._tdbgc4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC4_SELECTr BCM53324_A0_TDBGC4_SELECTr
#define TDBGC4_SELECTr_SIZE BCM53324_A0_TDBGC4_SELECTr_SIZE
typedef BCM53324_A0_TDBGC4_SELECTr_t TDBGC4_SELECTr_t;
#define TDBGC4_SELECTr_CLR BCM53324_A0_TDBGC4_SELECTr_CLR
#define TDBGC4_SELECTr_SET BCM53324_A0_TDBGC4_SELECTr_SET
#define TDBGC4_SELECTr_GET BCM53324_A0_TDBGC4_SELECTr_GET
#define TDBGC4_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC4_SELECTr_BITMAPf_GET
#define TDBGC4_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC4_SELECTr_BITMAPf_SET
#define READ_TDBGC4_SELECTr BCM53324_A0_READ_TDBGC4_SELECTr
#define WRITE_TDBGC4_SELECTr BCM53324_A0_WRITE_TDBGC4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC5
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #5
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC5r 0x0a900005

#define BCM53324_A0_TDBGC5r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC5.
 *
 */
typedef union BCM53324_A0_TDBGC5r_s {
	uint32_t v[1];
	uint32_t tdbgc5[1];
	uint32_t _tdbgc5;
} BCM53324_A0_TDBGC5r_t;

#define BCM53324_A0_TDBGC5r_CLR(r) (r).tdbgc5[0] = 0
#define BCM53324_A0_TDBGC5r_SET(r,d) (r).tdbgc5[0] = d
#define BCM53324_A0_TDBGC5r_GET(r) (r).tdbgc5[0]


/*
 * These macros can be used to access TDBGC5.
 *
 */
#define BCM53324_A0_READ_TDBGC5r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC5r,(r._tdbgc5))
#define BCM53324_A0_WRITE_TDBGC5r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC5r,&(r._tdbgc5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC5r BCM53324_A0_TDBGC5r
#define TDBGC5r_SIZE BCM53324_A0_TDBGC5r_SIZE
typedef BCM53324_A0_TDBGC5r_t TDBGC5r_t;
#define TDBGC5r_CLR BCM53324_A0_TDBGC5r_CLR
#define TDBGC5r_SET BCM53324_A0_TDBGC5r_SET
#define TDBGC5r_GET BCM53324_A0_TDBGC5r_GET
#define READ_TDBGC5r BCM53324_A0_READ_TDBGC5r
#define WRITE_TDBGC5r BCM53324_A0_WRITE_TDBGC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC5_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #5 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC5_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC5_SELECTr 0x0a980025

#define BCM53324_A0_TDBGC5_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC5_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC5_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc5_select[1];
	uint32_t _tdbgc5_select;
} BCM53324_A0_TDBGC5_SELECTr_t;

#define BCM53324_A0_TDBGC5_SELECTr_CLR(r) (r).tdbgc5_select[0] = 0
#define BCM53324_A0_TDBGC5_SELECTr_SET(r,d) (r).tdbgc5_select[0] = d
#define BCM53324_A0_TDBGC5_SELECTr_GET(r) (r).tdbgc5_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC5_SELECTr_BITMAPf_GET(r) (((r).tdbgc5_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC5_SELECTr_BITMAPf_SET(r,f) (r).tdbgc5_select[0]=(((r).tdbgc5_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC5_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC5_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC5_SELECTr,(r._tdbgc5_select))
#define BCM53324_A0_WRITE_TDBGC5_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC5_SELECTr,&(r._tdbgc5_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC5_SELECTr BCM53324_A0_TDBGC5_SELECTr
#define TDBGC5_SELECTr_SIZE BCM53324_A0_TDBGC5_SELECTr_SIZE
typedef BCM53324_A0_TDBGC5_SELECTr_t TDBGC5_SELECTr_t;
#define TDBGC5_SELECTr_CLR BCM53324_A0_TDBGC5_SELECTr_CLR
#define TDBGC5_SELECTr_SET BCM53324_A0_TDBGC5_SELECTr_SET
#define TDBGC5_SELECTr_GET BCM53324_A0_TDBGC5_SELECTr_GET
#define TDBGC5_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC5_SELECTr_BITMAPf_GET
#define TDBGC5_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC5_SELECTr_BITMAPf_SET
#define READ_TDBGC5_SELECTr BCM53324_A0_READ_TDBGC5_SELECTr
#define WRITE_TDBGC5_SELECTr BCM53324_A0_WRITE_TDBGC5_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC5_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC6
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #6
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC6r 0x0a900006

#define BCM53324_A0_TDBGC6r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC6.
 *
 */
typedef union BCM53324_A0_TDBGC6r_s {
	uint32_t v[1];
	uint32_t tdbgc6[1];
	uint32_t _tdbgc6;
} BCM53324_A0_TDBGC6r_t;

#define BCM53324_A0_TDBGC6r_CLR(r) (r).tdbgc6[0] = 0
#define BCM53324_A0_TDBGC6r_SET(r,d) (r).tdbgc6[0] = d
#define BCM53324_A0_TDBGC6r_GET(r) (r).tdbgc6[0]


/*
 * These macros can be used to access TDBGC6.
 *
 */
#define BCM53324_A0_READ_TDBGC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC6r,(r._tdbgc6))
#define BCM53324_A0_WRITE_TDBGC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC6r,&(r._tdbgc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC6r BCM53324_A0_TDBGC6r
#define TDBGC6r_SIZE BCM53324_A0_TDBGC6r_SIZE
typedef BCM53324_A0_TDBGC6r_t TDBGC6r_t;
#define TDBGC6r_CLR BCM53324_A0_TDBGC6r_CLR
#define TDBGC6r_SET BCM53324_A0_TDBGC6r_SET
#define TDBGC6r_GET BCM53324_A0_TDBGC6r_GET
#define READ_TDBGC6r BCM53324_A0_READ_TDBGC6r
#define WRITE_TDBGC6r BCM53324_A0_WRITE_TDBGC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC6_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #6 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC6_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC6_SELECTr 0x0a980026

#define BCM53324_A0_TDBGC6_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC6_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC6_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc6_select[1];
	uint32_t _tdbgc6_select;
} BCM53324_A0_TDBGC6_SELECTr_t;

#define BCM53324_A0_TDBGC6_SELECTr_CLR(r) (r).tdbgc6_select[0] = 0
#define BCM53324_A0_TDBGC6_SELECTr_SET(r,d) (r).tdbgc6_select[0] = d
#define BCM53324_A0_TDBGC6_SELECTr_GET(r) (r).tdbgc6_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC6_SELECTr_BITMAPf_GET(r) (((r).tdbgc6_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC6_SELECTr_BITMAPf_SET(r,f) (r).tdbgc6_select[0]=(((r).tdbgc6_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC6_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC6_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC6_SELECTr,(r._tdbgc6_select))
#define BCM53324_A0_WRITE_TDBGC6_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC6_SELECTr,&(r._tdbgc6_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC6_SELECTr BCM53324_A0_TDBGC6_SELECTr
#define TDBGC6_SELECTr_SIZE BCM53324_A0_TDBGC6_SELECTr_SIZE
typedef BCM53324_A0_TDBGC6_SELECTr_t TDBGC6_SELECTr_t;
#define TDBGC6_SELECTr_CLR BCM53324_A0_TDBGC6_SELECTr_CLR
#define TDBGC6_SELECTr_SET BCM53324_A0_TDBGC6_SELECTr_SET
#define TDBGC6_SELECTr_GET BCM53324_A0_TDBGC6_SELECTr_GET
#define TDBGC6_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC6_SELECTr_BITMAPf_GET
#define TDBGC6_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC6_SELECTr_BITMAPf_SET
#define READ_TDBGC6_SELECTr BCM53324_A0_READ_TDBGC6_SELECTr
#define WRITE_TDBGC6_SELECTr BCM53324_A0_WRITE_TDBGC6_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC6_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC7
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #7
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC7r 0x0a900007

#define BCM53324_A0_TDBGC7r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC7.
 *
 */
typedef union BCM53324_A0_TDBGC7r_s {
	uint32_t v[1];
	uint32_t tdbgc7[1];
	uint32_t _tdbgc7;
} BCM53324_A0_TDBGC7r_t;

#define BCM53324_A0_TDBGC7r_CLR(r) (r).tdbgc7[0] = 0
#define BCM53324_A0_TDBGC7r_SET(r,d) (r).tdbgc7[0] = d
#define BCM53324_A0_TDBGC7r_GET(r) (r).tdbgc7[0]


/*
 * These macros can be used to access TDBGC7.
 *
 */
#define BCM53324_A0_READ_TDBGC7r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC7r,(r._tdbgc7))
#define BCM53324_A0_WRITE_TDBGC7r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC7r,&(r._tdbgc7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC7r BCM53324_A0_TDBGC7r
#define TDBGC7r_SIZE BCM53324_A0_TDBGC7r_SIZE
typedef BCM53324_A0_TDBGC7r_t TDBGC7r_t;
#define TDBGC7r_CLR BCM53324_A0_TDBGC7r_CLR
#define TDBGC7r_SET BCM53324_A0_TDBGC7r_SET
#define TDBGC7r_GET BCM53324_A0_TDBGC7r_GET
#define READ_TDBGC7r BCM53324_A0_READ_TDBGC7r
#define WRITE_TDBGC7r BCM53324_A0_WRITE_TDBGC7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC7_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #7 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC7_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC7_SELECTr 0x0a980027

#define BCM53324_A0_TDBGC7_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC7_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC7_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc7_select[1];
	uint32_t _tdbgc7_select;
} BCM53324_A0_TDBGC7_SELECTr_t;

#define BCM53324_A0_TDBGC7_SELECTr_CLR(r) (r).tdbgc7_select[0] = 0
#define BCM53324_A0_TDBGC7_SELECTr_SET(r,d) (r).tdbgc7_select[0] = d
#define BCM53324_A0_TDBGC7_SELECTr_GET(r) (r).tdbgc7_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC7_SELECTr_BITMAPf_GET(r) (((r).tdbgc7_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC7_SELECTr_BITMAPf_SET(r,f) (r).tdbgc7_select[0]=(((r).tdbgc7_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC7_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC7_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC7_SELECTr,(r._tdbgc7_select))
#define BCM53324_A0_WRITE_TDBGC7_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC7_SELECTr,&(r._tdbgc7_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC7_SELECTr BCM53324_A0_TDBGC7_SELECTr
#define TDBGC7_SELECTr_SIZE BCM53324_A0_TDBGC7_SELECTr_SIZE
typedef BCM53324_A0_TDBGC7_SELECTr_t TDBGC7_SELECTr_t;
#define TDBGC7_SELECTr_CLR BCM53324_A0_TDBGC7_SELECTr_CLR
#define TDBGC7_SELECTr_SET BCM53324_A0_TDBGC7_SELECTr_SET
#define TDBGC7_SELECTr_GET BCM53324_A0_TDBGC7_SELECTr_GET
#define TDBGC7_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC7_SELECTr_BITMAPf_GET
#define TDBGC7_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC7_SELECTr_BITMAPf_SET
#define READ_TDBGC7_SELECTr BCM53324_A0_READ_TDBGC7_SELECTr
#define WRITE_TDBGC7_SELECTr BCM53324_A0_WRITE_TDBGC7_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC7_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC8
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #8
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC8r 0x0a900008

#define BCM53324_A0_TDBGC8r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC8.
 *
 */
typedef union BCM53324_A0_TDBGC8r_s {
	uint32_t v[1];
	uint32_t tdbgc8[1];
	uint32_t _tdbgc8;
} BCM53324_A0_TDBGC8r_t;

#define BCM53324_A0_TDBGC8r_CLR(r) (r).tdbgc8[0] = 0
#define BCM53324_A0_TDBGC8r_SET(r,d) (r).tdbgc8[0] = d
#define BCM53324_A0_TDBGC8r_GET(r) (r).tdbgc8[0]


/*
 * These macros can be used to access TDBGC8.
 *
 */
#define BCM53324_A0_READ_TDBGC8r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC8r,(r._tdbgc8))
#define BCM53324_A0_WRITE_TDBGC8r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC8r,&(r._tdbgc8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC8r BCM53324_A0_TDBGC8r
#define TDBGC8r_SIZE BCM53324_A0_TDBGC8r_SIZE
typedef BCM53324_A0_TDBGC8r_t TDBGC8r_t;
#define TDBGC8r_CLR BCM53324_A0_TDBGC8r_CLR
#define TDBGC8r_SET BCM53324_A0_TDBGC8r_SET
#define TDBGC8r_GET BCM53324_A0_TDBGC8r_GET
#define READ_TDBGC8r BCM53324_A0_READ_TDBGC8r
#define WRITE_TDBGC8r BCM53324_A0_WRITE_TDBGC8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC8_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #8 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC8_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC8_SELECTr 0x0a980028

#define BCM53324_A0_TDBGC8_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC8_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC8_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc8_select[1];
	uint32_t _tdbgc8_select;
} BCM53324_A0_TDBGC8_SELECTr_t;

#define BCM53324_A0_TDBGC8_SELECTr_CLR(r) (r).tdbgc8_select[0] = 0
#define BCM53324_A0_TDBGC8_SELECTr_SET(r,d) (r).tdbgc8_select[0] = d
#define BCM53324_A0_TDBGC8_SELECTr_GET(r) (r).tdbgc8_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC8_SELECTr_BITMAPf_GET(r) (((r).tdbgc8_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC8_SELECTr_BITMAPf_SET(r,f) (r).tdbgc8_select[0]=(((r).tdbgc8_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC8_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC8_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC8_SELECTr,(r._tdbgc8_select))
#define BCM53324_A0_WRITE_TDBGC8_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC8_SELECTr,&(r._tdbgc8_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC8_SELECTr BCM53324_A0_TDBGC8_SELECTr
#define TDBGC8_SELECTr_SIZE BCM53324_A0_TDBGC8_SELECTr_SIZE
typedef BCM53324_A0_TDBGC8_SELECTr_t TDBGC8_SELECTr_t;
#define TDBGC8_SELECTr_CLR BCM53324_A0_TDBGC8_SELECTr_CLR
#define TDBGC8_SELECTr_SET BCM53324_A0_TDBGC8_SELECTr_SET
#define TDBGC8_SELECTr_GET BCM53324_A0_TDBGC8_SELECTr_GET
#define TDBGC8_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC8_SELECTr_BITMAPf_GET
#define TDBGC8_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC8_SELECTr_BITMAPf_SET
#define READ_TDBGC8_SELECTr BCM53324_A0_READ_TDBGC8_SELECTr
#define WRITE_TDBGC8_SELECTr BCM53324_A0_WRITE_TDBGC8_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC8_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC9
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #9
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC9r 0x0a900009

#define BCM53324_A0_TDBGC9r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC9.
 *
 */
typedef union BCM53324_A0_TDBGC9r_s {
	uint32_t v[1];
	uint32_t tdbgc9[1];
	uint32_t _tdbgc9;
} BCM53324_A0_TDBGC9r_t;

#define BCM53324_A0_TDBGC9r_CLR(r) (r).tdbgc9[0] = 0
#define BCM53324_A0_TDBGC9r_SET(r,d) (r).tdbgc9[0] = d
#define BCM53324_A0_TDBGC9r_GET(r) (r).tdbgc9[0]


/*
 * These macros can be used to access TDBGC9.
 *
 */
#define BCM53324_A0_READ_TDBGC9r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TDBGC9r,(r._tdbgc9))
#define BCM53324_A0_WRITE_TDBGC9r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TDBGC9r,&(r._tdbgc9))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC9r BCM53324_A0_TDBGC9r
#define TDBGC9r_SIZE BCM53324_A0_TDBGC9r_SIZE
typedef BCM53324_A0_TDBGC9r_t TDBGC9r_t;
#define TDBGC9r_CLR BCM53324_A0_TDBGC9r_CLR
#define TDBGC9r_SET BCM53324_A0_TDBGC9r_SET
#define TDBGC9r_GET BCM53324_A0_TDBGC9r_GET
#define READ_TDBGC9r BCM53324_A0_READ_TDBGC9r
#define WRITE_TDBGC9r BCM53324_A0_WRITE_TDBGC9r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TDBGC9_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #9 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC9_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM53324_A0_TDBGC9_SELECTr 0x0a980029

#define BCM53324_A0_TDBGC9_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC9_SELECT.
 *
 */
typedef union BCM53324_A0_TDBGC9_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc9_select[1];
	uint32_t _tdbgc9_select;
} BCM53324_A0_TDBGC9_SELECTr_t;

#define BCM53324_A0_TDBGC9_SELECTr_CLR(r) (r).tdbgc9_select[0] = 0
#define BCM53324_A0_TDBGC9_SELECTr_SET(r,d) (r).tdbgc9_select[0] = d
#define BCM53324_A0_TDBGC9_SELECTr_GET(r) (r).tdbgc9_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TDBGC9_SELECTr_BITMAPf_GET(r) (((r).tdbgc9_select[0]) & 0x1fffff)
#define BCM53324_A0_TDBGC9_SELECTr_BITMAPf_SET(r,f) (r).tdbgc9_select[0]=(((r).tdbgc9_select[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TDBGC9_SELECT.
 *
 */
#define BCM53324_A0_READ_TDBGC9_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TDBGC9_SELECTr,(r._tdbgc9_select))
#define BCM53324_A0_WRITE_TDBGC9_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TDBGC9_SELECTr,&(r._tdbgc9_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC9_SELECTr BCM53324_A0_TDBGC9_SELECTr
#define TDBGC9_SELECTr_SIZE BCM53324_A0_TDBGC9_SELECTr_SIZE
typedef BCM53324_A0_TDBGC9_SELECTr_t TDBGC9_SELECTr_t;
#define TDBGC9_SELECTr_CLR BCM53324_A0_TDBGC9_SELECTr_CLR
#define TDBGC9_SELECTr_SET BCM53324_A0_TDBGC9_SELECTr_SET
#define TDBGC9_SELECTr_GET BCM53324_A0_TDBGC9_SELECTr_GET
#define TDBGC9_SELECTr_BITMAPf_GET BCM53324_A0_TDBGC9_SELECTr_BITMAPf_GET
#define TDBGC9_SELECTr_BITMAPf_SET BCM53324_A0_TDBGC9_SELECTr_BITMAPf_SET
#define READ_TDBGC9_SELECTr BCM53324_A0_READ_TDBGC9_SELECTr
#define WRITE_TDBGC9_SELECTr BCM53324_A0_WRITE_TDBGC9_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TDBGC9_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TOTALDYNCELLRESETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLRESETLIMIT This regs is the reset limit. When total dynamic cell count is less than this reste limit. All COS hol dropping status will be reset. Default valueis 0x600 (1.5K cells)
 *
 ******************************************************************************/
#define BCM53324_A0_TOTALDYNCELLRESETLIMITr 0x00680040

#define BCM53324_A0_TOTALDYNCELLRESETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLRESETLIMIT.
 *
 */
typedef union BCM53324_A0_TOTALDYNCELLRESETLIMITr_s {
	uint32_t v[1];
	uint32_t totaldyncellresetlimit[1];
	uint32_t _totaldyncellresetlimit;
} BCM53324_A0_TOTALDYNCELLRESETLIMITr_t;

#define BCM53324_A0_TOTALDYNCELLRESETLIMITr_CLR(r) (r).totaldyncellresetlimit[0] = 0
#define BCM53324_A0_TOTALDYNCELLRESETLIMITr_SET(r,d) (r).totaldyncellresetlimit[0] = d
#define BCM53324_A0_TOTALDYNCELLRESETLIMITr_GET(r) (r).totaldyncellresetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_GET(r) (((r).totaldyncellresetlimit[0]) & 0x3ffff)
#define BCM53324_A0_TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_SET(r,f) (r).totaldyncellresetlimit[0]=(((r).totaldyncellresetlimit[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access TOTALDYNCELLRESETLIMIT.
 *
 */
#define BCM53324_A0_READ_TOTALDYNCELLRESETLIMITr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TOTALDYNCELLRESETLIMITr,(r._totaldyncellresetlimit))
#define BCM53324_A0_WRITE_TOTALDYNCELLRESETLIMITr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TOTALDYNCELLRESETLIMITr,&(r._totaldyncellresetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTALDYNCELLRESETLIMITr BCM53324_A0_TOTALDYNCELLRESETLIMITr
#define TOTALDYNCELLRESETLIMITr_SIZE BCM53324_A0_TOTALDYNCELLRESETLIMITr_SIZE
typedef BCM53324_A0_TOTALDYNCELLRESETLIMITr_t TOTALDYNCELLRESETLIMITr_t;
#define TOTALDYNCELLRESETLIMITr_CLR BCM53324_A0_TOTALDYNCELLRESETLIMITr_CLR
#define TOTALDYNCELLRESETLIMITr_SET BCM53324_A0_TOTALDYNCELLRESETLIMITr_SET
#define TOTALDYNCELLRESETLIMITr_GET BCM53324_A0_TOTALDYNCELLRESETLIMITr_GET
#define TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_GET BCM53324_A0_TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_GET
#define TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_SET BCM53324_A0_TOTALDYNCELLRESETLIMITr_TOTALDYNCELLRESETLIMITf_SET
#define READ_TOTALDYNCELLRESETLIMITr BCM53324_A0_READ_TOTALDYNCELLRESETLIMITr
#define WRITE_TOTALDYNCELLRESETLIMITr BCM53324_A0_WRITE_TOTALDYNCELLRESETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TOTALDYNCELLRESETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TOTALDYNCELLSETLIMIT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLSETLIMIT Total Dynamic Cell Count Limit for whole CBP memory. This represents thetotal dynamic cells that can be used by all {ports,cos}.Default value is 0x800 (2K cells).
 *
 ******************************************************************************/
#define BCM53324_A0_TOTALDYNCELLSETLIMITr 0x00680013

#define BCM53324_A0_TOTALDYNCELLSETLIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLSETLIMIT.
 *
 */
typedef union BCM53324_A0_TOTALDYNCELLSETLIMITr_s {
	uint32_t v[1];
	uint32_t totaldyncellsetlimit[1];
	uint32_t _totaldyncellsetlimit;
} BCM53324_A0_TOTALDYNCELLSETLIMITr_t;

#define BCM53324_A0_TOTALDYNCELLSETLIMITr_CLR(r) (r).totaldyncellsetlimit[0] = 0
#define BCM53324_A0_TOTALDYNCELLSETLIMITr_SET(r,d) (r).totaldyncellsetlimit[0] = d
#define BCM53324_A0_TOTALDYNCELLSETLIMITr_GET(r) (r).totaldyncellsetlimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_GET(r) (((r).totaldyncellsetlimit[0]) & 0x3ffff)
#define BCM53324_A0_TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_SET(r,f) (r).totaldyncellsetlimit[0]=(((r).totaldyncellsetlimit[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access TOTALDYNCELLSETLIMIT.
 *
 */
#define BCM53324_A0_READ_TOTALDYNCELLSETLIMITr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TOTALDYNCELLSETLIMITr,(r._totaldyncellsetlimit))
#define BCM53324_A0_WRITE_TOTALDYNCELLSETLIMITr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TOTALDYNCELLSETLIMITr,&(r._totaldyncellsetlimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTALDYNCELLSETLIMITr BCM53324_A0_TOTALDYNCELLSETLIMITr
#define TOTALDYNCELLSETLIMITr_SIZE BCM53324_A0_TOTALDYNCELLSETLIMITr_SIZE
typedef BCM53324_A0_TOTALDYNCELLSETLIMITr_t TOTALDYNCELLSETLIMITr_t;
#define TOTALDYNCELLSETLIMITr_CLR BCM53324_A0_TOTALDYNCELLSETLIMITr_CLR
#define TOTALDYNCELLSETLIMITr_SET BCM53324_A0_TOTALDYNCELLSETLIMITr_SET
#define TOTALDYNCELLSETLIMITr_GET BCM53324_A0_TOTALDYNCELLSETLIMITr_GET
#define TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_GET BCM53324_A0_TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_GET
#define TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_SET BCM53324_A0_TOTALDYNCELLSETLIMITr_TOTALDYNCELLSETLIMITf_SET
#define READ_TOTALDYNCELLSETLIMITr BCM53324_A0_READ_TOTALDYNCELLSETLIMITr
#define WRITE_TOTALDYNCELLSETLIMITr BCM53324_A0_WRITE_TOTALDYNCELLSETLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TOTALDYNCELLSETLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TOTALDYNCELLUSED
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TOTALDYNCELLUSED Total Dynamic Cell Count for whole CBP memory.This represents thetotal dynamic cells that are be used by all {ports,cos}.
 *
 ******************************************************************************/
#define BCM53324_A0_TOTALDYNCELLUSEDr 0x00680014

#define BCM53324_A0_TOTALDYNCELLUSEDr_SIZE 4

/*
 * This structure should be used to declare and program TOTALDYNCELLUSED.
 *
 */
typedef union BCM53324_A0_TOTALDYNCELLUSEDr_s {
	uint32_t v[1];
	uint32_t totaldyncellused[1];
	uint32_t _totaldyncellused;
} BCM53324_A0_TOTALDYNCELLUSEDr_t;

#define BCM53324_A0_TOTALDYNCELLUSEDr_CLR(r) (r).totaldyncellused[0] = 0
#define BCM53324_A0_TOTALDYNCELLUSEDr_SET(r,d) (r).totaldyncellused[0] = d
#define BCM53324_A0_TOTALDYNCELLUSEDr_GET(r) (r).totaldyncellused[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET(r) (((r).totaldyncellused[0]) & 0x3ffff)
#define BCM53324_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET(r,f) (r).totaldyncellused[0]=(((r).totaldyncellused[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access TOTALDYNCELLUSED.
 *
 */
#define BCM53324_A0_READ_TOTALDYNCELLUSEDr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TOTALDYNCELLUSEDr,(r._totaldyncellused))
#define BCM53324_A0_WRITE_TOTALDYNCELLUSEDr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TOTALDYNCELLUSEDr,&(r._totaldyncellused))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTALDYNCELLUSEDr BCM53324_A0_TOTALDYNCELLUSEDr
#define TOTALDYNCELLUSEDr_SIZE BCM53324_A0_TOTALDYNCELLUSEDr_SIZE
typedef BCM53324_A0_TOTALDYNCELLUSEDr_t TOTALDYNCELLUSEDr_t;
#define TOTALDYNCELLUSEDr_CLR BCM53324_A0_TOTALDYNCELLUSEDr_CLR
#define TOTALDYNCELLUSEDr_SET BCM53324_A0_TOTALDYNCELLUSEDr_SET
#define TOTALDYNCELLUSEDr_GET BCM53324_A0_TOTALDYNCELLUSEDr_GET
#define TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET BCM53324_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_GET
#define TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET BCM53324_A0_TOTALDYNCELLUSEDr_TOTALDYNCELLUSEDf_SET
#define READ_TOTALDYNCELLUSEDr BCM53324_A0_READ_TOTALDYNCELLUSEDr
#define WRITE_TOTALDYNCELLUSEDr BCM53324_A0_WRITE_TOTALDYNCELLUSEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TOTALDYNCELLUSEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TPCE
 * BLOCKS:   EPIPE
 * DESC:     Egress Purge and Cell Error Drop Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TPCEr 0x0a90000c

#define BCM53324_A0_TPCEr_SIZE 4

/*
 * This structure should be used to declare and program TPCE.
 *
 */
typedef union BCM53324_A0_TPCEr_s {
	uint32_t v[1];
	uint32_t tpce[1];
	uint32_t _tpce;
} BCM53324_A0_TPCEr_t;

#define BCM53324_A0_TPCEr_CLR(r) (r).tpce[0] = 0
#define BCM53324_A0_TPCEr_SET(r,d) (r).tpce[0] = d
#define BCM53324_A0_TPCEr_GET(r) (r).tpce[0]


/*
 * These macros can be used to access TPCE.
 *
 */
#define BCM53324_A0_READ_TPCEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TPCEr,(r._tpce))
#define BCM53324_A0_WRITE_TPCEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TPCEr,&(r._tpce))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TPCEr BCM53324_A0_TPCEr
#define TPCEr_SIZE BCM53324_A0_TPCEr_SIZE
typedef BCM53324_A0_TPCEr_t TPCEr_t;
#define TPCEr_CLR BCM53324_A0_TPCEr_CLR
#define TPCEr_SET BCM53324_A0_TPCEr_SET
#define TPCEr_GET BCM53324_A0_TPCEr_GET
#define READ_TPCEr BCM53324_A0_READ_TPCEr
#define WRITE_TPCEr BCM53324_A0_WRITE_TPCEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TPCEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  TRUNK_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table. To check membership based on src TGID. Indexed using src tgid.
 * SIZE:     25
 * FIELDS:
 *     TRUNK_BITMAP     Source Trunk Bitmap Table
 *     TRUNK_BITMAP_LO  Source Trunk Bitmap Table
 *
 ******************************************************************************/
#define BCM53324_A0_TRUNK_BITMAPm 0x0f730000

#define BCM53324_A0_TRUNK_BITMAPm_MIN 0
#define BCM53324_A0_TRUNK_BITMAPm_MAX 7
#define BCM53324_A0_TRUNK_BITMAPm_CMAX(u) 7
#define BCM53324_A0_TRUNK_BITMAPm_SIZE 4

/*
 * This structure should be used to declare and program TRUNK_BITMAP.
 *
 */
typedef union BCM53324_A0_TRUNK_BITMAPm_s {
	uint32_t v[1];
	uint32_t trunk_bitmap[1];
	uint32_t _trunk_bitmap;
} BCM53324_A0_TRUNK_BITMAPm_t;

#define BCM53324_A0_TRUNK_BITMAPm_CLR(r) (r).trunk_bitmap[0] = 0
#define BCM53324_A0_TRUNK_BITMAPm_SET(r,d) (r).trunk_bitmap[0] = d
#define BCM53324_A0_TRUNK_BITMAPm_GET(r) (r).trunk_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_GET(r) (((r).trunk_bitmap[0]) & 0x1ffffff)
#define BCM53324_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_SET(r,f) (r).trunk_bitmap[0]=(((r).trunk_bitmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_TRUNK_BITMAPm_TRUNK_BITMAP_LOf_GET(r) (((r).trunk_bitmap[0]) & 0x1ffffff)
#define BCM53324_A0_TRUNK_BITMAPm_TRUNK_BITMAP_LOf_SET(r,f) (r).trunk_bitmap[0]=(((r).trunk_bitmap[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access TRUNK_BITMAP.
 *
 */
#define BCM53324_A0_READ_TRUNK_BITMAPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_TRUNK_BITMAPm,i,(m._trunk_bitmap),1)
#define BCM53324_A0_WRITE_TRUNK_BITMAPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_TRUNK_BITMAPm,i,&(m._trunk_bitmap),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_BITMAPm BCM53324_A0_TRUNK_BITMAPm
#define TRUNK_BITMAPm_MIN BCM53324_A0_TRUNK_BITMAPm_MIN
#define TRUNK_BITMAPm_MAX BCM53324_A0_TRUNK_BITMAPm_MAX
#define TRUNK_BITMAPm_CMAX(u) BCM53324_A0_TRUNK_BITMAPm_CMAX(u)
#define TRUNK_BITMAPm_SIZE BCM53324_A0_TRUNK_BITMAPm_SIZE
typedef BCM53324_A0_TRUNK_BITMAPm_t TRUNK_BITMAPm_t;
#define TRUNK_BITMAPm_CLR BCM53324_A0_TRUNK_BITMAPm_CLR
#define TRUNK_BITMAPm_SET BCM53324_A0_TRUNK_BITMAPm_SET
#define TRUNK_BITMAPm_GET BCM53324_A0_TRUNK_BITMAPm_GET
#define TRUNK_BITMAPm_TRUNK_BITMAPf_GET BCM53324_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_GET
#define TRUNK_BITMAPm_TRUNK_BITMAPf_SET BCM53324_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_SET
#define TRUNK_BITMAPm_TRUNK_BITMAP_LOf_GET BCM53324_A0_TRUNK_BITMAPm_TRUNK_BITMAP_LOf_GET
#define TRUNK_BITMAPm_TRUNK_BITMAP_LOf_SET BCM53324_A0_TRUNK_BITMAPm_TRUNK_BITMAP_LOf_SET
#define READ_TRUNK_BITMAPm BCM53324_A0_READ_TRUNK_BITMAPm
#define WRITE_TRUNK_BITMAPm BCM53324_A0_WRITE_TRUNK_BITMAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TRUNK_BITMAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  TRUNK_GROUP
 * BLOCKS:   IPIPE
 * DESC:     Trunk Group Table. It contains information about LAG groups, memberships, RULEs for hash selection. Indexed using TGID.
 * SIZE:     83
 * FIELDS:
 *     PORT0            trunk port 0
 *     MODULE0          module id 0
 *     PORT1            trunk port 1
 *     MODULE1          module id 1
 *     PORT2            trunk port 2
 *     MODULE2          module id 2
 *     PORT3            trunk port 3
 *     MODULE3          module id 3
 *     PORT4            trunk port 4
 *     MODULE4          module id 4
 *     PORT5            trunk port 5
 *     MODULE5          module id 5
 *     PORT6            trunk port 6
 *     MODULE6          module id 6
 *     PORT7            trunk port 7
 *     MODULE7          module id 7
 *     RTAG             Supported RTAG values
 *
 ******************************************************************************/
#define BCM53324_A0_TRUNK_GROUPm 0x0f720000

#define BCM53324_A0_TRUNK_GROUPm_MIN 0
#define BCM53324_A0_TRUNK_GROUPm_MAX 7
#define BCM53324_A0_TRUNK_GROUPm_CMAX(u) 7
#define BCM53324_A0_TRUNK_GROUPm_SIZE 11

/*
 * This structure should be used to declare and program TRUNK_GROUP.
 *
 */
typedef union BCM53324_A0_TRUNK_GROUPm_s {
	uint32_t v[3];
	uint32_t trunk_group[3];
	uint32_t _trunk_group;
} BCM53324_A0_TRUNK_GROUPm_t;

#define BCM53324_A0_TRUNK_GROUPm_CLR(r) CDK_MEMSET(&((r)._trunk_group), 0, sizeof(BCM53324_A0_TRUNK_GROUPm_t))
#define BCM53324_A0_TRUNK_GROUPm_SET(r,i,d) (r).trunk_group[i] = d
#define BCM53324_A0_TRUNK_GROUPm_GET(r,i) (r).trunk_group[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TRUNK_GROUPm_PORT0f_GET(r) (((r).trunk_group[0]) & 0x3f)
#define BCM53324_A0_TRUNK_GROUPm_PORT0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53324_A0_TRUNK_GROUPm_MODULE0f_GET(r) ((((r).trunk_group[0]) >> 6) & 0xf)
#define BCM53324_A0_TRUNK_GROUPm_MODULE0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM53324_A0_TRUNK_GROUPm_PORT1f_GET(r) ((((r).trunk_group[0]) >> 10) & 0x3f)
#define BCM53324_A0_TRUNK_GROUPm_PORT1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM53324_A0_TRUNK_GROUPm_MODULE1f_GET(r) ((((r).trunk_group[0]) >> 16) & 0xf)
#define BCM53324_A0_TRUNK_GROUPm_MODULE1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53324_A0_TRUNK_GROUPm_PORT2f_GET(r) ((((r).trunk_group[0]) >> 20) & 0x3f)
#define BCM53324_A0_TRUNK_GROUPm_PORT2f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM53324_A0_TRUNK_GROUPm_MODULE2f_GET(r) ((((r).trunk_group[0]) >> 26) & 0xf)
#define BCM53324_A0_TRUNK_GROUPm_MODULE2f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0xf << 26)) | ((((uint32_t)f) & 0xf) << 26))
#define BCM53324_A0_TRUNK_GROUPm_PORT3f_GET(r) cdk_field32_get((r).trunk_group,30,35)
#define BCM53324_A0_TRUNK_GROUPm_PORT3f_SET(r,f) cdk_field32_set((r).trunk_group,30,35,f)
#define BCM53324_A0_TRUNK_GROUPm_MODULE3f_GET(r) ((((r).trunk_group[1]) >> 4) & 0xf)
#define BCM53324_A0_TRUNK_GROUPm_MODULE3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53324_A0_TRUNK_GROUPm_PORT4f_GET(r) ((((r).trunk_group[1]) >> 8) & 0x3f)
#define BCM53324_A0_TRUNK_GROUPm_PORT4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53324_A0_TRUNK_GROUPm_MODULE4f_GET(r) ((((r).trunk_group[1]) >> 14) & 0xf)
#define BCM53324_A0_TRUNK_GROUPm_MODULE4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0xf << 14)) | ((((uint32_t)f) & 0xf) << 14))
#define BCM53324_A0_TRUNK_GROUPm_PORT5f_GET(r) ((((r).trunk_group[1]) >> 18) & 0x3f)
#define BCM53324_A0_TRUNK_GROUPm_PORT5f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM53324_A0_TRUNK_GROUPm_MODULE5f_GET(r) ((((r).trunk_group[1]) >> 24) & 0xf)
#define BCM53324_A0_TRUNK_GROUPm_MODULE5f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53324_A0_TRUNK_GROUPm_PORT6f_GET(r) cdk_field32_get((r).trunk_group,60,65)
#define BCM53324_A0_TRUNK_GROUPm_PORT6f_SET(r,f) cdk_field32_set((r).trunk_group,60,65,f)
#define BCM53324_A0_TRUNK_GROUPm_MODULE6f_GET(r) ((((r).trunk_group[2]) >> 2) & 0xf)
#define BCM53324_A0_TRUNK_GROUPm_MODULE6f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM53324_A0_TRUNK_GROUPm_PORT7f_GET(r) ((((r).trunk_group[2]) >> 6) & 0x3f)
#define BCM53324_A0_TRUNK_GROUPm_PORT7f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM53324_A0_TRUNK_GROUPm_MODULE7f_GET(r) ((((r).trunk_group[2]) >> 12) & 0xf)
#define BCM53324_A0_TRUNK_GROUPm_MODULE7f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53324_A0_TRUNK_GROUPm_RTAGf_GET(r) ((((r).trunk_group[2]) >> 16) & 0x7)
#define BCM53324_A0_TRUNK_GROUPm_RTAGf_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))

/*
 * These macros can be used to access TRUNK_GROUP.
 *
 */
#define BCM53324_A0_READ_TRUNK_GROUPm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_TRUNK_GROUPm,i,(m._trunk_group),3)
#define BCM53324_A0_WRITE_TRUNK_GROUPm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_TRUNK_GROUPm,i,&(m._trunk_group),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GROUPm BCM53324_A0_TRUNK_GROUPm
#define TRUNK_GROUPm_MIN BCM53324_A0_TRUNK_GROUPm_MIN
#define TRUNK_GROUPm_MAX BCM53324_A0_TRUNK_GROUPm_MAX
#define TRUNK_GROUPm_CMAX(u) BCM53324_A0_TRUNK_GROUPm_CMAX(u)
#define TRUNK_GROUPm_SIZE BCM53324_A0_TRUNK_GROUPm_SIZE
typedef BCM53324_A0_TRUNK_GROUPm_t TRUNK_GROUPm_t;
#define TRUNK_GROUPm_CLR BCM53324_A0_TRUNK_GROUPm_CLR
#define TRUNK_GROUPm_SET BCM53324_A0_TRUNK_GROUPm_SET
#define TRUNK_GROUPm_GET BCM53324_A0_TRUNK_GROUPm_GET
#define TRUNK_GROUPm_PORT0f_GET BCM53324_A0_TRUNK_GROUPm_PORT0f_GET
#define TRUNK_GROUPm_PORT0f_SET BCM53324_A0_TRUNK_GROUPm_PORT0f_SET
#define TRUNK_GROUPm_MODULE0f_GET BCM53324_A0_TRUNK_GROUPm_MODULE0f_GET
#define TRUNK_GROUPm_MODULE0f_SET BCM53324_A0_TRUNK_GROUPm_MODULE0f_SET
#define TRUNK_GROUPm_PORT1f_GET BCM53324_A0_TRUNK_GROUPm_PORT1f_GET
#define TRUNK_GROUPm_PORT1f_SET BCM53324_A0_TRUNK_GROUPm_PORT1f_SET
#define TRUNK_GROUPm_MODULE1f_GET BCM53324_A0_TRUNK_GROUPm_MODULE1f_GET
#define TRUNK_GROUPm_MODULE1f_SET BCM53324_A0_TRUNK_GROUPm_MODULE1f_SET
#define TRUNK_GROUPm_PORT2f_GET BCM53324_A0_TRUNK_GROUPm_PORT2f_GET
#define TRUNK_GROUPm_PORT2f_SET BCM53324_A0_TRUNK_GROUPm_PORT2f_SET
#define TRUNK_GROUPm_MODULE2f_GET BCM53324_A0_TRUNK_GROUPm_MODULE2f_GET
#define TRUNK_GROUPm_MODULE2f_SET BCM53324_A0_TRUNK_GROUPm_MODULE2f_SET
#define TRUNK_GROUPm_PORT3f_GET BCM53324_A0_TRUNK_GROUPm_PORT3f_GET
#define TRUNK_GROUPm_PORT3f_SET BCM53324_A0_TRUNK_GROUPm_PORT3f_SET
#define TRUNK_GROUPm_MODULE3f_GET BCM53324_A0_TRUNK_GROUPm_MODULE3f_GET
#define TRUNK_GROUPm_MODULE3f_SET BCM53324_A0_TRUNK_GROUPm_MODULE3f_SET
#define TRUNK_GROUPm_PORT4f_GET BCM53324_A0_TRUNK_GROUPm_PORT4f_GET
#define TRUNK_GROUPm_PORT4f_SET BCM53324_A0_TRUNK_GROUPm_PORT4f_SET
#define TRUNK_GROUPm_MODULE4f_GET BCM53324_A0_TRUNK_GROUPm_MODULE4f_GET
#define TRUNK_GROUPm_MODULE4f_SET BCM53324_A0_TRUNK_GROUPm_MODULE4f_SET
#define TRUNK_GROUPm_PORT5f_GET BCM53324_A0_TRUNK_GROUPm_PORT5f_GET
#define TRUNK_GROUPm_PORT5f_SET BCM53324_A0_TRUNK_GROUPm_PORT5f_SET
#define TRUNK_GROUPm_MODULE5f_GET BCM53324_A0_TRUNK_GROUPm_MODULE5f_GET
#define TRUNK_GROUPm_MODULE5f_SET BCM53324_A0_TRUNK_GROUPm_MODULE5f_SET
#define TRUNK_GROUPm_PORT6f_GET BCM53324_A0_TRUNK_GROUPm_PORT6f_GET
#define TRUNK_GROUPm_PORT6f_SET BCM53324_A0_TRUNK_GROUPm_PORT6f_SET
#define TRUNK_GROUPm_MODULE6f_GET BCM53324_A0_TRUNK_GROUPm_MODULE6f_GET
#define TRUNK_GROUPm_MODULE6f_SET BCM53324_A0_TRUNK_GROUPm_MODULE6f_SET
#define TRUNK_GROUPm_PORT7f_GET BCM53324_A0_TRUNK_GROUPm_PORT7f_GET
#define TRUNK_GROUPm_PORT7f_SET BCM53324_A0_TRUNK_GROUPm_PORT7f_SET
#define TRUNK_GROUPm_MODULE7f_GET BCM53324_A0_TRUNK_GROUPm_MODULE7f_GET
#define TRUNK_GROUPm_MODULE7f_SET BCM53324_A0_TRUNK_GROUPm_MODULE7f_SET
#define TRUNK_GROUPm_RTAGf_GET BCM53324_A0_TRUNK_GROUPm_RTAGf_GET
#define TRUNK_GROUPm_RTAGf_SET BCM53324_A0_TRUNK_GROUPm_RTAGf_SET
#define READ_TRUNK_GROUPm BCM53324_A0_READ_TRUNK_GROUPm
#define WRITE_TRUNK_GROUPm BCM53324_A0_WRITE_TRUNK_GROUPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TRUNK_GROUPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TS_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Holds TS control info
 * SIZE:     32
 * FIELDS:
 *     TS_MSG_BITMAP    The bits correspond to the message values in the lower nibble of the TS message
 *     ETHERTYPE        L2 Ethertype field of the EAV frame
 *
 ******************************************************************************/
#define BCM53324_A0_TS_CONTROLr 0x02780017

#define BCM53324_A0_TS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program TS_CONTROL.
 *
 */
typedef union BCM53324_A0_TS_CONTROLr_s {
	uint32_t v[1];
	uint32_t ts_control[1];
	uint32_t _ts_control;
} BCM53324_A0_TS_CONTROLr_t;

#define BCM53324_A0_TS_CONTROLr_CLR(r) (r).ts_control[0] = 0
#define BCM53324_A0_TS_CONTROLr_SET(r,d) (r).ts_control[0] = d
#define BCM53324_A0_TS_CONTROLr_GET(r) (r).ts_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TS_CONTROLr_TS_MSG_BITMAPf_GET(r) (((r).ts_control[0]) & 0xffff)
#define BCM53324_A0_TS_CONTROLr_TS_MSG_BITMAPf_SET(r,f) (r).ts_control[0]=(((r).ts_control[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_TS_CONTROLr_ETHERTYPEf_GET(r) ((((r).ts_control[0]) >> 16) & 0xffff)
#define BCM53324_A0_TS_CONTROLr_ETHERTYPEf_SET(r,f) (r).ts_control[0]=(((r).ts_control[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access TS_CONTROL.
 *
 */
#define BCM53324_A0_READ_TS_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TS_CONTROLr,(r._ts_control))
#define BCM53324_A0_WRITE_TS_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TS_CONTROLr,&(r._ts_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TS_CONTROLr BCM53324_A0_TS_CONTROLr
#define TS_CONTROLr_SIZE BCM53324_A0_TS_CONTROLr_SIZE
typedef BCM53324_A0_TS_CONTROLr_t TS_CONTROLr_t;
#define TS_CONTROLr_CLR BCM53324_A0_TS_CONTROLr_CLR
#define TS_CONTROLr_SET BCM53324_A0_TS_CONTROLr_SET
#define TS_CONTROLr_GET BCM53324_A0_TS_CONTROLr_GET
#define TS_CONTROLr_TS_MSG_BITMAPf_GET BCM53324_A0_TS_CONTROLr_TS_MSG_BITMAPf_GET
#define TS_CONTROLr_TS_MSG_BITMAPf_SET BCM53324_A0_TS_CONTROLr_TS_MSG_BITMAPf_SET
#define TS_CONTROLr_ETHERTYPEf_GET BCM53324_A0_TS_CONTROLr_ETHERTYPEf_GET
#define TS_CONTROLr_ETHERTYPEf_SET BCM53324_A0_TS_CONTROLr_ETHERTYPEf_SET
#define READ_TS_CONTROLr BCM53324_A0_READ_TS_CONTROLr
#define WRITE_TS_CONTROLr BCM53324_A0_WRITE_TS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TS_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Vlaues for TS frame detection
 * SIZE:     32
 * FIELDS:
 *     MAC_DA_LOWER     MAC address to match TS frame detection
 *
 ******************************************************************************/
#define BCM53324_A0_TS_CONTROL_1r 0x0278001d

#define BCM53324_A0_TS_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program TS_CONTROL_1.
 *
 */
typedef union BCM53324_A0_TS_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t ts_control_1[1];
	uint32_t _ts_control_1;
} BCM53324_A0_TS_CONTROL_1r_t;

#define BCM53324_A0_TS_CONTROL_1r_CLR(r) (r).ts_control_1[0] = 0
#define BCM53324_A0_TS_CONTROL_1r_SET(r,d) (r).ts_control_1[0] = d
#define BCM53324_A0_TS_CONTROL_1r_GET(r) (r).ts_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TS_CONTROL_1r_MAC_DA_LOWERf_GET(r) ((r).ts_control_1[0])
#define BCM53324_A0_TS_CONTROL_1r_MAC_DA_LOWERf_SET(r,f) (r).ts_control_1[0]=((uint32_t)f)

/*
 * These macros can be used to access TS_CONTROL_1.
 *
 */
#define BCM53324_A0_READ_TS_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TS_CONTROL_1r,(r._ts_control_1))
#define BCM53324_A0_WRITE_TS_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TS_CONTROL_1r,&(r._ts_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TS_CONTROL_1r BCM53324_A0_TS_CONTROL_1r
#define TS_CONTROL_1r_SIZE BCM53324_A0_TS_CONTROL_1r_SIZE
typedef BCM53324_A0_TS_CONTROL_1r_t TS_CONTROL_1r_t;
#define TS_CONTROL_1r_CLR BCM53324_A0_TS_CONTROL_1r_CLR
#define TS_CONTROL_1r_SET BCM53324_A0_TS_CONTROL_1r_SET
#define TS_CONTROL_1r_GET BCM53324_A0_TS_CONTROL_1r_GET
#define TS_CONTROL_1r_MAC_DA_LOWERf_GET BCM53324_A0_TS_CONTROL_1r_MAC_DA_LOWERf_GET
#define TS_CONTROL_1r_MAC_DA_LOWERf_SET BCM53324_A0_TS_CONTROL_1r_MAC_DA_LOWERf_SET
#define READ_TS_CONTROL_1r BCM53324_A0_READ_TS_CONTROL_1r
#define WRITE_TS_CONTROL_1r BCM53324_A0_WRITE_TS_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TS_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TS_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Vlaues for TS frame detection
 * SIZE:     32
 * FIELDS:
 *     MAC_DA_UPPER     MAC address to match TS frame detection
 *
 ******************************************************************************/
#define BCM53324_A0_TS_CONTROL_2r 0x0278001c

#define BCM53324_A0_TS_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program TS_CONTROL_2.
 *
 */
typedef union BCM53324_A0_TS_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t ts_control_2[1];
	uint32_t _ts_control_2;
} BCM53324_A0_TS_CONTROL_2r_t;

#define BCM53324_A0_TS_CONTROL_2r_CLR(r) (r).ts_control_2[0] = 0
#define BCM53324_A0_TS_CONTROL_2r_SET(r,d) (r).ts_control_2[0] = d
#define BCM53324_A0_TS_CONTROL_2r_GET(r) (r).ts_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TS_CONTROL_2r_MAC_DA_UPPERf_GET(r) (((r).ts_control_2[0]) & 0xffff)
#define BCM53324_A0_TS_CONTROL_2r_MAC_DA_UPPERf_SET(r,f) (r).ts_control_2[0]=(((r).ts_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access TS_CONTROL_2.
 *
 */
#define BCM53324_A0_READ_TS_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_TS_CONTROL_2r,(r._ts_control_2))
#define BCM53324_A0_WRITE_TS_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_TS_CONTROL_2r,&(r._ts_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TS_CONTROL_2r BCM53324_A0_TS_CONTROL_2r
#define TS_CONTROL_2r_SIZE BCM53324_A0_TS_CONTROL_2r_SIZE
typedef BCM53324_A0_TS_CONTROL_2r_t TS_CONTROL_2r_t;
#define TS_CONTROL_2r_CLR BCM53324_A0_TS_CONTROL_2r_CLR
#define TS_CONTROL_2r_SET BCM53324_A0_TS_CONTROL_2r_SET
#define TS_CONTROL_2r_GET BCM53324_A0_TS_CONTROL_2r_GET
#define TS_CONTROL_2r_MAC_DA_UPPERf_GET BCM53324_A0_TS_CONTROL_2r_MAC_DA_UPPERf_GET
#define TS_CONTROL_2r_MAC_DA_UPPERf_SET BCM53324_A0_TS_CONTROL_2r_MAC_DA_UPPERf_SET
#define READ_TS_CONTROL_2r BCM53324_A0_READ_TS_CONTROL_2r
#define WRITE_TS_CONTROL_2r BCM53324_A0_WRITE_TS_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TS_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TS_STATUS_CNTRL
 * BLOCKS:   GPORT0
 * DESC:     Timestamp contrl/status
 * SIZE:     32
 * FIELDS:
 *     TX_TS_FIFO_FULL  Readonly field assertion shows that the transmit timestamp FIFO is full. 
 *     TX_TS_FIFO_EMPTY Readonly field assertion shows that the transmit timestamp FIFO is empty. 
 *     WORD_AVAIL       Indicates number of cells filled in the tx timestamp FIFO.
 *
 ******************************************************************************/
#define BCM53324_A0_TS_STATUS_CNTRLr 0x000001c6

#define BCM53324_A0_TS_STATUS_CNTRLr_SIZE 4

/*
 * This structure should be used to declare and program TS_STATUS_CNTRL.
 *
 */
typedef union BCM53324_A0_TS_STATUS_CNTRLr_s {
	uint32_t v[1];
	uint32_t ts_status_cntrl[1];
	uint32_t _ts_status_cntrl;
} BCM53324_A0_TS_STATUS_CNTRLr_t;

#define BCM53324_A0_TS_STATUS_CNTRLr_CLR(r) (r).ts_status_cntrl[0] = 0
#define BCM53324_A0_TS_STATUS_CNTRLr_SET(r,d) (r).ts_status_cntrl[0] = d
#define BCM53324_A0_TS_STATUS_CNTRLr_GET(r) (r).ts_status_cntrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_GET(r) (((r).ts_status_cntrl[0]) & 0x1)
#define BCM53324_A0_TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_GET(r) ((((r).ts_status_cntrl[0]) >> 1) & 0x1)
#define BCM53324_A0_TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_TS_STATUS_CNTRLr_WORD_AVAILf_GET(r) ((((r).ts_status_cntrl[0]) >> 2) & 0x7)
#define BCM53324_A0_TS_STATUS_CNTRLr_WORD_AVAILf_SET(r,f) (r).ts_status_cntrl[0]=(((r).ts_status_cntrl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))

/*
 * These macros can be used to access TS_STATUS_CNTRL.
 *
 */
#define BCM53324_A0_READ_TS_STATUS_CNTRLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TS_STATUS_CNTRLr,(r._ts_status_cntrl))
#define BCM53324_A0_WRITE_TS_STATUS_CNTRLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TS_STATUS_CNTRLr,&(r._ts_status_cntrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TS_STATUS_CNTRLr BCM53324_A0_TS_STATUS_CNTRLr
#define TS_STATUS_CNTRLr_SIZE BCM53324_A0_TS_STATUS_CNTRLr_SIZE
typedef BCM53324_A0_TS_STATUS_CNTRLr_t TS_STATUS_CNTRLr_t;
#define TS_STATUS_CNTRLr_CLR BCM53324_A0_TS_STATUS_CNTRLr_CLR
#define TS_STATUS_CNTRLr_SET BCM53324_A0_TS_STATUS_CNTRLr_SET
#define TS_STATUS_CNTRLr_GET BCM53324_A0_TS_STATUS_CNTRLr_GET
#define TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_GET BCM53324_A0_TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_GET
#define TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_SET BCM53324_A0_TS_STATUS_CNTRLr_TX_TS_FIFO_FULLf_SET
#define TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_GET BCM53324_A0_TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_GET
#define TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_SET BCM53324_A0_TS_STATUS_CNTRLr_TX_TS_FIFO_EMPTYf_SET
#define TS_STATUS_CNTRLr_WORD_AVAILf_GET BCM53324_A0_TS_STATUS_CNTRLr_WORD_AVAILf_GET
#define TS_STATUS_CNTRLr_WORD_AVAILf_SET BCM53324_A0_TS_STATUS_CNTRLr_WORD_AVAILf_SET
#define READ_TS_STATUS_CNTRLr BCM53324_A0_READ_TS_STATUS_CNTRLr
#define WRITE_TS_STATUS_CNTRLr BCM53324_A0_WRITE_TS_STATUS_CNTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TS_STATUS_CNTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TXFIFO_STAT
 * BLOCKS:   GPORT0
 * DESC:     TXFIFO status register
 * SIZE:     32
 * FIELDS:
 *     TXFIFO_UNDERRUN  TXFIFO Underrun occurred.
 *     TXFIFO_OVERRUN   TXFIFO Overrun occurred.
 *
 ******************************************************************************/
#define BCM53324_A0_TXFIFO_STATr 0x000001cf

#define BCM53324_A0_TXFIFO_STATr_SIZE 4

/*
 * This structure should be used to declare and program TXFIFO_STAT.
 *
 */
typedef union BCM53324_A0_TXFIFO_STATr_s {
	uint32_t v[1];
	uint32_t txfifo_stat[1];
	uint32_t _txfifo_stat;
} BCM53324_A0_TXFIFO_STATr_t;

#define BCM53324_A0_TXFIFO_STATr_CLR(r) (r).txfifo_stat[0] = 0
#define BCM53324_A0_TXFIFO_STATr_SET(r,d) (r).txfifo_stat[0] = d
#define BCM53324_A0_TXFIFO_STATr_GET(r) (r).txfifo_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TXFIFO_STATr_TXFIFO_UNDERRUNf_GET(r) (((r).txfifo_stat[0]) & 0x1)
#define BCM53324_A0_TXFIFO_STATr_TXFIFO_UNDERRUNf_SET(r,f) (r).txfifo_stat[0]=(((r).txfifo_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_TXFIFO_STATr_TXFIFO_OVERRUNf_GET(r) ((((r).txfifo_stat[0]) >> 1) & 0x1)
#define BCM53324_A0_TXFIFO_STATr_TXFIFO_OVERRUNf_SET(r,f) (r).txfifo_stat[0]=(((r).txfifo_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access TXFIFO_STAT.
 *
 */
#define BCM53324_A0_READ_TXFIFO_STATr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TXFIFO_STATr,(r._txfifo_stat))
#define BCM53324_A0_WRITE_TXFIFO_STATr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TXFIFO_STATr,&(r._txfifo_stat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFIFO_STATr BCM53324_A0_TXFIFO_STATr
#define TXFIFO_STATr_SIZE BCM53324_A0_TXFIFO_STATr_SIZE
typedef BCM53324_A0_TXFIFO_STATr_t TXFIFO_STATr_t;
#define TXFIFO_STATr_CLR BCM53324_A0_TXFIFO_STATr_CLR
#define TXFIFO_STATr_SET BCM53324_A0_TXFIFO_STATr_SET
#define TXFIFO_STATr_GET BCM53324_A0_TXFIFO_STATr_GET
#define TXFIFO_STATr_TXFIFO_UNDERRUNf_GET BCM53324_A0_TXFIFO_STATr_TXFIFO_UNDERRUNf_GET
#define TXFIFO_STATr_TXFIFO_UNDERRUNf_SET BCM53324_A0_TXFIFO_STATr_TXFIFO_UNDERRUNf_SET
#define TXFIFO_STATr_TXFIFO_OVERRUNf_GET BCM53324_A0_TXFIFO_STATr_TXFIFO_OVERRUNf_GET
#define TXFIFO_STATr_TXFIFO_OVERRUNf_SET BCM53324_A0_TXFIFO_STATr_TXFIFO_OVERRUNf_SET
#define READ_TXFIFO_STATr BCM53324_A0_READ_TXFIFO_STATr
#define WRITE_TXFIFO_STATr BCM53324_A0_WRITE_TXFIFO_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TXFIFO_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * SWFORMAT:  TX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     352
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     DONE             Descriptor done.
 *     MODULE_HEADER    Valid only if the HG bit is set to 1 in this descriptor.
 *     BYTE_COUNT       Byte count for the transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet continues in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     HG               Specifies whether the current packet is in HiGig format. 0=Regular Ethernet format, 1=HiGig format.
 *     STAT             Update statistics counters.
 *     PAUSE            Set to indicate that packet is a pause frame.
 *     PURGE            Set to indicate that packets should be purged.
 *     ADDR             Physical memory address for the transfer.
 *
 ******************************************************************************/
#define BCM53324_A0_TX_DCB 0x00000000

#define BCM53324_A0_TX_DCB_SIZE 44

/*
 * This structure should be used to declare and program TX_DCB.
 *
 */
typedef union BCM53324_A0_TX_DCB_s {
	uint32_t v[11];
	uint32_t tx_dcb[11];
	uint32_t _tx_dcb;
} BCM53324_A0_TX_DCB_t;

#define BCM53324_A0_TX_DCB_CLR(r) CDK_MEMSET(&((r)._tx_dcb), 0, sizeof(BCM53324_A0_TX_DCB_t))
#define BCM53324_A0_TX_DCB_SET(r,i,d) (r).tx_dcb[i] = d
#define BCM53324_A0_TX_DCB_GET(r,i) (r).tx_dcb[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).tx_dcb[10]) & 0xffff)
#define BCM53324_A0_TX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).tx_dcb[10]=(((r).tx_dcb[10] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_TX_DCB_DONEf_GET(r) ((((r).tx_dcb[10]) >> 31) & 0x1)
#define BCM53324_A0_TX_DCB_DONEf_SET(r,f) (r).tx_dcb[10]=(((r).tx_dcb[10] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53324_A0_TX_DCB_MODULE_HEADERf_GET(r,a) cdk_field_be_get((r).tx_dcb,11,160,287,a)
#define BCM53324_A0_TX_DCB_MODULE_HEADERf_SET(r,a) cdk_field_be_set((r).tx_dcb,11,160,287,a)
#define BCM53324_A0_TX_DCB_MODULE_HEADERf_PTR(r) ((void*)&(r).tx_dcb[2])
#define BCM53324_A0_TX_DCB_BYTE_COUNTf_GET(r) (((r).tx_dcb[1]) & 0xffff)
#define BCM53324_A0_TX_DCB_BYTE_COUNTf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_TX_DCB_CHAINf_GET(r) ((((r).tx_dcb[1]) >> 16) & 0x1)
#define BCM53324_A0_TX_DCB_CHAINf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_TX_DCB_SGf_GET(r) ((((r).tx_dcb[1]) >> 17) & 0x1)
#define BCM53324_A0_TX_DCB_SGf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_TX_DCB_RELOADf_GET(r) ((((r).tx_dcb[1]) >> 18) & 0x1)
#define BCM53324_A0_TX_DCB_RELOADf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_TX_DCB_HGf_GET(r) ((((r).tx_dcb[1]) >> 19) & 0x1)
#define BCM53324_A0_TX_DCB_HGf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_TX_DCB_STATf_GET(r) ((((r).tx_dcb[1]) >> 20) & 0x1)
#define BCM53324_A0_TX_DCB_STATf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53324_A0_TX_DCB_PAUSEf_GET(r) ((((r).tx_dcb[1]) >> 21) & 0x1)
#define BCM53324_A0_TX_DCB_PAUSEf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53324_A0_TX_DCB_PURGEf_GET(r) ((((r).tx_dcb[1]) >> 22) & 0x1)
#define BCM53324_A0_TX_DCB_PURGEf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53324_A0_TX_DCB_ADDRf_GET(r) ((r).tx_dcb[0])
#define BCM53324_A0_TX_DCB_ADDRf_SET(r,f) (r).tx_dcb[0]=((uint32_t)f)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_DCB BCM53324_A0_TX_DCB
#define TX_DCB_SIZE BCM53324_A0_TX_DCB_SIZE
typedef BCM53324_A0_TX_DCB_t TX_DCB_t;
#define TX_DCB_CLR BCM53324_A0_TX_DCB_CLR
#define TX_DCB_SET BCM53324_A0_TX_DCB_SET
#define TX_DCB_GET BCM53324_A0_TX_DCB_GET
#define TX_DCB_BYTES_TRANSFERREDf_GET BCM53324_A0_TX_DCB_BYTES_TRANSFERREDf_GET
#define TX_DCB_BYTES_TRANSFERREDf_SET BCM53324_A0_TX_DCB_BYTES_TRANSFERREDf_SET
#define TX_DCB_DONEf_GET BCM53324_A0_TX_DCB_DONEf_GET
#define TX_DCB_DONEf_SET BCM53324_A0_TX_DCB_DONEf_SET
#define TX_DCB_MODULE_HEADERf_GET BCM53324_A0_TX_DCB_MODULE_HEADERf_GET
#define TX_DCB_MODULE_HEADERf_SET BCM53324_A0_TX_DCB_MODULE_HEADERf_SET
#define TX_DCB_MODULE_HEADERf_PTR BCM53324_A0_TX_DCB_MODULE_HEADERf_PTR
#define TX_DCB_BYTE_COUNTf_GET BCM53324_A0_TX_DCB_BYTE_COUNTf_GET
#define TX_DCB_BYTE_COUNTf_SET BCM53324_A0_TX_DCB_BYTE_COUNTf_SET
#define TX_DCB_CHAINf_GET BCM53324_A0_TX_DCB_CHAINf_GET
#define TX_DCB_CHAINf_SET BCM53324_A0_TX_DCB_CHAINf_SET
#define TX_DCB_SGf_GET BCM53324_A0_TX_DCB_SGf_GET
#define TX_DCB_SGf_SET BCM53324_A0_TX_DCB_SGf_SET
#define TX_DCB_RELOADf_GET BCM53324_A0_TX_DCB_RELOADf_GET
#define TX_DCB_RELOADf_SET BCM53324_A0_TX_DCB_RELOADf_SET
#define TX_DCB_HGf_GET BCM53324_A0_TX_DCB_HGf_GET
#define TX_DCB_HGf_SET BCM53324_A0_TX_DCB_HGf_SET
#define TX_DCB_STATf_GET BCM53324_A0_TX_DCB_STATf_GET
#define TX_DCB_STATf_SET BCM53324_A0_TX_DCB_STATf_SET
#define TX_DCB_PAUSEf_GET BCM53324_A0_TX_DCB_PAUSEf_GET
#define TX_DCB_PAUSEf_SET BCM53324_A0_TX_DCB_PAUSEf_SET
#define TX_DCB_PURGEf_GET BCM53324_A0_TX_DCB_PURGEf_GET
#define TX_DCB_PURGEf_SET BCM53324_A0_TX_DCB_PURGEf_SET
#define TX_DCB_ADDRf_GET BCM53324_A0_TX_DCB_ADDRf_GET
#define TX_DCB_ADDRf_SET BCM53324_A0_TX_DCB_ADDRf_SET
#define READ_TX_DCB BCM53324_A0_READ_TX_DCB
#define WRITE_TX_DCB BCM53324_A0_WRITE_TX_DCB

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TX_DCB'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TX_EEE_LPI_DURATION_COUNTER
 * BLOCKS:   GPORT0
 * DESC:     TX EEE LPI Duration Counter.
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr 0x0000003f

#define BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program TX_EEE_LPI_DURATION_COUNTER.
 *
 */
typedef union BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_s {
	uint32_t v[1];
	uint32_t tx_eee_lpi_duration_counter[1];
	uint32_t _tx_eee_lpi_duration_counter;
} BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_t;

#define BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_CLR(r) (r).tx_eee_lpi_duration_counter[0] = 0
#define BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_SET(r,d) (r).tx_eee_lpi_duration_counter[0] = d
#define BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_GET(r) (r).tx_eee_lpi_duration_counter[0]


/*
 * These macros can be used to access TX_EEE_LPI_DURATION_COUNTER.
 *
 */
#define BCM53324_A0_READ_TX_EEE_LPI_DURATION_COUNTERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr,(r._tx_eee_lpi_duration_counter))
#define BCM53324_A0_WRITE_TX_EEE_LPI_DURATION_COUNTERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr,&(r._tx_eee_lpi_duration_counter))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_EEE_LPI_DURATION_COUNTERr BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr
#define TX_EEE_LPI_DURATION_COUNTERr_SIZE BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_SIZE
typedef BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_t TX_EEE_LPI_DURATION_COUNTERr_t;
#define TX_EEE_LPI_DURATION_COUNTERr_CLR BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_CLR
#define TX_EEE_LPI_DURATION_COUNTERr_SET BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_SET
#define TX_EEE_LPI_DURATION_COUNTERr_GET BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr_GET
#define READ_TX_EEE_LPI_DURATION_COUNTERr BCM53324_A0_READ_TX_EEE_LPI_DURATION_COUNTERr
#define WRITE_TX_EEE_LPI_DURATION_COUNTERr BCM53324_A0_WRITE_TX_EEE_LPI_DURATION_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TX_EEE_LPI_DURATION_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TX_EEE_LPI_EVENT_COUNTER
 * BLOCKS:   GPORT0
 * DESC:     TX EEE LPI Event Counter.
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr 0x0000003e

#define BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_SIZE 4

/*
 * This structure should be used to declare and program TX_EEE_LPI_EVENT_COUNTER.
 *
 */
typedef union BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_s {
	uint32_t v[1];
	uint32_t tx_eee_lpi_event_counter[1];
	uint32_t _tx_eee_lpi_event_counter;
} BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_t;

#define BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_CLR(r) (r).tx_eee_lpi_event_counter[0] = 0
#define BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_SET(r,d) (r).tx_eee_lpi_event_counter[0] = d
#define BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_GET(r) (r).tx_eee_lpi_event_counter[0]


/*
 * These macros can be used to access TX_EEE_LPI_EVENT_COUNTER.
 *
 */
#define BCM53324_A0_READ_TX_EEE_LPI_EVENT_COUNTERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr,(r._tx_eee_lpi_event_counter))
#define BCM53324_A0_WRITE_TX_EEE_LPI_EVENT_COUNTERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr,&(r._tx_eee_lpi_event_counter))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_EEE_LPI_EVENT_COUNTERr BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr
#define TX_EEE_LPI_EVENT_COUNTERr_SIZE BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_SIZE
typedef BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_t TX_EEE_LPI_EVENT_COUNTERr_t;
#define TX_EEE_LPI_EVENT_COUNTERr_CLR BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_CLR
#define TX_EEE_LPI_EVENT_COUNTERr_SET BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_SET
#define TX_EEE_LPI_EVENT_COUNTERr_GET BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr_GET
#define READ_TX_EEE_LPI_EVENT_COUNTERr BCM53324_A0_READ_TX_EEE_LPI_EVENT_COUNTERr
#define WRITE_TX_EEE_LPI_EVENT_COUNTERr BCM53324_A0_WRITE_TX_EEE_LPI_EVENT_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TX_EEE_LPI_EVENT_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TX_IPG_LENGTH
 * BLOCKS:   GPORT0
 * DESC:     Programmable Inter-Packet-Gap (IPG).
 * SIZE:     32
 * FIELDS:
 *     TX_IPG_LENGTH    Set the Transmit minimum IPG from 8 to 64 Byte-times. If a value below 8 or above 64 isprogrammed, the minimum IPG is set to 12 byte-times.Ignored when Rate Limiting with programmable IPG is eanbled (Register RT_IPG_ENA) set to '1'.
 *
 ******************************************************************************/
#define BCM53324_A0_TX_IPG_LENGTHr 0x00000117

#define BCM53324_A0_TX_IPG_LENGTHr_SIZE 4

/*
 * This structure should be used to declare and program TX_IPG_LENGTH.
 *
 */
typedef union BCM53324_A0_TX_IPG_LENGTHr_s {
	uint32_t v[1];
	uint32_t tx_ipg_length[1];
	uint32_t _tx_ipg_length;
} BCM53324_A0_TX_IPG_LENGTHr_t;

#define BCM53324_A0_TX_IPG_LENGTHr_CLR(r) (r).tx_ipg_length[0] = 0
#define BCM53324_A0_TX_IPG_LENGTHr_SET(r,d) (r).tx_ipg_length[0] = d
#define BCM53324_A0_TX_IPG_LENGTHr_GET(r) (r).tx_ipg_length[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TX_IPG_LENGTHr_TX_IPG_LENGTHf_GET(r) (((r).tx_ipg_length[0]) & 0x7f)
#define BCM53324_A0_TX_IPG_LENGTHr_TX_IPG_LENGTHf_SET(r,f) (r).tx_ipg_length[0]=(((r).tx_ipg_length[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access TX_IPG_LENGTH.
 *
 */
#define BCM53324_A0_READ_TX_IPG_LENGTHr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TX_IPG_LENGTHr,(r._tx_ipg_length))
#define BCM53324_A0_WRITE_TX_IPG_LENGTHr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TX_IPG_LENGTHr,&(r._tx_ipg_length))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_IPG_LENGTHr BCM53324_A0_TX_IPG_LENGTHr
#define TX_IPG_LENGTHr_SIZE BCM53324_A0_TX_IPG_LENGTHr_SIZE
typedef BCM53324_A0_TX_IPG_LENGTHr_t TX_IPG_LENGTHr_t;
#define TX_IPG_LENGTHr_CLR BCM53324_A0_TX_IPG_LENGTHr_CLR
#define TX_IPG_LENGTHr_SET BCM53324_A0_TX_IPG_LENGTHr_SET
#define TX_IPG_LENGTHr_GET BCM53324_A0_TX_IPG_LENGTHr_GET
#define TX_IPG_LENGTHr_TX_IPG_LENGTHf_GET BCM53324_A0_TX_IPG_LENGTHr_TX_IPG_LENGTHf_GET
#define TX_IPG_LENGTHr_TX_IPG_LENGTHf_SET BCM53324_A0_TX_IPG_LENGTHr_TX_IPG_LENGTHf_SET
#define READ_TX_IPG_LENGTHr BCM53324_A0_READ_TX_IPG_LENGTHr
#define WRITE_TX_IPG_LENGTHr BCM53324_A0_WRITE_TX_IPG_LENGTHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TX_IPG_LENGTHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  TX_TS_DATA
 * BLOCKS:   GPORT0
 * DESC:     Transmit Timestamp data
 * SIZE:     32
 * FIELDS:
 *     TX_TS_DATA       Every read of this register will fetch out one timestamp value from the transmit FIFO.(One timestamp value per one read command on the sbus).
 *
 ******************************************************************************/
#define BCM53324_A0_TX_TS_DATAr 0x000001c7

#define BCM53324_A0_TX_TS_DATAr_SIZE 4

/*
 * This structure should be used to declare and program TX_TS_DATA.
 *
 */
typedef union BCM53324_A0_TX_TS_DATAr_s {
	uint32_t v[1];
	uint32_t tx_ts_data[1];
	uint32_t _tx_ts_data;
} BCM53324_A0_TX_TS_DATAr_t;

#define BCM53324_A0_TX_TS_DATAr_CLR(r) (r).tx_ts_data[0] = 0
#define BCM53324_A0_TX_TS_DATAr_SET(r,d) (r).tx_ts_data[0] = d
#define BCM53324_A0_TX_TS_DATAr_GET(r) (r).tx_ts_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_TX_TS_DATAr_TX_TS_DATAf_GET(r) ((r).tx_ts_data[0])
#define BCM53324_A0_TX_TS_DATAr_TX_TS_DATAf_SET(r,f) (r).tx_ts_data[0]=((uint32_t)f)

/*
 * These macros can be used to access TX_TS_DATA.
 *
 */
#define BCM53324_A0_READ_TX_TS_DATAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_TX_TS_DATAr,(r._tx_ts_data))
#define BCM53324_A0_WRITE_TX_TS_DATAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_TX_TS_DATAr,&(r._tx_ts_data))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_TS_DATAr BCM53324_A0_TX_TS_DATAr
#define TX_TS_DATAr_SIZE BCM53324_A0_TX_TS_DATAr_SIZE
typedef BCM53324_A0_TX_TS_DATAr_t TX_TS_DATAr_t;
#define TX_TS_DATAr_CLR BCM53324_A0_TX_TS_DATAr_CLR
#define TX_TS_DATAr_SET BCM53324_A0_TX_TS_DATAr_SET
#define TX_TS_DATAr_GET BCM53324_A0_TX_TS_DATAr_GET
#define TX_TS_DATAr_TX_TS_DATAf_GET BCM53324_A0_TX_TS_DATAr_TX_TS_DATAf_GET
#define TX_TS_DATAr_TX_TS_DATAf_SET BCM53324_A0_TX_TS_DATAr_TX_TS_DATAf_SET
#define READ_TX_TS_DATAr BCM53324_A0_READ_TX_TS_DATAr
#define WRITE_TX_TS_DATAr BCM53324_A0_WRITE_TX_TS_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_TX_TS_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UDF_ETHERTYPE_MATCH
 * BLOCKS:   IPIPE
 * DESC:     UDF Ethertype Match Register (used to select unique UDF offsets for different EtherTypes
 * SIZE:     32
 * FIELDS:
 *     ETHERTYPE        Programmable ethertype to match for UDF ethertype match
 *     RESERVED0        Unused bit
 *     L2_PACKET_FORMAT L2 packet format to match for UDF ethertype match
 *     ENABLE           Enables UDF ethertype match
 *
 ******************************************************************************/
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr 0x02780000

#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_SIZE 4

/*
 * This structure should be used to declare and program UDF_ETHERTYPE_MATCH.
 *
 */
typedef union BCM53324_A0_UDF_ETHERTYPE_MATCHr_s {
	uint32_t v[1];
	uint32_t udf_ethertype_match[1];
	uint32_t _udf_ethertype_match;
} BCM53324_A0_UDF_ETHERTYPE_MATCHr_t;

#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_CLR(r) (r).udf_ethertype_match[0] = 0
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_SET(r,d) (r).udf_ethertype_match[0] = d
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_GET(r) (r).udf_ethertype_match[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET(r) (((r).udf_ethertype_match[0]) & 0xffff)
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_GET(r) ((((r).udf_ethertype_match[0]) >> 16) & 0x1)
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET(r) ((((r).udf_ethertype_match[0]) >> 17) & 0x3)
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_GET(r) ((((r).udf_ethertype_match[0]) >> 19) & 0x1)
#define BCM53324_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access UDF_ETHERTYPE_MATCH.
 *
 */
#define BCM53324_A0_READ_UDF_ETHERTYPE_MATCHr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_UDF_ETHERTYPE_MATCHr+(i),(r._udf_ethertype_match))
#define BCM53324_A0_WRITE_UDF_ETHERTYPE_MATCHr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_UDF_ETHERTYPE_MATCHr+(i),&(r._udf_ethertype_match))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_ETHERTYPE_MATCHr BCM53324_A0_UDF_ETHERTYPE_MATCHr
#define UDF_ETHERTYPE_MATCHr_SIZE BCM53324_A0_UDF_ETHERTYPE_MATCHr_SIZE
typedef BCM53324_A0_UDF_ETHERTYPE_MATCHr_t UDF_ETHERTYPE_MATCHr_t;
#define UDF_ETHERTYPE_MATCHr_CLR BCM53324_A0_UDF_ETHERTYPE_MATCHr_CLR
#define UDF_ETHERTYPE_MATCHr_SET BCM53324_A0_UDF_ETHERTYPE_MATCHr_SET
#define UDF_ETHERTYPE_MATCHr_GET BCM53324_A0_UDF_ETHERTYPE_MATCHr_GET
#define UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET BCM53324_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET
#define UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET BCM53324_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET
#define UDF_ETHERTYPE_MATCHr_RESERVED0f_GET BCM53324_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_GET
#define UDF_ETHERTYPE_MATCHr_RESERVED0f_SET BCM53324_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_SET
#define UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET BCM53324_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET
#define UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET BCM53324_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET
#define UDF_ETHERTYPE_MATCHr_ENABLEf_GET BCM53324_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_GET
#define UDF_ETHERTYPE_MATCHr_ENABLEf_SET BCM53324_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_SET
#define READ_UDF_ETHERTYPE_MATCHr BCM53324_A0_READ_UDF_ETHERTYPE_MATCHr
#define WRITE_UDF_ETHERTYPE_MATCHr BCM53324_A0_WRITE_UDF_ETHERTYPE_MATCHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UDF_ETHERTYPE_MATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UDF_IPPROTO_MATCH
 * BLOCKS:   IPIPE
 * DESC:     UDF IP Protocol Matching Register (select unique UDF offsets for different IP protocols)
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL         IP protocol to match
 *     IPV6ENABLE       Enable this UDF matching mechanism for IPv6
 *     IPV4ENABLE       Enable this UDF matching mechanism for IPv4
 *
 ******************************************************************************/
#define BCM53324_A0_UDF_IPPROTO_MATCHr 0x02780008

#define BCM53324_A0_UDF_IPPROTO_MATCHr_SIZE 4

/*
 * This structure should be used to declare and program UDF_IPPROTO_MATCH.
 *
 */
typedef union BCM53324_A0_UDF_IPPROTO_MATCHr_s {
	uint32_t v[1];
	uint32_t udf_ipproto_match[1];
	uint32_t _udf_ipproto_match;
} BCM53324_A0_UDF_IPPROTO_MATCHr_t;

#define BCM53324_A0_UDF_IPPROTO_MATCHr_CLR(r) (r).udf_ipproto_match[0] = 0
#define BCM53324_A0_UDF_IPPROTO_MATCHr_SET(r,d) (r).udf_ipproto_match[0] = d
#define BCM53324_A0_UDF_IPPROTO_MATCHr_GET(r) (r).udf_ipproto_match[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_GET(r) (((r).udf_ipproto_match[0]) & 0xff)
#define BCM53324_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET(r) ((((r).udf_ipproto_match[0]) >> 8) & 0x1)
#define BCM53324_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET(r) ((((r).udf_ipproto_match[0]) >> 9) & 0x1)
#define BCM53324_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access UDF_IPPROTO_MATCH.
 *
 */
#define BCM53324_A0_READ_UDF_IPPROTO_MATCHr(u,i,r) cdk_xgs_reg32_read(u,BCM53324_A0_UDF_IPPROTO_MATCHr+(i),(r._udf_ipproto_match))
#define BCM53324_A0_WRITE_UDF_IPPROTO_MATCHr(u,i,r) cdk_xgs_reg32_write(u,BCM53324_A0_UDF_IPPROTO_MATCHr+(i),&(r._udf_ipproto_match))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_IPPROTO_MATCHr BCM53324_A0_UDF_IPPROTO_MATCHr
#define UDF_IPPROTO_MATCHr_SIZE BCM53324_A0_UDF_IPPROTO_MATCHr_SIZE
typedef BCM53324_A0_UDF_IPPROTO_MATCHr_t UDF_IPPROTO_MATCHr_t;
#define UDF_IPPROTO_MATCHr_CLR BCM53324_A0_UDF_IPPROTO_MATCHr_CLR
#define UDF_IPPROTO_MATCHr_SET BCM53324_A0_UDF_IPPROTO_MATCHr_SET
#define UDF_IPPROTO_MATCHr_GET BCM53324_A0_UDF_IPPROTO_MATCHr_GET
#define UDF_IPPROTO_MATCHr_PROTOCOLf_GET BCM53324_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_GET
#define UDF_IPPROTO_MATCHr_PROTOCOLf_SET BCM53324_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_SET
#define UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET BCM53324_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET
#define UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET BCM53324_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET
#define UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET BCM53324_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET
#define UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET BCM53324_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET
#define READ_UDF_IPPROTO_MATCHr BCM53324_A0_READ_UDF_IPPROTO_MATCHr
#define WRITE_UDF_IPPROTO_MATCHr BCM53324_A0_WRITE_UDF_IPPROTO_MATCHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UDF_IPPROTO_MATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UMAC_EEE_CTRL
 * BLOCKS:   GPORT0
 * DESC:     control configs for EEE feature
 * SIZE:     32
 * FIELDS:
 *     ECO_EEE_LINKUP_CONFIG_EN If set, enables link up LPI delay ECO. Defaults to enabled. Write 0 to disable the ECO.
 *     EEE_EN           If set, the TX LPI policy control engine is enabled and the MAC inserts LPI_idle codes if the link is idle. The rx_lpi_detect assertion is independent of this configuration. Reset default depends on EEE_en_strap input, which if tied to 1, defaults to enabled, otherwise if tied to 0, defaults to disabled.
 *     RX_FIFO_CHECK    If enabled, lpi_rx_detect is set whenever the LPI_IDLES are being received on the RX line and Unimac Rx FIFO is empty.By default, lpi_rx_detect is set only when whenever the LPI_IDLES are being received on the RX line.
 *     EEE_TXCLK_DIS    If enabled, UNIMAC will shut down TXCLK to PHY, when in LPI state.
 *     DIS_EEE_10M      When this bit is set and link is established at 10Mbps, LPI is not supported (saving is achieved by reduced PHYs output swing). UNIMAC ignores EEE feature on both Tx & Rx in 10Mbps.When cleared, Unimac doesnt diffrentiate between speeds for EEE feature.
 *     LP_IDLE_PREDICTION_MODE When set to 1, enables LP_IDLE Prediction. When set to 0, disables LP_IDLE Prediction.  
 *
 ******************************************************************************/
#define BCM53324_A0_UMAC_EEE_CTRLr 0x00000119

#define BCM53324_A0_UMAC_EEE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program UMAC_EEE_CTRL.
 *
 */
typedef union BCM53324_A0_UMAC_EEE_CTRLr_s {
	uint32_t v[1];
	uint32_t umac_eee_ctrl[1];
	uint32_t _umac_eee_ctrl;
} BCM53324_A0_UMAC_EEE_CTRLr_t;

#define BCM53324_A0_UMAC_EEE_CTRLr_CLR(r) (r).umac_eee_ctrl[0] = 0
#define BCM53324_A0_UMAC_EEE_CTRLr_SET(r,d) (r).umac_eee_ctrl[0] = d
#define BCM53324_A0_UMAC_EEE_CTRLr_GET(r) (r).umac_eee_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UMAC_EEE_CTRLr_ECO_EEE_LINKUP_CONFIG_ENf_GET(r) ((((r).umac_eee_ctrl[0]) >> 2) & 0x1)
#define BCM53324_A0_UMAC_EEE_CTRLr_ECO_EEE_LINKUP_CONFIG_ENf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_UMAC_EEE_CTRLr_EEE_ENf_GET(r) ((((r).umac_eee_ctrl[0]) >> 3) & 0x1)
#define BCM53324_A0_UMAC_EEE_CTRLr_EEE_ENf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53324_A0_UMAC_EEE_CTRLr_RX_FIFO_CHECKf_GET(r) ((((r).umac_eee_ctrl[0]) >> 4) & 0x1)
#define BCM53324_A0_UMAC_EEE_CTRLr_RX_FIFO_CHECKf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_UMAC_EEE_CTRLr_EEE_TXCLK_DISf_GET(r) ((((r).umac_eee_ctrl[0]) >> 5) & 0x1)
#define BCM53324_A0_UMAC_EEE_CTRLr_EEE_TXCLK_DISf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_UMAC_EEE_CTRLr_DIS_EEE_10Mf_GET(r) ((((r).umac_eee_ctrl[0]) >> 6) & 0x1)
#define BCM53324_A0_UMAC_EEE_CTRLr_DIS_EEE_10Mf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_GET(r) ((((r).umac_eee_ctrl[0]) >> 7) & 0x1)
#define BCM53324_A0_UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_SET(r,f) (r).umac_eee_ctrl[0]=(((r).umac_eee_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access UMAC_EEE_CTRL.
 *
 */
#define BCM53324_A0_READ_UMAC_EEE_CTRLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_UMAC_EEE_CTRLr,(r._umac_eee_ctrl))
#define BCM53324_A0_WRITE_UMAC_EEE_CTRLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_UMAC_EEE_CTRLr,&(r._umac_eee_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UMAC_EEE_CTRLr BCM53324_A0_UMAC_EEE_CTRLr
#define UMAC_EEE_CTRLr_SIZE BCM53324_A0_UMAC_EEE_CTRLr_SIZE
typedef BCM53324_A0_UMAC_EEE_CTRLr_t UMAC_EEE_CTRLr_t;
#define UMAC_EEE_CTRLr_CLR BCM53324_A0_UMAC_EEE_CTRLr_CLR
#define UMAC_EEE_CTRLr_SET BCM53324_A0_UMAC_EEE_CTRLr_SET
#define UMAC_EEE_CTRLr_GET BCM53324_A0_UMAC_EEE_CTRLr_GET
#define UMAC_EEE_CTRLr_ECO_EEE_LINKUP_CONFIG_ENf_GET BCM53324_A0_UMAC_EEE_CTRLr_ECO_EEE_LINKUP_CONFIG_ENf_GET
#define UMAC_EEE_CTRLr_ECO_EEE_LINKUP_CONFIG_ENf_SET BCM53324_A0_UMAC_EEE_CTRLr_ECO_EEE_LINKUP_CONFIG_ENf_SET
#define UMAC_EEE_CTRLr_EEE_ENf_GET BCM53324_A0_UMAC_EEE_CTRLr_EEE_ENf_GET
#define UMAC_EEE_CTRLr_EEE_ENf_SET BCM53324_A0_UMAC_EEE_CTRLr_EEE_ENf_SET
#define UMAC_EEE_CTRLr_RX_FIFO_CHECKf_GET BCM53324_A0_UMAC_EEE_CTRLr_RX_FIFO_CHECKf_GET
#define UMAC_EEE_CTRLr_RX_FIFO_CHECKf_SET BCM53324_A0_UMAC_EEE_CTRLr_RX_FIFO_CHECKf_SET
#define UMAC_EEE_CTRLr_EEE_TXCLK_DISf_GET BCM53324_A0_UMAC_EEE_CTRLr_EEE_TXCLK_DISf_GET
#define UMAC_EEE_CTRLr_EEE_TXCLK_DISf_SET BCM53324_A0_UMAC_EEE_CTRLr_EEE_TXCLK_DISf_SET
#define UMAC_EEE_CTRLr_DIS_EEE_10Mf_GET BCM53324_A0_UMAC_EEE_CTRLr_DIS_EEE_10Mf_GET
#define UMAC_EEE_CTRLr_DIS_EEE_10Mf_SET BCM53324_A0_UMAC_EEE_CTRLr_DIS_EEE_10Mf_SET
#define UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_GET BCM53324_A0_UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_GET
#define UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_SET BCM53324_A0_UMAC_EEE_CTRLr_LP_IDLE_PREDICTION_MODEf_SET
#define READ_UMAC_EEE_CTRLr BCM53324_A0_READ_UMAC_EEE_CTRLr
#define WRITE_UMAC_EEE_CTRLr BCM53324_A0_WRITE_UMAC_EEE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UMAC_EEE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UMAC_EEE_REF_COUNT
 * BLOCKS:   GPORT0
 * DESC:     clock divider for 1 us quanta count in EEE 
 * SIZE:     32
 * FIELDS:
 *     EEE_REF_COUNT    This field controls clock divider used to generate ~1us reference pulses used by EEE timers. It specifies integer number of timer clock cycles contained within 1us.We may consider having 0.5us reference, as timeout values in 802.3az/D1.3 are not always integer number of 1us.
 *
 ******************************************************************************/
#define BCM53324_A0_UMAC_EEE_REF_COUNTr 0x0000011c

#define BCM53324_A0_UMAC_EEE_REF_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program UMAC_EEE_REF_COUNT.
 *
 */
typedef union BCM53324_A0_UMAC_EEE_REF_COUNTr_s {
	uint32_t v[1];
	uint32_t umac_eee_ref_count[1];
	uint32_t _umac_eee_ref_count;
} BCM53324_A0_UMAC_EEE_REF_COUNTr_t;

#define BCM53324_A0_UMAC_EEE_REF_COUNTr_CLR(r) (r).umac_eee_ref_count[0] = 0
#define BCM53324_A0_UMAC_EEE_REF_COUNTr_SET(r,d) (r).umac_eee_ref_count[0] = d
#define BCM53324_A0_UMAC_EEE_REF_COUNTr_GET(r) (r).umac_eee_ref_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_GET(r) (((r).umac_eee_ref_count[0]) & 0xffff)
#define BCM53324_A0_UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_SET(r,f) (r).umac_eee_ref_count[0]=(((r).umac_eee_ref_count[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access UMAC_EEE_REF_COUNT.
 *
 */
#define BCM53324_A0_READ_UMAC_EEE_REF_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_UMAC_EEE_REF_COUNTr,(r._umac_eee_ref_count))
#define BCM53324_A0_WRITE_UMAC_EEE_REF_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_UMAC_EEE_REF_COUNTr,&(r._umac_eee_ref_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UMAC_EEE_REF_COUNTr BCM53324_A0_UMAC_EEE_REF_COUNTr
#define UMAC_EEE_REF_COUNTr_SIZE BCM53324_A0_UMAC_EEE_REF_COUNTr_SIZE
typedef BCM53324_A0_UMAC_EEE_REF_COUNTr_t UMAC_EEE_REF_COUNTr_t;
#define UMAC_EEE_REF_COUNTr_CLR BCM53324_A0_UMAC_EEE_REF_COUNTr_CLR
#define UMAC_EEE_REF_COUNTr_SET BCM53324_A0_UMAC_EEE_REF_COUNTr_SET
#define UMAC_EEE_REF_COUNTr_GET BCM53324_A0_UMAC_EEE_REF_COUNTr_GET
#define UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_GET BCM53324_A0_UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_GET
#define UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_SET BCM53324_A0_UMAC_EEE_REF_COUNTr_EEE_REF_COUNTf_SET
#define READ_UMAC_EEE_REF_COUNTr BCM53324_A0_READ_UMAC_EEE_REF_COUNTr
#define WRITE_UMAC_EEE_REF_COUNTr BCM53324_A0_WRITE_UMAC_EEE_REF_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UMAC_EEE_REF_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UMAC_SYMMETRIC_IDLE_THRESHOLD
 * BLOCKS:   GPORT0
 * DESC:     RX IDLE threshold for LPI prediction
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD_VALUE  If LPI_Prediction is enabled then this register defines the number of IDLEs to be received by the UniMAC before allowing LP_IDLE to be sent to Link Partner.
 *
 ******************************************************************************/
#define BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr 0x0000011f

#define BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program UMAC_SYMMETRIC_IDLE_THRESHOLD.
 *
 */
typedef union BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t umac_symmetric_idle_threshold[1];
	uint32_t _umac_symmetric_idle_threshold;
} BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_t;

#define BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_CLR(r) (r).umac_symmetric_idle_threshold[0] = 0
#define BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_SET(r,d) (r).umac_symmetric_idle_threshold[0] = d
#define BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_GET(r) (r).umac_symmetric_idle_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_THRESHOLD_VALUEf_GET(r) (((r).umac_symmetric_idle_threshold[0]) & 0xffff)
#define BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_THRESHOLD_VALUEf_SET(r,f) (r).umac_symmetric_idle_threshold[0]=(((r).umac_symmetric_idle_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access UMAC_SYMMETRIC_IDLE_THRESHOLD.
 *
 */
#define BCM53324_A0_READ_UMAC_SYMMETRIC_IDLE_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr,(r._umac_symmetric_idle_threshold))
#define BCM53324_A0_WRITE_UMAC_SYMMETRIC_IDLE_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr,&(r._umac_symmetric_idle_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UMAC_SYMMETRIC_IDLE_THRESHOLDr BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr
#define UMAC_SYMMETRIC_IDLE_THRESHOLDr_SIZE BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_SIZE
typedef BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_t UMAC_SYMMETRIC_IDLE_THRESHOLDr_t;
#define UMAC_SYMMETRIC_IDLE_THRESHOLDr_CLR BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_CLR
#define UMAC_SYMMETRIC_IDLE_THRESHOLDr_SET BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_SET
#define UMAC_SYMMETRIC_IDLE_THRESHOLDr_GET BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_GET
#define UMAC_SYMMETRIC_IDLE_THRESHOLDr_THRESHOLD_VALUEf_GET BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_THRESHOLD_VALUEf_GET
#define UMAC_SYMMETRIC_IDLE_THRESHOLDr_THRESHOLD_VALUEf_SET BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr_THRESHOLD_VALUEf_SET
#define READ_UMAC_SYMMETRIC_IDLE_THRESHOLDr BCM53324_A0_READ_UMAC_SYMMETRIC_IDLE_THRESHOLDr
#define WRITE_UMAC_SYMMETRIC_IDLE_THRESHOLDr BCM53324_A0_WRITE_UMAC_SYMMETRIC_IDLE_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UMAC_SYMMETRIC_IDLE_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UMAN_EP_FLSH_WAIT_CNTR
 * BLOCKS:   GPORT0
 * DESC:     Holds the programmable, EP drain out time value.
 * SIZE:     32
 * FIELDS:
 *     UMAN_EP_FLSH_WAIT_CNTR Used to wait the flush stm of per port stm for the ep to drain out in case of flush. The reset default is decimal 512.
 *
 ******************************************************************************/
#define BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr 0x00080034

#define BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_SIZE 4

/*
 * This structure should be used to declare and program UMAN_EP_FLSH_WAIT_CNTR.
 *
 */
typedef union BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_s {
	uint32_t v[1];
	uint32_t uman_ep_flsh_wait_cntr[1];
	uint32_t _uman_ep_flsh_wait_cntr;
} BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_t;

#define BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_CLR(r) (r).uman_ep_flsh_wait_cntr[0] = 0
#define BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_SET(r,d) (r).uman_ep_flsh_wait_cntr[0] = d
#define BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_GET(r) (r).uman_ep_flsh_wait_cntr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_UMAN_EP_FLSH_WAIT_CNTRf_GET(r) (((r).uman_ep_flsh_wait_cntr[0]) & 0xfff)
#define BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_UMAN_EP_FLSH_WAIT_CNTRf_SET(r,f) (r).uman_ep_flsh_wait_cntr[0]=(((r).uman_ep_flsh_wait_cntr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access UMAN_EP_FLSH_WAIT_CNTR.
 *
 */
#define BCM53324_A0_READ_UMAN_EP_FLSH_WAIT_CNTRr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr,(r._uman_ep_flsh_wait_cntr))
#define BCM53324_A0_WRITE_UMAN_EP_FLSH_WAIT_CNTRr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr,&(r._uman_ep_flsh_wait_cntr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UMAN_EP_FLSH_WAIT_CNTRr BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr
#define UMAN_EP_FLSH_WAIT_CNTRr_SIZE BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_SIZE
typedef BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_t UMAN_EP_FLSH_WAIT_CNTRr_t;
#define UMAN_EP_FLSH_WAIT_CNTRr_CLR BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_CLR
#define UMAN_EP_FLSH_WAIT_CNTRr_SET BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_SET
#define UMAN_EP_FLSH_WAIT_CNTRr_GET BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_GET
#define UMAN_EP_FLSH_WAIT_CNTRr_UMAN_EP_FLSH_WAIT_CNTRf_GET BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_UMAN_EP_FLSH_WAIT_CNTRf_GET
#define UMAN_EP_FLSH_WAIT_CNTRr_UMAN_EP_FLSH_WAIT_CNTRf_SET BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr_UMAN_EP_FLSH_WAIT_CNTRf_SET
#define READ_UMAN_EP_FLSH_WAIT_CNTRr BCM53324_A0_READ_UMAN_EP_FLSH_WAIT_CNTRr
#define WRITE_UMAN_EP_FLSH_WAIT_CNTRr BCM53324_A0_WRITE_UMAN_EP_FLSH_WAIT_CNTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UMAN_EP_FLSH_WAIT_CNTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UMAN_IP_FLSH_WAIT_CNTR
 * BLOCKS:   GPORT0
 * DESC:     Holds the programmable, IP drain out time value.
 * SIZE:     32
 * FIELDS:
 *     UMAN_IP_FLSH_WAIT_CNTR Used to wait the flush stm of per port stm for the ip to drain out in case of flush. The reset default is decimal 128.
 *
 ******************************************************************************/
#define BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr 0x00080035

#define BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_SIZE 4

/*
 * This structure should be used to declare and program UMAN_IP_FLSH_WAIT_CNTR.
 *
 */
typedef union BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_s {
	uint32_t v[1];
	uint32_t uman_ip_flsh_wait_cntr[1];
	uint32_t _uman_ip_flsh_wait_cntr;
} BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_t;

#define BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_CLR(r) (r).uman_ip_flsh_wait_cntr[0] = 0
#define BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_SET(r,d) (r).uman_ip_flsh_wait_cntr[0] = d
#define BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_GET(r) (r).uman_ip_flsh_wait_cntr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_UMAN_IP_FLSH_WAIT_CNTRf_GET(r) (((r).uman_ip_flsh_wait_cntr[0]) & 0xfff)
#define BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_UMAN_IP_FLSH_WAIT_CNTRf_SET(r,f) (r).uman_ip_flsh_wait_cntr[0]=(((r).uman_ip_flsh_wait_cntr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access UMAN_IP_FLSH_WAIT_CNTR.
 *
 */
#define BCM53324_A0_READ_UMAN_IP_FLSH_WAIT_CNTRr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr,(r._uman_ip_flsh_wait_cntr))
#define BCM53324_A0_WRITE_UMAN_IP_FLSH_WAIT_CNTRr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr,&(r._uman_ip_flsh_wait_cntr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UMAN_IP_FLSH_WAIT_CNTRr BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr
#define UMAN_IP_FLSH_WAIT_CNTRr_SIZE BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_SIZE
typedef BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_t UMAN_IP_FLSH_WAIT_CNTRr_t;
#define UMAN_IP_FLSH_WAIT_CNTRr_CLR BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_CLR
#define UMAN_IP_FLSH_WAIT_CNTRr_SET BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_SET
#define UMAN_IP_FLSH_WAIT_CNTRr_GET BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_GET
#define UMAN_IP_FLSH_WAIT_CNTRr_UMAN_IP_FLSH_WAIT_CNTRf_GET BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_UMAN_IP_FLSH_WAIT_CNTRf_GET
#define UMAN_IP_FLSH_WAIT_CNTRr_UMAN_IP_FLSH_WAIT_CNTRf_SET BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr_UMAN_IP_FLSH_WAIT_CNTRf_SET
#define READ_UMAN_IP_FLSH_WAIT_CNTRr BCM53324_A0_READ_UMAN_IP_FLSH_WAIT_CNTRr
#define WRITE_UMAN_IP_FLSH_WAIT_CNTRr BCM53324_A0_WRITE_UMAN_IP_FLSH_WAIT_CNTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UMAN_IP_FLSH_WAIT_CNTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UMAN_LINKUP_DLY_CNTR
 * BLOCKS:   GPORT0
 * DESC:     Holds the programmable link up delay count.
 * SIZE:     32
 * FIELDS:
 *     UMAN_LINKUP_DLY_CNTR Used to program the wait counter value used by the link status capture state machine. If this is zero, Link up is not delayed or else delayed as per the count value in this register. Default value is as per the LINKUP_DLY_CNTR_STRAP input, which if high then, the register value is all one, i.e., decimal 262144. If the strap is low, then the register default value is zero.
 *
 ******************************************************************************/
#define BCM53324_A0_UMAN_LINKUP_DLY_CNTRr 0x00080033

#define BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_SIZE 4

/*
 * This structure should be used to declare and program UMAN_LINKUP_DLY_CNTR.
 *
 */
typedef union BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_s {
	uint32_t v[1];
	uint32_t uman_linkup_dly_cntr[1];
	uint32_t _uman_linkup_dly_cntr;
} BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_t;

#define BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_CLR(r) (r).uman_linkup_dly_cntr[0] = 0
#define BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_SET(r,d) (r).uman_linkup_dly_cntr[0] = d
#define BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_GET(r) (r).uman_linkup_dly_cntr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_UMAN_LINKUP_DLY_CNTRf_GET(r) (((r).uman_linkup_dly_cntr[0]) & 0x3ffff)
#define BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_UMAN_LINKUP_DLY_CNTRf_SET(r,f) (r).uman_linkup_dly_cntr[0]=(((r).uman_linkup_dly_cntr[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access UMAN_LINKUP_DLY_CNTR.
 *
 */
#define BCM53324_A0_READ_UMAN_LINKUP_DLY_CNTRr(u,r,p) cdk_xgs_reg32_blocks_read(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_UMAN_LINKUP_DLY_CNTRr,(r._uman_linkup_dly_cntr))
#define BCM53324_A0_WRITE_UMAN_LINKUP_DLY_CNTRr(u,r,p) cdk_xgs_reg32_blocks_write(u,(1 << BCM53324_A0_BLKTYPE_GPORT),p,BCM53324_A0_UMAN_LINKUP_DLY_CNTRr,&(r._uman_linkup_dly_cntr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UMAN_LINKUP_DLY_CNTRr BCM53324_A0_UMAN_LINKUP_DLY_CNTRr
#define UMAN_LINKUP_DLY_CNTRr_SIZE BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_SIZE
typedef BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_t UMAN_LINKUP_DLY_CNTRr_t;
#define UMAN_LINKUP_DLY_CNTRr_CLR BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_CLR
#define UMAN_LINKUP_DLY_CNTRr_SET BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_SET
#define UMAN_LINKUP_DLY_CNTRr_GET BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_GET
#define UMAN_LINKUP_DLY_CNTRr_UMAN_LINKUP_DLY_CNTRf_GET BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_UMAN_LINKUP_DLY_CNTRf_GET
#define UMAN_LINKUP_DLY_CNTRr_UMAN_LINKUP_DLY_CNTRf_SET BCM53324_A0_UMAN_LINKUP_DLY_CNTRr_UMAN_LINKUP_DLY_CNTRf_SET
#define READ_UMAN_LINKUP_DLY_CNTRr BCM53324_A0_READ_UMAN_LINKUP_DLY_CNTRr
#define WRITE_UMAN_LINKUP_DLY_CNTRr BCM53324_A0_WRITE_UMAN_LINKUP_DLY_CNTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UMAN_LINKUP_DLY_CNTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UNKNOWN_MCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr 0x0f700102

#define BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_MCAST_BLOCK_MASK.
 *
 */
typedef union BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t unknown_mcast_block_mask[1];
	uint32_t _unknown_mcast_block_mask;
} BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_t;

#define BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_CLR(r) (r).unknown_mcast_block_mask[0] = 0
#define BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_SET(r,d) (r).unknown_mcast_block_mask[0] = d
#define BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_GET(r) (r).unknown_mcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).unknown_mcast_block_mask[0]) & 0x1ffffff)
#define BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).unknown_mcast_block_mask[0]=(((r).unknown_mcast_block_mask[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access UNKNOWN_MCAST_BLOCK_MASK.
 *
 */
#define BCM53324_A0_READ_UNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr,(r._unknown_mcast_block_mask))
#define BCM53324_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr,&(r._unknown_mcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_MCAST_BLOCK_MASKr BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr
#define UNKNOWN_MCAST_BLOCK_MASKr_SIZE BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_SIZE
typedef BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_t UNKNOWN_MCAST_BLOCK_MASKr_t;
#define UNKNOWN_MCAST_BLOCK_MASKr_CLR BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_CLR
#define UNKNOWN_MCAST_BLOCK_MASKr_SET BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_SET
#define UNKNOWN_MCAST_BLOCK_MASKr_GET BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_GET
#define UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_UNKNOWN_MCAST_BLOCK_MASKr BCM53324_A0_READ_UNKNOWN_MCAST_BLOCK_MASKr
#define WRITE_UNKNOWN_MCAST_BLOCK_MASKr BCM53324_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UNKNOWN_MCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  UNKNOWN_UCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask - Lower Bitmap
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr 0x0f700100

#define BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_UCAST_BLOCK_MASK.
 *
 */
typedef union BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t unknown_ucast_block_mask[1];
	uint32_t _unknown_ucast_block_mask;
} BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_t;

#define BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_CLR(r) (r).unknown_ucast_block_mask[0] = 0
#define BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_SET(r,d) (r).unknown_ucast_block_mask[0] = d
#define BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_GET(r) (r).unknown_ucast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).unknown_ucast_block_mask[0]) & 0x1ffffff)
#define BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).unknown_ucast_block_mask[0]=(((r).unknown_ucast_block_mask[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access UNKNOWN_UCAST_BLOCK_MASK.
 *
 */
#define BCM53324_A0_READ_UNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr,(r._unknown_ucast_block_mask))
#define BCM53324_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr,&(r._unknown_ucast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_UCAST_BLOCK_MASKr BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr
#define UNKNOWN_UCAST_BLOCK_MASKr_SIZE BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_SIZE
typedef BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_t UNKNOWN_UCAST_BLOCK_MASKr_t;
#define UNKNOWN_UCAST_BLOCK_MASKr_CLR BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_CLR
#define UNKNOWN_UCAST_BLOCK_MASKr_SET BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_SET
#define UNKNOWN_UCAST_BLOCK_MASKr_GET BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_GET
#define UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_UNKNOWN_UCAST_BLOCK_MASKr BCM53324_A0_READ_UNKNOWN_UCAST_BLOCK_MASKr
#define WRITE_UNKNOWN_UCAST_BLOCK_MASKr BCM53324_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_UNKNOWN_UCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  USER_TRUNK_HASH_SELECT
 * BLOCKS:   IPIPE
 * DESC:     User configured trunk hash value selection
 * SIZE:     32
 * FIELDS:
 *     TRUNK_CFG_VAL    3 bit configured trunk hash for LAG
 *
 ******************************************************************************/
#define BCM53324_A0_USER_TRUNK_HASH_SELECTr 0x0f700134

#define BCM53324_A0_USER_TRUNK_HASH_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program USER_TRUNK_HASH_SELECT.
 *
 */
typedef union BCM53324_A0_USER_TRUNK_HASH_SELECTr_s {
	uint32_t v[1];
	uint32_t user_trunk_hash_select[1];
	uint32_t _user_trunk_hash_select;
} BCM53324_A0_USER_TRUNK_HASH_SELECTr_t;

#define BCM53324_A0_USER_TRUNK_HASH_SELECTr_CLR(r) (r).user_trunk_hash_select[0] = 0
#define BCM53324_A0_USER_TRUNK_HASH_SELECTr_SET(r,d) (r).user_trunk_hash_select[0] = d
#define BCM53324_A0_USER_TRUNK_HASH_SELECTr_GET(r) (r).user_trunk_hash_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_USER_TRUNK_HASH_SELECTr_TRUNK_CFG_VALf_GET(r) (((r).user_trunk_hash_select[0]) & 0x7)
#define BCM53324_A0_USER_TRUNK_HASH_SELECTr_TRUNK_CFG_VALf_SET(r,f) (r).user_trunk_hash_select[0]=(((r).user_trunk_hash_select[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))

/*
 * These macros can be used to access USER_TRUNK_HASH_SELECT.
 *
 */
#define BCM53324_A0_READ_USER_TRUNK_HASH_SELECTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_USER_TRUNK_HASH_SELECTr,(r._user_trunk_hash_select))
#define BCM53324_A0_WRITE_USER_TRUNK_HASH_SELECTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_USER_TRUNK_HASH_SELECTr,&(r._user_trunk_hash_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define USER_TRUNK_HASH_SELECTr BCM53324_A0_USER_TRUNK_HASH_SELECTr
#define USER_TRUNK_HASH_SELECTr_SIZE BCM53324_A0_USER_TRUNK_HASH_SELECTr_SIZE
typedef BCM53324_A0_USER_TRUNK_HASH_SELECTr_t USER_TRUNK_HASH_SELECTr_t;
#define USER_TRUNK_HASH_SELECTr_CLR BCM53324_A0_USER_TRUNK_HASH_SELECTr_CLR
#define USER_TRUNK_HASH_SELECTr_SET BCM53324_A0_USER_TRUNK_HASH_SELECTr_SET
#define USER_TRUNK_HASH_SELECTr_GET BCM53324_A0_USER_TRUNK_HASH_SELECTr_GET
#define USER_TRUNK_HASH_SELECTr_TRUNK_CFG_VALf_GET BCM53324_A0_USER_TRUNK_HASH_SELECTr_TRUNK_CFG_VALf_GET
#define USER_TRUNK_HASH_SELECTr_TRUNK_CFG_VALf_SET BCM53324_A0_USER_TRUNK_HASH_SELECTr_TRUNK_CFG_VALf_SET
#define READ_USER_TRUNK_HASH_SELECTr BCM53324_A0_READ_USER_TRUNK_HASH_SELECTr
#define WRITE_USER_TRUNK_HASH_SELECTr BCM53324_A0_WRITE_USER_TRUNK_HASH_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_USER_TRUNK_HASH_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  VLAN_CTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN Control Register #1
 * SIZE:     32
 * FIELDS:
 *     LEARN_VID        LEARN_VID for ARL learning
 *     USE_LEARN_VID    USE LEARN_VID field from this register for ARL learning
 *     INNER_TPID       TPID for inner VLAN, used for double tagging modes only
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_CTRLr 0x01780003

#define BCM53324_A0_VLAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_CTRL.
 *
 */
typedef union BCM53324_A0_VLAN_CTRLr_s {
	uint32_t v[1];
	uint32_t vlan_ctrl[1];
	uint32_t _vlan_ctrl;
} BCM53324_A0_VLAN_CTRLr_t;

#define BCM53324_A0_VLAN_CTRLr_CLR(r) (r).vlan_ctrl[0] = 0
#define BCM53324_A0_VLAN_CTRLr_SET(r,d) (r).vlan_ctrl[0] = d
#define BCM53324_A0_VLAN_CTRLr_GET(r) (r).vlan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_CTRLr_LEARN_VIDf_GET(r) (((r).vlan_ctrl[0]) & 0xfff)
#define BCM53324_A0_VLAN_CTRLr_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53324_A0_VLAN_CTRLr_USE_LEARN_VIDf_GET(r) ((((r).vlan_ctrl[0]) >> 12) & 0x1)
#define BCM53324_A0_VLAN_CTRLr_USE_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53324_A0_VLAN_CTRLr_INNER_TPIDf_GET(r) ((((r).vlan_ctrl[0]) >> 13) & 0xffff)
#define BCM53324_A0_VLAN_CTRLr_INNER_TPIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0xffff << 13)) | ((((uint32_t)f) & 0xffff) << 13))

/*
 * These macros can be used to access VLAN_CTRL.
 *
 */
#define BCM53324_A0_READ_VLAN_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_VLAN_CTRLr,(r._vlan_ctrl))
#define BCM53324_A0_WRITE_VLAN_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_VLAN_CTRLr,&(r._vlan_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRLr BCM53324_A0_VLAN_CTRLr
#define VLAN_CTRLr_SIZE BCM53324_A0_VLAN_CTRLr_SIZE
typedef BCM53324_A0_VLAN_CTRLr_t VLAN_CTRLr_t;
#define VLAN_CTRLr_CLR BCM53324_A0_VLAN_CTRLr_CLR
#define VLAN_CTRLr_SET BCM53324_A0_VLAN_CTRLr_SET
#define VLAN_CTRLr_GET BCM53324_A0_VLAN_CTRLr_GET
#define VLAN_CTRLr_LEARN_VIDf_GET BCM53324_A0_VLAN_CTRLr_LEARN_VIDf_GET
#define VLAN_CTRLr_LEARN_VIDf_SET BCM53324_A0_VLAN_CTRLr_LEARN_VIDf_SET
#define VLAN_CTRLr_USE_LEARN_VIDf_GET BCM53324_A0_VLAN_CTRLr_USE_LEARN_VIDf_GET
#define VLAN_CTRLr_USE_LEARN_VIDf_SET BCM53324_A0_VLAN_CTRLr_USE_LEARN_VIDf_SET
#define VLAN_CTRLr_INNER_TPIDf_GET BCM53324_A0_VLAN_CTRLr_INNER_TPIDf_GET
#define VLAN_CTRLr_INNER_TPIDf_SET BCM53324_A0_VLAN_CTRLr_INNER_TPIDf_SET
#define READ_VLAN_CTRLr BCM53324_A0_READ_VLAN_CTRLr
#define WRITE_VLAN_CTRLr BCM53324_A0_WRITE_VLAN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_MAC
 * BLOCKS:   IPIPE
 * DESC:     Holds key & data for MAC-based VLAN substitution, Indexed by hash Value[6:0] of macsa. depending on the programming of the L2_AND_VLAN_MASH_HASH_SELECT, 7 bits of hash is taken for indexing 
 * SIZE:     64
 * FIELDS:
 *     MAC_ADDR         MAC address key
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     VALID            VLAN ID
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_MACm 0x04750000

#define BCM53324_A0_VLAN_MACm_MIN 0
#define BCM53324_A0_VLAN_MACm_MAX 63
#define BCM53324_A0_VLAN_MACm_CMAX(u) 63
#define BCM53324_A0_VLAN_MACm_SIZE 8

/*
 * This structure should be used to declare and program VLAN_MAC.
 *
 */
typedef union BCM53324_A0_VLAN_MACm_s {
	uint32_t v[2];
	uint32_t vlan_mac[2];
	uint32_t _vlan_mac;
} BCM53324_A0_VLAN_MACm_t;

#define BCM53324_A0_VLAN_MACm_CLR(r) CDK_MEMSET(&((r)._vlan_mac), 0, sizeof(BCM53324_A0_VLAN_MACm_t))
#define BCM53324_A0_VLAN_MACm_SET(r,i,d) (r).vlan_mac[i] = d
#define BCM53324_A0_VLAN_MACm_GET(r,i) (r).vlan_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_MACm_MAC_ADDRf_GET(r,a) cdk_field_get((r).vlan_mac,0,47,a)
#define BCM53324_A0_VLAN_MACm_MAC_ADDRf_SET(r,a) cdk_field_set((r).vlan_mac,0,47,a)
#define BCM53324_A0_VLAN_MACm_VLAN_IDf_GET(r) ((((r).vlan_mac[1]) >> 16) & 0xfff)
#define BCM53324_A0_VLAN_MACm_VLAN_IDf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53324_A0_VLAN_MACm_PRIf_GET(r) ((((r).vlan_mac[1]) >> 28) & 0x7)
#define BCM53324_A0_VLAN_MACm_PRIf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53324_A0_VLAN_MACm_VALIDf_GET(r) ((((r).vlan_mac[1]) >> 31) & 0x1)
#define BCM53324_A0_VLAN_MACm_VALIDf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access VLAN_MAC.
 *
 */
#define BCM53324_A0_READ_VLAN_MACm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_MACm,i,(m._vlan_mac),2)
#define BCM53324_A0_WRITE_VLAN_MACm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_MACm,i,&(m._vlan_mac),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MACm BCM53324_A0_VLAN_MACm
#define VLAN_MACm_MIN BCM53324_A0_VLAN_MACm_MIN
#define VLAN_MACm_MAX BCM53324_A0_VLAN_MACm_MAX
#define VLAN_MACm_CMAX(u) BCM53324_A0_VLAN_MACm_CMAX(u)
#define VLAN_MACm_SIZE BCM53324_A0_VLAN_MACm_SIZE
typedef BCM53324_A0_VLAN_MACm_t VLAN_MACm_t;
#define VLAN_MACm_CLR BCM53324_A0_VLAN_MACm_CLR
#define VLAN_MACm_SET BCM53324_A0_VLAN_MACm_SET
#define VLAN_MACm_GET BCM53324_A0_VLAN_MACm_GET
#define VLAN_MACm_MAC_ADDRf_GET BCM53324_A0_VLAN_MACm_MAC_ADDRf_GET
#define VLAN_MACm_MAC_ADDRf_SET BCM53324_A0_VLAN_MACm_MAC_ADDRf_SET
#define VLAN_MACm_VLAN_IDf_GET BCM53324_A0_VLAN_MACm_VLAN_IDf_GET
#define VLAN_MACm_VLAN_IDf_SET BCM53324_A0_VLAN_MACm_VLAN_IDf_SET
#define VLAN_MACm_PRIf_GET BCM53324_A0_VLAN_MACm_PRIf_GET
#define VLAN_MACm_PRIf_SET BCM53324_A0_VLAN_MACm_PRIf_SET
#define VLAN_MACm_VALIDf_GET BCM53324_A0_VLAN_MACm_VALIDf_GET
#define VLAN_MACm_VALIDf_SET BCM53324_A0_VLAN_MACm_VALIDf_SET
#define READ_VLAN_MACm BCM53324_A0_READ_VLAN_MACm
#define WRITE_VLAN_MACm BCM53324_A0_WRITE_VLAN_MACm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_MACm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  VLAN_MAC_AUX_HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_MAC_AUX_HASH_CONTROL
 * SIZE:     32
 * FIELDS:
 *     HASH_SELECT      Selects one of the standard hashing modes. HASH_CRC32_UPPER by default
 *     ENABLE           This bit enables dual hashing (if == 1 for the )2_ENTRY table.
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr 0x04780010

#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_MAC_AUX_HASH_CONTROL.
 *
 */
typedef union BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_s {
	uint32_t v[1];
	uint32_t vlan_mac_aux_hash_control[1];
	uint32_t _vlan_mac_aux_hash_control;
} BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_t;

#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_CLR(r) (r).vlan_mac_aux_hash_control[0] = 0
#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_SET(r,d) (r).vlan_mac_aux_hash_control[0] = d
#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_GET(r) (r).vlan_mac_aux_hash_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_HASH_SELECTf_GET(r) (((r).vlan_mac_aux_hash_control[0]) & 0x7)
#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_HASH_SELECTf_SET(r,f) (r).vlan_mac_aux_hash_control[0]=(((r).vlan_mac_aux_hash_control[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_ENABLEf_GET(r) ((((r).vlan_mac_aux_hash_control[0]) >> 3) & 0x1)
#define BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_ENABLEf_SET(r,f) (r).vlan_mac_aux_hash_control[0]=(((r).vlan_mac_aux_hash_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access VLAN_MAC_AUX_HASH_CONTROL.
 *
 */
#define BCM53324_A0_READ_VLAN_MAC_AUX_HASH_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr,(r._vlan_mac_aux_hash_control))
#define BCM53324_A0_WRITE_VLAN_MAC_AUX_HASH_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr,&(r._vlan_mac_aux_hash_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MAC_AUX_HASH_CONTROLr BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr
#define VLAN_MAC_AUX_HASH_CONTROLr_SIZE BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_SIZE
typedef BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_t VLAN_MAC_AUX_HASH_CONTROLr_t;
#define VLAN_MAC_AUX_HASH_CONTROLr_CLR BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_CLR
#define VLAN_MAC_AUX_HASH_CONTROLr_SET BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_SET
#define VLAN_MAC_AUX_HASH_CONTROLr_GET BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_GET
#define VLAN_MAC_AUX_HASH_CONTROLr_HASH_SELECTf_GET BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_HASH_SELECTf_GET
#define VLAN_MAC_AUX_HASH_CONTROLr_HASH_SELECTf_SET BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_HASH_SELECTf_SET
#define VLAN_MAC_AUX_HASH_CONTROLr_ENABLEf_GET BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_ENABLEf_GET
#define VLAN_MAC_AUX_HASH_CONTROLr_ENABLEf_SET BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr_ENABLEf_SET
#define READ_VLAN_MAC_AUX_HASH_CONTROLr BCM53324_A0_READ_VLAN_MAC_AUX_HASH_CONTROLr
#define WRITE_VLAN_MAC_AUX_HASH_CONTROLr BCM53324_A0_WRITE_VLAN_MAC_AUX_HASH_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_MAC_AUX_HASH_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  VLAN_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is ANDed with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the VLAN table.
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_PARITY_CONTROLr 0x05780001

#define BCM53324_A0_VLAN_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_PARITY_CONTROL.
 *
 */
typedef union BCM53324_A0_VLAN_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t vlan_parity_control[1];
	uint32_t _vlan_parity_control;
} BCM53324_A0_VLAN_PARITY_CONTROLr_t;

#define BCM53324_A0_VLAN_PARITY_CONTROLr_CLR(r) (r).vlan_parity_control[0] = 0
#define BCM53324_A0_VLAN_PARITY_CONTROLr_SET(r,d) (r).vlan_parity_control[0] = d
#define BCM53324_A0_VLAN_PARITY_CONTROLr_GET(r) (r).vlan_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).vlan_parity_control[0]) & 0x1)
#define BCM53324_A0_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).vlan_parity_control[0]=(((r).vlan_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_VLAN_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).vlan_parity_control[0]) >> 1) & 0x1)
#define BCM53324_A0_VLAN_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).vlan_parity_control[0]=(((r).vlan_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_PARITY_CONTROL.
 *
 */
#define BCM53324_A0_READ_VLAN_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_VLAN_PARITY_CONTROLr,(r._vlan_parity_control))
#define BCM53324_A0_WRITE_VLAN_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_VLAN_PARITY_CONTROLr,&(r._vlan_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PARITY_CONTROLr BCM53324_A0_VLAN_PARITY_CONTROLr
#define VLAN_PARITY_CONTROLr_SIZE BCM53324_A0_VLAN_PARITY_CONTROLr_SIZE
typedef BCM53324_A0_VLAN_PARITY_CONTROLr_t VLAN_PARITY_CONTROLr_t;
#define VLAN_PARITY_CONTROLr_CLR BCM53324_A0_VLAN_PARITY_CONTROLr_CLR
#define VLAN_PARITY_CONTROLr_SET BCM53324_A0_VLAN_PARITY_CONTROLr_SET
#define VLAN_PARITY_CONTROLr_GET BCM53324_A0_VLAN_PARITY_CONTROLr_GET
#define VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM53324_A0_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM53324_A0_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define VLAN_PARITY_CONTROLr_PARITY_ENf_GET BCM53324_A0_VLAN_PARITY_CONTROLr_PARITY_ENf_GET
#define VLAN_PARITY_CONTROLr_PARITY_ENf_SET BCM53324_A0_VLAN_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_VLAN_PARITY_CONTROLr BCM53324_A0_READ_VLAN_PARITY_CONTROLr
#define WRITE_VLAN_PARITY_CONTROLr BCM53324_A0_WRITE_VLAN_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  VLAN_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ERR_ADDR         This field indicates the address location in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_PARITY_STATUSr 0x05780002

#define BCM53324_A0_VLAN_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_PARITY_STATUS.
 *
 */
typedef union BCM53324_A0_VLAN_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_parity_status[1];
	uint32_t _vlan_parity_status;
} BCM53324_A0_VLAN_PARITY_STATUSr_t;

#define BCM53324_A0_VLAN_PARITY_STATUSr_CLR(r) (r).vlan_parity_status[0] = 0
#define BCM53324_A0_VLAN_PARITY_STATUSr_SET(r,d) (r).vlan_parity_status[0] = d
#define BCM53324_A0_VLAN_PARITY_STATUSr_GET(r) (r).vlan_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).vlan_parity_status[0]) & 0x1)
#define BCM53324_A0_VLAN_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).vlan_parity_status[0]=(((r).vlan_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_VLAN_PARITY_STATUSr_ERR_ADDRf_GET(r) ((((r).vlan_parity_status[0]) >> 1) & 0xfff)
#define BCM53324_A0_VLAN_PARITY_STATUSr_ERR_ADDRf_SET(r,f) (r).vlan_parity_status[0]=(((r).vlan_parity_status[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))

/*
 * These macros can be used to access VLAN_PARITY_STATUS.
 *
 */
#define BCM53324_A0_READ_VLAN_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_VLAN_PARITY_STATUSr,(r._vlan_parity_status))
#define BCM53324_A0_WRITE_VLAN_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_VLAN_PARITY_STATUSr,&(r._vlan_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PARITY_STATUSr BCM53324_A0_VLAN_PARITY_STATUSr
#define VLAN_PARITY_STATUSr_SIZE BCM53324_A0_VLAN_PARITY_STATUSr_SIZE
typedef BCM53324_A0_VLAN_PARITY_STATUSr_t VLAN_PARITY_STATUSr_t;
#define VLAN_PARITY_STATUSr_CLR BCM53324_A0_VLAN_PARITY_STATUSr_CLR
#define VLAN_PARITY_STATUSr_SET BCM53324_A0_VLAN_PARITY_STATUSr_SET
#define VLAN_PARITY_STATUSr_GET BCM53324_A0_VLAN_PARITY_STATUSr_GET
#define VLAN_PARITY_STATUSr_PARITY_ERRf_GET BCM53324_A0_VLAN_PARITY_STATUSr_PARITY_ERRf_GET
#define VLAN_PARITY_STATUSr_PARITY_ERRf_SET BCM53324_A0_VLAN_PARITY_STATUSr_PARITY_ERRf_SET
#define VLAN_PARITY_STATUSr_ERR_ADDRf_GET BCM53324_A0_VLAN_PARITY_STATUSr_ERR_ADDRf_GET
#define VLAN_PARITY_STATUSr_ERR_ADDRf_SET BCM53324_A0_VLAN_PARITY_STATUSr_ERR_ADDRf_SET
#define READ_VLAN_PARITY_STATUSr BCM53324_A0_READ_VLAN_PARITY_STATUSr
#define WRITE_VLAN_PARITY_STATUSr BCM53324_A0_WRITE_VLAN_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_PROFILE_TAB
 * BLOCKS:   IPIPE
 * DESC:     VLAN profile table for the VLAN specific properties. Indexed with the VLAN_PROFILE_PTR from the VLAN Table
 * SIZE:     17
 * FIELDS:
 *     L2_PFM           PFM value for L2 multicast lookups
 *     PFM              PFM value for multicast lookups
 *     LEARN_DISABLE    Disable learning on this VLAN
 *     OUTER_TPID_INDEX Used when PORT_TABLE.OUTER_TPID_VERIFY is enabled and indicates which of theING_OUTER_TPID[xx] register is expected to match for this VLAN
 *     IPMCV6_ENABLE    IPMC Enable for IPV6 packets on the VLAN. Taken from Triumph.
 *     IPMCV4_ENABLE    IPMC Enable for IPV4 packets on the VLAN. Taken from Triumph.
 *     IPMCV6_L2_ENABLE Enables L2-only forwarding of IPMCv6 packets on this VLAN based on(SGV,*GV) lookups. Taken from Triumph.
 *     IPMCV4_L2_ENABLE Enables L2-only forwarding of IPMCv4 packets on this VLAN based on(SGV,*GV) lookups. Taken from Triumph.
 *     IPV6L3_ENABLE    L3 Enable for IPV6 packets on the VLAN. Taken from Triumph.
 *     IPV4L3_ENABLE    L3 Enable for IPV4 packets on the VLAN. Taken from Triumph.
 *     L3_IPV4_PFM      PFM value for IPv4 multicast lookups
 *     L3_IPV6_PFM      PFM value for IPv6 multicast lookups
 *     UNKNOWN_IPV4_MC_TOCPU Unknown IPMC (IPMC miss) for IPv4 packets sent to CPU enable
 *     UNKNOWN_IPV6_MC_TOCPU Unknown IPMC (IPMC miss) for IPv6 packets sent to CPU enable
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_PROFILE_TABm 0x05720000

#define BCM53324_A0_VLAN_PROFILE_TABm_MIN 0
#define BCM53324_A0_VLAN_PROFILE_TABm_MAX 7
#define BCM53324_A0_VLAN_PROFILE_TABm_CMAX(u) 7
#define BCM53324_A0_VLAN_PROFILE_TABm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_PROFILE_TAB.
 *
 */
typedef union BCM53324_A0_VLAN_PROFILE_TABm_s {
	uint32_t v[1];
	uint32_t vlan_profile_tab[1];
	uint32_t _vlan_profile_tab;
} BCM53324_A0_VLAN_PROFILE_TABm_t;

#define BCM53324_A0_VLAN_PROFILE_TABm_CLR(r) (r).vlan_profile_tab[0] = 0
#define BCM53324_A0_VLAN_PROFILE_TABm_SET(r,d) (r).vlan_profile_tab[0] = d
#define BCM53324_A0_VLAN_PROFILE_TABm_GET(r) (r).vlan_profile_tab[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_PROFILE_TABm_L2_PFMf_GET(r) (((r).vlan_profile_tab[0]) & 0x3)
#define BCM53324_A0_VLAN_PROFILE_TABm_L2_PFMf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_VLAN_PROFILE_TABm_PFMf_GET(r) (((r).vlan_profile_tab[0]) & 0x3)
#define BCM53324_A0_VLAN_PROFILE_TABm_PFMf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_VLAN_PROFILE_TABm_LEARN_DISABLEf_GET(r) ((((r).vlan_profile_tab[0]) >> 2) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_LEARN_DISABLEf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_VLAN_PROFILE_TABm_OUTER_TPID_INDEXf_GET(r) ((((r).vlan_profile_tab[0]) >> 3) & 0x3)
#define BCM53324_A0_VLAN_PROFILE_TABm_OUTER_TPID_INDEXf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53324_A0_VLAN_PROFILE_TABm_IPMCV6_ENABLEf_GET(r) ((((r).vlan_profile_tab[0]) >> 5) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_IPMCV6_ENABLEf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_VLAN_PROFILE_TABm_IPMCV4_ENABLEf_GET(r) ((((r).vlan_profile_tab[0]) >> 6) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_IPMCV4_ENABLEf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53324_A0_VLAN_PROFILE_TABm_IPMCV6_L2_ENABLEf_GET(r) ((((r).vlan_profile_tab[0]) >> 7) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_IPMCV6_L2_ENABLEf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53324_A0_VLAN_PROFILE_TABm_IPMCV4_L2_ENABLEf_GET(r) ((((r).vlan_profile_tab[0]) >> 8) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_IPMCV4_L2_ENABLEf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53324_A0_VLAN_PROFILE_TABm_IPV6L3_ENABLEf_GET(r) ((((r).vlan_profile_tab[0]) >> 9) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_IPV6L3_ENABLEf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53324_A0_VLAN_PROFILE_TABm_IPV4L3_ENABLEf_GET(r) ((((r).vlan_profile_tab[0]) >> 10) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_IPV4L3_ENABLEf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53324_A0_VLAN_PROFILE_TABm_L3_IPV4_PFMf_GET(r) ((((r).vlan_profile_tab[0]) >> 11) & 0x3)
#define BCM53324_A0_VLAN_PROFILE_TABm_L3_IPV4_PFMf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53324_A0_VLAN_PROFILE_TABm_L3_IPV6_PFMf_GET(r) ((((r).vlan_profile_tab[0]) >> 13) & 0x3)
#define BCM53324_A0_VLAN_PROFILE_TABm_L3_IPV6_PFMf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53324_A0_VLAN_PROFILE_TABm_UNKNOWN_IPV4_MC_TOCPUf_GET(r) ((((r).vlan_profile_tab[0]) >> 15) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_UNKNOWN_IPV4_MC_TOCPUf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53324_A0_VLAN_PROFILE_TABm_UNKNOWN_IPV6_MC_TOCPUf_GET(r) ((((r).vlan_profile_tab[0]) >> 16) & 0x1)
#define BCM53324_A0_VLAN_PROFILE_TABm_UNKNOWN_IPV6_MC_TOCPUf_SET(r,f) (r).vlan_profile_tab[0]=(((r).vlan_profile_tab[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access VLAN_PROFILE_TAB.
 *
 */
#define BCM53324_A0_READ_VLAN_PROFILE_TABm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_PROFILE_TABm,i,(m._vlan_profile_tab),1)
#define BCM53324_A0_WRITE_VLAN_PROFILE_TABm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_PROFILE_TABm,i,&(m._vlan_profile_tab),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROFILE_TABm BCM53324_A0_VLAN_PROFILE_TABm
#define VLAN_PROFILE_TABm_MIN BCM53324_A0_VLAN_PROFILE_TABm_MIN
#define VLAN_PROFILE_TABm_MAX BCM53324_A0_VLAN_PROFILE_TABm_MAX
#define VLAN_PROFILE_TABm_CMAX(u) BCM53324_A0_VLAN_PROFILE_TABm_CMAX(u)
#define VLAN_PROFILE_TABm_SIZE BCM53324_A0_VLAN_PROFILE_TABm_SIZE
typedef BCM53324_A0_VLAN_PROFILE_TABm_t VLAN_PROFILE_TABm_t;
#define VLAN_PROFILE_TABm_CLR BCM53324_A0_VLAN_PROFILE_TABm_CLR
#define VLAN_PROFILE_TABm_SET BCM53324_A0_VLAN_PROFILE_TABm_SET
#define VLAN_PROFILE_TABm_GET BCM53324_A0_VLAN_PROFILE_TABm_GET
#define VLAN_PROFILE_TABm_L2_PFMf_GET BCM53324_A0_VLAN_PROFILE_TABm_L2_PFMf_GET
#define VLAN_PROFILE_TABm_L2_PFMf_SET BCM53324_A0_VLAN_PROFILE_TABm_L2_PFMf_SET
#define VLAN_PROFILE_TABm_PFMf_GET BCM53324_A0_VLAN_PROFILE_TABm_PFMf_GET
#define VLAN_PROFILE_TABm_PFMf_SET BCM53324_A0_VLAN_PROFILE_TABm_PFMf_SET
#define VLAN_PROFILE_TABm_LEARN_DISABLEf_GET BCM53324_A0_VLAN_PROFILE_TABm_LEARN_DISABLEf_GET
#define VLAN_PROFILE_TABm_LEARN_DISABLEf_SET BCM53324_A0_VLAN_PROFILE_TABm_LEARN_DISABLEf_SET
#define VLAN_PROFILE_TABm_OUTER_TPID_INDEXf_GET BCM53324_A0_VLAN_PROFILE_TABm_OUTER_TPID_INDEXf_GET
#define VLAN_PROFILE_TABm_OUTER_TPID_INDEXf_SET BCM53324_A0_VLAN_PROFILE_TABm_OUTER_TPID_INDEXf_SET
#define VLAN_PROFILE_TABm_IPMCV6_ENABLEf_GET BCM53324_A0_VLAN_PROFILE_TABm_IPMCV6_ENABLEf_GET
#define VLAN_PROFILE_TABm_IPMCV6_ENABLEf_SET BCM53324_A0_VLAN_PROFILE_TABm_IPMCV6_ENABLEf_SET
#define VLAN_PROFILE_TABm_IPMCV4_ENABLEf_GET BCM53324_A0_VLAN_PROFILE_TABm_IPMCV4_ENABLEf_GET
#define VLAN_PROFILE_TABm_IPMCV4_ENABLEf_SET BCM53324_A0_VLAN_PROFILE_TABm_IPMCV4_ENABLEf_SET
#define VLAN_PROFILE_TABm_IPMCV6_L2_ENABLEf_GET BCM53324_A0_VLAN_PROFILE_TABm_IPMCV6_L2_ENABLEf_GET
#define VLAN_PROFILE_TABm_IPMCV6_L2_ENABLEf_SET BCM53324_A0_VLAN_PROFILE_TABm_IPMCV6_L2_ENABLEf_SET
#define VLAN_PROFILE_TABm_IPMCV4_L2_ENABLEf_GET BCM53324_A0_VLAN_PROFILE_TABm_IPMCV4_L2_ENABLEf_GET
#define VLAN_PROFILE_TABm_IPMCV4_L2_ENABLEf_SET BCM53324_A0_VLAN_PROFILE_TABm_IPMCV4_L2_ENABLEf_SET
#define VLAN_PROFILE_TABm_IPV6L3_ENABLEf_GET BCM53324_A0_VLAN_PROFILE_TABm_IPV6L3_ENABLEf_GET
#define VLAN_PROFILE_TABm_IPV6L3_ENABLEf_SET BCM53324_A0_VLAN_PROFILE_TABm_IPV6L3_ENABLEf_SET
#define VLAN_PROFILE_TABm_IPV4L3_ENABLEf_GET BCM53324_A0_VLAN_PROFILE_TABm_IPV4L3_ENABLEf_GET
#define VLAN_PROFILE_TABm_IPV4L3_ENABLEf_SET BCM53324_A0_VLAN_PROFILE_TABm_IPV4L3_ENABLEf_SET
#define VLAN_PROFILE_TABm_L3_IPV4_PFMf_GET BCM53324_A0_VLAN_PROFILE_TABm_L3_IPV4_PFMf_GET
#define VLAN_PROFILE_TABm_L3_IPV4_PFMf_SET BCM53324_A0_VLAN_PROFILE_TABm_L3_IPV4_PFMf_SET
#define VLAN_PROFILE_TABm_L3_IPV6_PFMf_GET BCM53324_A0_VLAN_PROFILE_TABm_L3_IPV6_PFMf_GET
#define VLAN_PROFILE_TABm_L3_IPV6_PFMf_SET BCM53324_A0_VLAN_PROFILE_TABm_L3_IPV6_PFMf_SET
#define VLAN_PROFILE_TABm_UNKNOWN_IPV4_MC_TOCPUf_GET BCM53324_A0_VLAN_PROFILE_TABm_UNKNOWN_IPV4_MC_TOCPUf_GET
#define VLAN_PROFILE_TABm_UNKNOWN_IPV4_MC_TOCPUf_SET BCM53324_A0_VLAN_PROFILE_TABm_UNKNOWN_IPV4_MC_TOCPUf_SET
#define VLAN_PROFILE_TABm_UNKNOWN_IPV6_MC_TOCPUf_GET BCM53324_A0_VLAN_PROFILE_TABm_UNKNOWN_IPV6_MC_TOCPUf_GET
#define VLAN_PROFILE_TABm_UNKNOWN_IPV6_MC_TOCPUf_SET BCM53324_A0_VLAN_PROFILE_TABm_UNKNOWN_IPV6_MC_TOCPUf_SET
#define READ_VLAN_PROFILE_TABm BCM53324_A0_READ_VLAN_PROFILE_TABm
#define WRITE_VLAN_PROFILE_TABm BCM53324_A0_WRITE_VLAN_PROFILE_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_PROFILE_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_PROTOCOL
 * BLOCKS:   IPIPE
 * DESC:     Holds data for Protocol-based VLAN substitution.  Just the VLAN_PROTOCOL RAM. Lookup Key is constructed using pkt format and ethertype combination.
 * SIZE:     21
 * FIELDS:
 *     ETHERTYPE        Ethertype field
 *     LLC              LLC type pkt
 *     SNAP             SNAP type pkt
 *     ETHERII          Ethernet 2 type pkt
 *     MATCHLOWER       Match lower
 *     MATCHUPPER       Match upper
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_PROTOCOLm 0x04700000

#define BCM53324_A0_VLAN_PROTOCOLm_MIN 0
#define BCM53324_A0_VLAN_PROTOCOLm_MAX 15
#define BCM53324_A0_VLAN_PROTOCOLm_CMAX(u) 15
#define BCM53324_A0_VLAN_PROTOCOLm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_PROTOCOL.
 *
 */
typedef union BCM53324_A0_VLAN_PROTOCOLm_s {
	uint32_t v[1];
	uint32_t vlan_protocol[1];
	uint32_t _vlan_protocol;
} BCM53324_A0_VLAN_PROTOCOLm_t;

#define BCM53324_A0_VLAN_PROTOCOLm_CLR(r) (r).vlan_protocol[0] = 0
#define BCM53324_A0_VLAN_PROTOCOLm_SET(r,d) (r).vlan_protocol[0] = d
#define BCM53324_A0_VLAN_PROTOCOLm_GET(r) (r).vlan_protocol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_PROTOCOLm_ETHERTYPEf_GET(r) (((r).vlan_protocol[0]) & 0xffff)
#define BCM53324_A0_VLAN_PROTOCOLm_ETHERTYPEf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM53324_A0_VLAN_PROTOCOLm_LLCf_GET(r) ((((r).vlan_protocol[0]) >> 16) & 0x1)
#define BCM53324_A0_VLAN_PROTOCOLm_LLCf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53324_A0_VLAN_PROTOCOLm_SNAPf_GET(r) ((((r).vlan_protocol[0]) >> 17) & 0x1)
#define BCM53324_A0_VLAN_PROTOCOLm_SNAPf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53324_A0_VLAN_PROTOCOLm_ETHERIIf_GET(r) ((((r).vlan_protocol[0]) >> 18) & 0x1)
#define BCM53324_A0_VLAN_PROTOCOLm_ETHERIIf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_VLAN_PROTOCOLm_MATCHLOWERf_GET(r) ((((r).vlan_protocol[0]) >> 19) & 0x1)
#define BCM53324_A0_VLAN_PROTOCOLm_MATCHLOWERf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53324_A0_VLAN_PROTOCOLm_MATCHUPPERf_GET(r) ((((r).vlan_protocol[0]) >> 20) & 0x1)
#define BCM53324_A0_VLAN_PROTOCOLm_MATCHUPPERf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access VLAN_PROTOCOL.
 *
 */
#define BCM53324_A0_READ_VLAN_PROTOCOLm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_PROTOCOLm,i,(m._vlan_protocol),1)
#define BCM53324_A0_WRITE_VLAN_PROTOCOLm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_PROTOCOLm,i,&(m._vlan_protocol),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOLm BCM53324_A0_VLAN_PROTOCOLm
#define VLAN_PROTOCOLm_MIN BCM53324_A0_VLAN_PROTOCOLm_MIN
#define VLAN_PROTOCOLm_MAX BCM53324_A0_VLAN_PROTOCOLm_MAX
#define VLAN_PROTOCOLm_CMAX(u) BCM53324_A0_VLAN_PROTOCOLm_CMAX(u)
#define VLAN_PROTOCOLm_SIZE BCM53324_A0_VLAN_PROTOCOLm_SIZE
typedef BCM53324_A0_VLAN_PROTOCOLm_t VLAN_PROTOCOLm_t;
#define VLAN_PROTOCOLm_CLR BCM53324_A0_VLAN_PROTOCOLm_CLR
#define VLAN_PROTOCOLm_SET BCM53324_A0_VLAN_PROTOCOLm_SET
#define VLAN_PROTOCOLm_GET BCM53324_A0_VLAN_PROTOCOLm_GET
#define VLAN_PROTOCOLm_ETHERTYPEf_GET BCM53324_A0_VLAN_PROTOCOLm_ETHERTYPEf_GET
#define VLAN_PROTOCOLm_ETHERTYPEf_SET BCM53324_A0_VLAN_PROTOCOLm_ETHERTYPEf_SET
#define VLAN_PROTOCOLm_LLCf_GET BCM53324_A0_VLAN_PROTOCOLm_LLCf_GET
#define VLAN_PROTOCOLm_LLCf_SET BCM53324_A0_VLAN_PROTOCOLm_LLCf_SET
#define VLAN_PROTOCOLm_SNAPf_GET BCM53324_A0_VLAN_PROTOCOLm_SNAPf_GET
#define VLAN_PROTOCOLm_SNAPf_SET BCM53324_A0_VLAN_PROTOCOLm_SNAPf_SET
#define VLAN_PROTOCOLm_ETHERIIf_GET BCM53324_A0_VLAN_PROTOCOLm_ETHERIIf_GET
#define VLAN_PROTOCOLm_ETHERIIf_SET BCM53324_A0_VLAN_PROTOCOLm_ETHERIIf_SET
#define VLAN_PROTOCOLm_MATCHLOWERf_GET BCM53324_A0_VLAN_PROTOCOLm_MATCHLOWERf_GET
#define VLAN_PROTOCOLm_MATCHLOWERf_SET BCM53324_A0_VLAN_PROTOCOLm_MATCHLOWERf_SET
#define VLAN_PROTOCOLm_MATCHUPPERf_GET BCM53324_A0_VLAN_PROTOCOLm_MATCHUPPERf_GET
#define VLAN_PROTOCOLm_MATCHUPPERf_SET BCM53324_A0_VLAN_PROTOCOLm_MATCHUPPERf_SET
#define READ_VLAN_PROTOCOLm BCM53324_A0_READ_VLAN_PROTOCOLm
#define WRITE_VLAN_PROTOCOLm BCM53324_A0_WRITE_VLAN_PROTOCOLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_PROTOCOLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_PROTOCOL_DATA
 * BLOCKS:   IPIPE
 * DESC:     Holds data for Protocol-based VLAN substitution. Indexed by the {ingress_port[4:0], Matched entry index from VLAN_PROTOCOL table}
 * SIZE:     15
 * FIELDS:
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_PROTOCOL_DATAm 0x04710000

#define BCM53324_A0_VLAN_PROTOCOL_DATAm_MIN 0
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_MAX 399
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_CMAX(u) 399
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_SIZE 2

/*
 * This structure should be used to declare and program VLAN_PROTOCOL_DATA.
 *
 */
typedef union BCM53324_A0_VLAN_PROTOCOL_DATAm_s {
	uint32_t v[1];
	uint32_t vlan_protocol_data[1];
	uint32_t _vlan_protocol_data;
} BCM53324_A0_VLAN_PROTOCOL_DATAm_t;

#define BCM53324_A0_VLAN_PROTOCOL_DATAm_CLR(r) (r).vlan_protocol_data[0] = 0
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_SET(r,d) (r).vlan_protocol_data[0] = d
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_GET(r) (r).vlan_protocol_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_PRIf_GET(r) (((r).vlan_protocol_data[0]) & 0x7)
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_PRIf_SET(r,f) (r).vlan_protocol_data[0]=(((r).vlan_protocol_data[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_GET(r) ((((r).vlan_protocol_data[0]) >> 3) & 0xfff)
#define BCM53324_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_SET(r,f) (r).vlan_protocol_data[0]=(((r).vlan_protocol_data[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access VLAN_PROTOCOL_DATA.
 *
 */
#define BCM53324_A0_READ_VLAN_PROTOCOL_DATAm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_PROTOCOL_DATAm,i,(m._vlan_protocol_data),1)
#define BCM53324_A0_WRITE_VLAN_PROTOCOL_DATAm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_PROTOCOL_DATAm,i,&(m._vlan_protocol_data),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOL_DATAm BCM53324_A0_VLAN_PROTOCOL_DATAm
#define VLAN_PROTOCOL_DATAm_MIN BCM53324_A0_VLAN_PROTOCOL_DATAm_MIN
#define VLAN_PROTOCOL_DATAm_MAX BCM53324_A0_VLAN_PROTOCOL_DATAm_MAX
#define VLAN_PROTOCOL_DATAm_CMAX(u) BCM53324_A0_VLAN_PROTOCOL_DATAm_CMAX(u)
#define VLAN_PROTOCOL_DATAm_SIZE BCM53324_A0_VLAN_PROTOCOL_DATAm_SIZE
typedef BCM53324_A0_VLAN_PROTOCOL_DATAm_t VLAN_PROTOCOL_DATAm_t;
#define VLAN_PROTOCOL_DATAm_CLR BCM53324_A0_VLAN_PROTOCOL_DATAm_CLR
#define VLAN_PROTOCOL_DATAm_SET BCM53324_A0_VLAN_PROTOCOL_DATAm_SET
#define VLAN_PROTOCOL_DATAm_GET BCM53324_A0_VLAN_PROTOCOL_DATAm_GET
#define VLAN_PROTOCOL_DATAm_PRIf_GET BCM53324_A0_VLAN_PROTOCOL_DATAm_PRIf_GET
#define VLAN_PROTOCOL_DATAm_PRIf_SET BCM53324_A0_VLAN_PROTOCOL_DATAm_PRIf_SET
#define VLAN_PROTOCOL_DATAm_VLAN_IDf_GET BCM53324_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_GET
#define VLAN_PROTOCOL_DATAm_VLAN_IDf_SET BCM53324_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_SET
#define READ_VLAN_PROTOCOL_DATAm BCM53324_A0_READ_VLAN_PROTOCOL_DATAm
#define WRITE_VLAN_PROTOCOL_DATAm BCM53324_A0_WRITE_VLAN_PROTOCOL_DATAm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_PROTOCOL_DATAm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_SUBNET
 * BLOCKS:   IPIPE
 * DESC:     TCAM for IP subnet based VLAN substitution. Key is constructed using Packet SIP. 32 bits in case of v4 and 64 bits in case of v6. Check C code for more details.
 * SIZE:     150
 * FIELDS:
 *     VALID            IP Subnet mask
 *     IP_ADDR          IP Address key
 *     RESERVED_KEY     Unused bit in the IP Subnet data cam
 *     MASK             Useful IP Subnet mask
 *     RESERVED_MASK    Unused bit in the IP Subnet mask cam
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_SUBNETm 0x04720000

#define BCM53324_A0_VLAN_SUBNETm_MIN 0
#define BCM53324_A0_VLAN_SUBNETm_MAX 15
#define BCM53324_A0_VLAN_SUBNETm_CMAX(u) 15
#define BCM53324_A0_VLAN_SUBNETm_SIZE 19

/*
 * This structure should be used to declare and program VLAN_SUBNET.
 *
 */
typedef union BCM53324_A0_VLAN_SUBNETm_s {
	uint32_t v[5];
	uint32_t vlan_subnet[5];
	uint32_t _vlan_subnet;
} BCM53324_A0_VLAN_SUBNETm_t;

#define BCM53324_A0_VLAN_SUBNETm_CLR(r) CDK_MEMSET(&((r)._vlan_subnet), 0, sizeof(BCM53324_A0_VLAN_SUBNETm_t))
#define BCM53324_A0_VLAN_SUBNETm_SET(r,i,d) (r).vlan_subnet[i] = d
#define BCM53324_A0_VLAN_SUBNETm_GET(r,i) (r).vlan_subnet[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_SUBNETm_VALIDf_GET(r) (((r).vlan_subnet[0]) & 0x1)
#define BCM53324_A0_VLAN_SUBNETm_VALIDf_SET(r,f) (r).vlan_subnet[0]=(((r).vlan_subnet[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_VLAN_SUBNETm_IP_ADDRf_GET(r,a) cdk_field_get((r).vlan_subnet,1,64,a)
#define BCM53324_A0_VLAN_SUBNETm_IP_ADDRf_SET(r,a) cdk_field_set((r).vlan_subnet,1,64,a)
#define BCM53324_A0_VLAN_SUBNETm_RESERVED_KEYf_GET(r) ((((r).vlan_subnet[2]) >> 1) & 0x7)
#define BCM53324_A0_VLAN_SUBNETm_RESERVED_KEYf_SET(r,f) (r).vlan_subnet[2]=(((r).vlan_subnet[2] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53324_A0_VLAN_SUBNETm_MASKf_GET(r,a) cdk_field_get((r).vlan_subnet,68,131,a)
#define BCM53324_A0_VLAN_SUBNETm_MASKf_SET(r,a) cdk_field_set((r).vlan_subnet,68,131,a)
#define BCM53324_A0_VLAN_SUBNETm_RESERVED_MASKf_GET(r) ((((r).vlan_subnet[4]) >> 4) & 0x7)
#define BCM53324_A0_VLAN_SUBNETm_RESERVED_MASKf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53324_A0_VLAN_SUBNETm_PRIf_GET(r) ((((r).vlan_subnet[4]) >> 7) & 0x7)
#define BCM53324_A0_VLAN_SUBNETm_PRIf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53324_A0_VLAN_SUBNETm_VLAN_IDf_GET(r) ((((r).vlan_subnet[4]) >> 10) & 0xfff)
#define BCM53324_A0_VLAN_SUBNETm_VLAN_IDf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0xfff << 10)) | ((((uint32_t)f) & 0xfff) << 10))

/*
 * These macros can be used to access VLAN_SUBNET.
 *
 */
#define BCM53324_A0_READ_VLAN_SUBNETm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_SUBNETm,i,(m._vlan_subnet),5)
#define BCM53324_A0_WRITE_VLAN_SUBNETm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_SUBNETm,i,&(m._vlan_subnet),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNETm BCM53324_A0_VLAN_SUBNETm
#define VLAN_SUBNETm_MIN BCM53324_A0_VLAN_SUBNETm_MIN
#define VLAN_SUBNETm_MAX BCM53324_A0_VLAN_SUBNETm_MAX
#define VLAN_SUBNETm_CMAX(u) BCM53324_A0_VLAN_SUBNETm_CMAX(u)
#define VLAN_SUBNETm_SIZE BCM53324_A0_VLAN_SUBNETm_SIZE
typedef BCM53324_A0_VLAN_SUBNETm_t VLAN_SUBNETm_t;
#define VLAN_SUBNETm_CLR BCM53324_A0_VLAN_SUBNETm_CLR
#define VLAN_SUBNETm_SET BCM53324_A0_VLAN_SUBNETm_SET
#define VLAN_SUBNETm_GET BCM53324_A0_VLAN_SUBNETm_GET
#define VLAN_SUBNETm_VALIDf_GET BCM53324_A0_VLAN_SUBNETm_VALIDf_GET
#define VLAN_SUBNETm_VALIDf_SET BCM53324_A0_VLAN_SUBNETm_VALIDf_SET
#define VLAN_SUBNETm_IP_ADDRf_GET BCM53324_A0_VLAN_SUBNETm_IP_ADDRf_GET
#define VLAN_SUBNETm_IP_ADDRf_SET BCM53324_A0_VLAN_SUBNETm_IP_ADDRf_SET
#define VLAN_SUBNETm_RESERVED_KEYf_GET BCM53324_A0_VLAN_SUBNETm_RESERVED_KEYf_GET
#define VLAN_SUBNETm_RESERVED_KEYf_SET BCM53324_A0_VLAN_SUBNETm_RESERVED_KEYf_SET
#define VLAN_SUBNETm_MASKf_GET BCM53324_A0_VLAN_SUBNETm_MASKf_GET
#define VLAN_SUBNETm_MASKf_SET BCM53324_A0_VLAN_SUBNETm_MASKf_SET
#define VLAN_SUBNETm_RESERVED_MASKf_GET BCM53324_A0_VLAN_SUBNETm_RESERVED_MASKf_GET
#define VLAN_SUBNETm_RESERVED_MASKf_SET BCM53324_A0_VLAN_SUBNETm_RESERVED_MASKf_SET
#define VLAN_SUBNETm_PRIf_GET BCM53324_A0_VLAN_SUBNETm_PRIf_GET
#define VLAN_SUBNETm_PRIf_SET BCM53324_A0_VLAN_SUBNETm_PRIf_SET
#define VLAN_SUBNETm_VLAN_IDf_GET BCM53324_A0_VLAN_SUBNETm_VLAN_IDf_GET
#define VLAN_SUBNETm_VLAN_IDf_SET BCM53324_A0_VLAN_SUBNETm_VLAN_IDf_SET
#define READ_VLAN_SUBNETm BCM53324_A0_READ_VLAN_SUBNETm
#define WRITE_VLAN_SUBNETm BCM53324_A0_WRITE_VLAN_SUBNETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_SUBNETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_SUBNET_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Holds data for IP Subnet-based VLAN substitution. Data Table view.
 * SIZE:     15
 * FIELDS:
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm 0x04740000

#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_MIN 0
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_MAX 15
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_CMAX(u) 15
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_SIZE 2

/*
 * This structure should be used to declare and program VLAN_SUBNET_DATA_ONLY.
 *
 */
typedef union BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t vlan_subnet_data_only[1];
	uint32_t _vlan_subnet_data_only;
} BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_t;

#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_CLR(r) (r).vlan_subnet_data_only[0] = 0
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_SET(r,d) (r).vlan_subnet_data_only[0] = d
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_GET(r) (r).vlan_subnet_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_GET(r) (((r).vlan_subnet_data_only[0]) & 0x7)
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_SET(r,f) (r).vlan_subnet_data_only[0]=(((r).vlan_subnet_data_only[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET(r) ((((r).vlan_subnet_data_only[0]) >> 3) & 0xfff)
#define BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET(r,f) (r).vlan_subnet_data_only[0]=(((r).vlan_subnet_data_only[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access VLAN_SUBNET_DATA_ONLY.
 *
 */
#define BCM53324_A0_READ_VLAN_SUBNET_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_SUBNET_DATA_ONLYm,i,(m._vlan_subnet_data_only),1)
#define BCM53324_A0_WRITE_VLAN_SUBNET_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_SUBNET_DATA_ONLYm,i,&(m._vlan_subnet_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_DATA_ONLYm BCM53324_A0_VLAN_SUBNET_DATA_ONLYm
#define VLAN_SUBNET_DATA_ONLYm_MIN BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_MIN
#define VLAN_SUBNET_DATA_ONLYm_MAX BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_MAX
#define VLAN_SUBNET_DATA_ONLYm_CMAX(u) BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_CMAX(u)
#define VLAN_SUBNET_DATA_ONLYm_SIZE BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_SIZE
typedef BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_t VLAN_SUBNET_DATA_ONLYm_t;
#define VLAN_SUBNET_DATA_ONLYm_CLR BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_CLR
#define VLAN_SUBNET_DATA_ONLYm_SET BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_SET
#define VLAN_SUBNET_DATA_ONLYm_GET BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_GET
#define VLAN_SUBNET_DATA_ONLYm_PRIf_GET BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_GET
#define VLAN_SUBNET_DATA_ONLYm_PRIf_SET BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_SET
#define VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET
#define VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET BCM53324_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET
#define READ_VLAN_SUBNET_DATA_ONLYm BCM53324_A0_READ_VLAN_SUBNET_DATA_ONLYm
#define WRITE_VLAN_SUBNET_DATA_ONLYm BCM53324_A0_WRITE_VLAN_SUBNET_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_SUBNET_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_SUBNET_ONLY
 * BLOCKS:   IPIPE
 * DESC:     TCAM for IP subnet based VLAN substitution. Tcam view.
 * SIZE:     135
 * FIELDS:
 *     VALID            IP Subnet mask
 *     IP_ADDR          IP Address key
 *     RESERVED_KEY     Unused bits in the IP subnet data cam
 *     MASK             IP Subnet mask
 *     RESERVED_MASK    Unused bits in the IP Subnet mask cam.
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_SUBNET_ONLYm 0x04730000

#define BCM53324_A0_VLAN_SUBNET_ONLYm_MIN 0
#define BCM53324_A0_VLAN_SUBNET_ONLYm_MAX 15
#define BCM53324_A0_VLAN_SUBNET_ONLYm_CMAX(u) 15
#define BCM53324_A0_VLAN_SUBNET_ONLYm_SIZE 17

/*
 * This structure should be used to declare and program VLAN_SUBNET_ONLY.
 *
 */
typedef union BCM53324_A0_VLAN_SUBNET_ONLYm_s {
	uint32_t v[5];
	uint32_t vlan_subnet_only[5];
	uint32_t _vlan_subnet_only;
} BCM53324_A0_VLAN_SUBNET_ONLYm_t;

#define BCM53324_A0_VLAN_SUBNET_ONLYm_CLR(r) CDK_MEMSET(&((r)._vlan_subnet_only), 0, sizeof(BCM53324_A0_VLAN_SUBNET_ONLYm_t))
#define BCM53324_A0_VLAN_SUBNET_ONLYm_SET(r,i,d) (r).vlan_subnet_only[i] = d
#define BCM53324_A0_VLAN_SUBNET_ONLYm_GET(r,i) (r).vlan_subnet_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_SUBNET_ONLYm_VALIDf_GET(r) (((r).vlan_subnet_only[0]) & 0x1)
#define BCM53324_A0_VLAN_SUBNET_ONLYm_VALIDf_SET(r,f) (r).vlan_subnet_only[0]=(((r).vlan_subnet_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_GET(r,a) cdk_field_get((r).vlan_subnet_only,1,64,a)
#define BCM53324_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_SET(r,a) cdk_field_set((r).vlan_subnet_only,1,64,a)
#define BCM53324_A0_VLAN_SUBNET_ONLYm_RESERVED_KEYf_GET(r) ((((r).vlan_subnet_only[2]) >> 1) & 0x7)
#define BCM53324_A0_VLAN_SUBNET_ONLYm_RESERVED_KEYf_SET(r,f) (r).vlan_subnet_only[2]=(((r).vlan_subnet_only[2] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53324_A0_VLAN_SUBNET_ONLYm_MASKf_GET(r,a) cdk_field_get((r).vlan_subnet_only,68,131,a)
#define BCM53324_A0_VLAN_SUBNET_ONLYm_MASKf_SET(r,a) cdk_field_set((r).vlan_subnet_only,68,131,a)
#define BCM53324_A0_VLAN_SUBNET_ONLYm_RESERVED_MASKf_GET(r) ((((r).vlan_subnet_only[4]) >> 4) & 0x7)
#define BCM53324_A0_VLAN_SUBNET_ONLYm_RESERVED_MASKf_SET(r,f) (r).vlan_subnet_only[4]=(((r).vlan_subnet_only[4] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))

/*
 * These macros can be used to access VLAN_SUBNET_ONLY.
 *
 */
#define BCM53324_A0_READ_VLAN_SUBNET_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_SUBNET_ONLYm,i,(m._vlan_subnet_only),5)
#define BCM53324_A0_WRITE_VLAN_SUBNET_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_SUBNET_ONLYm,i,&(m._vlan_subnet_only),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_ONLYm BCM53324_A0_VLAN_SUBNET_ONLYm
#define VLAN_SUBNET_ONLYm_MIN BCM53324_A0_VLAN_SUBNET_ONLYm_MIN
#define VLAN_SUBNET_ONLYm_MAX BCM53324_A0_VLAN_SUBNET_ONLYm_MAX
#define VLAN_SUBNET_ONLYm_CMAX(u) BCM53324_A0_VLAN_SUBNET_ONLYm_CMAX(u)
#define VLAN_SUBNET_ONLYm_SIZE BCM53324_A0_VLAN_SUBNET_ONLYm_SIZE
typedef BCM53324_A0_VLAN_SUBNET_ONLYm_t VLAN_SUBNET_ONLYm_t;
#define VLAN_SUBNET_ONLYm_CLR BCM53324_A0_VLAN_SUBNET_ONLYm_CLR
#define VLAN_SUBNET_ONLYm_SET BCM53324_A0_VLAN_SUBNET_ONLYm_SET
#define VLAN_SUBNET_ONLYm_GET BCM53324_A0_VLAN_SUBNET_ONLYm_GET
#define VLAN_SUBNET_ONLYm_VALIDf_GET BCM53324_A0_VLAN_SUBNET_ONLYm_VALIDf_GET
#define VLAN_SUBNET_ONLYm_VALIDf_SET BCM53324_A0_VLAN_SUBNET_ONLYm_VALIDf_SET
#define VLAN_SUBNET_ONLYm_IP_ADDRf_GET BCM53324_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_GET
#define VLAN_SUBNET_ONLYm_IP_ADDRf_SET BCM53324_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_SET
#define VLAN_SUBNET_ONLYm_RESERVED_KEYf_GET BCM53324_A0_VLAN_SUBNET_ONLYm_RESERVED_KEYf_GET
#define VLAN_SUBNET_ONLYm_RESERVED_KEYf_SET BCM53324_A0_VLAN_SUBNET_ONLYm_RESERVED_KEYf_SET
#define VLAN_SUBNET_ONLYm_MASKf_GET BCM53324_A0_VLAN_SUBNET_ONLYm_MASKf_GET
#define VLAN_SUBNET_ONLYm_MASKf_SET BCM53324_A0_VLAN_SUBNET_ONLYm_MASKf_SET
#define VLAN_SUBNET_ONLYm_RESERVED_MASKf_GET BCM53324_A0_VLAN_SUBNET_ONLYm_RESERVED_MASKf_GET
#define VLAN_SUBNET_ONLYm_RESERVED_MASKf_SET BCM53324_A0_VLAN_SUBNET_ONLYm_RESERVED_MASKf_SET
#define READ_VLAN_SUBNET_ONLYm BCM53324_A0_READ_VLAN_SUBNET_ONLYm
#define WRITE_VLAN_SUBNET_ONLYm BCM53324_A0_WRITE_VLAN_SUBNET_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_SUBNET_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_TAB
 * BLOCKS:   IPIPE
 * DESC:     Contains controls associated with the 4K VLANs. Indexed by the 12 bit VLAN ID
 * SIZE:     44
 * FIELDS:
 *     PORT_BITMAP      VLAN port membership bitmap
 *     PORT_BITMAP_LO   VLAN port membership bitmap
 *     VALID            Valid VLAN ID
 *     STG              Spanning Tree Group ID
 *     VLAN_PROFILE_PTR VLAN profile pointer to get VLAN-specific properties
 *     HIGIG_TRUNK_OVERRIDE Overrides for Higig Trunk Logic based on Vlans.
 *     VRF_ID           VRF ID for L3 routing lookups
 *     EVEN_PARITY      Even parity for the VLAN RAM fields
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_TABm 0x05700000

#define BCM53324_A0_VLAN_TABm_MIN 0
#define BCM53324_A0_VLAN_TABm_MAX 4095
#define BCM53324_A0_VLAN_TABm_CMAX(u) 4095
#define BCM53324_A0_VLAN_TABm_SIZE 6

/*
 * This structure should be used to declare and program VLAN_TAB.
 *
 */
typedef union BCM53324_A0_VLAN_TABm_s {
	uint32_t v[2];
	uint32_t vlan_tab[2];
	uint32_t _vlan_tab;
} BCM53324_A0_VLAN_TABm_t;

#define BCM53324_A0_VLAN_TABm_CLR(r) CDK_MEMSET(&((r)._vlan_tab), 0, sizeof(BCM53324_A0_VLAN_TABm_t))
#define BCM53324_A0_VLAN_TABm_SET(r,i,d) (r).vlan_tab[i] = d
#define BCM53324_A0_VLAN_TABm_GET(r,i) (r).vlan_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_TABm_PORT_BITMAPf_GET(r) (((r).vlan_tab[0]) & 0x1ffffff)
#define BCM53324_A0_VLAN_TABm_PORT_BITMAPf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_VLAN_TABm_PORT_BITMAP_LOf_GET(r) (((r).vlan_tab[0]) & 0x1ffffff)
#define BCM53324_A0_VLAN_TABm_PORT_BITMAP_LOf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM53324_A0_VLAN_TABm_VALIDf_GET(r) ((((r).vlan_tab[0]) >> 25) & 0x1)
#define BCM53324_A0_VLAN_TABm_VALIDf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53324_A0_VLAN_TABm_STGf_GET(r) ((((r).vlan_tab[0]) >> 26) & 0x3f)
#define BCM53324_A0_VLAN_TABm_STGf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define BCM53324_A0_VLAN_TABm_VLAN_PROFILE_PTRf_GET(r) (((r).vlan_tab[1]) & 0x7)
#define BCM53324_A0_VLAN_TABm_VLAN_PROFILE_PTRf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53324_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).vlan_tab[1]) >> 3) & 0x3)
#define BCM53324_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53324_A0_VLAN_TABm_VRF_IDf_GET(r) ((((r).vlan_tab[1]) >> 5) & 0x3f)
#define BCM53324_A0_VLAN_TABm_VRF_IDf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5))
#define BCM53324_A0_VLAN_TABm_EVEN_PARITYf_GET(r) ((((r).vlan_tab[1]) >> 11) & 0x1)
#define BCM53324_A0_VLAN_TABm_EVEN_PARITYf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access VLAN_TAB.
 *
 */
#define BCM53324_A0_READ_VLAN_TABm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_TABm,i,(m._vlan_tab),2)
#define BCM53324_A0_WRITE_VLAN_TABm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_TABm,i,&(m._vlan_tab),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_TABm BCM53324_A0_VLAN_TABm
#define VLAN_TABm_MIN BCM53324_A0_VLAN_TABm_MIN
#define VLAN_TABm_MAX BCM53324_A0_VLAN_TABm_MAX
#define VLAN_TABm_CMAX(u) BCM53324_A0_VLAN_TABm_CMAX(u)
#define VLAN_TABm_SIZE BCM53324_A0_VLAN_TABm_SIZE
typedef BCM53324_A0_VLAN_TABm_t VLAN_TABm_t;
#define VLAN_TABm_CLR BCM53324_A0_VLAN_TABm_CLR
#define VLAN_TABm_SET BCM53324_A0_VLAN_TABm_SET
#define VLAN_TABm_GET BCM53324_A0_VLAN_TABm_GET
#define VLAN_TABm_PORT_BITMAPf_GET BCM53324_A0_VLAN_TABm_PORT_BITMAPf_GET
#define VLAN_TABm_PORT_BITMAPf_SET BCM53324_A0_VLAN_TABm_PORT_BITMAPf_SET
#define VLAN_TABm_PORT_BITMAP_LOf_GET BCM53324_A0_VLAN_TABm_PORT_BITMAP_LOf_GET
#define VLAN_TABm_PORT_BITMAP_LOf_SET BCM53324_A0_VLAN_TABm_PORT_BITMAP_LOf_SET
#define VLAN_TABm_VALIDf_GET BCM53324_A0_VLAN_TABm_VALIDf_GET
#define VLAN_TABm_VALIDf_SET BCM53324_A0_VLAN_TABm_VALIDf_SET
#define VLAN_TABm_STGf_GET BCM53324_A0_VLAN_TABm_STGf_GET
#define VLAN_TABm_STGf_SET BCM53324_A0_VLAN_TABm_STGf_SET
#define VLAN_TABm_VLAN_PROFILE_PTRf_GET BCM53324_A0_VLAN_TABm_VLAN_PROFILE_PTRf_GET
#define VLAN_TABm_VLAN_PROFILE_PTRf_SET BCM53324_A0_VLAN_TABm_VLAN_PROFILE_PTRf_SET
#define VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET BCM53324_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET
#define VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET BCM53324_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET
#define VLAN_TABm_VRF_IDf_GET BCM53324_A0_VLAN_TABm_VRF_IDf_GET
#define VLAN_TABm_VRF_IDf_SET BCM53324_A0_VLAN_TABm_VRF_IDf_SET
#define VLAN_TABm_EVEN_PARITYf_GET BCM53324_A0_VLAN_TABm_EVEN_PARITYf_GET
#define VLAN_TABm_EVEN_PARITYf_SET BCM53324_A0_VLAN_TABm_EVEN_PARITYf_SET
#define READ_VLAN_TABm BCM53324_A0_READ_VLAN_TABm
#define WRITE_VLAN_TABm BCM53324_A0_WRITE_VLAN_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_XLATE
 * BLOCKS:   IPIPE
 * DESC:     CAM for VLAN trans of tagged pkts. Key is constructed using the {incoming vid, ingress port num}
 * SIZE:     54
 * FIELDS:
 *     VALID            Indicates that the entry is valid.
 *     INGRESS_PORT     Source port part of the key
 *     PORT             Source port part of the key
 *     OLD_VLAN_ID      VLAN ID part of the key
 *     VLAN_ID          VLAN ID part of the key
 *     RESERVED_KEY      Unused bit in the cam data
 *     MASK             mask for the key{vlan_id, ingressport}
 *     RESERVED_MASK    Unused bit in the mask
 *     RPE              RPE bit
 *     PRI              Priority to be assigned
 *     NEW_VLAN_ID      VLAN ID to be assigned
 *     ADD_VID          Add the VLAN ID
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_XLATEm 0x04760000

#define BCM53324_A0_VLAN_XLATEm_MIN 0
#define BCM53324_A0_VLAN_XLATEm_MAX 15
#define BCM53324_A0_VLAN_XLATEm_CMAX(u) 15
#define BCM53324_A0_VLAN_XLATEm_SIZE 7

/*
 * This structure should be used to declare and program VLAN_XLATE.
 *
 */
typedef union BCM53324_A0_VLAN_XLATEm_s {
	uint32_t v[2];
	uint32_t vlan_xlate[2];
	uint32_t _vlan_xlate;
} BCM53324_A0_VLAN_XLATEm_t;

#define BCM53324_A0_VLAN_XLATEm_CLR(r) CDK_MEMSET(&((r)._vlan_xlate), 0, sizeof(BCM53324_A0_VLAN_XLATEm_t))
#define BCM53324_A0_VLAN_XLATEm_SET(r,i,d) (r).vlan_xlate[i] = d
#define BCM53324_A0_VLAN_XLATEm_GET(r,i) (r).vlan_xlate[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_XLATEm_VALIDf_GET(r) (((r).vlan_xlate[0]) & 0x1)
#define BCM53324_A0_VLAN_XLATEm_VALIDf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_VLAN_XLATEm_INGRESS_PORTf_GET(r) ((((r).vlan_xlate[0]) >> 1) & 0x1f)
#define BCM53324_A0_VLAN_XLATEm_INGRESS_PORTf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM53324_A0_VLAN_XLATEm_PORTf_GET(r) ((((r).vlan_xlate[0]) >> 1) & 0x1f)
#define BCM53324_A0_VLAN_XLATEm_PORTf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM53324_A0_VLAN_XLATEm_OLD_VLAN_IDf_GET(r) ((((r).vlan_xlate[0]) >> 6) & 0xfff)
#define BCM53324_A0_VLAN_XLATEm_OLD_VLAN_IDf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM53324_A0_VLAN_XLATEm_VLAN_IDf_GET(r) ((((r).vlan_xlate[0]) >> 6) & 0xfff)
#define BCM53324_A0_VLAN_XLATEm_VLAN_IDf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM53324_A0_VLAN_XLATEm_RESERVED_KEYf_GET(r) ((((r).vlan_xlate[0]) >> 18) & 0x1)
#define BCM53324_A0_VLAN_XLATEm_RESERVED_KEYf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_VLAN_XLATEm_MASKf_GET(r) cdk_field32_get((r).vlan_xlate,19,35)
#define BCM53324_A0_VLAN_XLATEm_MASKf_SET(r,f) cdk_field32_set((r).vlan_xlate,19,35,f)
#define BCM53324_A0_VLAN_XLATEm_RESERVED_MASKf_GET(r) ((((r).vlan_xlate[1]) >> 4) & 0x1)
#define BCM53324_A0_VLAN_XLATEm_RESERVED_MASKf_SET(r,f) (r).vlan_xlate[1]=(((r).vlan_xlate[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53324_A0_VLAN_XLATEm_RPEf_GET(r) ((((r).vlan_xlate[1]) >> 5) & 0x1)
#define BCM53324_A0_VLAN_XLATEm_RPEf_SET(r,f) (r).vlan_xlate[1]=(((r).vlan_xlate[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53324_A0_VLAN_XLATEm_PRIf_GET(r) ((((r).vlan_xlate[1]) >> 6) & 0x7)
#define BCM53324_A0_VLAN_XLATEm_PRIf_SET(r,f) (r).vlan_xlate[1]=(((r).vlan_xlate[1] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53324_A0_VLAN_XLATEm_NEW_VLAN_IDf_GET(r) ((((r).vlan_xlate[1]) >> 9) & 0xfff)
#define BCM53324_A0_VLAN_XLATEm_NEW_VLAN_IDf_SET(r,f) (r).vlan_xlate[1]=(((r).vlan_xlate[1] & ~((uint32_t)0xfff << 9)) | ((((uint32_t)f) & 0xfff) << 9))
#define BCM53324_A0_VLAN_XLATEm_ADD_VIDf_GET(r) ((((r).vlan_xlate[1]) >> 21) & 0x1)
#define BCM53324_A0_VLAN_XLATEm_ADD_VIDf_SET(r,f) (r).vlan_xlate[1]=(((r).vlan_xlate[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))

/*
 * These macros can be used to access VLAN_XLATE.
 *
 */
#define BCM53324_A0_READ_VLAN_XLATEm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_XLATEm,i,(m._vlan_xlate),2)
#define BCM53324_A0_WRITE_VLAN_XLATEm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_XLATEm,i,&(m._vlan_xlate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATEm BCM53324_A0_VLAN_XLATEm
#define VLAN_XLATEm_MIN BCM53324_A0_VLAN_XLATEm_MIN
#define VLAN_XLATEm_MAX BCM53324_A0_VLAN_XLATEm_MAX
#define VLAN_XLATEm_CMAX(u) BCM53324_A0_VLAN_XLATEm_CMAX(u)
#define VLAN_XLATEm_SIZE BCM53324_A0_VLAN_XLATEm_SIZE
typedef BCM53324_A0_VLAN_XLATEm_t VLAN_XLATEm_t;
#define VLAN_XLATEm_CLR BCM53324_A0_VLAN_XLATEm_CLR
#define VLAN_XLATEm_SET BCM53324_A0_VLAN_XLATEm_SET
#define VLAN_XLATEm_GET BCM53324_A0_VLAN_XLATEm_GET
#define VLAN_XLATEm_VALIDf_GET BCM53324_A0_VLAN_XLATEm_VALIDf_GET
#define VLAN_XLATEm_VALIDf_SET BCM53324_A0_VLAN_XLATEm_VALIDf_SET
#define VLAN_XLATEm_INGRESS_PORTf_GET BCM53324_A0_VLAN_XLATEm_INGRESS_PORTf_GET
#define VLAN_XLATEm_INGRESS_PORTf_SET BCM53324_A0_VLAN_XLATEm_INGRESS_PORTf_SET
#define VLAN_XLATEm_PORTf_GET BCM53324_A0_VLAN_XLATEm_PORTf_GET
#define VLAN_XLATEm_PORTf_SET BCM53324_A0_VLAN_XLATEm_PORTf_SET
#define VLAN_XLATEm_OLD_VLAN_IDf_GET BCM53324_A0_VLAN_XLATEm_OLD_VLAN_IDf_GET
#define VLAN_XLATEm_OLD_VLAN_IDf_SET BCM53324_A0_VLAN_XLATEm_OLD_VLAN_IDf_SET
#define VLAN_XLATEm_VLAN_IDf_GET BCM53324_A0_VLAN_XLATEm_VLAN_IDf_GET
#define VLAN_XLATEm_VLAN_IDf_SET BCM53324_A0_VLAN_XLATEm_VLAN_IDf_SET
#define VLAN_XLATEm_RESERVED_KEYf_GET BCM53324_A0_VLAN_XLATEm_RESERVED_KEYf_GET
#define VLAN_XLATEm_RESERVED_KEYf_SET BCM53324_A0_VLAN_XLATEm_RESERVED_KEYf_SET
#define VLAN_XLATEm_MASKf_GET BCM53324_A0_VLAN_XLATEm_MASKf_GET
#define VLAN_XLATEm_MASKf_SET BCM53324_A0_VLAN_XLATEm_MASKf_SET
#define VLAN_XLATEm_RESERVED_MASKf_GET BCM53324_A0_VLAN_XLATEm_RESERVED_MASKf_GET
#define VLAN_XLATEm_RESERVED_MASKf_SET BCM53324_A0_VLAN_XLATEm_RESERVED_MASKf_SET
#define VLAN_XLATEm_RPEf_GET BCM53324_A0_VLAN_XLATEm_RPEf_GET
#define VLAN_XLATEm_RPEf_SET BCM53324_A0_VLAN_XLATEm_RPEf_SET
#define VLAN_XLATEm_PRIf_GET BCM53324_A0_VLAN_XLATEm_PRIf_GET
#define VLAN_XLATEm_PRIf_SET BCM53324_A0_VLAN_XLATEm_PRIf_SET
#define VLAN_XLATEm_NEW_VLAN_IDf_GET BCM53324_A0_VLAN_XLATEm_NEW_VLAN_IDf_GET
#define VLAN_XLATEm_NEW_VLAN_IDf_SET BCM53324_A0_VLAN_XLATEm_NEW_VLAN_IDf_SET
#define VLAN_XLATEm_ADD_VIDf_GET BCM53324_A0_VLAN_XLATEm_ADD_VIDf_GET
#define VLAN_XLATEm_ADD_VIDf_SET BCM53324_A0_VLAN_XLATEm_ADD_VIDf_SET
#define READ_VLAN_XLATEm BCM53324_A0_READ_VLAN_XLATEm
#define WRITE_VLAN_XLATEm BCM53324_A0_WRITE_VLAN_XLATEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_XLATEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_XLATE_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Data SRAM for VLAN_XLATE CAM. Data view only. Indexed using the match coming from the vlan_xlate CAM.
 * SIZE:     17
 * FIELDS:
 *     RPE              RPE bit
 *     PRI              Priority to be assigned
 *     NEW_VLAN_ID      VLAN ID to be assigned
 *     ADD_VID          Add the VLAN ID
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm 0x04780000

#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_MIN 0
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_MAX 15
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_CMAX(u) 15
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_XLATE_DATA_ONLY.
 *
 */
typedef union BCM53324_A0_VLAN_XLATE_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t vlan_xlate_data_only[1];
	uint32_t _vlan_xlate_data_only;
} BCM53324_A0_VLAN_XLATE_DATA_ONLYm_t;

#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_CLR(r) (r).vlan_xlate_data_only[0] = 0
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_SET(r,d) (r).vlan_xlate_data_only[0] = d
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_GET(r) (r).vlan_xlate_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_RPEf_GET(r) (((r).vlan_xlate_data_only[0]) & 0x1)
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_RPEf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_PRIf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 1) & 0x7)
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_PRIf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 4) & 0xfff)
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 16) & 0x1)
#define BCM53324_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access VLAN_XLATE_DATA_ONLY.
 *
 */
#define BCM53324_A0_READ_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_XLATE_DATA_ONLYm,i,(m._vlan_xlate_data_only),1)
#define BCM53324_A0_WRITE_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_XLATE_DATA_ONLYm,i,&(m._vlan_xlate_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_DATA_ONLYm BCM53324_A0_VLAN_XLATE_DATA_ONLYm
#define VLAN_XLATE_DATA_ONLYm_MIN BCM53324_A0_VLAN_XLATE_DATA_ONLYm_MIN
#define VLAN_XLATE_DATA_ONLYm_MAX BCM53324_A0_VLAN_XLATE_DATA_ONLYm_MAX
#define VLAN_XLATE_DATA_ONLYm_CMAX(u) BCM53324_A0_VLAN_XLATE_DATA_ONLYm_CMAX(u)
#define VLAN_XLATE_DATA_ONLYm_SIZE BCM53324_A0_VLAN_XLATE_DATA_ONLYm_SIZE
typedef BCM53324_A0_VLAN_XLATE_DATA_ONLYm_t VLAN_XLATE_DATA_ONLYm_t;
#define VLAN_XLATE_DATA_ONLYm_CLR BCM53324_A0_VLAN_XLATE_DATA_ONLYm_CLR
#define VLAN_XLATE_DATA_ONLYm_SET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_SET
#define VLAN_XLATE_DATA_ONLYm_GET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_GET
#define VLAN_XLATE_DATA_ONLYm_RPEf_GET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_RPEf_GET
#define VLAN_XLATE_DATA_ONLYm_RPEf_SET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_RPEf_SET
#define VLAN_XLATE_DATA_ONLYm_PRIf_GET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_PRIf_GET
#define VLAN_XLATE_DATA_ONLYm_PRIf_SET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_PRIf_SET
#define VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET
#define VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET
#define VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET
#define VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET BCM53324_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET
#define READ_VLAN_XLATE_DATA_ONLYm BCM53324_A0_READ_VLAN_XLATE_DATA_ONLYm
#define WRITE_VLAN_XLATE_DATA_ONLYm BCM53324_A0_WRITE_VLAN_XLATE_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_XLATE_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * MEMORY:  VLAN_XLATE_ONLY
 * BLOCKS:   IPIPE
 * DESC:     CAM for VLAN trans of tagged pkts. CAM view only.
 * SIZE:     37
 * FIELDS:
 *     VALID            Indicates that the entry is valid.
 *     INGRESS_PORT     Source port part of the key
 *     VLAN_ID          VLAN ID part of the key
 *     RESERVED_KEY     RESERVED BITS for extending ports later
 *     MASK             mask for the key{reserved, vlan_id, ingressport}
 *     RESERVED_MASK    Reserved bit in the mask.
 *
 ******************************************************************************/
#define BCM53324_A0_VLAN_XLATE_ONLYm 0x04770000

#define BCM53324_A0_VLAN_XLATE_ONLYm_MIN 0
#define BCM53324_A0_VLAN_XLATE_ONLYm_MAX 15
#define BCM53324_A0_VLAN_XLATE_ONLYm_CMAX(u) 15
#define BCM53324_A0_VLAN_XLATE_ONLYm_SIZE 5

/*
 * This structure should be used to declare and program VLAN_XLATE_ONLY.
 *
 */
typedef union BCM53324_A0_VLAN_XLATE_ONLYm_s {
	uint32_t v[2];
	uint32_t vlan_xlate_only[2];
	uint32_t _vlan_xlate_only;
} BCM53324_A0_VLAN_XLATE_ONLYm_t;

#define BCM53324_A0_VLAN_XLATE_ONLYm_CLR(r) CDK_MEMSET(&((r)._vlan_xlate_only), 0, sizeof(BCM53324_A0_VLAN_XLATE_ONLYm_t))
#define BCM53324_A0_VLAN_XLATE_ONLYm_SET(r,i,d) (r).vlan_xlate_only[i] = d
#define BCM53324_A0_VLAN_XLATE_ONLYm_GET(r,i) (r).vlan_xlate_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_VLAN_XLATE_ONLYm_VALIDf_GET(r) (((r).vlan_xlate_only[0]) & 0x1)
#define BCM53324_A0_VLAN_XLATE_ONLYm_VALIDf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_GET(r) ((((r).vlan_xlate_only[0]) >> 1) & 0x1f)
#define BCM53324_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM53324_A0_VLAN_XLATE_ONLYm_VLAN_IDf_GET(r) ((((r).vlan_xlate_only[0]) >> 6) & 0xfff)
#define BCM53324_A0_VLAN_XLATE_ONLYm_VLAN_IDf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM53324_A0_VLAN_XLATE_ONLYm_RESERVED_KEYf_GET(r) ((((r).vlan_xlate_only[0]) >> 18) & 0x1)
#define BCM53324_A0_VLAN_XLATE_ONLYm_RESERVED_KEYf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53324_A0_VLAN_XLATE_ONLYm_MASKf_GET(r) cdk_field32_get((r).vlan_xlate_only,19,35)
#define BCM53324_A0_VLAN_XLATE_ONLYm_MASKf_SET(r,f) cdk_field32_set((r).vlan_xlate_only,19,35,f)
#define BCM53324_A0_VLAN_XLATE_ONLYm_RESERVED_MASKf_GET(r) ((((r).vlan_xlate_only[1]) >> 4) & 0x1)
#define BCM53324_A0_VLAN_XLATE_ONLYm_RESERVED_MASKf_SET(r,f) (r).vlan_xlate_only[1]=(((r).vlan_xlate_only[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access VLAN_XLATE_ONLY.
 *
 */
#define BCM53324_A0_READ_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM53324_A0_VLAN_XLATE_ONLYm,i,(m._vlan_xlate_only),2)
#define BCM53324_A0_WRITE_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM53324_A0_VLAN_XLATE_ONLYm,i,&(m._vlan_xlate_only),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_ONLYm BCM53324_A0_VLAN_XLATE_ONLYm
#define VLAN_XLATE_ONLYm_MIN BCM53324_A0_VLAN_XLATE_ONLYm_MIN
#define VLAN_XLATE_ONLYm_MAX BCM53324_A0_VLAN_XLATE_ONLYm_MAX
#define VLAN_XLATE_ONLYm_CMAX(u) BCM53324_A0_VLAN_XLATE_ONLYm_CMAX(u)
#define VLAN_XLATE_ONLYm_SIZE BCM53324_A0_VLAN_XLATE_ONLYm_SIZE
typedef BCM53324_A0_VLAN_XLATE_ONLYm_t VLAN_XLATE_ONLYm_t;
#define VLAN_XLATE_ONLYm_CLR BCM53324_A0_VLAN_XLATE_ONLYm_CLR
#define VLAN_XLATE_ONLYm_SET BCM53324_A0_VLAN_XLATE_ONLYm_SET
#define VLAN_XLATE_ONLYm_GET BCM53324_A0_VLAN_XLATE_ONLYm_GET
#define VLAN_XLATE_ONLYm_VALIDf_GET BCM53324_A0_VLAN_XLATE_ONLYm_VALIDf_GET
#define VLAN_XLATE_ONLYm_VALIDf_SET BCM53324_A0_VLAN_XLATE_ONLYm_VALIDf_SET
#define VLAN_XLATE_ONLYm_INGRESS_PORTf_GET BCM53324_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_GET
#define VLAN_XLATE_ONLYm_INGRESS_PORTf_SET BCM53324_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_SET
#define VLAN_XLATE_ONLYm_VLAN_IDf_GET BCM53324_A0_VLAN_XLATE_ONLYm_VLAN_IDf_GET
#define VLAN_XLATE_ONLYm_VLAN_IDf_SET BCM53324_A0_VLAN_XLATE_ONLYm_VLAN_IDf_SET
#define VLAN_XLATE_ONLYm_RESERVED_KEYf_GET BCM53324_A0_VLAN_XLATE_ONLYm_RESERVED_KEYf_GET
#define VLAN_XLATE_ONLYm_RESERVED_KEYf_SET BCM53324_A0_VLAN_XLATE_ONLYm_RESERVED_KEYf_SET
#define VLAN_XLATE_ONLYm_MASKf_GET BCM53324_A0_VLAN_XLATE_ONLYm_MASKf_GET
#define VLAN_XLATE_ONLYm_MASKf_SET BCM53324_A0_VLAN_XLATE_ONLYm_MASKf_SET
#define VLAN_XLATE_ONLYm_RESERVED_MASKf_GET BCM53324_A0_VLAN_XLATE_ONLYm_RESERVED_MASKf_GET
#define VLAN_XLATE_ONLYm_RESERVED_MASKf_SET BCM53324_A0_VLAN_XLATE_ONLYm_RESERVED_MASKf_SET
#define READ_VLAN_XLATE_ONLYm BCM53324_A0_READ_VLAN_XLATE_ONLYm
#define WRITE_VLAN_XLATE_ONLYm BCM53324_A0_WRITE_VLAN_XLATE_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_VLAN_XLATE_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  WRRWEIGHT_COS
 * BLOCKS:   MMU
 * DESC:      WRR Weight for each COS
 * SIZE:     32
 * FIELDS:
 *     WEIGHT           When Weighted Round Robin is selected, this register cos Weightdefines how many packets can  be trasmitted in one run.If value is zero, this COS will be a pure priority scheduling.When Deficit Round Robin Queueing selects, this register is COS weight,Define how many bytes can  be trasmitted in one run. If value is zero, this COS will be a pure priority scheduling.COS7Weight= 0:   pure prioirty,COS7Weight= value between 1-127: this will be the multiplication factor with the chosen quanta    
 *     ENABLE           Enable Egress Scheduler to service this cos queue.0: disable,1: enable,
 *
 ******************************************************************************/
#define BCM53324_A0_WRRWEIGHT_COSr 0x00600062

#define BCM53324_A0_WRRWEIGHT_COSr_SIZE 4

/*
 * This structure should be used to declare and program WRRWEIGHT_COS.
 *
 */
typedef union BCM53324_A0_WRRWEIGHT_COSr_s {
	uint32_t v[1];
	uint32_t wrrweight_cos[1];
	uint32_t _wrrweight_cos;
} BCM53324_A0_WRRWEIGHT_COSr_t;

#define BCM53324_A0_WRRWEIGHT_COSr_CLR(r) (r).wrrweight_cos[0] = 0
#define BCM53324_A0_WRRWEIGHT_COSr_SET(r,d) (r).wrrweight_cos[0] = d
#define BCM53324_A0_WRRWEIGHT_COSr_GET(r) (r).wrrweight_cos[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_WRRWEIGHT_COSr_WEIGHTf_GET(r) (((r).wrrweight_cos[0]) & 0x7f)
#define BCM53324_A0_WRRWEIGHT_COSr_WEIGHTf_SET(r,f) (r).wrrweight_cos[0]=(((r).wrrweight_cos[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53324_A0_WRRWEIGHT_COSr_ENABLEf_GET(r) ((((r).wrrweight_cos[0]) >> 7) & 0x1)
#define BCM53324_A0_WRRWEIGHT_COSr_ENABLEf_SET(r,f) (r).wrrweight_cos[0]=(((r).wrrweight_cos[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access WRRWEIGHT_COS.
 *
 */
#define BCM53324_A0_READ_WRRWEIGHT_COSr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_WRRWEIGHT_COSr+(i),(r._wrrweight_cos))
#define BCM53324_A0_WRITE_WRRWEIGHT_COSr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_WRRWEIGHT_COSr+(i),&(r._wrrweight_cos))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WRRWEIGHT_COSr BCM53324_A0_WRRWEIGHT_COSr
#define WRRWEIGHT_COSr_SIZE BCM53324_A0_WRRWEIGHT_COSr_SIZE
typedef BCM53324_A0_WRRWEIGHT_COSr_t WRRWEIGHT_COSr_t;
#define WRRWEIGHT_COSr_CLR BCM53324_A0_WRRWEIGHT_COSr_CLR
#define WRRWEIGHT_COSr_SET BCM53324_A0_WRRWEIGHT_COSr_SET
#define WRRWEIGHT_COSr_GET BCM53324_A0_WRRWEIGHT_COSr_GET
#define WRRWEIGHT_COSr_WEIGHTf_GET BCM53324_A0_WRRWEIGHT_COSr_WEIGHTf_GET
#define WRRWEIGHT_COSr_WEIGHTf_SET BCM53324_A0_WRRWEIGHT_COSr_WEIGHTf_SET
#define WRRWEIGHT_COSr_ENABLEf_GET BCM53324_A0_WRRWEIGHT_COSr_ENABLEf_GET
#define WRRWEIGHT_COSr_ENABLEf_SET BCM53324_A0_WRRWEIGHT_COSr_ENABLEf_SET
#define READ_WRRWEIGHT_COSr BCM53324_A0_READ_WRRWEIGHT_COSr
#define WRITE_WRRWEIGHT_COSr BCM53324_A0_WRITE_WRRWEIGHT_COSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_WRRWEIGHT_COSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  XQCOSARBSEL
 * BLOCKS:   MMU
 * DESC:     Scheduler Control Selection
 * SIZE:     32
 * FIELDS:
 *     COSARB           Scheduler Control OptionscosArb[1:0]=0: Strict priority among valid COSs. (default value.)cosArb[1:0]=1: Round Robin Queueing among valid COSs.cosArb[1:0]=2: Weightd Round Robin Queueing, WRR, scheduling according to WRR Weight.cosArb[1:0]=3: Deficit Round Robin Queueing, DRR, scheduling according to WRR Weight.
 *     MTU_QUANTA_SELECT In WDRR mode, each weight is multiplied by MTU quanta which is defined by MTU_Quanta_Select:cosArb[3:2]=0: MTU Quanta is 2048 bytes. cosArb[3:2]=1: MTU Quanta is 4096 bytes.cosArb[3:2]=2: MTU Quanta is 8192 bytes.cosArb[3:2]=3: MTU Quanta is 16384 bytes(default value)
 *
 ******************************************************************************/
#define BCM53324_A0_XQCOSARBSELr 0x00600061

#define BCM53324_A0_XQCOSARBSELr_SIZE 4

/*
 * This structure should be used to declare and program XQCOSARBSEL.
 *
 */
typedef union BCM53324_A0_XQCOSARBSELr_s {
	uint32_t v[1];
	uint32_t xqcosarbsel[1];
	uint32_t _xqcosarbsel;
} BCM53324_A0_XQCOSARBSELr_t;

#define BCM53324_A0_XQCOSARBSELr_CLR(r) (r).xqcosarbsel[0] = 0
#define BCM53324_A0_XQCOSARBSELr_SET(r,d) (r).xqcosarbsel[0] = d
#define BCM53324_A0_XQCOSARBSELr_GET(r) (r).xqcosarbsel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_XQCOSARBSELr_COSARBf_GET(r) (((r).xqcosarbsel[0]) & 0x3)
#define BCM53324_A0_XQCOSARBSELr_COSARBf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53324_A0_XQCOSARBSELr_MTU_QUANTA_SELECTf_GET(r) ((((r).xqcosarbsel[0]) >> 2) & 0x3)
#define BCM53324_A0_XQCOSARBSELr_MTU_QUANTA_SELECTf_SET(r,f) (r).xqcosarbsel[0]=(((r).xqcosarbsel[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))

/*
 * These macros can be used to access XQCOSARBSEL.
 *
 */
#define BCM53324_A0_READ_XQCOSARBSELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_XQCOSARBSELr,(r._xqcosarbsel))
#define BCM53324_A0_WRITE_XQCOSARBSELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_XQCOSARBSELr,&(r._xqcosarbsel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQCOSARBSELr BCM53324_A0_XQCOSARBSELr
#define XQCOSARBSELr_SIZE BCM53324_A0_XQCOSARBSELr_SIZE
typedef BCM53324_A0_XQCOSARBSELr_t XQCOSARBSELr_t;
#define XQCOSARBSELr_CLR BCM53324_A0_XQCOSARBSELr_CLR
#define XQCOSARBSELr_SET BCM53324_A0_XQCOSARBSELr_SET
#define XQCOSARBSELr_GET BCM53324_A0_XQCOSARBSELr_GET
#define XQCOSARBSELr_COSARBf_GET BCM53324_A0_XQCOSARBSELr_COSARBf_GET
#define XQCOSARBSELr_COSARBf_SET BCM53324_A0_XQCOSARBSELr_COSARBf_SET
#define XQCOSARBSELr_MTU_QUANTA_SELECTf_GET BCM53324_A0_XQCOSARBSELr_MTU_QUANTA_SELECTf_GET
#define XQCOSARBSELr_MTU_QUANTA_SELECTf_SET BCM53324_A0_XQCOSARBSELr_MTU_QUANTA_SELECTf_SET
#define READ_XQCOSARBSELr BCM53324_A0_READ_XQCOSARBSELr
#define WRITE_XQCOSARBSELr BCM53324_A0_WRITE_XQCOSARBSELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_XQCOSARBSELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  XQCOSPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TAILPOINTER      Tail pointer of COS. Tail pointer is used to write a queue.
 *     HEADPOINTER      Head pointer of COS.Head pointer is used to read from a queue
 *     COS              COS value of XQ pointer. This will be used to read head and tail pointer. COS=4 will give free list pointers.
 *
 ******************************************************************************/
#define BCM53324_A0_XQCOSPTRr 0x00600070

#define BCM53324_A0_XQCOSPTRr_SIZE 4

/*
 * This structure should be used to declare and program XQCOSPTR.
 *
 */
typedef union BCM53324_A0_XQCOSPTRr_s {
	uint32_t v[1];
	uint32_t xqcosptr[1];
	uint32_t _xqcosptr;
} BCM53324_A0_XQCOSPTRr_t;

#define BCM53324_A0_XQCOSPTRr_CLR(r) (r).xqcosptr[0] = 0
#define BCM53324_A0_XQCOSPTRr_SET(r,d) (r).xqcosptr[0] = d
#define BCM53324_A0_XQCOSPTRr_GET(r) (r).xqcosptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_XQCOSPTRr_TAILPOINTERf_GET(r) (((r).xqcosptr[0]) & 0x7ff)
#define BCM53324_A0_XQCOSPTRr_TAILPOINTERf_SET(r,f) (r).xqcosptr[0]=(((r).xqcosptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_XQCOSPTRr_HEADPOINTERf_GET(r) ((((r).xqcosptr[0]) >> 11) & 0x7ff)
#define BCM53324_A0_XQCOSPTRr_HEADPOINTERf_SET(r,f) (r).xqcosptr[0]=(((r).xqcosptr[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))
#define BCM53324_A0_XQCOSPTRr_COSf_GET(r) ((((r).xqcosptr[0]) >> 22) & 0xf)
#define BCM53324_A0_XQCOSPTRr_COSf_SET(r,f) (r).xqcosptr[0]=(((r).xqcosptr[0] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))

/*
 * These macros can be used to access XQCOSPTR.
 *
 */
#define BCM53324_A0_READ_XQCOSPTRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_XQCOSPTRr,(r._xqcosptr))
#define BCM53324_A0_WRITE_XQCOSPTRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_XQCOSPTRr,&(r._xqcosptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQCOSPTRr BCM53324_A0_XQCOSPTRr
#define XQCOSPTRr_SIZE BCM53324_A0_XQCOSPTRr_SIZE
typedef BCM53324_A0_XQCOSPTRr_t XQCOSPTRr_t;
#define XQCOSPTRr_CLR BCM53324_A0_XQCOSPTRr_CLR
#define XQCOSPTRr_SET BCM53324_A0_XQCOSPTRr_SET
#define XQCOSPTRr_GET BCM53324_A0_XQCOSPTRr_GET
#define XQCOSPTRr_TAILPOINTERf_GET BCM53324_A0_XQCOSPTRr_TAILPOINTERf_GET
#define XQCOSPTRr_TAILPOINTERf_SET BCM53324_A0_XQCOSPTRr_TAILPOINTERf_SET
#define XQCOSPTRr_HEADPOINTERf_GET BCM53324_A0_XQCOSPTRr_HEADPOINTERf_GET
#define XQCOSPTRr_HEADPOINTERf_SET BCM53324_A0_XQCOSPTRr_HEADPOINTERf_SET
#define XQCOSPTRr_COSf_GET BCM53324_A0_XQCOSPTRr_COSf_GET
#define XQCOSPTRr_COSf_SET BCM53324_A0_XQCOSPTRr_COSf_SET
#define READ_XQCOSPTRr BCM53324_A0_READ_XQCOSPTRr
#define WRITE_XQCOSPTRr BCM53324_A0_WRITE_XQCOSPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_XQCOSPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  XQEMPTY
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     COS0             COS0 has no entries for this port
 *     COS1             COS1 has no entries for this port
 *     COS2             COS2 has no entries for this port
 *     COS3             COS3 has no entries for this port
 *
 ******************************************************************************/
#define BCM53324_A0_XQEMPTYr 0x0060005e

#define BCM53324_A0_XQEMPTYr_SIZE 4

/*
 * This structure should be used to declare and program XQEMPTY.
 *
 */
typedef union BCM53324_A0_XQEMPTYr_s {
	uint32_t v[1];
	uint32_t xqempty[1];
	uint32_t _xqempty;
} BCM53324_A0_XQEMPTYr_t;

#define BCM53324_A0_XQEMPTYr_CLR(r) (r).xqempty[0] = 0
#define BCM53324_A0_XQEMPTYr_SET(r,d) (r).xqempty[0] = d
#define BCM53324_A0_XQEMPTYr_GET(r) (r).xqempty[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_XQEMPTYr_COS0f_GET(r) (((r).xqempty[0]) & 0x1)
#define BCM53324_A0_XQEMPTYr_COS0f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53324_A0_XQEMPTYr_COS1f_GET(r) ((((r).xqempty[0]) >> 1) & 0x1)
#define BCM53324_A0_XQEMPTYr_COS1f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53324_A0_XQEMPTYr_COS2f_GET(r) ((((r).xqempty[0]) >> 2) & 0x1)
#define BCM53324_A0_XQEMPTYr_COS2f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53324_A0_XQEMPTYr_COS3f_GET(r) ((((r).xqempty[0]) >> 3) & 0x1)
#define BCM53324_A0_XQEMPTYr_COS3f_SET(r,f) (r).xqempty[0]=(((r).xqempty[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access XQEMPTY.
 *
 */
#define BCM53324_A0_READ_XQEMPTYr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_XQEMPTYr,(r._xqempty))
#define BCM53324_A0_WRITE_XQEMPTYr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_XQEMPTYr,&(r._xqempty))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQEMPTYr BCM53324_A0_XQEMPTYr
#define XQEMPTYr_SIZE BCM53324_A0_XQEMPTYr_SIZE
typedef BCM53324_A0_XQEMPTYr_t XQEMPTYr_t;
#define XQEMPTYr_CLR BCM53324_A0_XQEMPTYr_CLR
#define XQEMPTYr_SET BCM53324_A0_XQEMPTYr_SET
#define XQEMPTYr_GET BCM53324_A0_XQEMPTYr_GET
#define XQEMPTYr_COS0f_GET BCM53324_A0_XQEMPTYr_COS0f_GET
#define XQEMPTYr_COS0f_SET BCM53324_A0_XQEMPTYr_COS0f_SET
#define XQEMPTYr_COS1f_GET BCM53324_A0_XQEMPTYr_COS1f_GET
#define XQEMPTYr_COS1f_SET BCM53324_A0_XQEMPTYr_COS1f_SET
#define XQEMPTYr_COS2f_GET BCM53324_A0_XQEMPTYr_COS2f_GET
#define XQEMPTYr_COS2f_SET BCM53324_A0_XQEMPTYr_COS2f_SET
#define XQEMPTYr_COS3f_GET BCM53324_A0_XQEMPTYr_COS3f_GET
#define XQEMPTYr_COS3f_SET BCM53324_A0_XQEMPTYr_COS3f_SET
#define READ_XQEMPTYr BCM53324_A0_READ_XQEMPTYr
#define WRITE_XQEMPTYr BCM53324_A0_WRITE_XQEMPTYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_XQEMPTYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  XQMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm 
 *     WW               Weak Write 
 *
 ******************************************************************************/
#define BCM53324_A0_XQMEMDEBUGr 0x00600071

#define BCM53324_A0_XQMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program XQMEMDEBUG.
 *
 */
typedef union BCM53324_A0_XQMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t xqmemdebug[1];
	uint32_t _xqmemdebug;
} BCM53324_A0_XQMEMDEBUGr_t;

#define BCM53324_A0_XQMEMDEBUGr_CLR(r) (r).xqmemdebug[0] = 0
#define BCM53324_A0_XQMEMDEBUGr_SET(r,d) (r).xqmemdebug[0] = d
#define BCM53324_A0_XQMEMDEBUGr_GET(r) (r).xqmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_XQMEMDEBUGr_TMf_GET(r) (((r).xqmemdebug[0]) & 0xff)
#define BCM53324_A0_XQMEMDEBUGr_TMf_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53324_A0_XQMEMDEBUGr_WWf_GET(r) ((((r).xqmemdebug[0]) >> 8) & 0x1)
#define BCM53324_A0_XQMEMDEBUGr_WWf_SET(r,f) (r).xqmemdebug[0]=(((r).xqmemdebug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access XQMEMDEBUG.
 *
 */
#define BCM53324_A0_READ_XQMEMDEBUGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_XQMEMDEBUGr,(r._xqmemdebug))
#define BCM53324_A0_WRITE_XQMEMDEBUGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_XQMEMDEBUGr,&(r._xqmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQMEMDEBUGr BCM53324_A0_XQMEMDEBUGr
#define XQMEMDEBUGr_SIZE BCM53324_A0_XQMEMDEBUGr_SIZE
typedef BCM53324_A0_XQMEMDEBUGr_t XQMEMDEBUGr_t;
#define XQMEMDEBUGr_CLR BCM53324_A0_XQMEMDEBUGr_CLR
#define XQMEMDEBUGr_SET BCM53324_A0_XQMEMDEBUGr_SET
#define XQMEMDEBUGr_GET BCM53324_A0_XQMEMDEBUGr_GET
#define XQMEMDEBUGr_TMf_GET BCM53324_A0_XQMEMDEBUGr_TMf_GET
#define XQMEMDEBUGr_TMf_SET BCM53324_A0_XQMEMDEBUGr_TMf_SET
#define XQMEMDEBUGr_WWf_GET BCM53324_A0_XQMEMDEBUGr_WWf_GET
#define XQMEMDEBUGr_WWf_SET BCM53324_A0_XQMEMDEBUGr_WWf_SET
#define READ_XQMEMDEBUGr BCM53324_A0_READ_XQMEMDEBUGr
#define WRITE_XQMEMDEBUGr BCM53324_A0_WRITE_XQMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_XQMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  XQPARITYERRORPBM
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     XQPARITYERRORPBM Egress Port Bitmap indicats which egress port detects XQ parity error.
 *
 ******************************************************************************/
#define BCM53324_A0_XQPARITYERRORPBMr 0x0068002d

#define BCM53324_A0_XQPARITYERRORPBMr_SIZE 4

/*
 * This structure should be used to declare and program XQPARITYERRORPBM.
 *
 */
typedef union BCM53324_A0_XQPARITYERRORPBMr_s {
	uint32_t v[1];
	uint32_t xqparityerrorpbm[1];
	uint32_t _xqparityerrorpbm;
} BCM53324_A0_XQPARITYERRORPBMr_t;

#define BCM53324_A0_XQPARITYERRORPBMr_CLR(r) (r).xqparityerrorpbm[0] = 0
#define BCM53324_A0_XQPARITYERRORPBMr_SET(r,d) (r).xqparityerrorpbm[0] = d
#define BCM53324_A0_XQPARITYERRORPBMr_GET(r) (r).xqparityerrorpbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET(r) (((r).xqparityerrorpbm[0]) & 0x1ffffff)
#define BCM53324_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET(r,f) (r).xqparityerrorpbm[0]=(((r).xqparityerrorpbm[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access XQPARITYERRORPBM.
 *
 */
#define BCM53324_A0_READ_XQPARITYERRORPBMr(u,r) cdk_xgs_reg32_read(u,BCM53324_A0_XQPARITYERRORPBMr,(r._xqparityerrorpbm))
#define BCM53324_A0_WRITE_XQPARITYERRORPBMr(u,r) cdk_xgs_reg32_write(u,BCM53324_A0_XQPARITYERRORPBMr,&(r._xqparityerrorpbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQPARITYERRORPBMr BCM53324_A0_XQPARITYERRORPBMr
#define XQPARITYERRORPBMr_SIZE BCM53324_A0_XQPARITYERRORPBMr_SIZE
typedef BCM53324_A0_XQPARITYERRORPBMr_t XQPARITYERRORPBMr_t;
#define XQPARITYERRORPBMr_CLR BCM53324_A0_XQPARITYERRORPBMr_CLR
#define XQPARITYERRORPBMr_SET BCM53324_A0_XQPARITYERRORPBMr_SET
#define XQPARITYERRORPBMr_GET BCM53324_A0_XQPARITYERRORPBMr_GET
#define XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET BCM53324_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_GET
#define XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET BCM53324_A0_XQPARITYERRORPBMr_XQPARITYERRORPBMf_SET
#define READ_XQPARITYERRORPBMr BCM53324_A0_READ_XQPARITYERRORPBMr
#define WRITE_XQPARITYERRORPBMr BCM53324_A0_WRITE_XQPARITYERRORPBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_XQPARITYERRORPBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  XQPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     XQPARITYERRORPTR Egress Port XQ's parity error packet pointer keeps the abandonedxq parity errored memory address.
 *     XQPARITYERRORPKTPTR Egress Port XQ's parity error packet pointer keeps the abandonedxq parity errored memory read data's packet pointer.
 *     XQPARITYERRORTYPE XQ parity error type.[28] : 1'b0 : error occured on XQ port0, 1'b1: error occured on XQ port1[27] : 2 bit ECC error detected.[26] : 1 bit ECC error detected.[25] : data parity error detected.
 *
 ******************************************************************************/
#define BCM53324_A0_XQPARITYERRORPTRr 0x0060006f

#define BCM53324_A0_XQPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program XQPARITYERRORPTR.
 *
 */
typedef union BCM53324_A0_XQPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t xqparityerrorptr[1];
	uint32_t _xqparityerrorptr;
} BCM53324_A0_XQPARITYERRORPTRr_t;

#define BCM53324_A0_XQPARITYERRORPTRr_CLR(r) (r).xqparityerrorptr[0] = 0
#define BCM53324_A0_XQPARITYERRORPTRr_SET(r,d) (r).xqparityerrorptr[0] = d
#define BCM53324_A0_XQPARITYERRORPTRr_GET(r) (r).xqparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET(r) (((r).xqparityerrorptr[0]) & 0x1ff)
#define BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET(r,f) (r).xqparityerrorptr[0]=(((r).xqparityerrorptr[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET(r) ((((r).xqparityerrorptr[0]) >> 9) & 0xfff)
#define BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET(r,f) (r).xqparityerrorptr[0]=(((r).xqparityerrorptr[0] & ~((uint32_t)0xfff << 9)) | ((((uint32_t)f) & 0xfff) << 9))
#define BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORTYPEf_GET(r) ((((r).xqparityerrorptr[0]) >> 21) & 0xf)
#define BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORTYPEf_SET(r,f) (r).xqparityerrorptr[0]=(((r).xqparityerrorptr[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))

/*
 * These macros can be used to access XQPARITYERRORPTR.
 *
 */
#define BCM53324_A0_READ_XQPARITYERRORPTRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_XQPARITYERRORPTRr,(r._xqparityerrorptr))
#define BCM53324_A0_WRITE_XQPARITYERRORPTRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_XQPARITYERRORPTRr,&(r._xqparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQPARITYERRORPTRr BCM53324_A0_XQPARITYERRORPTRr
#define XQPARITYERRORPTRr_SIZE BCM53324_A0_XQPARITYERRORPTRr_SIZE
typedef BCM53324_A0_XQPARITYERRORPTRr_t XQPARITYERRORPTRr_t;
#define XQPARITYERRORPTRr_CLR BCM53324_A0_XQPARITYERRORPTRr_CLR
#define XQPARITYERRORPTRr_SET BCM53324_A0_XQPARITYERRORPTRr_SET
#define XQPARITYERRORPTRr_GET BCM53324_A0_XQPARITYERRORPTRr_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORPTRf_SET
#define XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_GET
#define XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORPKTPTRf_SET
#define XQPARITYERRORPTRr_XQPARITYERRORTYPEf_GET BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORTYPEf_GET
#define XQPARITYERRORPTRr_XQPARITYERRORTYPEf_SET BCM53324_A0_XQPARITYERRORPTRr_XQPARITYERRORTYPEf_SET
#define READ_XQPARITYERRORPTRr BCM53324_A0_READ_XQPARITYERRORPTRr
#define WRITE_XQPARITYERRORPTRr BCM53324_A0_WRITE_XQPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_XQPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53324_A0
 * REGISTER:  XQREADPOINTER
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     READPOINTER       Current read address of XQ memory.
 *     COS              Currnet COS of XQ read pointer.
 *
 ******************************************************************************/
#define BCM53324_A0_XQREADPOINTERr 0x0060005f

#define BCM53324_A0_XQREADPOINTERr_SIZE 4

/*
 * This structure should be used to declare and program XQREADPOINTER.
 *
 */
typedef union BCM53324_A0_XQREADPOINTERr_s {
	uint32_t v[1];
	uint32_t xqreadpointer[1];
	uint32_t _xqreadpointer;
} BCM53324_A0_XQREADPOINTERr_t;

#define BCM53324_A0_XQREADPOINTERr_CLR(r) (r).xqreadpointer[0] = 0
#define BCM53324_A0_XQREADPOINTERr_SET(r,d) (r).xqreadpointer[0] = d
#define BCM53324_A0_XQREADPOINTERr_GET(r) (r).xqreadpointer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53324_A0_XQREADPOINTERr_READPOINTERf_GET(r) (((r).xqreadpointer[0]) & 0x7ff)
#define BCM53324_A0_XQREADPOINTERr_READPOINTERf_SET(r,f) (r).xqreadpointer[0]=(((r).xqreadpointer[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53324_A0_XQREADPOINTERr_COSf_GET(r) ((((r).xqreadpointer[0]) >> 11) & 0x7)
#define BCM53324_A0_XQREADPOINTERr_COSf_SET(r,f) (r).xqreadpointer[0]=(((r).xqreadpointer[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))

/*
 * These macros can be used to access XQREADPOINTER.
 *
 */
#define BCM53324_A0_READ_XQREADPOINTERr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM53324_A0_XQREADPOINTERr,(r._xqreadpointer))
#define BCM53324_A0_WRITE_XQREADPOINTERr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM53324_A0_XQREADPOINTERr,&(r._xqreadpointer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XQREADPOINTERr BCM53324_A0_XQREADPOINTERr
#define XQREADPOINTERr_SIZE BCM53324_A0_XQREADPOINTERr_SIZE
typedef BCM53324_A0_XQREADPOINTERr_t XQREADPOINTERr_t;
#define XQREADPOINTERr_CLR BCM53324_A0_XQREADPOINTERr_CLR
#define XQREADPOINTERr_SET BCM53324_A0_XQREADPOINTERr_SET
#define XQREADPOINTERr_GET BCM53324_A0_XQREADPOINTERr_GET
#define XQREADPOINTERr_READPOINTERf_GET BCM53324_A0_XQREADPOINTERr_READPOINTERf_GET
#define XQREADPOINTERr_READPOINTERf_SET BCM53324_A0_XQREADPOINTERr_READPOINTERf_SET
#define XQREADPOINTERr_COSf_GET BCM53324_A0_XQREADPOINTERr_COSf_GET
#define XQREADPOINTERr_COSf_SET BCM53324_A0_XQREADPOINTERr_COSf_SET
#define READ_XQREADPOINTERr BCM53324_A0_READ_XQREADPOINTERr
#define WRITE_XQREADPOINTERr BCM53324_A0_WRITE_XQREADPOINTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53324_A0_XQREADPOINTERr'
 ******************************************************************************/




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM53324_A0_DEFS_H__ */
