#ifndef __BCM53115_A0_DEFS_H__
#define __BCM53115_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM53115_A0.
 * This file provides all basic definitions required to program the BCM53115_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/robo_reg.h>
#include <cdk/arch/robo_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CPIC/IMP port */
#define BCM53115_A0_CPIC_PORT           8

/* Additional block types */
#define BCM53115_A0_BLKTYPE_CPIC        0
#define BCM53115_A0_BLKTYPE_EXP         1
#define BCM53115_A0_BLKTYPE_GPIC        2
#define BCM53115_A0_BLKTYPE_SPI         3
#define BCM53115_A0_BLKTYPE_SYS         4


#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPIC_PORT                       BCM53115_A0_CPIC_PORT

#define BLKTYPE_CPIC                    BCM53115_A0_BLKTYPE_CPIC
#define BLKTYPE_EXP                     BCM53115_A0_BLKTYPE_EXP
#define BLKTYPE_GPIC                    BCM53115_A0_BLKTYPE_GPIC
#define BLKTYPE_SPI                     BCM53115_A0_BLKTYPE_SPI
#define BLKTYPE_SYS                     BCM53115_A0_BLKTYPE_SYS


#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ACT_POL_DATA0
 * BLOCKS:   SYS
 * DESC:     CFP Action/Policy Data 0 Registers
 * SIZE:     32
 * FIELDS:
 *     DST_MAP_IB       
 *     CHANGE_FWRD_MAP_IB 
 *     NEW_DSCP_IB      
 *     CHANGE_DSCP_IB   
 *     DST_MAP_OB       
 *     CHANGE_FWRD_MAP_OB 
 *     NEW_DSCP_OB      
 *     CHANGE_DSCP_OB   
 *
 ******************************************************************************/
#define BCM53115_A0_ACT_POL_DATA0r 0x0000a050

#define BCM53115_A0_ACT_POL_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program ACT_POL_DATA0.
 *
 */
typedef union BCM53115_A0_ACT_POL_DATA0r_s {
	uint32_t v[1];
	uint32_t act_pol_data0[1];
	uint32_t _act_pol_data0;
} BCM53115_A0_ACT_POL_DATA0r_t;

#define BCM53115_A0_ACT_POL_DATA0r_CLR(r) (r).act_pol_data0[0] = 0
#define BCM53115_A0_ACT_POL_DATA0r_SET(r,d) (r).act_pol_data0[0] = d
#define BCM53115_A0_ACT_POL_DATA0r_GET(r) (r).act_pol_data0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ACT_POL_DATA0r_DST_MAP_IBf_GET(r) (((r).act_pol_data0[0]) & 0x7f)
#define BCM53115_A0_ACT_POL_DATA0r_DST_MAP_IBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53115_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_GET(r) ((((r).act_pol_data0[0]) >> 7) & 0x3)
#define BCM53115_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53115_A0_ACT_POL_DATA0r_NEW_DSCP_IBf_GET(r) ((((r).act_pol_data0[0]) >> 9) & 0x3f)
#define BCM53115_A0_ACT_POL_DATA0r_NEW_DSCP_IBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM53115_A0_ACT_POL_DATA0r_CHANGE_DSCP_IBf_GET(r) ((((r).act_pol_data0[0]) >> 15) & 0x1)
#define BCM53115_A0_ACT_POL_DATA0r_CHANGE_DSCP_IBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_ACT_POL_DATA0r_DST_MAP_OBf_GET(r) ((((r).act_pol_data0[0]) >> 16) & 0x7f)
#define BCM53115_A0_ACT_POL_DATA0r_DST_MAP_OBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define BCM53115_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_OBf_GET(r) ((((r).act_pol_data0[0]) >> 23) & 0x3)
#define BCM53115_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_OBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x3 << 23)) | ((((uint32_t)f) & 0x3) << 23))
#define BCM53115_A0_ACT_POL_DATA0r_NEW_DSCP_OBf_GET(r) ((((r).act_pol_data0[0]) >> 25) & 0x3f)
#define BCM53115_A0_ACT_POL_DATA0r_NEW_DSCP_OBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x3f << 25)) | ((((uint32_t)f) & 0x3f) << 25))
#define BCM53115_A0_ACT_POL_DATA0r_CHANGE_DSCP_OBf_GET(r) ((((r).act_pol_data0[0]) >> 31) & 0x1)
#define BCM53115_A0_ACT_POL_DATA0r_CHANGE_DSCP_OBf_SET(r,f) (r).act_pol_data0[0]=(((r).act_pol_data0[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ACT_POL_DATA0.
 *
 */
#define BCM53115_A0_READ_ACT_POL_DATA0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ACT_POL_DATA0r,(r._act_pol_data0),4)
#define BCM53115_A0_WRITE_ACT_POL_DATA0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ACT_POL_DATA0r,&(r._act_pol_data0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ACT_POL_DATA0r BCM53115_A0_ACT_POL_DATA0r
#define ACT_POL_DATA0r_SIZE BCM53115_A0_ACT_POL_DATA0r_SIZE
typedef BCM53115_A0_ACT_POL_DATA0r_t ACT_POL_DATA0r_t;
#define ACT_POL_DATA0r_CLR BCM53115_A0_ACT_POL_DATA0r_CLR
#define ACT_POL_DATA0r_SET BCM53115_A0_ACT_POL_DATA0r_SET
#define ACT_POL_DATA0r_GET BCM53115_A0_ACT_POL_DATA0r_GET
#define ACT_POL_DATA0r_DST_MAP_IBf_GET BCM53115_A0_ACT_POL_DATA0r_DST_MAP_IBf_GET
#define ACT_POL_DATA0r_DST_MAP_IBf_SET BCM53115_A0_ACT_POL_DATA0r_DST_MAP_IBf_SET
#define ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_GET BCM53115_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_GET
#define ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_SET BCM53115_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_IBf_SET
#define ACT_POL_DATA0r_NEW_DSCP_IBf_GET BCM53115_A0_ACT_POL_DATA0r_NEW_DSCP_IBf_GET
#define ACT_POL_DATA0r_NEW_DSCP_IBf_SET BCM53115_A0_ACT_POL_DATA0r_NEW_DSCP_IBf_SET
#define ACT_POL_DATA0r_CHANGE_DSCP_IBf_GET BCM53115_A0_ACT_POL_DATA0r_CHANGE_DSCP_IBf_GET
#define ACT_POL_DATA0r_CHANGE_DSCP_IBf_SET BCM53115_A0_ACT_POL_DATA0r_CHANGE_DSCP_IBf_SET
#define ACT_POL_DATA0r_DST_MAP_OBf_GET BCM53115_A0_ACT_POL_DATA0r_DST_MAP_OBf_GET
#define ACT_POL_DATA0r_DST_MAP_OBf_SET BCM53115_A0_ACT_POL_DATA0r_DST_MAP_OBf_SET
#define ACT_POL_DATA0r_CHANGE_FWRD_MAP_OBf_GET BCM53115_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_OBf_GET
#define ACT_POL_DATA0r_CHANGE_FWRD_MAP_OBf_SET BCM53115_A0_ACT_POL_DATA0r_CHANGE_FWRD_MAP_OBf_SET
#define ACT_POL_DATA0r_NEW_DSCP_OBf_GET BCM53115_A0_ACT_POL_DATA0r_NEW_DSCP_OBf_GET
#define ACT_POL_DATA0r_NEW_DSCP_OBf_SET BCM53115_A0_ACT_POL_DATA0r_NEW_DSCP_OBf_SET
#define ACT_POL_DATA0r_CHANGE_DSCP_OBf_GET BCM53115_A0_ACT_POL_DATA0r_CHANGE_DSCP_OBf_GET
#define ACT_POL_DATA0r_CHANGE_DSCP_OBf_SET BCM53115_A0_ACT_POL_DATA0r_CHANGE_DSCP_OBf_SET
#define READ_ACT_POL_DATA0r BCM53115_A0_READ_ACT_POL_DATA0r
#define WRITE_ACT_POL_DATA0r BCM53115_A0_WRITE_ACT_POL_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ACT_POL_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ACT_POL_DATA1
 * BLOCKS:   SYS
 * DESC:     CFP Action/Policy Data 1 Registers
 * SIZE:     32
 * FIELDS:
 *     VLAN_BYP         
 *     EAP_BYP          
 *     STP_BYP          
 *     REASON_CODE      
 *     LOOP_BK_EN       
 *     NEW_TC           
 *     CHANGE_TC        
 *     CHAIN_ID         
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ACT_POL_DATA1r 0x0000a054

#define BCM53115_A0_ACT_POL_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program ACT_POL_DATA1.
 *
 */
typedef union BCM53115_A0_ACT_POL_DATA1r_s {
	uint32_t v[1];
	uint32_t act_pol_data1[1];
	uint32_t _act_pol_data1;
} BCM53115_A0_ACT_POL_DATA1r_t;

#define BCM53115_A0_ACT_POL_DATA1r_CLR(r) (r).act_pol_data1[0] = 0
#define BCM53115_A0_ACT_POL_DATA1r_SET(r,d) (r).act_pol_data1[0] = d
#define BCM53115_A0_ACT_POL_DATA1r_GET(r) (r).act_pol_data1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ACT_POL_DATA1r_VLAN_BYPf_GET(r) (((r).act_pol_data1[0]) & 0x1)
#define BCM53115_A0_ACT_POL_DATA1r_VLAN_BYPf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_ACT_POL_DATA1r_EAP_BYPf_GET(r) ((((r).act_pol_data1[0]) >> 1) & 0x1)
#define BCM53115_A0_ACT_POL_DATA1r_EAP_BYPf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_ACT_POL_DATA1r_STP_BYPf_GET(r) ((((r).act_pol_data1[0]) >> 2) & 0x1)
#define BCM53115_A0_ACT_POL_DATA1r_STP_BYPf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_ACT_POL_DATA1r_REASON_CODEf_GET(r) ((((r).act_pol_data1[0]) >> 3) & 0x3f)
#define BCM53115_A0_ACT_POL_DATA1r_REASON_CODEf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM53115_A0_ACT_POL_DATA1r_LOOP_BK_ENf_GET(r) ((((r).act_pol_data1[0]) >> 9) & 0x1)
#define BCM53115_A0_ACT_POL_DATA1r_LOOP_BK_ENf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_ACT_POL_DATA1r_NEW_TCf_GET(r) ((((r).act_pol_data1[0]) >> 10) & 0x7)
#define BCM53115_A0_ACT_POL_DATA1r_NEW_TCf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53115_A0_ACT_POL_DATA1r_CHANGE_TCf_GET(r) ((((r).act_pol_data1[0]) >> 13) & 0x1)
#define BCM53115_A0_ACT_POL_DATA1r_CHANGE_TCf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_ACT_POL_DATA1r_CHAIN_IDf_GET(r) ((((r).act_pol_data1[0]) >> 14) & 0xff)
#define BCM53115_A0_ACT_POL_DATA1r_CHAIN_IDf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0xff << 14)) | ((((uint32_t)f) & 0xff) << 14))
#define BCM53115_A0_ACT_POL_DATA1r_RESERVED_1Rf_GET(r) ((((r).act_pol_data1[0]) >> 22) & 0x3ff)
#define BCM53115_A0_ACT_POL_DATA1r_RESERVED_1Rf_SET(r,f) (r).act_pol_data1[0]=(((r).act_pol_data1[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access ACT_POL_DATA1.
 *
 */
#define BCM53115_A0_READ_ACT_POL_DATA1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ACT_POL_DATA1r,(r._act_pol_data1),4)
#define BCM53115_A0_WRITE_ACT_POL_DATA1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ACT_POL_DATA1r,&(r._act_pol_data1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ACT_POL_DATA1r BCM53115_A0_ACT_POL_DATA1r
#define ACT_POL_DATA1r_SIZE BCM53115_A0_ACT_POL_DATA1r_SIZE
typedef BCM53115_A0_ACT_POL_DATA1r_t ACT_POL_DATA1r_t;
#define ACT_POL_DATA1r_CLR BCM53115_A0_ACT_POL_DATA1r_CLR
#define ACT_POL_DATA1r_SET BCM53115_A0_ACT_POL_DATA1r_SET
#define ACT_POL_DATA1r_GET BCM53115_A0_ACT_POL_DATA1r_GET
#define ACT_POL_DATA1r_VLAN_BYPf_GET BCM53115_A0_ACT_POL_DATA1r_VLAN_BYPf_GET
#define ACT_POL_DATA1r_VLAN_BYPf_SET BCM53115_A0_ACT_POL_DATA1r_VLAN_BYPf_SET
#define ACT_POL_DATA1r_EAP_BYPf_GET BCM53115_A0_ACT_POL_DATA1r_EAP_BYPf_GET
#define ACT_POL_DATA1r_EAP_BYPf_SET BCM53115_A0_ACT_POL_DATA1r_EAP_BYPf_SET
#define ACT_POL_DATA1r_STP_BYPf_GET BCM53115_A0_ACT_POL_DATA1r_STP_BYPf_GET
#define ACT_POL_DATA1r_STP_BYPf_SET BCM53115_A0_ACT_POL_DATA1r_STP_BYPf_SET
#define ACT_POL_DATA1r_REASON_CODEf_GET BCM53115_A0_ACT_POL_DATA1r_REASON_CODEf_GET
#define ACT_POL_DATA1r_REASON_CODEf_SET BCM53115_A0_ACT_POL_DATA1r_REASON_CODEf_SET
#define ACT_POL_DATA1r_LOOP_BK_ENf_GET BCM53115_A0_ACT_POL_DATA1r_LOOP_BK_ENf_GET
#define ACT_POL_DATA1r_LOOP_BK_ENf_SET BCM53115_A0_ACT_POL_DATA1r_LOOP_BK_ENf_SET
#define ACT_POL_DATA1r_NEW_TCf_GET BCM53115_A0_ACT_POL_DATA1r_NEW_TCf_GET
#define ACT_POL_DATA1r_NEW_TCf_SET BCM53115_A0_ACT_POL_DATA1r_NEW_TCf_SET
#define ACT_POL_DATA1r_CHANGE_TCf_GET BCM53115_A0_ACT_POL_DATA1r_CHANGE_TCf_GET
#define ACT_POL_DATA1r_CHANGE_TCf_SET BCM53115_A0_ACT_POL_DATA1r_CHANGE_TCf_SET
#define ACT_POL_DATA1r_CHAIN_IDf_GET BCM53115_A0_ACT_POL_DATA1r_CHAIN_IDf_GET
#define ACT_POL_DATA1r_CHAIN_IDf_SET BCM53115_A0_ACT_POL_DATA1r_CHAIN_IDf_SET
#define ACT_POL_DATA1r_RESERVED_1Rf_GET BCM53115_A0_ACT_POL_DATA1r_RESERVED_1Rf_GET
#define ACT_POL_DATA1r_RESERVED_1Rf_SET BCM53115_A0_ACT_POL_DATA1r_RESERVED_1Rf_SET
#define READ_ACT_POL_DATA1r BCM53115_A0_READ_ACT_POL_DATA1r
#define WRITE_ACT_POL_DATA1r BCM53115_A0_WRITE_ACT_POL_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ACT_POL_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_FWD_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID_R         
 *     ARL_CON          
 *     ARL_PRI          
 *     ARL_AGE          
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR0 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_FWD_ENTRY0r 0x00000518

#define BCM53115_A0_ARLA_FWD_ENTRY0r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY0.
 *
 */
typedef union BCM53115_A0_ARLA_FWD_ENTRY0r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry0[1];
	uint32_t _arla_fwd_entry0;
} BCM53115_A0_ARLA_FWD_ENTRY0r_t;

#define BCM53115_A0_ARLA_FWD_ENTRY0r_CLR(r) (r).arla_fwd_entry0[0] = 0
#define BCM53115_A0_ARLA_FWD_ENTRY0r_SET(r,d) (r).arla_fwd_entry0[0] = d
#define BCM53115_A0_ARLA_FWD_ENTRY0r_GET(r) (r).arla_fwd_entry0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_FWD_ENTRY0r_PORTID_Rf_GET(r) (((r).arla_fwd_entry0[0]) & 0x1ff)
#define BCM53115_A0_ARLA_FWD_ENTRY0r_PORTID_Rf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET(r) ((((r).arla_fwd_entry0[0]) >> 9) & 0x3)
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry0[0]) >> 11) & 0x7)
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry0[0]) >> 14) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry0[0]) >> 15) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 16) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_ARLA_FWD_ENTRY0r_RESERVED_Rf_GET(r) ((((r).arla_fwd_entry0[0]) >> 17) & 0x7fff)
#define BCM53115_A0_ARLA_FWD_ENTRY0r_RESERVED_Rf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY0.
 *
 */
#define BCM53115_A0_READ_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_FWD_ENTRY0r,(r._arla_fwd_entry0),4)
#define BCM53115_A0_WRITE_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_FWD_ENTRY0r,&(r._arla_fwd_entry0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY0r BCM53115_A0_ARLA_FWD_ENTRY0r
#define ARLA_FWD_ENTRY0r_SIZE BCM53115_A0_ARLA_FWD_ENTRY0r_SIZE
typedef BCM53115_A0_ARLA_FWD_ENTRY0r_t ARLA_FWD_ENTRY0r_t;
#define ARLA_FWD_ENTRY0r_CLR BCM53115_A0_ARLA_FWD_ENTRY0r_CLR
#define ARLA_FWD_ENTRY0r_SET BCM53115_A0_ARLA_FWD_ENTRY0r_SET
#define ARLA_FWD_ENTRY0r_GET BCM53115_A0_ARLA_FWD_ENTRY0r_GET
#define ARLA_FWD_ENTRY0r_PORTID_Rf_GET BCM53115_A0_ARLA_FWD_ENTRY0r_PORTID_Rf_GET
#define ARLA_FWD_ENTRY0r_PORTID_Rf_SET BCM53115_A0_ARLA_FWD_ENTRY0r_PORTID_Rf_SET
#define ARLA_FWD_ENTRY0r_ARL_CONf_GET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET
#define ARLA_FWD_ENTRY0r_ARL_CONf_SET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_GET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_SET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_GET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_SET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_GET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_SET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_GET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_SET BCM53115_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY0r_RESERVED_Rf_GET BCM53115_A0_ARLA_FWD_ENTRY0r_RESERVED_Rf_GET
#define ARLA_FWD_ENTRY0r_RESERVED_Rf_SET BCM53115_A0_ARLA_FWD_ENTRY0r_RESERVED_Rf_SET
#define READ_ARLA_FWD_ENTRY0r BCM53115_A0_READ_ARLA_FWD_ENTRY0r
#define WRITE_ARLA_FWD_ENTRY0r BCM53115_A0_WRITE_ARLA_FWD_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_FWD_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_FWD_ENTRY1
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID_R         
 *     ARL_CON          arl control bit for arl cintrol mode enhancement.
 *     ARL_PRI          
 *     ARL_AGE          
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR1 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_FWD_ENTRY1r 0x00000528

#define BCM53115_A0_ARLA_FWD_ENTRY1r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY1.
 *
 */
typedef union BCM53115_A0_ARLA_FWD_ENTRY1r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry1[1];
	uint32_t _arla_fwd_entry1;
} BCM53115_A0_ARLA_FWD_ENTRY1r_t;

#define BCM53115_A0_ARLA_FWD_ENTRY1r_CLR(r) (r).arla_fwd_entry1[0] = 0
#define BCM53115_A0_ARLA_FWD_ENTRY1r_SET(r,d) (r).arla_fwd_entry1[0] = d
#define BCM53115_A0_ARLA_FWD_ENTRY1r_GET(r) (r).arla_fwd_entry1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_FWD_ENTRY1r_PORTID_Rf_GET(r) (((r).arla_fwd_entry1[0]) & 0x1ff)
#define BCM53115_A0_ARLA_FWD_ENTRY1r_PORTID_Rf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_CONf_GET(r) ((((r).arla_fwd_entry1[0]) >> 9) & 0x3)
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_CONf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry1[0]) >> 11) & 0x7)
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry1[0]) >> 14) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry1[0]) >> 15) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry1[0]) >> 16) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_ARLA_FWD_ENTRY1r_RESERVED_Rf_GET(r) ((((r).arla_fwd_entry1[0]) >> 17) & 0x7fff)
#define BCM53115_A0_ARLA_FWD_ENTRY1r_RESERVED_Rf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY1.
 *
 */
#define BCM53115_A0_READ_ARLA_FWD_ENTRY1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_FWD_ENTRY1r,(r._arla_fwd_entry1),4)
#define BCM53115_A0_WRITE_ARLA_FWD_ENTRY1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_FWD_ENTRY1r,&(r._arla_fwd_entry1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY1r BCM53115_A0_ARLA_FWD_ENTRY1r
#define ARLA_FWD_ENTRY1r_SIZE BCM53115_A0_ARLA_FWD_ENTRY1r_SIZE
typedef BCM53115_A0_ARLA_FWD_ENTRY1r_t ARLA_FWD_ENTRY1r_t;
#define ARLA_FWD_ENTRY1r_CLR BCM53115_A0_ARLA_FWD_ENTRY1r_CLR
#define ARLA_FWD_ENTRY1r_SET BCM53115_A0_ARLA_FWD_ENTRY1r_SET
#define ARLA_FWD_ENTRY1r_GET BCM53115_A0_ARLA_FWD_ENTRY1r_GET
#define ARLA_FWD_ENTRY1r_PORTID_Rf_GET BCM53115_A0_ARLA_FWD_ENTRY1r_PORTID_Rf_GET
#define ARLA_FWD_ENTRY1r_PORTID_Rf_SET BCM53115_A0_ARLA_FWD_ENTRY1r_PORTID_Rf_SET
#define ARLA_FWD_ENTRY1r_ARL_CONf_GET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_CONf_GET
#define ARLA_FWD_ENTRY1r_ARL_CONf_SET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_CONf_SET
#define ARLA_FWD_ENTRY1r_ARL_PRIf_GET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY1r_ARL_PRIf_SET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY1r_ARL_AGEf_GET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY1r_ARL_AGEf_SET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY1r_ARL_STATICf_GET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY1r_ARL_STATICf_SET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY1r_ARL_VALIDf_GET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY1r_ARL_VALIDf_SET BCM53115_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY1r_RESERVED_Rf_GET BCM53115_A0_ARLA_FWD_ENTRY1r_RESERVED_Rf_GET
#define ARLA_FWD_ENTRY1r_RESERVED_Rf_SET BCM53115_A0_ARLA_FWD_ENTRY1r_RESERVED_Rf_SET
#define READ_ARLA_FWD_ENTRY1r BCM53115_A0_READ_ARLA_FWD_ENTRY1r
#define WRITE_ARLA_FWD_ENTRY1r BCM53115_A0_WRITE_ARLA_FWD_ENTRY1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_FWD_ENTRY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_FWD_ENTRY2
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID_R         
 *     ARL_CON          arl control bit for arl cintrol mode enhancement.
 *     ARL_PRI          
 *     ARL_AGE          
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR2 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_FWD_ENTRY2r 0x00000538

#define BCM53115_A0_ARLA_FWD_ENTRY2r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY2.
 *
 */
typedef union BCM53115_A0_ARLA_FWD_ENTRY2r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry2[1];
	uint32_t _arla_fwd_entry2;
} BCM53115_A0_ARLA_FWD_ENTRY2r_t;

#define BCM53115_A0_ARLA_FWD_ENTRY2r_CLR(r) (r).arla_fwd_entry2[0] = 0
#define BCM53115_A0_ARLA_FWD_ENTRY2r_SET(r,d) (r).arla_fwd_entry2[0] = d
#define BCM53115_A0_ARLA_FWD_ENTRY2r_GET(r) (r).arla_fwd_entry2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_FWD_ENTRY2r_PORTID_Rf_GET(r) (((r).arla_fwd_entry2[0]) & 0x1ff)
#define BCM53115_A0_ARLA_FWD_ENTRY2r_PORTID_Rf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_CONf_GET(r) ((((r).arla_fwd_entry2[0]) >> 9) & 0x3)
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_CONf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry2[0]) >> 11) & 0x7)
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry2[0]) >> 14) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry2[0]) >> 15) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry2[0]) >> 16) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_ARLA_FWD_ENTRY2r_RESERVED_Rf_GET(r) ((((r).arla_fwd_entry2[0]) >> 17) & 0x7fff)
#define BCM53115_A0_ARLA_FWD_ENTRY2r_RESERVED_Rf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY2.
 *
 */
#define BCM53115_A0_READ_ARLA_FWD_ENTRY2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_FWD_ENTRY2r,(r._arla_fwd_entry2),4)
#define BCM53115_A0_WRITE_ARLA_FWD_ENTRY2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_FWD_ENTRY2r,&(r._arla_fwd_entry2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY2r BCM53115_A0_ARLA_FWD_ENTRY2r
#define ARLA_FWD_ENTRY2r_SIZE BCM53115_A0_ARLA_FWD_ENTRY2r_SIZE
typedef BCM53115_A0_ARLA_FWD_ENTRY2r_t ARLA_FWD_ENTRY2r_t;
#define ARLA_FWD_ENTRY2r_CLR BCM53115_A0_ARLA_FWD_ENTRY2r_CLR
#define ARLA_FWD_ENTRY2r_SET BCM53115_A0_ARLA_FWD_ENTRY2r_SET
#define ARLA_FWD_ENTRY2r_GET BCM53115_A0_ARLA_FWD_ENTRY2r_GET
#define ARLA_FWD_ENTRY2r_PORTID_Rf_GET BCM53115_A0_ARLA_FWD_ENTRY2r_PORTID_Rf_GET
#define ARLA_FWD_ENTRY2r_PORTID_Rf_SET BCM53115_A0_ARLA_FWD_ENTRY2r_PORTID_Rf_SET
#define ARLA_FWD_ENTRY2r_ARL_CONf_GET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_CONf_GET
#define ARLA_FWD_ENTRY2r_ARL_CONf_SET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_CONf_SET
#define ARLA_FWD_ENTRY2r_ARL_PRIf_GET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY2r_ARL_PRIf_SET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY2r_ARL_AGEf_GET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY2r_ARL_AGEf_SET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY2r_ARL_STATICf_GET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY2r_ARL_STATICf_SET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY2r_ARL_VALIDf_GET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY2r_ARL_VALIDf_SET BCM53115_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY2r_RESERVED_Rf_GET BCM53115_A0_ARLA_FWD_ENTRY2r_RESERVED_Rf_GET
#define ARLA_FWD_ENTRY2r_RESERVED_Rf_SET BCM53115_A0_ARLA_FWD_ENTRY2r_RESERVED_Rf_SET
#define READ_ARLA_FWD_ENTRY2r BCM53115_A0_READ_ARLA_FWD_ENTRY2r
#define WRITE_ARLA_FWD_ENTRY2r BCM53115_A0_WRITE_ARLA_FWD_ENTRY2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_FWD_ENTRY2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_FWD_ENTRY3
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 3 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID_R         
 *     ARL_CON          arl control bit for arl cintrol mode enhancement.
 *     ARL_PRI          
 *     ARL_AGE          
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR3 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_FWD_ENTRY3r 0x00000548

#define BCM53115_A0_ARLA_FWD_ENTRY3r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY3.
 *
 */
typedef union BCM53115_A0_ARLA_FWD_ENTRY3r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry3[1];
	uint32_t _arla_fwd_entry3;
} BCM53115_A0_ARLA_FWD_ENTRY3r_t;

#define BCM53115_A0_ARLA_FWD_ENTRY3r_CLR(r) (r).arla_fwd_entry3[0] = 0
#define BCM53115_A0_ARLA_FWD_ENTRY3r_SET(r,d) (r).arla_fwd_entry3[0] = d
#define BCM53115_A0_ARLA_FWD_ENTRY3r_GET(r) (r).arla_fwd_entry3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_FWD_ENTRY3r_PORTID_Rf_GET(r) (((r).arla_fwd_entry3[0]) & 0x1ff)
#define BCM53115_A0_ARLA_FWD_ENTRY3r_PORTID_Rf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_CONf_GET(r) ((((r).arla_fwd_entry3[0]) >> 9) & 0x3)
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_CONf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry3[0]) >> 11) & 0x7)
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry3[0]) >> 14) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry3[0]) >> 15) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry3[0]) >> 16) & 0x1)
#define BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_ARLA_FWD_ENTRY3r_RESERVED_Rf_GET(r) ((((r).arla_fwd_entry3[0]) >> 17) & 0x7fff)
#define BCM53115_A0_ARLA_FWD_ENTRY3r_RESERVED_Rf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY3.
 *
 */
#define BCM53115_A0_READ_ARLA_FWD_ENTRY3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_FWD_ENTRY3r,(r._arla_fwd_entry3),4)
#define BCM53115_A0_WRITE_ARLA_FWD_ENTRY3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_FWD_ENTRY3r,&(r._arla_fwd_entry3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY3r BCM53115_A0_ARLA_FWD_ENTRY3r
#define ARLA_FWD_ENTRY3r_SIZE BCM53115_A0_ARLA_FWD_ENTRY3r_SIZE
typedef BCM53115_A0_ARLA_FWD_ENTRY3r_t ARLA_FWD_ENTRY3r_t;
#define ARLA_FWD_ENTRY3r_CLR BCM53115_A0_ARLA_FWD_ENTRY3r_CLR
#define ARLA_FWD_ENTRY3r_SET BCM53115_A0_ARLA_FWD_ENTRY3r_SET
#define ARLA_FWD_ENTRY3r_GET BCM53115_A0_ARLA_FWD_ENTRY3r_GET
#define ARLA_FWD_ENTRY3r_PORTID_Rf_GET BCM53115_A0_ARLA_FWD_ENTRY3r_PORTID_Rf_GET
#define ARLA_FWD_ENTRY3r_PORTID_Rf_SET BCM53115_A0_ARLA_FWD_ENTRY3r_PORTID_Rf_SET
#define ARLA_FWD_ENTRY3r_ARL_CONf_GET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_CONf_GET
#define ARLA_FWD_ENTRY3r_ARL_CONf_SET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_CONf_SET
#define ARLA_FWD_ENTRY3r_ARL_PRIf_GET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY3r_ARL_PRIf_SET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY3r_ARL_AGEf_GET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY3r_ARL_AGEf_SET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY3r_ARL_STATICf_GET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY3r_ARL_STATICf_SET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY3r_ARL_VALIDf_GET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY3r_ARL_VALIDf_SET BCM53115_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY3r_RESERVED_Rf_GET BCM53115_A0_ARLA_FWD_ENTRY3r_RESERVED_Rf_GET
#define ARLA_FWD_ENTRY3r_RESERVED_Rf_SET BCM53115_A0_ARLA_FWD_ENTRY3r_RESERVED_Rf_SET
#define READ_ARLA_FWD_ENTRY3r BCM53115_A0_READ_ARLA_FWD_ENTRY3r
#define WRITE_ARLA_FWD_ENTRY3r BCM53115_A0_WRITE_ARLA_FWD_ENTRY3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_FWD_ENTRY3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_MAC
 * BLOCKS:   SYS
 * DESC:     MAC Address Index Register
 * SIZE:     48
 * FIELDS:
 *     MAC_ADDR_INDX    MAC Address Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0/1/2/3 locations. These entries are 64 bits wide. Initiating a write command will write the contents of ARL Entry 0/1/2/3 to the specified bin location (4 entries deep) and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_MACr 0x00000502

#define BCM53115_A0_ARLA_MACr_SIZE 6

/*
 * This structure should be used to declare and program ARLA_MAC.
 *
 */
typedef union BCM53115_A0_ARLA_MACr_s {
	uint32_t v[2];
	uint32_t arla_mac[2];
	uint32_t _arla_mac;
} BCM53115_A0_ARLA_MACr_t;

#define BCM53115_A0_ARLA_MACr_CLR(r) CDK_MEMSET(&((r)._arla_mac), 0, sizeof(BCM53115_A0_ARLA_MACr_t))
#define BCM53115_A0_ARLA_MACr_SET(r,i,d) (r).arla_mac[i] = d
#define BCM53115_A0_ARLA_MACr_GET(r,i) (r).arla_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_MACr_MAC_ADDR_INDXf_GET(r,a) cdk_field_get((r).arla_mac,0,47,a)
#define BCM53115_A0_ARLA_MACr_MAC_ADDR_INDXf_SET(r,a) cdk_field_set((r).arla_mac,0,47,a)

/*
 * These macros can be used to access ARLA_MAC.
 *
 */
#define BCM53115_A0_READ_ARLA_MACr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_MACr,(r._arla_mac),6)
#define BCM53115_A0_WRITE_ARLA_MACr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_MACr,&(r._arla_mac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACr BCM53115_A0_ARLA_MACr
#define ARLA_MACr_SIZE BCM53115_A0_ARLA_MACr_SIZE
typedef BCM53115_A0_ARLA_MACr_t ARLA_MACr_t;
#define ARLA_MACr_CLR BCM53115_A0_ARLA_MACr_CLR
#define ARLA_MACr_SET BCM53115_A0_ARLA_MACr_SET
#define ARLA_MACr_GET BCM53115_A0_ARLA_MACr_GET
#define ARLA_MACr_MAC_ADDR_INDXf_GET BCM53115_A0_ARLA_MACr_MAC_ADDR_INDXf_GET
#define ARLA_MACr_MAC_ADDR_INDXf_SET BCM53115_A0_ARLA_MACr_MAC_ADDR_INDXf_SET
#define READ_ARLA_MACr BCM53115_A0_READ_ARLA_MACr
#define WRITE_ARLA_MACr BCM53115_A0_WRITE_ARLA_MACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_MACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_MACVID_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address.
 *     VID_R            VID0.The VID0 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 0 Register and MAC/VID Entry 0 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_MACVID_ENTRY0r 0x00000510

#define BCM53115_A0_ARLA_MACVID_ENTRY0r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY0.
 *
 */
typedef union BCM53115_A0_ARLA_MACVID_ENTRY0r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry0[2];
	uint32_t _arla_macvid_entry0;
} BCM53115_A0_ARLA_MACVID_ENTRY0r_t;

#define BCM53115_A0_ARLA_MACVID_ENTRY0r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry0), 0, sizeof(BCM53115_A0_ARLA_MACVID_ENTRY0r_t))
#define BCM53115_A0_ARLA_MACVID_ENTRY0r_SET(r,i,d) (r).arla_macvid_entry0[i] = d
#define BCM53115_A0_ARLA_MACVID_ENTRY0r_GET(r,i) (r).arla_macvid_entry0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry0,0,47,a)
#define BCM53115_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry0,0,47,a)
#define BCM53115_A0_ARLA_MACVID_ENTRY0r_VID_Rf_GET(r) ((((r).arla_macvid_entry0[1]) >> 16) & 0xfff)
#define BCM53115_A0_ARLA_MACVID_ENTRY0r_VID_Rf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_ARLA_MACVID_ENTRY0r_RESERVED_Rf_GET(r) ((((r).arla_macvid_entry0[1]) >> 28) & 0xf)
#define BCM53115_A0_ARLA_MACVID_ENTRY0r_RESERVED_Rf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY0.
 *
 */
#define BCM53115_A0_READ_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_MACVID_ENTRY0r,(r._arla_macvid_entry0),8)
#define BCM53115_A0_WRITE_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_MACVID_ENTRY0r,&(r._arla_macvid_entry0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY0r BCM53115_A0_ARLA_MACVID_ENTRY0r
#define ARLA_MACVID_ENTRY0r_SIZE BCM53115_A0_ARLA_MACVID_ENTRY0r_SIZE
typedef BCM53115_A0_ARLA_MACVID_ENTRY0r_t ARLA_MACVID_ENTRY0r_t;
#define ARLA_MACVID_ENTRY0r_CLR BCM53115_A0_ARLA_MACVID_ENTRY0r_CLR
#define ARLA_MACVID_ENTRY0r_SET BCM53115_A0_ARLA_MACVID_ENTRY0r_SET
#define ARLA_MACVID_ENTRY0r_GET BCM53115_A0_ARLA_MACVID_ENTRY0r_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET BCM53115_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET BCM53115_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY0r_VID_Rf_GET BCM53115_A0_ARLA_MACVID_ENTRY0r_VID_Rf_GET
#define ARLA_MACVID_ENTRY0r_VID_Rf_SET BCM53115_A0_ARLA_MACVID_ENTRY0r_VID_Rf_SET
#define ARLA_MACVID_ENTRY0r_RESERVED_Rf_GET BCM53115_A0_ARLA_MACVID_ENTRY0r_RESERVED_Rf_GET
#define ARLA_MACVID_ENTRY0r_RESERVED_Rf_SET BCM53115_A0_ARLA_MACVID_ENTRY0r_RESERVED_Rf_SET
#define READ_ARLA_MACVID_ENTRY0r BCM53115_A0_READ_ARLA_MACVID_ENTRY0r
#define WRITE_ARLA_MACVID_ENTRY0r BCM53115_A0_WRITE_ARLA_MACVID_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_MACVID_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_MACVID_ENTRY1
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 1 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address.
 *     VID_R            VID1.The VID1 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 1 Register and MAC/VID Entry 1 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_MACVID_ENTRY1r 0x00000520

#define BCM53115_A0_ARLA_MACVID_ENTRY1r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY1.
 *
 */
typedef union BCM53115_A0_ARLA_MACVID_ENTRY1r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry1[2];
	uint32_t _arla_macvid_entry1;
} BCM53115_A0_ARLA_MACVID_ENTRY1r_t;

#define BCM53115_A0_ARLA_MACVID_ENTRY1r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry1), 0, sizeof(BCM53115_A0_ARLA_MACVID_ENTRY1r_t))
#define BCM53115_A0_ARLA_MACVID_ENTRY1r_SET(r,i,d) (r).arla_macvid_entry1[i] = d
#define BCM53115_A0_ARLA_MACVID_ENTRY1r_GET(r,i) (r).arla_macvid_entry1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry1,0,47,a)
#define BCM53115_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry1,0,47,a)
#define BCM53115_A0_ARLA_MACVID_ENTRY1r_VID_Rf_GET(r) ((((r).arla_macvid_entry1[1]) >> 16) & 0xfff)
#define BCM53115_A0_ARLA_MACVID_ENTRY1r_VID_Rf_SET(r,f) (r).arla_macvid_entry1[1]=(((r).arla_macvid_entry1[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_ARLA_MACVID_ENTRY1r_RESERVED_Rf_GET(r) ((((r).arla_macvid_entry1[1]) >> 28) & 0xf)
#define BCM53115_A0_ARLA_MACVID_ENTRY1r_RESERVED_Rf_SET(r,f) (r).arla_macvid_entry1[1]=(((r).arla_macvid_entry1[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY1.
 *
 */
#define BCM53115_A0_READ_ARLA_MACVID_ENTRY1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_MACVID_ENTRY1r,(r._arla_macvid_entry1),8)
#define BCM53115_A0_WRITE_ARLA_MACVID_ENTRY1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_MACVID_ENTRY1r,&(r._arla_macvid_entry1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY1r BCM53115_A0_ARLA_MACVID_ENTRY1r
#define ARLA_MACVID_ENTRY1r_SIZE BCM53115_A0_ARLA_MACVID_ENTRY1r_SIZE
typedef BCM53115_A0_ARLA_MACVID_ENTRY1r_t ARLA_MACVID_ENTRY1r_t;
#define ARLA_MACVID_ENTRY1r_CLR BCM53115_A0_ARLA_MACVID_ENTRY1r_CLR
#define ARLA_MACVID_ENTRY1r_SET BCM53115_A0_ARLA_MACVID_ENTRY1r_SET
#define ARLA_MACVID_ENTRY1r_GET BCM53115_A0_ARLA_MACVID_ENTRY1r_GET
#define ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET BCM53115_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET BCM53115_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY1r_VID_Rf_GET BCM53115_A0_ARLA_MACVID_ENTRY1r_VID_Rf_GET
#define ARLA_MACVID_ENTRY1r_VID_Rf_SET BCM53115_A0_ARLA_MACVID_ENTRY1r_VID_Rf_SET
#define ARLA_MACVID_ENTRY1r_RESERVED_Rf_GET BCM53115_A0_ARLA_MACVID_ENTRY1r_RESERVED_Rf_GET
#define ARLA_MACVID_ENTRY1r_RESERVED_Rf_SET BCM53115_A0_ARLA_MACVID_ENTRY1r_RESERVED_Rf_SET
#define READ_ARLA_MACVID_ENTRY1r BCM53115_A0_READ_ARLA_MACVID_ENTRY1r
#define WRITE_ARLA_MACVID_ENTRY1r BCM53115_A0_WRITE_ARLA_MACVID_ENTRY1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_MACVID_ENTRY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_MACVID_ENTRY2
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 2 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address.
 *     VID_R            VID2.The VID2 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 2 Register and MAC/VID Entry 2 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_MACVID_ENTRY2r 0x00000530

#define BCM53115_A0_ARLA_MACVID_ENTRY2r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY2.
 *
 */
typedef union BCM53115_A0_ARLA_MACVID_ENTRY2r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry2[2];
	uint32_t _arla_macvid_entry2;
} BCM53115_A0_ARLA_MACVID_ENTRY2r_t;

#define BCM53115_A0_ARLA_MACVID_ENTRY2r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry2), 0, sizeof(BCM53115_A0_ARLA_MACVID_ENTRY2r_t))
#define BCM53115_A0_ARLA_MACVID_ENTRY2r_SET(r,i,d) (r).arla_macvid_entry2[i] = d
#define BCM53115_A0_ARLA_MACVID_ENTRY2r_GET(r,i) (r).arla_macvid_entry2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry2,0,47,a)
#define BCM53115_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry2,0,47,a)
#define BCM53115_A0_ARLA_MACVID_ENTRY2r_VID_Rf_GET(r) ((((r).arla_macvid_entry2[1]) >> 16) & 0xfff)
#define BCM53115_A0_ARLA_MACVID_ENTRY2r_VID_Rf_SET(r,f) (r).arla_macvid_entry2[1]=(((r).arla_macvid_entry2[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_ARLA_MACVID_ENTRY2r_RESERVED_Rf_GET(r) ((((r).arla_macvid_entry2[1]) >> 28) & 0xf)
#define BCM53115_A0_ARLA_MACVID_ENTRY2r_RESERVED_Rf_SET(r,f) (r).arla_macvid_entry2[1]=(((r).arla_macvid_entry2[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY2.
 *
 */
#define BCM53115_A0_READ_ARLA_MACVID_ENTRY2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_MACVID_ENTRY2r,(r._arla_macvid_entry2),8)
#define BCM53115_A0_WRITE_ARLA_MACVID_ENTRY2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_MACVID_ENTRY2r,&(r._arla_macvid_entry2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY2r BCM53115_A0_ARLA_MACVID_ENTRY2r
#define ARLA_MACVID_ENTRY2r_SIZE BCM53115_A0_ARLA_MACVID_ENTRY2r_SIZE
typedef BCM53115_A0_ARLA_MACVID_ENTRY2r_t ARLA_MACVID_ENTRY2r_t;
#define ARLA_MACVID_ENTRY2r_CLR BCM53115_A0_ARLA_MACVID_ENTRY2r_CLR
#define ARLA_MACVID_ENTRY2r_SET BCM53115_A0_ARLA_MACVID_ENTRY2r_SET
#define ARLA_MACVID_ENTRY2r_GET BCM53115_A0_ARLA_MACVID_ENTRY2r_GET
#define ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET BCM53115_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET BCM53115_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY2r_VID_Rf_GET BCM53115_A0_ARLA_MACVID_ENTRY2r_VID_Rf_GET
#define ARLA_MACVID_ENTRY2r_VID_Rf_SET BCM53115_A0_ARLA_MACVID_ENTRY2r_VID_Rf_SET
#define ARLA_MACVID_ENTRY2r_RESERVED_Rf_GET BCM53115_A0_ARLA_MACVID_ENTRY2r_RESERVED_Rf_GET
#define ARLA_MACVID_ENTRY2r_RESERVED_Rf_SET BCM53115_A0_ARLA_MACVID_ENTRY2r_RESERVED_Rf_SET
#define READ_ARLA_MACVID_ENTRY2r BCM53115_A0_READ_ARLA_MACVID_ENTRY2r
#define WRITE_ARLA_MACVID_ENTRY2r BCM53115_A0_WRITE_ARLA_MACVID_ENTRY2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_MACVID_ENTRY2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_MACVID_ENTRY3
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 3 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address.
 *     VID_R            VID3.The VID3 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 3 Register and MAC/VID Entry 3 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_MACVID_ENTRY3r 0x00000540

#define BCM53115_A0_ARLA_MACVID_ENTRY3r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY3.
 *
 */
typedef union BCM53115_A0_ARLA_MACVID_ENTRY3r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry3[2];
	uint32_t _arla_macvid_entry3;
} BCM53115_A0_ARLA_MACVID_ENTRY3r_t;

#define BCM53115_A0_ARLA_MACVID_ENTRY3r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry3), 0, sizeof(BCM53115_A0_ARLA_MACVID_ENTRY3r_t))
#define BCM53115_A0_ARLA_MACVID_ENTRY3r_SET(r,i,d) (r).arla_macvid_entry3[i] = d
#define BCM53115_A0_ARLA_MACVID_ENTRY3r_GET(r,i) (r).arla_macvid_entry3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry3,0,47,a)
#define BCM53115_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry3,0,47,a)
#define BCM53115_A0_ARLA_MACVID_ENTRY3r_VID_Rf_GET(r) ((((r).arla_macvid_entry3[1]) >> 16) & 0xfff)
#define BCM53115_A0_ARLA_MACVID_ENTRY3r_VID_Rf_SET(r,f) (r).arla_macvid_entry3[1]=(((r).arla_macvid_entry3[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_ARLA_MACVID_ENTRY3r_RESERVED_Rf_GET(r) ((((r).arla_macvid_entry3[1]) >> 28) & 0xf)
#define BCM53115_A0_ARLA_MACVID_ENTRY3r_RESERVED_Rf_SET(r,f) (r).arla_macvid_entry3[1]=(((r).arla_macvid_entry3[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY3.
 *
 */
#define BCM53115_A0_READ_ARLA_MACVID_ENTRY3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_MACVID_ENTRY3r,(r._arla_macvid_entry3),8)
#define BCM53115_A0_WRITE_ARLA_MACVID_ENTRY3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_MACVID_ENTRY3r,&(r._arla_macvid_entry3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY3r BCM53115_A0_ARLA_MACVID_ENTRY3r
#define ARLA_MACVID_ENTRY3r_SIZE BCM53115_A0_ARLA_MACVID_ENTRY3r_SIZE
typedef BCM53115_A0_ARLA_MACVID_ENTRY3r_t ARLA_MACVID_ENTRY3r_t;
#define ARLA_MACVID_ENTRY3r_CLR BCM53115_A0_ARLA_MACVID_ENTRY3r_CLR
#define ARLA_MACVID_ENTRY3r_SET BCM53115_A0_ARLA_MACVID_ENTRY3r_SET
#define ARLA_MACVID_ENTRY3r_GET BCM53115_A0_ARLA_MACVID_ENTRY3r_GET
#define ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET BCM53115_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET BCM53115_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY3r_VID_Rf_GET BCM53115_A0_ARLA_MACVID_ENTRY3r_VID_Rf_GET
#define ARLA_MACVID_ENTRY3r_VID_Rf_SET BCM53115_A0_ARLA_MACVID_ENTRY3r_VID_Rf_SET
#define ARLA_MACVID_ENTRY3r_RESERVED_Rf_GET BCM53115_A0_ARLA_MACVID_ENTRY3r_RESERVED_Rf_GET
#define ARLA_MACVID_ENTRY3r_RESERVED_Rf_SET BCM53115_A0_ARLA_MACVID_ENTRY3r_RESERVED_Rf_SET
#define READ_ARLA_MACVID_ENTRY3r BCM53115_A0_READ_ARLA_MACVID_ENTRY3r
#define WRITE_ARLA_MACVID_ENTRY3r BCM53115_A0_WRITE_ARLA_MACVID_ENTRY3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_MACVID_ENTRY3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_RWCTL
 * BLOCKS:   SYS
 * DESC:     ARL Read/Write Control Register
 * SIZE:     8
 * FIELDS:
 *     ARL_RW           ARL Read/Write.1 = Read,0 = Write.
 *     RESERVED_R       Reserved
 *     ARL_STRTDN       Start/Done Command.Write as 1 to initiate a read or write command, after first loading the MAC_ADDR_INDX register with the MAC address for which the ARL entry is to be read or written.The BCM5388 will reset the bit to indicate a write operation completed, or a read operation has completed and data from the bin entry is available in ARL Entry 0/1 Note that both ARL Entry 0 and 1 are both always read/written by the BCM5388 when accessing the address table locations in memory.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_RWCTLr 0x00000500

#define BCM53115_A0_ARLA_RWCTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_RWCTL.
 *
 */
typedef union BCM53115_A0_ARLA_RWCTLr_s {
	uint32_t v[1];
	uint32_t arla_rwctl[1];
	uint32_t _arla_rwctl;
} BCM53115_A0_ARLA_RWCTLr_t;

#define BCM53115_A0_ARLA_RWCTLr_CLR(r) (r).arla_rwctl[0] = 0
#define BCM53115_A0_ARLA_RWCTLr_SET(r,d) (r).arla_rwctl[0] = d
#define BCM53115_A0_ARLA_RWCTLr_GET(r) (r).arla_rwctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_RWCTLr_ARL_RWf_GET(r) (((r).arla_rwctl[0]) & 0x1)
#define BCM53115_A0_ARLA_RWCTLr_ARL_RWf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_ARLA_RWCTLr_RESERVED_Rf_GET(r) ((((r).arla_rwctl[0]) >> 1) & 0x3f)
#define BCM53115_A0_ARLA_RWCTLr_RESERVED_Rf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53115_A0_ARLA_RWCTLr_ARL_STRTDNf_GET(r) ((((r).arla_rwctl[0]) >> 7) & 0x1)
#define BCM53115_A0_ARLA_RWCTLr_ARL_STRTDNf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_RWCTL.
 *
 */
#define BCM53115_A0_READ_ARLA_RWCTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_RWCTLr,(r._arla_rwctl),1)
#define BCM53115_A0_WRITE_ARLA_RWCTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_RWCTLr,&(r._arla_rwctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_RWCTLr BCM53115_A0_ARLA_RWCTLr
#define ARLA_RWCTLr_SIZE BCM53115_A0_ARLA_RWCTLr_SIZE
typedef BCM53115_A0_ARLA_RWCTLr_t ARLA_RWCTLr_t;
#define ARLA_RWCTLr_CLR BCM53115_A0_ARLA_RWCTLr_CLR
#define ARLA_RWCTLr_SET BCM53115_A0_ARLA_RWCTLr_SET
#define ARLA_RWCTLr_GET BCM53115_A0_ARLA_RWCTLr_GET
#define ARLA_RWCTLr_ARL_RWf_GET BCM53115_A0_ARLA_RWCTLr_ARL_RWf_GET
#define ARLA_RWCTLr_ARL_RWf_SET BCM53115_A0_ARLA_RWCTLr_ARL_RWf_SET
#define ARLA_RWCTLr_RESERVED_Rf_GET BCM53115_A0_ARLA_RWCTLr_RESERVED_Rf_GET
#define ARLA_RWCTLr_RESERVED_Rf_SET BCM53115_A0_ARLA_RWCTLr_RESERVED_Rf_SET
#define ARLA_RWCTLr_ARL_STRTDNf_GET BCM53115_A0_ARLA_RWCTLr_ARL_STRTDNf_GET
#define ARLA_RWCTLr_ARL_STRTDNf_SET BCM53115_A0_ARLA_RWCTLr_ARL_STRTDNf_SET
#define READ_ARLA_RWCTLr BCM53115_A0_READ_ARLA_RWCTLr
#define WRITE_ARLA_RWCTLr BCM53115_A0_WRITE_ARLA_RWCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_RWCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_SRCH_ADR
 * BLOCKS:   SYS
 * DESC:     ARL Search Address Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_SRCH_ADR    ARL Address.15 bit internal representation of the address of the ARL entry currently being accessed by the ARL search routine.This is not a direct address of the ARL location, and is intended for factory test/diagnostic use only.
 *     ARLA_SRCH_ADR_VALID ARL Address Valid.Indicates the lower 15 bits of this register contain a valid internal representation of the ARL entry currently being accessed. Intended for factory test/diagnostic use only.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_SRCH_ADRr 0x00000551

#define BCM53115_A0_ARLA_SRCH_ADRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_ADR.
 *
 */
typedef union BCM53115_A0_ARLA_SRCH_ADRr_s {
	uint32_t v[1];
	uint32_t arla_srch_adr[1];
	uint32_t _arla_srch_adr;
} BCM53115_A0_ARLA_SRCH_ADRr_t;

#define BCM53115_A0_ARLA_SRCH_ADRr_CLR(r) (r).arla_srch_adr[0] = 0
#define BCM53115_A0_ARLA_SRCH_ADRr_SET(r,d) (r).arla_srch_adr[0] = d
#define BCM53115_A0_ARLA_SRCH_ADRr_GET(r) (r).arla_srch_adr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET(r) (((r).arla_srch_adr[0]) & 0x7fff)
#define BCM53115_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))
#define BCM53115_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET(r) ((((r).arla_srch_adr[0]) >> 15) & 0x1)
#define BCM53115_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_SRCH_ADR.
 *
 */
#define BCM53115_A0_READ_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_SRCH_ADRr,(r._arla_srch_adr),2)
#define BCM53115_A0_WRITE_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_SRCH_ADRr,&(r._arla_srch_adr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_ADRr BCM53115_A0_ARLA_SRCH_ADRr
#define ARLA_SRCH_ADRr_SIZE BCM53115_A0_ARLA_SRCH_ADRr_SIZE
typedef BCM53115_A0_ARLA_SRCH_ADRr_t ARLA_SRCH_ADRr_t;
#define ARLA_SRCH_ADRr_CLR BCM53115_A0_ARLA_SRCH_ADRr_CLR
#define ARLA_SRCH_ADRr_SET BCM53115_A0_ARLA_SRCH_ADRr_SET
#define ARLA_SRCH_ADRr_GET BCM53115_A0_ARLA_SRCH_ADRr_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET BCM53115_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET BCM53115_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET BCM53115_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET BCM53115_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET
#define READ_ARLA_SRCH_ADRr BCM53115_A0_READ_ARLA_SRCH_ADRr
#define WRITE_ARLA_SRCH_ADRr BCM53115_A0_WRITE_ARLA_SRCH_ADRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_SRCH_ADRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_SRCH_CTL
 * BLOCKS:   SYS
 * DESC:     ARL Search Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_SRCH_VLID   ARL Search Result ValidSet by the BCM5395 to indicate that an ARL entry is available in the ARL Search Result register.Reset by a host read to the ARL Search Result register 1 , which will cause the ARL search process to continue through the ARL entries until the next entry is found with a Valid bit is set.(Note: should not reset by a host read to ARL Search VID Result Register. The correct process of reading a ARL Entry after having searched a valid one: Read ARL Search VID Result Register => Read ARL Search Result Register 1)
 *     RESERVED_R       Reserved
 *     ARLA_SRCH_STDN   Start/Done.Write as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result Register causes the ARL search to continue.The BCM5388 will clear this bit to indicate the entire ARL entry database has been searched.)
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_SRCH_CTLr 0x00000550

#define BCM53115_A0_ARLA_SRCH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_SRCH_CTL.
 *
 */
typedef union BCM53115_A0_ARLA_SRCH_CTLr_s {
	uint32_t v[1];
	uint32_t arla_srch_ctl[1];
	uint32_t _arla_srch_ctl;
} BCM53115_A0_ARLA_SRCH_CTLr_t;

#define BCM53115_A0_ARLA_SRCH_CTLr_CLR(r) (r).arla_srch_ctl[0] = 0
#define BCM53115_A0_ARLA_SRCH_CTLr_SET(r,d) (r).arla_srch_ctl[0] = d
#define BCM53115_A0_ARLA_SRCH_CTLr_GET(r) (r).arla_srch_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET(r) (((r).arla_srch_ctl[0]) & 0x1)
#define BCM53115_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_ARLA_SRCH_CTLr_RESERVED_Rf_GET(r) ((((r).arla_srch_ctl[0]) >> 1) & 0x3f)
#define BCM53115_A0_ARLA_SRCH_CTLr_RESERVED_Rf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53115_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET(r) ((((r).arla_srch_ctl[0]) >> 7) & 0x1)
#define BCM53115_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_SRCH_CTL.
 *
 */
#define BCM53115_A0_READ_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_SRCH_CTLr,(r._arla_srch_ctl),1)
#define BCM53115_A0_WRITE_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_SRCH_CTLr,&(r._arla_srch_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_CTLr BCM53115_A0_ARLA_SRCH_CTLr
#define ARLA_SRCH_CTLr_SIZE BCM53115_A0_ARLA_SRCH_CTLr_SIZE
typedef BCM53115_A0_ARLA_SRCH_CTLr_t ARLA_SRCH_CTLr_t;
#define ARLA_SRCH_CTLr_CLR BCM53115_A0_ARLA_SRCH_CTLr_CLR
#define ARLA_SRCH_CTLr_SET BCM53115_A0_ARLA_SRCH_CTLr_SET
#define ARLA_SRCH_CTLr_GET BCM53115_A0_ARLA_SRCH_CTLr_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET BCM53115_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET BCM53115_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET
#define ARLA_SRCH_CTLr_RESERVED_Rf_GET BCM53115_A0_ARLA_SRCH_CTLr_RESERVED_Rf_GET
#define ARLA_SRCH_CTLr_RESERVED_Rf_SET BCM53115_A0_ARLA_SRCH_CTLr_RESERVED_Rf_SET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET BCM53115_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET BCM53115_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET
#define READ_ARLA_SRCH_CTLr BCM53115_A0_READ_ARLA_SRCH_CTLr
#define WRITE_ARLA_SRCH_CTLr BCM53115_A0_WRITE_ARLA_SRCH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_SRCH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_SRCH_RSLT
 * BLOCKS:   SYS
 * DESC:     ARL Search Result 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID_R         
 *     ARL_CON          ARL control bit for arl control mode enhancement.
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.Multicast group Forward Portmap bit8 for CPU.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_SRCH_RSLTr 0x00000568

#define BCM53115_A0_ARLA_SRCH_RSLTr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT.
 *
 */
typedef union BCM53115_A0_ARLA_SRCH_RSLTr_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt[1];
	uint32_t _arla_srch_rslt;
} BCM53115_A0_ARLA_SRCH_RSLTr_t;

#define BCM53115_A0_ARLA_SRCH_RSLTr_CLR(r) (r).arla_srch_rslt[0] = 0
#define BCM53115_A0_ARLA_SRCH_RSLTr_SET(r,d) (r).arla_srch_rslt[0] = d
#define BCM53115_A0_ARLA_SRCH_RSLTr_GET(r) (r).arla_srch_rslt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_SRCH_RSLTr_PORTID_Rf_GET(r) (((r).arla_srch_rslt[0]) & 0x1ff)
#define BCM53115_A0_ARLA_SRCH_RSLTr_PORTID_Rf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARL_CONf_GET(r) ((((r).arla_srch_rslt[0]) >> 9) & 0x3)
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARL_CONf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt[0]) >> 11) & 0x7)
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt[0]) >> 14) & 0x1)
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt[0]) >> 15) & 0x1)
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt[0]) >> 16) & 0x1)
#define BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_ARLA_SRCH_RSLTr_RESERVED_Rf_GET(r) ((((r).arla_srch_rslt[0]) >> 17) & 0x7fff)
#define BCM53115_A0_ARLA_SRCH_RSLTr_RESERVED_Rf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_SRCH_RSLT.
 *
 */
#define BCM53115_A0_READ_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_SRCH_RSLTr,(r._arla_srch_rslt),4)
#define BCM53115_A0_WRITE_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_SRCH_RSLTr,&(r._arla_srch_rslt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLTr BCM53115_A0_ARLA_SRCH_RSLTr
#define ARLA_SRCH_RSLTr_SIZE BCM53115_A0_ARLA_SRCH_RSLTr_SIZE
typedef BCM53115_A0_ARLA_SRCH_RSLTr_t ARLA_SRCH_RSLTr_t;
#define ARLA_SRCH_RSLTr_CLR BCM53115_A0_ARLA_SRCH_RSLTr_CLR
#define ARLA_SRCH_RSLTr_SET BCM53115_A0_ARLA_SRCH_RSLTr_SET
#define ARLA_SRCH_RSLTr_GET BCM53115_A0_ARLA_SRCH_RSLTr_GET
#define ARLA_SRCH_RSLTr_PORTID_Rf_GET BCM53115_A0_ARLA_SRCH_RSLTr_PORTID_Rf_GET
#define ARLA_SRCH_RSLTr_PORTID_Rf_SET BCM53115_A0_ARLA_SRCH_RSLTr_PORTID_Rf_SET
#define ARLA_SRCH_RSLTr_ARL_CONf_GET BCM53115_A0_ARLA_SRCH_RSLTr_ARL_CONf_GET
#define ARLA_SRCH_RSLTr_ARL_CONf_SET BCM53115_A0_ARLA_SRCH_RSLTr_ARL_CONf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET BCM53115_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET
#define ARLA_SRCH_RSLTr_RESERVED_Rf_GET BCM53115_A0_ARLA_SRCH_RSLTr_RESERVED_Rf_GET
#define ARLA_SRCH_RSLTr_RESERVED_Rf_SET BCM53115_A0_ARLA_SRCH_RSLTr_RESERVED_Rf_SET
#define READ_ARLA_SRCH_RSLTr BCM53115_A0_READ_ARLA_SRCH_RSLTr
#define WRITE_ARLA_SRCH_RSLTr BCM53115_A0_WRITE_ARLA_SRCH_RSLTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_SRCH_RSLTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_SRCH_RSLT_0_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr 0x00000560

#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_0_MACVID.
 *
 */
typedef union BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_0_macvid[2];
	uint32_t _arla_srch_rslt_0_macvid;
} BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_t;

#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_0_macvid), 0, sizeof(BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_t))
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_0_macvid[i] = d
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_GET(r,i) (r).arla_srch_rslt_0_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_0_macvid,0,47,a)
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_0_macvid,0,47,a)
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_0_macvid[1]) >> 16) & 0xfff)
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_0_macvid[1]=(((r).arla_srch_rslt_0_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVED_Rf_GET(r) ((((r).arla_srch_rslt_0_macvid[1]) >> 28) & 0xf)
#define BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVED_Rf_SET(r,f) (r).arla_srch_rslt_0_macvid[1]=(((r).arla_srch_rslt_0_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_0_MACVID.
 *
 */
#define BCM53115_A0_READ_ARLA_SRCH_RSLT_0_MACVIDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr,(r._arla_srch_rslt_0_macvid),8)
#define BCM53115_A0_WRITE_ARLA_SRCH_RSLT_0_MACVIDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr,&(r._arla_srch_rslt_0_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_0_MACVIDr BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr
#define ARLA_SRCH_RSLT_0_MACVIDr_SIZE BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_SIZE
typedef BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_t ARLA_SRCH_RSLT_0_MACVIDr_t;
#define ARLA_SRCH_RSLT_0_MACVIDr_CLR BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_CLR
#define ARLA_SRCH_RSLT_0_MACVIDr_SET BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_GET BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_RESERVED_Rf_GET BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVED_Rf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_RESERVED_Rf_SET BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVED_Rf_SET
#define READ_ARLA_SRCH_RSLT_0_MACVIDr BCM53115_A0_READ_ARLA_SRCH_RSLT_0_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_0_MACVIDr BCM53115_A0_WRITE_ARLA_SRCH_RSLT_0_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_SRCH_RSLT_0_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_SRCH_RSLT_1
 * BLOCKS:   SYS
 * DESC:     ARL Search Result 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID_R         
 *     ARL_CON          ARL control bit for arl control mode enhancement.
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.Multicast group Forward Portmap bit8 for CPU.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_SRCH_RSLT_1r 0x00000578

#define BCM53115_A0_ARLA_SRCH_RSLT_1r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_1.
 *
 */
typedef union BCM53115_A0_ARLA_SRCH_RSLT_1r_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt_1[1];
	uint32_t _arla_srch_rslt_1;
} BCM53115_A0_ARLA_SRCH_RSLT_1r_t;

#define BCM53115_A0_ARLA_SRCH_RSLT_1r_CLR(r) (r).arla_srch_rslt_1[0] = 0
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_SET(r,d) (r).arla_srch_rslt_1[0] = d
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_GET(r) (r).arla_srch_rslt_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_PORTID_Rf_GET(r) (((r).arla_srch_rslt_1[0]) & 0x1ff)
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_PORTID_Rf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 9) & 0x3)
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 11) & 0x7)
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 14) & 0x1)
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 15) & 0x1)
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 16) & 0x1)
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_RESERVED_Rf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 17) & 0x7fff)
#define BCM53115_A0_ARLA_SRCH_RSLT_1r_RESERVED_Rf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_1.
 *
 */
#define BCM53115_A0_READ_ARLA_SRCH_RSLT_1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_SRCH_RSLT_1r,(r._arla_srch_rslt_1),4)
#define BCM53115_A0_WRITE_ARLA_SRCH_RSLT_1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_SRCH_RSLT_1r,&(r._arla_srch_rslt_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_1r BCM53115_A0_ARLA_SRCH_RSLT_1r
#define ARLA_SRCH_RSLT_1r_SIZE BCM53115_A0_ARLA_SRCH_RSLT_1r_SIZE
typedef BCM53115_A0_ARLA_SRCH_RSLT_1r_t ARLA_SRCH_RSLT_1r_t;
#define ARLA_SRCH_RSLT_1r_CLR BCM53115_A0_ARLA_SRCH_RSLT_1r_CLR
#define ARLA_SRCH_RSLT_1r_SET BCM53115_A0_ARLA_SRCH_RSLT_1r_SET
#define ARLA_SRCH_RSLT_1r_GET BCM53115_A0_ARLA_SRCH_RSLT_1r_GET
#define ARLA_SRCH_RSLT_1r_PORTID_Rf_GET BCM53115_A0_ARLA_SRCH_RSLT_1r_PORTID_Rf_GET
#define ARLA_SRCH_RSLT_1r_PORTID_Rf_SET BCM53115_A0_ARLA_SRCH_RSLT_1r_PORTID_Rf_SET
#define ARLA_SRCH_RSLT_1r_ARL_CONf_GET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_GET
#define ARLA_SRCH_RSLT_1r_ARL_CONf_SET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET BCM53115_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET
#define ARLA_SRCH_RSLT_1r_RESERVED_Rf_GET BCM53115_A0_ARLA_SRCH_RSLT_1r_RESERVED_Rf_GET
#define ARLA_SRCH_RSLT_1r_RESERVED_Rf_SET BCM53115_A0_ARLA_SRCH_RSLT_1r_RESERVED_Rf_SET
#define READ_ARLA_SRCH_RSLT_1r BCM53115_A0_READ_ARLA_SRCH_RSLT_1r
#define WRITE_ARLA_SRCH_RSLT_1r BCM53115_A0_WRITE_ARLA_SRCH_RSLT_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_SRCH_RSLT_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_SRCH_RSLT_1_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result 1 Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr 0x00000570

#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_1_MACVID.
 *
 */
typedef union BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_1_macvid[2];
	uint32_t _arla_srch_rslt_1_macvid;
} BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_t;

#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_1_macvid), 0, sizeof(BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_t))
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_1_macvid[i] = d
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_GET(r,i) (r).arla_srch_rslt_1_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_1_macvid,0,47,a)
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_1_macvid,0,47,a)
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_1_macvid[1]) >> 16) & 0xfff)
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_1_macvid[1]=(((r).arla_srch_rslt_1_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVED_Rf_GET(r) ((((r).arla_srch_rslt_1_macvid[1]) >> 28) & 0xf)
#define BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVED_Rf_SET(r,f) (r).arla_srch_rslt_1_macvid[1]=(((r).arla_srch_rslt_1_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_1_MACVID.
 *
 */
#define BCM53115_A0_READ_ARLA_SRCH_RSLT_1_MACVIDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr,(r._arla_srch_rslt_1_macvid),8)
#define BCM53115_A0_WRITE_ARLA_SRCH_RSLT_1_MACVIDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr,&(r._arla_srch_rslt_1_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_1_MACVIDr BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr
#define ARLA_SRCH_RSLT_1_MACVIDr_SIZE BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_SIZE
typedef BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_t ARLA_SRCH_RSLT_1_MACVIDr_t;
#define ARLA_SRCH_RSLT_1_MACVIDr_CLR BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_CLR
#define ARLA_SRCH_RSLT_1_MACVIDr_SET BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_GET BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_RESERVED_Rf_GET BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVED_Rf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_RESERVED_Rf_SET BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVED_Rf_SET
#define READ_ARLA_SRCH_RSLT_1_MACVIDr BCM53115_A0_READ_ARLA_SRCH_RSLT_1_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_1_MACVIDr BCM53115_A0_WRITE_ARLA_SRCH_RSLT_1_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_SRCH_RSLT_1_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_VID
 * BLOCKS:   SYS
 * DESC:     VID Index Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_VIDTAB_INDX VID Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address upon MAC Address Index, upon 12 bit VID Index Register if 802.1Q is enabled, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0 locations and VID Entry0. Both ARL entries are 64 bits wide. Both VID entries are 12 bits wide.Initiating a write command will write the contents of ARL Entry 0/1 and VID Entry 0/1 to the specified bin location and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *     ARLA_VIDTAB_RSRV0 Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_VIDr 0x00000508

#define BCM53115_A0_ARLA_VIDr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VID.
 *
 */
typedef union BCM53115_A0_ARLA_VIDr_s {
	uint32_t v[1];
	uint32_t arla_vid[1];
	uint32_t _arla_vid;
} BCM53115_A0_ARLA_VIDr_t;

#define BCM53115_A0_ARLA_VIDr_CLR(r) (r).arla_vid[0] = 0
#define BCM53115_A0_ARLA_VIDr_SET(r,d) (r).arla_vid[0] = d
#define BCM53115_A0_ARLA_VIDr_GET(r) (r).arla_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET(r) (((r).arla_vid[0]) & 0xfff)
#define BCM53115_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET(r) ((((r).arla_vid[0]) >> 12) & 0xf)
#define BCM53115_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VID.
 *
 */
#define BCM53115_A0_READ_ARLA_VIDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_VIDr,(r._arla_vid),2)
#define BCM53115_A0_WRITE_ARLA_VIDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_VIDr,&(r._arla_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VIDr BCM53115_A0_ARLA_VIDr
#define ARLA_VIDr_SIZE BCM53115_A0_ARLA_VIDr_SIZE
typedef BCM53115_A0_ARLA_VIDr_t ARLA_VIDr_t;
#define ARLA_VIDr_CLR BCM53115_A0_ARLA_VIDr_CLR
#define ARLA_VIDr_SET BCM53115_A0_ARLA_VIDr_SET
#define ARLA_VIDr_GET BCM53115_A0_ARLA_VIDr_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_GET BCM53115_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_SET BCM53115_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET BCM53115_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET BCM53115_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET
#define READ_ARLA_VIDr BCM53115_A0_READ_ARLA_VIDr
#define WRITE_ARLA_VIDr BCM53115_A0_WRITE_ARLA_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_VTBL_ADDR
 * BLOCKS:   SYS
 * DESC:     VTBL Address Index Register
 * SIZE:     16
 * FIELDS:
 *     VTBL_ADDR_INDEX  VLAN Table Address Index.The VLAN Table Address Index Register is used to access VLAN Table Entry.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_VTBL_ADDRr 0x00000581

#define BCM53115_A0_ARLA_VTBL_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VTBL_ADDR.
 *
 */
typedef union BCM53115_A0_ARLA_VTBL_ADDRr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_addr[1];
	uint32_t _arla_vtbl_addr;
} BCM53115_A0_ARLA_VTBL_ADDRr_t;

#define BCM53115_A0_ARLA_VTBL_ADDRr_CLR(r) (r).arla_vtbl_addr[0] = 0
#define BCM53115_A0_ARLA_VTBL_ADDRr_SET(r,d) (r).arla_vtbl_addr[0] = d
#define BCM53115_A0_ARLA_VTBL_ADDRr_GET(r) (r).arla_vtbl_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET(r) (((r).arla_vtbl_addr[0]) & 0xfff)
#define BCM53115_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_ARLA_VTBL_ADDRr_RESERVED_Rf_GET(r) ((((r).arla_vtbl_addr[0]) >> 12) & 0xf)
#define BCM53115_A0_ARLA_VTBL_ADDRr_RESERVED_Rf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VTBL_ADDR.
 *
 */
#define BCM53115_A0_READ_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_VTBL_ADDRr,(r._arla_vtbl_addr),2)
#define BCM53115_A0_WRITE_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_VTBL_ADDRr,&(r._arla_vtbl_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ADDRr BCM53115_A0_ARLA_VTBL_ADDRr
#define ARLA_VTBL_ADDRr_SIZE BCM53115_A0_ARLA_VTBL_ADDRr_SIZE
typedef BCM53115_A0_ARLA_VTBL_ADDRr_t ARLA_VTBL_ADDRr_t;
#define ARLA_VTBL_ADDRr_CLR BCM53115_A0_ARLA_VTBL_ADDRr_CLR
#define ARLA_VTBL_ADDRr_SET BCM53115_A0_ARLA_VTBL_ADDRr_SET
#define ARLA_VTBL_ADDRr_GET BCM53115_A0_ARLA_VTBL_ADDRr_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET BCM53115_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET BCM53115_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET
#define ARLA_VTBL_ADDRr_RESERVED_Rf_GET BCM53115_A0_ARLA_VTBL_ADDRr_RESERVED_Rf_GET
#define ARLA_VTBL_ADDRr_RESERVED_Rf_SET BCM53115_A0_ARLA_VTBL_ADDRr_RESERVED_Rf_SET
#define READ_ARLA_VTBL_ADDRr BCM53115_A0_READ_ARLA_VTBL_ADDRr
#define WRITE_ARLA_VTBL_ADDRr BCM53115_A0_WRITE_ARLA_VTBL_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_VTBL_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_VTBL_ENTRY
 * BLOCKS:   SYS
 * DESC:     VTBL Entry Register
 * SIZE:     32
 * FIELDS:
 *     FWD_MAP          Forward PORT MAP.The VLAN-tagged Frame is allowed to be forwarded to the destination ports corresponding bits set in the Map.Bits5-0: Port 5-0.Bit8: Management Port.
 *     UNTAG_MAP        Untag Port Map.The VLAN-tagged Frame forward to the destination ports corresponding bits set in the Map will be untagged.Bits5-0: Port 5-0.Bit8: Management Port.
 *     MSPT_INDEX       Index for 16 spanning tree.
 *     FWD_MODE         It indicate wheter the packet forwarding should be based on VLANmembership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used forcertain ISP tagged packets received from ISP port when Falcon isoperating in Double Tag mode.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_VTBL_ENTRYr 0x00000583

#define BCM53115_A0_ARLA_VTBL_ENTRYr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_VTBL_ENTRY.
 *
 */
typedef union BCM53115_A0_ARLA_VTBL_ENTRYr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_entry[1];
	uint32_t _arla_vtbl_entry;
} BCM53115_A0_ARLA_VTBL_ENTRYr_t;

#define BCM53115_A0_ARLA_VTBL_ENTRYr_CLR(r) (r).arla_vtbl_entry[0] = 0
#define BCM53115_A0_ARLA_VTBL_ENTRYr_SET(r,d) (r).arla_vtbl_entry[0] = d
#define BCM53115_A0_ARLA_VTBL_ENTRYr_GET(r) (r).arla_vtbl_entry[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET(r) (((r).arla_vtbl_entry[0]) & 0x1ff)
#define BCM53115_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET(r) ((((r).arla_vtbl_entry[0]) >> 9) & 0x1ff)
#define BCM53115_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53115_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET(r) ((((r).arla_vtbl_entry[0]) >> 18) & 0x7)
#define BCM53115_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53115_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_GET(r) ((((r).arla_vtbl_entry[0]) >> 21) & 0x1)
#define BCM53115_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53115_A0_ARLA_VTBL_ENTRYr_RESERVED_Rf_GET(r) ((((r).arla_vtbl_entry[0]) >> 22) & 0x3ff)
#define BCM53115_A0_ARLA_VTBL_ENTRYr_RESERVED_Rf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access ARLA_VTBL_ENTRY.
 *
 */
#define BCM53115_A0_READ_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_VTBL_ENTRYr,(r._arla_vtbl_entry),4)
#define BCM53115_A0_WRITE_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_VTBL_ENTRYr,&(r._arla_vtbl_entry),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ENTRYr BCM53115_A0_ARLA_VTBL_ENTRYr
#define ARLA_VTBL_ENTRYr_SIZE BCM53115_A0_ARLA_VTBL_ENTRYr_SIZE
typedef BCM53115_A0_ARLA_VTBL_ENTRYr_t ARLA_VTBL_ENTRYr_t;
#define ARLA_VTBL_ENTRYr_CLR BCM53115_A0_ARLA_VTBL_ENTRYr_CLR
#define ARLA_VTBL_ENTRYr_SET BCM53115_A0_ARLA_VTBL_ENTRYr_SET
#define ARLA_VTBL_ENTRYr_GET BCM53115_A0_ARLA_VTBL_ENTRYr_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_GET BCM53115_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_SET BCM53115_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET BCM53115_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET BCM53115_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET BCM53115_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET BCM53115_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET
#define ARLA_VTBL_ENTRYr_FWD_MODEf_GET BCM53115_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_GET
#define ARLA_VTBL_ENTRYr_FWD_MODEf_SET BCM53115_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_SET
#define ARLA_VTBL_ENTRYr_RESERVED_Rf_GET BCM53115_A0_ARLA_VTBL_ENTRYr_RESERVED_Rf_GET
#define ARLA_VTBL_ENTRYr_RESERVED_Rf_SET BCM53115_A0_ARLA_VTBL_ENTRYr_RESERVED_Rf_SET
#define READ_ARLA_VTBL_ENTRYr BCM53115_A0_READ_ARLA_VTBL_ENTRYr
#define WRITE_ARLA_VTBL_ENTRYr BCM53115_A0_WRITE_ARLA_VTBL_ENTRYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_VTBL_ENTRYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ARLA_VTBL_RWCTRL
 * BLOCKS:   SYS
 * DESC:     VTBL Read/Write/Clear Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_VTBL_RW_CLR VTBL Read/Write/Clear-table11 = Reserved10 = Clear-table01 = Read00 = Write
 *     RESERVED_R       Reserved
 *     ARLA_VTBL_STDN   Start/Done.Write as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result Register causes the ARL search to continue.The BCM5388 will clear this bit to indicate the entire ARL entry database has been searched.)
 *
 ******************************************************************************/
#define BCM53115_A0_ARLA_VTBL_RWCTRLr 0x00000580

#define BCM53115_A0_ARLA_VTBL_RWCTRLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_VTBL_RWCTRL.
 *
 */
typedef union BCM53115_A0_ARLA_VTBL_RWCTRLr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_rwctrl[1];
	uint32_t _arla_vtbl_rwctrl;
} BCM53115_A0_ARLA_VTBL_RWCTRLr_t;

#define BCM53115_A0_ARLA_VTBL_RWCTRLr_CLR(r) (r).arla_vtbl_rwctrl[0] = 0
#define BCM53115_A0_ARLA_VTBL_RWCTRLr_SET(r,d) (r).arla_vtbl_rwctrl[0] = d
#define BCM53115_A0_ARLA_VTBL_RWCTRLr_GET(r) (r).arla_vtbl_rwctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET(r) (((r).arla_vtbl_rwctrl[0]) & 0x3)
#define BCM53115_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_ARLA_VTBL_RWCTRLr_RESERVED_Rf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 2) & 0x1f)
#define BCM53115_A0_ARLA_VTBL_RWCTRLr_RESERVED_Rf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM53115_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 7) & 0x1)
#define BCM53115_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_VTBL_RWCTRL.
 *
 */
#define BCM53115_A0_READ_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ARLA_VTBL_RWCTRLr,(r._arla_vtbl_rwctrl),1)
#define BCM53115_A0_WRITE_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ARLA_VTBL_RWCTRLr,&(r._arla_vtbl_rwctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_RWCTRLr BCM53115_A0_ARLA_VTBL_RWCTRLr
#define ARLA_VTBL_RWCTRLr_SIZE BCM53115_A0_ARLA_VTBL_RWCTRLr_SIZE
typedef BCM53115_A0_ARLA_VTBL_RWCTRLr_t ARLA_VTBL_RWCTRLr_t;
#define ARLA_VTBL_RWCTRLr_CLR BCM53115_A0_ARLA_VTBL_RWCTRLr_CLR
#define ARLA_VTBL_RWCTRLr_SET BCM53115_A0_ARLA_VTBL_RWCTRLr_SET
#define ARLA_VTBL_RWCTRLr_GET BCM53115_A0_ARLA_VTBL_RWCTRLr_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET BCM53115_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET BCM53115_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET
#define ARLA_VTBL_RWCTRLr_RESERVED_Rf_GET BCM53115_A0_ARLA_VTBL_RWCTRLr_RESERVED_Rf_GET
#define ARLA_VTBL_RWCTRLr_RESERVED_Rf_SET BCM53115_A0_ARLA_VTBL_RWCTRLr_RESERVED_Rf_SET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET BCM53115_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET BCM53115_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET
#define READ_ARLA_VTBL_RWCTRLr BCM53115_A0_READ_ARLA_VTBL_RWCTRLr
#define WRITE_ARLA_VTBL_RWCTRLr BCM53115_A0_WRITE_ARLA_VTBL_RWCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ARLA_VTBL_RWCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr 0x00004170

#define BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_IMP.
 *
 */
typedef union BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_imp[1];
	uint32_t _bc_sup_pktdrop_cnt_imp;
} BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_t;

#define BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_CLR(r) (r).bc_sup_pktdrop_cnt_imp[0] = 0
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_SET(r,d) (r).bc_sup_pktdrop_cnt_imp[0] = d
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_GET(r) (r).bc_sup_pktdrop_cnt_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_imp[0])
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_IMP.
 *
 */
#define BCM53115_A0_READ_BC_SUP_PKTDROP_CNT_IMPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr,(r._bc_sup_pktdrop_cnt_imp),4)
#define BCM53115_A0_WRITE_BC_SUP_PKTDROP_CNT_IMPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr,&(r._bc_sup_pktdrop_cnt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_IMPr BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr
#define BC_SUP_PKTDROP_CNT_IMPr_SIZE BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_SIZE
typedef BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_t BC_SUP_PKTDROP_CNT_IMPr_t;
#define BC_SUP_PKTDROP_CNT_IMPr_CLR BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_CLR
#define BC_SUP_PKTDROP_CNT_IMPr_SET BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_SET
#define BC_SUP_PKTDROP_CNT_IMPr_GET BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_GET
#define BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_IMPr BCM53115_A0_READ_BC_SUP_PKTDROP_CNT_IMPr
#define WRITE_BC_SUP_PKTDROP_CNT_IMPr BCM53115_A0_WRITE_BC_SUP_PKTDROP_CNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_BC_SUP_PKTDROP_CNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_P
 * BLOCKS:   GPIC0
 * DESC:     Port N Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr 0x00004150

#define BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_P.
 *
 */
typedef union BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_p[1];
	uint32_t _bc_sup_pktdrop_cnt_p;
} BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_t;

#define BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_CLR(r) (r).bc_sup_pktdrop_cnt_p[0] = 0
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_SET(r,d) (r).bc_sup_pktdrop_cnt_p[0] = d
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_GET(r) (r).bc_sup_pktdrop_cnt_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_p[0])
#define BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_p[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_P.
 *
 */
#define BCM53115_A0_READ_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr,(r._bc_sup_pktdrop_cnt_p),4)
#define BCM53115_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr,&(r._bc_sup_pktdrop_cnt_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_Pr BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr
#define BC_SUP_PKTDROP_CNT_Pr_SIZE BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE
typedef BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_t BC_SUP_PKTDROP_CNT_Pr_t;
#define BC_SUP_PKTDROP_CNT_Pr_CLR BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_CLR
#define BC_SUP_PKTDROP_CNT_Pr_SET BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_SET
#define BC_SUP_PKTDROP_CNT_Pr_GET BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_Pr BCM53115_A0_READ_BC_SUP_PKTDROP_CNT_Pr
#define WRITE_BC_SUP_PKTDROP_CNT_Pr BCM53115_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_BC_SUP_PKTDROP_CNT_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  BC_SUP_RATECTRL_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mbdefault by {3'b0,bc_sup,4'b0}.
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(valid 4K bytes),3'b001:20K Byte (valid 8K bytes),3'b010:28K Byte (Valid 16K bytes),3'b011:40K Byte (Valid 28K bytes),3'b100:76K Byte (Valid 64K bytes),3'b101:140K Byte(Valid 128K bytes),3'b110:268K Byte(Valid 256K bytes),3'b111:500K Byte(Valid 488K bytes).
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control RegisterWhen Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb 29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb 128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(Valid 4K bytes),3'b001:20K Byte(Valid 8K bytes),3'b010:28K Byte(Valid 16K bytes),3'b011:40K Byte(Valid 28K bytes),3'b100:76K Byte(Valid 64K bytes),3'b101:140K Byte(Valid 128K bytes),3'b110:268K Byte(Valid 256K bytes),3'b111:500K Byte(Valid 488K bytes).
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.Default by Strap pin bc_supp_en
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression.1:Enable,0:Disable.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr 0x00004130

#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_IMP.
 *
 */
typedef union BCM53115_A0_BC_SUP_RATECTRL_IMPr_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_imp[1];
	uint32_t _bc_sup_ratectrl_imp;
} BCM53115_A0_BC_SUP_RATECTRL_IMPr_t;

#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_CLR(r) (r).bc_sup_ratectrl_imp[0] = 0
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_SET(r,d) (r).bc_sup_ratectrl_imp[0] = d
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_GET(r) (r).bc_sup_ratectrl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_imp[0]) & 0xff)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 8) & 0x7)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 11) & 0xff)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 19) & 0x7)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 22) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 23) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 24) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 25) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 26) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 27) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 28) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_RESERVED_Rf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 29) & 0x7)
#define BCM53115_A0_BC_SUP_RATECTRL_IMPr_RESERVED_Rf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access BC_SUP_RATECTRL_IMP.
 *
 */
#define BCM53115_A0_READ_BC_SUP_RATECTRL_IMPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_BC_SUP_RATECTRL_IMPr,(r._bc_sup_ratectrl_imp),4)
#define BCM53115_A0_WRITE_BC_SUP_RATECTRL_IMPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_BC_SUP_RATECTRL_IMPr,&(r._bc_sup_ratectrl_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_IMPr BCM53115_A0_BC_SUP_RATECTRL_IMPr
#define BC_SUP_RATECTRL_IMPr_SIZE BCM53115_A0_BC_SUP_RATECTRL_IMPr_SIZE
typedef BCM53115_A0_BC_SUP_RATECTRL_IMPr_t BC_SUP_RATECTRL_IMPr_t;
#define BC_SUP_RATECTRL_IMPr_CLR BCM53115_A0_BC_SUP_RATECTRL_IMPr_CLR
#define BC_SUP_RATECTRL_IMPr_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_SET
#define BC_SUP_RATECTRL_IMPr_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_RESERVED_Rf_GET BCM53115_A0_BC_SUP_RATECTRL_IMPr_RESERVED_Rf_GET
#define BC_SUP_RATECTRL_IMPr_RESERVED_Rf_SET BCM53115_A0_BC_SUP_RATECTRL_IMPr_RESERVED_Rf_SET
#define READ_BC_SUP_RATECTRL_IMPr BCM53115_A0_READ_BC_SUP_RATECTRL_IMPr
#define WRITE_BC_SUP_RATECTRL_IMPr BCM53115_A0_WRITE_BC_SUP_RATECTRL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_BC_SUP_RATECTRL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  BC_SUP_RATECTRL_P
 * BLOCKS:   CPIC GPIC0
 * DESC:     Port N Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mbdefault by {3'b0,bc_sup,4'b0}.
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(valid 4K bytes),3'b001:20K Byte (valid 8K bytes),3'b010:28K Byte (Valid 16K bytes),3'b011:40K Byte (Valid 28K bytes),3'b100:76K Byte (Valid 64K bytes),3'b101:140K Byte(Valid 128K bytes),3'b110:268K Byte(Valid 256K bytes),3'b111:500K Byte(Valid 488K bytes).
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control RegisterWhen Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb 29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb 128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(Valid 4K bytes),3'b001:20K Byte(Valid 8K bytes),3'b010:28K Byte(Valid 16K bytes),3'b011:40K Byte(Valid 28K bytes),3'b100:76K Byte(Valid 64K bytes),3'b101:140K Byte(Valid 128K bytes),3'b110:268K Byte(Valid 256K bytes),3'b111:500K Byte(Valid 488K bytes).
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.Default by Strap pin bc_supp_en
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression.1:Enable,0:Disable.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_BC_SUP_RATECTRL_Pr 0x00004110

#define BCM53115_A0_BC_SUP_RATECTRL_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_P.
 *
 */
typedef union BCM53115_A0_BC_SUP_RATECTRL_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_p[1];
	uint32_t _bc_sup_ratectrl_p;
} BCM53115_A0_BC_SUP_RATECTRL_Pr_t;

#define BCM53115_A0_BC_SUP_RATECTRL_Pr_CLR(r) (r).bc_sup_ratectrl_p[0] = 0
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_SET(r,d) (r).bc_sup_ratectrl_p[0] = d
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_GET(r) (r).bc_sup_ratectrl_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_p[0]) & 0xff)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 8) & 0x7)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 11) & 0xff)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 19) & 0x7)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 22) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 23) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 24) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 25) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 26) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 27) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 28) & 0x1)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_RESERVED_Rf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 29) & 0x7)
#define BCM53115_A0_BC_SUP_RATECTRL_Pr_RESERVED_Rf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access BC_SUP_RATECTRL_P.
 *
 */
#define BCM53115_A0_READ_BC_SUP_RATECTRL_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_BC_SUP_RATECTRL_Pr,(r._bc_sup_ratectrl_p),4)
#define BCM53115_A0_WRITE_BC_SUP_RATECTRL_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_BC_SUP_RATECTRL_Pr,&(r._bc_sup_ratectrl_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_Pr BCM53115_A0_BC_SUP_RATECTRL_Pr
#define BC_SUP_RATECTRL_Pr_SIZE BCM53115_A0_BC_SUP_RATECTRL_Pr_SIZE
typedef BCM53115_A0_BC_SUP_RATECTRL_Pr_t BC_SUP_RATECTRL_Pr_t;
#define BC_SUP_RATECTRL_Pr_CLR BCM53115_A0_BC_SUP_RATECTRL_Pr_CLR
#define BC_SUP_RATECTRL_Pr_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_SET
#define BC_SUP_RATECTRL_Pr_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_Pr_RESERVED_Rf_GET BCM53115_A0_BC_SUP_RATECTRL_Pr_RESERVED_Rf_GET
#define BC_SUP_RATECTRL_Pr_RESERVED_Rf_SET BCM53115_A0_BC_SUP_RATECTRL_Pr_RESERVED_Rf_SET
#define READ_BC_SUP_RATECTRL_Pr BCM53115_A0_READ_BC_SUP_RATECTRL_Pr
#define WRITE_BC_SUP_RATECTRL_Pr BCM53115_A0_WRITE_BC_SUP_RATECTRL_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_BC_SUP_RATECTRL_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  BIST_STS0
 * BLOCKS:   SYS
 * DESC:     BIST Status Register 0
 * SIZE:     8
 * FIELDS:
 *     LV_MBIST_STATUS  
 *     RESERVED_R       
 *
 ******************************************************************************/
#define BCM53115_A0_BIST_STS0r 0x00000146

#define BCM53115_A0_BIST_STS0r_SIZE 1

/*
 * This structure should be used to declare and program BIST_STS0.
 *
 */
typedef union BCM53115_A0_BIST_STS0r_s {
	uint32_t v[1];
	uint32_t bist_sts0[1];
	uint32_t _bist_sts0;
} BCM53115_A0_BIST_STS0r_t;

#define BCM53115_A0_BIST_STS0r_CLR(r) (r).bist_sts0[0] = 0
#define BCM53115_A0_BIST_STS0r_SET(r,d) (r).bist_sts0[0] = d
#define BCM53115_A0_BIST_STS0r_GET(r) (r).bist_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_BIST_STS0r_LV_MBIST_STATUSf_GET(r) (((r).bist_sts0[0]) & 0xf)
#define BCM53115_A0_BIST_STS0r_LV_MBIST_STATUSf_SET(r,f) (r).bist_sts0[0]=(((r).bist_sts0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_BIST_STS0r_RESERVED_Rf_GET(r) ((((r).bist_sts0[0]) >> 4) & 0xf)
#define BCM53115_A0_BIST_STS0r_RESERVED_Rf_SET(r,f) (r).bist_sts0[0]=(((r).bist_sts0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access BIST_STS0.
 *
 */
#define BCM53115_A0_READ_BIST_STS0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_BIST_STS0r,(r._bist_sts0),1)
#define BCM53115_A0_WRITE_BIST_STS0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_BIST_STS0r,&(r._bist_sts0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STS0r BCM53115_A0_BIST_STS0r
#define BIST_STS0r_SIZE BCM53115_A0_BIST_STS0r_SIZE
typedef BCM53115_A0_BIST_STS0r_t BIST_STS0r_t;
#define BIST_STS0r_CLR BCM53115_A0_BIST_STS0r_CLR
#define BIST_STS0r_SET BCM53115_A0_BIST_STS0r_SET
#define BIST_STS0r_GET BCM53115_A0_BIST_STS0r_GET
#define BIST_STS0r_LV_MBIST_STATUSf_GET BCM53115_A0_BIST_STS0r_LV_MBIST_STATUSf_GET
#define BIST_STS0r_LV_MBIST_STATUSf_SET BCM53115_A0_BIST_STS0r_LV_MBIST_STATUSf_SET
#define BIST_STS0r_RESERVED_Rf_GET BCM53115_A0_BIST_STS0r_RESERVED_Rf_GET
#define BIST_STS0r_RESERVED_Rf_SET BCM53115_A0_BIST_STS0r_RESERVED_Rf_SET
#define READ_BIST_STS0r BCM53115_A0_READ_BIST_STS0r
#define WRITE_BIST_STS0r BCM53115_A0_WRITE_BIST_STS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_BIST_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  BONDING_PAD_STATUS
 * BLOCKS:   SYS
 * DESC:     Bonding PAD status Registrer(Engineering Use Only)
 * SIZE:     8
 * FIELDS:
 *     BOND_CFP_EAV_EN_0 
 *     BOND_CFP_EAV_EN_1 
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_BONDING_PAD_STATUSr 0x000000ee

#define BCM53115_A0_BONDING_PAD_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program BONDING_PAD_STATUS.
 *
 */
typedef union BCM53115_A0_BONDING_PAD_STATUSr_s {
	uint32_t v[1];
	uint32_t bonding_pad_status[1];
	uint32_t _bonding_pad_status;
} BCM53115_A0_BONDING_PAD_STATUSr_t;

#define BCM53115_A0_BONDING_PAD_STATUSr_CLR(r) (r).bonding_pad_status[0] = 0
#define BCM53115_A0_BONDING_PAD_STATUSr_SET(r,d) (r).bonding_pad_status[0] = d
#define BCM53115_A0_BONDING_PAD_STATUSr_GET(r) (r).bonding_pad_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_0f_GET(r) (((r).bonding_pad_status[0]) & 0x1)
#define BCM53115_A0_BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_0f_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_1f_GET(r) ((((r).bonding_pad_status[0]) >> 1) & 0x1)
#define BCM53115_A0_BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_1f_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_BONDING_PAD_STATUSr_RESERVED_Rf_GET(r) ((((r).bonding_pad_status[0]) >> 2) & 0x3f)
#define BCM53115_A0_BONDING_PAD_STATUSr_RESERVED_Rf_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access BONDING_PAD_STATUS.
 *
 */
#define BCM53115_A0_READ_BONDING_PAD_STATUSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_BONDING_PAD_STATUSr,(r._bonding_pad_status),1)
#define BCM53115_A0_WRITE_BONDING_PAD_STATUSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_BONDING_PAD_STATUSr,&(r._bonding_pad_status),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BONDING_PAD_STATUSr BCM53115_A0_BONDING_PAD_STATUSr
#define BONDING_PAD_STATUSr_SIZE BCM53115_A0_BONDING_PAD_STATUSr_SIZE
typedef BCM53115_A0_BONDING_PAD_STATUSr_t BONDING_PAD_STATUSr_t;
#define BONDING_PAD_STATUSr_CLR BCM53115_A0_BONDING_PAD_STATUSr_CLR
#define BONDING_PAD_STATUSr_SET BCM53115_A0_BONDING_PAD_STATUSr_SET
#define BONDING_PAD_STATUSr_GET BCM53115_A0_BONDING_PAD_STATUSr_GET
#define BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_0f_GET BCM53115_A0_BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_0f_GET
#define BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_0f_SET BCM53115_A0_BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_0f_SET
#define BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_1f_GET BCM53115_A0_BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_1f_GET
#define BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_1f_SET BCM53115_A0_BONDING_PAD_STATUSr_BOND_CFP_EAV_EN_1f_SET
#define BONDING_PAD_STATUSr_RESERVED_Rf_GET BCM53115_A0_BONDING_PAD_STATUSr_RESERVED_Rf_GET
#define BONDING_PAD_STATUSr_RESERVED_Rf_SET BCM53115_A0_BONDING_PAD_STATUSr_RESERVED_Rf_SET
#define READ_BONDING_PAD_STATUSr BCM53115_A0_READ_BONDING_PAD_STATUSr
#define WRITE_BONDING_PAD_STATUSr BCM53115_A0_WRITE_BONDING_PAD_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_BONDING_PAD_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  BPDU_MCADDR
 * BLOCKS:   SYS
 * DESC:     BPDU Multicast Address Register
 * SIZE:     48
 * FIELDS:
 *     BPDU_MC_ADDR     BPDU Multicast Address.(not release to customer).Defaults to the 802.1 defined reserved multicast address for the Bridge Group #Address. Programming to an alternate value allows support of proprietary #protocols in place of the normal Spanning Tree Protocol. Frames with a matching #DA to this address will be forwarded only to the designated management port #(IMP).
 *
 ******************************************************************************/
#define BCM53115_A0_BPDU_MCADDRr 0x00000404

#define BCM53115_A0_BPDU_MCADDRr_SIZE 6

/*
 * This structure should be used to declare and program BPDU_MCADDR.
 *
 */
typedef union BCM53115_A0_BPDU_MCADDRr_s {
	uint32_t v[2];
	uint32_t bpdu_mcaddr[2];
	uint32_t _bpdu_mcaddr;
} BCM53115_A0_BPDU_MCADDRr_t;

#define BCM53115_A0_BPDU_MCADDRr_CLR(r) CDK_MEMSET(&((r)._bpdu_mcaddr), 0, sizeof(BCM53115_A0_BPDU_MCADDRr_t))
#define BCM53115_A0_BPDU_MCADDRr_SET(r,i,d) (r).bpdu_mcaddr[i] = d
#define BCM53115_A0_BPDU_MCADDRr_GET(r,i) (r).bpdu_mcaddr[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET(r,a) cdk_field_get((r).bpdu_mcaddr,0,47,a)
#define BCM53115_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET(r,a) cdk_field_set((r).bpdu_mcaddr,0,47,a)

/*
 * These macros can be used to access BPDU_MCADDR.
 *
 */
#define BCM53115_A0_READ_BPDU_MCADDRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_BPDU_MCADDRr,(r._bpdu_mcaddr),6)
#define BCM53115_A0_WRITE_BPDU_MCADDRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_BPDU_MCADDRr,&(r._bpdu_mcaddr),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BPDU_MCADDRr BCM53115_A0_BPDU_MCADDRr
#define BPDU_MCADDRr_SIZE BCM53115_A0_BPDU_MCADDRr_SIZE
typedef BCM53115_A0_BPDU_MCADDRr_t BPDU_MCADDRr_t;
#define BPDU_MCADDRr_CLR BCM53115_A0_BPDU_MCADDRr_CLR
#define BPDU_MCADDRr_SET BCM53115_A0_BPDU_MCADDRr_SET
#define BPDU_MCADDRr_GET BCM53115_A0_BPDU_MCADDRr_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_GET BCM53115_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_SET BCM53115_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET
#define READ_BPDU_MCADDRr BCM53115_A0_READ_BPDU_MCADDRr
#define WRITE_BPDU_MCADDRr BCM53115_A0_WRITE_BPDU_MCADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_BPDU_MCADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  BRCM_HDR_CTRL
 * BLOCKS:   SYS
 * DESC:     BRCM Header Control Register
 * SIZE:     8
 * FIELDS:
 *     BRCM_HDR_EN      Broadcom Header enable
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_BRCM_HDR_CTRLr 0x00000203

#define BCM53115_A0_BRCM_HDR_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program BRCM_HDR_CTRL.
 *
 */
typedef union BCM53115_A0_BRCM_HDR_CTRLr_s {
	uint32_t v[1];
	uint32_t brcm_hdr_ctrl[1];
	uint32_t _brcm_hdr_ctrl;
} BCM53115_A0_BRCM_HDR_CTRLr_t;

#define BCM53115_A0_BRCM_HDR_CTRLr_CLR(r) (r).brcm_hdr_ctrl[0] = 0
#define BCM53115_A0_BRCM_HDR_CTRLr_SET(r,d) (r).brcm_hdr_ctrl[0] = d
#define BCM53115_A0_BRCM_HDR_CTRLr_GET(r) (r).brcm_hdr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET(r) (((r).brcm_hdr_ctrl[0]) & 0x3)
#define BCM53115_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET(r,f) (r).brcm_hdr_ctrl[0]=(((r).brcm_hdr_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_BRCM_HDR_CTRLr_RESERVED_Rf_GET(r) ((((r).brcm_hdr_ctrl[0]) >> 2) & 0x3f)
#define BCM53115_A0_BRCM_HDR_CTRLr_RESERVED_Rf_SET(r,f) (r).brcm_hdr_ctrl[0]=(((r).brcm_hdr_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access BRCM_HDR_CTRL.
 *
 */
#define BCM53115_A0_READ_BRCM_HDR_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_BRCM_HDR_CTRLr,(r._brcm_hdr_ctrl),1)
#define BCM53115_A0_WRITE_BRCM_HDR_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_BRCM_HDR_CTRLr,&(r._brcm_hdr_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BRCM_HDR_CTRLr BCM53115_A0_BRCM_HDR_CTRLr
#define BRCM_HDR_CTRLr_SIZE BCM53115_A0_BRCM_HDR_CTRLr_SIZE
typedef BCM53115_A0_BRCM_HDR_CTRLr_t BRCM_HDR_CTRLr_t;
#define BRCM_HDR_CTRLr_CLR BCM53115_A0_BRCM_HDR_CTRLr_CLR
#define BRCM_HDR_CTRLr_SET BCM53115_A0_BRCM_HDR_CTRLr_SET
#define BRCM_HDR_CTRLr_GET BCM53115_A0_BRCM_HDR_CTRLr_GET
#define BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET BCM53115_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET
#define BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET BCM53115_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET
#define BRCM_HDR_CTRLr_RESERVED_Rf_GET BCM53115_A0_BRCM_HDR_CTRLr_RESERVED_Rf_GET
#define BRCM_HDR_CTRLr_RESERVED_Rf_SET BCM53115_A0_BRCM_HDR_CTRLr_RESERVED_Rf_SET
#define READ_BRCM_HDR_CTRLr BCM53115_A0_READ_BRCM_HDR_CTRLr
#define WRITE_BRCM_HDR_CTRLr BCM53115_A0_WRITE_BRCM_HDR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_BRCM_HDR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  C4_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Class4 Service Weight Register
 * SIZE:     16
 * FIELDS:
 *     C4_WEIGHT        C4 Service WeightThis field defines the service weight between Class 4 traffic and the Best Effort Q3-Q0. When this field is N, it means Class-4:Best-Effort = N:1 When in weighted round robin mode, it is meaningless to set this field as zero.
 *     C4_STRCT         C4 Strict PriorityWhen this field is set to '1', the C4 service weight is don't care and Class 4 is in strict priority over the best effort queues (Q3-Q0).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_C4_WEIGHTr 0x00003085

#define BCM53115_A0_C4_WEIGHTr_SIZE 2

/*
 * This structure should be used to declare and program C4_WEIGHT.
 *
 */
typedef union BCM53115_A0_C4_WEIGHTr_s {
	uint32_t v[1];
	uint32_t c4_weight[1];
	uint32_t _c4_weight;
} BCM53115_A0_C4_WEIGHTr_t;

#define BCM53115_A0_C4_WEIGHTr_CLR(r) (r).c4_weight[0] = 0
#define BCM53115_A0_C4_WEIGHTr_SET(r,d) (r).c4_weight[0] = d
#define BCM53115_A0_C4_WEIGHTr_GET(r) (r).c4_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_C4_WEIGHTr_C4_WEIGHTf_GET(r) (((r).c4_weight[0]) & 0xff)
#define BCM53115_A0_C4_WEIGHTr_C4_WEIGHTf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_C4_WEIGHTr_C4_STRCTf_GET(r) ((((r).c4_weight[0]) >> 8) & 0x1)
#define BCM53115_A0_C4_WEIGHTr_C4_STRCTf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_C4_WEIGHTr_RESERVED_Rf_GET(r) ((((r).c4_weight[0]) >> 9) & 0x7f)
#define BCM53115_A0_C4_WEIGHTr_RESERVED_Rf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access C4_WEIGHT.
 *
 */
#define BCM53115_A0_READ_C4_WEIGHTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_C4_WEIGHTr,(r._c4_weight),2)
#define BCM53115_A0_WRITE_C4_WEIGHTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_C4_WEIGHTr,&(r._c4_weight),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define C4_WEIGHTr BCM53115_A0_C4_WEIGHTr
#define C4_WEIGHTr_SIZE BCM53115_A0_C4_WEIGHTr_SIZE
typedef BCM53115_A0_C4_WEIGHTr_t C4_WEIGHTr_t;
#define C4_WEIGHTr_CLR BCM53115_A0_C4_WEIGHTr_CLR
#define C4_WEIGHTr_SET BCM53115_A0_C4_WEIGHTr_SET
#define C4_WEIGHTr_GET BCM53115_A0_C4_WEIGHTr_GET
#define C4_WEIGHTr_C4_WEIGHTf_GET BCM53115_A0_C4_WEIGHTr_C4_WEIGHTf_GET
#define C4_WEIGHTr_C4_WEIGHTf_SET BCM53115_A0_C4_WEIGHTr_C4_WEIGHTf_SET
#define C4_WEIGHTr_C4_STRCTf_GET BCM53115_A0_C4_WEIGHTr_C4_STRCTf_GET
#define C4_WEIGHTr_C4_STRCTf_SET BCM53115_A0_C4_WEIGHTr_C4_STRCTf_SET
#define C4_WEIGHTr_RESERVED_Rf_GET BCM53115_A0_C4_WEIGHTr_RESERVED_Rf_GET
#define C4_WEIGHTr_RESERVED_Rf_SET BCM53115_A0_C4_WEIGHTr_RESERVED_Rf_SET
#define READ_C4_WEIGHTr BCM53115_A0_READ_C4_WEIGHTr
#define WRITE_C4_WEIGHTr BCM53115_A0_WRITE_C4_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_C4_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  CFP_ACC
 * BLOCKS:   SYS
 * DESC:     CFP Access Registers
 * SIZE:     32
 * FIELDS:
 *     OP_STR_DONE      Operation Start.Software set this bit to start the operation after having configured all the necessary operation related information to the registers.Hardware automatically clear this bit when the operation is done. For read and write operation, this bit is clear when a single read or write operation is done. For search operation, this bit is clear only when all the searches are done. For TCAM reset, software needn t to set this bit to start the reset.
 *     OP_SEL           Operational Select.3'b000: No op3'b001: Read operation (for TCAM and RAM)3'b010: Write operation (for TCAM and RAM)3'b100: Search operation (for TCAM only)others: reserved
 *     CFP_RAM_CLEAR    
 *     RESERVED_R       
 *     RAM_SEL          RAM Selection.This field selects the target of the operation.5'b1_0000: Out-band Statistic RAM5'b0_1000: In-band Statistic RAM5'b0_0100: Rate Meter RAM5'b0_0010: Action/policy RAM5'b0_0001: TCAM5'b0_0000: no operationothers: not allowed
 *     TCAM_RST         TCAM Reset.Software set this bit to reset all the valid bit of all entries of the TCAM. It is necessary that software to perform TCAM reset before start to programming the TCAM, if software is not going to program all the entries in the TCAM.Software can only reset the TCAM while CFP is in disable state, i.e., no any port is enabled to request CFP lookup. Software is not allowed to reset TCAM in the middle of CFP lookup.Hardware automatically clear this bit when the reset operation is done.
 *     XCESS_ADDR       Access Address.This field indicates the address offset of the RAM blocks for the operation.For read and write operation, this is the target address for the TCAM and RAM blocks.For search operation, this is the initial search address which set by the software.This field contains the address of a valid content when the search_status is set.Hardware finishes search operation whenever it reaches the last entry of the TCAM.
 *     SERCH_STS        Search Status.This field indicates the status of search operation.Hardware will set this bit whenever a valid search content has been updated at the TCAM data register 0-3, and the address has been updated at the address bits of this register.Hardware will auto clear this bit whenever software read this register.After software read this bit as 1, software need to read TCAM_DATA0_REG to TCAM_DATA5_REG, and TCAM_MASK0_REG to TCAM_MASK5_REG.Hardware uses the read operation of TCAM_DATA5_REG as the signal of starting search again, in this case, software need to be carefully arrange the order of reading the TCAM data and mask registers.The TCAM_DATA5_REG need to the last one to read, otherwise, the TCAM data or mask registers might be overwritten by the next valid entry.
 *     RD_STS           Read Status.This field indicates the status of read operation.  1  means read data valid,  0  means read data not yet valid. Hardware will auto clear this bit whenever software read this register.4'b1000: Statistic RAM4'b0100: Rate Meter RAM4'b0010: Action/policy RAM4'b0001: TCAM4'b0000: Not readyOthers: not allowed
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_ACCr 0x0000a000

#define BCM53115_A0_CFP_ACCr_SIZE 4

/*
 * This structure should be used to declare and program CFP_ACC.
 *
 */
typedef union BCM53115_A0_CFP_ACCr_s {
	uint32_t v[1];
	uint32_t cfp_acc[1];
	uint32_t _cfp_acc;
} BCM53115_A0_CFP_ACCr_t;

#define BCM53115_A0_CFP_ACCr_CLR(r) (r).cfp_acc[0] = 0
#define BCM53115_A0_CFP_ACCr_SET(r,d) (r).cfp_acc[0] = d
#define BCM53115_A0_CFP_ACCr_GET(r) (r).cfp_acc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_ACCr_OP_STR_DONEf_GET(r) (((r).cfp_acc[0]) & 0x1)
#define BCM53115_A0_CFP_ACCr_OP_STR_DONEf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_CFP_ACCr_OP_SELf_GET(r) ((((r).cfp_acc[0]) >> 1) & 0x7)
#define BCM53115_A0_CFP_ACCr_OP_SELf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53115_A0_CFP_ACCr_CFP_RAM_CLEARf_GET(r) ((((r).cfp_acc[0]) >> 4) & 0x1)
#define BCM53115_A0_CFP_ACCr_CFP_RAM_CLEARf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_CFP_ACCr_RESERVED_Rf_GET(r) ((((r).cfp_acc[0]) >> 5) & 0x1f)
#define BCM53115_A0_CFP_ACCr_RESERVED_Rf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM53115_A0_CFP_ACCr_RAM_SELf_GET(r) ((((r).cfp_acc[0]) >> 10) & 0x1f)
#define BCM53115_A0_CFP_ACCr_RAM_SELf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM53115_A0_CFP_ACCr_TCAM_RSTf_GET(r) ((((r).cfp_acc[0]) >> 15) & 0x1)
#define BCM53115_A0_CFP_ACCr_TCAM_RSTf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_CFP_ACCr_XCESS_ADDRf_GET(r) ((((r).cfp_acc[0]) >> 16) & 0xff)
#define BCM53115_A0_CFP_ACCr_XCESS_ADDRf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53115_A0_CFP_ACCr_SERCH_STSf_GET(r) ((((r).cfp_acc[0]) >> 27) & 0x1)
#define BCM53115_A0_CFP_ACCr_SERCH_STSf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_CFP_ACCr_RD_STSf_GET(r) ((((r).cfp_acc[0]) >> 28) & 0xf)
#define BCM53115_A0_CFP_ACCr_RD_STSf_SET(r,f) (r).cfp_acc[0]=(((r).cfp_acc[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CFP_ACC.
 *
 */
#define BCM53115_A0_READ_CFP_ACCr(u,r) cdk_robo_reg_read(u,BCM53115_A0_CFP_ACCr,(r._cfp_acc),4)
#define BCM53115_A0_WRITE_CFP_ACCr(u,r) cdk_robo_reg_write(u,BCM53115_A0_CFP_ACCr,&(r._cfp_acc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_ACCr BCM53115_A0_CFP_ACCr
#define CFP_ACCr_SIZE BCM53115_A0_CFP_ACCr_SIZE
typedef BCM53115_A0_CFP_ACCr_t CFP_ACCr_t;
#define CFP_ACCr_CLR BCM53115_A0_CFP_ACCr_CLR
#define CFP_ACCr_SET BCM53115_A0_CFP_ACCr_SET
#define CFP_ACCr_GET BCM53115_A0_CFP_ACCr_GET
#define CFP_ACCr_OP_STR_DONEf_GET BCM53115_A0_CFP_ACCr_OP_STR_DONEf_GET
#define CFP_ACCr_OP_STR_DONEf_SET BCM53115_A0_CFP_ACCr_OP_STR_DONEf_SET
#define CFP_ACCr_OP_SELf_GET BCM53115_A0_CFP_ACCr_OP_SELf_GET
#define CFP_ACCr_OP_SELf_SET BCM53115_A0_CFP_ACCr_OP_SELf_SET
#define CFP_ACCr_CFP_RAM_CLEARf_GET BCM53115_A0_CFP_ACCr_CFP_RAM_CLEARf_GET
#define CFP_ACCr_CFP_RAM_CLEARf_SET BCM53115_A0_CFP_ACCr_CFP_RAM_CLEARf_SET
#define CFP_ACCr_RESERVED_Rf_GET BCM53115_A0_CFP_ACCr_RESERVED_Rf_GET
#define CFP_ACCr_RESERVED_Rf_SET BCM53115_A0_CFP_ACCr_RESERVED_Rf_SET
#define CFP_ACCr_RAM_SELf_GET BCM53115_A0_CFP_ACCr_RAM_SELf_GET
#define CFP_ACCr_RAM_SELf_SET BCM53115_A0_CFP_ACCr_RAM_SELf_SET
#define CFP_ACCr_TCAM_RSTf_GET BCM53115_A0_CFP_ACCr_TCAM_RSTf_GET
#define CFP_ACCr_TCAM_RSTf_SET BCM53115_A0_CFP_ACCr_TCAM_RSTf_SET
#define CFP_ACCr_XCESS_ADDRf_GET BCM53115_A0_CFP_ACCr_XCESS_ADDRf_GET
#define CFP_ACCr_XCESS_ADDRf_SET BCM53115_A0_CFP_ACCr_XCESS_ADDRf_SET
#define CFP_ACCr_SERCH_STSf_GET BCM53115_A0_CFP_ACCr_SERCH_STSf_GET
#define CFP_ACCr_SERCH_STSf_SET BCM53115_A0_CFP_ACCr_SERCH_STSf_SET
#define CFP_ACCr_RD_STSf_GET BCM53115_A0_CFP_ACCr_RD_STSf_GET
#define CFP_ACCr_RD_STSf_SET BCM53115_A0_CFP_ACCr_RD_STSf_SET
#define READ_CFP_ACCr BCM53115_A0_READ_CFP_ACCr
#define WRITE_CFP_ACCr BCM53115_A0_WRITE_CFP_ACCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_ACCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_ACT_POL
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     64
 * FIELDS:
 *     DST_MAP_IB       
 *     CHANGE_FWRD_MAP_IB 
 *     NEW_DSCP_IB      
 *     CHANGE_DSCP_IB   
 *     DST_MAP_OB       
 *     CHANGE_FWRD_MAP_OB 
 *     NEW_DSCP_OB      
 *     CHANGE_DSCP_OB   
 *     VLAN_BYP         
 *     EAP_BYP          
 *     STP_BYP          
 *     REASON_CODE      
 *     LOOP_BK_EN       
 *     NEW_TC           
 *     CHANGE_TC        
 *     CHAIN_ID         
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_ACT_POLm 0x00005000

#define BCM53115_A0_CFP_ACT_POLm_MIN 0
#define BCM53115_A0_CFP_ACT_POLm_MAX 255
#define BCM53115_A0_CFP_ACT_POLm_CMAX(u) 255
#define BCM53115_A0_CFP_ACT_POLm_SIZE 8

/*
 * This structure should be used to declare and program CFP_ACT_POL.
 *
 */
typedef union BCM53115_A0_CFP_ACT_POLm_s {
	uint32_t v[2];
	uint32_t cfp_act_pol[2];
	uint32_t _cfp_act_pol;
} BCM53115_A0_CFP_ACT_POLm_t;

#define BCM53115_A0_CFP_ACT_POLm_CLR(r) CDK_MEMSET(&((r)._cfp_act_pol), 0, sizeof(BCM53115_A0_CFP_ACT_POLm_t))
#define BCM53115_A0_CFP_ACT_POLm_SET(r,i,d) (r).cfp_act_pol[i] = d
#define BCM53115_A0_CFP_ACT_POLm_GET(r,i) (r).cfp_act_pol[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_ACT_POLm_DST_MAP_IBf_GET(r) (((r).cfp_act_pol[0]) & 0x7f)
#define BCM53115_A0_CFP_ACT_POLm_DST_MAP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 7) & 0x3)
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53115_A0_CFP_ACT_POLm_NEW_DSCP_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 9) & 0x3f)
#define BCM53115_A0_CFP_ACT_POLm_NEW_DSCP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_GET(r) ((((r).cfp_act_pol[0]) >> 15) & 0x1)
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_CFP_ACT_POLm_DST_MAP_OBf_GET(r) ((((r).cfp_act_pol[0]) >> 16) & 0x7f)
#define BCM53115_A0_CFP_ACT_POLm_DST_MAP_OBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_GET(r) ((((r).cfp_act_pol[0]) >> 23) & 0x3)
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3 << 23)) | ((((uint32_t)f) & 0x3) << 23))
#define BCM53115_A0_CFP_ACT_POLm_NEW_DSCP_OBf_GET(r) ((((r).cfp_act_pol[0]) >> 25) & 0x3f)
#define BCM53115_A0_CFP_ACT_POLm_NEW_DSCP_OBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x3f << 25)) | ((((uint32_t)f) & 0x3f) << 25))
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_GET(r) ((((r).cfp_act_pol[0]) >> 31) & 0x1)
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_SET(r,f) (r).cfp_act_pol[0]=(((r).cfp_act_pol[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53115_A0_CFP_ACT_POLm_VLAN_BYPf_GET(r) (((r).cfp_act_pol[1]) & 0x1)
#define BCM53115_A0_CFP_ACT_POLm_VLAN_BYPf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_CFP_ACT_POLm_EAP_BYPf_GET(r) ((((r).cfp_act_pol[1]) >> 1) & 0x1)
#define BCM53115_A0_CFP_ACT_POLm_EAP_BYPf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_CFP_ACT_POLm_STP_BYPf_GET(r) ((((r).cfp_act_pol[1]) >> 2) & 0x1)
#define BCM53115_A0_CFP_ACT_POLm_STP_BYPf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_CFP_ACT_POLm_REASON_CODEf_GET(r) ((((r).cfp_act_pol[1]) >> 3) & 0x3f)
#define BCM53115_A0_CFP_ACT_POLm_REASON_CODEf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM53115_A0_CFP_ACT_POLm_LOOP_BK_ENf_GET(r) ((((r).cfp_act_pol[1]) >> 9) & 0x1)
#define BCM53115_A0_CFP_ACT_POLm_LOOP_BK_ENf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_CFP_ACT_POLm_NEW_TCf_GET(r) ((((r).cfp_act_pol[1]) >> 10) & 0x7)
#define BCM53115_A0_CFP_ACT_POLm_NEW_TCf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_TCf_GET(r) ((((r).cfp_act_pol[1]) >> 13) & 0x1)
#define BCM53115_A0_CFP_ACT_POLm_CHANGE_TCf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_CFP_ACT_POLm_CHAIN_IDf_GET(r) ((((r).cfp_act_pol[1]) >> 14) & 0xff)
#define BCM53115_A0_CFP_ACT_POLm_CHAIN_IDf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0xff << 14)) | ((((uint32_t)f) & 0xff) << 14))
#define BCM53115_A0_CFP_ACT_POLm_RESERVED_1Rf_GET(r) ((((r).cfp_act_pol[1]) >> 22) & 0x3ff)
#define BCM53115_A0_CFP_ACT_POLm_RESERVED_1Rf_SET(r,f) (r).cfp_act_pol[1]=(((r).cfp_act_pol[1] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CFP_ACT_POL.
 *
 */
#define BCM53115_A0_READ_CFP_ACT_POLm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_ACT_POLm,i,(m),8)
#define BCM53115_A0_WRITE_CFP_ACT_POLm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_ACT_POLm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_ACT_POLm BCM53115_A0_CFP_ACT_POLm
#define CFP_ACT_POLm_MIN BCM53115_A0_CFP_ACT_POLm_MIN
#define CFP_ACT_POLm_MAX BCM53115_A0_CFP_ACT_POLm_MAX
#define CFP_ACT_POLm_CMAX(u) BCM53115_A0_CFP_ACT_POLm_CMAX(u)
#define CFP_ACT_POLm_SIZE BCM53115_A0_CFP_ACT_POLm_SIZE
typedef BCM53115_A0_CFP_ACT_POLm_t CFP_ACT_POLm_t;
#define CFP_ACT_POLm_CLR BCM53115_A0_CFP_ACT_POLm_CLR
#define CFP_ACT_POLm_SET BCM53115_A0_CFP_ACT_POLm_SET
#define CFP_ACT_POLm_GET BCM53115_A0_CFP_ACT_POLm_GET
#define CFP_ACT_POLm_DST_MAP_IBf_GET BCM53115_A0_CFP_ACT_POLm_DST_MAP_IBf_GET
#define CFP_ACT_POLm_DST_MAP_IBf_SET BCM53115_A0_CFP_ACT_POLm_DST_MAP_IBf_SET
#define CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_GET BCM53115_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_GET
#define CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_SET BCM53115_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_IBf_SET
#define CFP_ACT_POLm_NEW_DSCP_IBf_GET BCM53115_A0_CFP_ACT_POLm_NEW_DSCP_IBf_GET
#define CFP_ACT_POLm_NEW_DSCP_IBf_SET BCM53115_A0_CFP_ACT_POLm_NEW_DSCP_IBf_SET
#define CFP_ACT_POLm_CHANGE_DSCP_IBf_GET BCM53115_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_GET
#define CFP_ACT_POLm_CHANGE_DSCP_IBf_SET BCM53115_A0_CFP_ACT_POLm_CHANGE_DSCP_IBf_SET
#define CFP_ACT_POLm_DST_MAP_OBf_GET BCM53115_A0_CFP_ACT_POLm_DST_MAP_OBf_GET
#define CFP_ACT_POLm_DST_MAP_OBf_SET BCM53115_A0_CFP_ACT_POLm_DST_MAP_OBf_SET
#define CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_GET BCM53115_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_GET
#define CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_SET BCM53115_A0_CFP_ACT_POLm_CHANGE_FWRD_MAP_OBf_SET
#define CFP_ACT_POLm_NEW_DSCP_OBf_GET BCM53115_A0_CFP_ACT_POLm_NEW_DSCP_OBf_GET
#define CFP_ACT_POLm_NEW_DSCP_OBf_SET BCM53115_A0_CFP_ACT_POLm_NEW_DSCP_OBf_SET
#define CFP_ACT_POLm_CHANGE_DSCP_OBf_GET BCM53115_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_GET
#define CFP_ACT_POLm_CHANGE_DSCP_OBf_SET BCM53115_A0_CFP_ACT_POLm_CHANGE_DSCP_OBf_SET
#define CFP_ACT_POLm_VLAN_BYPf_GET BCM53115_A0_CFP_ACT_POLm_VLAN_BYPf_GET
#define CFP_ACT_POLm_VLAN_BYPf_SET BCM53115_A0_CFP_ACT_POLm_VLAN_BYPf_SET
#define CFP_ACT_POLm_EAP_BYPf_GET BCM53115_A0_CFP_ACT_POLm_EAP_BYPf_GET
#define CFP_ACT_POLm_EAP_BYPf_SET BCM53115_A0_CFP_ACT_POLm_EAP_BYPf_SET
#define CFP_ACT_POLm_STP_BYPf_GET BCM53115_A0_CFP_ACT_POLm_STP_BYPf_GET
#define CFP_ACT_POLm_STP_BYPf_SET BCM53115_A0_CFP_ACT_POLm_STP_BYPf_SET
#define CFP_ACT_POLm_REASON_CODEf_GET BCM53115_A0_CFP_ACT_POLm_REASON_CODEf_GET
#define CFP_ACT_POLm_REASON_CODEf_SET BCM53115_A0_CFP_ACT_POLm_REASON_CODEf_SET
#define CFP_ACT_POLm_LOOP_BK_ENf_GET BCM53115_A0_CFP_ACT_POLm_LOOP_BK_ENf_GET
#define CFP_ACT_POLm_LOOP_BK_ENf_SET BCM53115_A0_CFP_ACT_POLm_LOOP_BK_ENf_SET
#define CFP_ACT_POLm_NEW_TCf_GET BCM53115_A0_CFP_ACT_POLm_NEW_TCf_GET
#define CFP_ACT_POLm_NEW_TCf_SET BCM53115_A0_CFP_ACT_POLm_NEW_TCf_SET
#define CFP_ACT_POLm_CHANGE_TCf_GET BCM53115_A0_CFP_ACT_POLm_CHANGE_TCf_GET
#define CFP_ACT_POLm_CHANGE_TCf_SET BCM53115_A0_CFP_ACT_POLm_CHANGE_TCf_SET
#define CFP_ACT_POLm_CHAIN_IDf_GET BCM53115_A0_CFP_ACT_POLm_CHAIN_IDf_GET
#define CFP_ACT_POLm_CHAIN_IDf_SET BCM53115_A0_CFP_ACT_POLm_CHAIN_IDf_SET
#define CFP_ACT_POLm_RESERVED_1Rf_GET BCM53115_A0_CFP_ACT_POLm_RESERVED_1Rf_GET
#define CFP_ACT_POLm_RESERVED_1Rf_SET BCM53115_A0_CFP_ACT_POLm_RESERVED_1Rf_SET
#define READ_CFP_ACT_POLm BCM53115_A0_READ_CFP_ACT_POLm
#define WRITE_CFP_ACT_POLm BCM53115_A0_WRITE_CFP_ACT_POLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_ACT_POLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  CFP_CTL_REG
 * BLOCKS:   SYS
 * DESC:     CFP Control Registers
 * SIZE:     16
 * FIELDS:
 *     CFP_EN_MAP       The bitmap to enable CFP function. When set to one, the corresponding port CFP feature is enabled.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_CTL_REGr 0x0000a100

#define BCM53115_A0_CFP_CTL_REGr_SIZE 2

/*
 * This structure should be used to declare and program CFP_CTL_REG.
 *
 */
typedef union BCM53115_A0_CFP_CTL_REGr_s {
	uint32_t v[1];
	uint32_t cfp_ctl_reg[1];
	uint32_t _cfp_ctl_reg;
} BCM53115_A0_CFP_CTL_REGr_t;

#define BCM53115_A0_CFP_CTL_REGr_CLR(r) (r).cfp_ctl_reg[0] = 0
#define BCM53115_A0_CFP_CTL_REGr_SET(r,d) (r).cfp_ctl_reg[0] = d
#define BCM53115_A0_CFP_CTL_REGr_GET(r) (r).cfp_ctl_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_CTL_REGr_CFP_EN_MAPf_GET(r) (((r).cfp_ctl_reg[0]) & 0x1ff)
#define BCM53115_A0_CFP_CTL_REGr_CFP_EN_MAPf_SET(r,f) (r).cfp_ctl_reg[0]=(((r).cfp_ctl_reg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_CFP_CTL_REGr_RESERVED_Rf_GET(r) ((((r).cfp_ctl_reg[0]) >> 9) & 0x7f)
#define BCM53115_A0_CFP_CTL_REGr_RESERVED_Rf_SET(r,f) (r).cfp_ctl_reg[0]=(((r).cfp_ctl_reg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access CFP_CTL_REG.
 *
 */
#define BCM53115_A0_READ_CFP_CTL_REGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_CFP_CTL_REGr,(r._cfp_ctl_reg),2)
#define BCM53115_A0_WRITE_CFP_CTL_REGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_CFP_CTL_REGr,&(r._cfp_ctl_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_CTL_REGr BCM53115_A0_CFP_CTL_REGr
#define CFP_CTL_REGr_SIZE BCM53115_A0_CFP_CTL_REGr_SIZE
typedef BCM53115_A0_CFP_CTL_REGr_t CFP_CTL_REGr_t;
#define CFP_CTL_REGr_CLR BCM53115_A0_CFP_CTL_REGr_CLR
#define CFP_CTL_REGr_SET BCM53115_A0_CFP_CTL_REGr_SET
#define CFP_CTL_REGr_GET BCM53115_A0_CFP_CTL_REGr_GET
#define CFP_CTL_REGr_CFP_EN_MAPf_GET BCM53115_A0_CFP_CTL_REGr_CFP_EN_MAPf_GET
#define CFP_CTL_REGr_CFP_EN_MAPf_SET BCM53115_A0_CFP_CTL_REGr_CFP_EN_MAPf_SET
#define CFP_CTL_REGr_RESERVED_Rf_GET BCM53115_A0_CFP_CTL_REGr_RESERVED_Rf_GET
#define CFP_CTL_REGr_RESERVED_Rf_SET BCM53115_A0_CFP_CTL_REGr_RESERVED_Rf_SET
#define READ_CFP_CTL_REGr BCM53115_A0_READ_CFP_CTL_REGr
#define WRITE_CFP_CTL_REGr BCM53115_A0_WRITE_CFP_CTL_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_CTL_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  CFP_DATA
 * BLOCKS:   SYS
 * DESC:     CFP TCAM Data X Registers
 * SIZE:     32
 * FIELDS:
 *     TCAM_DATA        TCAM Data.The data to be read from or write to the TCAM data.Please note that the bit [1:0] of this register are the valid bits of the rule.These two bits should be both 1 to validate this entry.The rules LSB is in this register bit[2].CFP_DATA0[31:0] for tcam_data[31:0]CFP_DATA1[31:0] for tcam_data[63:32]CFP_DATA2[31:0] for tcam_data[95:64]CFP_DATA3[31:0] for tcam_data[127:96]CFP_DATA4[31:0] for tcam_data[159:128]CFP_DATA5[24:0] for tcam_data[185:160]CFP_DATA5[31:25] for Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_DATAr 0x0000a010

#define BCM53115_A0_CFP_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CFP_DATA.
 *
 */
typedef union BCM53115_A0_CFP_DATAr_s {
	uint32_t v[1];
	uint32_t cfp_data[1];
	uint32_t _cfp_data;
} BCM53115_A0_CFP_DATAr_t;

#define BCM53115_A0_CFP_DATAr_CLR(r) (r).cfp_data[0] = 0
#define BCM53115_A0_CFP_DATAr_SET(r,d) (r).cfp_data[0] = d
#define BCM53115_A0_CFP_DATAr_GET(r) (r).cfp_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_DATAr_TCAM_DATAf_GET(r) ((r).cfp_data[0])
#define BCM53115_A0_CFP_DATAr_TCAM_DATAf_SET(r,f) (r).cfp_data[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_DATA.
 *
 */
#define BCM53115_A0_READ_CFP_DATAr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_CFP_DATAr+(4*(i)),(r._cfp_data),4)
#define BCM53115_A0_WRITE_CFP_DATAr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_CFP_DATAr+(4*(i)),&(r._cfp_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_DATAr BCM53115_A0_CFP_DATAr
#define CFP_DATAr_SIZE BCM53115_A0_CFP_DATAr_SIZE
typedef BCM53115_A0_CFP_DATAr_t CFP_DATAr_t;
#define CFP_DATAr_CLR BCM53115_A0_CFP_DATAr_CLR
#define CFP_DATAr_SET BCM53115_A0_CFP_DATAr_SET
#define CFP_DATAr_GET BCM53115_A0_CFP_DATAr_GET
#define CFP_DATAr_TCAM_DATAf_GET BCM53115_A0_CFP_DATAr_TCAM_DATAf_GET
#define CFP_DATAr_TCAM_DATAf_SET BCM53115_A0_CFP_DATAr_TCAM_DATAf_SET
#define READ_CFP_DATAr BCM53115_A0_READ_CFP_DATAr
#define WRITE_CFP_DATAr BCM53115_A0_WRITE_CFP_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  CFP_MASK
 * BLOCKS:   SYS
 * DESC:     CFP TCAM Mask X Registers
 * SIZE:     32
 * FIELDS:
 *     TCAM_MASK        TCAM Data.The data to be read from or write to the TCAM mask.Please note that the bit [1:0] of this register are the valid bits of the rule.These two bits should be both 1 to validate this entry.The masks LSB is in this register bit[2].CFP_MASK0[31:0] for tcam_mask[31:0]CFP_MASK1[31:0] for tcam_mask[63:32]CFP_MASK2[31:0] for tcam_mask[95:64]CFP_MASK3[31:0] for tcam_mask[127:96]CFP_MASK4[31:0] for tcam_mask[159:128]CFP_MASK5[24:0] for tcam_mask[185:160]CFP_MASK5[31:25] for Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_MASKr 0x0000a030

#define BCM53115_A0_CFP_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CFP_MASK.
 *
 */
typedef union BCM53115_A0_CFP_MASKr_s {
	uint32_t v[1];
	uint32_t cfp_mask[1];
	uint32_t _cfp_mask;
} BCM53115_A0_CFP_MASKr_t;

#define BCM53115_A0_CFP_MASKr_CLR(r) (r).cfp_mask[0] = 0
#define BCM53115_A0_CFP_MASKr_SET(r,d) (r).cfp_mask[0] = d
#define BCM53115_A0_CFP_MASKr_GET(r) (r).cfp_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_MASKr_TCAM_MASKf_GET(r) ((r).cfp_mask[0])
#define BCM53115_A0_CFP_MASKr_TCAM_MASKf_SET(r,f) (r).cfp_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_MASK.
 *
 */
#define BCM53115_A0_READ_CFP_MASKr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_CFP_MASKr+(4*(i)),(r._cfp_mask),4)
#define BCM53115_A0_WRITE_CFP_MASKr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_CFP_MASKr+(4*(i)),&(r._cfp_mask),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_MASKr BCM53115_A0_CFP_MASKr
#define CFP_MASKr_SIZE BCM53115_A0_CFP_MASKr_SIZE
typedef BCM53115_A0_CFP_MASKr_t CFP_MASKr_t;
#define CFP_MASKr_CLR BCM53115_A0_CFP_MASKr_CLR
#define CFP_MASKr_SET BCM53115_A0_CFP_MASKr_SET
#define CFP_MASKr_GET BCM53115_A0_CFP_MASKr_GET
#define CFP_MASKr_TCAM_MASKf_GET BCM53115_A0_CFP_MASKr_TCAM_MASKf_GET
#define CFP_MASKr_TCAM_MASKf_SET BCM53115_A0_CFP_MASKr_TCAM_MASKf_SET
#define READ_CFP_MASKr BCM53115_A0_READ_CFP_MASKr
#define WRITE_CFP_MASKr BCM53115_A0_WRITE_CFP_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_METER
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     64
 * FIELDS:
 *     CURR_QUOTA       Current Quota.This field is initialized by software as the initial credit for each flow. And hardware will update the current quota according to the per flow rate meter scheme. The unit is in byte.
 *     RESERVED_1R      Reserved
 *     TOKEN_NUM        Token.This token to be added on each refresh cycle, theunit is 32 byte.
 *     REF_CAP          Reference CAP.This field indicates the max bucket size per flow need to keep track off. The unit is in byte.5'b0_0000: ref_cap = 24'b1111_1111_1111_1111_1111_1111;5'b0_0001: ref_cap = 24'b0111_1111_1111_1111_1111_1111;5'b0_0010: ref_cap = 24'b0011_1111_1111_1111_1111_1111;5'b0_0011: ref_cap = 24'b0001_1111_1111_1111_1111_1111;5'b0_0100: ref_cap = 24'b0000_1111_1111_1111_1111_1111;5'b0_0101: ref_cap = 24'b0000_0111_1111_1111_1111_1111;5'b0_0110: ref_cap = 24'b0000_0011_1111_1111_1111_1111;5'b0_0111: ref_cap = 24'b0000_0001_1111_1111_1111_1111;5'b0_1000: ref_cap = 24'b0000_0000_1111_1111_1111_1111;5'b0_1001: ref_cap = 24'b0000_0000_0111_1111_1111_1111;5'b0_1010: ref_cap = 24'b0000_0000_0011_1111_1111_1111;5'b0_1011: ref_cap = 24'b0000_0000_0001_1111_1111_1111;5'b0_1100: ref_cap = 24'b0000_0000_0000_1111_1111_1111;5'b0_1101: ref_cap = 24'b0000_0000_0000_0111_1111_1111;5'b0_1110: ref_cap = 24'b0000_0000_0000_0011_1111_1111;5'b0_1111: ref_cap = 24'b0000_0000_0000_0001_1111_1111;others: reserved
 *     RESERVED_2R      Reserved
 *     RATE_REFRESH_EN  Rate Meter Refresh Enable.This field enables hardware for rate meter refresh.Software should set this bit after the rate meter RAM has been initialized, and software would like to start rate meter refresh (Global control).
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_METERm 0x00005100

#define BCM53115_A0_CFP_METERm_MIN 0
#define BCM53115_A0_CFP_METERm_MAX 255
#define BCM53115_A0_CFP_METERm_CMAX(u) 255
#define BCM53115_A0_CFP_METERm_SIZE 8

/*
 * This structure should be used to declare and program CFP_METER.
 *
 */
typedef union BCM53115_A0_CFP_METERm_s {
	uint32_t v[2];
	uint32_t cfp_meter[2];
	uint32_t _cfp_meter;
} BCM53115_A0_CFP_METERm_t;

#define BCM53115_A0_CFP_METERm_CLR(r) CDK_MEMSET(&((r)._cfp_meter), 0, sizeof(BCM53115_A0_CFP_METERm_t))
#define BCM53115_A0_CFP_METERm_SET(r,i,d) (r).cfp_meter[i] = d
#define BCM53115_A0_CFP_METERm_GET(r,i) (r).cfp_meter[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_METERm_CURR_QUOTAf_GET(r) (((r).cfp_meter[0]) & 0xffffff)
#define BCM53115_A0_CFP_METERm_CURR_QUOTAf_SET(r,f) (r).cfp_meter[0]=(((r).cfp_meter[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53115_A0_CFP_METERm_RESERVED_1Rf_GET(r) ((((r).cfp_meter[0]) >> 24) & 0xff)
#define BCM53115_A0_CFP_METERm_RESERVED_1Rf_SET(r,f) (r).cfp_meter[0]=(((r).cfp_meter[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53115_A0_CFP_METERm_TOKEN_NUMf_GET(r) (((r).cfp_meter[1]) & 0xff)
#define BCM53115_A0_CFP_METERm_TOKEN_NUMf_SET(r,f) (r).cfp_meter[1]=(((r).cfp_meter[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_CFP_METERm_REF_CAPf_GET(r) ((((r).cfp_meter[1]) >> 8) & 0xf)
#define BCM53115_A0_CFP_METERm_REF_CAPf_SET(r,f) (r).cfp_meter[1]=(((r).cfp_meter[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_CFP_METERm_RESERVED_2Rf_GET(r) ((((r).cfp_meter[1]) >> 12) & 0x7ffff)
#define BCM53115_A0_CFP_METERm_RESERVED_2Rf_SET(r,f) (r).cfp_meter[1]=(((r).cfp_meter[1] & ~((uint32_t)0x7ffff << 12)) | ((((uint32_t)f) & 0x7ffff) << 12))
#define BCM53115_A0_CFP_METERm_RATE_REFRESH_ENf_GET(r) ((((r).cfp_meter[1]) >> 31) & 0x1)
#define BCM53115_A0_CFP_METERm_RATE_REFRESH_ENf_SET(r,f) (r).cfp_meter[1]=(((r).cfp_meter[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CFP_METER.
 *
 */
#define BCM53115_A0_READ_CFP_METERm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_METERm,i,(m),8)
#define BCM53115_A0_WRITE_CFP_METERm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_METERm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_METERm BCM53115_A0_CFP_METERm
#define CFP_METERm_MIN BCM53115_A0_CFP_METERm_MIN
#define CFP_METERm_MAX BCM53115_A0_CFP_METERm_MAX
#define CFP_METERm_CMAX(u) BCM53115_A0_CFP_METERm_CMAX(u)
#define CFP_METERm_SIZE BCM53115_A0_CFP_METERm_SIZE
typedef BCM53115_A0_CFP_METERm_t CFP_METERm_t;
#define CFP_METERm_CLR BCM53115_A0_CFP_METERm_CLR
#define CFP_METERm_SET BCM53115_A0_CFP_METERm_SET
#define CFP_METERm_GET BCM53115_A0_CFP_METERm_GET
#define CFP_METERm_CURR_QUOTAf_GET BCM53115_A0_CFP_METERm_CURR_QUOTAf_GET
#define CFP_METERm_CURR_QUOTAf_SET BCM53115_A0_CFP_METERm_CURR_QUOTAf_SET
#define CFP_METERm_RESERVED_1Rf_GET BCM53115_A0_CFP_METERm_RESERVED_1Rf_GET
#define CFP_METERm_RESERVED_1Rf_SET BCM53115_A0_CFP_METERm_RESERVED_1Rf_SET
#define CFP_METERm_TOKEN_NUMf_GET BCM53115_A0_CFP_METERm_TOKEN_NUMf_GET
#define CFP_METERm_TOKEN_NUMf_SET BCM53115_A0_CFP_METERm_TOKEN_NUMf_SET
#define CFP_METERm_REF_CAPf_GET BCM53115_A0_CFP_METERm_REF_CAPf_GET
#define CFP_METERm_REF_CAPf_SET BCM53115_A0_CFP_METERm_REF_CAPf_SET
#define CFP_METERm_RESERVED_2Rf_GET BCM53115_A0_CFP_METERm_RESERVED_2Rf_GET
#define CFP_METERm_RESERVED_2Rf_SET BCM53115_A0_CFP_METERm_RESERVED_2Rf_SET
#define CFP_METERm_RATE_REFRESH_ENf_GET BCM53115_A0_CFP_METERm_RATE_REFRESH_ENf_GET
#define CFP_METERm_RATE_REFRESH_ENf_SET BCM53115_A0_CFP_METERm_RATE_REFRESH_ENf_SET
#define READ_CFP_METERm BCM53115_A0_READ_CFP_METERm
#define WRITE_CFP_METERm BCM53115_A0_WRITE_CFP_METERm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_METERm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_STAT_IB
 * BLOCKS:   SYS
 * DESC:     Statistic In-Band RAM
 * SIZE:     32
 * FIELDS:
 *     IN_BAND_CNT      In band counter
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_STAT_IBm 0x00005300

#define BCM53115_A0_CFP_STAT_IBm_MIN 0
#define BCM53115_A0_CFP_STAT_IBm_MAX 255
#define BCM53115_A0_CFP_STAT_IBm_CMAX(u) 255
#define BCM53115_A0_CFP_STAT_IBm_SIZE 4

/*
 * This structure should be used to declare and program CFP_STAT_IB.
 *
 */
typedef union BCM53115_A0_CFP_STAT_IBm_s {
	uint32_t v[1];
	uint32_t cfp_stat_ib[1];
	uint32_t _cfp_stat_ib;
} BCM53115_A0_CFP_STAT_IBm_t;

#define BCM53115_A0_CFP_STAT_IBm_CLR(r) (r).cfp_stat_ib[0] = 0
#define BCM53115_A0_CFP_STAT_IBm_SET(r,d) (r).cfp_stat_ib[0] = d
#define BCM53115_A0_CFP_STAT_IBm_GET(r) (r).cfp_stat_ib[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_STAT_IBm_IN_BAND_CNTf_GET(r) ((r).cfp_stat_ib[0])
#define BCM53115_A0_CFP_STAT_IBm_IN_BAND_CNTf_SET(r,f) (r).cfp_stat_ib[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_STAT_IB.
 *
 */
#define BCM53115_A0_READ_CFP_STAT_IBm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_STAT_IBm,i,(m),4)
#define BCM53115_A0_WRITE_CFP_STAT_IBm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_STAT_IBm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_STAT_IBm BCM53115_A0_CFP_STAT_IBm
#define CFP_STAT_IBm_MIN BCM53115_A0_CFP_STAT_IBm_MIN
#define CFP_STAT_IBm_MAX BCM53115_A0_CFP_STAT_IBm_MAX
#define CFP_STAT_IBm_CMAX(u) BCM53115_A0_CFP_STAT_IBm_CMAX(u)
#define CFP_STAT_IBm_SIZE BCM53115_A0_CFP_STAT_IBm_SIZE
typedef BCM53115_A0_CFP_STAT_IBm_t CFP_STAT_IBm_t;
#define CFP_STAT_IBm_CLR BCM53115_A0_CFP_STAT_IBm_CLR
#define CFP_STAT_IBm_SET BCM53115_A0_CFP_STAT_IBm_SET
#define CFP_STAT_IBm_GET BCM53115_A0_CFP_STAT_IBm_GET
#define CFP_STAT_IBm_IN_BAND_CNTf_GET BCM53115_A0_CFP_STAT_IBm_IN_BAND_CNTf_GET
#define CFP_STAT_IBm_IN_BAND_CNTf_SET BCM53115_A0_CFP_STAT_IBm_IN_BAND_CNTf_SET
#define READ_CFP_STAT_IBm BCM53115_A0_READ_CFP_STAT_IBm
#define WRITE_CFP_STAT_IBm BCM53115_A0_WRITE_CFP_STAT_IBm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_STAT_IBm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_STAT_OB
 * BLOCKS:   SYS
 * DESC:     Statistic Out-Band RAM
 * SIZE:     32
 * FIELDS:
 *     OUT_BAND_CNT     Out band counter
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_STAT_OBm 0x00005200

#define BCM53115_A0_CFP_STAT_OBm_MIN 0
#define BCM53115_A0_CFP_STAT_OBm_MAX 255
#define BCM53115_A0_CFP_STAT_OBm_CMAX(u) 255
#define BCM53115_A0_CFP_STAT_OBm_SIZE 4

/*
 * This structure should be used to declare and program CFP_STAT_OB.
 *
 */
typedef union BCM53115_A0_CFP_STAT_OBm_s {
	uint32_t v[1];
	uint32_t cfp_stat_ob[1];
	uint32_t _cfp_stat_ob;
} BCM53115_A0_CFP_STAT_OBm_t;

#define BCM53115_A0_CFP_STAT_OBm_CLR(r) (r).cfp_stat_ob[0] = 0
#define BCM53115_A0_CFP_STAT_OBm_SET(r,d) (r).cfp_stat_ob[0] = d
#define BCM53115_A0_CFP_STAT_OBm_GET(r) (r).cfp_stat_ob[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_STAT_OBm_OUT_BAND_CNTf_GET(r) ((r).cfp_stat_ob[0])
#define BCM53115_A0_CFP_STAT_OBm_OUT_BAND_CNTf_SET(r,f) (r).cfp_stat_ob[0]=((uint32_t)f)

/*
 * These macros can be used to access CFP_STAT_OB.
 *
 */
#define BCM53115_A0_READ_CFP_STAT_OBm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_STAT_OBm,i,(m),4)
#define BCM53115_A0_WRITE_CFP_STAT_OBm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_STAT_OBm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_STAT_OBm BCM53115_A0_CFP_STAT_OBm
#define CFP_STAT_OBm_MIN BCM53115_A0_CFP_STAT_OBm_MIN
#define CFP_STAT_OBm_MAX BCM53115_A0_CFP_STAT_OBm_MAX
#define CFP_STAT_OBm_CMAX(u) BCM53115_A0_CFP_STAT_OBm_CMAX(u)
#define CFP_STAT_OBm_SIZE BCM53115_A0_CFP_STAT_OBm_SIZE
typedef BCM53115_A0_CFP_STAT_OBm_t CFP_STAT_OBm_t;
#define CFP_STAT_OBm_CLR BCM53115_A0_CFP_STAT_OBm_CLR
#define CFP_STAT_OBm_SET BCM53115_A0_CFP_STAT_OBm_SET
#define CFP_STAT_OBm_GET BCM53115_A0_CFP_STAT_OBm_GET
#define CFP_STAT_OBm_OUT_BAND_CNTf_GET BCM53115_A0_CFP_STAT_OBm_OUT_BAND_CNTf_GET
#define CFP_STAT_OBm_OUT_BAND_CNTf_SET BCM53115_A0_CFP_STAT_OBm_OUT_BAND_CNTf_SET
#define READ_CFP_STAT_OBm BCM53115_A0_READ_CFP_STAT_OBm
#define WRITE_CFP_STAT_OBm BCM53115_A0_WRITE_CFP_STAT_OBm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_STAT_OBm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_TCAM_CHAIN_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Field Mask
 *     SC_N_ID          Field Mask
 *     RESERVED_R       Reserved
 *     UDF_N_D0         Field Mask
 *     UDF_N_D1         Field Mask
 *     UDF_N_D2         Field Mask
 *     UDF_N_D3         Field Mask
 *     UDF_N_D4         Field Mask
 *     UDF_N_D5         Field Mask
 *     UDF_N_D6         Field Mask
 *     UDF_N_D7         Field Mask
 *     UDF_N_D8         Field Mask
 *     UDF_N_D9         Field Mask
 *     UDF_N_D10        Field Mask
 *     UDF_N_D11        Field Mask
 *     UDF0_VLD         Field Mask
 *     UDF1_VLD         Field Mask
 *     UDF2_VLD         Field Mask
 *     UDF3_VLD         Field Mask
 *     UDF4_VLD         Field Mask
 *     UDF5_VLD         Field Mask
 *     UDF6_VLD         Field Mask
 *     UDF7_VLD         Field Mask
 *     UDF8_VLD         Field Mask
 *     UDF9_VLD         Field Mask
 *     UDF10_VLD        Field Mask
 *     UDF11_VLD        Field Mask
 *     RESERVED_1R      Reserved
 *     CHAIN_ID         Field Mask
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm 0x00004e00

#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_MIN 0
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_MAX 255
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_CMAX(u) 255
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_CHAIN_MASK.
 *
 */
typedef union BCM53115_A0_CFP_TCAM_CHAIN_MASKm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_chain_mask[8];
	uint32_t _cfp_tcam_chain_mask;
} BCM53115_A0_CFP_TCAM_CHAIN_MASKm_t;

#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_chain_mask), 0, sizeof(BCM53115_A0_CFP_TCAM_CHAIN_MASKm_t))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_SET(r,i,d) (r).cfp_tcam_chain_mask[i] = d
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_GET(r,i) (r).cfp_tcam_chain_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_VALID_Rf_GET(r) (((r).cfp_tcam_chain_mask[0]) & 0x3)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_SC_N_IDf_GET(r) ((((r).cfp_tcam_chain_mask[0]) >> 2) & 0x3)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_SC_N_IDf_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_chain_mask[0]) >> 4) & 0xf)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_GET(r) ((((r).cfp_tcam_chain_mask[0]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_SET(r,f) (r).cfp_tcam_chain_mask[0]=(((r).cfp_tcam_chain_mask[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,24,39)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,24,39,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_GET(r) ((((r).cfp_tcam_chain_mask[1]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_SET(r,f) (r).cfp_tcam_chain_mask[1]=(((r).cfp_tcam_chain_mask[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,56,71)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,56,71,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_GET(r) ((((r).cfp_tcam_chain_mask[2]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_SET(r,f) (r).cfp_tcam_chain_mask[2]=(((r).cfp_tcam_chain_mask[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,88,103)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,88,103,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_GET(r) ((((r).cfp_tcam_chain_mask[3]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_SET(r,f) (r).cfp_tcam_chain_mask[3]=(((r).cfp_tcam_chain_mask[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,120,135)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,120,135,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_GET(r) ((((r).cfp_tcam_chain_mask[4]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_SET(r,f) (r).cfp_tcam_chain_mask[4]=(((r).cfp_tcam_chain_mask[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,152,167)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,152,167,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_GET(r) ((((r).cfp_tcam_chain_mask[5]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_SET(r,f) (r).cfp_tcam_chain_mask[5]=(((r).cfp_tcam_chain_mask[5] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_GET(r) cdk_field32_get((r).cfp_tcam_chain_mask,184,199)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_mask,184,199,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 8) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 9) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 10) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 11) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 12) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 13) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 14) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 15) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 16) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 17) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 18) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 19) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 20) & 0xf)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET(r) ((((r).cfp_tcam_chain_mask[6]) >> 24) & 0xff)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET(r,f) (r).cfp_tcam_chain_mask[6]=(((r).cfp_tcam_chain_mask[6] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_GET(r) (((r).cfp_tcam_chain_mask[7]) & 0xff)
#define BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_SET(r,f) (r).cfp_tcam_chain_mask[7]=(((r).cfp_tcam_chain_mask[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_CHAIN_MASK.
 *
 */
#define BCM53115_A0_READ_CFP_TCAM_CHAIN_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_TCAM_CHAIN_MASKm,i,(m),29)
#define BCM53115_A0_WRITE_CFP_TCAM_CHAIN_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_TCAM_CHAIN_MASKm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_CHAIN_MASKm BCM53115_A0_CFP_TCAM_CHAIN_MASKm
#define CFP_TCAM_CHAIN_MASKm_MIN BCM53115_A0_CFP_TCAM_CHAIN_MASKm_MIN
#define CFP_TCAM_CHAIN_MASKm_MAX BCM53115_A0_CFP_TCAM_CHAIN_MASKm_MAX
#define CFP_TCAM_CHAIN_MASKm_CMAX(u) BCM53115_A0_CFP_TCAM_CHAIN_MASKm_CMAX(u)
#define CFP_TCAM_CHAIN_MASKm_SIZE BCM53115_A0_CFP_TCAM_CHAIN_MASKm_SIZE
typedef BCM53115_A0_CFP_TCAM_CHAIN_MASKm_t CFP_TCAM_CHAIN_MASKm_t;
#define CFP_TCAM_CHAIN_MASKm_CLR BCM53115_A0_CFP_TCAM_CHAIN_MASKm_CLR
#define CFP_TCAM_CHAIN_MASKm_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_SET
#define CFP_TCAM_CHAIN_MASKm_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_GET
#define CFP_TCAM_CHAIN_MASKm_VALID_Rf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_VALID_Rf_GET
#define CFP_TCAM_CHAIN_MASKm_VALID_Rf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_VALID_Rf_SET
#define CFP_TCAM_CHAIN_MASKm_SC_N_IDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_SC_N_IDf_GET
#define CFP_TCAM_CHAIN_MASKm_SC_N_IDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_SC_N_IDf_SET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_GET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_Rf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D0f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D1f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D2f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D3f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D4f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D5f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D6f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D7f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D8f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D9f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D10f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_GET
#define CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF_N_D11f_SET
#define CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF0_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF1_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF2_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF3_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF4_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF5_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF6_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF7_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF8_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF9_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF10_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_GET
#define CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_UDF11_VLDf_SET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_GET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_1Rf_SET
#define CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_GET
#define CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_CHAIN_IDf_SET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_GET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_GET
#define CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_SET BCM53115_A0_CFP_TCAM_CHAIN_MASKm_RESERVED_2Rf_SET
#define READ_CFP_TCAM_CHAIN_MASKm BCM53115_A0_READ_CFP_TCAM_CHAIN_MASKm
#define WRITE_CFP_TCAM_CHAIN_MASKm BCM53115_A0_WRITE_CFP_TCAM_CHAIN_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_TCAM_CHAIN_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_TCAM_CHAIN_SC
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Valid bits
 *     SC_N_ID          Slice n indentification:00 => Slice 0, n = 001 => Slice 1, n = 110 => Slice 2, n = 211 => Slice 3(Chain Slice), n = 3
 *     RESERVED_R       Reserved
 *     UDF_N_D0         User define field 0
 *     UDF_N_D1         User define field 1
 *     UDF_N_D2         User define field 2
 *     UDF_N_D3         User define field 3
 *     UDF_N_D4         User define field 4
 *     UDF_N_D5         User define field 5
 *     UDF_N_D6         User define field 6
 *     UDF_N_D7         User define field 7
 *     UDF_N_D8         User define field 8
 *     UDF_N_D9         User define field 9
 *     UDF_N_D10        User define field 10
 *     UDF_N_D11        User define field 11
 *     UDF0_VLD         Valid indication for UDF_n_D0
 *     UDF1_VLD         Valid indication for UDF_n_D1
 *     UDF2_VLD         Valid indication for UDF_n_D2
 *     UDF3_VLD         Valid indication for UDF_n_D3
 *     UDF4_VLD         Valid indication for UDF_n_D4
 *     UDF5_VLD         Valid indication for UDF_n_D5
 *     UDF6_VLD         Valid indication for UDF_n_D6
 *     UDF7_VLD         Valid indication for UDF_n_D7
 *     UDF8_VLD         Valid indication for UDF_n_D8
 *     UDF9_VLD         Valid indication for UDF_n_D9
 *     UDF10_VLD        Valid indication for UDF_n_D10
 *     UDF11_VLD        Valid indication for UDF_n_D11
 *     RESERVED_1R      Reserved
 *     CHAIN_ID         The abstract ID found from Slice 0 chained rule searching
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm 0x00004600

#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_MIN 0
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_MAX 255
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_CMAX(u) 255
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_CHAIN_SC.
 *
 */
typedef union BCM53115_A0_CFP_TCAM_CHAIN_SCm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_chain_sc[8];
	uint32_t _cfp_tcam_chain_sc;
} BCM53115_A0_CFP_TCAM_CHAIN_SCm_t;

#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_chain_sc), 0, sizeof(BCM53115_A0_CFP_TCAM_CHAIN_SCm_t))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_SET(r,i,d) (r).cfp_tcam_chain_sc[i] = d
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_GET(r,i) (r).cfp_tcam_chain_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_VALID_Rf_GET(r) (((r).cfp_tcam_chain_sc[0]) & 0x3)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_VALID_Rf_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_SC_N_IDf_GET(r) ((((r).cfp_tcam_chain_sc[0]) >> 2) & 0x3)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_SC_N_IDf_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_chain_sc[0]) >> 4) & 0xf)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D0f_GET(r) ((((r).cfp_tcam_chain_sc[0]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D0f_SET(r,f) (r).cfp_tcam_chain_sc[0]=(((r).cfp_tcam_chain_sc[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D1f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,24,39)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D1f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,24,39,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D2f_GET(r) ((((r).cfp_tcam_chain_sc[1]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D2f_SET(r,f) (r).cfp_tcam_chain_sc[1]=(((r).cfp_tcam_chain_sc[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D3f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,56,71)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D3f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,56,71,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D4f_GET(r) ((((r).cfp_tcam_chain_sc[2]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D4f_SET(r,f) (r).cfp_tcam_chain_sc[2]=(((r).cfp_tcam_chain_sc[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D5f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,88,103)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D5f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,88,103,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D6f_GET(r) ((((r).cfp_tcam_chain_sc[3]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D6f_SET(r,f) (r).cfp_tcam_chain_sc[3]=(((r).cfp_tcam_chain_sc[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D7f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,120,135)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D7f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,120,135,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D8f_GET(r) ((((r).cfp_tcam_chain_sc[4]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D8f_SET(r,f) (r).cfp_tcam_chain_sc[4]=(((r).cfp_tcam_chain_sc[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D9f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,152,167)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D9f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,152,167,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D10f_GET(r) ((((r).cfp_tcam_chain_sc[5]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D10f_SET(r,f) (r).cfp_tcam_chain_sc[5]=(((r).cfp_tcam_chain_sc[5] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D11f_GET(r) cdk_field32_get((r).cfp_tcam_chain_sc,184,199)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D11f_SET(r,f) cdk_field32_set((r).cfp_tcam_chain_sc,184,199,f)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 8) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 9) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 10) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 11) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 12) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 13) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 14) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 15) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF8_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 16) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF9_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 17) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF9_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF10_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 18) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF10_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF11_VLDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 19) & 0x1)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF11_VLDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 20) & 0xf)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET(r) ((((r).cfp_tcam_chain_sc[6]) >> 24) & 0xff)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET(r,f) (r).cfp_tcam_chain_sc[6]=(((r).cfp_tcam_chain_sc[6] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_GET(r) (((r).cfp_tcam_chain_sc[7]) & 0xff)
#define BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_SET(r,f) (r).cfp_tcam_chain_sc[7]=(((r).cfp_tcam_chain_sc[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_CHAIN_SC.
 *
 */
#define BCM53115_A0_READ_CFP_TCAM_CHAIN_SCm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_TCAM_CHAIN_SCm,i,(m),29)
#define BCM53115_A0_WRITE_CFP_TCAM_CHAIN_SCm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_TCAM_CHAIN_SCm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_CHAIN_SCm BCM53115_A0_CFP_TCAM_CHAIN_SCm
#define CFP_TCAM_CHAIN_SCm_MIN BCM53115_A0_CFP_TCAM_CHAIN_SCm_MIN
#define CFP_TCAM_CHAIN_SCm_MAX BCM53115_A0_CFP_TCAM_CHAIN_SCm_MAX
#define CFP_TCAM_CHAIN_SCm_CMAX(u) BCM53115_A0_CFP_TCAM_CHAIN_SCm_CMAX(u)
#define CFP_TCAM_CHAIN_SCm_SIZE BCM53115_A0_CFP_TCAM_CHAIN_SCm_SIZE
typedef BCM53115_A0_CFP_TCAM_CHAIN_SCm_t CFP_TCAM_CHAIN_SCm_t;
#define CFP_TCAM_CHAIN_SCm_CLR BCM53115_A0_CFP_TCAM_CHAIN_SCm_CLR
#define CFP_TCAM_CHAIN_SCm_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_SET
#define CFP_TCAM_CHAIN_SCm_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_GET
#define CFP_TCAM_CHAIN_SCm_VALID_Rf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_VALID_Rf_GET
#define CFP_TCAM_CHAIN_SCm_VALID_Rf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_VALID_Rf_SET
#define CFP_TCAM_CHAIN_SCm_SC_N_IDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_SC_N_IDf_GET
#define CFP_TCAM_CHAIN_SCm_SC_N_IDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_SC_N_IDf_SET
#define CFP_TCAM_CHAIN_SCm_RESERVED_Rf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_Rf_GET
#define CFP_TCAM_CHAIN_SCm_RESERVED_Rf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_Rf_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D0f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D0f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D0f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D0f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D1f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D1f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D1f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D1f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D2f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D2f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D2f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D2f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D3f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D3f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D3f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D3f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D4f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D4f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D4f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D4f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D5f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D5f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D5f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D5f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D6f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D6f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D6f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D6f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D7f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D7f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D7f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D7f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D8f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D8f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D8f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D8f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D9f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D9f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D9f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D9f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D10f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D10f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D10f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D10f_SET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D11f_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D11f_GET
#define CFP_TCAM_CHAIN_SCm_UDF_N_D11f_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF_N_D11f_SET
#define CFP_TCAM_CHAIN_SCm_UDF0_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF0_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF0_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF0_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF1_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF1_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF1_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF1_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF2_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF2_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF2_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF2_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF3_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF3_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF3_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF3_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF4_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF4_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF4_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF4_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF5_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF5_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF5_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF5_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF6_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF6_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF6_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF6_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF7_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF7_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF7_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF7_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF8_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF8_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF8_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF8_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF9_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF9_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF9_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF9_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF10_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF10_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF10_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF10_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_UDF11_VLDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF11_VLDf_GET
#define CFP_TCAM_CHAIN_SCm_UDF11_VLDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_UDF11_VLDf_SET
#define CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_GET
#define CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_1Rf_SET
#define CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_GET
#define CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_CHAIN_IDf_SET
#define CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_GET BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_GET
#define CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_SET BCM53115_A0_CFP_TCAM_CHAIN_SCm_RESERVED_2Rf_SET
#define READ_CFP_TCAM_CHAIN_SCm BCM53115_A0_READ_CFP_TCAM_CHAIN_SCm
#define WRITE_CFP_TCAM_CHAIN_SCm BCM53115_A0_WRITE_CFP_TCAM_CHAIN_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_TCAM_CHAIN_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_TCAM_IPV4_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Field Mask
 *     SC_N_ID          Field Mask
 *     RESERVED_R       Field Mask
 *     UDF_N_A0         Field Mask
 *     UDF_N_A1         Field Mask
 *     UDF_N_A2         Field Mask
 *     UDF_N_A3         Field Mask
 *     UDF_N_A4         Field Mask
 *     UDF_N_A5         Field Mask
 *     UDF_N_A6         Field Mask
 *     UDF_N_A7         Field Mask
 *     UDF_N_A8         Field Mask
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Field Mask
 *     UDF1_VLD         Field Mask
 *     UDF2_VLD         Field Mask
 *     UDF3_VLD         Field Mask
 *     UDF4_VLD         Field Mask
 *     UDF5_VLD         Field Mask
 *     UDF6_VLD         Field Mask
 *     UDF7_VLD         Field Mask
 *     UDF8_VLD         Field Mask
 *     RESERVED_1R      Field Mask
 *     TTL_RANGE        Field Mask
 *     IP_AUTH          Field Mask
 *     NON_FIRST_FRAG   Field Mask
 *     IP_FRAG          Field Mask
 *     IP_PROTO         Field Mask
 *     IP_TOS           Field Mask
 *     L3_FRAMING       Field Mask
 *     L2_FRAMING       Field Mask
 *     C_TAGGED         Field Mask
 *     S_TAGGED         Field Mask
 *     SRC_PMAP         Field Mask
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm 0x00004800

#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_MIN 0
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_MAX 255
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_CMAX(u) 255
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_IPV4_MASK.
 *
 */
typedef union BCM53115_A0_CFP_TCAM_IPV4_MASKm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_ipv4_mask[8];
	uint32_t _cfp_tcam_ipv4_mask;
} BCM53115_A0_CFP_TCAM_IPV4_MASKm_t;

#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_ipv4_mask), 0, sizeof(BCM53115_A0_CFP_TCAM_IPV4_MASKm_t))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SET(r,i,d) (r).cfp_tcam_ipv4_mask[i] = d
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_GET(r,i) (r).cfp_tcam_ipv4_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_VALID_Rf_GET(r) (((r).cfp_tcam_ipv4_mask[0]) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_ipv4_mask[0]=(((r).cfp_tcam_ipv4_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SC_N_IDf_GET(r) ((((r).cfp_tcam_ipv4_mask[0]) >> 2) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SC_N_IDf_SET(r,f) (r).cfp_tcam_ipv4_mask[0]=(((r).cfp_tcam_ipv4_mask[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_ipv4_mask[0]) >> 4) & 0xf)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_ipv4_mask[0]=(((r).cfp_tcam_ipv4_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A0f_GET(r) ((((r).cfp_tcam_ipv4_mask[0]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A0f_SET(r,f) (r).cfp_tcam_ipv4_mask[0]=(((r).cfp_tcam_ipv4_mask[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A1f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,24,39)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A1f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,24,39,f)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A2f_GET(r) ((((r).cfp_tcam_ipv4_mask[1]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A2f_SET(r,f) (r).cfp_tcam_ipv4_mask[1]=(((r).cfp_tcam_ipv4_mask[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A3f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,56,71)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A3f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,56,71,f)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A4f_GET(r) ((((r).cfp_tcam_ipv4_mask[2]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A4f_SET(r,f) (r).cfp_tcam_ipv4_mask[2]=(((r).cfp_tcam_ipv4_mask[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A5f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,88,103)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A5f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,88,103,f)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A6f_GET(r) ((((r).cfp_tcam_ipv4_mask[3]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A6f_SET(r,f) (r).cfp_tcam_ipv4_mask[3]=(((r).cfp_tcam_ipv4_mask[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A7f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,120,135)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A7f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,120,135,f)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A8f_GET(r) ((((r).cfp_tcam_ipv4_mask[4]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A8f_SET(r,f) (r).cfp_tcam_ipv4_mask[4]=(((r).cfp_tcam_ipv4_mask[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_mask,152,163)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_mask,152,163,f)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_CFIf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 4) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_CFIf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_PRIf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 5) & 0x7)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_PRIf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_VIDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 8) & 0xfff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_VIDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_CFIf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 20) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_CFIf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_PRIf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 21) & 0x7)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_PRIf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 24) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 25) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 26) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 27) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 28) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 29) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 30) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_ipv4_mask[5]) >> 31) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[5]=(((r).cfp_tcam_ipv4_mask[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF8_VLDf_GET(r) (((r).cfp_tcam_ipv4_mask[6]) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 1) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 3) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_AUTHf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 5) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_AUTHf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 6) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_FRAGf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 7) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_FRAGf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_PROTOf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 8) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_PROTOf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_TOSf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 16) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_TOSf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 24) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 26) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 28) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv4_mask[6]) >> 30) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv4_mask[6]=(((r).cfp_tcam_ipv4_mask[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SRC_PMAPf_GET(r) (((r).cfp_tcam_ipv4_mask[7]) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV4_MASKm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_ipv4_mask[7]=(((r).cfp_tcam_ipv4_mask[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_IPV4_MASK.
 *
 */
#define BCM53115_A0_READ_CFP_TCAM_IPV4_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_TCAM_IPV4_MASKm,i,(m),29)
#define BCM53115_A0_WRITE_CFP_TCAM_IPV4_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_TCAM_IPV4_MASKm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_IPV4_MASKm BCM53115_A0_CFP_TCAM_IPV4_MASKm
#define CFP_TCAM_IPV4_MASKm_MIN BCM53115_A0_CFP_TCAM_IPV4_MASKm_MIN
#define CFP_TCAM_IPV4_MASKm_MAX BCM53115_A0_CFP_TCAM_IPV4_MASKm_MAX
#define CFP_TCAM_IPV4_MASKm_CMAX(u) BCM53115_A0_CFP_TCAM_IPV4_MASKm_CMAX(u)
#define CFP_TCAM_IPV4_MASKm_SIZE BCM53115_A0_CFP_TCAM_IPV4_MASKm_SIZE
typedef BCM53115_A0_CFP_TCAM_IPV4_MASKm_t CFP_TCAM_IPV4_MASKm_t;
#define CFP_TCAM_IPV4_MASKm_CLR BCM53115_A0_CFP_TCAM_IPV4_MASKm_CLR
#define CFP_TCAM_IPV4_MASKm_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SET
#define CFP_TCAM_IPV4_MASKm_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_GET
#define CFP_TCAM_IPV4_MASKm_VALID_Rf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_VALID_Rf_GET
#define CFP_TCAM_IPV4_MASKm_VALID_Rf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_VALID_Rf_SET
#define CFP_TCAM_IPV4_MASKm_SC_N_IDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SC_N_IDf_GET
#define CFP_TCAM_IPV4_MASKm_SC_N_IDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SC_N_IDf_SET
#define CFP_TCAM_IPV4_MASKm_RESERVED_Rf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_RESERVED_Rf_GET
#define CFP_TCAM_IPV4_MASKm_RESERVED_Rf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_RESERVED_Rf_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A0f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A0f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A0f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A0f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A1f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A1f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A1f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A1f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A2f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A2f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A2f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A2f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A3f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A3f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A3f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A3f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A4f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A4f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A4f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A4f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A5f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A5f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A5f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A5f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A6f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A6f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A6f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A6f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A7f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A7f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A7f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A7f_SET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A8f_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A8f_GET
#define CFP_TCAM_IPV4_MASKm_UDF_N_A8f_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF_N_A8f_SET
#define CFP_TCAM_IPV4_MASKm_USR_VIDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_VIDf_GET
#define CFP_TCAM_IPV4_MASKm_USR_VIDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_VIDf_SET
#define CFP_TCAM_IPV4_MASKm_USR_CFIf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_CFIf_GET
#define CFP_TCAM_IPV4_MASKm_USR_CFIf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_CFIf_SET
#define CFP_TCAM_IPV4_MASKm_USR_PRIf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_PRIf_GET
#define CFP_TCAM_IPV4_MASKm_USR_PRIf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_USR_PRIf_SET
#define CFP_TCAM_IPV4_MASKm_SP_VIDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_VIDf_GET
#define CFP_TCAM_IPV4_MASKm_SP_VIDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_VIDf_SET
#define CFP_TCAM_IPV4_MASKm_SP_CFIf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_CFIf_GET
#define CFP_TCAM_IPV4_MASKm_SP_CFIf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_CFIf_SET
#define CFP_TCAM_IPV4_MASKm_SP_PRIf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_PRIf_GET
#define CFP_TCAM_IPV4_MASKm_SP_PRIf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SP_PRIf_SET
#define CFP_TCAM_IPV4_MASKm_UDF0_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF0_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF0_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF0_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF1_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF1_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF1_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF1_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF2_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF2_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF2_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF2_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF3_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF3_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF3_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF3_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF4_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF4_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF4_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF4_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF5_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF5_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF5_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF5_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF6_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF6_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF6_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF6_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF7_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF7_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF7_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF7_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_UDF8_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF8_VLDf_GET
#define CFP_TCAM_IPV4_MASKm_UDF8_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_UDF8_VLDf_SET
#define CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_GET
#define CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_RESERVED_1Rf_SET
#define CFP_TCAM_IPV4_MASKm_TTL_RANGEf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_TTL_RANGEf_GET
#define CFP_TCAM_IPV4_MASKm_TTL_RANGEf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_TTL_RANGEf_SET
#define CFP_TCAM_IPV4_MASKm_IP_AUTHf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_AUTHf_GET
#define CFP_TCAM_IPV4_MASKm_IP_AUTHf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_AUTHf_SET
#define CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_IPV4_MASKm_IP_FRAGf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_FRAGf_GET
#define CFP_TCAM_IPV4_MASKm_IP_FRAGf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_FRAGf_SET
#define CFP_TCAM_IPV4_MASKm_IP_PROTOf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_PROTOf_GET
#define CFP_TCAM_IPV4_MASKm_IP_PROTOf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_PROTOf_SET
#define CFP_TCAM_IPV4_MASKm_IP_TOSf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_TOSf_GET
#define CFP_TCAM_IPV4_MASKm_IP_TOSf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_IP_TOSf_SET
#define CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_GET
#define CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_L3_FRAMINGf_SET
#define CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_GET
#define CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_L2_FRAMINGf_SET
#define CFP_TCAM_IPV4_MASKm_C_TAGGEDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_C_TAGGEDf_GET
#define CFP_TCAM_IPV4_MASKm_C_TAGGEDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_C_TAGGEDf_SET
#define CFP_TCAM_IPV4_MASKm_S_TAGGEDf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_S_TAGGEDf_GET
#define CFP_TCAM_IPV4_MASKm_S_TAGGEDf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_S_TAGGEDf_SET
#define CFP_TCAM_IPV4_MASKm_SRC_PMAPf_GET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SRC_PMAPf_GET
#define CFP_TCAM_IPV4_MASKm_SRC_PMAPf_SET BCM53115_A0_CFP_TCAM_IPV4_MASKm_SRC_PMAPf_SET
#define READ_CFP_TCAM_IPV4_MASKm BCM53115_A0_READ_CFP_TCAM_IPV4_MASKm
#define WRITE_CFP_TCAM_IPV4_MASKm BCM53115_A0_WRITE_CFP_TCAM_IPV4_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_TCAM_IPV4_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_TCAM_IPV4_SC
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Valid bits
 *     SC_N_ID          Slice n indentification:00 => Slice 0, n = 001 => Slice 1, n = 110 => Slice 2, n = 211 => Slice 3(Chain Slice), n = 3
 *     RESERVED_R       Reserved
 *     UDF_N_A0         User define field 0
 *     UDF_N_A1         User define field 1
 *     UDF_N_A2         User define field 2
 *     UDF_N_A3         User define field 3
 *     UDF_N_A4         User define field 4
 *     UDF_N_A5         User define field 5
 *     UDF_N_A6         User define field 6
 *     UDF_N_A7         User define field 7
 *     UDF_N_A8         User define field 8
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Valid indication for UDF_n_A0
 *     UDF1_VLD         Valid indication for UDF_n_A1
 *     UDF2_VLD         Valid indication for UDF_n_A2
 *     UDF3_VLD         Valid indication for UDF_n_A3
 *     UDF4_VLD         Valid indication for UDF_n_A4
 *     UDF5_VLD         Valid indication for UDF_n_A5
 *     UDF6_VLD         Valid indication for UDF_n_A6
 *     UDF7_VLD         Valid indication for UDF_n_A7
 *     UDF8_VLD         Valid indication for UDF_n_A8
 *     RESERVED_1R      Reserved
 *     TTL_RANGE        b00: TTL=0b01: TTL=1b10: TTL=Othersb11: TTL=255
 *     IP_AUTH          0: Not Authenticated1: Authenticated
 *     NON_FIRST_FRAG   0: Not Fragmented or First Fragment1: NonFirst Fragment
 *     IP_FRAG          0: Not Fragmented1: Fragmented
 *     IP_PROTO         The Protocol field of IPv4 header
 *     IP_TOS           Type Of Service field in IPv4 header
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PMAP         Ingress port indication
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_TCAM_IPV4_SCm 0x00004000

#define BCM53115_A0_CFP_TCAM_IPV4_SCm_MIN 0
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_MAX 255
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_CMAX(u) 255
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_IPV4_SC.
 *
 */
typedef union BCM53115_A0_CFP_TCAM_IPV4_SCm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_ipv4_sc[8];
	uint32_t _cfp_tcam_ipv4_sc;
} BCM53115_A0_CFP_TCAM_IPV4_SCm_t;

#define BCM53115_A0_CFP_TCAM_IPV4_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_ipv4_sc), 0, sizeof(BCM53115_A0_CFP_TCAM_IPV4_SCm_t))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SET(r,i,d) (r).cfp_tcam_ipv4_sc[i] = d
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_GET(r,i) (r).cfp_tcam_ipv4_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_VALID_Rf_GET(r) (((r).cfp_tcam_ipv4_sc[0]) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_VALID_Rf_SET(r,f) (r).cfp_tcam_ipv4_sc[0]=(((r).cfp_tcam_ipv4_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SC_N_IDf_GET(r) ((((r).cfp_tcam_ipv4_sc[0]) >> 2) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SC_N_IDf_SET(r,f) (r).cfp_tcam_ipv4_sc[0]=(((r).cfp_tcam_ipv4_sc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_ipv4_sc[0]) >> 4) & 0xf)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_ipv4_sc[0]=(((r).cfp_tcam_ipv4_sc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A0f_GET(r) ((((r).cfp_tcam_ipv4_sc[0]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A0f_SET(r,f) (r).cfp_tcam_ipv4_sc[0]=(((r).cfp_tcam_ipv4_sc[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A1f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,24,39)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A1f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,24,39,f)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A2f_GET(r) ((((r).cfp_tcam_ipv4_sc[1]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A2f_SET(r,f) (r).cfp_tcam_ipv4_sc[1]=(((r).cfp_tcam_ipv4_sc[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A3f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,56,71)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A3f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,56,71,f)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A4f_GET(r) ((((r).cfp_tcam_ipv4_sc[2]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A4f_SET(r,f) (r).cfp_tcam_ipv4_sc[2]=(((r).cfp_tcam_ipv4_sc[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A5f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,88,103)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A5f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,88,103,f)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A6f_GET(r) ((((r).cfp_tcam_ipv4_sc[3]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A6f_SET(r,f) (r).cfp_tcam_ipv4_sc[3]=(((r).cfp_tcam_ipv4_sc[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A7f_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,120,135)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A7f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,120,135,f)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A8f_GET(r) ((((r).cfp_tcam_ipv4_sc[4]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A8f_SET(r,f) (r).cfp_tcam_ipv4_sc[4]=(((r).cfp_tcam_ipv4_sc[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_ipv4_sc,152,163)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv4_sc,152,163,f)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_CFIf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 4) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_CFIf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_PRIf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 5) & 0x7)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_PRIf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_VIDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 8) & 0xfff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_VIDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_CFIf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 20) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_CFIf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_PRIf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 21) & 0x7)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_PRIf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 24) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 25) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 26) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 27) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 28) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 29) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 30) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_ipv4_sc[5]) >> 31) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[5]=(((r).cfp_tcam_ipv4_sc[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF8_VLDf_GET(r) (((r).cfp_tcam_ipv4_sc[6]) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 1) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 3) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_AUTHf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 5) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_AUTHf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 6) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_FRAGf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 7) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_FRAGf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_PROTOf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 8) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_PROTOf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_TOSf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 16) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_TOSf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 24) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 26) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 28) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv4_sc[6]) >> 30) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv4_sc[6]=(((r).cfp_tcam_ipv4_sc[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SRC_PMAPf_GET(r) (((r).cfp_tcam_ipv4_sc[7]) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV4_SCm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_ipv4_sc[7]=(((r).cfp_tcam_ipv4_sc[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_IPV4_SC.
 *
 */
#define BCM53115_A0_READ_CFP_TCAM_IPV4_SCm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_TCAM_IPV4_SCm,i,(m),29)
#define BCM53115_A0_WRITE_CFP_TCAM_IPV4_SCm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_TCAM_IPV4_SCm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_IPV4_SCm BCM53115_A0_CFP_TCAM_IPV4_SCm
#define CFP_TCAM_IPV4_SCm_MIN BCM53115_A0_CFP_TCAM_IPV4_SCm_MIN
#define CFP_TCAM_IPV4_SCm_MAX BCM53115_A0_CFP_TCAM_IPV4_SCm_MAX
#define CFP_TCAM_IPV4_SCm_CMAX(u) BCM53115_A0_CFP_TCAM_IPV4_SCm_CMAX(u)
#define CFP_TCAM_IPV4_SCm_SIZE BCM53115_A0_CFP_TCAM_IPV4_SCm_SIZE
typedef BCM53115_A0_CFP_TCAM_IPV4_SCm_t CFP_TCAM_IPV4_SCm_t;
#define CFP_TCAM_IPV4_SCm_CLR BCM53115_A0_CFP_TCAM_IPV4_SCm_CLR
#define CFP_TCAM_IPV4_SCm_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_SET
#define CFP_TCAM_IPV4_SCm_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_GET
#define CFP_TCAM_IPV4_SCm_VALID_Rf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_VALID_Rf_GET
#define CFP_TCAM_IPV4_SCm_VALID_Rf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_VALID_Rf_SET
#define CFP_TCAM_IPV4_SCm_SC_N_IDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_SC_N_IDf_GET
#define CFP_TCAM_IPV4_SCm_SC_N_IDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_SC_N_IDf_SET
#define CFP_TCAM_IPV4_SCm_RESERVED_Rf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_RESERVED_Rf_GET
#define CFP_TCAM_IPV4_SCm_RESERVED_Rf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_RESERVED_Rf_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A0f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A0f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A0f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A0f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A1f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A1f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A1f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A1f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A2f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A2f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A2f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A2f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A3f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A3f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A3f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A3f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A4f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A4f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A4f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A4f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A5f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A5f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A5f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A5f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A6f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A6f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A6f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A6f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A7f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A7f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A7f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A7f_SET
#define CFP_TCAM_IPV4_SCm_UDF_N_A8f_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A8f_GET
#define CFP_TCAM_IPV4_SCm_UDF_N_A8f_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF_N_A8f_SET
#define CFP_TCAM_IPV4_SCm_USR_VIDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_VIDf_GET
#define CFP_TCAM_IPV4_SCm_USR_VIDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_VIDf_SET
#define CFP_TCAM_IPV4_SCm_USR_CFIf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_CFIf_GET
#define CFP_TCAM_IPV4_SCm_USR_CFIf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_CFIf_SET
#define CFP_TCAM_IPV4_SCm_USR_PRIf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_PRIf_GET
#define CFP_TCAM_IPV4_SCm_USR_PRIf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_USR_PRIf_SET
#define CFP_TCAM_IPV4_SCm_SP_VIDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_VIDf_GET
#define CFP_TCAM_IPV4_SCm_SP_VIDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_VIDf_SET
#define CFP_TCAM_IPV4_SCm_SP_CFIf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_CFIf_GET
#define CFP_TCAM_IPV4_SCm_SP_CFIf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_CFIf_SET
#define CFP_TCAM_IPV4_SCm_SP_PRIf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_PRIf_GET
#define CFP_TCAM_IPV4_SCm_SP_PRIf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_SP_PRIf_SET
#define CFP_TCAM_IPV4_SCm_UDF0_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF0_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF0_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF0_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF1_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF1_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF1_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF1_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF2_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF2_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF2_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF2_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF3_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF3_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF3_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF3_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF4_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF4_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF4_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF4_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF5_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF5_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF5_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF5_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF6_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF6_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF6_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF6_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF7_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF7_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF7_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF7_VLDf_SET
#define CFP_TCAM_IPV4_SCm_UDF8_VLDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF8_VLDf_GET
#define CFP_TCAM_IPV4_SCm_UDF8_VLDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_UDF8_VLDf_SET
#define CFP_TCAM_IPV4_SCm_RESERVED_1Rf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_RESERVED_1Rf_GET
#define CFP_TCAM_IPV4_SCm_RESERVED_1Rf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_RESERVED_1Rf_SET
#define CFP_TCAM_IPV4_SCm_TTL_RANGEf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_TTL_RANGEf_GET
#define CFP_TCAM_IPV4_SCm_TTL_RANGEf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_TTL_RANGEf_SET
#define CFP_TCAM_IPV4_SCm_IP_AUTHf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_AUTHf_GET
#define CFP_TCAM_IPV4_SCm_IP_AUTHf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_AUTHf_SET
#define CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_IPV4_SCm_IP_FRAGf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_FRAGf_GET
#define CFP_TCAM_IPV4_SCm_IP_FRAGf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_FRAGf_SET
#define CFP_TCAM_IPV4_SCm_IP_PROTOf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_PROTOf_GET
#define CFP_TCAM_IPV4_SCm_IP_PROTOf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_PROTOf_SET
#define CFP_TCAM_IPV4_SCm_IP_TOSf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_TOSf_GET
#define CFP_TCAM_IPV4_SCm_IP_TOSf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_IP_TOSf_SET
#define CFP_TCAM_IPV4_SCm_L3_FRAMINGf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_L3_FRAMINGf_GET
#define CFP_TCAM_IPV4_SCm_L3_FRAMINGf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_L3_FRAMINGf_SET
#define CFP_TCAM_IPV4_SCm_L2_FRAMINGf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_L2_FRAMINGf_GET
#define CFP_TCAM_IPV4_SCm_L2_FRAMINGf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_L2_FRAMINGf_SET
#define CFP_TCAM_IPV4_SCm_C_TAGGEDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_C_TAGGEDf_GET
#define CFP_TCAM_IPV4_SCm_C_TAGGEDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_C_TAGGEDf_SET
#define CFP_TCAM_IPV4_SCm_S_TAGGEDf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_S_TAGGEDf_GET
#define CFP_TCAM_IPV4_SCm_S_TAGGEDf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_S_TAGGEDf_SET
#define CFP_TCAM_IPV4_SCm_SRC_PMAPf_GET BCM53115_A0_CFP_TCAM_IPV4_SCm_SRC_PMAPf_GET
#define CFP_TCAM_IPV4_SCm_SRC_PMAPf_SET BCM53115_A0_CFP_TCAM_IPV4_SCm_SRC_PMAPf_SET
#define READ_CFP_TCAM_IPV4_SCm BCM53115_A0_READ_CFP_TCAM_IPV4_SCm
#define WRITE_CFP_TCAM_IPV4_SCm BCM53115_A0_WRITE_CFP_TCAM_IPV4_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_TCAM_IPV4_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_TCAM_IPV6_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Field Mask
 *     SC_N_ID          Field Mask
 *     RESERVED_R       Field Mask
 *     UDF_N_B0         Field Mask
 *     UDF_N_B1         Field Mask
 *     UDF_N_B2         Field Mask
 *     UDF_N_B3         Field Mask
 *     UDF_N_B4         Field Mask
 *     UDF_N_B5         Field Mask
 *     UDF_N_B6         Field Mask
 *     UDF_N_B7         Field Mask
 *     UDF_N_B8         Field Mask
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Field Mask
 *     UDF1_VLD         Field Mask
 *     UDF2_VLD         Field Mask
 *     UDF3_VLD         Field Mask
 *     UDF4_VLD         Field Mask
 *     UDF5_VLD         Field Mask
 *     UDF6_VLD         Field Mask
 *     UDF7_VLD         Field Mask
 *     UDF8_VLD         Field Mask
 *     RESERVED_1R      Reserved
 *     TTL_RANGE        Field Mask
 *     IP_AUTH          Field Mask
 *     NON_FIRST_FRAG   Field Mask
 *     IP_FRAG          Field Mask
 *     IP_PROTO         Field Mask
 *     IP_TOS           Field Mask
 *     L3_FRAMING       Field Mask
 *     L2_FRAMING       Field Mask
 *     C_TAGGED         Field Mask
 *     S_TAGGED         Field Mask
 *     SRC_PMAP         Field Mask
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm 0x00004a00

#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_MIN 0
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_MAX 255
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_CMAX(u) 255
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_IPV6_MASK.
 *
 */
typedef union BCM53115_A0_CFP_TCAM_IPV6_MASKm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_ipv6_mask[8];
	uint32_t _cfp_tcam_ipv6_mask;
} BCM53115_A0_CFP_TCAM_IPV6_MASKm_t;

#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_ipv6_mask), 0, sizeof(BCM53115_A0_CFP_TCAM_IPV6_MASKm_t))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SET(r,i,d) (r).cfp_tcam_ipv6_mask[i] = d
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_GET(r,i) (r).cfp_tcam_ipv6_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_VALID_Rf_GET(r) (((r).cfp_tcam_ipv6_mask[0]) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_ipv6_mask[0]=(((r).cfp_tcam_ipv6_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SC_N_IDf_GET(r) ((((r).cfp_tcam_ipv6_mask[0]) >> 2) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SC_N_IDf_SET(r,f) (r).cfp_tcam_ipv6_mask[0]=(((r).cfp_tcam_ipv6_mask[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_ipv6_mask[0]) >> 4) & 0xf)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_ipv6_mask[0]=(((r).cfp_tcam_ipv6_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B0f_GET(r) ((((r).cfp_tcam_ipv6_mask[0]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B0f_SET(r,f) (r).cfp_tcam_ipv6_mask[0]=(((r).cfp_tcam_ipv6_mask[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B1f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,24,39)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B1f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,24,39,f)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B2f_GET(r) ((((r).cfp_tcam_ipv6_mask[1]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B2f_SET(r,f) (r).cfp_tcam_ipv6_mask[1]=(((r).cfp_tcam_ipv6_mask[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B3f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,56,71)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B3f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,56,71,f)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B4f_GET(r) ((((r).cfp_tcam_ipv6_mask[2]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B4f_SET(r,f) (r).cfp_tcam_ipv6_mask[2]=(((r).cfp_tcam_ipv6_mask[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B5f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,88,103)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B5f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,88,103,f)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B6f_GET(r) ((((r).cfp_tcam_ipv6_mask[3]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B6f_SET(r,f) (r).cfp_tcam_ipv6_mask[3]=(((r).cfp_tcam_ipv6_mask[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B7f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,120,135)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B7f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,120,135,f)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B8f_GET(r) ((((r).cfp_tcam_ipv6_mask[4]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B8f_SET(r,f) (r).cfp_tcam_ipv6_mask[4]=(((r).cfp_tcam_ipv6_mask[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_mask,152,163)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_mask,152,163,f)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_CFIf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 4) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_CFIf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_PRIf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 5) & 0x7)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_PRIf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_VIDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 8) & 0xfff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_VIDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_CFIf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 20) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_CFIf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_PRIf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 21) & 0x7)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_PRIf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 24) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 25) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 26) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 27) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 28) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 29) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 30) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_ipv6_mask[5]) >> 31) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[5]=(((r).cfp_tcam_ipv6_mask[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF8_VLDf_GET(r) (((r).cfp_tcam_ipv6_mask[6]) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 1) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 3) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_AUTHf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 5) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_AUTHf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 6) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_FRAGf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 7) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_FRAGf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_PROTOf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 8) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_PROTOf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_TOSf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 16) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_TOSf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 24) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 26) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 28) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv6_mask[6]) >> 30) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv6_mask[6]=(((r).cfp_tcam_ipv6_mask[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SRC_PMAPf_GET(r) (((r).cfp_tcam_ipv6_mask[7]) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV6_MASKm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_ipv6_mask[7]=(((r).cfp_tcam_ipv6_mask[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_IPV6_MASK.
 *
 */
#define BCM53115_A0_READ_CFP_TCAM_IPV6_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_TCAM_IPV6_MASKm,i,(m),29)
#define BCM53115_A0_WRITE_CFP_TCAM_IPV6_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_TCAM_IPV6_MASKm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_IPV6_MASKm BCM53115_A0_CFP_TCAM_IPV6_MASKm
#define CFP_TCAM_IPV6_MASKm_MIN BCM53115_A0_CFP_TCAM_IPV6_MASKm_MIN
#define CFP_TCAM_IPV6_MASKm_MAX BCM53115_A0_CFP_TCAM_IPV6_MASKm_MAX
#define CFP_TCAM_IPV6_MASKm_CMAX(u) BCM53115_A0_CFP_TCAM_IPV6_MASKm_CMAX(u)
#define CFP_TCAM_IPV6_MASKm_SIZE BCM53115_A0_CFP_TCAM_IPV6_MASKm_SIZE
typedef BCM53115_A0_CFP_TCAM_IPV6_MASKm_t CFP_TCAM_IPV6_MASKm_t;
#define CFP_TCAM_IPV6_MASKm_CLR BCM53115_A0_CFP_TCAM_IPV6_MASKm_CLR
#define CFP_TCAM_IPV6_MASKm_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SET
#define CFP_TCAM_IPV6_MASKm_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_GET
#define CFP_TCAM_IPV6_MASKm_VALID_Rf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_VALID_Rf_GET
#define CFP_TCAM_IPV6_MASKm_VALID_Rf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_VALID_Rf_SET
#define CFP_TCAM_IPV6_MASKm_SC_N_IDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SC_N_IDf_GET
#define CFP_TCAM_IPV6_MASKm_SC_N_IDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SC_N_IDf_SET
#define CFP_TCAM_IPV6_MASKm_RESERVED_Rf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_RESERVED_Rf_GET
#define CFP_TCAM_IPV6_MASKm_RESERVED_Rf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_RESERVED_Rf_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B0f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B0f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B0f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B0f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B1f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B1f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B1f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B1f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B2f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B2f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B2f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B2f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B3f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B3f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B3f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B3f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B4f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B4f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B4f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B4f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B5f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B5f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B5f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B5f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B6f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B6f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B6f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B6f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B7f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B7f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B7f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B7f_SET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B8f_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B8f_GET
#define CFP_TCAM_IPV6_MASKm_UDF_N_B8f_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF_N_B8f_SET
#define CFP_TCAM_IPV6_MASKm_USR_VIDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_VIDf_GET
#define CFP_TCAM_IPV6_MASKm_USR_VIDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_VIDf_SET
#define CFP_TCAM_IPV6_MASKm_USR_CFIf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_CFIf_GET
#define CFP_TCAM_IPV6_MASKm_USR_CFIf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_CFIf_SET
#define CFP_TCAM_IPV6_MASKm_USR_PRIf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_PRIf_GET
#define CFP_TCAM_IPV6_MASKm_USR_PRIf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_USR_PRIf_SET
#define CFP_TCAM_IPV6_MASKm_SP_VIDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_VIDf_GET
#define CFP_TCAM_IPV6_MASKm_SP_VIDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_VIDf_SET
#define CFP_TCAM_IPV6_MASKm_SP_CFIf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_CFIf_GET
#define CFP_TCAM_IPV6_MASKm_SP_CFIf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_CFIf_SET
#define CFP_TCAM_IPV6_MASKm_SP_PRIf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_PRIf_GET
#define CFP_TCAM_IPV6_MASKm_SP_PRIf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SP_PRIf_SET
#define CFP_TCAM_IPV6_MASKm_UDF0_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF0_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF0_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF0_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF1_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF1_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF1_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF1_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF2_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF2_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF2_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF2_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF3_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF3_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF3_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF3_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF4_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF4_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF4_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF4_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF5_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF5_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF5_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF5_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF6_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF6_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF6_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF6_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF7_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF7_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF7_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF7_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_UDF8_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF8_VLDf_GET
#define CFP_TCAM_IPV6_MASKm_UDF8_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_UDF8_VLDf_SET
#define CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_GET
#define CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_RESERVED_1Rf_SET
#define CFP_TCAM_IPV6_MASKm_TTL_RANGEf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_TTL_RANGEf_GET
#define CFP_TCAM_IPV6_MASKm_TTL_RANGEf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_TTL_RANGEf_SET
#define CFP_TCAM_IPV6_MASKm_IP_AUTHf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_AUTHf_GET
#define CFP_TCAM_IPV6_MASKm_IP_AUTHf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_AUTHf_SET
#define CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_IPV6_MASKm_IP_FRAGf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_FRAGf_GET
#define CFP_TCAM_IPV6_MASKm_IP_FRAGf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_FRAGf_SET
#define CFP_TCAM_IPV6_MASKm_IP_PROTOf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_PROTOf_GET
#define CFP_TCAM_IPV6_MASKm_IP_PROTOf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_PROTOf_SET
#define CFP_TCAM_IPV6_MASKm_IP_TOSf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_TOSf_GET
#define CFP_TCAM_IPV6_MASKm_IP_TOSf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_IP_TOSf_SET
#define CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_GET
#define CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_L3_FRAMINGf_SET
#define CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_GET
#define CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_L2_FRAMINGf_SET
#define CFP_TCAM_IPV6_MASKm_C_TAGGEDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_C_TAGGEDf_GET
#define CFP_TCAM_IPV6_MASKm_C_TAGGEDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_C_TAGGEDf_SET
#define CFP_TCAM_IPV6_MASKm_S_TAGGEDf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_S_TAGGEDf_GET
#define CFP_TCAM_IPV6_MASKm_S_TAGGEDf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_S_TAGGEDf_SET
#define CFP_TCAM_IPV6_MASKm_SRC_PMAPf_GET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SRC_PMAPf_GET
#define CFP_TCAM_IPV6_MASKm_SRC_PMAPf_SET BCM53115_A0_CFP_TCAM_IPV6_MASKm_SRC_PMAPf_SET
#define READ_CFP_TCAM_IPV6_MASKm BCM53115_A0_READ_CFP_TCAM_IPV6_MASKm
#define WRITE_CFP_TCAM_IPV6_MASKm BCM53115_A0_WRITE_CFP_TCAM_IPV6_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_TCAM_IPV6_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_TCAM_IPV6_SC
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Valid bits
 *     SC_N_ID          Slice n indentification:00 => Slice 0, n = 001 => Slice 1, n = 110 => Slice 2, n = 211 => Slice 3(Chain Slice), n = 3
 *     RESERVED_R       Reserved
 *     UDF_N_B0         User define field 0
 *     UDF_N_B1         User define field 1
 *     UDF_N_B2         User define field 2
 *     UDF_N_B3         User define field 3
 *     UDF_N_B4         User define field 4
 *     UDF_N_B5         User define field 5
 *     UDF_N_B6         User define field 6
 *     UDF_N_B7         User define field 7
 *     UDF_N_B8         User define field 8
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Valid indication for UDF_n_B0
 *     UDF1_VLD         Valid indication for UDF_n_B1
 *     UDF2_VLD         Valid indication for UDF_n_B2
 *     UDF3_VLD         Valid indication for UDF_n_B3
 *     UDF4_VLD         Valid indication for UDF_n_B4
 *     UDF5_VLD         Valid indication for UDF_n_B5
 *     UDF6_VLD         Valid indication for UDF_n_B6
 *     UDF7_VLD         Valid indication for UDF_n_B7
 *     UDF8_VLD         Valid indication for UDF_n_B8
 *     RESERVED_1R      Reserved
 *     TTL_RANGE        HopLimit Range:b00: HopLimit=0b01: HopLimit TTL=1b10: HopLimit =Othersb11: HopLimit =255.
 *     IP_AUTH          0: Not Authenticated1: Authenticated
 *     NON_FIRST_FRAG   0: Not Fragmented or First Fragment1: NonFirst Fragment
 *     IP_FRAG          0: Not Fragmented1: Fragmented
 *     IP_PROTO         The Next Header  field of IPv6 header
 *     IP_TOS           TrafficClass field in IPv4 header
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PMAP         Ingress port indication
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_TCAM_IPV6_SCm 0x00004200

#define BCM53115_A0_CFP_TCAM_IPV6_SCm_MIN 0
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_MAX 255
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_CMAX(u) 255
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_IPV6_SC.
 *
 */
typedef union BCM53115_A0_CFP_TCAM_IPV6_SCm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_ipv6_sc[8];
	uint32_t _cfp_tcam_ipv6_sc;
} BCM53115_A0_CFP_TCAM_IPV6_SCm_t;

#define BCM53115_A0_CFP_TCAM_IPV6_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_ipv6_sc), 0, sizeof(BCM53115_A0_CFP_TCAM_IPV6_SCm_t))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SET(r,i,d) (r).cfp_tcam_ipv6_sc[i] = d
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_GET(r,i) (r).cfp_tcam_ipv6_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_VALID_Rf_GET(r) (((r).cfp_tcam_ipv6_sc[0]) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_VALID_Rf_SET(r,f) (r).cfp_tcam_ipv6_sc[0]=(((r).cfp_tcam_ipv6_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SC_N_IDf_GET(r) ((((r).cfp_tcam_ipv6_sc[0]) >> 2) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SC_N_IDf_SET(r,f) (r).cfp_tcam_ipv6_sc[0]=(((r).cfp_tcam_ipv6_sc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_ipv6_sc[0]) >> 4) & 0xf)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_ipv6_sc[0]=(((r).cfp_tcam_ipv6_sc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B0f_GET(r) ((((r).cfp_tcam_ipv6_sc[0]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B0f_SET(r,f) (r).cfp_tcam_ipv6_sc[0]=(((r).cfp_tcam_ipv6_sc[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B1f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,24,39)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B1f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,24,39,f)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B2f_GET(r) ((((r).cfp_tcam_ipv6_sc[1]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B2f_SET(r,f) (r).cfp_tcam_ipv6_sc[1]=(((r).cfp_tcam_ipv6_sc[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B3f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,56,71)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B3f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,56,71,f)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B4f_GET(r) ((((r).cfp_tcam_ipv6_sc[2]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B4f_SET(r,f) (r).cfp_tcam_ipv6_sc[2]=(((r).cfp_tcam_ipv6_sc[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B5f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,88,103)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B5f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,88,103,f)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B6f_GET(r) ((((r).cfp_tcam_ipv6_sc[3]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B6f_SET(r,f) (r).cfp_tcam_ipv6_sc[3]=(((r).cfp_tcam_ipv6_sc[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B7f_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,120,135)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B7f_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,120,135,f)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B8f_GET(r) ((((r).cfp_tcam_ipv6_sc[4]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B8f_SET(r,f) (r).cfp_tcam_ipv6_sc[4]=(((r).cfp_tcam_ipv6_sc[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_ipv6_sc,152,163)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_ipv6_sc,152,163,f)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_CFIf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 4) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_CFIf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_PRIf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 5) & 0x7)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_PRIf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_VIDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 8) & 0xfff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_VIDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_CFIf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 20) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_CFIf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_PRIf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 21) & 0x7)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_PRIf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 24) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 25) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 26) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 27) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 28) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 29) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 30) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_ipv6_sc[5]) >> 31) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[5]=(((r).cfp_tcam_ipv6_sc[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF8_VLDf_GET(r) (((r).cfp_tcam_ipv6_sc[6]) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 1) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_TTL_RANGEf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 3) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_TTL_RANGEf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_AUTHf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 5) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_AUTHf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 6) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_FRAGf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 7) & 0x1)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_FRAGf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_PROTOf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 8) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_PROTOf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_TOSf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 16) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_TOSf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 24) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 26) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 28) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_ipv6_sc[6]) >> 30) & 0x3)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_ipv6_sc[6]=(((r).cfp_tcam_ipv6_sc[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SRC_PMAPf_GET(r) (((r).cfp_tcam_ipv6_sc[7]) & 0xff)
#define BCM53115_A0_CFP_TCAM_IPV6_SCm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_ipv6_sc[7]=(((r).cfp_tcam_ipv6_sc[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_IPV6_SC.
 *
 */
#define BCM53115_A0_READ_CFP_TCAM_IPV6_SCm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_TCAM_IPV6_SCm,i,(m),29)
#define BCM53115_A0_WRITE_CFP_TCAM_IPV6_SCm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_TCAM_IPV6_SCm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_IPV6_SCm BCM53115_A0_CFP_TCAM_IPV6_SCm
#define CFP_TCAM_IPV6_SCm_MIN BCM53115_A0_CFP_TCAM_IPV6_SCm_MIN
#define CFP_TCAM_IPV6_SCm_MAX BCM53115_A0_CFP_TCAM_IPV6_SCm_MAX
#define CFP_TCAM_IPV6_SCm_CMAX(u) BCM53115_A0_CFP_TCAM_IPV6_SCm_CMAX(u)
#define CFP_TCAM_IPV6_SCm_SIZE BCM53115_A0_CFP_TCAM_IPV6_SCm_SIZE
typedef BCM53115_A0_CFP_TCAM_IPV6_SCm_t CFP_TCAM_IPV6_SCm_t;
#define CFP_TCAM_IPV6_SCm_CLR BCM53115_A0_CFP_TCAM_IPV6_SCm_CLR
#define CFP_TCAM_IPV6_SCm_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_SET
#define CFP_TCAM_IPV6_SCm_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_GET
#define CFP_TCAM_IPV6_SCm_VALID_Rf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_VALID_Rf_GET
#define CFP_TCAM_IPV6_SCm_VALID_Rf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_VALID_Rf_SET
#define CFP_TCAM_IPV6_SCm_SC_N_IDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_SC_N_IDf_GET
#define CFP_TCAM_IPV6_SCm_SC_N_IDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_SC_N_IDf_SET
#define CFP_TCAM_IPV6_SCm_RESERVED_Rf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_RESERVED_Rf_GET
#define CFP_TCAM_IPV6_SCm_RESERVED_Rf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_RESERVED_Rf_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B0f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B0f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B0f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B0f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B1f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B1f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B1f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B1f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B2f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B2f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B2f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B2f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B3f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B3f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B3f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B3f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B4f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B4f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B4f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B4f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B5f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B5f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B5f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B5f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B6f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B6f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B6f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B6f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B7f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B7f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B7f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B7f_SET
#define CFP_TCAM_IPV6_SCm_UDF_N_B8f_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B8f_GET
#define CFP_TCAM_IPV6_SCm_UDF_N_B8f_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF_N_B8f_SET
#define CFP_TCAM_IPV6_SCm_USR_VIDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_VIDf_GET
#define CFP_TCAM_IPV6_SCm_USR_VIDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_VIDf_SET
#define CFP_TCAM_IPV6_SCm_USR_CFIf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_CFIf_GET
#define CFP_TCAM_IPV6_SCm_USR_CFIf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_CFIf_SET
#define CFP_TCAM_IPV6_SCm_USR_PRIf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_PRIf_GET
#define CFP_TCAM_IPV6_SCm_USR_PRIf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_USR_PRIf_SET
#define CFP_TCAM_IPV6_SCm_SP_VIDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_VIDf_GET
#define CFP_TCAM_IPV6_SCm_SP_VIDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_VIDf_SET
#define CFP_TCAM_IPV6_SCm_SP_CFIf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_CFIf_GET
#define CFP_TCAM_IPV6_SCm_SP_CFIf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_CFIf_SET
#define CFP_TCAM_IPV6_SCm_SP_PRIf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_PRIf_GET
#define CFP_TCAM_IPV6_SCm_SP_PRIf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_SP_PRIf_SET
#define CFP_TCAM_IPV6_SCm_UDF0_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF0_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF0_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF0_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF1_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF1_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF1_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF1_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF2_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF2_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF2_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF2_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF3_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF3_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF3_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF3_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF4_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF4_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF4_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF4_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF5_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF5_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF5_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF5_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF6_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF6_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF6_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF6_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF7_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF7_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF7_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF7_VLDf_SET
#define CFP_TCAM_IPV6_SCm_UDF8_VLDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF8_VLDf_GET
#define CFP_TCAM_IPV6_SCm_UDF8_VLDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_UDF8_VLDf_SET
#define CFP_TCAM_IPV6_SCm_RESERVED_1Rf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_RESERVED_1Rf_GET
#define CFP_TCAM_IPV6_SCm_RESERVED_1Rf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_RESERVED_1Rf_SET
#define CFP_TCAM_IPV6_SCm_TTL_RANGEf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_TTL_RANGEf_GET
#define CFP_TCAM_IPV6_SCm_TTL_RANGEf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_TTL_RANGEf_SET
#define CFP_TCAM_IPV6_SCm_IP_AUTHf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_AUTHf_GET
#define CFP_TCAM_IPV6_SCm_IP_AUTHf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_AUTHf_SET
#define CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_GET
#define CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_NON_FIRST_FRAGf_SET
#define CFP_TCAM_IPV6_SCm_IP_FRAGf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_FRAGf_GET
#define CFP_TCAM_IPV6_SCm_IP_FRAGf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_FRAGf_SET
#define CFP_TCAM_IPV6_SCm_IP_PROTOf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_PROTOf_GET
#define CFP_TCAM_IPV6_SCm_IP_PROTOf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_PROTOf_SET
#define CFP_TCAM_IPV6_SCm_IP_TOSf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_TOSf_GET
#define CFP_TCAM_IPV6_SCm_IP_TOSf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_IP_TOSf_SET
#define CFP_TCAM_IPV6_SCm_L3_FRAMINGf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_L3_FRAMINGf_GET
#define CFP_TCAM_IPV6_SCm_L3_FRAMINGf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_L3_FRAMINGf_SET
#define CFP_TCAM_IPV6_SCm_L2_FRAMINGf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_L2_FRAMINGf_GET
#define CFP_TCAM_IPV6_SCm_L2_FRAMINGf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_L2_FRAMINGf_SET
#define CFP_TCAM_IPV6_SCm_C_TAGGEDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_C_TAGGEDf_GET
#define CFP_TCAM_IPV6_SCm_C_TAGGEDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_C_TAGGEDf_SET
#define CFP_TCAM_IPV6_SCm_S_TAGGEDf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_S_TAGGEDf_GET
#define CFP_TCAM_IPV6_SCm_S_TAGGEDf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_S_TAGGEDf_SET
#define CFP_TCAM_IPV6_SCm_SRC_PMAPf_GET BCM53115_A0_CFP_TCAM_IPV6_SCm_SRC_PMAPf_GET
#define CFP_TCAM_IPV6_SCm_SRC_PMAPf_SET BCM53115_A0_CFP_TCAM_IPV6_SCm_SRC_PMAPf_SET
#define READ_CFP_TCAM_IPV6_SCm BCM53115_A0_READ_CFP_TCAM_IPV6_SCm
#define WRITE_CFP_TCAM_IPV6_SCm BCM53115_A0_WRITE_CFP_TCAM_IPV6_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_TCAM_IPV6_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_TCAM_NONIP_MASK
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Field Mask
 *     SC_N_ID          Field Mask
 *     RESERVED_R       Reserved
 *     UDF_N_C0         Field Mask
 *     UDF_N_C1         Field Mask
 *     UDF_N_C2         Field Mask
 *     UDF_N_C3         Field Mask
 *     UDF_N_C4         Field Mask
 *     UDF_N_C5         Field Mask
 *     UDF_N_C6         Field Mask
 *     UDF_N_C7         Field Mask
 *     UDF_N_C8         Field Mask
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Field Mask
 *     UDF1_VLD         Field Mask
 *     UDF2_VLD         Field Mask
 *     UDF3_VLD         Field Mask
 *     UDF4_VLD         Field Mask
 *     UDF5_VLD         Field Mask
 *     UDF6_VLD         Field Mask
 *     UDF7_VLD         Field Mask
 *     UDF8_VLD         Field Mask
 *     RESERVED_1R      Reserved
 *     ETHERTYPE_SAP    Field Mask
 *     L3_FRAMING       Field Mask
 *     L2_FRAMING       Field Mask
 *     C_TAGGED         Field Mask
 *     S_TAGGED         Field Mask
 *     SRC_PMAP         Field Mask
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm 0x00004c00

#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_MIN 0
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_MAX 255
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_CMAX(u) 255
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_NONIP_MASK.
 *
 */
typedef union BCM53115_A0_CFP_TCAM_NONIP_MASKm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_nonip_mask[8];
	uint32_t _cfp_tcam_nonip_mask;
} BCM53115_A0_CFP_TCAM_NONIP_MASKm_t;

#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_nonip_mask), 0, sizeof(BCM53115_A0_CFP_TCAM_NONIP_MASKm_t))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SET(r,i,d) (r).cfp_tcam_nonip_mask[i] = d
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_GET(r,i) (r).cfp_tcam_nonip_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_VALID_Rf_GET(r) (((r).cfp_tcam_nonip_mask[0]) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_VALID_Rf_SET(r,f) (r).cfp_tcam_nonip_mask[0]=(((r).cfp_tcam_nonip_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SC_N_IDf_GET(r) ((((r).cfp_tcam_nonip_mask[0]) >> 2) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SC_N_IDf_SET(r,f) (r).cfp_tcam_nonip_mask[0]=(((r).cfp_tcam_nonip_mask[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_nonip_mask[0]) >> 4) & 0xf)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_nonip_mask[0]=(((r).cfp_tcam_nonip_mask[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C0f_GET(r) ((((r).cfp_tcam_nonip_mask[0]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C0f_SET(r,f) (r).cfp_tcam_nonip_mask[0]=(((r).cfp_tcam_nonip_mask[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C1f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,24,39)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C1f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,24,39,f)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C2f_GET(r) ((((r).cfp_tcam_nonip_mask[1]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C2f_SET(r,f) (r).cfp_tcam_nonip_mask[1]=(((r).cfp_tcam_nonip_mask[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C3f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,56,71)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C3f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,56,71,f)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C4f_GET(r) ((((r).cfp_tcam_nonip_mask[2]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C4f_SET(r,f) (r).cfp_tcam_nonip_mask[2]=(((r).cfp_tcam_nonip_mask[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C5f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,88,103)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C5f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,88,103,f)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C6f_GET(r) ((((r).cfp_tcam_nonip_mask[3]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C6f_SET(r,f) (r).cfp_tcam_nonip_mask[3]=(((r).cfp_tcam_nonip_mask[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C7f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,120,135)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C7f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,120,135,f)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C8f_GET(r) ((((r).cfp_tcam_nonip_mask[4]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C8f_SET(r,f) (r).cfp_tcam_nonip_mask[4]=(((r).cfp_tcam_nonip_mask[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_nonip_mask,152,163)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_mask,152,163,f)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_CFIf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 4) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_CFIf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_PRIf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 5) & 0x7)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_PRIf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_VIDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 8) & 0xfff)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_VIDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_CFIf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 20) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_CFIf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_PRIf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 21) & 0x7)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_PRIf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 24) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 25) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 26) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 27) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 28) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 29) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 30) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_nonip_mask[5]) >> 31) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[5]=(((r).cfp_tcam_nonip_mask[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF8_VLDf_GET(r) (((r).cfp_tcam_nonip_mask[6]) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 1) & 0x7f)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 24) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 26) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 28) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_nonip_mask[6]) >> 30) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_nonip_mask[6]=(((r).cfp_tcam_nonip_mask[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SRC_PMAPf_GET(r) (((r).cfp_tcam_nonip_mask[7]) & 0xff)
#define BCM53115_A0_CFP_TCAM_NONIP_MASKm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_nonip_mask[7]=(((r).cfp_tcam_nonip_mask[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_NONIP_MASK.
 *
 */
#define BCM53115_A0_READ_CFP_TCAM_NONIP_MASKm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_TCAM_NONIP_MASKm,i,(m),29)
#define BCM53115_A0_WRITE_CFP_TCAM_NONIP_MASKm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_TCAM_NONIP_MASKm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_NONIP_MASKm BCM53115_A0_CFP_TCAM_NONIP_MASKm
#define CFP_TCAM_NONIP_MASKm_MIN BCM53115_A0_CFP_TCAM_NONIP_MASKm_MIN
#define CFP_TCAM_NONIP_MASKm_MAX BCM53115_A0_CFP_TCAM_NONIP_MASKm_MAX
#define CFP_TCAM_NONIP_MASKm_CMAX(u) BCM53115_A0_CFP_TCAM_NONIP_MASKm_CMAX(u)
#define CFP_TCAM_NONIP_MASKm_SIZE BCM53115_A0_CFP_TCAM_NONIP_MASKm_SIZE
typedef BCM53115_A0_CFP_TCAM_NONIP_MASKm_t CFP_TCAM_NONIP_MASKm_t;
#define CFP_TCAM_NONIP_MASKm_CLR BCM53115_A0_CFP_TCAM_NONIP_MASKm_CLR
#define CFP_TCAM_NONIP_MASKm_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SET
#define CFP_TCAM_NONIP_MASKm_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_GET
#define CFP_TCAM_NONIP_MASKm_VALID_Rf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_VALID_Rf_GET
#define CFP_TCAM_NONIP_MASKm_VALID_Rf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_VALID_Rf_SET
#define CFP_TCAM_NONIP_MASKm_SC_N_IDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SC_N_IDf_GET
#define CFP_TCAM_NONIP_MASKm_SC_N_IDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SC_N_IDf_SET
#define CFP_TCAM_NONIP_MASKm_RESERVED_Rf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_RESERVED_Rf_GET
#define CFP_TCAM_NONIP_MASKm_RESERVED_Rf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_RESERVED_Rf_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C0f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C0f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C0f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C0f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C1f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C1f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C1f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C1f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C2f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C2f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C2f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C2f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C3f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C3f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C3f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C3f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C4f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C4f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C4f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C4f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C5f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C5f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C5f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C5f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C6f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C6f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C6f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C6f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C7f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C7f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C7f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C7f_SET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C8f_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C8f_GET
#define CFP_TCAM_NONIP_MASKm_UDF_N_C8f_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF_N_C8f_SET
#define CFP_TCAM_NONIP_MASKm_USR_VIDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_VIDf_GET
#define CFP_TCAM_NONIP_MASKm_USR_VIDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_VIDf_SET
#define CFP_TCAM_NONIP_MASKm_USR_CFIf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_CFIf_GET
#define CFP_TCAM_NONIP_MASKm_USR_CFIf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_CFIf_SET
#define CFP_TCAM_NONIP_MASKm_USR_PRIf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_PRIf_GET
#define CFP_TCAM_NONIP_MASKm_USR_PRIf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_USR_PRIf_SET
#define CFP_TCAM_NONIP_MASKm_SP_VIDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_VIDf_GET
#define CFP_TCAM_NONIP_MASKm_SP_VIDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_VIDf_SET
#define CFP_TCAM_NONIP_MASKm_SP_CFIf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_CFIf_GET
#define CFP_TCAM_NONIP_MASKm_SP_CFIf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_CFIf_SET
#define CFP_TCAM_NONIP_MASKm_SP_PRIf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_PRIf_GET
#define CFP_TCAM_NONIP_MASKm_SP_PRIf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SP_PRIf_SET
#define CFP_TCAM_NONIP_MASKm_UDF0_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF0_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF0_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF0_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF1_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF1_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF1_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF1_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF2_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF2_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF2_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF2_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF3_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF3_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF3_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF3_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF4_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF4_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF4_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF4_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF5_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF5_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF5_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF5_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF6_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF6_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF6_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF6_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF7_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF7_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF7_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF7_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_UDF8_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF8_VLDf_GET
#define CFP_TCAM_NONIP_MASKm_UDF8_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_UDF8_VLDf_SET
#define CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_GET
#define CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_RESERVED_1Rf_SET
#define CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_GET
#define CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_ETHERTYPE_SAPf_SET
#define CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_GET
#define CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_L3_FRAMINGf_SET
#define CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_GET
#define CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_L2_FRAMINGf_SET
#define CFP_TCAM_NONIP_MASKm_C_TAGGEDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_C_TAGGEDf_GET
#define CFP_TCAM_NONIP_MASKm_C_TAGGEDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_C_TAGGEDf_SET
#define CFP_TCAM_NONIP_MASKm_S_TAGGEDf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_S_TAGGEDf_GET
#define CFP_TCAM_NONIP_MASKm_S_TAGGEDf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_S_TAGGEDf_SET
#define CFP_TCAM_NONIP_MASKm_SRC_PMAPf_GET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SRC_PMAPf_GET
#define CFP_TCAM_NONIP_MASKm_SRC_PMAPf_SET BCM53115_A0_CFP_TCAM_NONIP_MASKm_SRC_PMAPf_SET
#define READ_CFP_TCAM_NONIP_MASKm BCM53115_A0_READ_CFP_TCAM_NONIP_MASKm
#define WRITE_CFP_TCAM_NONIP_MASKm BCM53115_A0_WRITE_CFP_TCAM_NONIP_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_TCAM_NONIP_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  CFP_TCAM_NONIP_SC
 * BLOCKS:   SYS
 * DESC:     TCAM Table
 * SIZE:     232
 * FIELDS:
 *     VALID_R          Valid bits
 *     SC_N_ID          Slice n indentification:00 => Slice 0, n = 001 => Slice 1, n = 110 => Slice 2, n = 211 => Slice 3(Chain Slice), n = 3
 *     RESERVED_R       Reserved
 *     UDF_N_C0         User define field 0
 *     UDF_N_C1         User define field 1
 *     UDF_N_C2         User define field 2
 *     UDF_N_C3         User define field 3
 *     UDF_N_C4         User define field 4
 *     UDF_N_C5         User define field 5
 *     UDF_N_C6         User define field 6
 *     UDF_N_C7         User define field 7
 *     UDF_N_C8         User define field 8
 *     USR_VID          USER VID 
 *     USR_CFI          USER CFI
 *     USR_PRI          USER priority
 *     SP_VID           Service provider VID 
 *     SP_CFI           Service provider CFI
 *     SP_PRI           Service provider priority
 *     UDF0_VLD         Valid indication for UDF_n_C0
 *     UDF1_VLD         Valid indication for UDF_n_C1
 *     UDF2_VLD         Valid indication for UDF_n_C2
 *     UDF3_VLD         Valid indication for UDF_n_C3
 *     UDF4_VLD         Valid indication for UDF_n_C4
 *     UDF5_VLD         Valid indication for UDF_n_C5
 *     UDF6_VLD         Valid indication for UDF_n_C6
 *     UDF7_VLD         Valid indication for UDF_n_C7
 *     UDF8_VLD         Valid indication for UDF_n_C8
 *     RESERVED_1R      Reserved
 *     ETHERTYPE_SAP    EtherType :when L2 Framing = DIXv2 or SNAP_PublicDSAP,SSAP : when L2 Framing = LLC or SNAP_Private.
 *     L3_FRAMING       00: IPv401: IPv610: Reserved11: Non-IP
 *     L2_FRAMING       00: DIXv201: SNAP_Public10: LLC11: SNAP_Private
 *     C_TAGGED         00: The packet is originally received without C-Tag01: The packet is originally received with C_VID = 010: Reserved11: The packet is originally received with C_VID != 0
 *     S_TAGGED         00: The packet is originally received without S-Tag01: The packet is originally received with S_VID = 010: Reserved11: The packet is originally received with S_VID != 0
 *     SRC_PMAP         Ingress port indication
 *
 ******************************************************************************/
#define BCM53115_A0_CFP_TCAM_NONIP_SCm 0x00004400

#define BCM53115_A0_CFP_TCAM_NONIP_SCm_MIN 0
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_MAX 255
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_CMAX(u) 255
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SIZE 29

/*
 * This structure should be used to declare and program CFP_TCAM_NONIP_SC.
 *
 */
typedef union BCM53115_A0_CFP_TCAM_NONIP_SCm_s {
	uint32_t v[8];
	uint32_t cfp_tcam_nonip_sc[8];
	uint32_t _cfp_tcam_nonip_sc;
} BCM53115_A0_CFP_TCAM_NONIP_SCm_t;

#define BCM53115_A0_CFP_TCAM_NONIP_SCm_CLR(r) CDK_MEMSET(&((r)._cfp_tcam_nonip_sc), 0, sizeof(BCM53115_A0_CFP_TCAM_NONIP_SCm_t))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SET(r,i,d) (r).cfp_tcam_nonip_sc[i] = d
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_GET(r,i) (r).cfp_tcam_nonip_sc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_VALID_Rf_GET(r) (((r).cfp_tcam_nonip_sc[0]) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_VALID_Rf_SET(r,f) (r).cfp_tcam_nonip_sc[0]=(((r).cfp_tcam_nonip_sc[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SC_N_IDf_GET(r) ((((r).cfp_tcam_nonip_sc[0]) >> 2) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SC_N_IDf_SET(r,f) (r).cfp_tcam_nonip_sc[0]=(((r).cfp_tcam_nonip_sc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_RESERVED_Rf_GET(r) ((((r).cfp_tcam_nonip_sc[0]) >> 4) & 0xf)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_RESERVED_Rf_SET(r,f) (r).cfp_tcam_nonip_sc[0]=(((r).cfp_tcam_nonip_sc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C0f_GET(r) ((((r).cfp_tcam_nonip_sc[0]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C0f_SET(r,f) (r).cfp_tcam_nonip_sc[0]=(((r).cfp_tcam_nonip_sc[0] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C1f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,24,39)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C1f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,24,39,f)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C2f_GET(r) ((((r).cfp_tcam_nonip_sc[1]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C2f_SET(r,f) (r).cfp_tcam_nonip_sc[1]=(((r).cfp_tcam_nonip_sc[1] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C3f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,56,71)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C3f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,56,71,f)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C4f_GET(r) ((((r).cfp_tcam_nonip_sc[2]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C4f_SET(r,f) (r).cfp_tcam_nonip_sc[2]=(((r).cfp_tcam_nonip_sc[2] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C5f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,88,103)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C5f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,88,103,f)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C6f_GET(r) ((((r).cfp_tcam_nonip_sc[3]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C6f_SET(r,f) (r).cfp_tcam_nonip_sc[3]=(((r).cfp_tcam_nonip_sc[3] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C7f_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,120,135)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C7f_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,120,135,f)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C8f_GET(r) ((((r).cfp_tcam_nonip_sc[4]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C8f_SET(r,f) (r).cfp_tcam_nonip_sc[4]=(((r).cfp_tcam_nonip_sc[4] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_VIDf_GET(r) cdk_field32_get((r).cfp_tcam_nonip_sc,152,163)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_VIDf_SET(r,f) cdk_field32_set((r).cfp_tcam_nonip_sc,152,163,f)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_CFIf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 4) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_CFIf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_PRIf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 5) & 0x7)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_PRIf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_VIDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 8) & 0xfff)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_VIDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_CFIf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 20) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_CFIf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_PRIf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 21) & 0x7)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_PRIf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF0_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 24) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF0_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF1_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 25) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF1_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF2_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 26) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF2_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF3_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 27) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF3_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF4_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 28) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF4_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF5_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 29) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF5_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF6_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 30) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF6_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF7_VLDf_GET(r) ((((r).cfp_tcam_nonip_sc[5]) >> 31) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF7_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[5]=(((r).cfp_tcam_nonip_sc[5] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF8_VLDf_GET(r) (((r).cfp_tcam_nonip_sc[6]) & 0x1)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF8_VLDf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_RESERVED_1Rf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 1) & 0x7f)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_RESERVED_1Rf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 8) & 0xffff)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0xffff << 8)) | ((((uint32_t)f) & 0xffff) << 8))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_L3_FRAMINGf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 24) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_L3_FRAMINGf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_L2_FRAMINGf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 26) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_L2_FRAMINGf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_C_TAGGEDf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 28) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_C_TAGGEDf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_S_TAGGEDf_GET(r) ((((r).cfp_tcam_nonip_sc[6]) >> 30) & 0x3)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_S_TAGGEDf_SET(r,f) (r).cfp_tcam_nonip_sc[6]=(((r).cfp_tcam_nonip_sc[6] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SRC_PMAPf_GET(r) (((r).cfp_tcam_nonip_sc[7]) & 0xff)
#define BCM53115_A0_CFP_TCAM_NONIP_SCm_SRC_PMAPf_SET(r,f) (r).cfp_tcam_nonip_sc[7]=(((r).cfp_tcam_nonip_sc[7] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CFP_TCAM_NONIP_SC.
 *
 */
#define BCM53115_A0_READ_CFP_TCAM_NONIP_SCm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_CFP_TCAM_NONIP_SCm,i,(m),29)
#define BCM53115_A0_WRITE_CFP_TCAM_NONIP_SCm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_CFP_TCAM_NONIP_SCm,i,&(m),29)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFP_TCAM_NONIP_SCm BCM53115_A0_CFP_TCAM_NONIP_SCm
#define CFP_TCAM_NONIP_SCm_MIN BCM53115_A0_CFP_TCAM_NONIP_SCm_MIN
#define CFP_TCAM_NONIP_SCm_MAX BCM53115_A0_CFP_TCAM_NONIP_SCm_MAX
#define CFP_TCAM_NONIP_SCm_CMAX(u) BCM53115_A0_CFP_TCAM_NONIP_SCm_CMAX(u)
#define CFP_TCAM_NONIP_SCm_SIZE BCM53115_A0_CFP_TCAM_NONIP_SCm_SIZE
typedef BCM53115_A0_CFP_TCAM_NONIP_SCm_t CFP_TCAM_NONIP_SCm_t;
#define CFP_TCAM_NONIP_SCm_CLR BCM53115_A0_CFP_TCAM_NONIP_SCm_CLR
#define CFP_TCAM_NONIP_SCm_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_SET
#define CFP_TCAM_NONIP_SCm_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_GET
#define CFP_TCAM_NONIP_SCm_VALID_Rf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_VALID_Rf_GET
#define CFP_TCAM_NONIP_SCm_VALID_Rf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_VALID_Rf_SET
#define CFP_TCAM_NONIP_SCm_SC_N_IDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_SC_N_IDf_GET
#define CFP_TCAM_NONIP_SCm_SC_N_IDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_SC_N_IDf_SET
#define CFP_TCAM_NONIP_SCm_RESERVED_Rf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_RESERVED_Rf_GET
#define CFP_TCAM_NONIP_SCm_RESERVED_Rf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_RESERVED_Rf_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C0f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C0f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C0f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C0f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C1f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C1f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C1f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C1f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C2f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C2f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C2f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C2f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C3f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C3f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C3f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C3f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C4f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C4f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C4f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C4f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C5f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C5f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C5f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C5f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C6f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C6f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C6f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C6f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C7f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C7f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C7f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C7f_SET
#define CFP_TCAM_NONIP_SCm_UDF_N_C8f_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C8f_GET
#define CFP_TCAM_NONIP_SCm_UDF_N_C8f_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF_N_C8f_SET
#define CFP_TCAM_NONIP_SCm_USR_VIDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_VIDf_GET
#define CFP_TCAM_NONIP_SCm_USR_VIDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_VIDf_SET
#define CFP_TCAM_NONIP_SCm_USR_CFIf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_CFIf_GET
#define CFP_TCAM_NONIP_SCm_USR_CFIf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_CFIf_SET
#define CFP_TCAM_NONIP_SCm_USR_PRIf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_PRIf_GET
#define CFP_TCAM_NONIP_SCm_USR_PRIf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_USR_PRIf_SET
#define CFP_TCAM_NONIP_SCm_SP_VIDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_VIDf_GET
#define CFP_TCAM_NONIP_SCm_SP_VIDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_VIDf_SET
#define CFP_TCAM_NONIP_SCm_SP_CFIf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_CFIf_GET
#define CFP_TCAM_NONIP_SCm_SP_CFIf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_CFIf_SET
#define CFP_TCAM_NONIP_SCm_SP_PRIf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_PRIf_GET
#define CFP_TCAM_NONIP_SCm_SP_PRIf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_SP_PRIf_SET
#define CFP_TCAM_NONIP_SCm_UDF0_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF0_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF0_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF0_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF1_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF1_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF1_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF1_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF2_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF2_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF2_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF2_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF3_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF3_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF3_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF3_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF4_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF4_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF4_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF4_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF5_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF5_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF5_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF5_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF6_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF6_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF6_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF6_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF7_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF7_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF7_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF7_VLDf_SET
#define CFP_TCAM_NONIP_SCm_UDF8_VLDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF8_VLDf_GET
#define CFP_TCAM_NONIP_SCm_UDF8_VLDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_UDF8_VLDf_SET
#define CFP_TCAM_NONIP_SCm_RESERVED_1Rf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_RESERVED_1Rf_GET
#define CFP_TCAM_NONIP_SCm_RESERVED_1Rf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_RESERVED_1Rf_SET
#define CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_GET
#define CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_ETHERTYPE_SAPf_SET
#define CFP_TCAM_NONIP_SCm_L3_FRAMINGf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_L3_FRAMINGf_GET
#define CFP_TCAM_NONIP_SCm_L3_FRAMINGf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_L3_FRAMINGf_SET
#define CFP_TCAM_NONIP_SCm_L2_FRAMINGf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_L2_FRAMINGf_GET
#define CFP_TCAM_NONIP_SCm_L2_FRAMINGf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_L2_FRAMINGf_SET
#define CFP_TCAM_NONIP_SCm_C_TAGGEDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_C_TAGGEDf_GET
#define CFP_TCAM_NONIP_SCm_C_TAGGEDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_C_TAGGEDf_SET
#define CFP_TCAM_NONIP_SCm_S_TAGGEDf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_S_TAGGEDf_GET
#define CFP_TCAM_NONIP_SCm_S_TAGGEDf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_S_TAGGEDf_SET
#define CFP_TCAM_NONIP_SCm_SRC_PMAPf_GET BCM53115_A0_CFP_TCAM_NONIP_SCm_SRC_PMAPf_GET
#define CFP_TCAM_NONIP_SCm_SRC_PMAPf_SET BCM53115_A0_CFP_TCAM_NONIP_SCm_SRC_PMAPf_SET
#define READ_CFP_TCAM_NONIP_SCm BCM53115_A0_READ_CFP_TCAM_NONIP_SCm
#define WRITE_CFP_TCAM_NONIP_SCm BCM53115_A0_WRITE_CFP_TCAM_NONIP_SCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CFP_TCAM_NONIP_SCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  CHIP_REVID
 * BLOCKS:   SYS
 * DESC:     Chip Revision ID Register
 * SIZE:     8
 * FIELDS:
 *     REVID_R          Chip Revision ID.
 *
 ******************************************************************************/
#define BCM53115_A0_CHIP_REVIDr 0x00000240

#define BCM53115_A0_CHIP_REVIDr_SIZE 1

/*
 * This structure should be used to declare and program CHIP_REVID.
 *
 */
typedef union BCM53115_A0_CHIP_REVIDr_s {
	uint32_t v[1];
	uint32_t chip_revid[1];
	uint32_t _chip_revid;
} BCM53115_A0_CHIP_REVIDr_t;

#define BCM53115_A0_CHIP_REVIDr_CLR(r) (r).chip_revid[0] = 0
#define BCM53115_A0_CHIP_REVIDr_SET(r,d) (r).chip_revid[0] = d
#define BCM53115_A0_CHIP_REVIDr_GET(r) (r).chip_revid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CHIP_REVIDr_REVID_Rf_GET(r) (((r).chip_revid[0]) & 0xff)
#define BCM53115_A0_CHIP_REVIDr_REVID_Rf_SET(r,f) (r).chip_revid[0]=(((r).chip_revid[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CHIP_REVID.
 *
 */
#define BCM53115_A0_READ_CHIP_REVIDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_CHIP_REVIDr,(r._chip_revid),1)
#define BCM53115_A0_WRITE_CHIP_REVIDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_CHIP_REVIDr,&(r._chip_revid),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CHIP_REVIDr BCM53115_A0_CHIP_REVIDr
#define CHIP_REVIDr_SIZE BCM53115_A0_CHIP_REVIDr_SIZE
typedef BCM53115_A0_CHIP_REVIDr_t CHIP_REVIDr_t;
#define CHIP_REVIDr_CLR BCM53115_A0_CHIP_REVIDr_CLR
#define CHIP_REVIDr_SET BCM53115_A0_CHIP_REVIDr_SET
#define CHIP_REVIDr_GET BCM53115_A0_CHIP_REVIDr_GET
#define CHIP_REVIDr_REVID_Rf_GET BCM53115_A0_CHIP_REVIDr_REVID_Rf_GET
#define CHIP_REVIDr_REVID_Rf_SET BCM53115_A0_CHIP_REVIDr_REVID_Rf_SET
#define READ_CHIP_REVIDr BCM53115_A0_READ_CHIP_REVIDr
#define WRITE_CHIP_REVIDr BCM53115_A0_WRITE_CHIP_REVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CHIP_REVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  CLKSET
 * BLOCKS:   SYS
 * DESC:     Clock Period Setting Registers
 * SIZE:     32
 * FIELDS:
 *     RESERVED_R       Clock Control Register
 *
 ******************************************************************************/
#define BCM53115_A0_CLKSETr 0x0000fffa

#define BCM53115_A0_CLKSETr_SIZE 4

/*
 * This structure should be used to declare and program CLKSET.
 *
 */
typedef union BCM53115_A0_CLKSETr_s {
	uint32_t v[1];
	uint32_t clkset[1];
	uint32_t _clkset;
} BCM53115_A0_CLKSETr_t;

#define BCM53115_A0_CLKSETr_CLR(r) (r).clkset[0] = 0
#define BCM53115_A0_CLKSETr_SET(r,d) (r).clkset[0] = d
#define BCM53115_A0_CLKSETr_GET(r) (r).clkset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CLKSETr_RESERVED_Rf_GET(r) ((r).clkset[0])
#define BCM53115_A0_CLKSETr_RESERVED_Rf_SET(r,f) (r).clkset[0]=((uint32_t)f)

/*
 * These macros can be used to access CLKSET.
 *
 */
#define BCM53115_A0_READ_CLKSETr(u,r) cdk_robo_reg_read(u,BCM53115_A0_CLKSETr,(r._clkset),4)
#define BCM53115_A0_WRITE_CLKSETr(u,r) cdk_robo_reg_write(u,BCM53115_A0_CLKSETr,&(r._clkset),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CLKSETr BCM53115_A0_CLKSETr
#define CLKSETr_SIZE BCM53115_A0_CLKSETr_SIZE
typedef BCM53115_A0_CLKSETr_t CLKSETr_t;
#define CLKSETr_CLR BCM53115_A0_CLKSETr_CLR
#define CLKSETr_SET BCM53115_A0_CLKSETr_SET
#define CLKSETr_GET BCM53115_A0_CLKSETr_GET
#define CLKSETr_RESERVED_Rf_GET BCM53115_A0_CLKSETr_RESERVED_Rf_GET
#define CLKSETr_RESERVED_Rf_SET BCM53115_A0_CLKSETr_RESERVED_Rf_SET
#define READ_CLKSETr BCM53115_A0_READ_CLKSETr
#define WRITE_CLKSETr BCM53115_A0_WRITE_CLKSETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CLKSETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  COMM_IRC_CON
 * BLOCKS:   SYS
 * DESC:     Common Ingress rate Control Configuration Registers
 * SIZE:     32
 * FIELDS:
 *     PKT_MSK0         Packet Mask for Bucket 0.default value : {3'b0, bcsupp_en, 3'b0}
 *     DROP_EN0         suppression Drop Mode Enabled.default value : base on strap pin bc_supp_en.
 *     RATE_TYPE0       Bit Rate Mode selection.default value : base on strap pin bc_supp_en.
 *     PKT_MSK1         Packet Mask for Bucket 1.
 *     DROP_EN1         suppression Drop Mode Enabled for bucket 1.
 *     RATE_TYPE1       Bit Rate Mode selection.
 *     XLEN_EN          bit rate Mode  Selection.0 : Rx rate exclude IGP,1 : Rx rate include IGP,
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_COMM_IRC_CONr 0x00004100

#define BCM53115_A0_COMM_IRC_CONr_SIZE 4

/*
 * This structure should be used to declare and program COMM_IRC_CON.
 *
 */
typedef union BCM53115_A0_COMM_IRC_CONr_s {
	uint32_t v[1];
	uint32_t comm_irc_con[1];
	uint32_t _comm_irc_con;
} BCM53115_A0_COMM_IRC_CONr_t;

#define BCM53115_A0_COMM_IRC_CONr_CLR(r) (r).comm_irc_con[0] = 0
#define BCM53115_A0_COMM_IRC_CONr_SET(r,d) (r).comm_irc_con[0] = d
#define BCM53115_A0_COMM_IRC_CONr_GET(r) (r).comm_irc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_COMM_IRC_CONr_PKT_MSK0f_GET(r) (((r).comm_irc_con[0]) & 0x7f)
#define BCM53115_A0_COMM_IRC_CONr_PKT_MSK0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM53115_A0_COMM_IRC_CONr_DROP_EN0f_GET(r) ((((r).comm_irc_con[0]) >> 7) & 0x1)
#define BCM53115_A0_COMM_IRC_CONr_DROP_EN0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_COMM_IRC_CONr_RATE_TYPE0f_GET(r) ((((r).comm_irc_con[0]) >> 8) & 0x1)
#define BCM53115_A0_COMM_IRC_CONr_RATE_TYPE0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_COMM_IRC_CONr_PKT_MSK1f_GET(r) ((((r).comm_irc_con[0]) >> 9) & 0x7f)
#define BCM53115_A0_COMM_IRC_CONr_PKT_MSK1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM53115_A0_COMM_IRC_CONr_DROP_EN1f_GET(r) ((((r).comm_irc_con[0]) >> 16) & 0x1)
#define BCM53115_A0_COMM_IRC_CONr_DROP_EN1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_COMM_IRC_CONr_RATE_TYPE1f_GET(r) ((((r).comm_irc_con[0]) >> 17) & 0x1)
#define BCM53115_A0_COMM_IRC_CONr_RATE_TYPE1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53115_A0_COMM_IRC_CONr_XLEN_ENf_GET(r) ((((r).comm_irc_con[0]) >> 18) & 0x1)
#define BCM53115_A0_COMM_IRC_CONr_XLEN_ENf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53115_A0_COMM_IRC_CONr_RESERVED_Rf_GET(r) ((((r).comm_irc_con[0]) >> 19) & 0x1fff)
#define BCM53115_A0_COMM_IRC_CONr_RESERVED_Rf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access COMM_IRC_CON.
 *
 */
#define BCM53115_A0_READ_COMM_IRC_CONr(u,r) cdk_robo_reg_read(u,BCM53115_A0_COMM_IRC_CONr,(r._comm_irc_con),4)
#define BCM53115_A0_WRITE_COMM_IRC_CONr(u,r) cdk_robo_reg_write(u,BCM53115_A0_COMM_IRC_CONr,&(r._comm_irc_con),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COMM_IRC_CONr BCM53115_A0_COMM_IRC_CONr
#define COMM_IRC_CONr_SIZE BCM53115_A0_COMM_IRC_CONr_SIZE
typedef BCM53115_A0_COMM_IRC_CONr_t COMM_IRC_CONr_t;
#define COMM_IRC_CONr_CLR BCM53115_A0_COMM_IRC_CONr_CLR
#define COMM_IRC_CONr_SET BCM53115_A0_COMM_IRC_CONr_SET
#define COMM_IRC_CONr_GET BCM53115_A0_COMM_IRC_CONr_GET
#define COMM_IRC_CONr_PKT_MSK0f_GET BCM53115_A0_COMM_IRC_CONr_PKT_MSK0f_GET
#define COMM_IRC_CONr_PKT_MSK0f_SET BCM53115_A0_COMM_IRC_CONr_PKT_MSK0f_SET
#define COMM_IRC_CONr_DROP_EN0f_GET BCM53115_A0_COMM_IRC_CONr_DROP_EN0f_GET
#define COMM_IRC_CONr_DROP_EN0f_SET BCM53115_A0_COMM_IRC_CONr_DROP_EN0f_SET
#define COMM_IRC_CONr_RATE_TYPE0f_GET BCM53115_A0_COMM_IRC_CONr_RATE_TYPE0f_GET
#define COMM_IRC_CONr_RATE_TYPE0f_SET BCM53115_A0_COMM_IRC_CONr_RATE_TYPE0f_SET
#define COMM_IRC_CONr_PKT_MSK1f_GET BCM53115_A0_COMM_IRC_CONr_PKT_MSK1f_GET
#define COMM_IRC_CONr_PKT_MSK1f_SET BCM53115_A0_COMM_IRC_CONr_PKT_MSK1f_SET
#define COMM_IRC_CONr_DROP_EN1f_GET BCM53115_A0_COMM_IRC_CONr_DROP_EN1f_GET
#define COMM_IRC_CONr_DROP_EN1f_SET BCM53115_A0_COMM_IRC_CONr_DROP_EN1f_SET
#define COMM_IRC_CONr_RATE_TYPE1f_GET BCM53115_A0_COMM_IRC_CONr_RATE_TYPE1f_GET
#define COMM_IRC_CONr_RATE_TYPE1f_SET BCM53115_A0_COMM_IRC_CONr_RATE_TYPE1f_SET
#define COMM_IRC_CONr_XLEN_ENf_GET BCM53115_A0_COMM_IRC_CONr_XLEN_ENf_GET
#define COMM_IRC_CONr_XLEN_ENf_SET BCM53115_A0_COMM_IRC_CONr_XLEN_ENf_SET
#define COMM_IRC_CONr_RESERVED_Rf_GET BCM53115_A0_COMM_IRC_CONr_RESERVED_Rf_GET
#define COMM_IRC_CONr_RESERVED_Rf_SET BCM53115_A0_COMM_IRC_CONr_RESERVED_Rf_SET
#define READ_COMM_IRC_CONr BCM53115_A0_READ_COMM_IRC_CONr
#define WRITE_COMM_IRC_CONr BCM53115_A0_WRITE_COMM_IRC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_COMM_IRC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  CPU2COS_MAP
 * BLOCKS:   SYS
 * DESC:     CPU to COS Mapping Register
 * SIZE:     32
 * FIELDS:
 *     MIRROR_R         The packet forwarded to the CPU for mirroring reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     SA_LRN           The packet forwarded to the CPU for SA Learning reason .The COS selection is based on the highest COS valuses among all the resons for the packet..
 *     SW_FLD           The packet forwarded to the CPU for Switching/Flooding reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     PRTC_TRMNT       The packet forwarded to the CPU for Protocol Termination reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     PRTC_SNOOP       The packet forwarded to the CPU for Protocol Snooping reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     EXCPT_PRCS       The packet forwarded to the CPU for Exception Processing reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_CPU2COS_MAPr 0x00003064

#define BCM53115_A0_CPU2COS_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CPU2COS_MAP.
 *
 */
typedef union BCM53115_A0_CPU2COS_MAPr_s {
	uint32_t v[1];
	uint32_t cpu2cos_map[1];
	uint32_t _cpu2cos_map;
} BCM53115_A0_CPU2COS_MAPr_t;

#define BCM53115_A0_CPU2COS_MAPr_CLR(r) (r).cpu2cos_map[0] = 0
#define BCM53115_A0_CPU2COS_MAPr_SET(r,d) (r).cpu2cos_map[0] = d
#define BCM53115_A0_CPU2COS_MAPr_GET(r) (r).cpu2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_CPU2COS_MAPr_MIRROR_Rf_GET(r) (((r).cpu2cos_map[0]) & 0x7)
#define BCM53115_A0_CPU2COS_MAPr_MIRROR_Rf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_CPU2COS_MAPr_SA_LRNf_GET(r) ((((r).cpu2cos_map[0]) >> 3) & 0x7)
#define BCM53115_A0_CPU2COS_MAPr_SA_LRNf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_CPU2COS_MAPr_SW_FLDf_GET(r) ((((r).cpu2cos_map[0]) >> 6) & 0x7)
#define BCM53115_A0_CPU2COS_MAPr_SW_FLDf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_CPU2COS_MAPr_PRTC_TRMNTf_GET(r) ((((r).cpu2cos_map[0]) >> 9) & 0x7)
#define BCM53115_A0_CPU2COS_MAPr_PRTC_TRMNTf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53115_A0_CPU2COS_MAPr_PRTC_SNOOPf_GET(r) ((((r).cpu2cos_map[0]) >> 12) & 0x7)
#define BCM53115_A0_CPU2COS_MAPr_PRTC_SNOOPf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_CPU2COS_MAPr_EXCPT_PRCSf_GET(r) ((((r).cpu2cos_map[0]) >> 15) & 0x7)
#define BCM53115_A0_CPU2COS_MAPr_EXCPT_PRCSf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53115_A0_CPU2COS_MAPr_RESERVED_Rf_GET(r) ((((r).cpu2cos_map[0]) >> 18) & 0x3fff)
#define BCM53115_A0_CPU2COS_MAPr_RESERVED_Rf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access CPU2COS_MAP.
 *
 */
#define BCM53115_A0_READ_CPU2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_CPU2COS_MAPr,(r._cpu2cos_map),4)
#define BCM53115_A0_WRITE_CPU2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_CPU2COS_MAPr,&(r._cpu2cos_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU2COS_MAPr BCM53115_A0_CPU2COS_MAPr
#define CPU2COS_MAPr_SIZE BCM53115_A0_CPU2COS_MAPr_SIZE
typedef BCM53115_A0_CPU2COS_MAPr_t CPU2COS_MAPr_t;
#define CPU2COS_MAPr_CLR BCM53115_A0_CPU2COS_MAPr_CLR
#define CPU2COS_MAPr_SET BCM53115_A0_CPU2COS_MAPr_SET
#define CPU2COS_MAPr_GET BCM53115_A0_CPU2COS_MAPr_GET
#define CPU2COS_MAPr_MIRROR_Rf_GET BCM53115_A0_CPU2COS_MAPr_MIRROR_Rf_GET
#define CPU2COS_MAPr_MIRROR_Rf_SET BCM53115_A0_CPU2COS_MAPr_MIRROR_Rf_SET
#define CPU2COS_MAPr_SA_LRNf_GET BCM53115_A0_CPU2COS_MAPr_SA_LRNf_GET
#define CPU2COS_MAPr_SA_LRNf_SET BCM53115_A0_CPU2COS_MAPr_SA_LRNf_SET
#define CPU2COS_MAPr_SW_FLDf_GET BCM53115_A0_CPU2COS_MAPr_SW_FLDf_GET
#define CPU2COS_MAPr_SW_FLDf_SET BCM53115_A0_CPU2COS_MAPr_SW_FLDf_SET
#define CPU2COS_MAPr_PRTC_TRMNTf_GET BCM53115_A0_CPU2COS_MAPr_PRTC_TRMNTf_GET
#define CPU2COS_MAPr_PRTC_TRMNTf_SET BCM53115_A0_CPU2COS_MAPr_PRTC_TRMNTf_SET
#define CPU2COS_MAPr_PRTC_SNOOPf_GET BCM53115_A0_CPU2COS_MAPr_PRTC_SNOOPf_GET
#define CPU2COS_MAPr_PRTC_SNOOPf_SET BCM53115_A0_CPU2COS_MAPr_PRTC_SNOOPf_SET
#define CPU2COS_MAPr_EXCPT_PRCSf_GET BCM53115_A0_CPU2COS_MAPr_EXCPT_PRCSf_GET
#define CPU2COS_MAPr_EXCPT_PRCSf_SET BCM53115_A0_CPU2COS_MAPr_EXCPT_PRCSf_SET
#define CPU2COS_MAPr_RESERVED_Rf_GET BCM53115_A0_CPU2COS_MAPr_RESERVED_Rf_GET
#define CPU2COS_MAPr_RESERVED_Rf_SET BCM53115_A0_CPU2COS_MAPr_RESERVED_Rf_SET
#define READ_CPU2COS_MAPr BCM53115_A0_READ_CPU2COS_MAPr
#define WRITE_CPU2COS_MAPr BCM53115_A0_WRITE_CPU2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_CPU2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DEBUG_REG
 * BLOCKS:   SYS
 * DESC:     Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_DEBUG         1 : Enable debugging bus
 *     DEBUG_SEL_R      Debug bus select.
 *     MDC_TIMING_ENH   
 *
 ******************************************************************************/
#define BCM53115_A0_DEBUG_REGr 0x0000001e

#define BCM53115_A0_DEBUG_REGr_SIZE 1

/*
 * This structure should be used to declare and program DEBUG_REG.
 *
 */
typedef union BCM53115_A0_DEBUG_REGr_s {
	uint32_t v[1];
	uint32_t debug_reg[1];
	uint32_t _debug_reg;
} BCM53115_A0_DEBUG_REGr_t;

#define BCM53115_A0_DEBUG_REGr_CLR(r) (r).debug_reg[0] = 0
#define BCM53115_A0_DEBUG_REGr_SET(r,d) (r).debug_reg[0] = d
#define BCM53115_A0_DEBUG_REGr_GET(r) (r).debug_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DEBUG_REGr_EN_DEBUGf_GET(r) (((r).debug_reg[0]) & 0x1)
#define BCM53115_A0_DEBUG_REGr_EN_DEBUGf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_DEBUG_REGr_DEBUG_SEL_Rf_GET(r) ((((r).debug_reg[0]) >> 1) & 0x3f)
#define BCM53115_A0_DEBUG_REGr_DEBUG_SEL_Rf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53115_A0_DEBUG_REGr_MDC_TIMING_ENHf_GET(r) ((((r).debug_reg[0]) >> 7) & 0x1)
#define BCM53115_A0_DEBUG_REGr_MDC_TIMING_ENHf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access DEBUG_REG.
 *
 */
#define BCM53115_A0_READ_DEBUG_REGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DEBUG_REGr,(r._debug_reg),1)
#define BCM53115_A0_WRITE_DEBUG_REGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DEBUG_REGr,&(r._debug_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG_REGr BCM53115_A0_DEBUG_REGr
#define DEBUG_REGr_SIZE BCM53115_A0_DEBUG_REGr_SIZE
typedef BCM53115_A0_DEBUG_REGr_t DEBUG_REGr_t;
#define DEBUG_REGr_CLR BCM53115_A0_DEBUG_REGr_CLR
#define DEBUG_REGr_SET BCM53115_A0_DEBUG_REGr_SET
#define DEBUG_REGr_GET BCM53115_A0_DEBUG_REGr_GET
#define DEBUG_REGr_EN_DEBUGf_GET BCM53115_A0_DEBUG_REGr_EN_DEBUGf_GET
#define DEBUG_REGr_EN_DEBUGf_SET BCM53115_A0_DEBUG_REGr_EN_DEBUGf_SET
#define DEBUG_REGr_DEBUG_SEL_Rf_GET BCM53115_A0_DEBUG_REGr_DEBUG_SEL_Rf_GET
#define DEBUG_REGr_DEBUG_SEL_Rf_SET BCM53115_A0_DEBUG_REGr_DEBUG_SEL_Rf_SET
#define DEBUG_REGr_MDC_TIMING_ENHf_GET BCM53115_A0_DEBUG_REGr_MDC_TIMING_ENHf_GET
#define DEBUG_REGr_MDC_TIMING_ENHf_SET BCM53115_A0_DEBUG_REGr_MDC_TIMING_ENHf_SET
#define READ_DEBUG_REGr BCM53115_A0_READ_DEBUG_REGr
#define WRITE_DEBUG_REGr BCM53115_A0_WRITE_DEBUG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DEBUG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DEFAULT_1Q_TAG
 * BLOCKS:   CPIC GPIC0
 * DESC:     802.1Q Default Port Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID_R            Default VLAN ID.When incoming packet is non-1Q tagged frame or priority tagged frame,Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI_R            Canonical Form Indicator (BCM5388 don't care this bit).
 *     PRI_R            Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM53115_A0_DEFAULT_1Q_TAGr 0x00003410

#define BCM53115_A0_DEFAULT_1Q_TAGr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG.
 *
 */
typedef union BCM53115_A0_DEFAULT_1Q_TAGr_s {
	uint32_t v[1];
	uint32_t default_1q_tag[1];
	uint32_t _default_1q_tag;
} BCM53115_A0_DEFAULT_1Q_TAGr_t;

#define BCM53115_A0_DEFAULT_1Q_TAGr_CLR(r) (r).default_1q_tag[0] = 0
#define BCM53115_A0_DEFAULT_1Q_TAGr_SET(r,d) (r).default_1q_tag[0] = d
#define BCM53115_A0_DEFAULT_1Q_TAGr_GET(r) (r).default_1q_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DEFAULT_1Q_TAGr_VID_Rf_GET(r) (((r).default_1q_tag[0]) & 0xfff)
#define BCM53115_A0_DEFAULT_1Q_TAGr_VID_Rf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_DEFAULT_1Q_TAGr_CFI_Rf_GET(r) ((((r).default_1q_tag[0]) >> 12) & 0x1)
#define BCM53115_A0_DEFAULT_1Q_TAGr_CFI_Rf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_DEFAULT_1Q_TAGr_PRI_Rf_GET(r) ((((r).default_1q_tag[0]) >> 13) & 0x7)
#define BCM53115_A0_DEFAULT_1Q_TAGr_PRI_Rf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG.
 *
 */
#define BCM53115_A0_READ_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_DEFAULT_1Q_TAGr,(r._default_1q_tag),2)
#define BCM53115_A0_WRITE_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_DEFAULT_1Q_TAGr,&(r._default_1q_tag),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAGr BCM53115_A0_DEFAULT_1Q_TAGr
#define DEFAULT_1Q_TAGr_SIZE BCM53115_A0_DEFAULT_1Q_TAGr_SIZE
typedef BCM53115_A0_DEFAULT_1Q_TAGr_t DEFAULT_1Q_TAGr_t;
#define DEFAULT_1Q_TAGr_CLR BCM53115_A0_DEFAULT_1Q_TAGr_CLR
#define DEFAULT_1Q_TAGr_SET BCM53115_A0_DEFAULT_1Q_TAGr_SET
#define DEFAULT_1Q_TAGr_GET BCM53115_A0_DEFAULT_1Q_TAGr_GET
#define DEFAULT_1Q_TAGr_VID_Rf_GET BCM53115_A0_DEFAULT_1Q_TAGr_VID_Rf_GET
#define DEFAULT_1Q_TAGr_VID_Rf_SET BCM53115_A0_DEFAULT_1Q_TAGr_VID_Rf_SET
#define DEFAULT_1Q_TAGr_CFI_Rf_GET BCM53115_A0_DEFAULT_1Q_TAGr_CFI_Rf_GET
#define DEFAULT_1Q_TAGr_CFI_Rf_SET BCM53115_A0_DEFAULT_1Q_TAGr_CFI_Rf_SET
#define DEFAULT_1Q_TAGr_PRI_Rf_GET BCM53115_A0_DEFAULT_1Q_TAGr_PRI_Rf_GET
#define DEFAULT_1Q_TAGr_PRI_Rf_SET BCM53115_A0_DEFAULT_1Q_TAGr_PRI_Rf_SET
#define READ_DEFAULT_1Q_TAGr BCM53115_A0_READ_DEFAULT_1Q_TAGr
#define WRITE_DEFAULT_1Q_TAGr BCM53115_A0_WRITE_DEFAULT_1Q_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DEFAULT_1Q_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DEFAULT_1Q_TAG_IMP
 * BLOCKS:   CPIC
 * DESC:     802.1Q Default Port 8 Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID_R            Default VLAN ID.When incoming packet is non-1Q tagged frame or priority tagged frame,Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI_R            Canonical Form Indicator (BCM5388 don't care this bit).
 *     PRI_R            Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr 0x00003420

#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG_IMP.
 *
 */
typedef union BCM53115_A0_DEFAULT_1Q_TAG_IMPr_s {
	uint32_t v[1];
	uint32_t default_1q_tag_imp[1];
	uint32_t _default_1q_tag_imp;
} BCM53115_A0_DEFAULT_1Q_TAG_IMPr_t;

#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_CLR(r) (r).default_1q_tag_imp[0] = 0
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_SET(r,d) (r).default_1q_tag_imp[0] = d
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_GET(r) (r).default_1q_tag_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_VID_Rf_GET(r) (((r).default_1q_tag_imp[0]) & 0xfff)
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_VID_Rf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_CFI_Rf_GET(r) ((((r).default_1q_tag_imp[0]) >> 12) & 0x1)
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_CFI_Rf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_PRI_Rf_GET(r) ((((r).default_1q_tag_imp[0]) >> 13) & 0x7)
#define BCM53115_A0_DEFAULT_1Q_TAG_IMPr_PRI_Rf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG_IMP.
 *
 */
#define BCM53115_A0_READ_DEFAULT_1Q_TAG_IMPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DEFAULT_1Q_TAG_IMPr,(r._default_1q_tag_imp),2)
#define BCM53115_A0_WRITE_DEFAULT_1Q_TAG_IMPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DEFAULT_1Q_TAG_IMPr,&(r._default_1q_tag_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAG_IMPr BCM53115_A0_DEFAULT_1Q_TAG_IMPr
#define DEFAULT_1Q_TAG_IMPr_SIZE BCM53115_A0_DEFAULT_1Q_TAG_IMPr_SIZE
typedef BCM53115_A0_DEFAULT_1Q_TAG_IMPr_t DEFAULT_1Q_TAG_IMPr_t;
#define DEFAULT_1Q_TAG_IMPr_CLR BCM53115_A0_DEFAULT_1Q_TAG_IMPr_CLR
#define DEFAULT_1Q_TAG_IMPr_SET BCM53115_A0_DEFAULT_1Q_TAG_IMPr_SET
#define DEFAULT_1Q_TAG_IMPr_GET BCM53115_A0_DEFAULT_1Q_TAG_IMPr_GET
#define DEFAULT_1Q_TAG_IMPr_VID_Rf_GET BCM53115_A0_DEFAULT_1Q_TAG_IMPr_VID_Rf_GET
#define DEFAULT_1Q_TAG_IMPr_VID_Rf_SET BCM53115_A0_DEFAULT_1Q_TAG_IMPr_VID_Rf_SET
#define DEFAULT_1Q_TAG_IMPr_CFI_Rf_GET BCM53115_A0_DEFAULT_1Q_TAG_IMPr_CFI_Rf_GET
#define DEFAULT_1Q_TAG_IMPr_CFI_Rf_SET BCM53115_A0_DEFAULT_1Q_TAG_IMPr_CFI_Rf_SET
#define DEFAULT_1Q_TAG_IMPr_PRI_Rf_GET BCM53115_A0_DEFAULT_1Q_TAG_IMPr_PRI_Rf_GET
#define DEFAULT_1Q_TAG_IMPr_PRI_Rf_SET BCM53115_A0_DEFAULT_1Q_TAG_IMPr_PRI_Rf_SET
#define READ_DEFAULT_1Q_TAG_IMPr BCM53115_A0_READ_DEFAULT_1Q_TAG_IMPr
#define WRITE_DEFAULT_1Q_TAG_IMPr BCM53115_A0_WRITE_DEFAULT_1Q_TAG_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DEFAULT_1Q_TAG_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DF_TIMER
 * BLOCKS:   SYS
 * DESC:     Discovery Frame Timer Registers
 * SIZE:     8
 * FIELDS:
 *     DF_TIME          Frome 1 sec to 16 sec,scale = 1 sec
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_DF_TIMERr 0x00007202

#define BCM53115_A0_DF_TIMERr_SIZE 1

/*
 * This structure should be used to declare and program DF_TIMER.
 *
 */
typedef union BCM53115_A0_DF_TIMERr_s {
	uint32_t v[1];
	uint32_t df_timer[1];
	uint32_t _df_timer;
} BCM53115_A0_DF_TIMERr_t;

#define BCM53115_A0_DF_TIMERr_CLR(r) (r).df_timer[0] = 0
#define BCM53115_A0_DF_TIMERr_SET(r,d) (r).df_timer[0] = d
#define BCM53115_A0_DF_TIMERr_GET(r) (r).df_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DF_TIMERr_DF_TIMEf_GET(r) (((r).df_timer[0]) & 0xf)
#define BCM53115_A0_DF_TIMERr_DF_TIMEf_SET(r,f) (r).df_timer[0]=(((r).df_timer[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_DF_TIMERr_RESERVED_Rf_GET(r) ((((r).df_timer[0]) >> 4) & 0xf)
#define BCM53115_A0_DF_TIMERr_RESERVED_Rf_SET(r,f) (r).df_timer[0]=(((r).df_timer[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access DF_TIMER.
 *
 */
#define BCM53115_A0_READ_DF_TIMERr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DF_TIMERr,(r._df_timer),1)
#define BCM53115_A0_WRITE_DF_TIMERr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DF_TIMERr,&(r._df_timer),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DF_TIMERr BCM53115_A0_DF_TIMERr
#define DF_TIMERr_SIZE BCM53115_A0_DF_TIMERr_SIZE
typedef BCM53115_A0_DF_TIMERr_t DF_TIMERr_t;
#define DF_TIMERr_CLR BCM53115_A0_DF_TIMERr_CLR
#define DF_TIMERr_SET BCM53115_A0_DF_TIMERr_SET
#define DF_TIMERr_GET BCM53115_A0_DF_TIMERr_GET
#define DF_TIMERr_DF_TIMEf_GET BCM53115_A0_DF_TIMERr_DF_TIMEf_GET
#define DF_TIMERr_DF_TIMEf_SET BCM53115_A0_DF_TIMERr_DF_TIMEf_SET
#define DF_TIMERr_RESERVED_Rf_GET BCM53115_A0_DF_TIMERr_RESERVED_Rf_GET
#define DF_TIMERr_RESERVED_Rf_SET BCM53115_A0_DF_TIMERr_RESERVED_Rf_SET
#define READ_DF_TIMERr BCM53115_A0_READ_DF_TIMERr
#define WRITE_DF_TIMERr BCM53115_A0_WRITE_DF_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DF_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DIRECT_CTRL_PIN
 * BLOCKS:   SYS
 * DESC:     Direct input control value register
 * SIZE:     32
 * FIELDS:
 *     ACT_LOOP_DETECT  
 *     OSC_XTAL_SEL     
 *     GPHY_TEST        
 *     IMP_DUPLEX       
 *     IMP_LINK         
 *     IMP_PAUSECAP_RX  
 *     IMP_PAUSECAP_TX  
 *     IMP_SPEED        
 *     OVST_B           
 *     PROBE_SYSCLK     
 *     TST_ENABLE       
 *     EN_CLK25_OUT     
 *     LOOP_DETECTED    
 *     IMP_VOLTAGE_SEL0 
 *     IMP_VOLTAGE_SEL1 
 *     GMII_VOLTAGE_SEL0 
 *     GMII_VOLTAGE_SEL1 
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_DIRECT_CTRL_PINr 0x00000180

#define BCM53115_A0_DIRECT_CTRL_PINr_SIZE 4

/*
 * This structure should be used to declare and program DIRECT_CTRL_PIN.
 *
 */
typedef union BCM53115_A0_DIRECT_CTRL_PINr_s {
	uint32_t v[1];
	uint32_t direct_ctrl_pin[1];
	uint32_t _direct_ctrl_pin;
} BCM53115_A0_DIRECT_CTRL_PINr_t;

#define BCM53115_A0_DIRECT_CTRL_PINr_CLR(r) (r).direct_ctrl_pin[0] = 0
#define BCM53115_A0_DIRECT_CTRL_PINr_SET(r,d) (r).direct_ctrl_pin[0] = d
#define BCM53115_A0_DIRECT_CTRL_PINr_GET(r) (r).direct_ctrl_pin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DIRECT_CTRL_PINr_ACT_LOOP_DETECTf_GET(r) (((r).direct_ctrl_pin[0]) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_ACT_LOOP_DETECTf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_DIRECT_CTRL_PINr_OSC_XTAL_SELf_GET(r) ((((r).direct_ctrl_pin[0]) >> 1) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_OSC_XTAL_SELf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_DIRECT_CTRL_PINr_GPHY_TESTf_GET(r) ((((r).direct_ctrl_pin[0]) >> 2) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_GPHY_TESTf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_DUPLEXf_GET(r) ((((r).direct_ctrl_pin[0]) >> 3) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_DUPLEXf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_LINKf_GET(r) ((((r).direct_ctrl_pin[0]) >> 4) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_LINKf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_PAUSECAP_RXf_GET(r) ((((r).direct_ctrl_pin[0]) >> 5) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_PAUSECAP_RXf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_PAUSECAP_TXf_GET(r) ((((r).direct_ctrl_pin[0]) >> 6) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_PAUSECAP_TXf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_SPEEDf_GET(r) ((((r).direct_ctrl_pin[0]) >> 7) & 0x3)
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_SPEEDf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM53115_A0_DIRECT_CTRL_PINr_OVST_Bf_GET(r) ((((r).direct_ctrl_pin[0]) >> 9) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_OVST_Bf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_DIRECT_CTRL_PINr_PROBE_SYSCLKf_GET(r) ((((r).direct_ctrl_pin[0]) >> 10) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_PROBE_SYSCLKf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_DIRECT_CTRL_PINr_TST_ENABLEf_GET(r) ((((r).direct_ctrl_pin[0]) >> 11) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_TST_ENABLEf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_DIRECT_CTRL_PINr_EN_CLK25_OUTf_GET(r) ((((r).direct_ctrl_pin[0]) >> 12) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_EN_CLK25_OUTf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_DIRECT_CTRL_PINr_LOOP_DETECTEDf_GET(r) ((((r).direct_ctrl_pin[0]) >> 13) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_LOOP_DETECTEDf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL0f_GET(r) ((((r).direct_ctrl_pin[0]) >> 14) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL0f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL1f_GET(r) ((((r).direct_ctrl_pin[0]) >> 15) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL1f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL0f_GET(r) ((((r).direct_ctrl_pin[0]) >> 16) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL0f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL1f_GET(r) ((((r).direct_ctrl_pin[0]) >> 17) & 0x1)
#define BCM53115_A0_DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL1f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53115_A0_DIRECT_CTRL_PINr_RESERVED_Rf_GET(r) ((((r).direct_ctrl_pin[0]) >> 18) & 0x3fff)
#define BCM53115_A0_DIRECT_CTRL_PINr_RESERVED_Rf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access DIRECT_CTRL_PIN.
 *
 */
#define BCM53115_A0_READ_DIRECT_CTRL_PINr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DIRECT_CTRL_PINr,(r._direct_ctrl_pin),4)
#define BCM53115_A0_WRITE_DIRECT_CTRL_PINr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DIRECT_CTRL_PINr,&(r._direct_ctrl_pin),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIRECT_CTRL_PINr BCM53115_A0_DIRECT_CTRL_PINr
#define DIRECT_CTRL_PINr_SIZE BCM53115_A0_DIRECT_CTRL_PINr_SIZE
typedef BCM53115_A0_DIRECT_CTRL_PINr_t DIRECT_CTRL_PINr_t;
#define DIRECT_CTRL_PINr_CLR BCM53115_A0_DIRECT_CTRL_PINr_CLR
#define DIRECT_CTRL_PINr_SET BCM53115_A0_DIRECT_CTRL_PINr_SET
#define DIRECT_CTRL_PINr_GET BCM53115_A0_DIRECT_CTRL_PINr_GET
#define DIRECT_CTRL_PINr_ACT_LOOP_DETECTf_GET BCM53115_A0_DIRECT_CTRL_PINr_ACT_LOOP_DETECTf_GET
#define DIRECT_CTRL_PINr_ACT_LOOP_DETECTf_SET BCM53115_A0_DIRECT_CTRL_PINr_ACT_LOOP_DETECTf_SET
#define DIRECT_CTRL_PINr_OSC_XTAL_SELf_GET BCM53115_A0_DIRECT_CTRL_PINr_OSC_XTAL_SELf_GET
#define DIRECT_CTRL_PINr_OSC_XTAL_SELf_SET BCM53115_A0_DIRECT_CTRL_PINr_OSC_XTAL_SELf_SET
#define DIRECT_CTRL_PINr_GPHY_TESTf_GET BCM53115_A0_DIRECT_CTRL_PINr_GPHY_TESTf_GET
#define DIRECT_CTRL_PINr_GPHY_TESTf_SET BCM53115_A0_DIRECT_CTRL_PINr_GPHY_TESTf_SET
#define DIRECT_CTRL_PINr_IMP_DUPLEXf_GET BCM53115_A0_DIRECT_CTRL_PINr_IMP_DUPLEXf_GET
#define DIRECT_CTRL_PINr_IMP_DUPLEXf_SET BCM53115_A0_DIRECT_CTRL_PINr_IMP_DUPLEXf_SET
#define DIRECT_CTRL_PINr_IMP_LINKf_GET BCM53115_A0_DIRECT_CTRL_PINr_IMP_LINKf_GET
#define DIRECT_CTRL_PINr_IMP_LINKf_SET BCM53115_A0_DIRECT_CTRL_PINr_IMP_LINKf_SET
#define DIRECT_CTRL_PINr_IMP_PAUSECAP_RXf_GET BCM53115_A0_DIRECT_CTRL_PINr_IMP_PAUSECAP_RXf_GET
#define DIRECT_CTRL_PINr_IMP_PAUSECAP_RXf_SET BCM53115_A0_DIRECT_CTRL_PINr_IMP_PAUSECAP_RXf_SET
#define DIRECT_CTRL_PINr_IMP_PAUSECAP_TXf_GET BCM53115_A0_DIRECT_CTRL_PINr_IMP_PAUSECAP_TXf_GET
#define DIRECT_CTRL_PINr_IMP_PAUSECAP_TXf_SET BCM53115_A0_DIRECT_CTRL_PINr_IMP_PAUSECAP_TXf_SET
#define DIRECT_CTRL_PINr_IMP_SPEEDf_GET BCM53115_A0_DIRECT_CTRL_PINr_IMP_SPEEDf_GET
#define DIRECT_CTRL_PINr_IMP_SPEEDf_SET BCM53115_A0_DIRECT_CTRL_PINr_IMP_SPEEDf_SET
#define DIRECT_CTRL_PINr_OVST_Bf_GET BCM53115_A0_DIRECT_CTRL_PINr_OVST_Bf_GET
#define DIRECT_CTRL_PINr_OVST_Bf_SET BCM53115_A0_DIRECT_CTRL_PINr_OVST_Bf_SET
#define DIRECT_CTRL_PINr_PROBE_SYSCLKf_GET BCM53115_A0_DIRECT_CTRL_PINr_PROBE_SYSCLKf_GET
#define DIRECT_CTRL_PINr_PROBE_SYSCLKf_SET BCM53115_A0_DIRECT_CTRL_PINr_PROBE_SYSCLKf_SET
#define DIRECT_CTRL_PINr_TST_ENABLEf_GET BCM53115_A0_DIRECT_CTRL_PINr_TST_ENABLEf_GET
#define DIRECT_CTRL_PINr_TST_ENABLEf_SET BCM53115_A0_DIRECT_CTRL_PINr_TST_ENABLEf_SET
#define DIRECT_CTRL_PINr_EN_CLK25_OUTf_GET BCM53115_A0_DIRECT_CTRL_PINr_EN_CLK25_OUTf_GET
#define DIRECT_CTRL_PINr_EN_CLK25_OUTf_SET BCM53115_A0_DIRECT_CTRL_PINr_EN_CLK25_OUTf_SET
#define DIRECT_CTRL_PINr_LOOP_DETECTEDf_GET BCM53115_A0_DIRECT_CTRL_PINr_LOOP_DETECTEDf_GET
#define DIRECT_CTRL_PINr_LOOP_DETECTEDf_SET BCM53115_A0_DIRECT_CTRL_PINr_LOOP_DETECTEDf_SET
#define DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL0f_GET BCM53115_A0_DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL0f_GET
#define DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL0f_SET BCM53115_A0_DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL0f_SET
#define DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL1f_GET BCM53115_A0_DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL1f_GET
#define DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL1f_SET BCM53115_A0_DIRECT_CTRL_PINr_IMP_VOLTAGE_SEL1f_SET
#define DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL0f_GET BCM53115_A0_DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL0f_GET
#define DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL0f_SET BCM53115_A0_DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL0f_SET
#define DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL1f_GET BCM53115_A0_DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL1f_GET
#define DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL1f_SET BCM53115_A0_DIRECT_CTRL_PINr_GMII_VOLTAGE_SEL1f_SET
#define DIRECT_CTRL_PINr_RESERVED_Rf_GET BCM53115_A0_DIRECT_CTRL_PINr_RESERVED_Rf_GET
#define DIRECT_CTRL_PINr_RESERVED_Rf_SET BCM53115_A0_DIRECT_CTRL_PINr_RESERVED_Rf_SET
#define READ_DIRECT_CTRL_PINr BCM53115_A0_READ_DIRECT_CTRL_PINr
#define WRITE_DIRECT_CTRL_PINr BCM53115_A0_WRITE_DIRECT_CTRL_PINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DIRECT_CTRL_PINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DIS_LEARN
 * BLOCKS:   SYS
 * DESC:     Disable Learning Registrer
 * SIZE:     16
 * FIELDS:
 *     DIS_LEARN        1 : Disable learning.0 : Enable Learning.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_DIS_LEARNr 0x0000003c

#define BCM53115_A0_DIS_LEARNr_SIZE 2

/*
 * This structure should be used to declare and program DIS_LEARN.
 *
 */
typedef union BCM53115_A0_DIS_LEARNr_s {
	uint32_t v[1];
	uint32_t dis_learn[1];
	uint32_t _dis_learn;
} BCM53115_A0_DIS_LEARNr_t;

#define BCM53115_A0_DIS_LEARNr_CLR(r) (r).dis_learn[0] = 0
#define BCM53115_A0_DIS_LEARNr_SET(r,d) (r).dis_learn[0] = d
#define BCM53115_A0_DIS_LEARNr_GET(r) (r).dis_learn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DIS_LEARNr_DIS_LEARNf_GET(r) (((r).dis_learn[0]) & 0x1ff)
#define BCM53115_A0_DIS_LEARNr_DIS_LEARNf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_DIS_LEARNr_RESERVED_Rf_GET(r) ((((r).dis_learn[0]) >> 9) & 0x7f)
#define BCM53115_A0_DIS_LEARNr_RESERVED_Rf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DIS_LEARN.
 *
 */
#define BCM53115_A0_READ_DIS_LEARNr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DIS_LEARNr,(r._dis_learn),2)
#define BCM53115_A0_WRITE_DIS_LEARNr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DIS_LEARNr,&(r._dis_learn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIS_LEARNr BCM53115_A0_DIS_LEARNr
#define DIS_LEARNr_SIZE BCM53115_A0_DIS_LEARNr_SIZE
typedef BCM53115_A0_DIS_LEARNr_t DIS_LEARNr_t;
#define DIS_LEARNr_CLR BCM53115_A0_DIS_LEARNr_CLR
#define DIS_LEARNr_SET BCM53115_A0_DIS_LEARNr_SET
#define DIS_LEARNr_GET BCM53115_A0_DIS_LEARNr_GET
#define DIS_LEARNr_DIS_LEARNf_GET BCM53115_A0_DIS_LEARNr_DIS_LEARNf_GET
#define DIS_LEARNr_DIS_LEARNf_SET BCM53115_A0_DIS_LEARNr_DIS_LEARNf_SET
#define DIS_LEARNr_RESERVED_Rf_GET BCM53115_A0_DIS_LEARNr_RESERVED_Rf_GET
#define DIS_LEARNr_RESERVED_Rf_SET BCM53115_A0_DIS_LEARNr_RESERVED_Rf_SET
#define READ_DIS_LEARNr BCM53115_A0_READ_DIS_LEARNr
#define WRITE_DIS_LEARNr BCM53115_A0_WRITE_DIS_LEARNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DIS_LEARNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DOS_CTRL
 * BLOCKS:   SYS
 * DESC:     DoS Control RegisterRegister
 * SIZE:     32
 * FIELDS:
 *     RESERVED_R       
 *     IP_LAND_DROP_EN  1= Drop0= Do not drop
 *     TCP_BLAT_DROP_EN 1= Drop0= Do not drop
 *     UDP_BLAT_DROP_EN 1= Drop0= Do not drop
 *     TCP_NULL_SCAN_DROP_EN 1= Drop0= Do not drop
 *     TCP_XMASS_SCAN_DROP_EN 1= Drop0= Do not drop
 *     TCP_SYNFIN_SCAN_DROP_EN 1= Drop0= Do not drop
 *     TCP_SYN_ERR_DROP_EN 1= Drop0= Do not drop
 *     TCP_SHORT_HDR_DROP_EN 1= Drop0= Do not drop
 *     TCP_FRAG_ERR_DROP_EN 1= Drop0= Do not drop
 *     ICMPV4_FRAGMENT_DROP_EN 1= Drop0= Do not drop
 *     ICMPV6_FRAGMENT_DROP_EN 1= Drop0= Do not drop
 *     ICMPV4_LONG_PING_DROP_EN 1= Drop0= Do not drop
 *     ICMPV6_LONG_PING_DROP_EN 1= Drop0= Do not drop
 *
 ******************************************************************************/
#define BCM53115_A0_DOS_CTRLr 0x00003600

#define BCM53115_A0_DOS_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CTRL.
 *
 */
typedef union BCM53115_A0_DOS_CTRLr_s {
	uint32_t v[1];
	uint32_t dos_ctrl[1];
	uint32_t _dos_ctrl;
} BCM53115_A0_DOS_CTRLr_t;

#define BCM53115_A0_DOS_CTRLr_CLR(r) (r).dos_ctrl[0] = 0
#define BCM53115_A0_DOS_CTRLr_SET(r,d) (r).dos_ctrl[0] = d
#define BCM53115_A0_DOS_CTRLr_GET(r) (r).dos_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DOS_CTRLr_RESERVED_Rf_GET(r) (((r).dos_ctrl[0]) & 0x1)
#define BCM53115_A0_DOS_CTRLr_RESERVED_Rf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_DOS_CTRLr_IP_LAND_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_DOS_CTRLr_IP_LAND_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 3) & 0x1)
#define BCM53115_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 4) & 0x1)
#define BCM53115_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 5) & 0x1)
#define BCM53115_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 6) & 0x1)
#define BCM53115_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 7) & 0x1)
#define BCM53115_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 8) & 0x1)
#define BCM53115_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 9) & 0x1)
#define BCM53115_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 10) & 0x1)
#define BCM53115_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 11) & 0x1)
#define BCM53115_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 12) & 0x1)
#define BCM53115_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 13) & 0x1)
#define BCM53115_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access DOS_CTRL.
 *
 */
#define BCM53115_A0_READ_DOS_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DOS_CTRLr,(r._dos_ctrl),4)
#define BCM53115_A0_WRITE_DOS_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DOS_CTRLr,&(r._dos_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CTRLr BCM53115_A0_DOS_CTRLr
#define DOS_CTRLr_SIZE BCM53115_A0_DOS_CTRLr_SIZE
typedef BCM53115_A0_DOS_CTRLr_t DOS_CTRLr_t;
#define DOS_CTRLr_CLR BCM53115_A0_DOS_CTRLr_CLR
#define DOS_CTRLr_SET BCM53115_A0_DOS_CTRLr_SET
#define DOS_CTRLr_GET BCM53115_A0_DOS_CTRLr_GET
#define DOS_CTRLr_RESERVED_Rf_GET BCM53115_A0_DOS_CTRLr_RESERVED_Rf_GET
#define DOS_CTRLr_RESERVED_Rf_SET BCM53115_A0_DOS_CTRLr_RESERVED_Rf_SET
#define DOS_CTRLr_IP_LAND_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_IP_LAND_DROP_ENf_GET
#define DOS_CTRLr_IP_LAND_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_IP_LAND_DROP_ENf_SET
#define DOS_CTRLr_TCP_BLAT_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_GET
#define DOS_CTRLr_TCP_BLAT_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_SET
#define DOS_CTRLr_UDP_BLAT_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_GET
#define DOS_CTRLr_UDP_BLAT_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_SET
#define DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET
#define DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET
#define DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET
#define DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET
#define DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET
#define DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET
#define DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET
#define DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET
#define DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET
#define DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET
#define DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET
#define DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET
#define DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET BCM53115_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET
#define DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET BCM53115_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET
#define READ_DOS_CTRLr BCM53115_A0_READ_DOS_CTRLr
#define WRITE_DOS_CTRLr BCM53115_A0_WRITE_DOS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DOS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DOS_DIS_LRN_REG
 * BLOCKS:   SYS
 * DESC:     DoS Disable Learn Register
 * SIZE:     8
 * FIELDS:
 *     DOS_DIS_LRN      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_DOS_DIS_LRN_REGr 0x00003610

#define BCM53115_A0_DOS_DIS_LRN_REGr_SIZE 1

/*
 * This structure should be used to declare and program DOS_DIS_LRN_REG.
 *
 */
typedef union BCM53115_A0_DOS_DIS_LRN_REGr_s {
	uint32_t v[1];
	uint32_t dos_dis_lrn_reg[1];
	uint32_t _dos_dis_lrn_reg;
} BCM53115_A0_DOS_DIS_LRN_REGr_t;

#define BCM53115_A0_DOS_DIS_LRN_REGr_CLR(r) (r).dos_dis_lrn_reg[0] = 0
#define BCM53115_A0_DOS_DIS_LRN_REGr_SET(r,d) (r).dos_dis_lrn_reg[0] = d
#define BCM53115_A0_DOS_DIS_LRN_REGr_GET(r) (r).dos_dis_lrn_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET(r) (((r).dos_dis_lrn_reg[0]) & 0x1)
#define BCM53115_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET(r,f) (r).dos_dis_lrn_reg[0]=(((r).dos_dis_lrn_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_DOS_DIS_LRN_REGr_RESERVED_Rf_GET(r) ((((r).dos_dis_lrn_reg[0]) >> 1) & 0x7f)
#define BCM53115_A0_DOS_DIS_LRN_REGr_RESERVED_Rf_SET(r,f) (r).dos_dis_lrn_reg[0]=(((r).dos_dis_lrn_reg[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access DOS_DIS_LRN_REG.
 *
 */
#define BCM53115_A0_READ_DOS_DIS_LRN_REGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DOS_DIS_LRN_REGr,(r._dos_dis_lrn_reg),1)
#define BCM53115_A0_WRITE_DOS_DIS_LRN_REGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DOS_DIS_LRN_REGr,&(r._dos_dis_lrn_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_DIS_LRN_REGr BCM53115_A0_DOS_DIS_LRN_REGr
#define DOS_DIS_LRN_REGr_SIZE BCM53115_A0_DOS_DIS_LRN_REGr_SIZE
typedef BCM53115_A0_DOS_DIS_LRN_REGr_t DOS_DIS_LRN_REGr_t;
#define DOS_DIS_LRN_REGr_CLR BCM53115_A0_DOS_DIS_LRN_REGr_CLR
#define DOS_DIS_LRN_REGr_SET BCM53115_A0_DOS_DIS_LRN_REGr_SET
#define DOS_DIS_LRN_REGr_GET BCM53115_A0_DOS_DIS_LRN_REGr_GET
#define DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET BCM53115_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET
#define DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET BCM53115_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET
#define DOS_DIS_LRN_REGr_RESERVED_Rf_GET BCM53115_A0_DOS_DIS_LRN_REGr_RESERVED_Rf_GET
#define DOS_DIS_LRN_REGr_RESERVED_Rf_SET BCM53115_A0_DOS_DIS_LRN_REGr_RESERVED_Rf_SET
#define READ_DOS_DIS_LRN_REGr BCM53115_A0_READ_DOS_DIS_LRN_REGr
#define WRITE_DOS_DIS_LRN_REGr BCM53115_A0_WRITE_DOS_DIS_LRN_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DOS_DIS_LRN_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DTAG_TPID
 * BLOCKS:   SYS
 * DESC:     Double Tagging TPID Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_TPID         TPID used to identify double tagged frame or not.
 *
 ******************************************************************************/
#define BCM53115_A0_DTAG_TPIDr 0x00003430

#define BCM53115_A0_DTAG_TPIDr_SIZE 2

/*
 * This structure should be used to declare and program DTAG_TPID.
 *
 */
typedef union BCM53115_A0_DTAG_TPIDr_s {
	uint32_t v[1];
	uint32_t dtag_tpid[1];
	uint32_t _dtag_tpid;
} BCM53115_A0_DTAG_TPIDr_t;

#define BCM53115_A0_DTAG_TPIDr_CLR(r) (r).dtag_tpid[0] = 0
#define BCM53115_A0_DTAG_TPIDr_SET(r,d) (r).dtag_tpid[0] = d
#define BCM53115_A0_DTAG_TPIDr_GET(r) (r).dtag_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DTAG_TPIDr_ISP_TPIDf_GET(r) (((r).dtag_tpid[0]) & 0xffff)
#define BCM53115_A0_DTAG_TPIDr_ISP_TPIDf_SET(r,f) (r).dtag_tpid[0]=(((r).dtag_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DTAG_TPID.
 *
 */
#define BCM53115_A0_READ_DTAG_TPIDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DTAG_TPIDr,(r._dtag_tpid),2)
#define BCM53115_A0_WRITE_DTAG_TPIDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DTAG_TPIDr,&(r._dtag_tpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DTAG_TPIDr BCM53115_A0_DTAG_TPIDr
#define DTAG_TPIDr_SIZE BCM53115_A0_DTAG_TPIDr_SIZE
typedef BCM53115_A0_DTAG_TPIDr_t DTAG_TPIDr_t;
#define DTAG_TPIDr_CLR BCM53115_A0_DTAG_TPIDr_CLR
#define DTAG_TPIDr_SET BCM53115_A0_DTAG_TPIDr_SET
#define DTAG_TPIDr_GET BCM53115_A0_DTAG_TPIDr_GET
#define DTAG_TPIDr_ISP_TPIDf_GET BCM53115_A0_DTAG_TPIDr_ISP_TPIDf_GET
#define DTAG_TPIDr_ISP_TPIDf_SET BCM53115_A0_DTAG_TPIDr_ISP_TPIDf_SET
#define READ_DTAG_TPIDr BCM53115_A0_READ_DTAG_TPIDr
#define WRITE_DTAG_TPIDr BCM53115_A0_WRITE_DTAG_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DTAG_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  DUPSTS
 * BLOCKS:   SYS
 * DESC:     Duplex status Summary Register
 * SIZE:     16
 * FIELDS:
 *     DUP_STS          Duplex State.16 bit field indicating the half/full duplex state for each 10/100/1000BASE-T port.(bits 0-7 = 10/100/1000BASE-T ports).0 = Half Duplex.1 = Full Duplex.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_DUPSTSr 0x00000108

#define BCM53115_A0_DUPSTSr_SIZE 2

/*
 * This structure should be used to declare and program DUPSTS.
 *
 */
typedef union BCM53115_A0_DUPSTSr_s {
	uint32_t v[1];
	uint32_t dupsts[1];
	uint32_t _dupsts;
} BCM53115_A0_DUPSTSr_t;

#define BCM53115_A0_DUPSTSr_CLR(r) (r).dupsts[0] = 0
#define BCM53115_A0_DUPSTSr_SET(r,d) (r).dupsts[0] = d
#define BCM53115_A0_DUPSTSr_GET(r) (r).dupsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_DUPSTSr_DUP_STSf_GET(r) (((r).dupsts[0]) & 0x1ff)
#define BCM53115_A0_DUPSTSr_DUP_STSf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_DUPSTSr_RESERVED_Rf_GET(r) ((((r).dupsts[0]) >> 9) & 0x7f)
#define BCM53115_A0_DUPSTSr_RESERVED_Rf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DUPSTS.
 *
 */
#define BCM53115_A0_READ_DUPSTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_DUPSTSr,(r._dupsts),2)
#define BCM53115_A0_WRITE_DUPSTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_DUPSTSr,&(r._dupsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DUPSTSr BCM53115_A0_DUPSTSr
#define DUPSTSr_SIZE BCM53115_A0_DUPSTSr_SIZE
typedef BCM53115_A0_DUPSTSr_t DUPSTSr_t;
#define DUPSTSr_CLR BCM53115_A0_DUPSTSr_CLR
#define DUPSTSr_SET BCM53115_A0_DUPSTSr_SET
#define DUPSTSr_GET BCM53115_A0_DUPSTSr_GET
#define DUPSTSr_DUP_STSf_GET BCM53115_A0_DUPSTSr_DUP_STSf_GET
#define DUPSTSr_DUP_STSf_SET BCM53115_A0_DUPSTSr_DUP_STSf_SET
#define DUPSTSr_RESERVED_Rf_GET BCM53115_A0_DUPSTSr_RESERVED_Rf_GET
#define DUPSTSr_RESERVED_Rf_SET BCM53115_A0_DUPSTSr_RESERVED_Rf_SET
#define READ_DUPSTSr BCM53115_A0_READ_DUPSTSr
#define WRITE_DUPSTSr BCM53115_A0_WRITE_DUPSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_DUPSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EAP_DIP
 * BLOCKS:   SYS
 * DESC:     EAP Destination IP Registers
 * SIZE:     64
 * FIELDS:
 *     DIP_MASK_REG     
 *     DIP_SUB_REG      
 *
 ******************************************************************************/
#define BCM53115_A0_EAP_DIPr 0x00004202

#define BCM53115_A0_EAP_DIPr_SIZE 8

/*
 * This structure should be used to declare and program EAP_DIP.
 *
 */
typedef union BCM53115_A0_EAP_DIPr_s {
	uint32_t v[2];
	uint32_t eap_dip[2];
	uint32_t _eap_dip;
} BCM53115_A0_EAP_DIPr_t;

#define BCM53115_A0_EAP_DIPr_CLR(r) CDK_MEMSET(&((r)._eap_dip), 0, sizeof(BCM53115_A0_EAP_DIPr_t))
#define BCM53115_A0_EAP_DIPr_SET(r,i,d) (r).eap_dip[i] = d
#define BCM53115_A0_EAP_DIPr_GET(r,i) (r).eap_dip[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EAP_DIPr_DIP_MASK_REGf_GET(r) ((r).eap_dip[0])
#define BCM53115_A0_EAP_DIPr_DIP_MASK_REGf_SET(r,f) (r).eap_dip[0]=((uint32_t)f)
#define BCM53115_A0_EAP_DIPr_DIP_SUB_REGf_GET(r) ((r).eap_dip[1])
#define BCM53115_A0_EAP_DIPr_DIP_SUB_REGf_SET(r,f) (r).eap_dip[1]=((uint32_t)f)

/*
 * These macros can be used to access EAP_DIP.
 *
 */
#define BCM53115_A0_READ_EAP_DIPr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_EAP_DIPr+(8*(i)),(r._eap_dip),8)
#define BCM53115_A0_WRITE_EAP_DIPr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_EAP_DIPr+(8*(i)),&(r._eap_dip),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_DIPr BCM53115_A0_EAP_DIPr
#define EAP_DIPr_SIZE BCM53115_A0_EAP_DIPr_SIZE
typedef BCM53115_A0_EAP_DIPr_t EAP_DIPr_t;
#define EAP_DIPr_CLR BCM53115_A0_EAP_DIPr_CLR
#define EAP_DIPr_SET BCM53115_A0_EAP_DIPr_SET
#define EAP_DIPr_GET BCM53115_A0_EAP_DIPr_GET
#define EAP_DIPr_DIP_MASK_REGf_GET BCM53115_A0_EAP_DIPr_DIP_MASK_REGf_GET
#define EAP_DIPr_DIP_MASK_REGf_SET BCM53115_A0_EAP_DIPr_DIP_MASK_REGf_SET
#define EAP_DIPr_DIP_SUB_REGf_GET BCM53115_A0_EAP_DIPr_DIP_SUB_REGf_GET
#define EAP_DIPr_DIP_SUB_REGf_SET BCM53115_A0_EAP_DIPr_DIP_SUB_REGf_SET
#define READ_EAP_DIPr BCM53115_A0_READ_EAP_DIPr
#define WRITE_EAP_DIPr BCM53115_A0_WRITE_EAP_DIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EAP_DIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EAP_GLO_CON
 * BLOCKS:   SYS
 * DESC:     EAP Global Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     EN_SPEC_SPK      When EAP_BLK_MODE is set, special frame type are allowed to pass:BPDU frame,DA : 01-80-C2-00-00-02(04-0F)2 multi-port DA
 *     EN_2_DIP         when EAP_BLK_MODE is set, 2 destination IP defined in EAP_DIP0_MASK & EAP_DIP1_MASK are allowed to pass.
 *     EN_ARP           
 *     EN_DHCP          
 *     EN_RMC           When EAP_BLK_MODE is set,1'b1 : allow DA = 01-80-C2-00-00-02, 04-0F to pass1'b0 : drop DA = 01-80-C2-00-00-02, 04-0F
 *     EN_BPDU          When EAP_BLK_MODE is set,1'b1 : allow BPDU to pass1'b0 : drop BPDU
 *     EN_RARP          1'b1: allow RARP to pass1'b0: drop RARP
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_EAP_GLO_CONr 0x00004200

#define BCM53115_A0_EAP_GLO_CONr_SIZE 1

/*
 * This structure should be used to declare and program EAP_GLO_CON.
 *
 */
typedef union BCM53115_A0_EAP_GLO_CONr_s {
	uint32_t v[1];
	uint32_t eap_glo_con[1];
	uint32_t _eap_glo_con;
} BCM53115_A0_EAP_GLO_CONr_t;

#define BCM53115_A0_EAP_GLO_CONr_CLR(r) (r).eap_glo_con[0] = 0
#define BCM53115_A0_EAP_GLO_CONr_SET(r,d) (r).eap_glo_con[0] = d
#define BCM53115_A0_EAP_GLO_CONr_GET(r) (r).eap_glo_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EAP_GLO_CONr_EN_SPEC_SPKf_GET(r) (((r).eap_glo_con[0]) & 0x1)
#define BCM53115_A0_EAP_GLO_CONr_EN_SPEC_SPKf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_EAP_GLO_CONr_EN_2_DIPf_GET(r) ((((r).eap_glo_con[0]) >> 1) & 0x1)
#define BCM53115_A0_EAP_GLO_CONr_EN_2_DIPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_EAP_GLO_CONr_EN_ARPf_GET(r) ((((r).eap_glo_con[0]) >> 2) & 0x1)
#define BCM53115_A0_EAP_GLO_CONr_EN_ARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_EAP_GLO_CONr_EN_DHCPf_GET(r) ((((r).eap_glo_con[0]) >> 3) & 0x1)
#define BCM53115_A0_EAP_GLO_CONr_EN_DHCPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_EAP_GLO_CONr_EN_RMCf_GET(r) ((((r).eap_glo_con[0]) >> 4) & 0x1)
#define BCM53115_A0_EAP_GLO_CONr_EN_RMCf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_EAP_GLO_CONr_EN_BPDUf_GET(r) ((((r).eap_glo_con[0]) >> 5) & 0x1)
#define BCM53115_A0_EAP_GLO_CONr_EN_BPDUf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_EAP_GLO_CONr_EN_RARPf_GET(r) ((((r).eap_glo_con[0]) >> 6) & 0x1)
#define BCM53115_A0_EAP_GLO_CONr_EN_RARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_EAP_GLO_CONr_RESERVED_Rf_GET(r) ((((r).eap_glo_con[0]) >> 7) & 0x1)
#define BCM53115_A0_EAP_GLO_CONr_RESERVED_Rf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access EAP_GLO_CON.
 *
 */
#define BCM53115_A0_READ_EAP_GLO_CONr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EAP_GLO_CONr,(r._eap_glo_con),1)
#define BCM53115_A0_WRITE_EAP_GLO_CONr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EAP_GLO_CONr,&(r._eap_glo_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_GLO_CONr BCM53115_A0_EAP_GLO_CONr
#define EAP_GLO_CONr_SIZE BCM53115_A0_EAP_GLO_CONr_SIZE
typedef BCM53115_A0_EAP_GLO_CONr_t EAP_GLO_CONr_t;
#define EAP_GLO_CONr_CLR BCM53115_A0_EAP_GLO_CONr_CLR
#define EAP_GLO_CONr_SET BCM53115_A0_EAP_GLO_CONr_SET
#define EAP_GLO_CONr_GET BCM53115_A0_EAP_GLO_CONr_GET
#define EAP_GLO_CONr_EN_SPEC_SPKf_GET BCM53115_A0_EAP_GLO_CONr_EN_SPEC_SPKf_GET
#define EAP_GLO_CONr_EN_SPEC_SPKf_SET BCM53115_A0_EAP_GLO_CONr_EN_SPEC_SPKf_SET
#define EAP_GLO_CONr_EN_2_DIPf_GET BCM53115_A0_EAP_GLO_CONr_EN_2_DIPf_GET
#define EAP_GLO_CONr_EN_2_DIPf_SET BCM53115_A0_EAP_GLO_CONr_EN_2_DIPf_SET
#define EAP_GLO_CONr_EN_ARPf_GET BCM53115_A0_EAP_GLO_CONr_EN_ARPf_GET
#define EAP_GLO_CONr_EN_ARPf_SET BCM53115_A0_EAP_GLO_CONr_EN_ARPf_SET
#define EAP_GLO_CONr_EN_DHCPf_GET BCM53115_A0_EAP_GLO_CONr_EN_DHCPf_GET
#define EAP_GLO_CONr_EN_DHCPf_SET BCM53115_A0_EAP_GLO_CONr_EN_DHCPf_SET
#define EAP_GLO_CONr_EN_RMCf_GET BCM53115_A0_EAP_GLO_CONr_EN_RMCf_GET
#define EAP_GLO_CONr_EN_RMCf_SET BCM53115_A0_EAP_GLO_CONr_EN_RMCf_SET
#define EAP_GLO_CONr_EN_BPDUf_GET BCM53115_A0_EAP_GLO_CONr_EN_BPDUf_GET
#define EAP_GLO_CONr_EN_BPDUf_SET BCM53115_A0_EAP_GLO_CONr_EN_BPDUf_SET
#define EAP_GLO_CONr_EN_RARPf_GET BCM53115_A0_EAP_GLO_CONr_EN_RARPf_GET
#define EAP_GLO_CONr_EN_RARPf_SET BCM53115_A0_EAP_GLO_CONr_EN_RARPf_SET
#define EAP_GLO_CONr_RESERVED_Rf_GET BCM53115_A0_EAP_GLO_CONr_RESERVED_Rf_GET
#define EAP_GLO_CONr_RESERVED_Rf_SET BCM53115_A0_EAP_GLO_CONr_RESERVED_Rf_SET
#define READ_EAP_GLO_CONr BCM53115_A0_READ_EAP_GLO_CONr
#define WRITE_EAP_GLO_CONr BCM53115_A0_WRITE_EAP_GLO_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EAP_GLO_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EAP_MULTI_ADDR_CTRL
 * BLOCKS:   SYS
 * DESC:     EAP Multiport Address Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_MPORT0        1'b1: allow multiport address define at Page/Offset=04/10h  to pass1'b0: drop
 *     EN_MPORT1        1'b1: allow multiport address define at Page/Offset=04/20h  to pass1'b0: drop
 *     EN_MPORT2        1'b1: allow multiport address define at Page/Offset=04/30h  to pass1'b0: drop
 *     EN_MPORT3        1'b1: allow multiport address define at Page/Offset=04/40h  to pass1'b0: drop
 *     EN_MPORT4        1'b1: allow multiport address define at Page/Offset=04/50h  to pass1'b0: drop
 *     EN_MPORT5        1'b1: allow multiport address define at Page/Offset=04/60h  to pass1'b0: drop
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr 0x00004201

#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program EAP_MULTI_ADDR_CTRL.
 *
 */
typedef union BCM53115_A0_EAP_MULTI_ADDR_CTRLr_s {
	uint32_t v[1];
	uint32_t eap_multi_addr_ctrl[1];
	uint32_t _eap_multi_addr_ctrl;
} BCM53115_A0_EAP_MULTI_ADDR_CTRLr_t;

#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_CLR(r) (r).eap_multi_addr_ctrl[0] = 0
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_SET(r,d) (r).eap_multi_addr_ctrl[0] = d
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_GET(r) (r).eap_multi_addr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET(r) (((r).eap_multi_addr_ctrl[0]) & 0x1)
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 3) & 0x1)
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 4) & 0x1)
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 5) & 0x1)
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_RESERVED_Rf_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 6) & 0x3)
#define BCM53115_A0_EAP_MULTI_ADDR_CTRLr_RESERVED_Rf_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access EAP_MULTI_ADDR_CTRL.
 *
 */
#define BCM53115_A0_READ_EAP_MULTI_ADDR_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EAP_MULTI_ADDR_CTRLr,(r._eap_multi_addr_ctrl),1)
#define BCM53115_A0_WRITE_EAP_MULTI_ADDR_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EAP_MULTI_ADDR_CTRLr,&(r._eap_multi_addr_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_MULTI_ADDR_CTRLr BCM53115_A0_EAP_MULTI_ADDR_CTRLr
#define EAP_MULTI_ADDR_CTRLr_SIZE BCM53115_A0_EAP_MULTI_ADDR_CTRLr_SIZE
typedef BCM53115_A0_EAP_MULTI_ADDR_CTRLr_t EAP_MULTI_ADDR_CTRLr_t;
#define EAP_MULTI_ADDR_CTRLr_CLR BCM53115_A0_EAP_MULTI_ADDR_CTRLr_CLR
#define EAP_MULTI_ADDR_CTRLr_SET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_SET
#define EAP_MULTI_ADDR_CTRLr_GET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET
#define EAP_MULTI_ADDR_CTRLr_RESERVED_Rf_GET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_RESERVED_Rf_GET
#define EAP_MULTI_ADDR_CTRLr_RESERVED_Rf_SET BCM53115_A0_EAP_MULTI_ADDR_CTRLr_RESERVED_Rf_SET
#define READ_EAP_MULTI_ADDR_CTRLr BCM53115_A0_READ_EAP_MULTI_ADDR_CTRLr
#define WRITE_EAP_MULTI_ADDR_CTRLr BCM53115_A0_WRITE_EAP_MULTI_ADDR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EAP_MULTI_ADDR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EAV_LNK_STATUS
 * BLOCKS:   SYS
 * DESC:     ResE Port EAV Link Status Register
 * SIZE:     16
 * FIELDS:
 *     PT_EAV_LNK_STATUS 
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_EAV_LNK_STATUSr 0x000090b0

#define BCM53115_A0_EAV_LNK_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program EAV_LNK_STATUS.
 *
 */
typedef union BCM53115_A0_EAV_LNK_STATUSr_s {
	uint32_t v[1];
	uint32_t eav_lnk_status[1];
	uint32_t _eav_lnk_status;
} BCM53115_A0_EAV_LNK_STATUSr_t;

#define BCM53115_A0_EAV_LNK_STATUSr_CLR(r) (r).eav_lnk_status[0] = 0
#define BCM53115_A0_EAV_LNK_STATUSr_SET(r,d) (r).eav_lnk_status[0] = d
#define BCM53115_A0_EAV_LNK_STATUSr_GET(r) (r).eav_lnk_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET(r) (((r).eav_lnk_status[0]) & 0x1f)
#define BCM53115_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET(r,f) (r).eav_lnk_status[0]=(((r).eav_lnk_status[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_EAV_LNK_STATUSr_RESERVED_Rf_GET(r) ((((r).eav_lnk_status[0]) >> 5) & 0x7ff)
#define BCM53115_A0_EAV_LNK_STATUSr_RESERVED_Rf_SET(r,f) (r).eav_lnk_status[0]=(((r).eav_lnk_status[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))

/*
 * These macros can be used to access EAV_LNK_STATUS.
 *
 */
#define BCM53115_A0_READ_EAV_LNK_STATUSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EAV_LNK_STATUSr,(r._eav_lnk_status),2)
#define BCM53115_A0_WRITE_EAV_LNK_STATUSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EAV_LNK_STATUSr,&(r._eav_lnk_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAV_LNK_STATUSr BCM53115_A0_EAV_LNK_STATUSr
#define EAV_LNK_STATUSr_SIZE BCM53115_A0_EAV_LNK_STATUSr_SIZE
typedef BCM53115_A0_EAV_LNK_STATUSr_t EAV_LNK_STATUSr_t;
#define EAV_LNK_STATUSr_CLR BCM53115_A0_EAV_LNK_STATUSr_CLR
#define EAV_LNK_STATUSr_SET BCM53115_A0_EAV_LNK_STATUSr_SET
#define EAV_LNK_STATUSr_GET BCM53115_A0_EAV_LNK_STATUSr_GET
#define EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET BCM53115_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET
#define EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET BCM53115_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET
#define EAV_LNK_STATUSr_RESERVED_Rf_GET BCM53115_A0_EAV_LNK_STATUSr_RESERVED_Rf_GET
#define EAV_LNK_STATUSr_RESERVED_Rf_SET BCM53115_A0_EAV_LNK_STATUSr_RESERVED_Rf_SET
#define READ_EAV_LNK_STATUSr BCM53115_A0_READ_EAV_LNK_STATUSr
#define WRITE_EAV_LNK_STATUSr BCM53115_A0_WRITE_EAV_LNK_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EAV_LNK_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_MSK      Egress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIRROR_CAPTURE_PORT.Bits 0-5 = Port0-5Bit 8= IMP.
 *     RESERVED_R       Reserved
 *     OUT_DIV_EN       Egress Divider Enable.Mirror every nth transmitted frame (n=OUT_MIRROR_DIV) that has passed through the OUT_MIRROR_FILTER.
 *     OUT_MIR_FLTR     Egress Mirror Filter.Defines the conditions under which frames transmitted on a port that has been selected in the OUT_MRROR_MASK[10:0], will be compared in orderto determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all egress frames.01: Mirror all transmitted frames with DA = IN_MIROR_MAC.10: Mirror all transmitted frames with SA = IN_MIRROR_MAC.11: Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_EGMIRCTLr 0x0000021c

#define BCM53115_A0_EGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRCTL.
 *
 */
typedef union BCM53115_A0_EGMIRCTLr_s {
	uint32_t v[1];
	uint32_t egmirctl[1];
	uint32_t _egmirctl;
} BCM53115_A0_EGMIRCTLr_t;

#define BCM53115_A0_EGMIRCTLr_CLR(r) (r).egmirctl[0] = 0
#define BCM53115_A0_EGMIRCTLr_SET(r,d) (r).egmirctl[0] = d
#define BCM53115_A0_EGMIRCTLr_GET(r) (r).egmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EGMIRCTLr_OUT_MIR_MSKf_GET(r) (((r).egmirctl[0]) & 0x1ff)
#define BCM53115_A0_EGMIRCTLr_OUT_MIR_MSKf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_EGMIRCTLr_RESERVED_Rf_GET(r) ((((r).egmirctl[0]) >> 9) & 0xf)
#define BCM53115_A0_EGMIRCTLr_RESERVED_Rf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53115_A0_EGMIRCTLr_OUT_DIV_ENf_GET(r) ((((r).egmirctl[0]) >> 13) & 0x1)
#define BCM53115_A0_EGMIRCTLr_OUT_DIV_ENf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET(r) ((((r).egmirctl[0]) >> 14) & 0x3)
#define BCM53115_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access EGMIRCTL.
 *
 */
#define BCM53115_A0_READ_EGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EGMIRCTLr,(r._egmirctl),2)
#define BCM53115_A0_WRITE_EGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EGMIRCTLr,&(r._egmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRCTLr BCM53115_A0_EGMIRCTLr
#define EGMIRCTLr_SIZE BCM53115_A0_EGMIRCTLr_SIZE
typedef BCM53115_A0_EGMIRCTLr_t EGMIRCTLr_t;
#define EGMIRCTLr_CLR BCM53115_A0_EGMIRCTLr_CLR
#define EGMIRCTLr_SET BCM53115_A0_EGMIRCTLr_SET
#define EGMIRCTLr_GET BCM53115_A0_EGMIRCTLr_GET
#define EGMIRCTLr_OUT_MIR_MSKf_GET BCM53115_A0_EGMIRCTLr_OUT_MIR_MSKf_GET
#define EGMIRCTLr_OUT_MIR_MSKf_SET BCM53115_A0_EGMIRCTLr_OUT_MIR_MSKf_SET
#define EGMIRCTLr_RESERVED_Rf_GET BCM53115_A0_EGMIRCTLr_RESERVED_Rf_GET
#define EGMIRCTLr_RESERVED_Rf_SET BCM53115_A0_EGMIRCTLr_RESERVED_Rf_SET
#define EGMIRCTLr_OUT_DIV_ENf_GET BCM53115_A0_EGMIRCTLr_OUT_DIV_ENf_GET
#define EGMIRCTLr_OUT_DIV_ENf_SET BCM53115_A0_EGMIRCTLr_OUT_DIV_ENf_SET
#define EGMIRCTLr_OUT_MIR_FLTRf_GET BCM53115_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET
#define EGMIRCTLr_OUT_MIR_FLTRf_SET BCM53115_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET
#define READ_EGMIRCTLr BCM53115_A0_READ_EGMIRCTLr
#define WRITE_EGMIRCTLr BCM53115_A0_WRITE_EGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_DIV      Egress Mirror Divider.Transmit frames that have passed the OUT_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the OUT_DIV_EN bit in the Egress Mirror Control register is set, frames that pass the OUT_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = OUT_MIRROR_DIV) will be mirrored.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_EGMIRDIVr 0x0000021e

#define BCM53115_A0_EGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRDIV.
 *
 */
typedef union BCM53115_A0_EGMIRDIVr_s {
	uint32_t v[1];
	uint32_t egmirdiv[1];
	uint32_t _egmirdiv;
} BCM53115_A0_EGMIRDIVr_t;

#define BCM53115_A0_EGMIRDIVr_CLR(r) (r).egmirdiv[0] = 0
#define BCM53115_A0_EGMIRDIVr_SET(r,d) (r).egmirdiv[0] = d
#define BCM53115_A0_EGMIRDIVr_GET(r) (r).egmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EGMIRDIVr_OUT_MIR_DIVf_GET(r) (((r).egmirdiv[0]) & 0x3ff)
#define BCM53115_A0_EGMIRDIVr_OUT_MIR_DIVf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_EGMIRDIVr_RESERVED_Rf_GET(r) ((((r).egmirdiv[0]) >> 10) & 0x3f)
#define BCM53115_A0_EGMIRDIVr_RESERVED_Rf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access EGMIRDIV.
 *
 */
#define BCM53115_A0_READ_EGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EGMIRDIVr,(r._egmirdiv),2)
#define BCM53115_A0_WRITE_EGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EGMIRDIVr,&(r._egmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRDIVr BCM53115_A0_EGMIRDIVr
#define EGMIRDIVr_SIZE BCM53115_A0_EGMIRDIVr_SIZE
typedef BCM53115_A0_EGMIRDIVr_t EGMIRDIVr_t;
#define EGMIRDIVr_CLR BCM53115_A0_EGMIRDIVr_CLR
#define EGMIRDIVr_SET BCM53115_A0_EGMIRDIVr_SET
#define EGMIRDIVr_GET BCM53115_A0_EGMIRDIVr_GET
#define EGMIRDIVr_OUT_MIR_DIVf_GET BCM53115_A0_EGMIRDIVr_OUT_MIR_DIVf_GET
#define EGMIRDIVr_OUT_MIR_DIVf_SET BCM53115_A0_EGMIRDIVr_OUT_MIR_DIVf_SET
#define EGMIRDIVr_RESERVED_Rf_GET BCM53115_A0_EGMIRDIVr_RESERVED_Rf_GET
#define EGMIRDIVr_RESERVED_Rf_SET BCM53115_A0_EGMIRDIVr_RESERVED_Rf_SET
#define READ_EGMIRDIVr BCM53115_A0_READ_EGMIRDIVr
#define WRITE_EGMIRDIVr BCM53115_A0_WRITE_EGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Egress Mirror MAC Address Register
 * SIZE:     48
 * FIELDS:
 *     OUT_MIR_MAC      Egress Mirror MAC Address.MAC address that will be compared against engress frames in accordance with the OUT_MIRROR_FILTER rules.
 *
 ******************************************************************************/
#define BCM53115_A0_EGMIRMACr 0x00000220

#define BCM53115_A0_EGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program EGMIRMAC.
 *
 */
typedef union BCM53115_A0_EGMIRMACr_s {
	uint32_t v[2];
	uint32_t egmirmac[2];
	uint32_t _egmirmac;
} BCM53115_A0_EGMIRMACr_t;

#define BCM53115_A0_EGMIRMACr_CLR(r) CDK_MEMSET(&((r)._egmirmac), 0, sizeof(BCM53115_A0_EGMIRMACr_t))
#define BCM53115_A0_EGMIRMACr_SET(r,i,d) (r).egmirmac[i] = d
#define BCM53115_A0_EGMIRMACr_GET(r,i) (r).egmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EGMIRMACr_OUT_MIR_MACf_GET(r,a) cdk_field_get((r).egmirmac,0,47,a)
#define BCM53115_A0_EGMIRMACr_OUT_MIR_MACf_SET(r,a) cdk_field_set((r).egmirmac,0,47,a)

/*
 * These macros can be used to access EGMIRMAC.
 *
 */
#define BCM53115_A0_READ_EGMIRMACr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EGMIRMACr,(r._egmirmac),6)
#define BCM53115_A0_WRITE_EGMIRMACr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EGMIRMACr,&(r._egmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRMACr BCM53115_A0_EGMIRMACr
#define EGMIRMACr_SIZE BCM53115_A0_EGMIRMACr_SIZE
typedef BCM53115_A0_EGMIRMACr_t EGMIRMACr_t;
#define EGMIRMACr_CLR BCM53115_A0_EGMIRMACr_CLR
#define EGMIRMACr_SET BCM53115_A0_EGMIRMACr_SET
#define EGMIRMACr_GET BCM53115_A0_EGMIRMACr_GET
#define EGMIRMACr_OUT_MIR_MACf_GET BCM53115_A0_EGMIRMACr_OUT_MIR_MACf_GET
#define EGMIRMACr_OUT_MIR_MACf_SET BCM53115_A0_EGMIRMACr_OUT_MIR_MACf_SET
#define READ_EGMIRMACr BCM53115_A0_READ_EGMIRMACr
#define WRITE_EGMIRMACr BCM53115_A0_WRITE_EGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EGRESS_NRESE_PKT_TC2PCP_MAP
 * BLOCKS:   CPIC GPIC0
 * DESC:     Egress Non-ResE Packet TC to PCP mapping Register
 * SIZE:     64
 * FIELDS:
 *     PCP_FOR_RV0_TC0  PCP for RV0_TC0
 *     PCP_FOR_RV0_TC1  PCP for RV0_TC1
 *     PCP_FOR_RV0_TC2  PCP for RV0_TC2
 *     PCP_FOR_RV0_TC3  PCP for RV0_TC3
 *     PCP_FOR_RV0_TC4  PCP for RV0_TC4
 *     PCP_FOR_RV0_TC5  PCP for RV0_TC5
 *     PCP_FOR_RV0_TC6  PCP for RV0_TC6
 *     PCP_FOR_RV0_TC7  PCP for RV0_TC7
 *     PCP_FOR_RV1_TC0  PCP for RV1_TC0
 *     PCP_FOR_RV1_TC1  PCP for RV1_TC1
 *     PCP_FOR_RV1_TC2  PCP for RV1_TC2
 *     PCP_FOR_RV1_TC3  PCP for RV1_TC3
 *     PCP_FOR_RV1_TC4  PCP for RV1_TC4
 *     PCP_FOR_RV1_TC5  PCP for RV1_TC5
 *     PCP_FOR_RV1_TC6  PCP for RV1_TC6
 *     PCP_FOR_RV1_TC7  PCP for RV1_TC7
 *
 ******************************************************************************/
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr 0x00009110

#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_SIZE 8

/*
 * This structure should be used to declare and program EGRESS_NRESE_PKT_TC2PCP_MAP.
 *
 */
typedef union BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_s {
	uint32_t v[2];
	uint32_t egress_nrese_pkt_tc2pcp_map[2];
	uint32_t _egress_nrese_pkt_tc2pcp_map;
} BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_t;

#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_CLR(r) CDK_MEMSET(&((r)._egress_nrese_pkt_tc2pcp_map), 0, sizeof(BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_t))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_SET(r,i,d) (r).egress_nrese_pkt_tc2pcp_map[i] = d
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_GET(r,i) (r).egress_nrese_pkt_tc2pcp_map[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET(r) (((r).egress_nrese_pkt_tc2pcp_map[0]) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 4) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 8) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 12) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 16) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 20) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 24) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 28) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_GET(r) (((r).egress_nrese_pkt_tc2pcp_map[1]) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=(((r).egress_nrese_pkt_tc2pcp_map[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[1]) >> 4) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=(((r).egress_nrese_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[1]) >> 8) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=(((r).egress_nrese_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[1]) >> 12) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=(((r).egress_nrese_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[1]) >> 16) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=(((r).egress_nrese_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[1]) >> 20) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=(((r).egress_nrese_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[1]) >> 24) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=(((r).egress_nrese_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[1]) >> 28) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=(((r).egress_nrese_pkt_tc2pcp_map[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access EGRESS_NRESE_PKT_TC2PCP_MAP.
 *
 */
#define BCM53115_A0_READ_EGRESS_NRESE_PKT_TC2PCP_MAPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr,(r._egress_nrese_pkt_tc2pcp_map),8)
#define BCM53115_A0_WRITE_EGRESS_NRESE_PKT_TC2PCP_MAPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr,&(r._egress_nrese_pkt_tc2pcp_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_NRESE_PKT_TC2PCP_MAPr BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_SIZE BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_SIZE
typedef BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_t EGRESS_NRESE_PKT_TC2PCP_MAPr_t;
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_CLR BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_CLR
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC0f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC1f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC2f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC3f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC4f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC5f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC6f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV1_TC7f_SET
#define READ_EGRESS_NRESE_PKT_TC2PCP_MAPr BCM53115_A0_READ_EGRESS_NRESE_PKT_TC2PCP_MAPr
#define WRITE_EGRESS_NRESE_PKT_TC2PCP_MAPr BCM53115_A0_WRITE_EGRESS_NRESE_PKT_TC2PCP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EGRESS_NRESE_PKT_TC2PCP_MAP_IMP
 * BLOCKS:   SYS
 * DESC:     Egress Non-ResE Packet TC to PCP mapping Register for port8
 * SIZE:     64
 * FIELDS:
 *     PCP_FOR_RV0_TC0  PCP for RV0_TC0
 *     PCP_FOR_RV0_TC1  PCP for RV0_TC1
 *     PCP_FOR_RV0_TC2  PCP for RV0_TC2
 *     PCP_FOR_RV0_TC3  PCP for RV0_TC3
 *     PCP_FOR_RV0_TC4  PCP for RV0_TC4
 *     PCP_FOR_RV0_TC5  PCP for RV0_TC5
 *     PCP_FOR_RV0_TC6  PCP for RV0_TC6
 *     PCP_FOR_RV0_TC7  PCP for RV0_TC7
 *     PCP_FOR_RV1_TC0  PCP for RV1_TC0
 *     PCP_FOR_RV1_TC1  PCP for RV1_TC1
 *     PCP_FOR_RV1_TC2  PCP for RV1_TC2
 *     PCP_FOR_RV1_TC3  PCP for RV1_TC3
 *     PCP_FOR_RV1_TC4  PCP for RV1_TC4
 *     PCP_FOR_RV1_TC5  PCP for RV1_TC5
 *     PCP_FOR_RV1_TC6  PCP for RV1_TC6
 *     PCP_FOR_RV1_TC7  PCP for RV1_TC7
 *
 ******************************************************************************/
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr 0x00009150

#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SIZE 8

/*
 * This structure should be used to declare and program EGRESS_NRESE_PKT_TC2PCP_MAP_IMP.
 *
 */
typedef union BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_s {
	uint32_t v[2];
	uint32_t egress_nrese_pkt_tc2pcp_map_imp[2];
	uint32_t _egress_nrese_pkt_tc2pcp_map_imp;
} BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_t;

#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_CLR(r) CDK_MEMSET(&((r)._egress_nrese_pkt_tc2pcp_map_imp), 0, sizeof(BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_t))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SET(r,i,d) (r).egress_nrese_pkt_tc2pcp_map_imp[i] = d
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_GET(r,i) (r).egress_nrese_pkt_tc2pcp_map_imp[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET(r) (((r).egress_nrese_pkt_tc2pcp_map_imp[0]) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 4) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 8) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 12) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 16) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 20) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 24) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 28) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_GET(r) (((r).egress_nrese_pkt_tc2pcp_map_imp[1]) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=(((r).egress_nrese_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[1]) >> 4) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=(((r).egress_nrese_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[1]) >> 8) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=(((r).egress_nrese_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[1]) >> 12) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=(((r).egress_nrese_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[1]) >> 16) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=(((r).egress_nrese_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[1]) >> 20) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=(((r).egress_nrese_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[1]) >> 24) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=(((r).egress_nrese_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[1]) >> 28) & 0xf)
#define BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=(((r).egress_nrese_pkt_tc2pcp_map_imp[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access EGRESS_NRESE_PKT_TC2PCP_MAP_IMP.
 *
 */
#define BCM53115_A0_READ_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr,(r._egress_nrese_pkt_tc2pcp_map_imp),8)
#define BCM53115_A0_WRITE_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr,&(r._egress_nrese_pkt_tc2pcp_map_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SIZE BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SIZE
typedef BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_t EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_t;
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_CLR BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_CLR
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC0f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC1f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC2f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC3f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC4f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC5f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC6f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_GET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_SET BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV1_TC7f_SET
#define READ_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr BCM53115_A0_READ_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr
#define WRITE_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr BCM53115_A0_WRITE_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  EGRESS_VID_REMARK
 * BLOCKS:   SYS
 * DESC:     Egress VID Remark table(Per port(0,1,2,3,4,5,cpu) 255 entries)
 * SIZE:     32
 * FIELDS:
 *     INNER_VID        Inner VID for modification
 *     INNER_OP         Inner Tag Operation,b00: as isb01: as receivedb10: removedb11: VID remarking
 *     RESERVED_1R      Reserved
 *     OUTER_VID        Outer VID for modification
 *     OUTER_OP         Outer Tag Operation,b00: as isb01: as receivedb10: removedb11: VID remarking
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_EGRESS_VID_REMARKm 0x00003200

#define BCM53115_A0_EGRESS_VID_REMARKm_MIN 0
#define BCM53115_A0_EGRESS_VID_REMARKm_MAX 1791
#define BCM53115_A0_EGRESS_VID_REMARKm_CMAX(u) 1791
#define BCM53115_A0_EGRESS_VID_REMARKm_SIZE 4

/*
 * This structure should be used to declare and program EGRESS_VID_REMARK.
 *
 */
typedef union BCM53115_A0_EGRESS_VID_REMARKm_s {
	uint32_t v[1];
	uint32_t egress_vid_remark[1];
	uint32_t _egress_vid_remark;
} BCM53115_A0_EGRESS_VID_REMARKm_t;

#define BCM53115_A0_EGRESS_VID_REMARKm_CLR(r) (r).egress_vid_remark[0] = 0
#define BCM53115_A0_EGRESS_VID_REMARKm_SET(r,d) (r).egress_vid_remark[0] = d
#define BCM53115_A0_EGRESS_VID_REMARKm_GET(r) (r).egress_vid_remark[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EGRESS_VID_REMARKm_INNER_VIDf_GET(r) (((r).egress_vid_remark[0]) & 0xfff)
#define BCM53115_A0_EGRESS_VID_REMARKm_INNER_VIDf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_EGRESS_VID_REMARKm_INNER_OPf_GET(r) ((((r).egress_vid_remark[0]) >> 12) & 0x3)
#define BCM53115_A0_EGRESS_VID_REMARKm_INNER_OPf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53115_A0_EGRESS_VID_REMARKm_RESERVED_1Rf_GET(r) ((((r).egress_vid_remark[0]) >> 14) & 0x3)
#define BCM53115_A0_EGRESS_VID_REMARKm_RESERVED_1Rf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53115_A0_EGRESS_VID_REMARKm_OUTER_VIDf_GET(r) ((((r).egress_vid_remark[0]) >> 16) & 0xfff)
#define BCM53115_A0_EGRESS_VID_REMARKm_OUTER_VIDf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_EGRESS_VID_REMARKm_OUTER_OPf_GET(r) ((((r).egress_vid_remark[0]) >> 28) & 0x3)
#define BCM53115_A0_EGRESS_VID_REMARKm_OUTER_OPf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53115_A0_EGRESS_VID_REMARKm_RESERVED_2Rf_GET(r) ((((r).egress_vid_remark[0]) >> 30) & 0x3)
#define BCM53115_A0_EGRESS_VID_REMARKm_RESERVED_2Rf_SET(r,f) (r).egress_vid_remark[0]=(((r).egress_vid_remark[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access EGRESS_VID_REMARK.
 *
 */
#define BCM53115_A0_READ_EGRESS_VID_REMARKm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_EGRESS_VID_REMARKm,i,(m),4)
#define BCM53115_A0_WRITE_EGRESS_VID_REMARKm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_EGRESS_VID_REMARKm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_VID_REMARKm BCM53115_A0_EGRESS_VID_REMARKm
#define EGRESS_VID_REMARKm_MIN BCM53115_A0_EGRESS_VID_REMARKm_MIN
#define EGRESS_VID_REMARKm_MAX BCM53115_A0_EGRESS_VID_REMARKm_MAX
#define EGRESS_VID_REMARKm_CMAX(u) BCM53115_A0_EGRESS_VID_REMARKm_CMAX(u)
#define EGRESS_VID_REMARKm_SIZE BCM53115_A0_EGRESS_VID_REMARKm_SIZE
typedef BCM53115_A0_EGRESS_VID_REMARKm_t EGRESS_VID_REMARKm_t;
#define EGRESS_VID_REMARKm_CLR BCM53115_A0_EGRESS_VID_REMARKm_CLR
#define EGRESS_VID_REMARKm_SET BCM53115_A0_EGRESS_VID_REMARKm_SET
#define EGRESS_VID_REMARKm_GET BCM53115_A0_EGRESS_VID_REMARKm_GET
#define EGRESS_VID_REMARKm_INNER_VIDf_GET BCM53115_A0_EGRESS_VID_REMARKm_INNER_VIDf_GET
#define EGRESS_VID_REMARKm_INNER_VIDf_SET BCM53115_A0_EGRESS_VID_REMARKm_INNER_VIDf_SET
#define EGRESS_VID_REMARKm_INNER_OPf_GET BCM53115_A0_EGRESS_VID_REMARKm_INNER_OPf_GET
#define EGRESS_VID_REMARKm_INNER_OPf_SET BCM53115_A0_EGRESS_VID_REMARKm_INNER_OPf_SET
#define EGRESS_VID_REMARKm_RESERVED_1Rf_GET BCM53115_A0_EGRESS_VID_REMARKm_RESERVED_1Rf_GET
#define EGRESS_VID_REMARKm_RESERVED_1Rf_SET BCM53115_A0_EGRESS_VID_REMARKm_RESERVED_1Rf_SET
#define EGRESS_VID_REMARKm_OUTER_VIDf_GET BCM53115_A0_EGRESS_VID_REMARKm_OUTER_VIDf_GET
#define EGRESS_VID_REMARKm_OUTER_VIDf_SET BCM53115_A0_EGRESS_VID_REMARKm_OUTER_VIDf_SET
#define EGRESS_VID_REMARKm_OUTER_OPf_GET BCM53115_A0_EGRESS_VID_REMARKm_OUTER_OPf_GET
#define EGRESS_VID_REMARKm_OUTER_OPf_SET BCM53115_A0_EGRESS_VID_REMARKm_OUTER_OPf_SET
#define EGRESS_VID_REMARKm_RESERVED_2Rf_GET BCM53115_A0_EGRESS_VID_REMARKm_RESERVED_2Rf_GET
#define EGRESS_VID_REMARKm_RESERVED_2Rf_SET BCM53115_A0_EGRESS_VID_REMARKm_RESERVED_2Rf_SET
#define READ_EGRESS_VID_REMARKm BCM53115_A0_READ_EGRESS_VID_REMARKm
#define WRITE_EGRESS_VID_REMARKm BCM53115_A0_WRITE_EGRESS_VID_REMARKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EGRESS_VID_REMARKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EGRESS_VID_RMK_TBL_ACS
 * BLOCKS:   SYS
 * DESC:     Egress VID Remarking Table Access Register
 * SIZE:     32
 * FIELDS:
 *     START_DONE       
 *     OP               
 *     RESET_EVT        Reserved.
 *     RESERVED2_R      Reserved.
 *     EGRESS_PORT_R    
 *     TBL_ADDR         
 *     RESERVED1_R      Reserved.
 *     GLOBAL_WR_EN     
 *
 ******************************************************************************/
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr 0x00003440

#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_SIZE 4

/*
 * This structure should be used to declare and program EGRESS_VID_RMK_TBL_ACS.
 *
 */
typedef union BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_s {
	uint32_t v[1];
	uint32_t egress_vid_rmk_tbl_acs[1];
	uint32_t _egress_vid_rmk_tbl_acs;
} BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_t;

#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_CLR(r) (r).egress_vid_rmk_tbl_acs[0] = 0
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_SET(r,d) (r).egress_vid_rmk_tbl_acs[0] = d
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_GET(r) (r).egress_vid_rmk_tbl_acs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_START_DONEf_GET(r) (((r).egress_vid_rmk_tbl_acs[0]) & 0x1)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_START_DONEf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_OPf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 1) & 0x1)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_OPf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 2) & 0x1)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED2_Rf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 3) & 0x1)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED2_Rf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORT_Rf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 4) & 0xf)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORT_Rf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 8) & 0xff)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED1_Rf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 16) & 0x7fff)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED1_Rf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_GET(r) ((((r).egress_vid_rmk_tbl_acs[0]) >> 31) & 0x1)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_SET(r,f) (r).egress_vid_rmk_tbl_acs[0]=(((r).egress_vid_rmk_tbl_acs[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access EGRESS_VID_RMK_TBL_ACS.
 *
 */
#define BCM53115_A0_READ_EGRESS_VID_RMK_TBL_ACSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr,(r._egress_vid_rmk_tbl_acs),4)
#define BCM53115_A0_WRITE_EGRESS_VID_RMK_TBL_ACSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr,&(r._egress_vid_rmk_tbl_acs),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_VID_RMK_TBL_ACSr BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr
#define EGRESS_VID_RMK_TBL_ACSr_SIZE BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_SIZE
typedef BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_t EGRESS_VID_RMK_TBL_ACSr_t;
#define EGRESS_VID_RMK_TBL_ACSr_CLR BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_CLR
#define EGRESS_VID_RMK_TBL_ACSr_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_SET
#define EGRESS_VID_RMK_TBL_ACSr_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_GET
#define EGRESS_VID_RMK_TBL_ACSr_START_DONEf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_START_DONEf_GET
#define EGRESS_VID_RMK_TBL_ACSr_START_DONEf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_START_DONEf_SET
#define EGRESS_VID_RMK_TBL_ACSr_OPf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_OPf_GET
#define EGRESS_VID_RMK_TBL_ACSr_OPf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_OPf_SET
#define EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_GET
#define EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESET_EVTf_SET
#define EGRESS_VID_RMK_TBL_ACSr_RESERVED2_Rf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED2_Rf_GET
#define EGRESS_VID_RMK_TBL_ACSr_RESERVED2_Rf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED2_Rf_SET
#define EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORT_Rf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORT_Rf_GET
#define EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORT_Rf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_EGRESS_PORT_Rf_SET
#define EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_GET
#define EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_TBL_ADDRf_SET
#define EGRESS_VID_RMK_TBL_ACSr_RESERVED1_Rf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED1_Rf_GET
#define EGRESS_VID_RMK_TBL_ACSr_RESERVED1_Rf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_RESERVED1_Rf_SET
#define EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_GET
#define EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr_GLOBAL_WR_ENf_SET
#define READ_EGRESS_VID_RMK_TBL_ACSr BCM53115_A0_READ_EGRESS_VID_RMK_TBL_ACSr
#define WRITE_EGRESS_VID_RMK_TBL_ACSr BCM53115_A0_WRITE_EGRESS_VID_RMK_TBL_ACSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EGRESS_VID_RMK_TBL_ACSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  EGRESS_VID_RMK_TBL_DATA
 * BLOCKS:   SYS
 * DESC:     Egress VID Remarking Table Data Register
 * SIZE:     32
 * FIELDS:
 *     INNER_VID        
 *     INNER_OP         
 *     RESERVED2_R      Reserved.
 *     OUTER_VID        
 *     OUTER_OP         
 *     RESERVED1_R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr 0x00003444

#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_SIZE 4

/*
 * This structure should be used to declare and program EGRESS_VID_RMK_TBL_DATA.
 *
 */
typedef union BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_s {
	uint32_t v[1];
	uint32_t egress_vid_rmk_tbl_data[1];
	uint32_t _egress_vid_rmk_tbl_data;
} BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_t;

#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_CLR(r) (r).egress_vid_rmk_tbl_data[0] = 0
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_SET(r,d) (r).egress_vid_rmk_tbl_data[0] = d
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_GET(r) (r).egress_vid_rmk_tbl_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_GET(r) (((r).egress_vid_rmk_tbl_data[0]) & 0xfff)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 12) & 0x3)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED2_Rf_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 14) & 0x3)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED2_Rf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 16) & 0xfff)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 28) & 0x3)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED1_Rf_GET(r) ((((r).egress_vid_rmk_tbl_data[0]) >> 30) & 0x3)
#define BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED1_Rf_SET(r,f) (r).egress_vid_rmk_tbl_data[0]=(((r).egress_vid_rmk_tbl_data[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access EGRESS_VID_RMK_TBL_DATA.
 *
 */
#define BCM53115_A0_READ_EGRESS_VID_RMK_TBL_DATAr(u,r) cdk_robo_reg_read(u,BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr,(r._egress_vid_rmk_tbl_data),4)
#define BCM53115_A0_WRITE_EGRESS_VID_RMK_TBL_DATAr(u,r) cdk_robo_reg_write(u,BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr,&(r._egress_vid_rmk_tbl_data),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_VID_RMK_TBL_DATAr BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr
#define EGRESS_VID_RMK_TBL_DATAr_SIZE BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_SIZE
typedef BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_t EGRESS_VID_RMK_TBL_DATAr_t;
#define EGRESS_VID_RMK_TBL_DATAr_CLR BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_CLR
#define EGRESS_VID_RMK_TBL_DATAr_SET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_SET
#define EGRESS_VID_RMK_TBL_DATAr_GET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_GET
#define EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_GET
#define EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_VIDf_SET
#define EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_GET
#define EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_INNER_OPf_SET
#define EGRESS_VID_RMK_TBL_DATAr_RESERVED2_Rf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED2_Rf_GET
#define EGRESS_VID_RMK_TBL_DATAr_RESERVED2_Rf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED2_Rf_SET
#define EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_GET
#define EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_VIDf_SET
#define EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_GET
#define EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_OUTER_OPf_SET
#define EGRESS_VID_RMK_TBL_DATAr_RESERVED1_Rf_GET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED1_Rf_GET
#define EGRESS_VID_RMK_TBL_DATAr_RESERVED1_Rf_SET BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr_RESERVED1_Rf_SET
#define READ_EGRESS_VID_RMK_TBL_DATAr BCM53115_A0_READ_EGRESS_VID_RMK_TBL_DATAr
#define WRITE_EGRESS_VID_RMK_TBL_DATAr BCM53115_A0_WRITE_EGRESS_VID_RMK_TBL_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_EGRESS_VID_RMK_TBL_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FAST_AGE_CTRL
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Control Registrer
 * SIZE:     8
 * FIELDS:
 *     EN_FAST_AGE_STATIC Set 1'b1 to Age out Dymanic Entry.
 *     EN_AGE_DYNAMIC   Set 1'b1 to Age out Dymanic Entry.
 *     EN_AGE_PORT      Set 1'b1 to Check Port ID
 *     EN_AGE_VLAN      Set 1'b1 to Check Vlan ID.
 *     EN_AGE_SPT       set 1'b1 to check spanning Tree ID(refer to EN_802_1S/MSPT_AGE_MAP at page/address=43h/00h,02-05h)
 *     EN_AGE_MCAST     Enable aging multicast entry1: Aging multicast entries in ARL table0: Disable aging multicast entries in ARL table
 *     RESERVED_R       Reserved
 *     FAST_AGE_STR_DONE When Set 1'b1, a control signal (fast_age_start) will invoke fast ageing mechanism.When Fast aging is done, a control signal (fast_age_done) will clear the control bit.
 *
 ******************************************************************************/
#define BCM53115_A0_FAST_AGE_CTRLr 0x00000088

#define BCM53115_A0_FAST_AGE_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_CTRL.
 *
 */
typedef union BCM53115_A0_FAST_AGE_CTRLr_s {
	uint32_t v[1];
	uint32_t fast_age_ctrl[1];
	uint32_t _fast_age_ctrl;
} BCM53115_A0_FAST_AGE_CTRLr_t;

#define BCM53115_A0_FAST_AGE_CTRLr_CLR(r) (r).fast_age_ctrl[0] = 0
#define BCM53115_A0_FAST_AGE_CTRLr_SET(r,d) (r).fast_age_ctrl[0] = d
#define BCM53115_A0_FAST_AGE_CTRLr_GET(r) (r).fast_age_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET(r) (((r).fast_age_ctrl[0]) & 0x1)
#define BCM53115_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET(r) ((((r).fast_age_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_GET(r) ((((r).fast_age_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_GET(r) ((((r).fast_age_ctrl[0]) >> 3) & 0x1)
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_GET(r) ((((r).fast_age_ctrl[0]) >> 4) & 0x1)
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_GET(r) ((((r).fast_age_ctrl[0]) >> 5) & 0x1)
#define BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_FAST_AGE_CTRLr_RESERVED_Rf_GET(r) ((((r).fast_age_ctrl[0]) >> 6) & 0x1)
#define BCM53115_A0_FAST_AGE_CTRLr_RESERVED_Rf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET(r) ((((r).fast_age_ctrl[0]) >> 7) & 0x1)
#define BCM53115_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FAST_AGE_CTRL.
 *
 */
#define BCM53115_A0_READ_FAST_AGE_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FAST_AGE_CTRLr,(r._fast_age_ctrl),1)
#define BCM53115_A0_WRITE_FAST_AGE_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FAST_AGE_CTRLr,&(r._fast_age_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_CTRLr BCM53115_A0_FAST_AGE_CTRLr
#define FAST_AGE_CTRLr_SIZE BCM53115_A0_FAST_AGE_CTRLr_SIZE
typedef BCM53115_A0_FAST_AGE_CTRLr_t FAST_AGE_CTRLr_t;
#define FAST_AGE_CTRLr_CLR BCM53115_A0_FAST_AGE_CTRLr_CLR
#define FAST_AGE_CTRLr_SET BCM53115_A0_FAST_AGE_CTRLr_SET
#define FAST_AGE_CTRLr_GET BCM53115_A0_FAST_AGE_CTRLr_GET
#define FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET BCM53115_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET
#define FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET BCM53115_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET
#define FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET
#define FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET
#define FAST_AGE_CTRLr_EN_AGE_PORTf_GET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_GET
#define FAST_AGE_CTRLr_EN_AGE_PORTf_SET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_SET
#define FAST_AGE_CTRLr_EN_AGE_VLANf_GET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_GET
#define FAST_AGE_CTRLr_EN_AGE_VLANf_SET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_SET
#define FAST_AGE_CTRLr_EN_AGE_SPTf_GET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_GET
#define FAST_AGE_CTRLr_EN_AGE_SPTf_SET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_SET
#define FAST_AGE_CTRLr_EN_AGE_MCASTf_GET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_GET
#define FAST_AGE_CTRLr_EN_AGE_MCASTf_SET BCM53115_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_SET
#define FAST_AGE_CTRLr_RESERVED_Rf_GET BCM53115_A0_FAST_AGE_CTRLr_RESERVED_Rf_GET
#define FAST_AGE_CTRLr_RESERVED_Rf_SET BCM53115_A0_FAST_AGE_CTRLr_RESERVED_Rf_SET
#define FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET BCM53115_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET
#define FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET BCM53115_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET
#define READ_FAST_AGE_CTRLr BCM53115_A0_READ_FAST_AGE_CTRLr
#define WRITE_FAST_AGE_CTRLr BCM53115_A0_WRITE_FAST_AGE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FAST_AGE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FAST_AGE_PORT
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Port Control Registrer
 * SIZE:     8
 * FIELDS:
 *     AGE_PORT         Select Fast Ageing Source Port.Select a specified Port ID to be aged-out.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FAST_AGE_PORTr 0x00000089

#define BCM53115_A0_FAST_AGE_PORTr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_PORT.
 *
 */
typedef union BCM53115_A0_FAST_AGE_PORTr_s {
	uint32_t v[1];
	uint32_t fast_age_port[1];
	uint32_t _fast_age_port;
} BCM53115_A0_FAST_AGE_PORTr_t;

#define BCM53115_A0_FAST_AGE_PORTr_CLR(r) (r).fast_age_port[0] = 0
#define BCM53115_A0_FAST_AGE_PORTr_SET(r,d) (r).fast_age_port[0] = d
#define BCM53115_A0_FAST_AGE_PORTr_GET(r) (r).fast_age_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FAST_AGE_PORTr_AGE_PORTf_GET(r) (((r).fast_age_port[0]) & 0xf)
#define BCM53115_A0_FAST_AGE_PORTr_AGE_PORTf_SET(r,f) (r).fast_age_port[0]=(((r).fast_age_port[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_FAST_AGE_PORTr_RESERVED_Rf_GET(r) ((((r).fast_age_port[0]) >> 4) & 0xf)
#define BCM53115_A0_FAST_AGE_PORTr_RESERVED_Rf_SET(r,f) (r).fast_age_port[0]=(((r).fast_age_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access FAST_AGE_PORT.
 *
 */
#define BCM53115_A0_READ_FAST_AGE_PORTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FAST_AGE_PORTr,(r._fast_age_port),1)
#define BCM53115_A0_WRITE_FAST_AGE_PORTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FAST_AGE_PORTr,&(r._fast_age_port),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_PORTr BCM53115_A0_FAST_AGE_PORTr
#define FAST_AGE_PORTr_SIZE BCM53115_A0_FAST_AGE_PORTr_SIZE
typedef BCM53115_A0_FAST_AGE_PORTr_t FAST_AGE_PORTr_t;
#define FAST_AGE_PORTr_CLR BCM53115_A0_FAST_AGE_PORTr_CLR
#define FAST_AGE_PORTr_SET BCM53115_A0_FAST_AGE_PORTr_SET
#define FAST_AGE_PORTr_GET BCM53115_A0_FAST_AGE_PORTr_GET
#define FAST_AGE_PORTr_AGE_PORTf_GET BCM53115_A0_FAST_AGE_PORTr_AGE_PORTf_GET
#define FAST_AGE_PORTr_AGE_PORTf_SET BCM53115_A0_FAST_AGE_PORTr_AGE_PORTf_SET
#define FAST_AGE_PORTr_RESERVED_Rf_GET BCM53115_A0_FAST_AGE_PORTr_RESERVED_Rf_GET
#define FAST_AGE_PORTr_RESERVED_Rf_SET BCM53115_A0_FAST_AGE_PORTr_RESERVED_Rf_SET
#define READ_FAST_AGE_PORTr BCM53115_A0_READ_FAST_AGE_PORTr
#define WRITE_FAST_AGE_PORTr BCM53115_A0_WRITE_FAST_AGE_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FAST_AGE_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FAST_AGE_VID
 * BLOCKS:   SYS
 * DESC:     Fast Ageing VID Control Registrer
 * SIZE:     16
 * FIELDS:
 *     AGE_VID          Select Fast Ageing VLAN IDSelect a specified VLAN ID to be aged-out.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FAST_AGE_VIDr 0x0000008a

#define BCM53115_A0_FAST_AGE_VIDr_SIZE 2

/*
 * This structure should be used to declare and program FAST_AGE_VID.
 *
 */
typedef union BCM53115_A0_FAST_AGE_VIDr_s {
	uint32_t v[1];
	uint32_t fast_age_vid[1];
	uint32_t _fast_age_vid;
} BCM53115_A0_FAST_AGE_VIDr_t;

#define BCM53115_A0_FAST_AGE_VIDr_CLR(r) (r).fast_age_vid[0] = 0
#define BCM53115_A0_FAST_AGE_VIDr_SET(r,d) (r).fast_age_vid[0] = d
#define BCM53115_A0_FAST_AGE_VIDr_GET(r) (r).fast_age_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FAST_AGE_VIDr_AGE_VIDf_GET(r) (((r).fast_age_vid[0]) & 0xfff)
#define BCM53115_A0_FAST_AGE_VIDr_AGE_VIDf_SET(r,f) (r).fast_age_vid[0]=(((r).fast_age_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_FAST_AGE_VIDr_RESERVED_Rf_GET(r) ((((r).fast_age_vid[0]) >> 12) & 0xf)
#define BCM53115_A0_FAST_AGE_VIDr_RESERVED_Rf_SET(r,f) (r).fast_age_vid[0]=(((r).fast_age_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access FAST_AGE_VID.
 *
 */
#define BCM53115_A0_READ_FAST_AGE_VIDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FAST_AGE_VIDr,(r._fast_age_vid),2)
#define BCM53115_A0_WRITE_FAST_AGE_VIDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FAST_AGE_VIDr,&(r._fast_age_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_VIDr BCM53115_A0_FAST_AGE_VIDr
#define FAST_AGE_VIDr_SIZE BCM53115_A0_FAST_AGE_VIDr_SIZE
typedef BCM53115_A0_FAST_AGE_VIDr_t FAST_AGE_VIDr_t;
#define FAST_AGE_VIDr_CLR BCM53115_A0_FAST_AGE_VIDr_CLR
#define FAST_AGE_VIDr_SET BCM53115_A0_FAST_AGE_VIDr_SET
#define FAST_AGE_VIDr_GET BCM53115_A0_FAST_AGE_VIDr_GET
#define FAST_AGE_VIDr_AGE_VIDf_GET BCM53115_A0_FAST_AGE_VIDr_AGE_VIDf_GET
#define FAST_AGE_VIDr_AGE_VIDf_SET BCM53115_A0_FAST_AGE_VIDr_AGE_VIDf_SET
#define FAST_AGE_VIDr_RESERVED_Rf_GET BCM53115_A0_FAST_AGE_VIDr_RESERVED_Rf_GET
#define FAST_AGE_VIDr_RESERVED_Rf_SET BCM53115_A0_FAST_AGE_VIDr_RESERVED_Rf_SET
#define READ_FAST_AGE_VIDr BCM53115_A0_READ_FAST_AGE_VIDr
#define WRITE_FAST_AGE_VIDr BCM53115_A0_WRITE_FAST_AGE_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FAST_AGE_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_CHIP_INFO
 * BLOCKS:   SYS
 * DESC:     Chip Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     PRT_LINK         
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_CHIP_INFOr 0x00000a9a

#define BCM53115_A0_FC_CHIP_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_CHIP_INFO.
 *
 */
typedef union BCM53115_A0_FC_CHIP_INFOr_s {
	uint32_t v[1];
	uint32_t fc_chip_info[1];
	uint32_t _fc_chip_info;
} BCM53115_A0_FC_CHIP_INFOr_t;

#define BCM53115_A0_FC_CHIP_INFOr_CLR(r) (r).fc_chip_info[0] = 0
#define BCM53115_A0_FC_CHIP_INFOr_SET(r,d) (r).fc_chip_info[0] = d
#define BCM53115_A0_FC_CHIP_INFOr_GET(r) (r).fc_chip_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_CHIP_INFOr_PRT_LINKf_GET(r) (((r).fc_chip_info[0]) & 0x1ff)
#define BCM53115_A0_FC_CHIP_INFOr_PRT_LINKf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_FC_CHIP_INFOr_RESERVED_Rf_GET(r) ((((r).fc_chip_info[0]) >> 9) & 0x7f)
#define BCM53115_A0_FC_CHIP_INFOr_RESERVED_Rf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_CHIP_INFO.
 *
 */
#define BCM53115_A0_READ_FC_CHIP_INFOr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_CHIP_INFOr,(r._fc_chip_info),2)
#define BCM53115_A0_WRITE_FC_CHIP_INFOr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_CHIP_INFOr,&(r._fc_chip_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CHIP_INFOr BCM53115_A0_FC_CHIP_INFOr
#define FC_CHIP_INFOr_SIZE BCM53115_A0_FC_CHIP_INFOr_SIZE
typedef BCM53115_A0_FC_CHIP_INFOr_t FC_CHIP_INFOr_t;
#define FC_CHIP_INFOr_CLR BCM53115_A0_FC_CHIP_INFOr_CLR
#define FC_CHIP_INFOr_SET BCM53115_A0_FC_CHIP_INFOr_SET
#define FC_CHIP_INFOr_GET BCM53115_A0_FC_CHIP_INFOr_GET
#define FC_CHIP_INFOr_PRT_LINKf_GET BCM53115_A0_FC_CHIP_INFOr_PRT_LINKf_GET
#define FC_CHIP_INFOr_PRT_LINKf_SET BCM53115_A0_FC_CHIP_INFOr_PRT_LINKf_SET
#define FC_CHIP_INFOr_RESERVED_Rf_GET BCM53115_A0_FC_CHIP_INFOr_RESERVED_Rf_GET
#define FC_CHIP_INFOr_RESERVED_Rf_SET BCM53115_A0_FC_CHIP_INFOr_RESERVED_Rf_SET
#define READ_FC_CHIP_INFOr BCM53115_A0_READ_FC_CHIP_INFOr
#define WRITE_FC_CHIP_INFOr BCM53115_A0_WRITE_FC_CHIP_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_CHIP_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_CONG_BUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Congested Bus Error Register
 * SIZE:     16
 * FIELDS:
 *     CONG_BUF_ERR_HIS 
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_CONG_BUF_ERR_HISr 0x00000aaa

#define BCM53115_A0_FC_CONG_BUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_BUF_ERR_HIS.
 *
 */
typedef union BCM53115_A0_FC_CONG_BUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_cong_buf_err_his[1];
	uint32_t _fc_cong_buf_err_his;
} BCM53115_A0_FC_CONG_BUF_ERR_HISr_t;

#define BCM53115_A0_FC_CONG_BUF_ERR_HISr_CLR(r) (r).fc_cong_buf_err_his[0] = 0
#define BCM53115_A0_FC_CONG_BUF_ERR_HISr_SET(r,d) (r).fc_cong_buf_err_his[0] = d
#define BCM53115_A0_FC_CONG_BUF_ERR_HISr_GET(r) (r).fc_cong_buf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET(r) (((r).fc_cong_buf_err_his[0]) & 0x1)
#define BCM53115_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_FC_CONG_BUF_ERR_HISr_RESERVED_Rf_GET(r) ((((r).fc_cong_buf_err_his[0]) >> 1) & 0x7fff)
#define BCM53115_A0_FC_CONG_BUF_ERR_HISr_RESERVED_Rf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access FC_CONG_BUF_ERR_HIS.
 *
 */
#define BCM53115_A0_READ_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_CONG_BUF_ERR_HISr,(r._fc_cong_buf_err_his),2)
#define BCM53115_A0_WRITE_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_CONG_BUF_ERR_HISr,&(r._fc_cong_buf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_BUF_ERR_HISr BCM53115_A0_FC_CONG_BUF_ERR_HISr
#define FC_CONG_BUF_ERR_HISr_SIZE BCM53115_A0_FC_CONG_BUF_ERR_HISr_SIZE
typedef BCM53115_A0_FC_CONG_BUF_ERR_HISr_t FC_CONG_BUF_ERR_HISr_t;
#define FC_CONG_BUF_ERR_HISr_CLR BCM53115_A0_FC_CONG_BUF_ERR_HISr_CLR
#define FC_CONG_BUF_ERR_HISr_SET BCM53115_A0_FC_CONG_BUF_ERR_HISr_SET
#define FC_CONG_BUF_ERR_HISr_GET BCM53115_A0_FC_CONG_BUF_ERR_HISr_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET BCM53115_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET BCM53115_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET
#define FC_CONG_BUF_ERR_HISr_RESERVED_Rf_GET BCM53115_A0_FC_CONG_BUF_ERR_HISr_RESERVED_Rf_GET
#define FC_CONG_BUF_ERR_HISr_RESERVED_Rf_SET BCM53115_A0_FC_CONG_BUF_ERR_HISr_RESERVED_Rf_SET
#define READ_FC_CONG_BUF_ERR_HISr BCM53115_A0_READ_FC_CONG_BUF_ERR_HISr
#define WRITE_FC_CONG_BUF_ERR_HISr BCM53115_A0_WRITE_FC_CONG_BUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_CONG_BUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_CONG_PORTMAP01
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port01 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP0    
 *     CONG_PORTMAP1    Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_CONG_PORTMAP01r 0x00000a90

#define BCM53115_A0_FC_CONG_PORTMAP01r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP01.
 *
 */
typedef union BCM53115_A0_FC_CONG_PORTMAP01r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap01[1];
	uint32_t _fc_cong_portmap01;
} BCM53115_A0_FC_CONG_PORTMAP01r_t;

#define BCM53115_A0_FC_CONG_PORTMAP01r_CLR(r) (r).fc_cong_portmap01[0] = 0
#define BCM53115_A0_FC_CONG_PORTMAP01r_SET(r,d) (r).fc_cong_portmap01[0] = d
#define BCM53115_A0_FC_CONG_PORTMAP01r_GET(r) (r).fc_cong_portmap01[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET(r) (((r).fc_cong_portmap01[0]) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET(r) ((((r).fc_cong_portmap01[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP01.
 *
 */
#define BCM53115_A0_READ_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_CONG_PORTMAP01r,(r._fc_cong_portmap01),2)
#define BCM53115_A0_WRITE_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_CONG_PORTMAP01r,&(r._fc_cong_portmap01),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP01r BCM53115_A0_FC_CONG_PORTMAP01r
#define FC_CONG_PORTMAP01r_SIZE BCM53115_A0_FC_CONG_PORTMAP01r_SIZE
typedef BCM53115_A0_FC_CONG_PORTMAP01r_t FC_CONG_PORTMAP01r_t;
#define FC_CONG_PORTMAP01r_CLR BCM53115_A0_FC_CONG_PORTMAP01r_CLR
#define FC_CONG_PORTMAP01r_SET BCM53115_A0_FC_CONG_PORTMAP01r_SET
#define FC_CONG_PORTMAP01r_GET BCM53115_A0_FC_CONG_PORTMAP01r_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET BCM53115_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET BCM53115_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET BCM53115_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET BCM53115_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET
#define READ_FC_CONG_PORTMAP01r BCM53115_A0_READ_FC_CONG_PORTMAP01r
#define WRITE_FC_CONG_PORTMAP01r BCM53115_A0_WRITE_FC_CONG_PORTMAP01r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_CONG_PORTMAP01r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_CONG_PORTMAP23
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port23 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP2    
 *     CONG_PORTMAP3    Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_CONG_PORTMAP23r 0x00000a92

#define BCM53115_A0_FC_CONG_PORTMAP23r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP23.
 *
 */
typedef union BCM53115_A0_FC_CONG_PORTMAP23r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap23[1];
	uint32_t _fc_cong_portmap23;
} BCM53115_A0_FC_CONG_PORTMAP23r_t;

#define BCM53115_A0_FC_CONG_PORTMAP23r_CLR(r) (r).fc_cong_portmap23[0] = 0
#define BCM53115_A0_FC_CONG_PORTMAP23r_SET(r,d) (r).fc_cong_portmap23[0] = d
#define BCM53115_A0_FC_CONG_PORTMAP23r_GET(r) (r).fc_cong_portmap23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET(r) (((r).fc_cong_portmap23[0]) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET(r) ((((r).fc_cong_portmap23[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP23.
 *
 */
#define BCM53115_A0_READ_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_CONG_PORTMAP23r,(r._fc_cong_portmap23),2)
#define BCM53115_A0_WRITE_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_CONG_PORTMAP23r,&(r._fc_cong_portmap23),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP23r BCM53115_A0_FC_CONG_PORTMAP23r
#define FC_CONG_PORTMAP23r_SIZE BCM53115_A0_FC_CONG_PORTMAP23r_SIZE
typedef BCM53115_A0_FC_CONG_PORTMAP23r_t FC_CONG_PORTMAP23r_t;
#define FC_CONG_PORTMAP23r_CLR BCM53115_A0_FC_CONG_PORTMAP23r_CLR
#define FC_CONG_PORTMAP23r_SET BCM53115_A0_FC_CONG_PORTMAP23r_SET
#define FC_CONG_PORTMAP23r_GET BCM53115_A0_FC_CONG_PORTMAP23r_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET BCM53115_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET BCM53115_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET BCM53115_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET BCM53115_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET
#define READ_FC_CONG_PORTMAP23r BCM53115_A0_READ_FC_CONG_PORTMAP23r
#define WRITE_FC_CONG_PORTMAP23r BCM53115_A0_WRITE_FC_CONG_PORTMAP23r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_CONG_PORTMAP23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_CONG_PORTMAP45
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port45 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP4    
 *     CONG_PORTMAP5    Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_CONG_PORTMAP45r 0x00000a94

#define BCM53115_A0_FC_CONG_PORTMAP45r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP45.
 *
 */
typedef union BCM53115_A0_FC_CONG_PORTMAP45r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap45[1];
	uint32_t _fc_cong_portmap45;
} BCM53115_A0_FC_CONG_PORTMAP45r_t;

#define BCM53115_A0_FC_CONG_PORTMAP45r_CLR(r) (r).fc_cong_portmap45[0] = 0
#define BCM53115_A0_FC_CONG_PORTMAP45r_SET(r,d) (r).fc_cong_portmap45[0] = d
#define BCM53115_A0_FC_CONG_PORTMAP45r_GET(r) (r).fc_cong_portmap45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET(r) (((r).fc_cong_portmap45[0]) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET(r) ((((r).fc_cong_portmap45[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP45.
 *
 */
#define BCM53115_A0_READ_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_CONG_PORTMAP45r,(r._fc_cong_portmap45),2)
#define BCM53115_A0_WRITE_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_CONG_PORTMAP45r,&(r._fc_cong_portmap45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP45r BCM53115_A0_FC_CONG_PORTMAP45r
#define FC_CONG_PORTMAP45r_SIZE BCM53115_A0_FC_CONG_PORTMAP45r_SIZE
typedef BCM53115_A0_FC_CONG_PORTMAP45r_t FC_CONG_PORTMAP45r_t;
#define FC_CONG_PORTMAP45r_CLR BCM53115_A0_FC_CONG_PORTMAP45r_CLR
#define FC_CONG_PORTMAP45r_SET BCM53115_A0_FC_CONG_PORTMAP45r_SET
#define FC_CONG_PORTMAP45r_GET BCM53115_A0_FC_CONG_PORTMAP45r_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET BCM53115_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET BCM53115_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET BCM53115_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET BCM53115_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET
#define READ_FC_CONG_PORTMAP45r BCM53115_A0_READ_FC_CONG_PORTMAP45r
#define WRITE_FC_CONG_PORTMAP45r BCM53115_A0_WRITE_FC_CONG_PORTMAP45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_CONG_PORTMAP45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_CONG_PORTMAP67
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port67 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP6    
 *     CONG_PORTMAP7    Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_CONG_PORTMAP67r 0x00000a96

#define BCM53115_A0_FC_CONG_PORTMAP67r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP67.
 *
 */
typedef union BCM53115_A0_FC_CONG_PORTMAP67r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap67[1];
	uint32_t _fc_cong_portmap67;
} BCM53115_A0_FC_CONG_PORTMAP67r_t;

#define BCM53115_A0_FC_CONG_PORTMAP67r_CLR(r) (r).fc_cong_portmap67[0] = 0
#define BCM53115_A0_FC_CONG_PORTMAP67r_SET(r,d) (r).fc_cong_portmap67[0] = d
#define BCM53115_A0_FC_CONG_PORTMAP67r_GET(r) (r).fc_cong_portmap67[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET(r) (((r).fc_cong_portmap67[0]) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET(r) ((((r).fc_cong_portmap67[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP67.
 *
 */
#define BCM53115_A0_READ_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_CONG_PORTMAP67r,(r._fc_cong_portmap67),2)
#define BCM53115_A0_WRITE_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_CONG_PORTMAP67r,&(r._fc_cong_portmap67),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP67r BCM53115_A0_FC_CONG_PORTMAP67r
#define FC_CONG_PORTMAP67r_SIZE BCM53115_A0_FC_CONG_PORTMAP67r_SIZE
typedef BCM53115_A0_FC_CONG_PORTMAP67r_t FC_CONG_PORTMAP67r_t;
#define FC_CONG_PORTMAP67r_CLR BCM53115_A0_FC_CONG_PORTMAP67r_CLR
#define FC_CONG_PORTMAP67r_SET BCM53115_A0_FC_CONG_PORTMAP67r_SET
#define FC_CONG_PORTMAP67r_GET BCM53115_A0_FC_CONG_PORTMAP67r_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET BCM53115_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET BCM53115_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET BCM53115_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET BCM53115_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET
#define READ_FC_CONG_PORTMAP67r BCM53115_A0_READ_FC_CONG_PORTMAP67r
#define WRITE_FC_CONG_PORTMAP67r BCM53115_A0_WRITE_FC_CONG_PORTMAP67r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_CONG_PORTMAP67r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_CONG_PORTMAP8
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port8 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP8    
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_CONG_PORTMAP8r 0x00000a98

#define BCM53115_A0_FC_CONG_PORTMAP8r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP8.
 *
 */
typedef union BCM53115_A0_FC_CONG_PORTMAP8r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap8[1];
	uint32_t _fc_cong_portmap8;
} BCM53115_A0_FC_CONG_PORTMAP8r_t;

#define BCM53115_A0_FC_CONG_PORTMAP8r_CLR(r) (r).fc_cong_portmap8[0] = 0
#define BCM53115_A0_FC_CONG_PORTMAP8r_SET(r,d) (r).fc_cong_portmap8[0] = d
#define BCM53115_A0_FC_CONG_PORTMAP8r_GET(r) (r).fc_cong_portmap8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET(r) (((r).fc_cong_portmap8[0]) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_CONG_PORTMAP8r_RESERVED_Rf_GET(r) ((((r).fc_cong_portmap8[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_CONG_PORTMAP8r_RESERVED_Rf_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP8.
 *
 */
#define BCM53115_A0_READ_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_CONG_PORTMAP8r,(r._fc_cong_portmap8),2)
#define BCM53115_A0_WRITE_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_CONG_PORTMAP8r,&(r._fc_cong_portmap8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP8r BCM53115_A0_FC_CONG_PORTMAP8r
#define FC_CONG_PORTMAP8r_SIZE BCM53115_A0_FC_CONG_PORTMAP8r_SIZE
typedef BCM53115_A0_FC_CONG_PORTMAP8r_t FC_CONG_PORTMAP8r_t;
#define FC_CONG_PORTMAP8r_CLR BCM53115_A0_FC_CONG_PORTMAP8r_CLR
#define FC_CONG_PORTMAP8r_SET BCM53115_A0_FC_CONG_PORTMAP8r_SET
#define FC_CONG_PORTMAP8r_GET BCM53115_A0_FC_CONG_PORTMAP8r_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET BCM53115_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET BCM53115_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET
#define FC_CONG_PORTMAP8r_RESERVED_Rf_GET BCM53115_A0_FC_CONG_PORTMAP8r_RESERVED_Rf_GET
#define FC_CONG_PORTMAP8r_RESERVED_Rf_SET BCM53115_A0_FC_CONG_PORTMAP8r_RESERVED_Rf_SET
#define READ_FC_CONG_PORTMAP8r BCM53115_A0_READ_FC_CONG_PORTMAP8r
#define WRITE_FC_CONG_PORTMAP8r BCM53115_A0_WRITE_FC_CONG_PORTMAP8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_CONG_PORTMAP8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_DIAG_CTRL
 * BLOCKS:   SYS
 * DESC:     Flowcon Diagnosis Control Register
 * SIZE:     16
 * FIELDS:
 *     DIG_FLOWCON_PROT Diagnosis only: Select which port to be monitored.4'd0 : port 0; 4'd1: port1;  4'd 7: port 7
 *     RESERVED_1R      Reserved.
 *     RESERVED_2R      Reserved.
 *     RESERVED_3R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_DIAG_CTRLr 0x00000a00

#define BCM53115_A0_FC_DIAG_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_DIAG_CTRL.
 *
 */
typedef union BCM53115_A0_FC_DIAG_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_diag_ctrl[1];
	uint32_t _fc_diag_ctrl;
} BCM53115_A0_FC_DIAG_CTRLr_t;

#define BCM53115_A0_FC_DIAG_CTRLr_CLR(r) (r).fc_diag_ctrl[0] = 0
#define BCM53115_A0_FC_DIAG_CTRLr_SET(r,d) (r).fc_diag_ctrl[0] = d
#define BCM53115_A0_FC_DIAG_CTRLr_GET(r) (r).fc_diag_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET(r) (((r).fc_diag_ctrl[0]) & 0xf)
#define BCM53115_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_FC_DIAG_CTRLr_RESERVED_1Rf_GET(r) ((((r).fc_diag_ctrl[0]) >> 4) & 0x3)
#define BCM53115_A0_FC_DIAG_CTRLr_RESERVED_1Rf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53115_A0_FC_DIAG_CTRLr_RESERVED_2Rf_GET(r) ((((r).fc_diag_ctrl[0]) >> 6) & 0x3)
#define BCM53115_A0_FC_DIAG_CTRLr_RESERVED_2Rf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53115_A0_FC_DIAG_CTRLr_RESERVED_3Rf_GET(r) ((((r).fc_diag_ctrl[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_DIAG_CTRLr_RESERVED_3Rf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_DIAG_CTRL.
 *
 */
#define BCM53115_A0_READ_FC_DIAG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_DIAG_CTRLr,(r._fc_diag_ctrl),2)
#define BCM53115_A0_WRITE_FC_DIAG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_DIAG_CTRLr,&(r._fc_diag_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_DIAG_CTRLr BCM53115_A0_FC_DIAG_CTRLr
#define FC_DIAG_CTRLr_SIZE BCM53115_A0_FC_DIAG_CTRLr_SIZE
typedef BCM53115_A0_FC_DIAG_CTRLr_t FC_DIAG_CTRLr_t;
#define FC_DIAG_CTRLr_CLR BCM53115_A0_FC_DIAG_CTRLr_CLR
#define FC_DIAG_CTRLr_SET BCM53115_A0_FC_DIAG_CTRLr_SET
#define FC_DIAG_CTRLr_GET BCM53115_A0_FC_DIAG_CTRLr_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET BCM53115_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET BCM53115_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET
#define FC_DIAG_CTRLr_RESERVED_1Rf_GET BCM53115_A0_FC_DIAG_CTRLr_RESERVED_1Rf_GET
#define FC_DIAG_CTRLr_RESERVED_1Rf_SET BCM53115_A0_FC_DIAG_CTRLr_RESERVED_1Rf_SET
#define FC_DIAG_CTRLr_RESERVED_2Rf_GET BCM53115_A0_FC_DIAG_CTRLr_RESERVED_2Rf_GET
#define FC_DIAG_CTRLr_RESERVED_2Rf_SET BCM53115_A0_FC_DIAG_CTRLr_RESERVED_2Rf_SET
#define FC_DIAG_CTRLr_RESERVED_3Rf_GET BCM53115_A0_FC_DIAG_CTRLr_RESERVED_3Rf_GET
#define FC_DIAG_CTRLr_RESERVED_3Rf_SET BCM53115_A0_FC_DIAG_CTRLr_RESERVED_3Rf_SET
#define READ_FC_DIAG_CTRLr BCM53115_A0_READ_FC_DIAG_CTRLr
#define WRITE_FC_DIAG_CTRLr BCM53115_A0_WRITE_FC_DIAG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_DIAG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_GIGA_INFO
 * BLOCKS:   SYS
 * DESC:     Giga Speed Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     GIGA_PORTMAP     
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_GIGA_INFOr 0x00000a9c

#define BCM53115_A0_FC_GIGA_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_GIGA_INFO.
 *
 */
typedef union BCM53115_A0_FC_GIGA_INFOr_s {
	uint32_t v[1];
	uint32_t fc_giga_info[1];
	uint32_t _fc_giga_info;
} BCM53115_A0_FC_GIGA_INFOr_t;

#define BCM53115_A0_FC_GIGA_INFOr_CLR(r) (r).fc_giga_info[0] = 0
#define BCM53115_A0_FC_GIGA_INFOr_SET(r,d) (r).fc_giga_info[0] = d
#define BCM53115_A0_FC_GIGA_INFOr_GET(r) (r).fc_giga_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET(r) (((r).fc_giga_info[0]) & 0x1ff)
#define BCM53115_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_FC_GIGA_INFOr_RESERVED_Rf_GET(r) ((((r).fc_giga_info[0]) >> 9) & 0x7f)
#define BCM53115_A0_FC_GIGA_INFOr_RESERVED_Rf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_GIGA_INFO.
 *
 */
#define BCM53115_A0_READ_FC_GIGA_INFOr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_GIGA_INFOr,(r._fc_giga_info),2)
#define BCM53115_A0_WRITE_FC_GIGA_INFOr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_GIGA_INFOr,&(r._fc_giga_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_GIGA_INFOr BCM53115_A0_FC_GIGA_INFOr
#define FC_GIGA_INFOr_SIZE BCM53115_A0_FC_GIGA_INFOr_SIZE
typedef BCM53115_A0_FC_GIGA_INFOr_t FC_GIGA_INFOr_t;
#define FC_GIGA_INFOr_CLR BCM53115_A0_FC_GIGA_INFOr_CLR
#define FC_GIGA_INFOr_SET BCM53115_A0_FC_GIGA_INFOr_SET
#define FC_GIGA_INFOr_GET BCM53115_A0_FC_GIGA_INFOr_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_GET BCM53115_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_SET BCM53115_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET
#define FC_GIGA_INFOr_RESERVED_Rf_GET BCM53115_A0_FC_GIGA_INFOr_RESERVED_Rf_GET
#define FC_GIGA_INFOr_RESERVED_Rf_SET BCM53115_A0_FC_GIGA_INFOr_RESERVED_Rf_SET
#define READ_FC_GIGA_INFOr BCM53115_A0_READ_FC_GIGA_INFOr
#define WRITE_FC_GIGA_INFOr BCM53115_A0_WRITE_FC_GIGA_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_GIGA_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_MCAST_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Multicast Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     PAR_DROP_EN      Multicast Partial Drop Enalbed.Bit 8 = IMP port,Bit 5:0 = Port 5 ~ Port 0,1: Multicast Frame can forward to uncongested Destination Port, and will not forward to congested Destination Port0: Multicast Frame can forward only if all destination ports are not congested.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_MCAST_DROP_CTRLr 0x00000a0c

#define BCM53115_A0_FC_MCAST_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_MCAST_DROP_CTRL.
 *
 */
typedef union BCM53115_A0_FC_MCAST_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_mcast_drop_ctrl[1];
	uint32_t _fc_mcast_drop_ctrl;
} BCM53115_A0_FC_MCAST_DROP_CTRLr_t;

#define BCM53115_A0_FC_MCAST_DROP_CTRLr_CLR(r) (r).fc_mcast_drop_ctrl[0] = 0
#define BCM53115_A0_FC_MCAST_DROP_CTRLr_SET(r,d) (r).fc_mcast_drop_ctrl[0] = d
#define BCM53115_A0_FC_MCAST_DROP_CTRLr_GET(r) (r).fc_mcast_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET(r) (((r).fc_mcast_drop_ctrl[0]) & 0x1ff)
#define BCM53115_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_FC_MCAST_DROP_CTRLr_RESERVED_Rf_GET(r) ((((r).fc_mcast_drop_ctrl[0]) >> 9) & 0x7f)
#define BCM53115_A0_FC_MCAST_DROP_CTRLr_RESERVED_Rf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_MCAST_DROP_CTRL.
 *
 */
#define BCM53115_A0_READ_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_MCAST_DROP_CTRLr,(r._fc_mcast_drop_ctrl),2)
#define BCM53115_A0_WRITE_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_MCAST_DROP_CTRLr,&(r._fc_mcast_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MCAST_DROP_CTRLr BCM53115_A0_FC_MCAST_DROP_CTRLr
#define FC_MCAST_DROP_CTRLr_SIZE BCM53115_A0_FC_MCAST_DROP_CTRLr_SIZE
typedef BCM53115_A0_FC_MCAST_DROP_CTRLr_t FC_MCAST_DROP_CTRLr_t;
#define FC_MCAST_DROP_CTRLr_CLR BCM53115_A0_FC_MCAST_DROP_CTRLr_CLR
#define FC_MCAST_DROP_CTRLr_SET BCM53115_A0_FC_MCAST_DROP_CTRLr_SET
#define FC_MCAST_DROP_CTRLr_GET BCM53115_A0_FC_MCAST_DROP_CTRLr_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET BCM53115_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET BCM53115_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET
#define FC_MCAST_DROP_CTRLr_RESERVED_Rf_GET BCM53115_A0_FC_MCAST_DROP_CTRLr_RESERVED_Rf_GET
#define FC_MCAST_DROP_CTRLr_RESERVED_Rf_SET BCM53115_A0_FC_MCAST_DROP_CTRLr_RESERVED_Rf_SET
#define READ_FC_MCAST_DROP_CTRLr BCM53115_A0_READ_FC_MCAST_DROP_CTRLr
#define WRITE_FC_MCAST_DROP_CTRLr BCM53115_A0_WRITE_FC_MCAST_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_MCAST_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_MON_TXQ
 * BLOCKS:   SYS
 * DESC:     Monitored TxQ N (0~5) Register
 * SIZE:     16
 * FIELDS:
 *     MONITORED_TXQ_CNT 
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_MON_TXQr 0x00000a60

#define BCM53115_A0_FC_MON_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_MON_TXQ.
 *
 */
typedef union BCM53115_A0_FC_MON_TXQr_s {
	uint32_t v[1];
	uint32_t fc_mon_txq[1];
	uint32_t _fc_mon_txq;
} BCM53115_A0_FC_MON_TXQr_t;

#define BCM53115_A0_FC_MON_TXQr_CLR(r) (r).fc_mon_txq[0] = 0
#define BCM53115_A0_FC_MON_TXQr_SET(r,d) (r).fc_mon_txq[0] = d
#define BCM53115_A0_FC_MON_TXQr_GET(r) (r).fc_mon_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_GET(r) (((r).fc_mon_txq[0]) & 0x7ff)
#define BCM53115_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_MON_TXQr_RESERVED_Rf_GET(r) ((((r).fc_mon_txq[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_MON_TXQr_RESERVED_Rf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_MON_TXQ.
 *
 */
#define BCM53115_A0_READ_FC_MON_TXQr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_MON_TXQr+(2*(i)),(r._fc_mon_txq),2)
#define BCM53115_A0_WRITE_FC_MON_TXQr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_MON_TXQr+(2*(i)),&(r._fc_mon_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MON_TXQr BCM53115_A0_FC_MON_TXQr
#define FC_MON_TXQr_SIZE BCM53115_A0_FC_MON_TXQr_SIZE
typedef BCM53115_A0_FC_MON_TXQr_t FC_MON_TXQr_t;
#define FC_MON_TXQr_CLR BCM53115_A0_FC_MON_TXQr_CLR
#define FC_MON_TXQr_SET BCM53115_A0_FC_MON_TXQr_SET
#define FC_MON_TXQr_GET BCM53115_A0_FC_MON_TXQr_GET
#define FC_MON_TXQr_MONITORED_TXQ_CNTf_GET BCM53115_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_GET
#define FC_MON_TXQr_MONITORED_TXQ_CNTf_SET BCM53115_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_SET
#define FC_MON_TXQr_RESERVED_Rf_GET BCM53115_A0_FC_MON_TXQr_RESERVED_Rf_GET
#define FC_MON_TXQr_RESERVED_Rf_SET BCM53115_A0_FC_MON_TXQr_RESERVED_Rf_SET
#define READ_FC_MON_TXQr BCM53115_A0_READ_FC_MON_TXQr
#define WRITE_FC_MON_TXQr BCM53115_A0_WRITE_FC_MON_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_MON_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_PAUSE_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause/Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TX_PAUSE      To enable txq pause machinism on Ethernet port
 *     EN_TX_DROP       
 *     EN_TOTAL_PAUSE   To enable total pause machinism on Ethernet port
 *     EN_TOTAL_DROP    
 *     EN_TX_LEGACY_PAUSE 
 *     RESERVED_R       Reserved.
 *     EN_RX_PAUSE      
 *     EN_RX_DROP       
 *     RESERVED_0R      Reserved.
 *     EN_IMP1_TXQ_PAUSE 
 *     EN_IMP1_TOTAL_PAUSE 
 *     EN_IMP_TXQ_PAUSE To enable txq pause machinism on IMP
 *     EN_IMP_TOTAL_PAUSE To enable total pause machinism on IMP
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr 0x00000a0e

#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_DROP_CTRL.
 *
 */
typedef union BCM53115_A0_FC_PAUSE_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_pause_drop_ctrl[1];
	uint32_t _fc_pause_drop_ctrl;
} BCM53115_A0_FC_PAUSE_DROP_CTRLr_t;

#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_CLR(r) (r).fc_pause_drop_ctrl[0] = 0
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_SET(r,d) (r).fc_pause_drop_ctrl[0] = d
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_GET(r) (r).fc_pause_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET(r) (((r).fc_pause_drop_ctrl[0]) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 3) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 4) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_Rf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 5) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_Rf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 6) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 7) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 8) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 9) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 10) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 11) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 12) & 0x1)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 13) & 0x7)
#define BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access FC_PAUSE_DROP_CTRL.
 *
 */
#define BCM53115_A0_READ_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_PAUSE_DROP_CTRLr,(r._fc_pause_drop_ctrl),2)
#define BCM53115_A0_WRITE_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_PAUSE_DROP_CTRLr,&(r._fc_pause_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_DROP_CTRLr BCM53115_A0_FC_PAUSE_DROP_CTRLr
#define FC_PAUSE_DROP_CTRLr_SIZE BCM53115_A0_FC_PAUSE_DROP_CTRLr_SIZE
typedef BCM53115_A0_FC_PAUSE_DROP_CTRLr_t FC_PAUSE_DROP_CTRLr_t;
#define FC_PAUSE_DROP_CTRLr_CLR BCM53115_A0_FC_PAUSE_DROP_CTRLr_CLR
#define FC_PAUSE_DROP_CTRLr_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_SET
#define FC_PAUSE_DROP_CTRLr_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_Rf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_Rf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_Rf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_Rf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_GET BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_SET BCM53115_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_SET
#define READ_FC_PAUSE_DROP_CTRLr BCM53115_A0_READ_FC_PAUSE_DROP_CTRLr
#define WRITE_FC_PAUSE_DROP_CTRLr BCM53115_A0_WRITE_FC_PAUSE_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_PAUSE_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_PAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     Pause History Register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_HIS        
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_PAUSE_HISr 0x00000aa0

#define BCM53115_A0_FC_PAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_HIS.
 *
 */
typedef union BCM53115_A0_FC_PAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_pause_his[1];
	uint32_t _fc_pause_his;
} BCM53115_A0_FC_PAUSE_HISr_t;

#define BCM53115_A0_FC_PAUSE_HISr_CLR(r) (r).fc_pause_his[0] = 0
#define BCM53115_A0_FC_PAUSE_HISr_SET(r,d) (r).fc_pause_his[0] = d
#define BCM53115_A0_FC_PAUSE_HISr_GET(r) (r).fc_pause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_PAUSE_HISr_PAUSE_HISf_GET(r) (((r).fc_pause_his[0]) & 0x7ff)
#define BCM53115_A0_FC_PAUSE_HISr_PAUSE_HISf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_PAUSE_HISr_RESERVED_Rf_GET(r) ((((r).fc_pause_his[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_PAUSE_HISr_RESERVED_Rf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PAUSE_HIS.
 *
 */
#define BCM53115_A0_READ_FC_PAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_PAUSE_HISr,(r._fc_pause_his),2)
#define BCM53115_A0_WRITE_FC_PAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_PAUSE_HISr,&(r._fc_pause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_HISr BCM53115_A0_FC_PAUSE_HISr
#define FC_PAUSE_HISr_SIZE BCM53115_A0_FC_PAUSE_HISr_SIZE
typedef BCM53115_A0_FC_PAUSE_HISr_t FC_PAUSE_HISr_t;
#define FC_PAUSE_HISr_CLR BCM53115_A0_FC_PAUSE_HISr_CLR
#define FC_PAUSE_HISr_SET BCM53115_A0_FC_PAUSE_HISr_SET
#define FC_PAUSE_HISr_GET BCM53115_A0_FC_PAUSE_HISr_GET
#define FC_PAUSE_HISr_PAUSE_HISf_GET BCM53115_A0_FC_PAUSE_HISr_PAUSE_HISf_GET
#define FC_PAUSE_HISr_PAUSE_HISf_SET BCM53115_A0_FC_PAUSE_HISr_PAUSE_HISf_SET
#define FC_PAUSE_HISr_RESERVED_Rf_GET BCM53115_A0_FC_PAUSE_HISr_RESERVED_Rf_GET
#define FC_PAUSE_HISr_RESERVED_Rf_SET BCM53115_A0_FC_PAUSE_HISr_RESERVED_Rf_SET
#define READ_FC_PAUSE_HISr BCM53115_A0_READ_FC_PAUSE_HISr
#define WRITE_FC_PAUSE_HISr BCM53115_A0_WRITE_FC_PAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_PAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_PEAK_RXBYTE
 * BLOCKS:   SYS
 * DESC:     Peak Rx Buffer Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_RXBUFFER_CNT Peak Rx Byte count.The diag_port setting in Diag register (Page 0A, Offset 00) can be selected for different Ports.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_PEAK_RXBYTEr 0x00000a78

#define BCM53115_A0_FC_PEAK_RXBYTEr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_RXBYTE.
 *
 */
typedef union BCM53115_A0_FC_PEAK_RXBYTEr_s {
	uint32_t v[1];
	uint32_t fc_peak_rxbyte[1];
	uint32_t _fc_peak_rxbyte;
} BCM53115_A0_FC_PEAK_RXBYTEr_t;

#define BCM53115_A0_FC_PEAK_RXBYTEr_CLR(r) (r).fc_peak_rxbyte[0] = 0
#define BCM53115_A0_FC_PEAK_RXBYTEr_SET(r,d) (r).fc_peak_rxbyte[0] = d
#define BCM53115_A0_FC_PEAK_RXBYTEr_GET(r) (r).fc_peak_rxbyte[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET(r) (((r).fc_peak_rxbyte[0]) & 0x7ff)
#define BCM53115_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_PEAK_RXBYTEr_RESERVED_Rf_GET(r) ((((r).fc_peak_rxbyte[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_PEAK_RXBYTEr_RESERVED_Rf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_RXBYTE.
 *
 */
#define BCM53115_A0_READ_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_PEAK_RXBYTEr,(r._fc_peak_rxbyte),2)
#define BCM53115_A0_WRITE_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_PEAK_RXBYTEr,&(r._fc_peak_rxbyte),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_RXBYTEr BCM53115_A0_FC_PEAK_RXBYTEr
#define FC_PEAK_RXBYTEr_SIZE BCM53115_A0_FC_PEAK_RXBYTEr_SIZE
typedef BCM53115_A0_FC_PEAK_RXBYTEr_t FC_PEAK_RXBYTEr_t;
#define FC_PEAK_RXBYTEr_CLR BCM53115_A0_FC_PEAK_RXBYTEr_CLR
#define FC_PEAK_RXBYTEr_SET BCM53115_A0_FC_PEAK_RXBYTEr_SET
#define FC_PEAK_RXBYTEr_GET BCM53115_A0_FC_PEAK_RXBYTEr_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET BCM53115_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET BCM53115_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET
#define FC_PEAK_RXBYTEr_RESERVED_Rf_GET BCM53115_A0_FC_PEAK_RXBYTEr_RESERVED_Rf_GET
#define FC_PEAK_RXBYTEr_RESERVED_Rf_SET BCM53115_A0_FC_PEAK_RXBYTEr_RESERVED_Rf_SET
#define READ_FC_PEAK_RXBYTEr BCM53115_A0_READ_FC_PEAK_RXBYTEr
#define WRITE_FC_PEAK_RXBYTEr BCM53115_A0_WRITE_FC_PEAK_RXBYTEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_PEAK_RXBYTEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_PEAK_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Peak Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TOTAL_USE   Peak Total Used count.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_PEAK_TOTAL_USEDr 0x00000a80

#define BCM53115_A0_FC_PEAK_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TOTAL_USED.
 *
 */
typedef union BCM53115_A0_FC_PEAK_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_peak_total_used[1];
	uint32_t _fc_peak_total_used;
} BCM53115_A0_FC_PEAK_TOTAL_USEDr_t;

#define BCM53115_A0_FC_PEAK_TOTAL_USEDr_CLR(r) (r).fc_peak_total_used[0] = 0
#define BCM53115_A0_FC_PEAK_TOTAL_USEDr_SET(r,d) (r).fc_peak_total_used[0] = d
#define BCM53115_A0_FC_PEAK_TOTAL_USEDr_GET(r) (r).fc_peak_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET(r) (((r).fc_peak_total_used[0]) & 0x7ff)
#define BCM53115_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_PEAK_TOTAL_USEDr_RESERVED_Rf_GET(r) ((((r).fc_peak_total_used[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_PEAK_TOTAL_USEDr_RESERVED_Rf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_TOTAL_USED.
 *
 */
#define BCM53115_A0_READ_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_PEAK_TOTAL_USEDr,(r._fc_peak_total_used),2)
#define BCM53115_A0_WRITE_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_PEAK_TOTAL_USEDr,&(r._fc_peak_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TOTAL_USEDr BCM53115_A0_FC_PEAK_TOTAL_USEDr
#define FC_PEAK_TOTAL_USEDr_SIZE BCM53115_A0_FC_PEAK_TOTAL_USEDr_SIZE
typedef BCM53115_A0_FC_PEAK_TOTAL_USEDr_t FC_PEAK_TOTAL_USEDr_t;
#define FC_PEAK_TOTAL_USEDr_CLR BCM53115_A0_FC_PEAK_TOTAL_USEDr_CLR
#define FC_PEAK_TOTAL_USEDr_SET BCM53115_A0_FC_PEAK_TOTAL_USEDr_SET
#define FC_PEAK_TOTAL_USEDr_GET BCM53115_A0_FC_PEAK_TOTAL_USEDr_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET BCM53115_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET BCM53115_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET
#define FC_PEAK_TOTAL_USEDr_RESERVED_Rf_GET BCM53115_A0_FC_PEAK_TOTAL_USEDr_RESERVED_Rf_GET
#define FC_PEAK_TOTAL_USEDr_RESERVED_Rf_SET BCM53115_A0_FC_PEAK_TOTAL_USEDr_RESERVED_Rf_SET
#define READ_FC_PEAK_TOTAL_USEDr BCM53115_A0_READ_FC_PEAK_TOTAL_USEDr
#define WRITE_FC_PEAK_TOTAL_USEDr BCM53115_A0_WRITE_FC_PEAK_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_PEAK_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_PEAK_TXQ
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (0~3) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 0~3 counr.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_PEAK_TXQr 0x00000a70

#define BCM53115_A0_FC_PEAK_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ.
 *
 */
typedef union BCM53115_A0_FC_PEAK_TXQr_s {
	uint32_t v[1];
	uint32_t fc_peak_txq[1];
	uint32_t _fc_peak_txq;
} BCM53115_A0_FC_PEAK_TXQr_t;

#define BCM53115_A0_FC_PEAK_TXQr_CLR(r) (r).fc_peak_txq[0] = 0
#define BCM53115_A0_FC_PEAK_TXQr_SET(r,d) (r).fc_peak_txq[0] = d
#define BCM53115_A0_FC_PEAK_TXQr_GET(r) (r).fc_peak_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq[0]) & 0x7ff)
#define BCM53115_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_PEAK_TXQr_RESERVED_Rf_GET(r) ((((r).fc_peak_txq[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_PEAK_TXQr_RESERVED_Rf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ.
 *
 */
#define BCM53115_A0_READ_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_PEAK_TXQr+(2*(i)),(r._fc_peak_txq),2)
#define BCM53115_A0_WRITE_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_PEAK_TXQr+(2*(i)),&(r._fc_peak_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQr BCM53115_A0_FC_PEAK_TXQr
#define FC_PEAK_TXQr_SIZE BCM53115_A0_FC_PEAK_TXQr_SIZE
typedef BCM53115_A0_FC_PEAK_TXQr_t FC_PEAK_TXQr_t;
#define FC_PEAK_TXQr_CLR BCM53115_A0_FC_PEAK_TXQr_CLR
#define FC_PEAK_TXQr_SET BCM53115_A0_FC_PEAK_TXQr_SET
#define FC_PEAK_TXQr_GET BCM53115_A0_FC_PEAK_TXQr_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_GET BCM53115_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_SET BCM53115_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQr_RESERVED_Rf_GET BCM53115_A0_FC_PEAK_TXQr_RESERVED_Rf_GET
#define FC_PEAK_TXQr_RESERVED_Rf_SET BCM53115_A0_FC_PEAK_TXQr_RESERVED_Rf_SET
#define READ_FC_PEAK_TXQr BCM53115_A0_READ_FC_PEAK_TXQr
#define WRITE_FC_PEAK_TXQr BCM53115_A0_WRITE_FC_PEAK_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_PEAK_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_PEAK_TXQ_45
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (4~5) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 4~5 counr.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_PEAK_TXQ_45r 0x00000a88

#define BCM53115_A0_FC_PEAK_TXQ_45r_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ_45.
 *
 */
typedef union BCM53115_A0_FC_PEAK_TXQ_45r_s {
	uint32_t v[1];
	uint32_t fc_peak_txq_45[1];
	uint32_t _fc_peak_txq_45;
} BCM53115_A0_FC_PEAK_TXQ_45r_t;

#define BCM53115_A0_FC_PEAK_TXQ_45r_CLR(r) (r).fc_peak_txq_45[0] = 0
#define BCM53115_A0_FC_PEAK_TXQ_45r_SET(r,d) (r).fc_peak_txq_45[0] = d
#define BCM53115_A0_FC_PEAK_TXQ_45r_GET(r) (r).fc_peak_txq_45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq_45[0]) & 0x7ff)
#define BCM53115_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq_45[0]=(((r).fc_peak_txq_45[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_PEAK_TXQ_45r_RESERVED_Rf_GET(r) ((((r).fc_peak_txq_45[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_PEAK_TXQ_45r_RESERVED_Rf_SET(r,f) (r).fc_peak_txq_45[0]=(((r).fc_peak_txq_45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ_45.
 *
 */
#define BCM53115_A0_READ_FC_PEAK_TXQ_45r(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_PEAK_TXQ_45r+(2*(i)),(r._fc_peak_txq_45),2)
#define BCM53115_A0_WRITE_FC_PEAK_TXQ_45r(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_PEAK_TXQ_45r+(2*(i)),&(r._fc_peak_txq_45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQ_45r BCM53115_A0_FC_PEAK_TXQ_45r
#define FC_PEAK_TXQ_45r_SIZE BCM53115_A0_FC_PEAK_TXQ_45r_SIZE
typedef BCM53115_A0_FC_PEAK_TXQ_45r_t FC_PEAK_TXQ_45r_t;
#define FC_PEAK_TXQ_45r_CLR BCM53115_A0_FC_PEAK_TXQ_45r_CLR
#define FC_PEAK_TXQ_45r_SET BCM53115_A0_FC_PEAK_TXQ_45r_SET
#define FC_PEAK_TXQ_45r_GET BCM53115_A0_FC_PEAK_TXQ_45r_GET
#define FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET BCM53115_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET BCM53115_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQ_45r_RESERVED_Rf_GET BCM53115_A0_FC_PEAK_TXQ_45r_RESERVED_Rf_GET
#define FC_PEAK_TXQ_45r_RESERVED_Rf_SET BCM53115_A0_FC_PEAK_TXQ_45r_RESERVED_Rf_SET
#define READ_FC_PEAK_TXQ_45r BCM53115_A0_READ_FC_PEAK_TXQ_45r
#define WRITE_FC_PEAK_TXQ_45r BCM53115_A0_WRITE_FC_PEAK_TXQ_45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_PEAK_TXQ_45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_0123
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 0,1,2,3 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP01   
 *     CONG_PORTMAP23   Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r 0x00000ad0

#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_0123.
 *
 */
typedef union BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_0123[1];
	uint32_t _fc_q45_cong_portmap_0123;
} BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_t;

#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CLR(r) (r).fc_q45_cong_portmap_0123[0] = 0
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_SET(r,d) (r).fc_q45_cong_portmap_0123[0] = d
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_GET(r) (r).fc_q45_cong_portmap_0123[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET(r) (((r).fc_q45_cong_portmap_0123[0]) & 0xff)
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET(r,f) (r).fc_q45_cong_portmap_0123[0]=(((r).fc_q45_cong_portmap_0123[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET(r) ((((r).fc_q45_cong_portmap_0123[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET(r,f) (r).fc_q45_cong_portmap_0123[0]=(((r).fc_q45_cong_portmap_0123[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_0123.
 *
 */
#define BCM53115_A0_READ_FC_Q45_CONG_PORTMAP_0123r(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r,(r._fc_q45_cong_portmap_0123),2)
#define BCM53115_A0_WRITE_FC_Q45_CONG_PORTMAP_0123r(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r,&(r._fc_q45_cong_portmap_0123),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_0123r BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r
#define FC_Q45_CONG_PORTMAP_0123r_SIZE BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_SIZE
typedef BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_t FC_Q45_CONG_PORTMAP_0123r_t;
#define FC_Q45_CONG_PORTMAP_0123r_CLR BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CLR
#define FC_Q45_CONG_PORTMAP_0123r_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_SET
#define FC_Q45_CONG_PORTMAP_0123r_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET
#define READ_FC_Q45_CONG_PORTMAP_0123r BCM53115_A0_READ_FC_Q45_CONG_PORTMAP_0123r
#define WRITE_FC_Q45_CONG_PORTMAP_0123r BCM53115_A0_WRITE_FC_Q45_CONG_PORTMAP_0123r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_Q45_CONG_PORTMAP_0123r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_4567
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 4,5,6,7 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP45   
 *     CONG_PORTMAP67   Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r 0x00000ad2

#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_4567.
 *
 */
typedef union BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_4567[1];
	uint32_t _fc_q45_cong_portmap_4567;
} BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_t;

#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CLR(r) (r).fc_q45_cong_portmap_4567[0] = 0
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_SET(r,d) (r).fc_q45_cong_portmap_4567[0] = d
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_GET(r) (r).fc_q45_cong_portmap_4567[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET(r) (((r).fc_q45_cong_portmap_4567[0]) & 0xff)
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET(r,f) (r).fc_q45_cong_portmap_4567[0]=(((r).fc_q45_cong_portmap_4567[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET(r) ((((r).fc_q45_cong_portmap_4567[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET(r,f) (r).fc_q45_cong_portmap_4567[0]=(((r).fc_q45_cong_portmap_4567[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_4567.
 *
 */
#define BCM53115_A0_READ_FC_Q45_CONG_PORTMAP_4567r(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r,(r._fc_q45_cong_portmap_4567),2)
#define BCM53115_A0_WRITE_FC_Q45_CONG_PORTMAP_4567r(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r,&(r._fc_q45_cong_portmap_4567),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_4567r BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r
#define FC_Q45_CONG_PORTMAP_4567r_SIZE BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_SIZE
typedef BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_t FC_Q45_CONG_PORTMAP_4567r_t;
#define FC_Q45_CONG_PORTMAP_4567r_CLR BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CLR
#define FC_Q45_CONG_PORTMAP_4567r_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_SET
#define FC_Q45_CONG_PORTMAP_4567r_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET
#define READ_FC_Q45_CONG_PORTMAP_4567r BCM53115_A0_READ_FC_Q45_CONG_PORTMAP_4567r
#define WRITE_FC_Q45_CONG_PORTMAP_4567r BCM53115_A0_WRITE_FC_Q45_CONG_PORTMAP_4567r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_Q45_CONG_PORTMAP_4567r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_8
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 8 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP8    
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r 0x00000ad4

#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_8.
 *
 */
typedef union BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_8[1];
	uint32_t _fc_q45_cong_portmap_8;
} BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_t;

#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_CLR(r) (r).fc_q45_cong_portmap_8[0] = 0
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_SET(r,d) (r).fc_q45_cong_portmap_8[0] = d
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_GET(r) (r).fc_q45_cong_portmap_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET(r) (((r).fc_q45_cong_portmap_8[0]) & 0xf)
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET(r,f) (r).fc_q45_cong_portmap_8[0]=(((r).fc_q45_cong_portmap_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_RESERVED_Rf_GET(r) ((((r).fc_q45_cong_portmap_8[0]) >> 4) & 0xfff)
#define BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_RESERVED_Rf_SET(r,f) (r).fc_q45_cong_portmap_8[0]=(((r).fc_q45_cong_portmap_8[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_8.
 *
 */
#define BCM53115_A0_READ_FC_Q45_CONG_PORTMAP_8r(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_Q45_CONG_PORTMAP_8r,(r._fc_q45_cong_portmap_8),2)
#define BCM53115_A0_WRITE_FC_Q45_CONG_PORTMAP_8r(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_Q45_CONG_PORTMAP_8r,&(r._fc_q45_cong_portmap_8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_8r BCM53115_A0_FC_Q45_CONG_PORTMAP_8r
#define FC_Q45_CONG_PORTMAP_8r_SIZE BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_SIZE
typedef BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_t FC_Q45_CONG_PORTMAP_8r_t;
#define FC_Q45_CONG_PORTMAP_8r_CLR BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_CLR
#define FC_Q45_CONG_PORTMAP_8r_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_SET
#define FC_Q45_CONG_PORTMAP_8r_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_GET
#define FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET
#define FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET
#define FC_Q45_CONG_PORTMAP_8r_RESERVED_Rf_GET BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_RESERVED_Rf_GET
#define FC_Q45_CONG_PORTMAP_8r_RESERVED_Rf_SET BCM53115_A0_FC_Q45_CONG_PORTMAP_8r_RESERVED_Rf_SET
#define READ_FC_Q45_CONG_PORTMAP_8r BCM53115_A0_READ_FC_Q45_CONG_PORTMAP_8r
#define WRITE_FC_Q45_CONG_PORTMAP_8r BCM53115_A0_WRITE_FC_Q45_CONG_PORTMAP_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_Q45_CONG_PORTMAP_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_RXBUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Rx Buffer Error History Register
 * SIZE:     16
 * FIELDS:
 *     RXBUF_ERR_HIS    
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_RXBUF_ERR_HISr 0x00000aa8

#define BCM53115_A0_FC_RXBUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXBUF_ERR_HIS.
 *
 */
typedef union BCM53115_A0_FC_RXBUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxbuf_err_his[1];
	uint32_t _fc_rxbuf_err_his;
} BCM53115_A0_FC_RXBUF_ERR_HISr_t;

#define BCM53115_A0_FC_RXBUF_ERR_HISr_CLR(r) (r).fc_rxbuf_err_his[0] = 0
#define BCM53115_A0_FC_RXBUF_ERR_HISr_SET(r,d) (r).fc_rxbuf_err_his[0] = d
#define BCM53115_A0_FC_RXBUF_ERR_HISr_GET(r) (r).fc_rxbuf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET(r) (((r).fc_rxbuf_err_his[0]) & 0x7ff)
#define BCM53115_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_RXBUF_ERR_HISr_RESERVED_Rf_GET(r) ((((r).fc_rxbuf_err_his[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_RXBUF_ERR_HISr_RESERVED_Rf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXBUF_ERR_HIS.
 *
 */
#define BCM53115_A0_READ_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_RXBUF_ERR_HISr,(r._fc_rxbuf_err_his),2)
#define BCM53115_A0_WRITE_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_RXBUF_ERR_HISr,&(r._fc_rxbuf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXBUF_ERR_HISr BCM53115_A0_FC_RXBUF_ERR_HISr
#define FC_RXBUF_ERR_HISr_SIZE BCM53115_A0_FC_RXBUF_ERR_HISr_SIZE
typedef BCM53115_A0_FC_RXBUF_ERR_HISr_t FC_RXBUF_ERR_HISr_t;
#define FC_RXBUF_ERR_HISr_CLR BCM53115_A0_FC_RXBUF_ERR_HISr_CLR
#define FC_RXBUF_ERR_HISr_SET BCM53115_A0_FC_RXBUF_ERR_HISr_SET
#define FC_RXBUF_ERR_HISr_GET BCM53115_A0_FC_RXBUF_ERR_HISr_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET BCM53115_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET BCM53115_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET
#define FC_RXBUF_ERR_HISr_RESERVED_Rf_GET BCM53115_A0_FC_RXBUF_ERR_HISr_RESERVED_Rf_GET
#define FC_RXBUF_ERR_HISr_RESERVED_Rf_SET BCM53115_A0_FC_RXBUF_ERR_HISr_RESERVED_Rf_SET
#define READ_FC_RXBUF_ERR_HISr BCM53115_A0_READ_FC_RXBUF_ERR_HISr
#define WRITE_FC_RXBUF_ERR_HISr BCM53115_A0_WRITE_FC_RXBUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_RXBUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_RXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     RX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     RXPAUSE_HIS      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_RXPAUSE_HISr 0x00000aa4

#define BCM53115_A0_FC_RXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXPAUSE_HIS.
 *
 */
typedef union BCM53115_A0_FC_RXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxpause_his[1];
	uint32_t _fc_rxpause_his;
} BCM53115_A0_FC_RXPAUSE_HISr_t;

#define BCM53115_A0_FC_RXPAUSE_HISr_CLR(r) (r).fc_rxpause_his[0] = 0
#define BCM53115_A0_FC_RXPAUSE_HISr_SET(r,d) (r).fc_rxpause_his[0] = d
#define BCM53115_A0_FC_RXPAUSE_HISr_GET(r) (r).fc_rxpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_GET(r) (((r).fc_rxpause_his[0]) & 0x7ff)
#define BCM53115_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_SET(r,f) (r).fc_rxpause_his[0]=(((r).fc_rxpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_RXPAUSE_HISr_RESERVED_Rf_GET(r) ((((r).fc_rxpause_his[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_RXPAUSE_HISr_RESERVED_Rf_SET(r,f) (r).fc_rxpause_his[0]=(((r).fc_rxpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXPAUSE_HIS.
 *
 */
#define BCM53115_A0_READ_FC_RXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_RXPAUSE_HISr,(r._fc_rxpause_his),2)
#define BCM53115_A0_WRITE_FC_RXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_RXPAUSE_HISr,&(r._fc_rxpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXPAUSE_HISr BCM53115_A0_FC_RXPAUSE_HISr
#define FC_RXPAUSE_HISr_SIZE BCM53115_A0_FC_RXPAUSE_HISr_SIZE
typedef BCM53115_A0_FC_RXPAUSE_HISr_t FC_RXPAUSE_HISr_t;
#define FC_RXPAUSE_HISr_CLR BCM53115_A0_FC_RXPAUSE_HISr_CLR
#define FC_RXPAUSE_HISr_SET BCM53115_A0_FC_RXPAUSE_HISr_SET
#define FC_RXPAUSE_HISr_GET BCM53115_A0_FC_RXPAUSE_HISr_GET
#define FC_RXPAUSE_HISr_RXPAUSE_HISf_GET BCM53115_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_GET
#define FC_RXPAUSE_HISr_RXPAUSE_HISf_SET BCM53115_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_SET
#define FC_RXPAUSE_HISr_RESERVED_Rf_GET BCM53115_A0_FC_RXPAUSE_HISr_RESERVED_Rf_GET
#define FC_RXPAUSE_HISr_RESERVED_Rf_SET BCM53115_A0_FC_RXPAUSE_HISr_RESERVED_Rf_SET
#define READ_FC_RXPAUSE_HISr BCM53115_A0_READ_FC_RXPAUSE_HISr
#define WRITE_FC_RXPAUSE_HISr BCM53115_A0_WRITE_FC_RXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_RXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_RX_HYST
 * BLOCKS:   SYS
 * DESC:     Rx-Base Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     RX_HYST_THRS     
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_RX_HYSTr 0x00000a54

#define BCM53115_A0_FC_RX_HYSTr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_HYST.
 *
 */
typedef union BCM53115_A0_FC_RX_HYSTr_s {
	uint32_t v[1];
	uint32_t fc_rx_hyst[1];
	uint32_t _fc_rx_hyst;
} BCM53115_A0_FC_RX_HYSTr_t;

#define BCM53115_A0_FC_RX_HYSTr_CLR(r) (r).fc_rx_hyst[0] = 0
#define BCM53115_A0_FC_RX_HYSTr_SET(r,d) (r).fc_rx_hyst[0] = d
#define BCM53115_A0_FC_RX_HYSTr_GET(r) (r).fc_rx_hyst[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET(r) (((r).fc_rx_hyst[0]) & 0xff)
#define BCM53115_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_RX_HYSTr_RESERVED_Rf_GET(r) ((((r).fc_rx_hyst[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_RX_HYSTr_RESERVED_Rf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_HYST.
 *
 */
#define BCM53115_A0_READ_FC_RX_HYSTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_RX_HYSTr,(r._fc_rx_hyst),2)
#define BCM53115_A0_WRITE_FC_RX_HYSTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_RX_HYSTr,&(r._fc_rx_hyst),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_HYSTr BCM53115_A0_FC_RX_HYSTr
#define FC_RX_HYSTr_SIZE BCM53115_A0_FC_RX_HYSTr_SIZE
typedef BCM53115_A0_FC_RX_HYSTr_t FC_RX_HYSTr_t;
#define FC_RX_HYSTr_CLR BCM53115_A0_FC_RX_HYSTr_CLR
#define FC_RX_HYSTr_SET BCM53115_A0_FC_RX_HYSTr_SET
#define FC_RX_HYSTr_GET BCM53115_A0_FC_RX_HYSTr_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_GET BCM53115_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_SET BCM53115_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET
#define FC_RX_HYSTr_RESERVED_Rf_GET BCM53115_A0_FC_RX_HYSTr_RESERVED_Rf_GET
#define FC_RX_HYSTr_RESERVED_Rf_SET BCM53115_A0_FC_RX_HYSTr_RESERVED_Rf_SET
#define READ_FC_RX_HYSTr BCM53115_A0_READ_FC_RX_HYSTr
#define WRITE_FC_RX_HYSTr BCM53115_A0_WRITE_FC_RX_HYSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_RX_HYSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_RX_MAX_PTR
 * BLOCKS:   SYS
 * DESC:     Rx-Base Max-Buffer Remap Register
 * SIZE:     16
 * FIELDS:
 *     MAXBUF_REMAP     Max_Buffer_ReMap Value.
 *     RESERVED_R       Reserved.
 *     EN_REMAP         Enable remap.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_RX_MAX_PTRr 0x00000a56

#define BCM53115_A0_FC_RX_MAX_PTRr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_MAX_PTR.
 *
 */
typedef union BCM53115_A0_FC_RX_MAX_PTRr_s {
	uint32_t v[1];
	uint32_t fc_rx_max_ptr[1];
	uint32_t _fc_rx_max_ptr;
} BCM53115_A0_FC_RX_MAX_PTRr_t;

#define BCM53115_A0_FC_RX_MAX_PTRr_CLR(r) (r).fc_rx_max_ptr[0] = 0
#define BCM53115_A0_FC_RX_MAX_PTRr_SET(r,d) (r).fc_rx_max_ptr[0] = d
#define BCM53115_A0_FC_RX_MAX_PTRr_GET(r) (r).fc_rx_max_ptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET(r) (((r).fc_rx_max_ptr[0]) & 0x7ff)
#define BCM53115_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_RX_MAX_PTRr_RESERVED_Rf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 11) & 0xf)
#define BCM53115_A0_FC_RX_MAX_PTRr_RESERVED_Rf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53115_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 15) & 0x1)
#define BCM53115_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FC_RX_MAX_PTR.
 *
 */
#define BCM53115_A0_READ_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_RX_MAX_PTRr,(r._fc_rx_max_ptr),2)
#define BCM53115_A0_WRITE_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_RX_MAX_PTRr,&(r._fc_rx_max_ptr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_MAX_PTRr BCM53115_A0_FC_RX_MAX_PTRr
#define FC_RX_MAX_PTRr_SIZE BCM53115_A0_FC_RX_MAX_PTRr_SIZE
typedef BCM53115_A0_FC_RX_MAX_PTRr_t FC_RX_MAX_PTRr_t;
#define FC_RX_MAX_PTRr_CLR BCM53115_A0_FC_RX_MAX_PTRr_CLR
#define FC_RX_MAX_PTRr_SET BCM53115_A0_FC_RX_MAX_PTRr_SET
#define FC_RX_MAX_PTRr_GET BCM53115_A0_FC_RX_MAX_PTRr_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET BCM53115_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET BCM53115_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET
#define FC_RX_MAX_PTRr_RESERVED_Rf_GET BCM53115_A0_FC_RX_MAX_PTRr_RESERVED_Rf_GET
#define FC_RX_MAX_PTRr_RESERVED_Rf_SET BCM53115_A0_FC_RX_MAX_PTRr_RESERVED_Rf_SET
#define FC_RX_MAX_PTRr_EN_REMAPf_GET BCM53115_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET
#define FC_RX_MAX_PTRr_EN_REMAPf_SET BCM53115_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET
#define READ_FC_RX_MAX_PTRr BCM53115_A0_READ_FC_RX_MAX_PTRr
#define WRITE_FC_RX_MAX_PTRr BCM53115_A0_WRITE_FC_RX_MAX_PTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_RX_MAX_PTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_RX_RSRV
 * BLOCKS:   SYS
 * DESC:     Rx-Base Reserved Register
 * SIZE:     16
 * FIELDS:
 *     RESV_CTRL        
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_RX_RSRVr 0x00000a52

#define BCM53115_A0_FC_RX_RSRVr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RSRV.
 *
 */
typedef union BCM53115_A0_FC_RX_RSRVr_s {
	uint32_t v[1];
	uint32_t fc_rx_rsrv[1];
	uint32_t _fc_rx_rsrv;
} BCM53115_A0_FC_RX_RSRVr_t;

#define BCM53115_A0_FC_RX_RSRVr_CLR(r) (r).fc_rx_rsrv[0] = 0
#define BCM53115_A0_FC_RX_RSRVr_SET(r,d) (r).fc_rx_rsrv[0] = d
#define BCM53115_A0_FC_RX_RSRVr_GET(r) (r).fc_rx_rsrv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_RX_RSRVr_RESV_CTRLf_GET(r) (((r).fc_rx_rsrv[0]) & 0xff)
#define BCM53115_A0_FC_RX_RSRVr_RESV_CTRLf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_RX_RSRVr_RESERVED_Rf_GET(r) ((((r).fc_rx_rsrv[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_RX_RSRVr_RESERVED_Rf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RSRV.
 *
 */
#define BCM53115_A0_READ_FC_RX_RSRVr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_RX_RSRVr,(r._fc_rx_rsrv),2)
#define BCM53115_A0_WRITE_FC_RX_RSRVr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_RX_RSRVr,&(r._fc_rx_rsrv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RSRVr BCM53115_A0_FC_RX_RSRVr
#define FC_RX_RSRVr_SIZE BCM53115_A0_FC_RX_RSRVr_SIZE
typedef BCM53115_A0_FC_RX_RSRVr_t FC_RX_RSRVr_t;
#define FC_RX_RSRVr_CLR BCM53115_A0_FC_RX_RSRVr_CLR
#define FC_RX_RSRVr_SET BCM53115_A0_FC_RX_RSRVr_SET
#define FC_RX_RSRVr_GET BCM53115_A0_FC_RX_RSRVr_GET
#define FC_RX_RSRVr_RESV_CTRLf_GET BCM53115_A0_FC_RX_RSRVr_RESV_CTRLf_GET
#define FC_RX_RSRVr_RESV_CTRLf_SET BCM53115_A0_FC_RX_RSRVr_RESV_CTRLf_SET
#define FC_RX_RSRVr_RESERVED_Rf_GET BCM53115_A0_FC_RX_RSRVr_RESERVED_Rf_GET
#define FC_RX_RSRVr_RESERVED_Rf_SET BCM53115_A0_FC_RX_RSRVr_RESERVED_Rf_SET
#define READ_FC_RX_RSRVr BCM53115_A0_READ_FC_RX_RSRVr
#define WRITE_FC_RX_RSRVr BCM53115_A0_WRITE_FC_RX_RSRVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_RX_RSRVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_RX_RUNOFF
 * BLOCKS:   SYS
 * DESC:     Rx-Base Run-Off Register
 * SIZE:     16
 * FIELDS:
 *     RUN_OFF          
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_RX_RUNOFFr 0x00000a50

#define BCM53115_A0_FC_RX_RUNOFFr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RUNOFF.
 *
 */
typedef union BCM53115_A0_FC_RX_RUNOFFr_s {
	uint32_t v[1];
	uint32_t fc_rx_runoff[1];
	uint32_t _fc_rx_runoff;
} BCM53115_A0_FC_RX_RUNOFFr_t;

#define BCM53115_A0_FC_RX_RUNOFFr_CLR(r) (r).fc_rx_runoff[0] = 0
#define BCM53115_A0_FC_RX_RUNOFFr_SET(r,d) (r).fc_rx_runoff[0] = d
#define BCM53115_A0_FC_RX_RUNOFFr_GET(r) (r).fc_rx_runoff[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_RX_RUNOFFr_RUN_OFFf_GET(r) (((r).fc_rx_runoff[0]) & 0xff)
#define BCM53115_A0_FC_RX_RUNOFFr_RUN_OFFf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_FC_RX_RUNOFFr_RESERVED_Rf_GET(r) ((((r).fc_rx_runoff[0]) >> 8) & 0xff)
#define BCM53115_A0_FC_RX_RUNOFFr_RESERVED_Rf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RUNOFF.
 *
 */
#define BCM53115_A0_READ_FC_RX_RUNOFFr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_RX_RUNOFFr,(r._fc_rx_runoff),2)
#define BCM53115_A0_WRITE_FC_RX_RUNOFFr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_RX_RUNOFFr,&(r._fc_rx_runoff),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RUNOFFr BCM53115_A0_FC_RX_RUNOFFr
#define FC_RX_RUNOFFr_SIZE BCM53115_A0_FC_RX_RUNOFFr_SIZE
typedef BCM53115_A0_FC_RX_RUNOFFr_t FC_RX_RUNOFFr_t;
#define FC_RX_RUNOFFr_CLR BCM53115_A0_FC_RX_RUNOFFr_CLR
#define FC_RX_RUNOFFr_SET BCM53115_A0_FC_RX_RUNOFFr_SET
#define FC_RX_RUNOFFr_GET BCM53115_A0_FC_RX_RUNOFFr_GET
#define FC_RX_RUNOFFr_RUN_OFFf_GET BCM53115_A0_FC_RX_RUNOFFr_RUN_OFFf_GET
#define FC_RX_RUNOFFr_RUN_OFFf_SET BCM53115_A0_FC_RX_RUNOFFr_RUN_OFFf_SET
#define FC_RX_RUNOFFr_RESERVED_Rf_GET BCM53115_A0_FC_RX_RUNOFFr_RESERVED_Rf_GET
#define FC_RX_RUNOFFr_RESERVED_Rf_SET BCM53115_A0_FC_RX_RUNOFFr_RESERVED_Rf_SET
#define READ_FC_RX_RUNOFFr BCM53115_A0_READ_FC_RX_RUNOFFr
#define WRITE_FC_RX_RUNOFFr BCM53115_A0_WRITE_FC_RX_RUNOFFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_RX_RUNOFFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_SPARE_REG
 * BLOCKS:   SYS
 * DESC:     Spare Registers
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_SPARE_REGr 0x00000a58

#define BCM53115_A0_FC_SPARE_REGr_SIZE 2

/*
 * This structure should be used to declare and program FC_SPARE_REG.
 *
 */
typedef union BCM53115_A0_FC_SPARE_REGr_s {
	uint32_t v[1];
	uint32_t fc_spare_reg[1];
	uint32_t _fc_spare_reg;
} BCM53115_A0_FC_SPARE_REGr_t;

#define BCM53115_A0_FC_SPARE_REGr_CLR(r) (r).fc_spare_reg[0] = 0
#define BCM53115_A0_FC_SPARE_REGr_SET(r,d) (r).fc_spare_reg[0] = d
#define BCM53115_A0_FC_SPARE_REGr_GET(r) (r).fc_spare_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_SPARE_REGr_RESERVED_Rf_GET(r) (((r).fc_spare_reg[0]) & 0xffff)
#define BCM53115_A0_FC_SPARE_REGr_RESERVED_Rf_SET(r,f) (r).fc_spare_reg[0]=(((r).fc_spare_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FC_SPARE_REG.
 *
 */
#define BCM53115_A0_READ_FC_SPARE_REGr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_SPARE_REGr+(2*(i)),(r._fc_spare_reg),2)
#define BCM53115_A0_WRITE_FC_SPARE_REGr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_SPARE_REGr+(2*(i)),&(r._fc_spare_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_SPARE_REGr BCM53115_A0_FC_SPARE_REGr
#define FC_SPARE_REGr_SIZE BCM53115_A0_FC_SPARE_REGr_SIZE
typedef BCM53115_A0_FC_SPARE_REGr_t FC_SPARE_REGr_t;
#define FC_SPARE_REGr_CLR BCM53115_A0_FC_SPARE_REGr_CLR
#define FC_SPARE_REGr_SET BCM53115_A0_FC_SPARE_REGr_SET
#define FC_SPARE_REGr_GET BCM53115_A0_FC_SPARE_REGr_GET
#define FC_SPARE_REGr_RESERVED_Rf_GET BCM53115_A0_FC_SPARE_REGr_RESERVED_Rf_GET
#define FC_SPARE_REGr_RESERVED_Rf_SET BCM53115_A0_FC_SPARE_REGr_RESERVED_Rf_SET
#define READ_FC_SPARE_REGr BCM53115_A0_READ_FC_SPARE_REGr
#define WRITE_FC_SPARE_REGr BCM53115_A0_WRITE_FC_SPARE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_SPARE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr 0x00000a38

#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q[1];
	uint32_t _fc_total_th_drop_q;
} BCM53115_A0_FC_TOTAL_TH_DROP_Qr_t;

#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr_CLR(r) (r).fc_total_th_drop_q[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr_SET(r,d) (r).fc_total_th_drop_q[0] = d
#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr_GET(r) (r).fc_total_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q[0]) & 0x7ff)
#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_GET(r) ((((r).fc_total_th_drop_q[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),(r._fc_total_th_drop_q),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),&(r._fc_total_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Qr BCM53115_A0_FC_TOTAL_TH_DROP_Qr
#define FC_TOTAL_TH_DROP_Qr_SIZE BCM53115_A0_FC_TOTAL_TH_DROP_Qr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_DROP_Qr_t FC_TOTAL_TH_DROP_Qr_t;
#define FC_TOTAL_TH_DROP_Qr_CLR BCM53115_A0_FC_TOTAL_TH_DROP_Qr_CLR
#define FC_TOTAL_TH_DROP_Qr_SET BCM53115_A0_FC_TOTAL_TH_DROP_Qr_SET
#define FC_TOTAL_TH_DROP_Qr_GET BCM53115_A0_FC_TOTAL_TH_DROP_Qr_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET BCM53115_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET BCM53115_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_GET
#define FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_DROP_Qr BCM53115_A0_READ_FC_TOTAL_TH_DROP_Qr
#define WRITE_FC_TOTAL_TH_DROP_Qr BCM53115_A0_WRITE_FC_TOTAL_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q45
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r 0x00000ac4

#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q45.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q45[1];
	uint32_t _fc_total_th_drop_q45;
} BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_t;

#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_CLR(r) (r).fc_total_th_drop_q45[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_SET(r,d) (r).fc_total_th_drop_q45[0] = d
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_GET(r) (r).fc_total_th_drop_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q45[0]) & 0x7ff)
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q45[0]=(((r).fc_total_th_drop_q45[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_RESERVED_Rf_GET(r) ((((r).fc_total_th_drop_q45[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_RESERVED_Rf_SET(r,f) (r).fc_total_th_drop_q45[0]=(((r).fc_total_th_drop_q45[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q45.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_DROP_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_DROP_Q45r+(2*(i)),(r._fc_total_th_drop_q45),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_DROP_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_DROP_Q45r+(2*(i)),&(r._fc_total_th_drop_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q45r BCM53115_A0_FC_TOTAL_TH_DROP_Q45r
#define FC_TOTAL_TH_DROP_Q45r_SIZE BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_t FC_TOTAL_TH_DROP_Q45r_t;
#define FC_TOTAL_TH_DROP_Q45r_CLR BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_CLR
#define FC_TOTAL_TH_DROP_Q45r_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_SET
#define FC_TOTAL_TH_DROP_Q45r_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_GET
#define FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q45r_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_RESERVED_Rf_GET
#define FC_TOTAL_TH_DROP_Q45r_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q45r_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_DROP_Q45r BCM53115_A0_READ_FC_TOTAL_TH_DROP_Q45r
#define WRITE_FC_TOTAL_TH_DROP_Q45r BCM53115_A0_WRITE_FC_TOTAL_TH_DROP_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_DROP_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr 0x00000d38

#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q_IMP.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q_imp[1];
	uint32_t _fc_total_th_drop_q_imp;
} BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_t;

#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_CLR(r) (r).fc_total_th_drop_q_imp[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_SET(r,d) (r).fc_total_th_drop_q_imp[0] = d
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_GET(r) (r).fc_total_th_drop_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q_imp[0]) & 0x7ff)
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q_imp[0]=(((r).fc_total_th_drop_q_imp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVED_Rf_GET(r) ((((r).fc_total_th_drop_q_imp[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVED_Rf_SET(r,f) (r).fc_total_th_drop_q_imp[0]=(((r).fc_total_th_drop_q_imp[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q_IMP.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr+(2*(i)),(r._fc_total_th_drop_q_imp),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr+(2*(i)),&(r._fc_total_th_drop_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q_IMPr BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr
#define FC_TOTAL_TH_DROP_Q_IMPr_SIZE BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_t FC_TOTAL_TH_DROP_Q_IMPr_t;
#define FC_TOTAL_TH_DROP_Q_IMPr_CLR BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_CLR
#define FC_TOTAL_TH_DROP_Q_IMPr_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_SET
#define FC_TOTAL_TH_DROP_Q_IMPr_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q_IMPr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVED_Rf_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_DROP_Q_IMPr BCM53115_A0_READ_FC_TOTAL_TH_DROP_Q_IMPr
#define WRITE_FC_TOTAL_TH_DROP_Q_IMPr BCM53115_A0_WRITE_FC_TOTAL_TH_DROP_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_DROP_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr 0x00000e38

#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q_WAN.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q_wan[1];
	uint32_t _fc_total_th_drop_q_wan;
} BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_t;

#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_CLR(r) (r).fc_total_th_drop_q_wan[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_SET(r,d) (r).fc_total_th_drop_q_wan[0] = d
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_GET(r) (r).fc_total_th_drop_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q_wan[0]) & 0x7ff)
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q_wan[0]=(((r).fc_total_th_drop_q_wan[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVED_Rf_GET(r) ((((r).fc_total_th_drop_q_wan[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVED_Rf_SET(r,f) (r).fc_total_th_drop_q_wan[0]=(((r).fc_total_th_drop_q_wan[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q_WAN.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr+(2*(i)),(r._fc_total_th_drop_q_wan),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr+(2*(i)),&(r._fc_total_th_drop_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q_WANr BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr
#define FC_TOTAL_TH_DROP_Q_WANr_SIZE BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_t FC_TOTAL_TH_DROP_Q_WANr_t;
#define FC_TOTAL_TH_DROP_Q_WANr_CLR BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_CLR
#define FC_TOTAL_TH_DROP_Q_WANr_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_SET
#define FC_TOTAL_TH_DROP_Q_WANr_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_GET
#define FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q_WANr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVED_Rf_GET
#define FC_TOTAL_TH_DROP_Q_WANr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_DROP_Q_WANr BCM53115_A0_READ_FC_TOTAL_TH_DROP_Q_WANr
#define WRITE_FC_TOTAL_TH_DROP_Q_WANr BCM53115_A0_WRITE_FC_TOTAL_TH_DROP_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_DROP_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr 0x00000a28

#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_HYST_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q[1];
	uint32_t _fc_total_th_hyst_q;
} BCM53115_A0_FC_TOTAL_TH_HYST_Qr_t;

#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr_CLR(r) (r).fc_total_th_hyst_q[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr_SET(r,d) (r).fc_total_th_hyst_q[0] = d
#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr_GET(r) (r).fc_total_th_hyst_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_GET(r) ((((r).fc_total_th_hyst_q[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),(r._fc_total_th_hyst_q),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),&(r._fc_total_th_hyst_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Qr BCM53115_A0_FC_TOTAL_TH_HYST_Qr
#define FC_TOTAL_TH_HYST_Qr_SIZE BCM53115_A0_FC_TOTAL_TH_HYST_Qr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_HYST_Qr_t FC_TOTAL_TH_HYST_Qr_t;
#define FC_TOTAL_TH_HYST_Qr_CLR BCM53115_A0_FC_TOTAL_TH_HYST_Qr_CLR
#define FC_TOTAL_TH_HYST_Qr_SET BCM53115_A0_FC_TOTAL_TH_HYST_Qr_SET
#define FC_TOTAL_TH_HYST_Qr_GET BCM53115_A0_FC_TOTAL_TH_HYST_Qr_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET BCM53115_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET BCM53115_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_GET
#define FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_HYST_Qr BCM53115_A0_READ_FC_TOTAL_TH_HYST_Qr
#define WRITE_FC_TOTAL_TH_HYST_Qr BCM53115_A0_WRITE_FC_TOTAL_TH_HYST_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_HYST_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q45
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r 0x00000abc

#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q45.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q45[1];
	uint32_t _fc_total_th_hyst_q45;
} BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_t;

#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_CLR(r) (r).fc_total_th_hyst_q45[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_SET(r,d) (r).fc_total_th_hyst_q45[0] = d
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_GET(r) (r).fc_total_th_hyst_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q45[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q45[0]=(((r).fc_total_th_hyst_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_RESERVED_Rf_GET(r) ((((r).fc_total_th_hyst_q45[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_RESERVED_Rf_SET(r,f) (r).fc_total_th_hyst_q45[0]=(((r).fc_total_th_hyst_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q45.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_HYST_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_HYST_Q45r+(2*(i)),(r._fc_total_th_hyst_q45),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_HYST_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_HYST_Q45r+(2*(i)),&(r._fc_total_th_hyst_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q45r BCM53115_A0_FC_TOTAL_TH_HYST_Q45r
#define FC_TOTAL_TH_HYST_Q45r_SIZE BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_t FC_TOTAL_TH_HYST_Q45r_t;
#define FC_TOTAL_TH_HYST_Q45r_CLR BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_CLR
#define FC_TOTAL_TH_HYST_Q45r_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_SET
#define FC_TOTAL_TH_HYST_Q45r_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_GET
#define FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q45r_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_RESERVED_Rf_GET
#define FC_TOTAL_TH_HYST_Q45r_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q45r_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_HYST_Q45r BCM53115_A0_READ_FC_TOTAL_TH_HYST_Q45r
#define WRITE_FC_TOTAL_TH_HYST_Q45r BCM53115_A0_WRITE_FC_TOTAL_TH_HYST_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_HYST_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr 0x00000d28

#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q_IMP.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q_imp[1];
	uint32_t _fc_total_th_hyst_q_imp;
} BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_t;

#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_CLR(r) (r).fc_total_th_hyst_q_imp[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_SET(r,d) (r).fc_total_th_hyst_q_imp[0] = d
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_GET(r) (r).fc_total_th_hyst_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q_imp[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q_imp[0]=(((r).fc_total_th_hyst_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVED_Rf_GET(r) ((((r).fc_total_th_hyst_q_imp[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVED_Rf_SET(r,f) (r).fc_total_th_hyst_q_imp[0]=(((r).fc_total_th_hyst_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q_IMP.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_HYST_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr+(2*(i)),(r._fc_total_th_hyst_q_imp),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_HYST_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr+(2*(i)),&(r._fc_total_th_hyst_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q_IMPr BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr
#define FC_TOTAL_TH_HYST_Q_IMPr_SIZE BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_t FC_TOTAL_TH_HYST_Q_IMPr_t;
#define FC_TOTAL_TH_HYST_Q_IMPr_CLR BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_CLR
#define FC_TOTAL_TH_HYST_Q_IMPr_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_SET
#define FC_TOTAL_TH_HYST_Q_IMPr_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q_IMPr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVED_Rf_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_HYST_Q_IMPr BCM53115_A0_READ_FC_TOTAL_TH_HYST_Q_IMPr
#define WRITE_FC_TOTAL_TH_HYST_Q_IMPr BCM53115_A0_WRITE_FC_TOTAL_TH_HYST_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_HYST_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr 0x00000e28

#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q_WAN.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q_wan[1];
	uint32_t _fc_total_th_hyst_q_wan;
} BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_t;

#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_CLR(r) (r).fc_total_th_hyst_q_wan[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_SET(r,d) (r).fc_total_th_hyst_q_wan[0] = d
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_GET(r) (r).fc_total_th_hyst_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q_wan[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q_wan[0]=(((r).fc_total_th_hyst_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVED_Rf_GET(r) ((((r).fc_total_th_hyst_q_wan[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVED_Rf_SET(r,f) (r).fc_total_th_hyst_q_wan[0]=(((r).fc_total_th_hyst_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q_WAN.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_HYST_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr+(2*(i)),(r._fc_total_th_hyst_q_wan),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_HYST_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr+(2*(i)),&(r._fc_total_th_hyst_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q_WANr BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr
#define FC_TOTAL_TH_HYST_Q_WANr_SIZE BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_t FC_TOTAL_TH_HYST_Q_WANr_t;
#define FC_TOTAL_TH_HYST_Q_WANr_CLR BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_CLR
#define FC_TOTAL_TH_HYST_Q_WANr_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_SET
#define FC_TOTAL_TH_HYST_Q_WANr_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_GET
#define FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q_WANr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVED_Rf_GET
#define FC_TOTAL_TH_HYST_Q_WANr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_HYST_Q_WANr BCM53115_A0_READ_FC_TOTAL_TH_HYST_Q_WANr
#define WRITE_FC_TOTAL_TH_HYST_Q_WANr BCM53115_A0_WRITE_FC_TOTAL_TH_HYST_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_HYST_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS if QOS is on, default is 290.if QOS is off, default is 416.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr 0x00000a30

#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q[1];
	uint32_t _fc_total_th_pause_q;
} BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_t;

#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_CLR(r) (r).fc_total_th_pause_q[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_SET(r,d) (r).fc_total_th_pause_q[0] = d
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_GET(r) (r).fc_total_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_GET(r) ((((r).fc_total_th_pause_q[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),(r._fc_total_th_pause_q),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),&(r._fc_total_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Qr BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr
#define FC_TOTAL_TH_PAUSE_Qr_SIZE BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_t FC_TOTAL_TH_PAUSE_Qr_t;
#define FC_TOTAL_TH_PAUSE_Qr_CLR BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_CLR
#define FC_TOTAL_TH_PAUSE_Qr_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_SET
#define FC_TOTAL_TH_PAUSE_Qr_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_GET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_PAUSE_Qr BCM53115_A0_READ_FC_TOTAL_TH_PAUSE_Qr
#define WRITE_FC_TOTAL_TH_PAUSE_Qr BCM53115_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q45
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS if QOS is on, default is 290.if QOS is off, default is 416.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r 0x00000ac0

#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q45.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q45[1];
	uint32_t _fc_total_th_pause_q45;
} BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_t;

#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_CLR(r) (r).fc_total_th_pause_q45[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_SET(r,d) (r).fc_total_th_pause_q45[0] = d
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_GET(r) (r).fc_total_th_pause_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q45[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q45[0]=(((r).fc_total_th_pause_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVED_Rf_GET(r) ((((r).fc_total_th_pause_q45[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVED_Rf_SET(r,f) (r).fc_total_th_pause_q45[0]=(((r).fc_total_th_pause_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q45.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r+(2*(i)),(r._fc_total_th_pause_q45),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r+(2*(i)),&(r._fc_total_th_pause_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q45r BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r
#define FC_TOTAL_TH_PAUSE_Q45r_SIZE BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_t FC_TOTAL_TH_PAUSE_Q45r_t;
#define FC_TOTAL_TH_PAUSE_Q45r_CLR BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_CLR
#define FC_TOTAL_TH_PAUSE_Q45r_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_SET
#define FC_TOTAL_TH_PAUSE_Q45r_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_GET
#define FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q45r_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVED_Rf_GET
#define FC_TOTAL_TH_PAUSE_Q45r_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q45r BCM53115_A0_READ_FC_TOTAL_TH_PAUSE_Q45r
#define WRITE_FC_TOTAL_TH_PAUSE_Q45r BCM53115_A0_WRITE_FC_TOTAL_TH_PAUSE_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_PAUSE_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS if QOS is on, default is 290.if QOS is off, default is 416.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr 0x00000d30

#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q_IMP.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q_imp[1];
	uint32_t _fc_total_th_pause_q_imp;
} BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_t;

#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_CLR(r) (r).fc_total_th_pause_q_imp[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SET(r,d) (r).fc_total_th_pause_q_imp[0] = d
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_GET(r) (r).fc_total_th_pause_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q_imp[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q_imp[0]=(((r).fc_total_th_pause_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVED_Rf_GET(r) ((((r).fc_total_th_pause_q_imp[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVED_Rf_SET(r,f) (r).fc_total_th_pause_q_imp[0]=(((r).fc_total_th_pause_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q_IMP.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr+(2*(i)),(r._fc_total_th_pause_q_imp),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr+(2*(i)),&(r._fc_total_th_pause_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q_IMPr BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr
#define FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_t FC_TOTAL_TH_PAUSE_Q_IMPr_t;
#define FC_TOTAL_TH_PAUSE_Q_IMPr_CLR BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_CLR
#define FC_TOTAL_TH_PAUSE_Q_IMPr_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVED_Rf_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q_IMPr BCM53115_A0_READ_FC_TOTAL_TH_PAUSE_Q_IMPr
#define WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr BCM53115_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS if QOS is on, default is 290.if QOS is off, default is 416.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr 0x00000e30

#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q_WAN.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q_wan[1];
	uint32_t _fc_total_th_pause_q_wan;
} BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_t;

#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_CLR(r) (r).fc_total_th_pause_q_wan[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SET(r,d) (r).fc_total_th_pause_q_wan[0] = d
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_GET(r) (r).fc_total_th_pause_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q_wan[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q_wan[0]=(((r).fc_total_th_pause_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVED_Rf_GET(r) ((((r).fc_total_th_pause_q_wan[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVED_Rf_SET(r,f) (r).fc_total_th_pause_q_wan[0]=(((r).fc_total_th_pause_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q_WAN.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr+(2*(i)),(r._fc_total_th_pause_q_wan),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr+(2*(i)),&(r._fc_total_th_pause_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q_WANr BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr
#define FC_TOTAL_TH_PAUSE_Q_WANr_SIZE BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_t FC_TOTAL_TH_PAUSE_Q_WANr_t;
#define FC_TOTAL_TH_PAUSE_Q_WANr_CLR BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_CLR
#define FC_TOTAL_TH_PAUSE_Q_WANr_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SET
#define FC_TOTAL_TH_PAUSE_Q_WANr_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q_WANr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVED_Rf_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q_WANr BCM53115_A0_READ_FC_TOTAL_TH_PAUSE_Q_WANr
#define WRITE_FC_TOTAL_TH_PAUSE_Q_WANr BCM53115_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_PAUSE_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Total Reserved Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_RSRV_THRS if QOS is off, default is 512.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr 0x00000a40

#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_RSRV_Q.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_rsrv_q[1];
	uint32_t _fc_total_th_rsrv_q;
} BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_t;

#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_CLR(r) (r).fc_total_th_rsrv_q[0] = 0
#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_SET(r,d) (r).fc_total_th_rsrv_q[0] = d
#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_GET(r) (r).fc_total_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET(r) (((r).fc_total_th_rsrv_q[0]) & 0x3ff)
#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET(r,f) (r).fc_total_th_rsrv_q[0]=(((r).fc_total_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_RESERVED_Rf_GET(r) ((((r).fc_total_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_RESERVED_Rf_SET(r,f) (r).fc_total_th_rsrv_q[0]=(((r).fc_total_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_RSRV_Q.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_TH_RSRV_Qr+(2*(i)),(r._fc_total_th_rsrv_q),2)
#define BCM53115_A0_WRITE_FC_TOTAL_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_TH_RSRV_Qr+(2*(i)),&(r._fc_total_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_RSRV_Qr BCM53115_A0_FC_TOTAL_TH_RSRV_Qr
#define FC_TOTAL_TH_RSRV_Qr_SIZE BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_SIZE
typedef BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_t FC_TOTAL_TH_RSRV_Qr_t;
#define FC_TOTAL_TH_RSRV_Qr_CLR BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_CLR
#define FC_TOTAL_TH_RSRV_Qr_SET BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_SET
#define FC_TOTAL_TH_RSRV_Qr_GET BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_GET
#define FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET
#define FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET
#define FC_TOTAL_TH_RSRV_Qr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_RESERVED_Rf_GET
#define FC_TOTAL_TH_RSRV_Qr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_TH_RSRV_Qr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_RSRV_Qr BCM53115_A0_READ_FC_TOTAL_TH_RSRV_Qr
#define WRITE_FC_TOTAL_TH_RSRV_Qr BCM53115_A0_WRITE_FC_TOTAL_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_USE        Total Used count.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TOTAL_USEDr 0x00000a82

#define BCM53115_A0_FC_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_USED.
 *
 */
typedef union BCM53115_A0_FC_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_total_used[1];
	uint32_t _fc_total_used;
} BCM53115_A0_FC_TOTAL_USEDr_t;

#define BCM53115_A0_FC_TOTAL_USEDr_CLR(r) (r).fc_total_used[0] = 0
#define BCM53115_A0_FC_TOTAL_USEDr_SET(r,d) (r).fc_total_used[0] = d
#define BCM53115_A0_FC_TOTAL_USEDr_GET(r) (r).fc_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TOTAL_USEDr_TOTAL_USEf_GET(r) (((r).fc_total_used[0]) & 0x7ff)
#define BCM53115_A0_FC_TOTAL_USEDr_TOTAL_USEf_SET(r,f) (r).fc_total_used[0]=(((r).fc_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_TOTAL_USEDr_RESERVED_Rf_GET(r) ((((r).fc_total_used[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_TOTAL_USEDr_RESERVED_Rf_SET(r,f) (r).fc_total_used[0]=(((r).fc_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_USED.
 *
 */
#define BCM53115_A0_READ_FC_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TOTAL_USEDr,(r._fc_total_used),2)
#define BCM53115_A0_WRITE_FC_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TOTAL_USEDr,&(r._fc_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_USEDr BCM53115_A0_FC_TOTAL_USEDr
#define FC_TOTAL_USEDr_SIZE BCM53115_A0_FC_TOTAL_USEDr_SIZE
typedef BCM53115_A0_FC_TOTAL_USEDr_t FC_TOTAL_USEDr_t;
#define FC_TOTAL_USEDr_CLR BCM53115_A0_FC_TOTAL_USEDr_CLR
#define FC_TOTAL_USEDr_SET BCM53115_A0_FC_TOTAL_USEDr_SET
#define FC_TOTAL_USEDr_GET BCM53115_A0_FC_TOTAL_USEDr_GET
#define FC_TOTAL_USEDr_TOTAL_USEf_GET BCM53115_A0_FC_TOTAL_USEDr_TOTAL_USEf_GET
#define FC_TOTAL_USEDr_TOTAL_USEf_SET BCM53115_A0_FC_TOTAL_USEDr_TOTAL_USEf_SET
#define FC_TOTAL_USEDr_RESERVED_Rf_GET BCM53115_A0_FC_TOTAL_USEDr_RESERVED_Rf_GET
#define FC_TOTAL_USEDr_RESERVED_Rf_SET BCM53115_A0_FC_TOTAL_USEDr_RESERVED_Rf_SET
#define READ_FC_TOTAL_USEDr BCM53115_A0_READ_FC_TOTAL_USEDr
#define WRITE_FC_TOTAL_USEDr BCM53115_A0_WRITE_FC_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     TX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     TXPAUSE_HIS      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXPAUSE_HISr 0x00000aa2

#define BCM53115_A0_FC_TXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXPAUSE_HIS.
 *
 */
typedef union BCM53115_A0_FC_TXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_txpause_his[1];
	uint32_t _fc_txpause_his;
} BCM53115_A0_FC_TXPAUSE_HISr_t;

#define BCM53115_A0_FC_TXPAUSE_HISr_CLR(r) (r).fc_txpause_his[0] = 0
#define BCM53115_A0_FC_TXPAUSE_HISr_SET(r,d) (r).fc_txpause_his[0] = d
#define BCM53115_A0_FC_TXPAUSE_HISr_GET(r) (r).fc_txpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET(r) (((r).fc_txpause_his[0]) & 0x7ff)
#define BCM53115_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53115_A0_FC_TXPAUSE_HISr_RESERVED_Rf_GET(r) ((((r).fc_txpause_his[0]) >> 11) & 0x1f)
#define BCM53115_A0_FC_TXPAUSE_HISr_RESERVED_Rf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TXPAUSE_HIS.
 *
 */
#define BCM53115_A0_READ_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXPAUSE_HISr,(r._fc_txpause_his),2)
#define BCM53115_A0_WRITE_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXPAUSE_HISr,&(r._fc_txpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXPAUSE_HISr BCM53115_A0_FC_TXPAUSE_HISr
#define FC_TXPAUSE_HISr_SIZE BCM53115_A0_FC_TXPAUSE_HISr_SIZE
typedef BCM53115_A0_FC_TXPAUSE_HISr_t FC_TXPAUSE_HISr_t;
#define FC_TXPAUSE_HISr_CLR BCM53115_A0_FC_TXPAUSE_HISr_CLR
#define FC_TXPAUSE_HISr_SET BCM53115_A0_FC_TXPAUSE_HISr_SET
#define FC_TXPAUSE_HISr_GET BCM53115_A0_FC_TXPAUSE_HISr_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_GET BCM53115_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_SET BCM53115_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET
#define FC_TXPAUSE_HISr_RESERVED_Rf_GET BCM53115_A0_FC_TXPAUSE_HISr_RESERVED_Rf_GET
#define FC_TXPAUSE_HISr_RESERVED_Rf_SET BCM53115_A0_FC_TXPAUSE_HISr_RESERVED_Rf_SET
#define READ_FC_TXPAUSE_HISr BCM53115_A0_READ_FC_TXPAUSE_HISr
#define WRITE_FC_TXPAUSE_HISr BCM53115_A0_WRITE_FC_TXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_DROP_Qr 0x00000a20

#define BCM53115_A0_FC_TXQ_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q[1];
	uint32_t _fc_txq_th_drop_q;
} BCM53115_A0_FC_TXQ_TH_DROP_Qr_t;

#define BCM53115_A0_FC_TXQ_TH_DROP_Qr_CLR(r) (r).fc_txq_th_drop_q[0] = 0
#define BCM53115_A0_FC_TXQ_TH_DROP_Qr_SET(r,d) (r).fc_txq_th_drop_q[0] = d
#define BCM53115_A0_FC_TXQ_TH_DROP_Qr_GET(r) (r).fc_txq_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_DROP_Qr_RESERVED_Rf_GET(r) ((((r).fc_txq_th_drop_q[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_DROP_Qr_RESERVED_Rf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),(r._fc_txq_th_drop_q),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),&(r._fc_txq_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Qr BCM53115_A0_FC_TXQ_TH_DROP_Qr
#define FC_TXQ_TH_DROP_Qr_SIZE BCM53115_A0_FC_TXQ_TH_DROP_Qr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_DROP_Qr_t FC_TXQ_TH_DROP_Qr_t;
#define FC_TXQ_TH_DROP_Qr_CLR BCM53115_A0_FC_TXQ_TH_DROP_Qr_CLR
#define FC_TXQ_TH_DROP_Qr_SET BCM53115_A0_FC_TXQ_TH_DROP_Qr_SET
#define FC_TXQ_TH_DROP_Qr_GET BCM53115_A0_FC_TXQ_TH_DROP_Qr_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET BCM53115_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET BCM53115_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Qr_RESERVED_Rf_GET BCM53115_A0_FC_TXQ_TH_DROP_Qr_RESERVED_Rf_GET
#define FC_TXQ_TH_DROP_Qr_RESERVED_Rf_SET BCM53115_A0_FC_TXQ_TH_DROP_Qr_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_DROP_Qr BCM53115_A0_READ_FC_TXQ_TH_DROP_Qr
#define WRITE_FC_TXQ_TH_DROP_Qr BCM53115_A0_WRITE_FC_TXQ_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Drop Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r 0x00000ab8

#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q45.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_DROP_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q45[1];
	uint32_t _fc_txq_th_drop_q45;
} BCM53115_A0_FC_TXQ_TH_DROP_Q45r_t;

#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r_CLR(r) (r).fc_txq_th_drop_q45[0] = 0
#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r_SET(r,d) (r).fc_txq_th_drop_q45[0] = d
#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r_GET(r) (r).fc_txq_th_drop_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q45[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q45[0]=(((r).fc_txq_th_drop_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r_RESERVED_Rf_GET(r) ((((r).fc_txq_th_drop_q45[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_DROP_Q45r_RESERVED_Rf_SET(r,f) (r).fc_txq_th_drop_q45[0]=(((r).fc_txq_th_drop_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q45.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_DROP_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_DROP_Q45r+(2*(i)),(r._fc_txq_th_drop_q45),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_DROP_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_DROP_Q45r+(2*(i)),&(r._fc_txq_th_drop_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q45r BCM53115_A0_FC_TXQ_TH_DROP_Q45r
#define FC_TXQ_TH_DROP_Q45r_SIZE BCM53115_A0_FC_TXQ_TH_DROP_Q45r_SIZE
typedef BCM53115_A0_FC_TXQ_TH_DROP_Q45r_t FC_TXQ_TH_DROP_Q45r_t;
#define FC_TXQ_TH_DROP_Q45r_CLR BCM53115_A0_FC_TXQ_TH_DROP_Q45r_CLR
#define FC_TXQ_TH_DROP_Q45r_SET BCM53115_A0_FC_TXQ_TH_DROP_Q45r_SET
#define FC_TXQ_TH_DROP_Q45r_GET BCM53115_A0_FC_TXQ_TH_DROP_Q45r_GET
#define FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET BCM53115_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET BCM53115_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q45r_RESERVED_Rf_GET BCM53115_A0_FC_TXQ_TH_DROP_Q45r_RESERVED_Rf_GET
#define FC_TXQ_TH_DROP_Q45r_RESERVED_Rf_SET BCM53115_A0_FC_TXQ_TH_DROP_Q45r_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_DROP_Q45r BCM53115_A0_READ_FC_TXQ_TH_DROP_Q45r
#define WRITE_FC_TXQ_TH_DROP_Q45r BCM53115_A0_WRITE_FC_TXQ_TH_DROP_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_DROP_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr 0x00000d20

#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q_IMP.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q_imp[1];
	uint32_t _fc_txq_th_drop_q_imp;
} BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_t;

#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_CLR(r) (r).fc_txq_th_drop_q_imp[0] = 0
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_SET(r,d) (r).fc_txq_th_drop_q_imp[0] = d
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_GET(r) (r).fc_txq_th_drop_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q_imp[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q_imp[0]=(((r).fc_txq_th_drop_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVED_Rf_GET(r) ((((r).fc_txq_th_drop_q_imp[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVED_Rf_SET(r,f) (r).fc_txq_th_drop_q_imp[0]=(((r).fc_txq_th_drop_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q_IMP.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr+(2*(i)),(r._fc_txq_th_drop_q_imp),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr+(2*(i)),&(r._fc_txq_th_drop_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q_IMPr BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr
#define FC_TXQ_TH_DROP_Q_IMPr_SIZE BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_t FC_TXQ_TH_DROP_Q_IMPr_t;
#define FC_TXQ_TH_DROP_Q_IMPr_CLR BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_CLR
#define FC_TXQ_TH_DROP_Q_IMPr_SET BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_SET
#define FC_TXQ_TH_DROP_Q_IMPr_GET BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_GET
#define FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q_IMPr_RESERVED_Rf_GET BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVED_Rf_GET
#define FC_TXQ_TH_DROP_Q_IMPr_RESERVED_Rf_SET BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_DROP_Q_IMPr BCM53115_A0_READ_FC_TXQ_TH_DROP_Q_IMPr
#define WRITE_FC_TXQ_TH_DROP_Q_IMPr BCM53115_A0_WRITE_FC_TXQ_TH_DROP_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_DROP_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr 0x00000e20

#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q_WAN.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q_wan[1];
	uint32_t _fc_txq_th_drop_q_wan;
} BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_t;

#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_CLR(r) (r).fc_txq_th_drop_q_wan[0] = 0
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_SET(r,d) (r).fc_txq_th_drop_q_wan[0] = d
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_GET(r) (r).fc_txq_th_drop_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q_wan[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q_wan[0]=(((r).fc_txq_th_drop_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVED_Rf_GET(r) ((((r).fc_txq_th_drop_q_wan[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVED_Rf_SET(r,f) (r).fc_txq_th_drop_q_wan[0]=(((r).fc_txq_th_drop_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q_WAN.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr+(2*(i)),(r._fc_txq_th_drop_q_wan),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr+(2*(i)),&(r._fc_txq_th_drop_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q_WANr BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr
#define FC_TXQ_TH_DROP_Q_WANr_SIZE BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_t FC_TXQ_TH_DROP_Q_WANr_t;
#define FC_TXQ_TH_DROP_Q_WANr_CLR BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_CLR
#define FC_TXQ_TH_DROP_Q_WANr_SET BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_SET
#define FC_TXQ_TH_DROP_Q_WANr_GET BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_GET
#define FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q_WANr_RESERVED_Rf_GET BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVED_Rf_GET
#define FC_TXQ_TH_DROP_Q_WANr_RESERVED_Rf_SET BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_DROP_Q_WANr BCM53115_A0_READ_FC_TXQ_TH_DROP_Q_WANr
#define WRITE_FC_TXQ_TH_DROP_Q_WANr BCM53115_A0_WRITE_FC_TXQ_TH_DROP_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_DROP_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr 0x00000a18

#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q[1];
	uint32_t _fc_txq_th_pause_q;
} BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_t;

#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_CLR(r) (r).fc_txq_th_pause_q[0] = 0
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_SET(r,d) (r).fc_txq_th_pause_q[0] = d
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_GET(r) (r).fc_txq_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_GET(r) ((((r).fc_txq_th_pause_q[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),(r._fc_txq_th_pause_q),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),&(r._fc_txq_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Qr BCM53115_A0_FC_TXQ_TH_PAUSE_Qr
#define FC_TXQ_TH_PAUSE_Qr_SIZE BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_t FC_TXQ_TH_PAUSE_Qr_t;
#define FC_TXQ_TH_PAUSE_Qr_CLR BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_CLR
#define FC_TXQ_TH_PAUSE_Qr_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_SET
#define FC_TXQ_TH_PAUSE_Qr_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_GET
#define FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_PAUSE_Qr BCM53115_A0_READ_FC_TXQ_TH_PAUSE_Qr
#define WRITE_FC_TXQ_TH_PAUSE_Qr BCM53115_A0_WRITE_FC_TXQ_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r 0x00000ab4

#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q45.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q45[1];
	uint32_t _fc_txq_th_pause_q45;
} BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_t;

#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_CLR(r) (r).fc_txq_th_pause_q45[0] = 0
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_SET(r,d) (r).fc_txq_th_pause_q45[0] = d
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_GET(r) (r).fc_txq_th_pause_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q45[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q45[0]=(((r).fc_txq_th_pause_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVED_Rf_GET(r) ((((r).fc_txq_th_pause_q45[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVED_Rf_SET(r,f) (r).fc_txq_th_pause_q45[0]=(((r).fc_txq_th_pause_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q45.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r+(2*(i)),(r._fc_txq_th_pause_q45),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r+(2*(i)),&(r._fc_txq_th_pause_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q45r BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r
#define FC_TXQ_TH_PAUSE_Q45r_SIZE BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_SIZE
typedef BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_t FC_TXQ_TH_PAUSE_Q45r_t;
#define FC_TXQ_TH_PAUSE_Q45r_CLR BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_CLR
#define FC_TXQ_TH_PAUSE_Q45r_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_SET
#define FC_TXQ_TH_PAUSE_Q45r_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_GET
#define FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q45r_RESERVED_Rf_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVED_Rf_GET
#define FC_TXQ_TH_PAUSE_Q45r_RESERVED_Rf_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_PAUSE_Q45r BCM53115_A0_READ_FC_TXQ_TH_PAUSE_Q45r
#define WRITE_FC_TXQ_TH_PAUSE_Q45r BCM53115_A0_WRITE_FC_TXQ_TH_PAUSE_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_PAUSE_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr 0x00000d18

#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q_IMP.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q_imp[1];
	uint32_t _fc_txq_th_pause_q_imp;
} BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_t;

#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_CLR(r) (r).fc_txq_th_pause_q_imp[0] = 0
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SET(r,d) (r).fc_txq_th_pause_q_imp[0] = d
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_GET(r) (r).fc_txq_th_pause_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q_imp[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q_imp[0]=(((r).fc_txq_th_pause_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVED_Rf_GET(r) ((((r).fc_txq_th_pause_q_imp[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVED_Rf_SET(r,f) (r).fc_txq_th_pause_q_imp[0]=(((r).fc_txq_th_pause_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q_IMP.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr+(2*(i)),(r._fc_txq_th_pause_q_imp),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr+(2*(i)),&(r._fc_txq_th_pause_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q_IMPr BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr
#define FC_TXQ_TH_PAUSE_Q_IMPr_SIZE BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_t FC_TXQ_TH_PAUSE_Q_IMPr_t;
#define FC_TXQ_TH_PAUSE_Q_IMPr_CLR BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_CLR
#define FC_TXQ_TH_PAUSE_Q_IMPr_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SET
#define FC_TXQ_TH_PAUSE_Q_IMPr_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q_IMPr_RESERVED_Rf_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVED_Rf_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_RESERVED_Rf_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_PAUSE_Q_IMPr BCM53115_A0_READ_FC_TXQ_TH_PAUSE_Q_IMPr
#define WRITE_FC_TXQ_TH_PAUSE_Q_IMPr BCM53115_A0_WRITE_FC_TXQ_TH_PAUSE_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_PAUSE_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr 0x00000e18

#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q_WAN.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q_wan[1];
	uint32_t _fc_txq_th_pause_q_wan;
} BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_t;

#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_CLR(r) (r).fc_txq_th_pause_q_wan[0] = 0
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_SET(r,d) (r).fc_txq_th_pause_q_wan[0] = d
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_GET(r) (r).fc_txq_th_pause_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q_wan[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q_wan[0]=(((r).fc_txq_th_pause_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVED_Rf_GET(r) ((((r).fc_txq_th_pause_q_wan[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVED_Rf_SET(r,f) (r).fc_txq_th_pause_q_wan[0]=(((r).fc_txq_th_pause_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q_WAN.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr+(2*(i)),(r._fc_txq_th_pause_q_wan),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr+(2*(i)),&(r._fc_txq_th_pause_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q_WANr BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr
#define FC_TXQ_TH_PAUSE_Q_WANr_SIZE BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_t FC_TXQ_TH_PAUSE_Q_WANr_t;
#define FC_TXQ_TH_PAUSE_Q_WANr_CLR BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_CLR
#define FC_TXQ_TH_PAUSE_Q_WANr_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_SET
#define FC_TXQ_TH_PAUSE_Q_WANr_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q_WANr_RESERVED_Rf_GET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVED_Rf_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_RESERVED_Rf_SET BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_PAUSE_Q_WANr BCM53115_A0_READ_FC_TXQ_TH_PAUSE_Q_WANr
#define WRITE_FC_TXQ_TH_PAUSE_Q_WANr BCM53115_A0_WRITE_FC_TXQ_TH_PAUSE_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_PAUSE_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr 0x00000a10

#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q[1];
	uint32_t _fc_txq_th_rsrv_q;
} BCM53115_A0_FC_TXQ_TH_RSRV_Qr_t;

#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr_CLR(r) (r).fc_txq_th_rsrv_q[0] = 0
#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr_SET(r,d) (r).fc_txq_th_rsrv_q[0] = d
#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr_GET(r) (r).fc_txq_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_GET(r) ((((r).fc_txq_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),(r._fc_txq_th_rsrv_q),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),&(r._fc_txq_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Qr BCM53115_A0_FC_TXQ_TH_RSRV_Qr
#define FC_TXQ_TH_RSRV_Qr_SIZE BCM53115_A0_FC_TXQ_TH_RSRV_Qr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_RSRV_Qr_t FC_TXQ_TH_RSRV_Qr_t;
#define FC_TXQ_TH_RSRV_Qr_CLR BCM53115_A0_FC_TXQ_TH_RSRV_Qr_CLR
#define FC_TXQ_TH_RSRV_Qr_SET BCM53115_A0_FC_TXQ_TH_RSRV_Qr_SET
#define FC_TXQ_TH_RSRV_Qr_GET BCM53115_A0_FC_TXQ_TH_RSRV_Qr_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET BCM53115_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET BCM53115_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_GET BCM53115_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_GET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_SET BCM53115_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_SET
#define READ_FC_TXQ_TH_RSRV_Qr BCM53115_A0_READ_FC_TXQ_TH_RSRV_Qr
#define WRITE_FC_TXQ_TH_RSRV_Qr BCM53115_A0_WRITE_FC_TXQ_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r 0x00000ab0

#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q45.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q45[1];
	uint32_t _fc_txq_th_rsrv_q45;
} BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_t;

#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_CLR(r) (r).fc_txq_th_rsrv_q45[0] = 0
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_SET(r,d) (r).fc_txq_th_rsrv_q45[0] = d
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_GET(r) (r).fc_txq_th_rsrv_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q45[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q45[0]=(((r).fc_txq_th_rsrv_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1Rf_GET(r) ((((r).fc_txq_th_rsrv_q45[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1Rf_SET(r,f) (r).fc_txq_th_rsrv_q45[0]=(((r).fc_txq_th_rsrv_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q45.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_RSRV_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_RSRV_Q45r+(2*(i)),(r._fc_txq_th_rsrv_q45),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_RSRV_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_RSRV_Q45r+(2*(i)),&(r._fc_txq_th_rsrv_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q45r BCM53115_A0_FC_TXQ_TH_RSRV_Q45r
#define FC_TXQ_TH_RSRV_Q45r_SIZE BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_SIZE
typedef BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_t FC_TXQ_TH_RSRV_Q45r_t;
#define FC_TXQ_TH_RSRV_Q45r_CLR BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_CLR
#define FC_TXQ_TH_RSRV_Q45r_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_SET
#define FC_TXQ_TH_RSRV_Q45r_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_GET
#define FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q45r_RESERVED_1Rf_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1Rf_GET
#define FC_TXQ_TH_RSRV_Q45r_RESERVED_1Rf_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1Rf_SET
#define READ_FC_TXQ_TH_RSRV_Q45r BCM53115_A0_READ_FC_TXQ_TH_RSRV_Q45r
#define WRITE_FC_TXQ_TH_RSRV_Q45r BCM53115_A0_WRITE_FC_TXQ_TH_RSRV_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_RSRV_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr 0x00000d10

#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q_IMP.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q_imp[1];
	uint32_t _fc_txq_th_rsrv_q_imp;
} BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_t;

#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_CLR(r) (r).fc_txq_th_rsrv_q_imp[0] = 0
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_SET(r,d) (r).fc_txq_th_rsrv_q_imp[0] = d
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_GET(r) (r).fc_txq_th_rsrv_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q_imp[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q_imp[0]=(((r).fc_txq_th_rsrv_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1Rf_GET(r) ((((r).fc_txq_th_rsrv_q_imp[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1Rf_SET(r,f) (r).fc_txq_th_rsrv_q_imp[0]=(((r).fc_txq_th_rsrv_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q_IMP.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_RSRV_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr+(2*(i)),(r._fc_txq_th_rsrv_q_imp),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_RSRV_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr+(2*(i)),&(r._fc_txq_th_rsrv_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q_IMPr BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr
#define FC_TXQ_TH_RSRV_Q_IMPr_SIZE BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_t FC_TXQ_TH_RSRV_Q_IMPr_t;
#define FC_TXQ_TH_RSRV_Q_IMPr_CLR BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_CLR
#define FC_TXQ_TH_RSRV_Q_IMPr_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_SET
#define FC_TXQ_TH_RSRV_Q_IMPr_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1Rf_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1Rf_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1Rf_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1Rf_SET
#define READ_FC_TXQ_TH_RSRV_Q_IMPr BCM53115_A0_READ_FC_TXQ_TH_RSRV_Q_IMPr
#define WRITE_FC_TXQ_TH_RSRV_Q_IMPr BCM53115_A0_WRITE_FC_TXQ_TH_RSRV_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_RSRV_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr 0x00000e10

#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q_WAN.
 *
 */
typedef union BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q_wan[1];
	uint32_t _fc_txq_th_rsrv_q_wan;
} BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_t;

#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_CLR(r) (r).fc_txq_th_rsrv_q_wan[0] = 0
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_SET(r,d) (r).fc_txq_th_rsrv_q_wan[0] = d
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_GET(r) (r).fc_txq_th_rsrv_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q_wan[0]) & 0x3ff)
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q_wan[0]=(((r).fc_txq_th_rsrv_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1Rf_GET(r) ((((r).fc_txq_th_rsrv_q_wan[0]) >> 10) & 0x3f)
#define BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1Rf_SET(r,f) (r).fc_txq_th_rsrv_q_wan[0]=(((r).fc_txq_th_rsrv_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q_WAN.
 *
 */
#define BCM53115_A0_READ_FC_TXQ_TH_RSRV_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr+(2*(i)),(r._fc_txq_th_rsrv_q_wan),2)
#define BCM53115_A0_WRITE_FC_TXQ_TH_RSRV_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr+(2*(i)),&(r._fc_txq_th_rsrv_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q_WANr BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr
#define FC_TXQ_TH_RSRV_Q_WANr_SIZE BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_SIZE
typedef BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_t FC_TXQ_TH_RSRV_Q_WANr_t;
#define FC_TXQ_TH_RSRV_Q_WANr_CLR BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_CLR
#define FC_TXQ_TH_RSRV_Q_WANr_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_SET
#define FC_TXQ_TH_RSRV_Q_WANr_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_GET
#define FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1Rf_GET BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1Rf_GET
#define FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1Rf_SET BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1Rf_SET
#define READ_FC_TXQ_TH_RSRV_Q_WANr BCM53115_A0_READ_FC_TXQ_TH_RSRV_Q_WANr
#define WRITE_FC_TXQ_TH_RSRV_Q_WANr BCM53115_A0_WRITE_FC_TXQ_TH_RSRV_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_FC_TXQ_TH_RSRV_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  GARLCFG
 * BLOCKS:   SYS
 * DESC:     Global ARL Configuration Register
 * SIZE:     8
 * FIELDS:
 *     HASH_DISABLE     Disable The hash function for the ARL such that entries are direct mapped to the table. The hash function is enable default for the BCM5395M ARL,but can be disabled by setting this bit.
 *     RESERVED_1R      Reserved
 *     AGE_ACC          Age Accele rate, test only.
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_GARLCFGr 0x00000400

#define BCM53115_A0_GARLCFGr_SIZE 1

/*
 * This structure should be used to declare and program GARLCFG.
 *
 */
typedef union BCM53115_A0_GARLCFGr_s {
	uint32_t v[1];
	uint32_t garlcfg[1];
	uint32_t _garlcfg;
} BCM53115_A0_GARLCFGr_t;

#define BCM53115_A0_GARLCFGr_CLR(r) (r).garlcfg[0] = 0
#define BCM53115_A0_GARLCFGr_SET(r,d) (r).garlcfg[0] = d
#define BCM53115_A0_GARLCFGr_GET(r) (r).garlcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_GARLCFGr_HASH_DISABLEf_GET(r) (((r).garlcfg[0]) & 0x1)
#define BCM53115_A0_GARLCFGr_HASH_DISABLEf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_GARLCFGr_RESERVED_1Rf_GET(r) ((((r).garlcfg[0]) >> 1) & 0x1)
#define BCM53115_A0_GARLCFGr_RESERVED_1Rf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_GARLCFGr_AGE_ACCf_GET(r) ((((r).garlcfg[0]) >> 2) & 0x1)
#define BCM53115_A0_GARLCFGr_AGE_ACCf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_GARLCFGr_RESERVED_2Rf_GET(r) ((((r).garlcfg[0]) >> 3) & 0x1f)
#define BCM53115_A0_GARLCFGr_RESERVED_2Rf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access GARLCFG.
 *
 */
#define BCM53115_A0_READ_GARLCFGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_GARLCFGr,(r._garlcfg),1)
#define BCM53115_A0_WRITE_GARLCFGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_GARLCFGr,&(r._garlcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GARLCFGr BCM53115_A0_GARLCFGr
#define GARLCFGr_SIZE BCM53115_A0_GARLCFGr_SIZE
typedef BCM53115_A0_GARLCFGr_t GARLCFGr_t;
#define GARLCFGr_CLR BCM53115_A0_GARLCFGr_CLR
#define GARLCFGr_SET BCM53115_A0_GARLCFGr_SET
#define GARLCFGr_GET BCM53115_A0_GARLCFGr_GET
#define GARLCFGr_HASH_DISABLEf_GET BCM53115_A0_GARLCFGr_HASH_DISABLEf_GET
#define GARLCFGr_HASH_DISABLEf_SET BCM53115_A0_GARLCFGr_HASH_DISABLEf_SET
#define GARLCFGr_RESERVED_1Rf_GET BCM53115_A0_GARLCFGr_RESERVED_1Rf_GET
#define GARLCFGr_RESERVED_1Rf_SET BCM53115_A0_GARLCFGr_RESERVED_1Rf_SET
#define GARLCFGr_AGE_ACCf_GET BCM53115_A0_GARLCFGr_AGE_ACCf_GET
#define GARLCFGr_AGE_ACCf_SET BCM53115_A0_GARLCFGr_AGE_ACCf_SET
#define GARLCFGr_RESERVED_2Rf_GET BCM53115_A0_GARLCFGr_RESERVED_2Rf_GET
#define GARLCFGr_RESERVED_2Rf_SET BCM53115_A0_GARLCFGr_RESERVED_2Rf_SET
#define READ_GARLCFGr BCM53115_A0_READ_GARLCFGr
#define WRITE_GARLCFGr BCM53115_A0_WRITE_GARLCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_GARLCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  GMNGCFG
 * BLOCKS:   SYS
 * DESC:     Global Management Configuration Register
 * SIZE:     8
 * FIELDS:
 *     RST_MIB_CNT      Reset MIB CountersResets all MIB counters for all ports to zero (Pages 20h-28h). The host must set the bit and then clear the bit in successive write cycles to activate the reset operation.
 *     RXBPDU_EN        Receive BPDU Enable.Enables all ports to receive BPDUs and forward to the defined Physical Management Port. Management CPU must set this bit to globally allow BPDUs to be received.
 *     RESERVED_0R      Reserved
 *     INT_EN_R         Interrupt enable
 *     RESERVED_1R      Reserved
 *     FRM_MNGP         Frame Management Port.Defines the physical port used to report management frames directed to the switch.00=No Management Port01=Reserved10=MII Port (In-band Management Port - IMP)11=ReservedThese bits are ignored when SW_FWD_MODE=Unmanaged in the Switch Mode Register, and the device will behave as if there is no defined management port.
 *
 ******************************************************************************/
#define BCM53115_A0_GMNGCFGr 0x00000200

#define BCM53115_A0_GMNGCFGr_SIZE 1

/*
 * This structure should be used to declare and program GMNGCFG.
 *
 */
typedef union BCM53115_A0_GMNGCFGr_s {
	uint32_t v[1];
	uint32_t gmngcfg[1];
	uint32_t _gmngcfg;
} BCM53115_A0_GMNGCFGr_t;

#define BCM53115_A0_GMNGCFGr_CLR(r) (r).gmngcfg[0] = 0
#define BCM53115_A0_GMNGCFGr_SET(r,d) (r).gmngcfg[0] = d
#define BCM53115_A0_GMNGCFGr_GET(r) (r).gmngcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_GMNGCFGr_RST_MIB_CNTf_GET(r) (((r).gmngcfg[0]) & 0x1)
#define BCM53115_A0_GMNGCFGr_RST_MIB_CNTf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_GMNGCFGr_RXBPDU_ENf_GET(r) ((((r).gmngcfg[0]) >> 1) & 0x1)
#define BCM53115_A0_GMNGCFGr_RXBPDU_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_GMNGCFGr_RESERVED_0Rf_GET(r) ((((r).gmngcfg[0]) >> 2) & 0x3)
#define BCM53115_A0_GMNGCFGr_RESERVED_0Rf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_GMNGCFGr_INT_EN_Rf_GET(r) ((((r).gmngcfg[0]) >> 4) & 0x1)
#define BCM53115_A0_GMNGCFGr_INT_EN_Rf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_GMNGCFGr_RESERVED_1Rf_GET(r) ((((r).gmngcfg[0]) >> 5) & 0x1)
#define BCM53115_A0_GMNGCFGr_RESERVED_1Rf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_GMNGCFGr_FRM_MNGPf_GET(r) ((((r).gmngcfg[0]) >> 6) & 0x3)
#define BCM53115_A0_GMNGCFGr_FRM_MNGPf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access GMNGCFG.
 *
 */
#define BCM53115_A0_READ_GMNGCFGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_GMNGCFGr,(r._gmngcfg),1)
#define BCM53115_A0_WRITE_GMNGCFGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_GMNGCFGr,&(r._gmngcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMNGCFGr BCM53115_A0_GMNGCFGr
#define GMNGCFGr_SIZE BCM53115_A0_GMNGCFGr_SIZE
typedef BCM53115_A0_GMNGCFGr_t GMNGCFGr_t;
#define GMNGCFGr_CLR BCM53115_A0_GMNGCFGr_CLR
#define GMNGCFGr_SET BCM53115_A0_GMNGCFGr_SET
#define GMNGCFGr_GET BCM53115_A0_GMNGCFGr_GET
#define GMNGCFGr_RST_MIB_CNTf_GET BCM53115_A0_GMNGCFGr_RST_MIB_CNTf_GET
#define GMNGCFGr_RST_MIB_CNTf_SET BCM53115_A0_GMNGCFGr_RST_MIB_CNTf_SET
#define GMNGCFGr_RXBPDU_ENf_GET BCM53115_A0_GMNGCFGr_RXBPDU_ENf_GET
#define GMNGCFGr_RXBPDU_ENf_SET BCM53115_A0_GMNGCFGr_RXBPDU_ENf_SET
#define GMNGCFGr_RESERVED_0Rf_GET BCM53115_A0_GMNGCFGr_RESERVED_0Rf_GET
#define GMNGCFGr_RESERVED_0Rf_SET BCM53115_A0_GMNGCFGr_RESERVED_0Rf_SET
#define GMNGCFGr_INT_EN_Rf_GET BCM53115_A0_GMNGCFGr_INT_EN_Rf_GET
#define GMNGCFGr_INT_EN_Rf_SET BCM53115_A0_GMNGCFGr_INT_EN_Rf_SET
#define GMNGCFGr_RESERVED_1Rf_GET BCM53115_A0_GMNGCFGr_RESERVED_1Rf_GET
#define GMNGCFGr_RESERVED_1Rf_SET BCM53115_A0_GMNGCFGr_RESERVED_1Rf_SET
#define GMNGCFGr_FRM_MNGPf_GET BCM53115_A0_GMNGCFGr_FRM_MNGPf_GET
#define GMNGCFGr_FRM_MNGPf_SET BCM53115_A0_GMNGCFGr_FRM_MNGPf_SET
#define READ_GMNGCFGr BCM53115_A0_READ_GMNGCFGr
#define WRITE_GMNGCFGr BCM53115_A0_WRITE_GMNGCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_GMNGCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANADV
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2R      write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANADVr 0x00001008

#define BCM53115_A0_G_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV.
 *
 */
typedef union BCM53115_A0_G_ANADVr_s {
	uint32_t v[1];
	uint32_t g_anadv[1];
	uint32_t _g_anadv;
} BCM53115_A0_G_ANADVr_t;

#define BCM53115_A0_G_ANADVr_CLR(r) (r).g_anadv[0] = 0
#define BCM53115_A0_G_ANADVr_SET(r,d) (r).g_anadv[0] = d
#define BCM53115_A0_G_ANADVr_GET(r) (r).g_anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANADVr_PROTOCOL_SELf_GET(r) (((r).g_anadv[0]) & 0x1f)
#define BCM53115_A0_G_ANADVr_PROTOCOL_SELf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_G_ANADVr_ADV_B10Tf_GET(r) ((((r).g_anadv[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANADVr_ADV_B10Tf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv[0]) >> 6) & 0x1)
#define BCM53115_A0_G_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_ANADVr_ADV_B100Xf_GET(r) ((((r).g_anadv[0]) >> 7) & 0x1)
#define BCM53115_A0_G_ANADVr_ADV_B100Xf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_ANADVr_ADV_B100_FDXf_GET(r) ((((r).g_anadv[0]) >> 8) & 0x1)
#define BCM53115_A0_G_ANADVr_ADV_B100_FDXf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_ANADVr_B100T4f_GET(r) ((((r).g_anadv[0]) >> 9) & 0x1)
#define BCM53115_A0_G_ANADVr_B100T4f_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv[0]) >> 10) & 0x1)
#define BCM53115_A0_G_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_ANADVr_ASY_PAUSEf_GET(r) ((((r).g_anadv[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANADVr_ASY_PAUSEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANADVr_RESERVED_1Rf_GET(r) ((((r).g_anadv[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANADVr_RESERVED_1Rf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANADVr_REMOTE_FAULT_Rf_GET(r) ((((r).g_anadv[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANADVr_REMOTE_FAULT_Rf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANADVr_RESERVED_2Rf_GET(r) ((((r).g_anadv[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANADVr_RESERVED_2Rf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANADVr_NEXT_PAGEf_GET(r) ((((r).g_anadv[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANADVr_NEXT_PAGEf_SET(r,f) (r).g_anadv[0]=(((r).g_anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV.
 *
 */
#define BCM53115_A0_READ_G_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_ANADVr,(r._g_anadv),2)
#define BCM53115_A0_WRITE_G_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_ANADVr,&(r._g_anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADVr BCM53115_A0_G_ANADVr
#define G_ANADVr_SIZE BCM53115_A0_G_ANADVr_SIZE
typedef BCM53115_A0_G_ANADVr_t G_ANADVr_t;
#define G_ANADVr_CLR BCM53115_A0_G_ANADVr_CLR
#define G_ANADVr_SET BCM53115_A0_G_ANADVr_SET
#define G_ANADVr_GET BCM53115_A0_G_ANADVr_GET
#define G_ANADVr_PROTOCOL_SELf_GET BCM53115_A0_G_ANADVr_PROTOCOL_SELf_GET
#define G_ANADVr_PROTOCOL_SELf_SET BCM53115_A0_G_ANADVr_PROTOCOL_SELf_SET
#define G_ANADVr_ADV_B10Tf_GET BCM53115_A0_G_ANADVr_ADV_B10Tf_GET
#define G_ANADVr_ADV_B10Tf_SET BCM53115_A0_G_ANADVr_ADV_B10Tf_SET
#define G_ANADVr_ADV_B10T_FDXf_GET BCM53115_A0_G_ANADVr_ADV_B10T_FDXf_GET
#define G_ANADVr_ADV_B10T_FDXf_SET BCM53115_A0_G_ANADVr_ADV_B10T_FDXf_SET
#define G_ANADVr_ADV_B100Xf_GET BCM53115_A0_G_ANADVr_ADV_B100Xf_GET
#define G_ANADVr_ADV_B100Xf_SET BCM53115_A0_G_ANADVr_ADV_B100Xf_SET
#define G_ANADVr_ADV_B100_FDXf_GET BCM53115_A0_G_ANADVr_ADV_B100_FDXf_GET
#define G_ANADVr_ADV_B100_FDXf_SET BCM53115_A0_G_ANADVr_ADV_B100_FDXf_SET
#define G_ANADVr_B100T4f_GET BCM53115_A0_G_ANADVr_B100T4f_GET
#define G_ANADVr_B100T4f_SET BCM53115_A0_G_ANADVr_B100T4f_SET
#define G_ANADVr_ADV_PAUSE_CAPf_GET BCM53115_A0_G_ANADVr_ADV_PAUSE_CAPf_GET
#define G_ANADVr_ADV_PAUSE_CAPf_SET BCM53115_A0_G_ANADVr_ADV_PAUSE_CAPf_SET
#define G_ANADVr_ASY_PAUSEf_GET BCM53115_A0_G_ANADVr_ASY_PAUSEf_GET
#define G_ANADVr_ASY_PAUSEf_SET BCM53115_A0_G_ANADVr_ASY_PAUSEf_SET
#define G_ANADVr_RESERVED_1Rf_GET BCM53115_A0_G_ANADVr_RESERVED_1Rf_GET
#define G_ANADVr_RESERVED_1Rf_SET BCM53115_A0_G_ANADVr_RESERVED_1Rf_SET
#define G_ANADVr_REMOTE_FAULT_Rf_GET BCM53115_A0_G_ANADVr_REMOTE_FAULT_Rf_GET
#define G_ANADVr_REMOTE_FAULT_Rf_SET BCM53115_A0_G_ANADVr_REMOTE_FAULT_Rf_SET
#define G_ANADVr_RESERVED_2Rf_GET BCM53115_A0_G_ANADVr_RESERVED_2Rf_GET
#define G_ANADVr_RESERVED_2Rf_SET BCM53115_A0_G_ANADVr_RESERVED_2Rf_SET
#define G_ANADVr_NEXT_PAGEf_GET BCM53115_A0_G_ANADVr_NEXT_PAGEf_GET
#define G_ANADVr_NEXT_PAGEf_SET BCM53115_A0_G_ANADVr_NEXT_PAGEf_SET
#define READ_G_ANADVr BCM53115_A0_READ_G_ANADVr
#define WRITE_G_ANADVr BCM53115_A0_WRITE_G_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANADV_EXT
 * BLOCKS:   CPIC
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2R      write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANADV_EXTr 0x00008808

#define BCM53115_A0_G_ANADV_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT.
 *
 */
typedef union BCM53115_A0_G_ANADV_EXTr_s {
	uint32_t v[1];
	uint32_t g_anadv_ext[1];
	uint32_t _g_anadv_ext;
} BCM53115_A0_G_ANADV_EXTr_t;

#define BCM53115_A0_G_ANADV_EXTr_CLR(r) (r).g_anadv_ext[0] = 0
#define BCM53115_A0_G_ANADV_EXTr_SET(r,d) (r).g_anadv_ext[0] = d
#define BCM53115_A0_G_ANADV_EXTr_GET(r) (r).g_anadv_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANADV_EXTr_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext[0]) & 0x1f)
#define BCM53115_A0_G_ANADV_EXTr_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_G_ANADV_EXTr_ADV_B10Tf_GET(r) ((((r).g_anadv_ext[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_ADV_B10Tf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANADV_EXTr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext[0]) >> 6) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_ANADV_EXTr_ADV_B100Xf_GET(r) ((((r).g_anadv_ext[0]) >> 7) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_ADV_B100Xf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_ANADV_EXTr_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext[0]) >> 8) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_ANADV_EXTr_B100T4f_GET(r) ((((r).g_anadv_ext[0]) >> 9) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_B100T4f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext[0]) >> 10) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_ANADV_EXTr_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANADV_EXTr_RESERVED_1Rf_GET(r) ((((r).g_anadv_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_RESERVED_1Rf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANADV_EXTr_REMOTE_FAULT_Rf_GET(r) ((((r).g_anadv_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_REMOTE_FAULT_Rf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANADV_EXTr_RESERVED_2Rf_GET(r) ((((r).g_anadv_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_RESERVED_2Rf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANADV_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANADV_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT.
 *
 */
#define BCM53115_A0_READ_G_ANADV_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_ANADV_EXTr,(r._g_anadv_ext),2)
#define BCM53115_A0_WRITE_G_ANADV_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_ANADV_EXTr,&(r._g_anadv_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXTr BCM53115_A0_G_ANADV_EXTr
#define G_ANADV_EXTr_SIZE BCM53115_A0_G_ANADV_EXTr_SIZE
typedef BCM53115_A0_G_ANADV_EXTr_t G_ANADV_EXTr_t;
#define G_ANADV_EXTr_CLR BCM53115_A0_G_ANADV_EXTr_CLR
#define G_ANADV_EXTr_SET BCM53115_A0_G_ANADV_EXTr_SET
#define G_ANADV_EXTr_GET BCM53115_A0_G_ANADV_EXTr_GET
#define G_ANADV_EXTr_PROTOCOL_SELf_GET BCM53115_A0_G_ANADV_EXTr_PROTOCOL_SELf_GET
#define G_ANADV_EXTr_PROTOCOL_SELf_SET BCM53115_A0_G_ANADV_EXTr_PROTOCOL_SELf_SET
#define G_ANADV_EXTr_ADV_B10Tf_GET BCM53115_A0_G_ANADV_EXTr_ADV_B10Tf_GET
#define G_ANADV_EXTr_ADV_B10Tf_SET BCM53115_A0_G_ANADV_EXTr_ADV_B10Tf_SET
#define G_ANADV_EXTr_ADV_B10T_FDXf_GET BCM53115_A0_G_ANADV_EXTr_ADV_B10T_FDXf_GET
#define G_ANADV_EXTr_ADV_B10T_FDXf_SET BCM53115_A0_G_ANADV_EXTr_ADV_B10T_FDXf_SET
#define G_ANADV_EXTr_ADV_B100Xf_GET BCM53115_A0_G_ANADV_EXTr_ADV_B100Xf_GET
#define G_ANADV_EXTr_ADV_B100Xf_SET BCM53115_A0_G_ANADV_EXTr_ADV_B100Xf_SET
#define G_ANADV_EXTr_ADV_B100_FDXf_GET BCM53115_A0_G_ANADV_EXTr_ADV_B100_FDXf_GET
#define G_ANADV_EXTr_ADV_B100_FDXf_SET BCM53115_A0_G_ANADV_EXTr_ADV_B100_FDXf_SET
#define G_ANADV_EXTr_B100T4f_GET BCM53115_A0_G_ANADV_EXTr_B100T4f_GET
#define G_ANADV_EXTr_B100T4f_SET BCM53115_A0_G_ANADV_EXTr_B100T4f_SET
#define G_ANADV_EXTr_ADV_PAUSE_CAPf_GET BCM53115_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXTr_ADV_PAUSE_CAPf_SET BCM53115_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXTr_ASY_PAUSEf_GET BCM53115_A0_G_ANADV_EXTr_ASY_PAUSEf_GET
#define G_ANADV_EXTr_ASY_PAUSEf_SET BCM53115_A0_G_ANADV_EXTr_ASY_PAUSEf_SET
#define G_ANADV_EXTr_RESERVED_1Rf_GET BCM53115_A0_G_ANADV_EXTr_RESERVED_1Rf_GET
#define G_ANADV_EXTr_RESERVED_1Rf_SET BCM53115_A0_G_ANADV_EXTr_RESERVED_1Rf_SET
#define G_ANADV_EXTr_REMOTE_FAULT_Rf_GET BCM53115_A0_G_ANADV_EXTr_REMOTE_FAULT_Rf_GET
#define G_ANADV_EXTr_REMOTE_FAULT_Rf_SET BCM53115_A0_G_ANADV_EXTr_REMOTE_FAULT_Rf_SET
#define G_ANADV_EXTr_RESERVED_2Rf_GET BCM53115_A0_G_ANADV_EXTr_RESERVED_2Rf_GET
#define G_ANADV_EXTr_RESERVED_2Rf_SET BCM53115_A0_G_ANADV_EXTr_RESERVED_2Rf_SET
#define G_ANADV_EXTr_NEXT_PAGEf_GET BCM53115_A0_G_ANADV_EXTr_NEXT_PAGEf_GET
#define G_ANADV_EXTr_NEXT_PAGEf_SET BCM53115_A0_G_ANADV_EXTr_NEXT_PAGEf_SET
#define READ_G_ANADV_EXTr BCM53115_A0_READ_G_ANADV_EXTr
#define WRITE_G_ANADV_EXTr BCM53115_A0_WRITE_G_ANADV_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANADV_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANADV_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2R      write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANADV_EXT_P5r 0x00008508

#define BCM53115_A0_G_ANADV_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_ANADV_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_anadv_ext_p5[1];
	uint32_t _g_anadv_ext_p5;
} BCM53115_A0_G_ANADV_EXT_P5r_t;

#define BCM53115_A0_G_ANADV_EXT_P5r_CLR(r) (r).g_anadv_ext_p5[0] = 0
#define BCM53115_A0_G_ANADV_EXT_P5r_SET(r,d) (r).g_anadv_ext_p5[0] = d
#define BCM53115_A0_G_ANADV_EXT_P5r_GET(r) (r).g_anadv_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANADV_EXT_P5r_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext_p5[0]) & 0x1f)
#define BCM53115_A0_G_ANADV_EXT_P5r_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_B10Tf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_B10Tf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 6) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_B100Xf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 7) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_B100Xf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 8) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_ANADV_EXT_P5r_B100T4f_GET(r) ((((r).g_anadv_ext_p5[0]) >> 9) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_B100T4f_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 10) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_ANADV_EXT_P5r_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANADV_EXT_P5r_RESERVED_1Rf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_RESERVED_1Rf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANADV_EXT_P5r_REMOTE_FAULT_Rf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_REMOTE_FAULT_Rf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANADV_EXT_P5r_RESERVED_2Rf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_RESERVED_2Rf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANADV_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANADV_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext_p5[0]=(((r).g_anadv_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_ANADV_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_ANADV_EXT_P5r,(r._g_anadv_ext_p5),2)
#define BCM53115_A0_WRITE_G_ANADV_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_ANADV_EXT_P5r,&(r._g_anadv_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXT_P5r BCM53115_A0_G_ANADV_EXT_P5r
#define G_ANADV_EXT_P5r_SIZE BCM53115_A0_G_ANADV_EXT_P5r_SIZE
typedef BCM53115_A0_G_ANADV_EXT_P5r_t G_ANADV_EXT_P5r_t;
#define G_ANADV_EXT_P5r_CLR BCM53115_A0_G_ANADV_EXT_P5r_CLR
#define G_ANADV_EXT_P5r_SET BCM53115_A0_G_ANADV_EXT_P5r_SET
#define G_ANADV_EXT_P5r_GET BCM53115_A0_G_ANADV_EXT_P5r_GET
#define G_ANADV_EXT_P5r_PROTOCOL_SELf_GET BCM53115_A0_G_ANADV_EXT_P5r_PROTOCOL_SELf_GET
#define G_ANADV_EXT_P5r_PROTOCOL_SELf_SET BCM53115_A0_G_ANADV_EXT_P5r_PROTOCOL_SELf_SET
#define G_ANADV_EXT_P5r_ADV_B10Tf_GET BCM53115_A0_G_ANADV_EXT_P5r_ADV_B10Tf_GET
#define G_ANADV_EXT_P5r_ADV_B10Tf_SET BCM53115_A0_G_ANADV_EXT_P5r_ADV_B10Tf_SET
#define G_ANADV_EXT_P5r_ADV_B10T_FDXf_GET BCM53115_A0_G_ANADV_EXT_P5r_ADV_B10T_FDXf_GET
#define G_ANADV_EXT_P5r_ADV_B10T_FDXf_SET BCM53115_A0_G_ANADV_EXT_P5r_ADV_B10T_FDXf_SET
#define G_ANADV_EXT_P5r_ADV_B100Xf_GET BCM53115_A0_G_ANADV_EXT_P5r_ADV_B100Xf_GET
#define G_ANADV_EXT_P5r_ADV_B100Xf_SET BCM53115_A0_G_ANADV_EXT_P5r_ADV_B100Xf_SET
#define G_ANADV_EXT_P5r_ADV_B100_FDXf_GET BCM53115_A0_G_ANADV_EXT_P5r_ADV_B100_FDXf_GET
#define G_ANADV_EXT_P5r_ADV_B100_FDXf_SET BCM53115_A0_G_ANADV_EXT_P5r_ADV_B100_FDXf_SET
#define G_ANADV_EXT_P5r_B100T4f_GET BCM53115_A0_G_ANADV_EXT_P5r_B100T4f_GET
#define G_ANADV_EXT_P5r_B100T4f_SET BCM53115_A0_G_ANADV_EXT_P5r_B100T4f_SET
#define G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET BCM53115_A0_G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET BCM53115_A0_G_ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXT_P5r_ASY_PAUSEf_GET BCM53115_A0_G_ANADV_EXT_P5r_ASY_PAUSEf_GET
#define G_ANADV_EXT_P5r_ASY_PAUSEf_SET BCM53115_A0_G_ANADV_EXT_P5r_ASY_PAUSEf_SET
#define G_ANADV_EXT_P5r_RESERVED_1Rf_GET BCM53115_A0_G_ANADV_EXT_P5r_RESERVED_1Rf_GET
#define G_ANADV_EXT_P5r_RESERVED_1Rf_SET BCM53115_A0_G_ANADV_EXT_P5r_RESERVED_1Rf_SET
#define G_ANADV_EXT_P5r_REMOTE_FAULT_Rf_GET BCM53115_A0_G_ANADV_EXT_P5r_REMOTE_FAULT_Rf_GET
#define G_ANADV_EXT_P5r_REMOTE_FAULT_Rf_SET BCM53115_A0_G_ANADV_EXT_P5r_REMOTE_FAULT_Rf_SET
#define G_ANADV_EXT_P5r_RESERVED_2Rf_GET BCM53115_A0_G_ANADV_EXT_P5r_RESERVED_2Rf_GET
#define G_ANADV_EXT_P5r_RESERVED_2Rf_SET BCM53115_A0_G_ANADV_EXT_P5r_RESERVED_2Rf_SET
#define G_ANADV_EXT_P5r_NEXT_PAGEf_GET BCM53115_A0_G_ANADV_EXT_P5r_NEXT_PAGEf_GET
#define G_ANADV_EXT_P5r_NEXT_PAGEf_SET BCM53115_A0_G_ANADV_EXT_P5r_NEXT_PAGEf_SET
#define READ_G_ANADV_EXT_P5r BCM53115_A0_READ_G_ANADV_EXT_P5r
#define WRITE_G_ANADV_EXT_P5r BCM53115_A0_WRITE_G_ANADV_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANADV_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANEXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1R      ignore on read.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANEXPr 0x0000100c

#define BCM53115_A0_G_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP.
 *
 */
typedef union BCM53115_A0_G_ANEXPr_s {
	uint32_t v[1];
	uint32_t g_anexp[1];
	uint32_t _g_anexp;
} BCM53115_A0_G_ANEXPr_t;

#define BCM53115_A0_G_ANEXPr_CLR(r) (r).g_anexp[0] = 0
#define BCM53115_A0_G_ANEXPr_SET(r,d) (r).g_anexp[0] = d
#define BCM53115_A0_G_ANEXPr_GET(r) (r).g_anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANEXPr_LP_AN_ABIf_GET(r) (((r).g_anexp[0]) & 0x1)
#define BCM53115_A0_G_ANEXPr_LP_AN_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_ANEXPr_PAGE_RECf_GET(r) ((((r).g_anexp[0]) >> 1) & 0x1)
#define BCM53115_A0_G_ANEXPr_PAGE_RECf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 2) & 0x1)
#define BCM53115_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp[0]) >> 3) & 0x1)
#define BCM53115_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_ANEXPr_PAR_DET_FAILf_GET(r) ((((r).g_anexp[0]) >> 4) & 0x1)
#define BCM53115_A0_G_ANEXPr_PAR_DET_FAILf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_ANEXPr_NEXT_PAGEf_GET(r) ((((r).g_anexp[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANEXPr_NEXT_PAGEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp[0]) >> 6) & 0x1)
#define BCM53115_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_ANEXPr_RESERVED_1Rf_GET(r) ((((r).g_anexp[0]) >> 7) & 0x1ff)
#define BCM53115_A0_G_ANEXPr_RESERVED_1Rf_SET(r,f) (r).g_anexp[0]=(((r).g_anexp[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP.
 *
 */
#define BCM53115_A0_READ_G_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_ANEXPr,(r._g_anexp),2)
#define BCM53115_A0_WRITE_G_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_ANEXPr,&(r._g_anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXPr BCM53115_A0_G_ANEXPr
#define G_ANEXPr_SIZE BCM53115_A0_G_ANEXPr_SIZE
typedef BCM53115_A0_G_ANEXPr_t G_ANEXPr_t;
#define G_ANEXPr_CLR BCM53115_A0_G_ANEXPr_CLR
#define G_ANEXPr_SET BCM53115_A0_G_ANEXPr_SET
#define G_ANEXPr_GET BCM53115_A0_G_ANEXPr_GET
#define G_ANEXPr_LP_AN_ABIf_GET BCM53115_A0_G_ANEXPr_LP_AN_ABIf_GET
#define G_ANEXPr_LP_AN_ABIf_SET BCM53115_A0_G_ANEXPr_LP_AN_ABIf_SET
#define G_ANEXPr_PAGE_RECf_GET BCM53115_A0_G_ANEXPr_PAGE_RECf_GET
#define G_ANEXPr_PAGE_RECf_SET BCM53115_A0_G_ANEXPr_PAGE_RECf_SET
#define G_ANEXPr_NEXT_PAGE_ABIf_GET BCM53115_A0_G_ANEXPr_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_NEXT_PAGE_ABIf_SET BCM53115_A0_G_ANEXPr_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_GET BCM53115_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXPr_LP_NEXT_PAGE_ABIf_SET BCM53115_A0_G_ANEXPr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXPr_PAR_DET_FAILf_GET BCM53115_A0_G_ANEXPr_PAR_DET_FAILf_GET
#define G_ANEXPr_PAR_DET_FAILf_SET BCM53115_A0_G_ANEXPr_PAR_DET_FAILf_SET
#define G_ANEXPr_NEXT_PAGEf_GET BCM53115_A0_G_ANEXPr_NEXT_PAGEf_GET
#define G_ANEXPr_NEXT_PAGEf_SET BCM53115_A0_G_ANEXPr_NEXT_PAGEf_SET
#define G_ANEXPr_NEXT_PAGE_ABLEf_GET BCM53115_A0_G_ANEXPr_NEXT_PAGE_ABLEf_GET
#define G_ANEXPr_NEXT_PAGE_ABLEf_SET BCM53115_A0_G_ANEXPr_NEXT_PAGE_ABLEf_SET
#define G_ANEXPr_RESERVED_1Rf_GET BCM53115_A0_G_ANEXPr_RESERVED_1Rf_GET
#define G_ANEXPr_RESERVED_1Rf_SET BCM53115_A0_G_ANEXPr_RESERVED_1Rf_SET
#define READ_G_ANEXPr BCM53115_A0_READ_G_ANEXPr
#define WRITE_G_ANEXPr BCM53115_A0_WRITE_G_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANEXP_EXT
 * BLOCKS:   CPIC
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1R      ignore on read.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANEXP_EXTr 0x0000880c

#define BCM53115_A0_G_ANEXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT.
 *
 */
typedef union BCM53115_A0_G_ANEXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_anexp_ext[1];
	uint32_t _g_anexp_ext;
} BCM53115_A0_G_ANEXP_EXTr_t;

#define BCM53115_A0_G_ANEXP_EXTr_CLR(r) (r).g_anexp_ext[0] = 0
#define BCM53115_A0_G_ANEXP_EXTr_SET(r,d) (r).g_anexp_ext[0] = d
#define BCM53115_A0_G_ANEXP_EXTr_GET(r) (r).g_anexp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANEXP_EXTr_LP_AN_ABIf_GET(r) (((r).g_anexp_ext[0]) & 0x1)
#define BCM53115_A0_G_ANEXP_EXTr_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_ANEXP_EXTr_PAGE_RECf_GET(r) ((((r).g_anexp_ext[0]) >> 1) & 0x1)
#define BCM53115_A0_G_ANEXP_EXTr_PAGE_RECf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext[0]) >> 2) & 0x1)
#define BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext[0]) >> 3) & 0x1)
#define BCM53115_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_ANEXP_EXTr_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext[0]) >> 4) & 0x1)
#define BCM53115_A0_G_ANEXP_EXTr_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext[0]) >> 6) & 0x1)
#define BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_ANEXP_EXTr_RESERVED_1Rf_GET(r) ((((r).g_anexp_ext[0]) >> 7) & 0x1ff)
#define BCM53115_A0_G_ANEXP_EXTr_RESERVED_1Rf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT.
 *
 */
#define BCM53115_A0_READ_G_ANEXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_ANEXP_EXTr,(r._g_anexp_ext),2)
#define BCM53115_A0_WRITE_G_ANEXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_ANEXP_EXTr,&(r._g_anexp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXTr BCM53115_A0_G_ANEXP_EXTr
#define G_ANEXP_EXTr_SIZE BCM53115_A0_G_ANEXP_EXTr_SIZE
typedef BCM53115_A0_G_ANEXP_EXTr_t G_ANEXP_EXTr_t;
#define G_ANEXP_EXTr_CLR BCM53115_A0_G_ANEXP_EXTr_CLR
#define G_ANEXP_EXTr_SET BCM53115_A0_G_ANEXP_EXTr_SET
#define G_ANEXP_EXTr_GET BCM53115_A0_G_ANEXP_EXTr_GET
#define G_ANEXP_EXTr_LP_AN_ABIf_GET BCM53115_A0_G_ANEXP_EXTr_LP_AN_ABIf_GET
#define G_ANEXP_EXTr_LP_AN_ABIf_SET BCM53115_A0_G_ANEXP_EXTr_LP_AN_ABIf_SET
#define G_ANEXP_EXTr_PAGE_RECf_GET BCM53115_A0_G_ANEXP_EXTr_PAGE_RECf_GET
#define G_ANEXP_EXTr_PAGE_RECf_SET BCM53115_A0_G_ANEXP_EXTr_PAGE_RECf_SET
#define G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET BCM53115_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET BCM53115_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXTr_PAR_DET_FAILf_GET BCM53115_A0_G_ANEXP_EXTr_PAR_DET_FAILf_GET
#define G_ANEXP_EXTr_PAR_DET_FAILf_SET BCM53115_A0_G_ANEXP_EXTr_PAR_DET_FAILf_SET
#define G_ANEXP_EXTr_NEXT_PAGEf_GET BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGEf_GET
#define G_ANEXP_EXTr_NEXT_PAGEf_SET BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGEf_SET
#define G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET BCM53115_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXTr_RESERVED_1Rf_GET BCM53115_A0_G_ANEXP_EXTr_RESERVED_1Rf_GET
#define G_ANEXP_EXTr_RESERVED_1Rf_SET BCM53115_A0_G_ANEXP_EXTr_RESERVED_1Rf_SET
#define READ_G_ANEXP_EXTr BCM53115_A0_READ_G_ANEXP_EXTr
#define WRITE_G_ANEXP_EXTr BCM53115_A0_WRITE_G_ANEXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANEXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANEXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1R      ignore on read.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANEXP_EXT_P5r 0x0000850c

#define BCM53115_A0_G_ANEXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_ANEXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_anexp_ext_p5[1];
	uint32_t _g_anexp_ext_p5;
} BCM53115_A0_G_ANEXP_EXT_P5r_t;

#define BCM53115_A0_G_ANEXP_EXT_P5r_CLR(r) (r).g_anexp_ext_p5[0] = 0
#define BCM53115_A0_G_ANEXP_EXT_P5r_SET(r,d) (r).g_anexp_ext_p5[0] = d
#define BCM53115_A0_G_ANEXP_EXT_P5r_GET(r) (r).g_anexp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANEXP_EXT_P5r_LP_AN_ABIf_GET(r) (((r).g_anexp_ext_p5[0]) & 0x1)
#define BCM53115_A0_G_ANEXP_EXT_P5r_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_ANEXP_EXT_P5r_PAGE_RECf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 1) & 0x1)
#define BCM53115_A0_G_ANEXP_EXT_P5r_PAGE_RECf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 2) & 0x1)
#define BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 3) & 0x1)
#define BCM53115_A0_G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_ANEXP_EXT_P5r_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 4) & 0x1)
#define BCM53115_A0_G_ANEXP_EXT_P5r_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 6) & 0x1)
#define BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_ANEXP_EXT_P5r_RESERVED_1Rf_GET(r) ((((r).g_anexp_ext_p5[0]) >> 7) & 0x1ff)
#define BCM53115_A0_G_ANEXP_EXT_P5r_RESERVED_1Rf_SET(r,f) (r).g_anexp_ext_p5[0]=(((r).g_anexp_ext_p5[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_ANEXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_ANEXP_EXT_P5r,(r._g_anexp_ext_p5),2)
#define BCM53115_A0_WRITE_G_ANEXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_ANEXP_EXT_P5r,&(r._g_anexp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXT_P5r BCM53115_A0_G_ANEXP_EXT_P5r
#define G_ANEXP_EXT_P5r_SIZE BCM53115_A0_G_ANEXP_EXT_P5r_SIZE
typedef BCM53115_A0_G_ANEXP_EXT_P5r_t G_ANEXP_EXT_P5r_t;
#define G_ANEXP_EXT_P5r_CLR BCM53115_A0_G_ANEXP_EXT_P5r_CLR
#define G_ANEXP_EXT_P5r_SET BCM53115_A0_G_ANEXP_EXT_P5r_SET
#define G_ANEXP_EXT_P5r_GET BCM53115_A0_G_ANEXP_EXT_P5r_GET
#define G_ANEXP_EXT_P5r_LP_AN_ABIf_GET BCM53115_A0_G_ANEXP_EXT_P5r_LP_AN_ABIf_GET
#define G_ANEXP_EXT_P5r_LP_AN_ABIf_SET BCM53115_A0_G_ANEXP_EXT_P5r_LP_AN_ABIf_SET
#define G_ANEXP_EXT_P5r_PAGE_RECf_GET BCM53115_A0_G_ANEXP_EXT_P5r_PAGE_RECf_GET
#define G_ANEXP_EXT_P5r_PAGE_RECf_SET BCM53115_A0_G_ANEXP_EXT_P5r_PAGE_RECf_SET
#define G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_GET BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_SET BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_GET BCM53115_A0_G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_SET BCM53115_A0_G_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXT_P5r_PAR_DET_FAILf_GET BCM53115_A0_G_ANEXP_EXT_P5r_PAR_DET_FAILf_GET
#define G_ANEXP_EXT_P5r_PAR_DET_FAILf_SET BCM53115_A0_G_ANEXP_EXT_P5r_PAR_DET_FAILf_SET
#define G_ANEXP_EXT_P5r_NEXT_PAGEf_GET BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGEf_GET
#define G_ANEXP_EXT_P5r_NEXT_PAGEf_SET BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGEf_SET
#define G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET BCM53115_A0_G_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXT_P5r_RESERVED_1Rf_GET BCM53115_A0_G_ANEXP_EXT_P5r_RESERVED_1Rf_GET
#define G_ANEXP_EXT_P5r_RESERVED_1Rf_SET BCM53115_A0_G_ANEXP_EXT_P5r_RESERVED_1Rf_SET
#define READ_G_ANEXP_EXT_P5r BCM53115_A0_READ_G_ANEXP_EXT_P5r
#define WRITE_G_ANEXP_EXT_P5r BCM53115_A0_WRITE_G_ANEXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANEXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANLPA
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANLPAr 0x0000100a

#define BCM53115_A0_G_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA.
 *
 */
typedef union BCM53115_A0_G_ANLPAr_s {
	uint32_t v[1];
	uint32_t g_anlpa[1];
	uint32_t _g_anlpa;
} BCM53115_A0_G_ANLPAr_t;

#define BCM53115_A0_G_ANLPAr_CLR(r) (r).g_anlpa[0] = 0
#define BCM53115_A0_G_ANLPAr_SET(r,d) (r).g_anlpa[0] = d
#define BCM53115_A0_G_ANLPAr_GET(r) (r).g_anlpa[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANLPAr_PROTOCOL_SELf_GET(r) (((r).g_anlpa[0]) & 0x1f)
#define BCM53115_A0_G_ANLPAr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_G_ANLPAr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANLPAr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANLPAr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 7) & 0x1)
#define BCM53115_A0_G_ANLPAr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_ANLPAr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa[0]) >> 8) & 0x1)
#define BCM53115_A0_G_ANLPAr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_ANLPAr_B100T4_CAPf_GET(r) ((((r).g_anlpa[0]) >> 9) & 0x1)
#define BCM53115_A0_G_ANLPAr_B100T4_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_ANLPAr_PAUSE_CAPf_GET(r) ((((r).g_anlpa[0]) >> 10) & 0x1)
#define BCM53115_A0_G_ANLPAr_PAUSE_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANLPAr_RESERVED_1Rf_GET(r) ((((r).g_anlpa[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANLPAr_RESERVED_1Rf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANLPAr_REMOTE_FAULT_Rf_GET(r) ((((r).g_anlpa[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANLPAr_REMOTE_FAULT_Rf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANLPAr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANLPAr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANLPAr_NEXT_PAGEf_GET(r) ((((r).g_anlpa[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANLPAr_NEXT_PAGEf_SET(r,f) (r).g_anlpa[0]=(((r).g_anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA.
 *
 */
#define BCM53115_A0_READ_G_ANLPAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_ANLPAr,(r._g_anlpa),2)
#define BCM53115_A0_WRITE_G_ANLPAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_ANLPAr,&(r._g_anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPAr BCM53115_A0_G_ANLPAr
#define G_ANLPAr_SIZE BCM53115_A0_G_ANLPAr_SIZE
typedef BCM53115_A0_G_ANLPAr_t G_ANLPAr_t;
#define G_ANLPAr_CLR BCM53115_A0_G_ANLPAr_CLR
#define G_ANLPAr_SET BCM53115_A0_G_ANLPAr_SET
#define G_ANLPAr_GET BCM53115_A0_G_ANLPAr_GET
#define G_ANLPAr_PROTOCOL_SELf_GET BCM53115_A0_G_ANLPAr_PROTOCOL_SELf_GET
#define G_ANLPAr_PROTOCOL_SELf_SET BCM53115_A0_G_ANLPAr_PROTOCOL_SELf_SET
#define G_ANLPAr_B10T_FD_CAPf_GET BCM53115_A0_G_ANLPAr_B10T_FD_CAPf_GET
#define G_ANLPAr_B10T_FD_CAPf_SET BCM53115_A0_G_ANLPAr_B10T_FD_CAPf_SET
#define G_ANLPAr_B100_TXHD_CAPf_GET BCM53115_A0_G_ANLPAr_B100_TXHD_CAPf_GET
#define G_ANLPAr_B100_TXHD_CAPf_SET BCM53115_A0_G_ANLPAr_B100_TXHD_CAPf_SET
#define G_ANLPAr_B100_TXFD_CAPf_GET BCM53115_A0_G_ANLPAr_B100_TXFD_CAPf_GET
#define G_ANLPAr_B100_TXFD_CAPf_SET BCM53115_A0_G_ANLPAr_B100_TXFD_CAPf_SET
#define G_ANLPAr_B100T4_CAPf_GET BCM53115_A0_G_ANLPAr_B100T4_CAPf_GET
#define G_ANLPAr_B100T4_CAPf_SET BCM53115_A0_G_ANLPAr_B100T4_CAPf_SET
#define G_ANLPAr_PAUSE_CAPf_GET BCM53115_A0_G_ANLPAr_PAUSE_CAPf_GET
#define G_ANLPAr_PAUSE_CAPf_SET BCM53115_A0_G_ANLPAr_PAUSE_CAPf_SET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_GET BCM53115_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPAr_LK_PAR_ASYM_CAPf_SET BCM53115_A0_G_ANLPAr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPAr_RESERVED_1Rf_GET BCM53115_A0_G_ANLPAr_RESERVED_1Rf_GET
#define G_ANLPAr_RESERVED_1Rf_SET BCM53115_A0_G_ANLPAr_RESERVED_1Rf_SET
#define G_ANLPAr_REMOTE_FAULT_Rf_GET BCM53115_A0_G_ANLPAr_REMOTE_FAULT_Rf_GET
#define G_ANLPAr_REMOTE_FAULT_Rf_SET BCM53115_A0_G_ANLPAr_REMOTE_FAULT_Rf_SET
#define G_ANLPAr_ACKNOWLEDGEf_GET BCM53115_A0_G_ANLPAr_ACKNOWLEDGEf_GET
#define G_ANLPAr_ACKNOWLEDGEf_SET BCM53115_A0_G_ANLPAr_ACKNOWLEDGEf_SET
#define G_ANLPAr_NEXT_PAGEf_GET BCM53115_A0_G_ANLPAr_NEXT_PAGEf_GET
#define G_ANLPAr_NEXT_PAGEf_SET BCM53115_A0_G_ANLPAr_NEXT_PAGEf_SET
#define READ_G_ANLPAr BCM53115_A0_READ_G_ANLPAr
#define WRITE_G_ANLPAr BCM53115_A0_WRITE_G_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANLPAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANLPA_EXT
 * BLOCKS:   CPIC
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANLPA_EXTr 0x0000880a

#define BCM53115_A0_G_ANLPA_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT.
 *
 */
typedef union BCM53115_A0_G_ANLPA_EXTr_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext[1];
	uint32_t _g_anlpa_ext;
} BCM53115_A0_G_ANLPA_EXTr_t;

#define BCM53115_A0_G_ANLPA_EXTr_CLR(r) (r).g_anlpa_ext[0] = 0
#define BCM53115_A0_G_ANLPA_EXTr_SET(r,d) (r).g_anlpa_ext[0] = d
#define BCM53115_A0_G_ANLPA_EXTr_GET(r) (r).g_anlpa_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANLPA_EXTr_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext[0]) & 0x1f)
#define BCM53115_A0_G_ANLPA_EXTr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_G_ANLPA_EXTr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 7) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 8) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_ANLPA_EXTr_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 9) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_ANLPA_EXTr_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 10) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANLPA_EXTr_RESERVED_1Rf_GET(r) ((((r).g_anlpa_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_RESERVED_1Rf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANLPA_EXTr_REMOTE_FAULT_Rf_GET(r) ((((r).g_anlpa_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_REMOTE_FAULT_Rf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANLPA_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANLPA_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT.
 *
 */
#define BCM53115_A0_READ_G_ANLPA_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_ANLPA_EXTr,(r._g_anlpa_ext),2)
#define BCM53115_A0_WRITE_G_ANLPA_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_ANLPA_EXTr,&(r._g_anlpa_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXTr BCM53115_A0_G_ANLPA_EXTr
#define G_ANLPA_EXTr_SIZE BCM53115_A0_G_ANLPA_EXTr_SIZE
typedef BCM53115_A0_G_ANLPA_EXTr_t G_ANLPA_EXTr_t;
#define G_ANLPA_EXTr_CLR BCM53115_A0_G_ANLPA_EXTr_CLR
#define G_ANLPA_EXTr_SET BCM53115_A0_G_ANLPA_EXTr_SET
#define G_ANLPA_EXTr_GET BCM53115_A0_G_ANLPA_EXTr_GET
#define G_ANLPA_EXTr_PROTOCOL_SELf_GET BCM53115_A0_G_ANLPA_EXTr_PROTOCOL_SELf_GET
#define G_ANLPA_EXTr_PROTOCOL_SELf_SET BCM53115_A0_G_ANLPA_EXTr_PROTOCOL_SELf_SET
#define G_ANLPA_EXTr_B10T_FD_CAPf_GET BCM53115_A0_G_ANLPA_EXTr_B10T_FD_CAPf_GET
#define G_ANLPA_EXTr_B10T_FD_CAPf_SET BCM53115_A0_G_ANLPA_EXTr_B10T_FD_CAPf_SET
#define G_ANLPA_EXTr_B100_TXHD_CAPf_GET BCM53115_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_GET
#define G_ANLPA_EXTr_B100_TXHD_CAPf_SET BCM53115_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_SET
#define G_ANLPA_EXTr_B100_TXFD_CAPf_GET BCM53115_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_GET
#define G_ANLPA_EXTr_B100_TXFD_CAPf_SET BCM53115_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_SET
#define G_ANLPA_EXTr_B100T4_CAPf_GET BCM53115_A0_G_ANLPA_EXTr_B100T4_CAPf_GET
#define G_ANLPA_EXTr_B100T4_CAPf_SET BCM53115_A0_G_ANLPA_EXTr_B100T4_CAPf_SET
#define G_ANLPA_EXTr_PAUSE_CAPf_GET BCM53115_A0_G_ANLPA_EXTr_PAUSE_CAPf_GET
#define G_ANLPA_EXTr_PAUSE_CAPf_SET BCM53115_A0_G_ANLPA_EXTr_PAUSE_CAPf_SET
#define G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET BCM53115_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET BCM53115_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXTr_RESERVED_1Rf_GET BCM53115_A0_G_ANLPA_EXTr_RESERVED_1Rf_GET
#define G_ANLPA_EXTr_RESERVED_1Rf_SET BCM53115_A0_G_ANLPA_EXTr_RESERVED_1Rf_SET
#define G_ANLPA_EXTr_REMOTE_FAULT_Rf_GET BCM53115_A0_G_ANLPA_EXTr_REMOTE_FAULT_Rf_GET
#define G_ANLPA_EXTr_REMOTE_FAULT_Rf_SET BCM53115_A0_G_ANLPA_EXTr_REMOTE_FAULT_Rf_SET
#define G_ANLPA_EXTr_ACKNOWLEDGEf_GET BCM53115_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_GET
#define G_ANLPA_EXTr_ACKNOWLEDGEf_SET BCM53115_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_SET
#define G_ANLPA_EXTr_NEXT_PAGEf_GET BCM53115_A0_G_ANLPA_EXTr_NEXT_PAGEf_GET
#define G_ANLPA_EXTr_NEXT_PAGEf_SET BCM53115_A0_G_ANLPA_EXTr_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXTr BCM53115_A0_READ_G_ANLPA_EXTr
#define WRITE_G_ANLPA_EXTr BCM53115_A0_WRITE_G_ANLPA_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANLPA_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANLPA_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1R      write as 0, ignore on read.
 *     REMOTE_FAULT_R   1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANLPA_EXT_P5r 0x0000850a

#define BCM53115_A0_G_ANLPA_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_ANLPA_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext_p5[1];
	uint32_t _g_anlpa_ext_p5;
} BCM53115_A0_G_ANLPA_EXT_P5r_t;

#define BCM53115_A0_G_ANLPA_EXT_P5r_CLR(r) (r).g_anlpa_ext_p5[0] = 0
#define BCM53115_A0_G_ANLPA_EXT_P5r_SET(r,d) (r).g_anlpa_ext_p5[0] = d
#define BCM53115_A0_G_ANLPA_EXT_P5r_GET(r) (r).g_anlpa_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANLPA_EXT_P5r_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext_p5[0]) & 0x1f)
#define BCM53115_A0_G_ANLPA_EXT_P5r_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_G_ANLPA_EXT_P5r_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANLPA_EXT_P5r_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 7) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_ANLPA_EXT_P5r_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 8) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_ANLPA_EXT_P5r_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 9) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_ANLPA_EXT_P5r_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 10) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANLPA_EXT_P5r_RESERVED_1Rf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_RESERVED_1Rf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANLPA_EXT_P5r_REMOTE_FAULT_Rf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_REMOTE_FAULT_Rf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANLPA_EXT_P5r_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANLPA_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANLPA_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext_p5[0]=(((r).g_anlpa_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_ANLPA_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_ANLPA_EXT_P5r,(r._g_anlpa_ext_p5),2)
#define BCM53115_A0_WRITE_G_ANLPA_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_ANLPA_EXT_P5r,&(r._g_anlpa_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXT_P5r BCM53115_A0_G_ANLPA_EXT_P5r
#define G_ANLPA_EXT_P5r_SIZE BCM53115_A0_G_ANLPA_EXT_P5r_SIZE
typedef BCM53115_A0_G_ANLPA_EXT_P5r_t G_ANLPA_EXT_P5r_t;
#define G_ANLPA_EXT_P5r_CLR BCM53115_A0_G_ANLPA_EXT_P5r_CLR
#define G_ANLPA_EXT_P5r_SET BCM53115_A0_G_ANLPA_EXT_P5r_SET
#define G_ANLPA_EXT_P5r_GET BCM53115_A0_G_ANLPA_EXT_P5r_GET
#define G_ANLPA_EXT_P5r_PROTOCOL_SELf_GET BCM53115_A0_G_ANLPA_EXT_P5r_PROTOCOL_SELf_GET
#define G_ANLPA_EXT_P5r_PROTOCOL_SELf_SET BCM53115_A0_G_ANLPA_EXT_P5r_PROTOCOL_SELf_SET
#define G_ANLPA_EXT_P5r_B10T_FD_CAPf_GET BCM53115_A0_G_ANLPA_EXT_P5r_B10T_FD_CAPf_GET
#define G_ANLPA_EXT_P5r_B10T_FD_CAPf_SET BCM53115_A0_G_ANLPA_EXT_P5r_B10T_FD_CAPf_SET
#define G_ANLPA_EXT_P5r_B100_TXHD_CAPf_GET BCM53115_A0_G_ANLPA_EXT_P5r_B100_TXHD_CAPf_GET
#define G_ANLPA_EXT_P5r_B100_TXHD_CAPf_SET BCM53115_A0_G_ANLPA_EXT_P5r_B100_TXHD_CAPf_SET
#define G_ANLPA_EXT_P5r_B100_TXFD_CAPf_GET BCM53115_A0_G_ANLPA_EXT_P5r_B100_TXFD_CAPf_GET
#define G_ANLPA_EXT_P5r_B100_TXFD_CAPf_SET BCM53115_A0_G_ANLPA_EXT_P5r_B100_TXFD_CAPf_SET
#define G_ANLPA_EXT_P5r_B100T4_CAPf_GET BCM53115_A0_G_ANLPA_EXT_P5r_B100T4_CAPf_GET
#define G_ANLPA_EXT_P5r_B100T4_CAPf_SET BCM53115_A0_G_ANLPA_EXT_P5r_B100T4_CAPf_SET
#define G_ANLPA_EXT_P5r_PAUSE_CAPf_GET BCM53115_A0_G_ANLPA_EXT_P5r_PAUSE_CAPf_GET
#define G_ANLPA_EXT_P5r_PAUSE_CAPf_SET BCM53115_A0_G_ANLPA_EXT_P5r_PAUSE_CAPf_SET
#define G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_GET BCM53115_A0_G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_SET BCM53115_A0_G_ANLPA_EXT_P5r_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXT_P5r_RESERVED_1Rf_GET BCM53115_A0_G_ANLPA_EXT_P5r_RESERVED_1Rf_GET
#define G_ANLPA_EXT_P5r_RESERVED_1Rf_SET BCM53115_A0_G_ANLPA_EXT_P5r_RESERVED_1Rf_SET
#define G_ANLPA_EXT_P5r_REMOTE_FAULT_Rf_GET BCM53115_A0_G_ANLPA_EXT_P5r_REMOTE_FAULT_Rf_GET
#define G_ANLPA_EXT_P5r_REMOTE_FAULT_Rf_SET BCM53115_A0_G_ANLPA_EXT_P5r_REMOTE_FAULT_Rf_SET
#define G_ANLPA_EXT_P5r_ACKNOWLEDGEf_GET BCM53115_A0_G_ANLPA_EXT_P5r_ACKNOWLEDGEf_GET
#define G_ANLPA_EXT_P5r_ACKNOWLEDGEf_SET BCM53115_A0_G_ANLPA_EXT_P5r_ACKNOWLEDGEf_SET
#define G_ANLPA_EXT_P5r_NEXT_PAGEf_GET BCM53115_A0_G_ANLPA_EXT_P5r_NEXT_PAGEf_GET
#define G_ANLPA_EXT_P5r_NEXT_PAGEf_SET BCM53115_A0_G_ANLPA_EXT_P5r_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXT_P5r BCM53115_A0_READ_G_ANLPA_EXT_P5r
#define WRITE_G_ANLPA_EXT_P5r BCM53115_A0_WRITE_G_ANLPA_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANLPA_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANNXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1R      ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANNXPr 0x0000100e

#define BCM53115_A0_G_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP.
 *
 */
typedef union BCM53115_A0_G_ANNXPr_s {
	uint32_t v[1];
	uint32_t g_annxp[1];
	uint32_t _g_annxp;
} BCM53115_A0_G_ANNXPr_t;

#define BCM53115_A0_G_ANNXPr_CLR(r) (r).g_annxp[0] = 0
#define BCM53115_A0_G_ANNXPr_SET(r,d) (r).g_annxp[0] = d
#define BCM53115_A0_G_ANNXPr_GET(r) (r).g_annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANNXPr_CODE_FIELDf_GET(r) ((((r).g_annxp[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANNXPr_CODE_FIELDf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANNXPr_TOGGLEf_GET(r) ((((r).g_annxp[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANNXPr_TOGGLEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANNXPr_MES_PAGEf_GET(r) ((((r).g_annxp[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANNXPr_MES_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANNXPr_RESERVED_1Rf_GET(r) ((((r).g_annxp[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANNXPr_RESERVED_1Rf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANNXPr_NEXT_PAGEf_GET(r) ((((r).g_annxp[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANNXPr_NEXT_PAGEf_SET(r,f) (r).g_annxp[0]=(((r).g_annxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP.
 *
 */
#define BCM53115_A0_READ_G_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_ANNXPr,(r._g_annxp),2)
#define BCM53115_A0_WRITE_G_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_ANNXPr,&(r._g_annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXPr BCM53115_A0_G_ANNXPr
#define G_ANNXPr_SIZE BCM53115_A0_G_ANNXPr_SIZE
typedef BCM53115_A0_G_ANNXPr_t G_ANNXPr_t;
#define G_ANNXPr_CLR BCM53115_A0_G_ANNXPr_CLR
#define G_ANNXPr_SET BCM53115_A0_G_ANNXPr_SET
#define G_ANNXPr_GET BCM53115_A0_G_ANNXPr_GET
#define G_ANNXPr_CODE_FIELDf_GET BCM53115_A0_G_ANNXPr_CODE_FIELDf_GET
#define G_ANNXPr_CODE_FIELDf_SET BCM53115_A0_G_ANNXPr_CODE_FIELDf_SET
#define G_ANNXPr_TOGGLEf_GET BCM53115_A0_G_ANNXPr_TOGGLEf_GET
#define G_ANNXPr_TOGGLEf_SET BCM53115_A0_G_ANNXPr_TOGGLEf_SET
#define G_ANNXPr_ACKNOWLEDGE_2f_GET BCM53115_A0_G_ANNXPr_ACKNOWLEDGE_2f_GET
#define G_ANNXPr_ACKNOWLEDGE_2f_SET BCM53115_A0_G_ANNXPr_ACKNOWLEDGE_2f_SET
#define G_ANNXPr_MES_PAGEf_GET BCM53115_A0_G_ANNXPr_MES_PAGEf_GET
#define G_ANNXPr_MES_PAGEf_SET BCM53115_A0_G_ANNXPr_MES_PAGEf_SET
#define G_ANNXPr_RESERVED_1Rf_GET BCM53115_A0_G_ANNXPr_RESERVED_1Rf_GET
#define G_ANNXPr_RESERVED_1Rf_SET BCM53115_A0_G_ANNXPr_RESERVED_1Rf_SET
#define G_ANNXPr_NEXT_PAGEf_GET BCM53115_A0_G_ANNXPr_NEXT_PAGEf_GET
#define G_ANNXPr_NEXT_PAGEf_SET BCM53115_A0_G_ANNXPr_NEXT_PAGEf_SET
#define READ_G_ANNXPr BCM53115_A0_READ_G_ANNXPr
#define WRITE_G_ANNXPr BCM53115_A0_WRITE_G_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANNXP_EXT
 * BLOCKS:   CPIC
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1R      ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANNXP_EXTr 0x0000880e

#define BCM53115_A0_G_ANNXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT.
 *
 */
typedef union BCM53115_A0_G_ANNXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_annxp_ext[1];
	uint32_t _g_annxp_ext;
} BCM53115_A0_G_ANNXP_EXTr_t;

#define BCM53115_A0_G_ANNXP_EXTr_CLR(r) (r).g_annxp_ext[0] = 0
#define BCM53115_A0_G_ANNXP_EXTr_SET(r,d) (r).g_annxp_ext[0] = d
#define BCM53115_A0_G_ANNXP_EXTr_GET(r) (r).g_annxp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANNXP_EXTr_CODE_FIELDf_GET(r) ((((r).g_annxp_ext[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANNXP_EXTr_CODE_FIELDf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANNXP_EXTr_TOGGLEf_GET(r) ((((r).g_annxp_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANNXP_EXTr_TOGGLEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANNXP_EXTr_MES_PAGEf_GET(r) ((((r).g_annxp_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANNXP_EXTr_MES_PAGEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANNXP_EXTr_RESERVED_1Rf_GET(r) ((((r).g_annxp_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANNXP_EXTr_RESERVED_1Rf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANNXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANNXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT.
 *
 */
#define BCM53115_A0_READ_G_ANNXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_ANNXP_EXTr,(r._g_annxp_ext),2)
#define BCM53115_A0_WRITE_G_ANNXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_ANNXP_EXTr,&(r._g_annxp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXTr BCM53115_A0_G_ANNXP_EXTr
#define G_ANNXP_EXTr_SIZE BCM53115_A0_G_ANNXP_EXTr_SIZE
typedef BCM53115_A0_G_ANNXP_EXTr_t G_ANNXP_EXTr_t;
#define G_ANNXP_EXTr_CLR BCM53115_A0_G_ANNXP_EXTr_CLR
#define G_ANNXP_EXTr_SET BCM53115_A0_G_ANNXP_EXTr_SET
#define G_ANNXP_EXTr_GET BCM53115_A0_G_ANNXP_EXTr_GET
#define G_ANNXP_EXTr_CODE_FIELDf_GET BCM53115_A0_G_ANNXP_EXTr_CODE_FIELDf_GET
#define G_ANNXP_EXTr_CODE_FIELDf_SET BCM53115_A0_G_ANNXP_EXTr_CODE_FIELDf_SET
#define G_ANNXP_EXTr_TOGGLEf_GET BCM53115_A0_G_ANNXP_EXTr_TOGGLEf_GET
#define G_ANNXP_EXTr_TOGGLEf_SET BCM53115_A0_G_ANNXP_EXTr_TOGGLEf_SET
#define G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET BCM53115_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET BCM53115_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXTr_MES_PAGEf_GET BCM53115_A0_G_ANNXP_EXTr_MES_PAGEf_GET
#define G_ANNXP_EXTr_MES_PAGEf_SET BCM53115_A0_G_ANNXP_EXTr_MES_PAGEf_SET
#define G_ANNXP_EXTr_RESERVED_1Rf_GET BCM53115_A0_G_ANNXP_EXTr_RESERVED_1Rf_GET
#define G_ANNXP_EXTr_RESERVED_1Rf_SET BCM53115_A0_G_ANNXP_EXTr_RESERVED_1Rf_SET
#define G_ANNXP_EXTr_NEXT_PAGEf_GET BCM53115_A0_G_ANNXP_EXTr_NEXT_PAGEf_GET
#define G_ANNXP_EXTr_NEXT_PAGEf_SET BCM53115_A0_G_ANNXP_EXTr_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXTr BCM53115_A0_READ_G_ANNXP_EXTr
#define WRITE_G_ANNXP_EXTr BCM53115_A0_WRITE_G_ANNXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANNXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_ANNXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1R      ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53115_A0_G_ANNXP_EXT_P5r 0x0000850e

#define BCM53115_A0_G_ANNXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_ANNXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_annxp_ext_p5[1];
	uint32_t _g_annxp_ext_p5;
} BCM53115_A0_G_ANNXP_EXT_P5r_t;

#define BCM53115_A0_G_ANNXP_EXT_P5r_CLR(r) (r).g_annxp_ext_p5[0] = 0
#define BCM53115_A0_G_ANNXP_EXT_P5r_SET(r,d) (r).g_annxp_ext_p5[0] = d
#define BCM53115_A0_G_ANNXP_EXT_P5r_GET(r) (r).g_annxp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_ANNXP_EXT_P5r_CODE_FIELDf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 5) & 0x1)
#define BCM53115_A0_G_ANNXP_EXT_P5r_CODE_FIELDf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_ANNXP_EXT_P5r_TOGGLEf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_ANNXP_EXT_P5r_TOGGLEf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_ANNXP_EXT_P5r_MES_PAGEf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_ANNXP_EXT_P5r_MES_PAGEf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_ANNXP_EXT_P5r_RESERVED_1Rf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_ANNXP_EXT_P5r_RESERVED_1Rf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_ANNXP_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_ANNXP_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext_p5[0]=(((r).g_annxp_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_ANNXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_ANNXP_EXT_P5r,(r._g_annxp_ext_p5),2)
#define BCM53115_A0_WRITE_G_ANNXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_ANNXP_EXT_P5r,&(r._g_annxp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXT_P5r BCM53115_A0_G_ANNXP_EXT_P5r
#define G_ANNXP_EXT_P5r_SIZE BCM53115_A0_G_ANNXP_EXT_P5r_SIZE
typedef BCM53115_A0_G_ANNXP_EXT_P5r_t G_ANNXP_EXT_P5r_t;
#define G_ANNXP_EXT_P5r_CLR BCM53115_A0_G_ANNXP_EXT_P5r_CLR
#define G_ANNXP_EXT_P5r_SET BCM53115_A0_G_ANNXP_EXT_P5r_SET
#define G_ANNXP_EXT_P5r_GET BCM53115_A0_G_ANNXP_EXT_P5r_GET
#define G_ANNXP_EXT_P5r_CODE_FIELDf_GET BCM53115_A0_G_ANNXP_EXT_P5r_CODE_FIELDf_GET
#define G_ANNXP_EXT_P5r_CODE_FIELDf_SET BCM53115_A0_G_ANNXP_EXT_P5r_CODE_FIELDf_SET
#define G_ANNXP_EXT_P5r_TOGGLEf_GET BCM53115_A0_G_ANNXP_EXT_P5r_TOGGLEf_GET
#define G_ANNXP_EXT_P5r_TOGGLEf_SET BCM53115_A0_G_ANNXP_EXT_P5r_TOGGLEf_SET
#define G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_GET BCM53115_A0_G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_SET BCM53115_A0_G_ANNXP_EXT_P5r_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXT_P5r_MES_PAGEf_GET BCM53115_A0_G_ANNXP_EXT_P5r_MES_PAGEf_GET
#define G_ANNXP_EXT_P5r_MES_PAGEf_SET BCM53115_A0_G_ANNXP_EXT_P5r_MES_PAGEf_SET
#define G_ANNXP_EXT_P5r_RESERVED_1Rf_GET BCM53115_A0_G_ANNXP_EXT_P5r_RESERVED_1Rf_GET
#define G_ANNXP_EXT_P5r_RESERVED_1Rf_SET BCM53115_A0_G_ANNXP_EXT_P5r_RESERVED_1Rf_SET
#define G_ANNXP_EXT_P5r_NEXT_PAGEf_GET BCM53115_A0_G_ANNXP_EXT_P5r_NEXT_PAGEf_GET
#define G_ANNXP_EXT_P5r_NEXT_PAGEf_SET BCM53115_A0_G_ANNXP_EXT_P5r_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXT_P5r BCM53115_A0_READ_G_ANNXP_EXT_P5r
#define WRITE_G_ANNXP_EXT_P5r BCM53115_A0_WRITE_G_ANNXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_ANNXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_AUX_CTL
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM53115_A0_G_AUX_CTLr 0x00001030

#define BCM53115_A0_G_AUX_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL.
 *
 */
typedef union BCM53115_A0_G_AUX_CTLr_s {
	uint32_t v[1];
	uint32_t g_aux_ctl[1];
	uint32_t _g_aux_ctl;
} BCM53115_A0_G_AUX_CTLr_t;

#define BCM53115_A0_G_AUX_CTLr_CLR(r) (r).g_aux_ctl[0] = 0
#define BCM53115_A0_G_AUX_CTLr_SET(r,d) (r).g_aux_ctl[0] = d
#define BCM53115_A0_G_AUX_CTLr_GET(r) (r).g_aux_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_AUX_CTLr_SHADOW_REGf_GET(r) (((r).g_aux_ctl[0]) & 0xffff)
#define BCM53115_A0_G_AUX_CTLr_SHADOW_REGf_SET(r,f) (r).g_aux_ctl[0]=(((r).g_aux_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL.
 *
 */
#define BCM53115_A0_READ_G_AUX_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_AUX_CTLr,(r._g_aux_ctl),2)
#define BCM53115_A0_WRITE_G_AUX_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_AUX_CTLr,&(r._g_aux_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTLr BCM53115_A0_G_AUX_CTLr
#define G_AUX_CTLr_SIZE BCM53115_A0_G_AUX_CTLr_SIZE
typedef BCM53115_A0_G_AUX_CTLr_t G_AUX_CTLr_t;
#define G_AUX_CTLr_CLR BCM53115_A0_G_AUX_CTLr_CLR
#define G_AUX_CTLr_SET BCM53115_A0_G_AUX_CTLr_SET
#define G_AUX_CTLr_GET BCM53115_A0_G_AUX_CTLr_GET
#define G_AUX_CTLr_SHADOW_REGf_GET BCM53115_A0_G_AUX_CTLr_SHADOW_REGf_GET
#define G_AUX_CTLr_SHADOW_REGf_SET BCM53115_A0_G_AUX_CTLr_SHADOW_REGf_SET
#define READ_G_AUX_CTLr BCM53115_A0_READ_G_AUX_CTLr
#define WRITE_G_AUX_CTLr BCM53115_A0_WRITE_G_AUX_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_AUX_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_AUX_CTL_EXT
 * BLOCKS:   CPIC
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM53115_A0_G_AUX_CTL_EXTr 0x00008830

#define BCM53115_A0_G_AUX_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT.
 *
 */
typedef union BCM53115_A0_G_AUX_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext[1];
	uint32_t _g_aux_ctl_ext;
} BCM53115_A0_G_AUX_CTL_EXTr_t;

#define BCM53115_A0_G_AUX_CTL_EXTr_CLR(r) (r).g_aux_ctl_ext[0] = 0
#define BCM53115_A0_G_AUX_CTL_EXTr_SET(r,d) (r).g_aux_ctl_ext[0] = d
#define BCM53115_A0_G_AUX_CTL_EXTr_GET(r) (r).g_aux_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_AUX_CTL_EXTr_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext[0]) & 0xffff)
#define BCM53115_A0_G_AUX_CTL_EXTr_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext[0]=(((r).g_aux_ctl_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT.
 *
 */
#define BCM53115_A0_READ_G_AUX_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_AUX_CTL_EXTr,(r._g_aux_ctl_ext),2)
#define BCM53115_A0_WRITE_G_AUX_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_AUX_CTL_EXTr,&(r._g_aux_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXTr BCM53115_A0_G_AUX_CTL_EXTr
#define G_AUX_CTL_EXTr_SIZE BCM53115_A0_G_AUX_CTL_EXTr_SIZE
typedef BCM53115_A0_G_AUX_CTL_EXTr_t G_AUX_CTL_EXTr_t;
#define G_AUX_CTL_EXTr_CLR BCM53115_A0_G_AUX_CTL_EXTr_CLR
#define G_AUX_CTL_EXTr_SET BCM53115_A0_G_AUX_CTL_EXTr_SET
#define G_AUX_CTL_EXTr_GET BCM53115_A0_G_AUX_CTL_EXTr_GET
#define G_AUX_CTL_EXTr_SHADOW_REGf_GET BCM53115_A0_G_AUX_CTL_EXTr_SHADOW_REGf_GET
#define G_AUX_CTL_EXTr_SHADOW_REGf_SET BCM53115_A0_G_AUX_CTL_EXTr_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXTr BCM53115_A0_READ_G_AUX_CTL_EXTr
#define WRITE_G_AUX_CTL_EXTr BCM53115_A0_WRITE_G_AUX_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_AUX_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_AUX_CTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM53115_A0_G_AUX_CTL_EXT_P5r 0x00008530

#define BCM53115_A0_G_AUX_CTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_AUX_CTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext_p5[1];
	uint32_t _g_aux_ctl_ext_p5;
} BCM53115_A0_G_AUX_CTL_EXT_P5r_t;

#define BCM53115_A0_G_AUX_CTL_EXT_P5r_CLR(r) (r).g_aux_ctl_ext_p5[0] = 0
#define BCM53115_A0_G_AUX_CTL_EXT_P5r_SET(r,d) (r).g_aux_ctl_ext_p5[0] = d
#define BCM53115_A0_G_AUX_CTL_EXT_P5r_GET(r) (r).g_aux_ctl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_AUX_CTL_EXT_P5r_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_AUX_CTL_EXT_P5r_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext_p5[0]=(((r).g_aux_ctl_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_AUX_CTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_AUX_CTL_EXT_P5r,(r._g_aux_ctl_ext_p5),2)
#define BCM53115_A0_WRITE_G_AUX_CTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_AUX_CTL_EXT_P5r,&(r._g_aux_ctl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXT_P5r BCM53115_A0_G_AUX_CTL_EXT_P5r
#define G_AUX_CTL_EXT_P5r_SIZE BCM53115_A0_G_AUX_CTL_EXT_P5r_SIZE
typedef BCM53115_A0_G_AUX_CTL_EXT_P5r_t G_AUX_CTL_EXT_P5r_t;
#define G_AUX_CTL_EXT_P5r_CLR BCM53115_A0_G_AUX_CTL_EXT_P5r_CLR
#define G_AUX_CTL_EXT_P5r_SET BCM53115_A0_G_AUX_CTL_EXT_P5r_SET
#define G_AUX_CTL_EXT_P5r_GET BCM53115_A0_G_AUX_CTL_EXT_P5r_GET
#define G_AUX_CTL_EXT_P5r_SHADOW_REGf_GET BCM53115_A0_G_AUX_CTL_EXT_P5r_SHADOW_REGf_GET
#define G_AUX_CTL_EXT_P5r_SHADOW_REGf_SET BCM53115_A0_G_AUX_CTL_EXT_P5r_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXT_P5r BCM53115_A0_READ_G_AUX_CTL_EXT_P5r
#define WRITE_G_AUX_CTL_EXT_P5r BCM53115_A0_WRITE_G_AUX_CTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_AUX_CTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_AUX_STS
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM53115_A0_G_AUX_STSr 0x00001032

#define BCM53115_A0_G_AUX_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS.
 *
 */
typedef union BCM53115_A0_G_AUX_STSr_s {
	uint32_t v[1];
	uint32_t g_aux_sts[1];
	uint32_t _g_aux_sts;
} BCM53115_A0_G_AUX_STSr_t;

#define BCM53115_A0_G_AUX_STSr_CLR(r) (r).g_aux_sts[0] = 0
#define BCM53115_A0_G_AUX_STSr_SET(r,d) (r).g_aux_sts[0] = d
#define BCM53115_A0_G_AUX_STSr_GET(r) (r).g_aux_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_AUX_STSr_AUX_STSf_GET(r) (((r).g_aux_sts[0]) & 0xffff)
#define BCM53115_A0_G_AUX_STSr_AUX_STSf_SET(r,f) (r).g_aux_sts[0]=(((r).g_aux_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS.
 *
 */
#define BCM53115_A0_READ_G_AUX_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_AUX_STSr,(r._g_aux_sts),2)
#define BCM53115_A0_WRITE_G_AUX_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_AUX_STSr,&(r._g_aux_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STSr BCM53115_A0_G_AUX_STSr
#define G_AUX_STSr_SIZE BCM53115_A0_G_AUX_STSr_SIZE
typedef BCM53115_A0_G_AUX_STSr_t G_AUX_STSr_t;
#define G_AUX_STSr_CLR BCM53115_A0_G_AUX_STSr_CLR
#define G_AUX_STSr_SET BCM53115_A0_G_AUX_STSr_SET
#define G_AUX_STSr_GET BCM53115_A0_G_AUX_STSr_GET
#define G_AUX_STSr_AUX_STSf_GET BCM53115_A0_G_AUX_STSr_AUX_STSf_GET
#define G_AUX_STSr_AUX_STSf_SET BCM53115_A0_G_AUX_STSr_AUX_STSf_SET
#define READ_G_AUX_STSr BCM53115_A0_READ_G_AUX_STSr
#define WRITE_G_AUX_STSr BCM53115_A0_WRITE_G_AUX_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_AUX_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_AUX_STS_EXT
 * BLOCKS:   CPIC
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM53115_A0_G_AUX_STS_EXTr 0x00008832

#define BCM53115_A0_G_AUX_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT.
 *
 */
typedef union BCM53115_A0_G_AUX_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext[1];
	uint32_t _g_aux_sts_ext;
} BCM53115_A0_G_AUX_STS_EXTr_t;

#define BCM53115_A0_G_AUX_STS_EXTr_CLR(r) (r).g_aux_sts_ext[0] = 0
#define BCM53115_A0_G_AUX_STS_EXTr_SET(r,d) (r).g_aux_sts_ext[0] = d
#define BCM53115_A0_G_AUX_STS_EXTr_GET(r) (r).g_aux_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_AUX_STS_EXTr_AUX_STSf_GET(r) (((r).g_aux_sts_ext[0]) & 0xffff)
#define BCM53115_A0_G_AUX_STS_EXTr_AUX_STSf_SET(r,f) (r).g_aux_sts_ext[0]=(((r).g_aux_sts_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT.
 *
 */
#define BCM53115_A0_READ_G_AUX_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_AUX_STS_EXTr,(r._g_aux_sts_ext),2)
#define BCM53115_A0_WRITE_G_AUX_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_AUX_STS_EXTr,&(r._g_aux_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXTr BCM53115_A0_G_AUX_STS_EXTr
#define G_AUX_STS_EXTr_SIZE BCM53115_A0_G_AUX_STS_EXTr_SIZE
typedef BCM53115_A0_G_AUX_STS_EXTr_t G_AUX_STS_EXTr_t;
#define G_AUX_STS_EXTr_CLR BCM53115_A0_G_AUX_STS_EXTr_CLR
#define G_AUX_STS_EXTr_SET BCM53115_A0_G_AUX_STS_EXTr_SET
#define G_AUX_STS_EXTr_GET BCM53115_A0_G_AUX_STS_EXTr_GET
#define G_AUX_STS_EXTr_AUX_STSf_GET BCM53115_A0_G_AUX_STS_EXTr_AUX_STSf_GET
#define G_AUX_STS_EXTr_AUX_STSf_SET BCM53115_A0_G_AUX_STS_EXTr_AUX_STSf_SET
#define READ_G_AUX_STS_EXTr BCM53115_A0_READ_G_AUX_STS_EXTr
#define WRITE_G_AUX_STS_EXTr BCM53115_A0_WRITE_G_AUX_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_AUX_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_AUX_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM53115_A0_G_AUX_STS_EXT_P5r 0x00008532

#define BCM53115_A0_G_AUX_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_AUX_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext_p5[1];
	uint32_t _g_aux_sts_ext_p5;
} BCM53115_A0_G_AUX_STS_EXT_P5r_t;

#define BCM53115_A0_G_AUX_STS_EXT_P5r_CLR(r) (r).g_aux_sts_ext_p5[0] = 0
#define BCM53115_A0_G_AUX_STS_EXT_P5r_SET(r,d) (r).g_aux_sts_ext_p5[0] = d
#define BCM53115_A0_G_AUX_STS_EXT_P5r_GET(r) (r).g_aux_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_AUX_STS_EXT_P5r_AUX_STSf_GET(r) (((r).g_aux_sts_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_AUX_STS_EXT_P5r_AUX_STSf_SET(r,f) (r).g_aux_sts_ext_p5[0]=(((r).g_aux_sts_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_AUX_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_AUX_STS_EXT_P5r,(r._g_aux_sts_ext_p5),2)
#define BCM53115_A0_WRITE_G_AUX_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_AUX_STS_EXT_P5r,&(r._g_aux_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXT_P5r BCM53115_A0_G_AUX_STS_EXT_P5r
#define G_AUX_STS_EXT_P5r_SIZE BCM53115_A0_G_AUX_STS_EXT_P5r_SIZE
typedef BCM53115_A0_G_AUX_STS_EXT_P5r_t G_AUX_STS_EXT_P5r_t;
#define G_AUX_STS_EXT_P5r_CLR BCM53115_A0_G_AUX_STS_EXT_P5r_CLR
#define G_AUX_STS_EXT_P5r_SET BCM53115_A0_G_AUX_STS_EXT_P5r_SET
#define G_AUX_STS_EXT_P5r_GET BCM53115_A0_G_AUX_STS_EXT_P5r_GET
#define G_AUX_STS_EXT_P5r_AUX_STSf_GET BCM53115_A0_G_AUX_STS_EXT_P5r_AUX_STSf_GET
#define G_AUX_STS_EXT_P5r_AUX_STSf_SET BCM53115_A0_G_AUX_STS_EXT_P5r_AUX_STSf_SET
#define READ_G_AUX_STS_EXT_P5r BCM53115_A0_READ_G_AUX_STS_EXT_P5r
#define WRITE_G_AUX_STS_EXT_P5r BCM53115_A0_WRITE_G_AUX_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_AUX_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_B1000T_CTL
 * BLOCKS:   GPIC0
 * DESC:     1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE_R      1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM53115_A0_G_B1000T_CTLr 0x00001012

#define BCM53115_A0_G_B1000T_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL.
 *
 */
typedef union BCM53115_A0_G_B1000T_CTLr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl[1];
	uint32_t _g_b1000t_ctl;
} BCM53115_A0_G_B1000T_CTLr_t;

#define BCM53115_A0_G_B1000T_CTLr_CLR(r) (r).g_b1000t_ctl[0] = 0
#define BCM53115_A0_G_B1000T_CTLr_SET(r,d) (r).g_b1000t_ctl[0] = d
#define BCM53115_A0_G_B1000T_CTLr_GET(r) (r).g_b1000t_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_B1000T_CTLr_RESERVED_Rf_GET(r) (((r).g_b1000t_ctl[0]) & 0xff)
#define BCM53115_A0_G_B1000T_CTLr_RESERVED_Rf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 8) & 0x1)
#define BCM53115_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl[0]) >> 9) & 0x1)
#define BCM53115_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_B1000T_CTLr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 10) & 0x1)
#define BCM53115_A0_G_B1000T_CTLr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl[0]) >> 11) & 0x1)
#define BCM53115_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl[0]) >> 12) & 0x1)
#define BCM53115_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_B1000T_CTLr_TEST_MODE_Rf_GET(r) ((((r).g_b1000t_ctl[0]) >> 13) & 0x7)
#define BCM53115_A0_G_B1000T_CTLr_TEST_MODE_Rf_SET(r,f) (r).g_b1000t_ctl[0]=(((r).g_b1000t_ctl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL.
 *
 */
#define BCM53115_A0_READ_G_B1000T_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_B1000T_CTLr,(r._g_b1000t_ctl),2)
#define BCM53115_A0_WRITE_G_B1000T_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_B1000T_CTLr,&(r._g_b1000t_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTLr BCM53115_A0_G_B1000T_CTLr
#define G_B1000T_CTLr_SIZE BCM53115_A0_G_B1000T_CTLr_SIZE
typedef BCM53115_A0_G_B1000T_CTLr_t G_B1000T_CTLr_t;
#define G_B1000T_CTLr_CLR BCM53115_A0_G_B1000T_CTLr_CLR
#define G_B1000T_CTLr_SET BCM53115_A0_G_B1000T_CTLr_SET
#define G_B1000T_CTLr_GET BCM53115_A0_G_B1000T_CTLr_GET
#define G_B1000T_CTLr_RESERVED_Rf_GET BCM53115_A0_G_B1000T_CTLr_RESERVED_Rf_GET
#define G_B1000T_CTLr_RESERVED_Rf_SET BCM53115_A0_G_B1000T_CTLr_RESERVED_Rf_SET
#define G_B1000T_CTLr_ADV_B1000T_HDf_GET BCM53115_A0_G_B1000T_CTLr_ADV_B1000T_HDf_GET
#define G_B1000T_CTLr_ADV_B1000T_HDf_SET BCM53115_A0_G_B1000T_CTLr_ADV_B1000T_HDf_SET
#define G_B1000T_CTLr_ADV_B1000T_FDf_GET BCM53115_A0_G_B1000T_CTLr_ADV_B1000T_FDf_GET
#define G_B1000T_CTLr_ADV_B1000T_FDf_SET BCM53115_A0_G_B1000T_CTLr_ADV_B1000T_FDf_SET
#define G_B1000T_CTLr_REPEATER_DTEf_GET BCM53115_A0_G_B1000T_CTLr_REPEATER_DTEf_GET
#define G_B1000T_CTLr_REPEATER_DTEf_SET BCM53115_A0_G_B1000T_CTLr_REPEATER_DTEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET BCM53115_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET BCM53115_A0_G_B1000T_CTLr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET BCM53115_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET BCM53115_A0_G_B1000T_CTLr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTLr_TEST_MODE_Rf_GET BCM53115_A0_G_B1000T_CTLr_TEST_MODE_Rf_GET
#define G_B1000T_CTLr_TEST_MODE_Rf_SET BCM53115_A0_G_B1000T_CTLr_TEST_MODE_Rf_SET
#define READ_G_B1000T_CTLr BCM53115_A0_READ_G_B1000T_CTLr
#define WRITE_G_B1000T_CTLr BCM53115_A0_WRITE_G_B1000T_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_B1000T_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_B1000T_CTL_EXT
 * BLOCKS:   CPIC
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE_R      1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM53115_A0_G_B1000T_CTL_EXTr 0x00008812

#define BCM53115_A0_G_B1000T_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT.
 *
 */
typedef union BCM53115_A0_G_B1000T_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext[1];
	uint32_t _g_b1000t_ctl_ext;
} BCM53115_A0_G_B1000T_CTL_EXTr_t;

#define BCM53115_A0_G_B1000T_CTL_EXTr_CLR(r) (r).g_b1000t_ctl_ext[0] = 0
#define BCM53115_A0_G_B1000T_CTL_EXTr_SET(r,d) (r).g_b1000t_ctl_ext[0] = d
#define BCM53115_A0_G_B1000T_CTL_EXTr_GET(r) (r).g_b1000t_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_B1000T_CTL_EXTr_RESERVED_Rf_GET(r) (((r).g_b1000t_ctl_ext[0]) & 0xff)
#define BCM53115_A0_G_B1000T_CTL_EXTr_RESERVED_Rf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 8) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 9) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 10) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_B1000T_CTL_EXTr_TEST_MODE_Rf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 13) & 0x7)
#define BCM53115_A0_G_B1000T_CTL_EXTr_TEST_MODE_Rf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT.
 *
 */
#define BCM53115_A0_READ_G_B1000T_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_B1000T_CTL_EXTr,(r._g_b1000t_ctl_ext),2)
#define BCM53115_A0_WRITE_G_B1000T_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_B1000T_CTL_EXTr,&(r._g_b1000t_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXTr BCM53115_A0_G_B1000T_CTL_EXTr
#define G_B1000T_CTL_EXTr_SIZE BCM53115_A0_G_B1000T_CTL_EXTr_SIZE
typedef BCM53115_A0_G_B1000T_CTL_EXTr_t G_B1000T_CTL_EXTr_t;
#define G_B1000T_CTL_EXTr_CLR BCM53115_A0_G_B1000T_CTL_EXTr_CLR
#define G_B1000T_CTL_EXTr_SET BCM53115_A0_G_B1000T_CTL_EXTr_SET
#define G_B1000T_CTL_EXTr_GET BCM53115_A0_G_B1000T_CTL_EXTr_GET
#define G_B1000T_CTL_EXTr_RESERVED_Rf_GET BCM53115_A0_G_B1000T_CTL_EXTr_RESERVED_Rf_GET
#define G_B1000T_CTL_EXTr_RESERVED_Rf_SET BCM53115_A0_G_B1000T_CTL_EXTr_RESERVED_Rf_SET
#define G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET BCM53115_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET BCM53115_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET BCM53115_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET BCM53115_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXTr_REPEATER_DTEf_GET BCM53115_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXTr_REPEATER_DTEf_SET BCM53115_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET BCM53115_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET BCM53115_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET BCM53115_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET BCM53115_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXTr_TEST_MODE_Rf_GET BCM53115_A0_G_B1000T_CTL_EXTr_TEST_MODE_Rf_GET
#define G_B1000T_CTL_EXTr_TEST_MODE_Rf_SET BCM53115_A0_G_B1000T_CTL_EXTr_TEST_MODE_Rf_SET
#define READ_G_B1000T_CTL_EXTr BCM53115_A0_READ_G_B1000T_CTL_EXTr
#define WRITE_G_B1000T_CTL_EXTr BCM53115_A0_WRITE_G_B1000T_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_B1000T_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_B1000T_CTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE_R      1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r 0x00008512

#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_B1000T_CTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext_p5[1];
	uint32_t _g_b1000t_ctl_ext_p5;
} BCM53115_A0_G_B1000T_CTL_EXT_P5r_t;

#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_CLR(r) (r).g_b1000t_ctl_ext_p5[0] = 0
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_SET(r,d) (r).g_b1000t_ctl_ext_p5[0] = d
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_GET(r) (r).g_b1000t_ctl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_RESERVED_Rf_GET(r) (((r).g_b1000t_ctl_ext_p5[0]) & 0xff)
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_RESERVED_Rf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 8) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 9) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 10) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_TEST_MODE_Rf_GET(r) ((((r).g_b1000t_ctl_ext_p5[0]) >> 13) & 0x7)
#define BCM53115_A0_G_B1000T_CTL_EXT_P5r_TEST_MODE_Rf_SET(r,f) (r).g_b1000t_ctl_ext_p5[0]=(((r).g_b1000t_ctl_ext_p5[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_B1000T_CTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_B1000T_CTL_EXT_P5r,(r._g_b1000t_ctl_ext_p5),2)
#define BCM53115_A0_WRITE_G_B1000T_CTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_B1000T_CTL_EXT_P5r,&(r._g_b1000t_ctl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXT_P5r BCM53115_A0_G_B1000T_CTL_EXT_P5r
#define G_B1000T_CTL_EXT_P5r_SIZE BCM53115_A0_G_B1000T_CTL_EXT_P5r_SIZE
typedef BCM53115_A0_G_B1000T_CTL_EXT_P5r_t G_B1000T_CTL_EXT_P5r_t;
#define G_B1000T_CTL_EXT_P5r_CLR BCM53115_A0_G_B1000T_CTL_EXT_P5r_CLR
#define G_B1000T_CTL_EXT_P5r_SET BCM53115_A0_G_B1000T_CTL_EXT_P5r_SET
#define G_B1000T_CTL_EXT_P5r_GET BCM53115_A0_G_B1000T_CTL_EXT_P5r_GET
#define G_B1000T_CTL_EXT_P5r_RESERVED_Rf_GET BCM53115_A0_G_B1000T_CTL_EXT_P5r_RESERVED_Rf_GET
#define G_B1000T_CTL_EXT_P5r_RESERVED_Rf_SET BCM53115_A0_G_B1000T_CTL_EXT_P5r_RESERVED_Rf_SET
#define G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_GET BCM53115_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_SET BCM53115_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_GET BCM53115_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_SET BCM53115_A0_G_B1000T_CTL_EXT_P5r_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_GET BCM53115_A0_G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_SET BCM53115_A0_G_B1000T_CTL_EXT_P5r_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_GET BCM53115_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_SET BCM53115_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_GET BCM53115_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_SET BCM53115_A0_G_B1000T_CTL_EXT_P5r_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXT_P5r_TEST_MODE_Rf_GET BCM53115_A0_G_B1000T_CTL_EXT_P5r_TEST_MODE_Rf_GET
#define G_B1000T_CTL_EXT_P5r_TEST_MODE_Rf_SET BCM53115_A0_G_B1000T_CTL_EXT_P5r_TEST_MODE_Rf_SET
#define READ_G_B1000T_CTL_EXT_P5r BCM53115_A0_READ_G_B1000T_CTL_EXT_P5r
#define WRITE_G_B1000T_CTL_EXT_P5r BCM53115_A0_WRITE_G_B1000T_CTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_B1000T_CTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_B1000T_STS
 * BLOCKS:   GPIC0
 * DESC:     1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED_R       ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM53115_A0_G_B1000T_STSr 0x00001014

#define BCM53115_A0_G_B1000T_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS.
 *
 */
typedef union BCM53115_A0_G_B1000T_STSr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts[1];
	uint32_t _g_b1000t_sts;
} BCM53115_A0_G_B1000T_STSr_t;

#define BCM53115_A0_G_B1000T_STSr_CLR(r) (r).g_b1000t_sts[0] = 0
#define BCM53115_A0_G_B1000T_STSr_SET(r,d) (r).g_b1000t_sts[0] = d
#define BCM53115_A0_G_B1000T_STSr_GET(r) (r).g_b1000t_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts[0]) & 0xff)
#define BCM53115_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_B1000T_STSr_RESERVED_Rf_GET(r) ((((r).g_b1000t_sts[0]) >> 8) & 0x3)
#define BCM53115_A0_G_B1000T_STSr_RESERVED_Rf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53115_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 10) & 0x1)
#define BCM53115_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts[0]) >> 11) & 0x1)
#define BCM53115_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 12) & 0x1)
#define BCM53115_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 13) & 0x1)
#define BCM53115_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts[0]) >> 14) & 0x1)
#define BCM53115_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts[0]) >> 15) & 0x1)
#define BCM53115_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts[0]=(((r).g_b1000t_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS.
 *
 */
#define BCM53115_A0_READ_G_B1000T_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_B1000T_STSr,(r._g_b1000t_sts),2)
#define BCM53115_A0_WRITE_G_B1000T_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_B1000T_STSr,&(r._g_b1000t_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STSr BCM53115_A0_G_B1000T_STSr
#define G_B1000T_STSr_SIZE BCM53115_A0_G_B1000T_STSr_SIZE
typedef BCM53115_A0_G_B1000T_STSr_t G_B1000T_STSr_t;
#define G_B1000T_STSr_CLR BCM53115_A0_G_B1000T_STSr_CLR
#define G_B1000T_STSr_SET BCM53115_A0_G_B1000T_STSr_SET
#define G_B1000T_STSr_GET BCM53115_A0_G_B1000T_STSr_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_GET BCM53115_A0_G_B1000T_STSr_IDLE_ERR_CNTf_GET
#define G_B1000T_STSr_IDLE_ERR_CNTf_SET BCM53115_A0_G_B1000T_STSr_IDLE_ERR_CNTf_SET
#define G_B1000T_STSr_RESERVED_Rf_GET BCM53115_A0_G_B1000T_STSr_RESERVED_Rf_GET
#define G_B1000T_STSr_RESERVED_Rf_SET BCM53115_A0_G_B1000T_STSr_RESERVED_Rf_SET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_GET BCM53115_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_HD_CAPf_SET BCM53115_A0_G_B1000T_STSr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_GET BCM53115_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STSr_LP_B1000T_FD_CAPf_SET BCM53115_A0_G_B1000T_STSr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STSr_REMOTE_REC_STSf_GET BCM53115_A0_G_B1000T_STSr_REMOTE_REC_STSf_GET
#define G_B1000T_STSr_REMOTE_REC_STSf_SET BCM53115_A0_G_B1000T_STSr_REMOTE_REC_STSf_SET
#define G_B1000T_STSr_LOCAL_REC_STSf_GET BCM53115_A0_G_B1000T_STSr_LOCAL_REC_STSf_GET
#define G_B1000T_STSr_LOCAL_REC_STSf_SET BCM53115_A0_G_B1000T_STSr_LOCAL_REC_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_GET BCM53115_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_STSf_SET BCM53115_A0_G_B1000T_STSr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET BCM53115_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET BCM53115_A0_G_B1000T_STSr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STSr BCM53115_A0_READ_G_B1000T_STSr
#define WRITE_G_B1000T_STSr BCM53115_A0_WRITE_G_B1000T_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_B1000T_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_B1000T_STS_EXT
 * BLOCKS:   CPIC
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED_R       ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM53115_A0_G_B1000T_STS_EXTr 0x00008814

#define BCM53115_A0_G_B1000T_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT.
 *
 */
typedef union BCM53115_A0_G_B1000T_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext[1];
	uint32_t _g_b1000t_sts_ext;
} BCM53115_A0_G_B1000T_STS_EXTr_t;

#define BCM53115_A0_G_B1000T_STS_EXTr_CLR(r) (r).g_b1000t_sts_ext[0] = 0
#define BCM53115_A0_G_B1000T_STS_EXTr_SET(r,d) (r).g_b1000t_sts_ext[0] = d
#define BCM53115_A0_G_B1000T_STS_EXTr_GET(r) (r).g_b1000t_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext[0]) & 0xff)
#define BCM53115_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_B1000T_STS_EXTr_RESERVED_Rf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 8) & 0x3)
#define BCM53115_A0_G_B1000T_STS_EXTr_RESERVED_Rf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53115_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 10) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT.
 *
 */
#define BCM53115_A0_READ_G_B1000T_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_B1000T_STS_EXTr,(r._g_b1000t_sts_ext),2)
#define BCM53115_A0_WRITE_G_B1000T_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_B1000T_STS_EXTr,&(r._g_b1000t_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXTr BCM53115_A0_G_B1000T_STS_EXTr
#define G_B1000T_STS_EXTr_SIZE BCM53115_A0_G_B1000T_STS_EXTr_SIZE
typedef BCM53115_A0_G_B1000T_STS_EXTr_t G_B1000T_STS_EXTr_t;
#define G_B1000T_STS_EXTr_CLR BCM53115_A0_G_B1000T_STS_EXTr_CLR
#define G_B1000T_STS_EXTr_SET BCM53115_A0_G_B1000T_STS_EXTr_SET
#define G_B1000T_STS_EXTr_GET BCM53115_A0_G_B1000T_STS_EXTr_GET
#define G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET BCM53115_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET BCM53115_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXTr_RESERVED_Rf_GET BCM53115_A0_G_B1000T_STS_EXTr_RESERVED_Rf_GET
#define G_B1000T_STS_EXTr_RESERVED_Rf_SET BCM53115_A0_G_B1000T_STS_EXTr_RESERVED_Rf_SET
#define G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET BCM53115_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET BCM53115_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET BCM53115_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET BCM53115_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET BCM53115_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET BCM53115_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET BCM53115_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET BCM53115_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET BCM53115_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET BCM53115_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET BCM53115_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET BCM53115_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXTr BCM53115_A0_READ_G_B1000T_STS_EXTr
#define WRITE_G_B1000T_STS_EXTr BCM53115_A0_WRITE_G_B1000T_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_B1000T_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_B1000T_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED_R       ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM53115_A0_G_B1000T_STS_EXT_P5r 0x00008514

#define BCM53115_A0_G_B1000T_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_B1000T_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext_p5[1];
	uint32_t _g_b1000t_sts_ext_p5;
} BCM53115_A0_G_B1000T_STS_EXT_P5r_t;

#define BCM53115_A0_G_B1000T_STS_EXT_P5r_CLR(r) (r).g_b1000t_sts_ext_p5[0] = 0
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_SET(r,d) (r).g_b1000t_sts_ext_p5[0] = d
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_GET(r) (r).g_b1000t_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext_p5[0]) & 0xff)
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_RESERVED_Rf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 8) & 0x3)
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_RESERVED_Rf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 10) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext_p5[0]=(((r).g_b1000t_sts_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_B1000T_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_B1000T_STS_EXT_P5r,(r._g_b1000t_sts_ext_p5),2)
#define BCM53115_A0_WRITE_G_B1000T_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_B1000T_STS_EXT_P5r,&(r._g_b1000t_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXT_P5r BCM53115_A0_G_B1000T_STS_EXT_P5r
#define G_B1000T_STS_EXT_P5r_SIZE BCM53115_A0_G_B1000T_STS_EXT_P5r_SIZE
typedef BCM53115_A0_G_B1000T_STS_EXT_P5r_t G_B1000T_STS_EXT_P5r_t;
#define G_B1000T_STS_EXT_P5r_CLR BCM53115_A0_G_B1000T_STS_EXT_P5r_CLR
#define G_B1000T_STS_EXT_P5r_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_SET
#define G_B1000T_STS_EXT_P5r_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_GET
#define G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXT_P5r_RESERVED_Rf_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_RESERVED_Rf_GET
#define G_B1000T_STS_EXT_P5r_RESERVED_Rf_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_RESERVED_Rf_SET
#define G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_GET BCM53115_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_SET BCM53115_A0_G_B1000T_STS_EXT_P5r_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXT_P5r BCM53115_A0_READ_G_B1000T_STS_EXT_P5r
#define WRITE_G_B1000T_STS_EXT_P5r BCM53115_A0_WRITE_G_B1000T_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_B1000T_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_DSP_COEFFICIENT
 * BLOCKS:   GPIC0
 * DESC:     DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM53115_A0_G_DSP_COEFFICIENTr 0x0000102a

#define BCM53115_A0_G_DSP_COEFFICIENTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT.
 *
 */
typedef union BCM53115_A0_G_DSP_COEFFICIENTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient[1];
	uint32_t _g_dsp_coefficient;
} BCM53115_A0_G_DSP_COEFFICIENTr_t;

#define BCM53115_A0_G_DSP_COEFFICIENTr_CLR(r) (r).g_dsp_coefficient[0] = 0
#define BCM53115_A0_G_DSP_COEFFICIENTr_SET(r,d) (r).g_dsp_coefficient[0] = d
#define BCM53115_A0_G_DSP_COEFFICIENTr_GET(r) (r).g_dsp_coefficient[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient[0]) & 0xffff)
#define BCM53115_A0_G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient[0]=(((r).g_dsp_coefficient[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT.
 *
 */
#define BCM53115_A0_READ_G_DSP_COEFFICIENTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_DSP_COEFFICIENTr,(r._g_dsp_coefficient),2)
#define BCM53115_A0_WRITE_G_DSP_COEFFICIENTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_DSP_COEFFICIENTr,&(r._g_dsp_coefficient),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENTr BCM53115_A0_G_DSP_COEFFICIENTr
#define G_DSP_COEFFICIENTr_SIZE BCM53115_A0_G_DSP_COEFFICIENTr_SIZE
typedef BCM53115_A0_G_DSP_COEFFICIENTr_t G_DSP_COEFFICIENTr_t;
#define G_DSP_COEFFICIENTr_CLR BCM53115_A0_G_DSP_COEFFICIENTr_CLR
#define G_DSP_COEFFICIENTr_SET BCM53115_A0_G_DSP_COEFFICIENTr_SET
#define G_DSP_COEFFICIENTr_GET BCM53115_A0_G_DSP_COEFFICIENTr_GET
#define G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_GET BCM53115_A0_G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_SET BCM53115_A0_G_DSP_COEFFICIENTr_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENTr BCM53115_A0_READ_G_DSP_COEFFICIENTr
#define WRITE_G_DSP_COEFFICIENTr BCM53115_A0_WRITE_G_DSP_COEFFICIENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_DSP_COEFFICIENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR
 * BLOCKS:   GPIC0
 * DESC:     DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr 0x0000102e

#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR.
 *
 */
typedef union BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr[1];
	uint32_t _g_dsp_coefficient_addr;
} BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_t;

#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_CLR(r) (r).g_dsp_coefficient_addr[0] = 0
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_SET(r,d) (r).g_dsp_coefficient_addr[0] = d
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_GET(r) (r).g_dsp_coefficient_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr[0]) & 0xff)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr[0]) >> 8) & 0xf)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr[0]) >> 12) & 0x1)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr[0]) >> 13) & 0x3)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr[0]) >> 15) & 0x1)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr[0]=(((r).g_dsp_coefficient_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR.
 *
 */
#define BCM53115_A0_READ_G_DSP_COEFFICIENT_ADDRr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_DSP_COEFFICIENT_ADDRr,(r._g_dsp_coefficient_addr),2)
#define BCM53115_A0_WRITE_G_DSP_COEFFICIENT_ADDRr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_DSP_COEFFICIENT_ADDRr,&(r._g_dsp_coefficient_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDRr BCM53115_A0_G_DSP_COEFFICIENT_ADDRr
#define G_DSP_COEFFICIENT_ADDRr_SIZE BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_SIZE
typedef BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_t G_DSP_COEFFICIENT_ADDRr_t;
#define G_DSP_COEFFICIENT_ADDRr_CLR BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_CLR
#define G_DSP_COEFFICIENT_ADDRr_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_SET
#define G_DSP_COEFFICIENT_ADDRr_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_GET
#define G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDRr_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDRr BCM53115_A0_READ_G_DSP_COEFFICIENT_ADDRr
#define WRITE_G_DSP_COEFFICIENT_ADDRr BCM53115_A0_WRITE_G_DSP_COEFFICIENT_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_DSP_COEFFICIENT_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT
 * BLOCKS:   CPIC
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr 0x0000882e

#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT.
 *
 */
typedef union BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext[1];
	uint32_t _g_dsp_coefficient_addr_ext;
} BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_t;

#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CLR(r) (r).g_dsp_coefficient_addr_ext[0] = 0
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SET(r,d) (r).g_dsp_coefficient_addr_ext[0] = d
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_GET(r) (r).g_dsp_coefficient_addr_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext[0]) & 0xff)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 8) & 0xf)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 13) & 0x3)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT.
 *
 */
#define BCM53115_A0_READ_G_DSP_COEFFICIENT_ADDR_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr,(r._g_dsp_coefficient_addr_ext),2)
#define BCM53115_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr,&(r._g_dsp_coefficient_addr_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXTr BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr
#define G_DSP_COEFFICIENT_ADDR_EXTr_SIZE BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SIZE
typedef BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_t G_DSP_COEFFICIENT_ADDR_EXTr_t;
#define G_DSP_COEFFICIENT_ADDR_EXTr_CLR BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CLR
#define G_DSP_COEFFICIENT_ADDR_EXTr_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXTr BCM53115_A0_READ_G_DSP_COEFFICIENT_ADDR_EXTr
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXTr BCM53115_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r 0x0000852e

#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext_p5[1];
	uint32_t _g_dsp_coefficient_addr_ext_p5;
} BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_t;

#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CLR(r) (r).g_dsp_coefficient_addr_ext_p5[0] = 0
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_SET(r,d) (r).g_dsp_coefficient_addr_ext_p5[0] = d
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_GET(r) (r).g_dsp_coefficient_addr_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext_p5[0]) & 0xff)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p5[0]) >> 8) & 0xf)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p5[0]) >> 13) & 0x3)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext_p5[0]=(((r).g_dsp_coefficient_addr_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r,(r._g_dsp_coefficient_addr_ext_p5),2)
#define BCM53115_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r,&(r._g_dsp_coefficient_addr_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXT_P5r BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_SIZE BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_SIZE
typedef BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_t G_DSP_COEFFICIENT_ADDR_EXT_P5r_t;
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_CLR BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CLR
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_GET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_SET BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXT_P5r BCM53115_A0_READ_G_DSP_COEFFICIENT_ADDR_EXT_P5r
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P5r BCM53115_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_DSP_COEFFICIENT_ADDR_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT
 * BLOCKS:   CPIC
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM53115_A0_G_DSP_COEFFICIENT_EXTr 0x0000882a

#define BCM53115_A0_G_DSP_COEFFICIENT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT.
 *
 */
typedef union BCM53115_A0_G_DSP_COEFFICIENT_EXTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext[1];
	uint32_t _g_dsp_coefficient_ext;
} BCM53115_A0_G_DSP_COEFFICIENT_EXTr_t;

#define BCM53115_A0_G_DSP_COEFFICIENT_EXTr_CLR(r) (r).g_dsp_coefficient_ext[0] = 0
#define BCM53115_A0_G_DSP_COEFFICIENT_EXTr_SET(r,d) (r).g_dsp_coefficient_ext[0] = d
#define BCM53115_A0_G_DSP_COEFFICIENT_EXTr_GET(r) (r).g_dsp_coefficient_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext[0]) & 0xffff)
#define BCM53115_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext[0]=(((r).g_dsp_coefficient_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT.
 *
 */
#define BCM53115_A0_READ_G_DSP_COEFFICIENT_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_DSP_COEFFICIENT_EXTr,(r._g_dsp_coefficient_ext),2)
#define BCM53115_A0_WRITE_G_DSP_COEFFICIENT_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_DSP_COEFFICIENT_EXTr,&(r._g_dsp_coefficient_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXTr BCM53115_A0_G_DSP_COEFFICIENT_EXTr
#define G_DSP_COEFFICIENT_EXTr_SIZE BCM53115_A0_G_DSP_COEFFICIENT_EXTr_SIZE
typedef BCM53115_A0_G_DSP_COEFFICIENT_EXTr_t G_DSP_COEFFICIENT_EXTr_t;
#define G_DSP_COEFFICIENT_EXTr_CLR BCM53115_A0_G_DSP_COEFFICIENT_EXTr_CLR
#define G_DSP_COEFFICIENT_EXTr_SET BCM53115_A0_G_DSP_COEFFICIENT_EXTr_SET
#define G_DSP_COEFFICIENT_EXTr_GET BCM53115_A0_G_DSP_COEFFICIENT_EXTr_GET
#define G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET BCM53115_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET BCM53115_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXTr BCM53115_A0_READ_G_DSP_COEFFICIENT_EXTr
#define WRITE_G_DSP_COEFFICIENT_EXTr BCM53115_A0_WRITE_G_DSP_COEFFICIENT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_DSP_COEFFICIENT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r 0x0000852a

#define BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext_p5[1];
	uint32_t _g_dsp_coefficient_ext_p5;
} BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_t;

#define BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_CLR(r) (r).g_dsp_coefficient_ext_p5[0] = 0
#define BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_SET(r,d) (r).g_dsp_coefficient_ext_p5[0] = d
#define BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_GET(r) (r).g_dsp_coefficient_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext_p5[0]=(((r).g_dsp_coefficient_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_DSP_COEFFICIENT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r,(r._g_dsp_coefficient_ext_p5),2)
#define BCM53115_A0_WRITE_G_DSP_COEFFICIENT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r,&(r._g_dsp_coefficient_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXT_P5r BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r
#define G_DSP_COEFFICIENT_EXT_P5r_SIZE BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_SIZE
typedef BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_t G_DSP_COEFFICIENT_EXT_P5r_t;
#define G_DSP_COEFFICIENT_EXT_P5r_CLR BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_CLR
#define G_DSP_COEFFICIENT_EXT_P5r_SET BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_SET
#define G_DSP_COEFFICIENT_EXT_P5r_GET BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_GET
#define G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_GET BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_SET BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXT_P5r BCM53115_A0_READ_G_DSP_COEFFICIENT_EXT_P5r
#define WRITE_G_DSP_COEFFICIENT_EXT_P5r BCM53115_A0_WRITE_G_DSP_COEFFICIENT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_DSP_COEFFICIENT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_EXT_STS
 * BLOCKS:   GPIC0
 * DESC:     Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53115_A0_G_EXT_STSr 0x0000101e

#define BCM53115_A0_G_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS.
 *
 */
typedef union BCM53115_A0_G_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_ext_sts[1];
	uint32_t _g_ext_sts;
} BCM53115_A0_G_EXT_STSr_t;

#define BCM53115_A0_G_EXT_STSr_CLR(r) (r).g_ext_sts[0] = 0
#define BCM53115_A0_G_EXT_STSr_SET(r,d) (r).g_ext_sts[0] = d
#define BCM53115_A0_G_EXT_STSr_GET(r) (r).g_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_EXT_STSr_RESERVED_Rf_GET(r) (((r).g_ext_sts[0]) & 0xfff)
#define BCM53115_A0_G_EXT_STSr_RESERVED_Rf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_G_EXT_STSr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 12) & 0x1)
#define BCM53115_A0_G_EXT_STSr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_EXT_STSr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 13) & 0x1)
#define BCM53115_A0_G_EXT_STSr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_EXT_STSr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 14) & 0x1)
#define BCM53115_A0_G_EXT_STSr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_EXT_STSr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts[0]) >> 15) & 0x1)
#define BCM53115_A0_G_EXT_STSr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts[0]=(((r).g_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS.
 *
 */
#define BCM53115_A0_READ_G_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_EXT_STSr,(r._g_ext_sts),2)
#define BCM53115_A0_WRITE_G_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_EXT_STSr,&(r._g_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STSr BCM53115_A0_G_EXT_STSr
#define G_EXT_STSr_SIZE BCM53115_A0_G_EXT_STSr_SIZE
typedef BCM53115_A0_G_EXT_STSr_t G_EXT_STSr_t;
#define G_EXT_STSr_CLR BCM53115_A0_G_EXT_STSr_CLR
#define G_EXT_STSr_SET BCM53115_A0_G_EXT_STSr_SET
#define G_EXT_STSr_GET BCM53115_A0_G_EXT_STSr_GET
#define G_EXT_STSr_RESERVED_Rf_GET BCM53115_A0_G_EXT_STSr_RESERVED_Rf_GET
#define G_EXT_STSr_RESERVED_Rf_SET BCM53115_A0_G_EXT_STSr_RESERVED_Rf_SET
#define G_EXT_STSr_B1000T_HD_CAPf_GET BCM53115_A0_G_EXT_STSr_B1000T_HD_CAPf_GET
#define G_EXT_STSr_B1000T_HD_CAPf_SET BCM53115_A0_G_EXT_STSr_B1000T_HD_CAPf_SET
#define G_EXT_STSr_B1000T_FD_CAPf_GET BCM53115_A0_G_EXT_STSr_B1000T_FD_CAPf_GET
#define G_EXT_STSr_B1000T_FD_CAPf_SET BCM53115_A0_G_EXT_STSr_B1000T_FD_CAPf_SET
#define G_EXT_STSr_B1000X_HD_CAPf_GET BCM53115_A0_G_EXT_STSr_B1000X_HD_CAPf_GET
#define G_EXT_STSr_B1000X_HD_CAPf_SET BCM53115_A0_G_EXT_STSr_B1000X_HD_CAPf_SET
#define G_EXT_STSr_B1000X_FD_CAPf_GET BCM53115_A0_G_EXT_STSr_B1000X_FD_CAPf_GET
#define G_EXT_STSr_B1000X_FD_CAPf_SET BCM53115_A0_G_EXT_STSr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STSr BCM53115_A0_READ_G_EXT_STSr
#define WRITE_G_EXT_STSr BCM53115_A0_WRITE_G_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_EXT_STS_EXT
 * BLOCKS:   CPIC
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53115_A0_G_EXT_STS_EXTr 0x0000881e

#define BCM53115_A0_G_EXT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT.
 *
 */
typedef union BCM53115_A0_G_EXT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext[1];
	uint32_t _g_ext_sts_ext;
} BCM53115_A0_G_EXT_STS_EXTr_t;

#define BCM53115_A0_G_EXT_STS_EXTr_CLR(r) (r).g_ext_sts_ext[0] = 0
#define BCM53115_A0_G_EXT_STS_EXTr_SET(r,d) (r).g_ext_sts_ext[0] = d
#define BCM53115_A0_G_EXT_STS_EXTr_GET(r) (r).g_ext_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_EXT_STS_EXTr_RESERVED_Rf_GET(r) (((r).g_ext_sts_ext[0]) & 0xfff)
#define BCM53115_A0_G_EXT_STS_EXTr_RESERVED_Rf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT.
 *
 */
#define BCM53115_A0_READ_G_EXT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_EXT_STS_EXTr,(r._g_ext_sts_ext),2)
#define BCM53115_A0_WRITE_G_EXT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_EXT_STS_EXTr,&(r._g_ext_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXTr BCM53115_A0_G_EXT_STS_EXTr
#define G_EXT_STS_EXTr_SIZE BCM53115_A0_G_EXT_STS_EXTr_SIZE
typedef BCM53115_A0_G_EXT_STS_EXTr_t G_EXT_STS_EXTr_t;
#define G_EXT_STS_EXTr_CLR BCM53115_A0_G_EXT_STS_EXTr_CLR
#define G_EXT_STS_EXTr_SET BCM53115_A0_G_EXT_STS_EXTr_SET
#define G_EXT_STS_EXTr_GET BCM53115_A0_G_EXT_STS_EXTr_GET
#define G_EXT_STS_EXTr_RESERVED_Rf_GET BCM53115_A0_G_EXT_STS_EXTr_RESERVED_Rf_GET
#define G_EXT_STS_EXTr_RESERVED_Rf_SET BCM53115_A0_G_EXT_STS_EXTr_RESERVED_Rf_SET
#define G_EXT_STS_EXTr_B1000T_HD_CAPf_GET BCM53115_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXTr_B1000T_HD_CAPf_SET BCM53115_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXTr_B1000T_FD_CAPf_GET BCM53115_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXTr_B1000T_FD_CAPf_SET BCM53115_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXTr_B1000X_HD_CAPf_GET BCM53115_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXTr_B1000X_HD_CAPf_SET BCM53115_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXTr_B1000X_FD_CAPf_GET BCM53115_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXTr_B1000X_FD_CAPf_SET BCM53115_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXTr BCM53115_A0_READ_G_EXT_STS_EXTr
#define WRITE_G_EXT_STS_EXTr BCM53115_A0_WRITE_G_EXT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_EXT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_EXT_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53115_A0_G_EXT_STS_EXT_P5r 0x0000851e

#define BCM53115_A0_G_EXT_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_EXT_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext_p5[1];
	uint32_t _g_ext_sts_ext_p5;
} BCM53115_A0_G_EXT_STS_EXT_P5r_t;

#define BCM53115_A0_G_EXT_STS_EXT_P5r_CLR(r) (r).g_ext_sts_ext_p5[0] = 0
#define BCM53115_A0_G_EXT_STS_EXT_P5r_SET(r,d) (r).g_ext_sts_ext_p5[0] = d
#define BCM53115_A0_G_EXT_STS_EXT_P5r_GET(r) (r).g_ext_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_EXT_STS_EXT_P5r_RESERVED_Rf_GET(r) (((r).g_ext_sts_ext_p5[0]) & 0xfff)
#define BCM53115_A0_G_EXT_STS_EXT_P5r_RESERVED_Rf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext_p5[0]=(((r).g_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_EXT_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_EXT_STS_EXT_P5r,(r._g_ext_sts_ext_p5),2)
#define BCM53115_A0_WRITE_G_EXT_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_EXT_STS_EXT_P5r,&(r._g_ext_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXT_P5r BCM53115_A0_G_EXT_STS_EXT_P5r
#define G_EXT_STS_EXT_P5r_SIZE BCM53115_A0_G_EXT_STS_EXT_P5r_SIZE
typedef BCM53115_A0_G_EXT_STS_EXT_P5r_t G_EXT_STS_EXT_P5r_t;
#define G_EXT_STS_EXT_P5r_CLR BCM53115_A0_G_EXT_STS_EXT_P5r_CLR
#define G_EXT_STS_EXT_P5r_SET BCM53115_A0_G_EXT_STS_EXT_P5r_SET
#define G_EXT_STS_EXT_P5r_GET BCM53115_A0_G_EXT_STS_EXT_P5r_GET
#define G_EXT_STS_EXT_P5r_RESERVED_Rf_GET BCM53115_A0_G_EXT_STS_EXT_P5r_RESERVED_Rf_GET
#define G_EXT_STS_EXT_P5r_RESERVED_Rf_SET BCM53115_A0_G_EXT_STS_EXT_P5r_RESERVED_Rf_SET
#define G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_GET BCM53115_A0_G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_SET BCM53115_A0_G_EXT_STS_EXT_P5r_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_GET BCM53115_A0_G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_SET BCM53115_A0_G_EXT_STS_EXT_P5r_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_GET BCM53115_A0_G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_SET BCM53115_A0_G_EXT_STS_EXT_P5r_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_GET BCM53115_A0_G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_SET BCM53115_A0_G_EXT_STS_EXT_P5r_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXT_P5r BCM53115_A0_READ_G_EXT_STS_EXT_P5r
#define WRITE_G_EXT_STS_EXT_P5r BCM53115_A0_WRITE_G_EXT_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_EXT_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_FALSE_CARR_CNT
 * BLOCKS:   GPIC0
 * DESC:     False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM53115_A0_G_FALSE_CARR_CNTr 0x00001026

#define BCM53115_A0_G_FALSE_CARR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT.
 *
 */
typedef union BCM53115_A0_G_FALSE_CARR_CNTr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt[1];
	uint32_t _g_false_carr_cnt;
} BCM53115_A0_G_FALSE_CARR_CNTr_t;

#define BCM53115_A0_G_FALSE_CARR_CNTr_CLR(r) (r).g_false_carr_cnt[0] = 0
#define BCM53115_A0_G_FALSE_CARR_CNTr_SET(r,d) (r).g_false_carr_cnt[0] = d
#define BCM53115_A0_G_FALSE_CARR_CNTr_GET(r) (r).g_false_carr_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt[0]) & 0xff)
#define BCM53115_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt[0]=(((r).g_false_carr_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_FALSE_CARR_CNTr_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt[0]) >> 8) & 0xff)
#define BCM53115_A0_G_FALSE_CARR_CNTr_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt[0]=(((r).g_false_carr_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT.
 *
 */
#define BCM53115_A0_READ_G_FALSE_CARR_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_FALSE_CARR_CNTr,(r._g_false_carr_cnt),2)
#define BCM53115_A0_WRITE_G_FALSE_CARR_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_FALSE_CARR_CNTr,&(r._g_false_carr_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNTr BCM53115_A0_G_FALSE_CARR_CNTr
#define G_FALSE_CARR_CNTr_SIZE BCM53115_A0_G_FALSE_CARR_CNTr_SIZE
typedef BCM53115_A0_G_FALSE_CARR_CNTr_t G_FALSE_CARR_CNTr_t;
#define G_FALSE_CARR_CNTr_CLR BCM53115_A0_G_FALSE_CARR_CNTr_CLR
#define G_FALSE_CARR_CNTr_SET BCM53115_A0_G_FALSE_CARR_CNTr_SET
#define G_FALSE_CARR_CNTr_GET BCM53115_A0_G_FALSE_CARR_CNTr_GET
#define G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET BCM53115_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET BCM53115_A0_G_FALSE_CARR_CNTr_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNTr_SERDES_BER_CNTf_GET BCM53115_A0_G_FALSE_CARR_CNTr_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNTr_SERDES_BER_CNTf_SET BCM53115_A0_G_FALSE_CARR_CNTr_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNTr BCM53115_A0_READ_G_FALSE_CARR_CNTr
#define WRITE_G_FALSE_CARR_CNTr BCM53115_A0_WRITE_G_FALSE_CARR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_FALSE_CARR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT
 * BLOCKS:   CPIC
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr 0x00008826

#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT.
 *
 */
typedef union BCM53115_A0_G_FALSE_CARR_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext[1];
	uint32_t _g_false_carr_cnt_ext;
} BCM53115_A0_G_FALSE_CARR_CNT_EXTr_t;

#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr_CLR(r) (r).g_false_carr_cnt_ext[0] = 0
#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr_SET(r,d) (r).g_false_carr_cnt_ext[0] = d
#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr_GET(r) (r).g_false_carr_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext[0]) & 0xff)
#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext[0]=(((r).g_false_carr_cnt_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext[0]) >> 8) & 0xff)
#define BCM53115_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext[0]=(((r).g_false_carr_cnt_ext[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT.
 *
 */
#define BCM53115_A0_READ_G_FALSE_CARR_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_FALSE_CARR_CNT_EXTr,(r._g_false_carr_cnt_ext),2)
#define BCM53115_A0_WRITE_G_FALSE_CARR_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_FALSE_CARR_CNT_EXTr,&(r._g_false_carr_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXTr BCM53115_A0_G_FALSE_CARR_CNT_EXTr
#define G_FALSE_CARR_CNT_EXTr_SIZE BCM53115_A0_G_FALSE_CARR_CNT_EXTr_SIZE
typedef BCM53115_A0_G_FALSE_CARR_CNT_EXTr_t G_FALSE_CARR_CNT_EXTr_t;
#define G_FALSE_CARR_CNT_EXTr_CLR BCM53115_A0_G_FALSE_CARR_CNT_EXTr_CLR
#define G_FALSE_CARR_CNT_EXTr_SET BCM53115_A0_G_FALSE_CARR_CNT_EXTr_SET
#define G_FALSE_CARR_CNT_EXTr_GET BCM53115_A0_G_FALSE_CARR_CNT_EXTr_GET
#define G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET BCM53115_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET BCM53115_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET BCM53115_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET BCM53115_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXTr BCM53115_A0_READ_G_FALSE_CARR_CNT_EXTr
#define WRITE_G_FALSE_CARR_CNT_EXTr BCM53115_A0_WRITE_G_FALSE_CARR_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_FALSE_CARR_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r 0x00008526

#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext_p5[1];
	uint32_t _g_false_carr_cnt_ext_p5;
} BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_t;

#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_CLR(r) (r).g_false_carr_cnt_ext_p5[0] = 0
#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_SET(r,d) (r).g_false_carr_cnt_ext_p5[0] = d
#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_GET(r) (r).g_false_carr_cnt_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext_p5[0]) & 0xff)
#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_p5[0]=(((r).g_false_carr_cnt_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext_p5[0]) >> 8) & 0xff)
#define BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext_p5[0]=(((r).g_false_carr_cnt_ext_p5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_FALSE_CARR_CNT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r,(r._g_false_carr_cnt_ext_p5),2)
#define BCM53115_A0_WRITE_G_FALSE_CARR_CNT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r,&(r._g_false_carr_cnt_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXT_P5r BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r
#define G_FALSE_CARR_CNT_EXT_P5r_SIZE BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_SIZE
typedef BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_t G_FALSE_CARR_CNT_EXT_P5r_t;
#define G_FALSE_CARR_CNT_EXT_P5r_CLR BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_CLR
#define G_FALSE_CARR_CNT_EXT_P5r_SET BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_SET
#define G_FALSE_CARR_CNT_EXT_P5r_GET BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_GET
#define G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_GET BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_SET BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_GET BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_SET BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXT_P5r BCM53115_A0_READ_G_FALSE_CARR_CNT_EXT_P5r
#define WRITE_G_FALSE_CARR_CNT_EXT_P5r BCM53115_A0_WRITE_G_FALSE_CARR_CNT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_FALSE_CARR_CNT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_INTERRUPT_MSK
 * BLOCKS:   GPIC0
 * DESC:     Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM53115_A0_G_INTERRUPT_MSKr 0x00001036

#define BCM53115_A0_G_INTERRUPT_MSKr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK.
 *
 */
typedef union BCM53115_A0_G_INTERRUPT_MSKr_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk[1];
	uint32_t _g_interrupt_msk;
} BCM53115_A0_G_INTERRUPT_MSKr_t;

#define BCM53115_A0_G_INTERRUPT_MSKr_CLR(r) (r).g_interrupt_msk[0] = 0
#define BCM53115_A0_G_INTERRUPT_MSKr_SET(r,d) (r).g_interrupt_msk[0] = d
#define BCM53115_A0_G_INTERRUPT_MSKr_GET(r) (r).g_interrupt_msk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk[0]) & 0xffff)
#define BCM53115_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk[0]=(((r).g_interrupt_msk[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK.
 *
 */
#define BCM53115_A0_READ_G_INTERRUPT_MSKr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_INTERRUPT_MSKr,(r._g_interrupt_msk),2)
#define BCM53115_A0_WRITE_G_INTERRUPT_MSKr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_INTERRUPT_MSKr,&(r._g_interrupt_msk),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSKr BCM53115_A0_G_INTERRUPT_MSKr
#define G_INTERRUPT_MSKr_SIZE BCM53115_A0_G_INTERRUPT_MSKr_SIZE
typedef BCM53115_A0_G_INTERRUPT_MSKr_t G_INTERRUPT_MSKr_t;
#define G_INTERRUPT_MSKr_CLR BCM53115_A0_G_INTERRUPT_MSKr_CLR
#define G_INTERRUPT_MSKr_SET BCM53115_A0_G_INTERRUPT_MSKr_SET
#define G_INTERRUPT_MSKr_GET BCM53115_A0_G_INTERRUPT_MSKr_GET
#define G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET BCM53115_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET BCM53115_A0_G_INTERRUPT_MSKr_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSKr BCM53115_A0_READ_G_INTERRUPT_MSKr
#define WRITE_G_INTERRUPT_MSKr BCM53115_A0_WRITE_G_INTERRUPT_MSKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_INTERRUPT_MSKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT
 * BLOCKS:   CPIC
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM53115_A0_G_INTERRUPT_MSK_EXTr 0x00008836

#define BCM53115_A0_G_INTERRUPT_MSK_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT.
 *
 */
typedef union BCM53115_A0_G_INTERRUPT_MSK_EXTr_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext[1];
	uint32_t _g_interrupt_msk_ext;
} BCM53115_A0_G_INTERRUPT_MSK_EXTr_t;

#define BCM53115_A0_G_INTERRUPT_MSK_EXTr_CLR(r) (r).g_interrupt_msk_ext[0] = 0
#define BCM53115_A0_G_INTERRUPT_MSK_EXTr_SET(r,d) (r).g_interrupt_msk_ext[0] = d
#define BCM53115_A0_G_INTERRUPT_MSK_EXTr_GET(r) (r).g_interrupt_msk_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext[0]) & 0xffff)
#define BCM53115_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext[0]=(((r).g_interrupt_msk_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT.
 *
 */
#define BCM53115_A0_READ_G_INTERRUPT_MSK_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_INTERRUPT_MSK_EXTr,(r._g_interrupt_msk_ext),2)
#define BCM53115_A0_WRITE_G_INTERRUPT_MSK_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_INTERRUPT_MSK_EXTr,&(r._g_interrupt_msk_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXTr BCM53115_A0_G_INTERRUPT_MSK_EXTr
#define G_INTERRUPT_MSK_EXTr_SIZE BCM53115_A0_G_INTERRUPT_MSK_EXTr_SIZE
typedef BCM53115_A0_G_INTERRUPT_MSK_EXTr_t G_INTERRUPT_MSK_EXTr_t;
#define G_INTERRUPT_MSK_EXTr_CLR BCM53115_A0_G_INTERRUPT_MSK_EXTr_CLR
#define G_INTERRUPT_MSK_EXTr_SET BCM53115_A0_G_INTERRUPT_MSK_EXTr_SET
#define G_INTERRUPT_MSK_EXTr_GET BCM53115_A0_G_INTERRUPT_MSK_EXTr_GET
#define G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET BCM53115_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET BCM53115_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXTr BCM53115_A0_READ_G_INTERRUPT_MSK_EXTr
#define WRITE_G_INTERRUPT_MSK_EXTr BCM53115_A0_WRITE_G_INTERRUPT_MSK_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_INTERRUPT_MSK_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r 0x00008536

#define BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext_p5[1];
	uint32_t _g_interrupt_msk_ext_p5;
} BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_t;

#define BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_CLR(r) (r).g_interrupt_msk_ext_p5[0] = 0
#define BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_SET(r,d) (r).g_interrupt_msk_ext_p5[0] = d
#define BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_GET(r) (r).g_interrupt_msk_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext_p5[0]=(((r).g_interrupt_msk_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_INTERRUPT_MSK_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r,(r._g_interrupt_msk_ext_p5),2)
#define BCM53115_A0_WRITE_G_INTERRUPT_MSK_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r,&(r._g_interrupt_msk_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXT_P5r BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r
#define G_INTERRUPT_MSK_EXT_P5r_SIZE BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_SIZE
typedef BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_t G_INTERRUPT_MSK_EXT_P5r_t;
#define G_INTERRUPT_MSK_EXT_P5r_CLR BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_CLR
#define G_INTERRUPT_MSK_EXT_P5r_SET BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_SET
#define G_INTERRUPT_MSK_EXT_P5r_GET BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_GET
#define G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_GET BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_SET BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXT_P5r BCM53115_A0_READ_G_INTERRUPT_MSK_EXT_P5r
#define WRITE_G_INTERRUPT_MSK_EXT_P5r BCM53115_A0_WRITE_G_INTERRUPT_MSK_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_INTERRUPT_MSK_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_INTERRUPT_STS
 * BLOCKS:   GPIC0
 * DESC:     Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM53115_A0_G_INTERRUPT_STSr 0x00001034

#define BCM53115_A0_G_INTERRUPT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS.
 *
 */
typedef union BCM53115_A0_G_INTERRUPT_STSr_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts[1];
	uint32_t _g_interrupt_sts;
} BCM53115_A0_G_INTERRUPT_STSr_t;

#define BCM53115_A0_G_INTERRUPT_STSr_CLR(r) (r).g_interrupt_sts[0] = 0
#define BCM53115_A0_G_INTERRUPT_STSr_SET(r,d) (r).g_interrupt_sts[0] = d
#define BCM53115_A0_G_INTERRUPT_STSr_GET(r) (r).g_interrupt_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_INTERRUPT_STSr_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts[0]) & 0xffff)
#define BCM53115_A0_G_INTERRUPT_STSr_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts[0]=(((r).g_interrupt_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS.
 *
 */
#define BCM53115_A0_READ_G_INTERRUPT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_INTERRUPT_STSr,(r._g_interrupt_sts),2)
#define BCM53115_A0_WRITE_G_INTERRUPT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_INTERRUPT_STSr,&(r._g_interrupt_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STSr BCM53115_A0_G_INTERRUPT_STSr
#define G_INTERRUPT_STSr_SIZE BCM53115_A0_G_INTERRUPT_STSr_SIZE
typedef BCM53115_A0_G_INTERRUPT_STSr_t G_INTERRUPT_STSr_t;
#define G_INTERRUPT_STSr_CLR BCM53115_A0_G_INTERRUPT_STSr_CLR
#define G_INTERRUPT_STSr_SET BCM53115_A0_G_INTERRUPT_STSr_SET
#define G_INTERRUPT_STSr_GET BCM53115_A0_G_INTERRUPT_STSr_GET
#define G_INTERRUPT_STSr_INTERRUPT_STSf_GET BCM53115_A0_G_INTERRUPT_STSr_INTERRUPT_STSf_GET
#define G_INTERRUPT_STSr_INTERRUPT_STSf_SET BCM53115_A0_G_INTERRUPT_STSr_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STSr BCM53115_A0_READ_G_INTERRUPT_STSr
#define WRITE_G_INTERRUPT_STSr BCM53115_A0_WRITE_G_INTERRUPT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_INTERRUPT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_INTERRUPT_STS_EXT
 * BLOCKS:   CPIC
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM53115_A0_G_INTERRUPT_STS_EXTr 0x00008834

#define BCM53115_A0_G_INTERRUPT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT.
 *
 */
typedef union BCM53115_A0_G_INTERRUPT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext[1];
	uint32_t _g_interrupt_sts_ext;
} BCM53115_A0_G_INTERRUPT_STS_EXTr_t;

#define BCM53115_A0_G_INTERRUPT_STS_EXTr_CLR(r) (r).g_interrupt_sts_ext[0] = 0
#define BCM53115_A0_G_INTERRUPT_STS_EXTr_SET(r,d) (r).g_interrupt_sts_ext[0] = d
#define BCM53115_A0_G_INTERRUPT_STS_EXTr_GET(r) (r).g_interrupt_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext[0]) & 0xffff)
#define BCM53115_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext[0]=(((r).g_interrupt_sts_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT.
 *
 */
#define BCM53115_A0_READ_G_INTERRUPT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_INTERRUPT_STS_EXTr,(r._g_interrupt_sts_ext),2)
#define BCM53115_A0_WRITE_G_INTERRUPT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_INTERRUPT_STS_EXTr,&(r._g_interrupt_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXTr BCM53115_A0_G_INTERRUPT_STS_EXTr
#define G_INTERRUPT_STS_EXTr_SIZE BCM53115_A0_G_INTERRUPT_STS_EXTr_SIZE
typedef BCM53115_A0_G_INTERRUPT_STS_EXTr_t G_INTERRUPT_STS_EXTr_t;
#define G_INTERRUPT_STS_EXTr_CLR BCM53115_A0_G_INTERRUPT_STS_EXTr_CLR
#define G_INTERRUPT_STS_EXTr_SET BCM53115_A0_G_INTERRUPT_STS_EXTr_SET
#define G_INTERRUPT_STS_EXTr_GET BCM53115_A0_G_INTERRUPT_STS_EXTr_GET
#define G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET BCM53115_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET BCM53115_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXTr BCM53115_A0_READ_G_INTERRUPT_STS_EXTr
#define WRITE_G_INTERRUPT_STS_EXTr BCM53115_A0_WRITE_G_INTERRUPT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_INTERRUPT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_INTERRUPT_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM53115_A0_G_INTERRUPT_STS_EXT_P5r 0x00008534

#define BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext_p5[1];
	uint32_t _g_interrupt_sts_ext_p5;
} BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_t;

#define BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_CLR(r) (r).g_interrupt_sts_ext_p5[0] = 0
#define BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_SET(r,d) (r).g_interrupt_sts_ext_p5[0] = d
#define BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_GET(r) (r).g_interrupt_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext_p5[0]=(((r).g_interrupt_sts_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_INTERRUPT_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_INTERRUPT_STS_EXT_P5r,(r._g_interrupt_sts_ext_p5),2)
#define BCM53115_A0_WRITE_G_INTERRUPT_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_INTERRUPT_STS_EXT_P5r,&(r._g_interrupt_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXT_P5r BCM53115_A0_G_INTERRUPT_STS_EXT_P5r
#define G_INTERRUPT_STS_EXT_P5r_SIZE BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_SIZE
typedef BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_t G_INTERRUPT_STS_EXT_P5r_t;
#define G_INTERRUPT_STS_EXT_P5r_CLR BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_CLR
#define G_INTERRUPT_STS_EXT_P5r_SET BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_SET
#define G_INTERRUPT_STS_EXT_P5r_GET BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_GET
#define G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_GET BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_SET BCM53115_A0_G_INTERRUPT_STS_EXT_P5r_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXT_P5r BCM53115_A0_READ_G_INTERRUPT_STS_EXT_P5r
#define WRITE_G_INTERRUPT_STS_EXT_P5r BCM53115_A0_WRITE_G_INTERRUPT_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_INTERRUPT_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_LPNXP
 * BLOCKS:   GPIC0
 * DESC:     Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53115_A0_G_LPNXPr 0x00001010

#define BCM53115_A0_G_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP.
 *
 */
typedef union BCM53115_A0_G_LPNXPr_s {
	uint32_t v[1];
	uint32_t g_lpnxp[1];
	uint32_t _g_lpnxp;
} BCM53115_A0_G_LPNXPr_t;

#define BCM53115_A0_G_LPNXPr_CLR(r) (r).g_lpnxp[0] = 0
#define BCM53115_A0_G_LPNXPr_SET(r,d) (r).g_lpnxp[0] = d
#define BCM53115_A0_G_LPNXPr_GET(r) (r).g_lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_LPNXPr_CODE_FIELDf_GET(r) ((((r).g_lpnxp[0]) >> 5) & 0x1)
#define BCM53115_A0_G_LPNXPr_CODE_FIELDf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_LPNXPr_TOGGLEf_GET(r) ((((r).g_lpnxp[0]) >> 11) & 0x1)
#define BCM53115_A0_G_LPNXPr_TOGGLEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp[0]) >> 12) & 0x1)
#define BCM53115_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_LPNXPr_MES_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 13) & 0x1)
#define BCM53115_A0_G_LPNXPr_MES_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_LPNXPr_ACKf_GET(r) ((((r).g_lpnxp[0]) >> 14) & 0x1)
#define BCM53115_A0_G_LPNXPr_ACKf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_LPNXPr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp[0]) >> 15) & 0x1)
#define BCM53115_A0_G_LPNXPr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp[0]=(((r).g_lpnxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP.
 *
 */
#define BCM53115_A0_READ_G_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_LPNXPr,(r._g_lpnxp),2)
#define BCM53115_A0_WRITE_G_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_LPNXPr,&(r._g_lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXPr BCM53115_A0_G_LPNXPr
#define G_LPNXPr_SIZE BCM53115_A0_G_LPNXPr_SIZE
typedef BCM53115_A0_G_LPNXPr_t G_LPNXPr_t;
#define G_LPNXPr_CLR BCM53115_A0_G_LPNXPr_CLR
#define G_LPNXPr_SET BCM53115_A0_G_LPNXPr_SET
#define G_LPNXPr_GET BCM53115_A0_G_LPNXPr_GET
#define G_LPNXPr_CODE_FIELDf_GET BCM53115_A0_G_LPNXPr_CODE_FIELDf_GET
#define G_LPNXPr_CODE_FIELDf_SET BCM53115_A0_G_LPNXPr_CODE_FIELDf_SET
#define G_LPNXPr_TOGGLEf_GET BCM53115_A0_G_LPNXPr_TOGGLEf_GET
#define G_LPNXPr_TOGGLEf_SET BCM53115_A0_G_LPNXPr_TOGGLEf_SET
#define G_LPNXPr_ACKNOWLEDGE_2f_GET BCM53115_A0_G_LPNXPr_ACKNOWLEDGE_2f_GET
#define G_LPNXPr_ACKNOWLEDGE_2f_SET BCM53115_A0_G_LPNXPr_ACKNOWLEDGE_2f_SET
#define G_LPNXPr_MES_PAGEf_GET BCM53115_A0_G_LPNXPr_MES_PAGEf_GET
#define G_LPNXPr_MES_PAGEf_SET BCM53115_A0_G_LPNXPr_MES_PAGEf_SET
#define G_LPNXPr_ACKf_GET BCM53115_A0_G_LPNXPr_ACKf_GET
#define G_LPNXPr_ACKf_SET BCM53115_A0_G_LPNXPr_ACKf_SET
#define G_LPNXPr_NEXT_PAGEf_GET BCM53115_A0_G_LPNXPr_NEXT_PAGEf_GET
#define G_LPNXPr_NEXT_PAGEf_SET BCM53115_A0_G_LPNXPr_NEXT_PAGEf_SET
#define READ_G_LPNXPr BCM53115_A0_READ_G_LPNXPr
#define WRITE_G_LPNXPr BCM53115_A0_WRITE_G_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_LPNXP_EXT
 * BLOCKS:   CPIC
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53115_A0_G_LPNXP_EXTr 0x00008810

#define BCM53115_A0_G_LPNXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT.
 *
 */
typedef union BCM53115_A0_G_LPNXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext[1];
	uint32_t _g_lpnxp_ext;
} BCM53115_A0_G_LPNXP_EXTr_t;

#define BCM53115_A0_G_LPNXP_EXTr_CLR(r) (r).g_lpnxp_ext[0] = 0
#define BCM53115_A0_G_LPNXP_EXTr_SET(r,d) (r).g_lpnxp_ext[0] = d
#define BCM53115_A0_G_LPNXP_EXTr_GET(r) (r).g_lpnxp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_LPNXP_EXTr_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext[0]) >> 5) & 0x1)
#define BCM53115_A0_G_LPNXP_EXTr_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_LPNXP_EXTr_TOGGLEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_LPNXP_EXTr_TOGGLEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_LPNXP_EXTr_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_LPNXP_EXTr_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_LPNXP_EXTr_ACKf_GET(r) ((((r).g_lpnxp_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_LPNXP_EXTr_ACKf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_LPNXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_LPNXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT.
 *
 */
#define BCM53115_A0_READ_G_LPNXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_LPNXP_EXTr,(r._g_lpnxp_ext),2)
#define BCM53115_A0_WRITE_G_LPNXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_LPNXP_EXTr,&(r._g_lpnxp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXTr BCM53115_A0_G_LPNXP_EXTr
#define G_LPNXP_EXTr_SIZE BCM53115_A0_G_LPNXP_EXTr_SIZE
typedef BCM53115_A0_G_LPNXP_EXTr_t G_LPNXP_EXTr_t;
#define G_LPNXP_EXTr_CLR BCM53115_A0_G_LPNXP_EXTr_CLR
#define G_LPNXP_EXTr_SET BCM53115_A0_G_LPNXP_EXTr_SET
#define G_LPNXP_EXTr_GET BCM53115_A0_G_LPNXP_EXTr_GET
#define G_LPNXP_EXTr_CODE_FIELDf_GET BCM53115_A0_G_LPNXP_EXTr_CODE_FIELDf_GET
#define G_LPNXP_EXTr_CODE_FIELDf_SET BCM53115_A0_G_LPNXP_EXTr_CODE_FIELDf_SET
#define G_LPNXP_EXTr_TOGGLEf_GET BCM53115_A0_G_LPNXP_EXTr_TOGGLEf_GET
#define G_LPNXP_EXTr_TOGGLEf_SET BCM53115_A0_G_LPNXP_EXTr_TOGGLEf_SET
#define G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET BCM53115_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET BCM53115_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXTr_MES_PAGEf_GET BCM53115_A0_G_LPNXP_EXTr_MES_PAGEf_GET
#define G_LPNXP_EXTr_MES_PAGEf_SET BCM53115_A0_G_LPNXP_EXTr_MES_PAGEf_SET
#define G_LPNXP_EXTr_ACKf_GET BCM53115_A0_G_LPNXP_EXTr_ACKf_GET
#define G_LPNXP_EXTr_ACKf_SET BCM53115_A0_G_LPNXP_EXTr_ACKf_SET
#define G_LPNXP_EXTr_NEXT_PAGEf_GET BCM53115_A0_G_LPNXP_EXTr_NEXT_PAGEf_GET
#define G_LPNXP_EXTr_NEXT_PAGEf_SET BCM53115_A0_G_LPNXP_EXTr_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXTr BCM53115_A0_READ_G_LPNXP_EXTr
#define WRITE_G_LPNXP_EXTr BCM53115_A0_WRITE_G_LPNXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_LPNXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_LPNXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53115_A0_G_LPNXP_EXT_P5r 0x00008510

#define BCM53115_A0_G_LPNXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_LPNXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext_p5[1];
	uint32_t _g_lpnxp_ext_p5;
} BCM53115_A0_G_LPNXP_EXT_P5r_t;

#define BCM53115_A0_G_LPNXP_EXT_P5r_CLR(r) (r).g_lpnxp_ext_p5[0] = 0
#define BCM53115_A0_G_LPNXP_EXT_P5r_SET(r,d) (r).g_lpnxp_ext_p5[0] = d
#define BCM53115_A0_G_LPNXP_EXT_P5r_GET(r) (r).g_lpnxp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_LPNXP_EXT_P5r_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 5) & 0x1)
#define BCM53115_A0_G_LPNXP_EXT_P5r_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_LPNXP_EXT_P5r_TOGGLEf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_LPNXP_EXT_P5r_TOGGLEf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_LPNXP_EXT_P5r_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_LPNXP_EXT_P5r_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_LPNXP_EXT_P5r_ACKf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_LPNXP_EXT_P5r_ACKf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_LPNXP_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_LPNXP_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext_p5[0]=(((r).g_lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_LPNXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_LPNXP_EXT_P5r,(r._g_lpnxp_ext_p5),2)
#define BCM53115_A0_WRITE_G_LPNXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_LPNXP_EXT_P5r,&(r._g_lpnxp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXT_P5r BCM53115_A0_G_LPNXP_EXT_P5r
#define G_LPNXP_EXT_P5r_SIZE BCM53115_A0_G_LPNXP_EXT_P5r_SIZE
typedef BCM53115_A0_G_LPNXP_EXT_P5r_t G_LPNXP_EXT_P5r_t;
#define G_LPNXP_EXT_P5r_CLR BCM53115_A0_G_LPNXP_EXT_P5r_CLR
#define G_LPNXP_EXT_P5r_SET BCM53115_A0_G_LPNXP_EXT_P5r_SET
#define G_LPNXP_EXT_P5r_GET BCM53115_A0_G_LPNXP_EXT_P5r_GET
#define G_LPNXP_EXT_P5r_CODE_FIELDf_GET BCM53115_A0_G_LPNXP_EXT_P5r_CODE_FIELDf_GET
#define G_LPNXP_EXT_P5r_CODE_FIELDf_SET BCM53115_A0_G_LPNXP_EXT_P5r_CODE_FIELDf_SET
#define G_LPNXP_EXT_P5r_TOGGLEf_GET BCM53115_A0_G_LPNXP_EXT_P5r_TOGGLEf_GET
#define G_LPNXP_EXT_P5r_TOGGLEf_SET BCM53115_A0_G_LPNXP_EXT_P5r_TOGGLEf_SET
#define G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_GET BCM53115_A0_G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_SET BCM53115_A0_G_LPNXP_EXT_P5r_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXT_P5r_MES_PAGEf_GET BCM53115_A0_G_LPNXP_EXT_P5r_MES_PAGEf_GET
#define G_LPNXP_EXT_P5r_MES_PAGEf_SET BCM53115_A0_G_LPNXP_EXT_P5r_MES_PAGEf_SET
#define G_LPNXP_EXT_P5r_ACKf_GET BCM53115_A0_G_LPNXP_EXT_P5r_ACKf_GET
#define G_LPNXP_EXT_P5r_ACKf_SET BCM53115_A0_G_LPNXP_EXT_P5r_ACKf_SET
#define G_LPNXP_EXT_P5r_NEXT_PAGEf_GET BCM53115_A0_G_LPNXP_EXT_P5r_NEXT_PAGEf_GET
#define G_LPNXP_EXT_P5r_NEXT_PAGEf_SET BCM53115_A0_G_LPNXP_EXT_P5r_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXT_P5r BCM53115_A0_READ_G_LPNXP_EXT_P5r
#define WRITE_G_LPNXP_EXT_P5r BCM53115_A0_WRITE_G_LPNXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_LPNXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MASTER_SLAVE_SEED
 * BLOCKS:   GPIC0
 * DESC:     Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED_R           Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM53115_A0_G_MASTER_SLAVE_SEEDr 0x0000103a

#define BCM53115_A0_G_MASTER_SLAVE_SEEDr_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED.
 *
 */
typedef union BCM53115_A0_G_MASTER_SLAVE_SEEDr_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed[1];
	uint32_t _g_master_slave_seed;
} BCM53115_A0_G_MASTER_SLAVE_SEEDr_t;

#define BCM53115_A0_G_MASTER_SLAVE_SEEDr_CLR(r) (r).g_master_slave_seed[0] = 0
#define BCM53115_A0_G_MASTER_SLAVE_SEEDr_SET(r,d) (r).g_master_slave_seed[0] = d
#define BCM53115_A0_G_MASTER_SLAVE_SEEDr_GET(r) (r).g_master_slave_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MASTER_SLAVE_SEEDr_SEED_Rf_GET(r) (((r).g_master_slave_seed[0]) & 0xffff)
#define BCM53115_A0_G_MASTER_SLAVE_SEEDr_SEED_Rf_SET(r,f) (r).g_master_slave_seed[0]=(((r).g_master_slave_seed[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED.
 *
 */
#define BCM53115_A0_READ_G_MASTER_SLAVE_SEEDr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_MASTER_SLAVE_SEEDr,(r._g_master_slave_seed),2)
#define BCM53115_A0_WRITE_G_MASTER_SLAVE_SEEDr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_MASTER_SLAVE_SEEDr,&(r._g_master_slave_seed),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEEDr BCM53115_A0_G_MASTER_SLAVE_SEEDr
#define G_MASTER_SLAVE_SEEDr_SIZE BCM53115_A0_G_MASTER_SLAVE_SEEDr_SIZE
typedef BCM53115_A0_G_MASTER_SLAVE_SEEDr_t G_MASTER_SLAVE_SEEDr_t;
#define G_MASTER_SLAVE_SEEDr_CLR BCM53115_A0_G_MASTER_SLAVE_SEEDr_CLR
#define G_MASTER_SLAVE_SEEDr_SET BCM53115_A0_G_MASTER_SLAVE_SEEDr_SET
#define G_MASTER_SLAVE_SEEDr_GET BCM53115_A0_G_MASTER_SLAVE_SEEDr_GET
#define G_MASTER_SLAVE_SEEDr_SEED_Rf_GET BCM53115_A0_G_MASTER_SLAVE_SEEDr_SEED_Rf_GET
#define G_MASTER_SLAVE_SEEDr_SEED_Rf_SET BCM53115_A0_G_MASTER_SLAVE_SEEDr_SEED_Rf_SET
#define READ_G_MASTER_SLAVE_SEEDr BCM53115_A0_READ_G_MASTER_SLAVE_SEEDr
#define WRITE_G_MASTER_SLAVE_SEEDr BCM53115_A0_WRITE_G_MASTER_SLAVE_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MASTER_SLAVE_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT
 * BLOCKS:   CPIC
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED_R           Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr 0x0000883a

#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT.
 *
 */
typedef union BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext[1];
	uint32_t _g_master_slave_seed_ext;
} BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_t;

#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_CLR(r) (r).g_master_slave_seed_ext[0] = 0
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_SET(r,d) (r).g_master_slave_seed_ext[0] = d
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_GET(r) (r).g_master_slave_seed_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_SEED_Rf_GET(r) (((r).g_master_slave_seed_ext[0]) & 0xffff)
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_SEED_Rf_SET(r,f) (r).g_master_slave_seed_ext[0]=(((r).g_master_slave_seed_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT.
 *
 */
#define BCM53115_A0_READ_G_MASTER_SLAVE_SEED_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr,(r._g_master_slave_seed_ext),2)
#define BCM53115_A0_WRITE_G_MASTER_SLAVE_SEED_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr,&(r._g_master_slave_seed_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXTr BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr
#define G_MASTER_SLAVE_SEED_EXTr_SIZE BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_SIZE
typedef BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_t G_MASTER_SLAVE_SEED_EXTr_t;
#define G_MASTER_SLAVE_SEED_EXTr_CLR BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_CLR
#define G_MASTER_SLAVE_SEED_EXTr_SET BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_SET
#define G_MASTER_SLAVE_SEED_EXTr_GET BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_GET
#define G_MASTER_SLAVE_SEED_EXTr_SEED_Rf_GET BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_SEED_Rf_GET
#define G_MASTER_SLAVE_SEED_EXTr_SEED_Rf_SET BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr_SEED_Rf_SET
#define READ_G_MASTER_SLAVE_SEED_EXTr BCM53115_A0_READ_G_MASTER_SLAVE_SEED_EXTr
#define WRITE_G_MASTER_SLAVE_SEED_EXTr BCM53115_A0_WRITE_G_MASTER_SLAVE_SEED_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MASTER_SLAVE_SEED_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED_R           Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r 0x0000853a

#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext_p5[1];
	uint32_t _g_master_slave_seed_ext_p5;
} BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_t;

#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_CLR(r) (r).g_master_slave_seed_ext_p5[0] = 0
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SET(r,d) (r).g_master_slave_seed_ext_p5[0] = d
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_GET(r) (r).g_master_slave_seed_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SEED_Rf_GET(r) (((r).g_master_slave_seed_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SEED_Rf_SET(r,f) (r).g_master_slave_seed_ext_p5[0]=(((r).g_master_slave_seed_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_MASTER_SLAVE_SEED_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r,(r._g_master_slave_seed_ext_p5),2)
#define BCM53115_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r,&(r._g_master_slave_seed_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXT_P5r BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r
#define G_MASTER_SLAVE_SEED_EXT_P5r_SIZE BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SIZE
typedef BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_t G_MASTER_SLAVE_SEED_EXT_P5r_t;
#define G_MASTER_SLAVE_SEED_EXT_P5r_CLR BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_CLR
#define G_MASTER_SLAVE_SEED_EXT_P5r_SET BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SET
#define G_MASTER_SLAVE_SEED_EXT_P5r_GET BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_GET
#define G_MASTER_SLAVE_SEED_EXT_P5r_SEED_Rf_GET BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SEED_Rf_GET
#define G_MASTER_SLAVE_SEED_EXT_P5r_SEED_Rf_SET BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r_SEED_Rf_SET
#define READ_G_MASTER_SLAVE_SEED_EXT_P5r BCM53115_A0_READ_G_MASTER_SLAVE_SEED_EXT_P5r
#define WRITE_G_MASTER_SLAVE_SEED_EXT_P5r BCM53115_A0_WRITE_G_MASTER_SLAVE_SEED_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MASTER_SLAVE_SEED_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MIICTL
 * BLOCKS:   GPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET_R          1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM53115_A0_G_MIICTLr 0x00001000

#define BCM53115_A0_G_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL.
 *
 */
typedef union BCM53115_A0_G_MIICTLr_s {
	uint32_t v[1];
	uint32_t g_miictl[1];
	uint32_t _g_miictl;
} BCM53115_A0_G_MIICTLr_t;

#define BCM53115_A0_G_MIICTLr_CLR(r) (r).g_miictl[0] = 0
#define BCM53115_A0_G_MIICTLr_SET(r,d) (r).g_miictl[0] = d
#define BCM53115_A0_G_MIICTLr_GET(r) (r).g_miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MIICTLr_RESERVED_Rf_GET(r) (((r).g_miictl[0]) & 0x3f)
#define BCM53115_A0_G_MIICTLr_RESERVED_Rf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_G_MIICTLr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl[0]) >> 6) & 0x1)
#define BCM53115_A0_G_MIICTLr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_MIICTLr_COL_TESTf_GET(r) ((((r).g_miictl[0]) >> 7) & 0x1)
#define BCM53115_A0_G_MIICTLr_COL_TESTf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_MIICTLr_DUPLEX_MODf_GET(r) ((((r).g_miictl[0]) >> 8) & 0x1)
#define BCM53115_A0_G_MIICTLr_DUPLEX_MODf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_MIICTLr_RE_ANf_GET(r) ((((r).g_miictl[0]) >> 9) & 0x1)
#define BCM53115_A0_G_MIICTLr_RE_ANf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_MIICTLr_ISOLATEf_GET(r) ((((r).g_miictl[0]) >> 10) & 0x1)
#define BCM53115_A0_G_MIICTLr_ISOLATEf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_MIICTLr_PWR_DOWNf_GET(r) ((((r).g_miictl[0]) >> 11) & 0x1)
#define BCM53115_A0_G_MIICTLr_PWR_DOWNf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_MIICTLr_AN_ENf_GET(r) ((((r).g_miictl[0]) >> 12) & 0x1)
#define BCM53115_A0_G_MIICTLr_AN_ENf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_MIICTLr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl[0]) >> 13) & 0x1)
#define BCM53115_A0_G_MIICTLr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_MIICTLr_LOOPBACKf_GET(r) ((((r).g_miictl[0]) >> 14) & 0x1)
#define BCM53115_A0_G_MIICTLr_LOOPBACKf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_MIICTLr_RESET_Rf_GET(r) ((((r).g_miictl[0]) >> 15) & 0x1)
#define BCM53115_A0_G_MIICTLr_RESET_Rf_SET(r,f) (r).g_miictl[0]=(((r).g_miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL.
 *
 */
#define BCM53115_A0_READ_G_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_MIICTLr,(r._g_miictl),2)
#define BCM53115_A0_WRITE_G_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_MIICTLr,&(r._g_miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTLr BCM53115_A0_G_MIICTLr
#define G_MIICTLr_SIZE BCM53115_A0_G_MIICTLr_SIZE
typedef BCM53115_A0_G_MIICTLr_t G_MIICTLr_t;
#define G_MIICTLr_CLR BCM53115_A0_G_MIICTLr_CLR
#define G_MIICTLr_SET BCM53115_A0_G_MIICTLr_SET
#define G_MIICTLr_GET BCM53115_A0_G_MIICTLr_GET
#define G_MIICTLr_RESERVED_Rf_GET BCM53115_A0_G_MIICTLr_RESERVED_Rf_GET
#define G_MIICTLr_RESERVED_Rf_SET BCM53115_A0_G_MIICTLr_RESERVED_Rf_SET
#define G_MIICTLr_SPD_SEL_MSBf_GET BCM53115_A0_G_MIICTLr_SPD_SEL_MSBf_GET
#define G_MIICTLr_SPD_SEL_MSBf_SET BCM53115_A0_G_MIICTLr_SPD_SEL_MSBf_SET
#define G_MIICTLr_COL_TESTf_GET BCM53115_A0_G_MIICTLr_COL_TESTf_GET
#define G_MIICTLr_COL_TESTf_SET BCM53115_A0_G_MIICTLr_COL_TESTf_SET
#define G_MIICTLr_DUPLEX_MODf_GET BCM53115_A0_G_MIICTLr_DUPLEX_MODf_GET
#define G_MIICTLr_DUPLEX_MODf_SET BCM53115_A0_G_MIICTLr_DUPLEX_MODf_SET
#define G_MIICTLr_RE_ANf_GET BCM53115_A0_G_MIICTLr_RE_ANf_GET
#define G_MIICTLr_RE_ANf_SET BCM53115_A0_G_MIICTLr_RE_ANf_SET
#define G_MIICTLr_ISOLATEf_GET BCM53115_A0_G_MIICTLr_ISOLATEf_GET
#define G_MIICTLr_ISOLATEf_SET BCM53115_A0_G_MIICTLr_ISOLATEf_SET
#define G_MIICTLr_PWR_DOWNf_GET BCM53115_A0_G_MIICTLr_PWR_DOWNf_GET
#define G_MIICTLr_PWR_DOWNf_SET BCM53115_A0_G_MIICTLr_PWR_DOWNf_SET
#define G_MIICTLr_AN_ENf_GET BCM53115_A0_G_MIICTLr_AN_ENf_GET
#define G_MIICTLr_AN_ENf_SET BCM53115_A0_G_MIICTLr_AN_ENf_SET
#define G_MIICTLr_SPD_SEL_LSBf_GET BCM53115_A0_G_MIICTLr_SPD_SEL_LSBf_GET
#define G_MIICTLr_SPD_SEL_LSBf_SET BCM53115_A0_G_MIICTLr_SPD_SEL_LSBf_SET
#define G_MIICTLr_LOOPBACKf_GET BCM53115_A0_G_MIICTLr_LOOPBACKf_GET
#define G_MIICTLr_LOOPBACKf_SET BCM53115_A0_G_MIICTLr_LOOPBACKf_SET
#define G_MIICTLr_RESET_Rf_GET BCM53115_A0_G_MIICTLr_RESET_Rf_GET
#define G_MIICTLr_RESET_Rf_SET BCM53115_A0_G_MIICTLr_RESET_Rf_SET
#define READ_G_MIICTLr BCM53115_A0_READ_G_MIICTLr
#define WRITE_G_MIICTLr BCM53115_A0_WRITE_G_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MIICTL_EXT
 * BLOCKS:   CPIC
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET_R          1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM53115_A0_G_MIICTL_EXTr 0x00008800

#define BCM53115_A0_G_MIICTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT.
 *
 */
typedef union BCM53115_A0_G_MIICTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_miictl_ext[1];
	uint32_t _g_miictl_ext;
} BCM53115_A0_G_MIICTL_EXTr_t;

#define BCM53115_A0_G_MIICTL_EXTr_CLR(r) (r).g_miictl_ext[0] = 0
#define BCM53115_A0_G_MIICTL_EXTr_SET(r,d) (r).g_miictl_ext[0] = d
#define BCM53115_A0_G_MIICTL_EXTr_GET(r) (r).g_miictl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MIICTL_EXTr_RESERVED_Rf_GET(r) (((r).g_miictl_ext[0]) & 0x3f)
#define BCM53115_A0_G_MIICTL_EXTr_RESERVED_Rf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext[0]) >> 6) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_MIICTL_EXTr_COL_TESTf_GET(r) ((((r).g_miictl_ext[0]) >> 7) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_COL_TESTf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_MIICTL_EXTr_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext[0]) >> 8) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_MIICTL_EXTr_RE_ANf_GET(r) ((((r).g_miictl_ext[0]) >> 9) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_RE_ANf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_MIICTL_EXTr_ISOLATEf_GET(r) ((((r).g_miictl_ext[0]) >> 10) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_ISOLATEf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_MIICTL_EXTr_PWR_DOWNf_GET(r) ((((r).g_miictl_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_PWR_DOWNf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_MIICTL_EXTr_AN_ENf_GET(r) ((((r).g_miictl_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_AN_ENf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_MIICTL_EXTr_LOOPBACKf_GET(r) ((((r).g_miictl_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_LOOPBACKf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_MIICTL_EXTr_RESET_Rf_GET(r) ((((r).g_miictl_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_MIICTL_EXTr_RESET_Rf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT.
 *
 */
#define BCM53115_A0_READ_G_MIICTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_MIICTL_EXTr,(r._g_miictl_ext),2)
#define BCM53115_A0_WRITE_G_MIICTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_MIICTL_EXTr,&(r._g_miictl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXTr BCM53115_A0_G_MIICTL_EXTr
#define G_MIICTL_EXTr_SIZE BCM53115_A0_G_MIICTL_EXTr_SIZE
typedef BCM53115_A0_G_MIICTL_EXTr_t G_MIICTL_EXTr_t;
#define G_MIICTL_EXTr_CLR BCM53115_A0_G_MIICTL_EXTr_CLR
#define G_MIICTL_EXTr_SET BCM53115_A0_G_MIICTL_EXTr_SET
#define G_MIICTL_EXTr_GET BCM53115_A0_G_MIICTL_EXTr_GET
#define G_MIICTL_EXTr_RESERVED_Rf_GET BCM53115_A0_G_MIICTL_EXTr_RESERVED_Rf_GET
#define G_MIICTL_EXTr_RESERVED_Rf_SET BCM53115_A0_G_MIICTL_EXTr_RESERVED_Rf_SET
#define G_MIICTL_EXTr_SPD_SEL_MSBf_GET BCM53115_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_GET
#define G_MIICTL_EXTr_SPD_SEL_MSBf_SET BCM53115_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_SET
#define G_MIICTL_EXTr_COL_TESTf_GET BCM53115_A0_G_MIICTL_EXTr_COL_TESTf_GET
#define G_MIICTL_EXTr_COL_TESTf_SET BCM53115_A0_G_MIICTL_EXTr_COL_TESTf_SET
#define G_MIICTL_EXTr_DUPLEX_MODf_GET BCM53115_A0_G_MIICTL_EXTr_DUPLEX_MODf_GET
#define G_MIICTL_EXTr_DUPLEX_MODf_SET BCM53115_A0_G_MIICTL_EXTr_DUPLEX_MODf_SET
#define G_MIICTL_EXTr_RE_ANf_GET BCM53115_A0_G_MIICTL_EXTr_RE_ANf_GET
#define G_MIICTL_EXTr_RE_ANf_SET BCM53115_A0_G_MIICTL_EXTr_RE_ANf_SET
#define G_MIICTL_EXTr_ISOLATEf_GET BCM53115_A0_G_MIICTL_EXTr_ISOLATEf_GET
#define G_MIICTL_EXTr_ISOLATEf_SET BCM53115_A0_G_MIICTL_EXTr_ISOLATEf_SET
#define G_MIICTL_EXTr_PWR_DOWNf_GET BCM53115_A0_G_MIICTL_EXTr_PWR_DOWNf_GET
#define G_MIICTL_EXTr_PWR_DOWNf_SET BCM53115_A0_G_MIICTL_EXTr_PWR_DOWNf_SET
#define G_MIICTL_EXTr_AN_ENf_GET BCM53115_A0_G_MIICTL_EXTr_AN_ENf_GET
#define G_MIICTL_EXTr_AN_ENf_SET BCM53115_A0_G_MIICTL_EXTr_AN_ENf_SET
#define G_MIICTL_EXTr_SPD_SEL_LSBf_GET BCM53115_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_GET
#define G_MIICTL_EXTr_SPD_SEL_LSBf_SET BCM53115_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_SET
#define G_MIICTL_EXTr_LOOPBACKf_GET BCM53115_A0_G_MIICTL_EXTr_LOOPBACKf_GET
#define G_MIICTL_EXTr_LOOPBACKf_SET BCM53115_A0_G_MIICTL_EXTr_LOOPBACKf_SET
#define G_MIICTL_EXTr_RESET_Rf_GET BCM53115_A0_G_MIICTL_EXTr_RESET_Rf_GET
#define G_MIICTL_EXTr_RESET_Rf_SET BCM53115_A0_G_MIICTL_EXTr_RESET_Rf_SET
#define READ_G_MIICTL_EXTr BCM53115_A0_READ_G_MIICTL_EXTr
#define WRITE_G_MIICTL_EXTr BCM53115_A0_WRITE_G_MIICTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MIICTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MIICTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET_R          1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM53115_A0_G_MIICTL_EXT_P5r 0x00008500

#define BCM53115_A0_G_MIICTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_MIICTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_miictl_ext_p5[1];
	uint32_t _g_miictl_ext_p5;
} BCM53115_A0_G_MIICTL_EXT_P5r_t;

#define BCM53115_A0_G_MIICTL_EXT_P5r_CLR(r) (r).g_miictl_ext_p5[0] = 0
#define BCM53115_A0_G_MIICTL_EXT_P5r_SET(r,d) (r).g_miictl_ext_p5[0] = d
#define BCM53115_A0_G_MIICTL_EXT_P5r_GET(r) (r).g_miictl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MIICTL_EXT_P5r_RESERVED_Rf_GET(r) (((r).g_miictl_ext_p5[0]) & 0x3f)
#define BCM53115_A0_G_MIICTL_EXT_P5r_RESERVED_Rf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_G_MIICTL_EXT_P5r_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 6) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_MIICTL_EXT_P5r_COL_TESTf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 7) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_COL_TESTf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_MIICTL_EXT_P5r_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 8) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_MIICTL_EXT_P5r_RE_ANf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 9) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_RE_ANf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_MIICTL_EXT_P5r_ISOLATEf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 10) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_ISOLATEf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_MIICTL_EXT_P5r_PWR_DOWNf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_PWR_DOWNf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_MIICTL_EXT_P5r_AN_ENf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_AN_ENf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_MIICTL_EXT_P5r_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_MIICTL_EXT_P5r_LOOPBACKf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_LOOPBACKf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_MIICTL_EXT_P5r_RESET_Rf_GET(r) ((((r).g_miictl_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_MIICTL_EXT_P5r_RESET_Rf_SET(r,f) (r).g_miictl_ext_p5[0]=(((r).g_miictl_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_MIICTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_MIICTL_EXT_P5r,(r._g_miictl_ext_p5),2)
#define BCM53115_A0_WRITE_G_MIICTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_MIICTL_EXT_P5r,&(r._g_miictl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXT_P5r BCM53115_A0_G_MIICTL_EXT_P5r
#define G_MIICTL_EXT_P5r_SIZE BCM53115_A0_G_MIICTL_EXT_P5r_SIZE
typedef BCM53115_A0_G_MIICTL_EXT_P5r_t G_MIICTL_EXT_P5r_t;
#define G_MIICTL_EXT_P5r_CLR BCM53115_A0_G_MIICTL_EXT_P5r_CLR
#define G_MIICTL_EXT_P5r_SET BCM53115_A0_G_MIICTL_EXT_P5r_SET
#define G_MIICTL_EXT_P5r_GET BCM53115_A0_G_MIICTL_EXT_P5r_GET
#define G_MIICTL_EXT_P5r_RESERVED_Rf_GET BCM53115_A0_G_MIICTL_EXT_P5r_RESERVED_Rf_GET
#define G_MIICTL_EXT_P5r_RESERVED_Rf_SET BCM53115_A0_G_MIICTL_EXT_P5r_RESERVED_Rf_SET
#define G_MIICTL_EXT_P5r_SPD_SEL_MSBf_GET BCM53115_A0_G_MIICTL_EXT_P5r_SPD_SEL_MSBf_GET
#define G_MIICTL_EXT_P5r_SPD_SEL_MSBf_SET BCM53115_A0_G_MIICTL_EXT_P5r_SPD_SEL_MSBf_SET
#define G_MIICTL_EXT_P5r_COL_TESTf_GET BCM53115_A0_G_MIICTL_EXT_P5r_COL_TESTf_GET
#define G_MIICTL_EXT_P5r_COL_TESTf_SET BCM53115_A0_G_MIICTL_EXT_P5r_COL_TESTf_SET
#define G_MIICTL_EXT_P5r_DUPLEX_MODf_GET BCM53115_A0_G_MIICTL_EXT_P5r_DUPLEX_MODf_GET
#define G_MIICTL_EXT_P5r_DUPLEX_MODf_SET BCM53115_A0_G_MIICTL_EXT_P5r_DUPLEX_MODf_SET
#define G_MIICTL_EXT_P5r_RE_ANf_GET BCM53115_A0_G_MIICTL_EXT_P5r_RE_ANf_GET
#define G_MIICTL_EXT_P5r_RE_ANf_SET BCM53115_A0_G_MIICTL_EXT_P5r_RE_ANf_SET
#define G_MIICTL_EXT_P5r_ISOLATEf_GET BCM53115_A0_G_MIICTL_EXT_P5r_ISOLATEf_GET
#define G_MIICTL_EXT_P5r_ISOLATEf_SET BCM53115_A0_G_MIICTL_EXT_P5r_ISOLATEf_SET
#define G_MIICTL_EXT_P5r_PWR_DOWNf_GET BCM53115_A0_G_MIICTL_EXT_P5r_PWR_DOWNf_GET
#define G_MIICTL_EXT_P5r_PWR_DOWNf_SET BCM53115_A0_G_MIICTL_EXT_P5r_PWR_DOWNf_SET
#define G_MIICTL_EXT_P5r_AN_ENf_GET BCM53115_A0_G_MIICTL_EXT_P5r_AN_ENf_GET
#define G_MIICTL_EXT_P5r_AN_ENf_SET BCM53115_A0_G_MIICTL_EXT_P5r_AN_ENf_SET
#define G_MIICTL_EXT_P5r_SPD_SEL_LSBf_GET BCM53115_A0_G_MIICTL_EXT_P5r_SPD_SEL_LSBf_GET
#define G_MIICTL_EXT_P5r_SPD_SEL_LSBf_SET BCM53115_A0_G_MIICTL_EXT_P5r_SPD_SEL_LSBf_SET
#define G_MIICTL_EXT_P5r_LOOPBACKf_GET BCM53115_A0_G_MIICTL_EXT_P5r_LOOPBACKf_GET
#define G_MIICTL_EXT_P5r_LOOPBACKf_SET BCM53115_A0_G_MIICTL_EXT_P5r_LOOPBACKf_SET
#define G_MIICTL_EXT_P5r_RESET_Rf_GET BCM53115_A0_G_MIICTL_EXT_P5r_RESET_Rf_GET
#define G_MIICTL_EXT_P5r_RESET_Rf_SET BCM53115_A0_G_MIICTL_EXT_P5r_RESET_Rf_SET
#define READ_G_MIICTL_EXT_P5r BCM53115_A0_READ_G_MIICTL_EXT_P5r
#define WRITE_G_MIICTL_EXT_P5r BCM53115_A0_WRITE_G_MIICTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MIICTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MIISTS
 * BLOCKS:   GPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT_R   1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED_R       Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM53115_A0_G_MIISTSr 0x00001002

#define BCM53115_A0_G_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS.
 *
 */
typedef union BCM53115_A0_G_MIISTSr_s {
	uint32_t v[1];
	uint32_t g_miists[1];
	uint32_t _g_miists;
} BCM53115_A0_G_MIISTSr_t;

#define BCM53115_A0_G_MIISTSr_CLR(r) (r).g_miists[0] = 0
#define BCM53115_A0_G_MIISTSr_SET(r,d) (r).g_miists[0] = d
#define BCM53115_A0_G_MIISTSr_GET(r) (r).g_miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MIISTSr_EXT_CAPf_GET(r) (((r).g_miists[0]) & 0x1)
#define BCM53115_A0_G_MIISTSr_EXT_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_MIISTSr_JABBER_DETf_GET(r) ((((r).g_miists[0]) >> 1) & 0x1)
#define BCM53115_A0_G_MIISTSr_JABBER_DETf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_MIISTSr_LINK_STAf_GET(r) ((((r).g_miists[0]) >> 2) & 0x1)
#define BCM53115_A0_G_MIISTSr_LINK_STAf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists[0]) >> 3) & 0x1)
#define BCM53115_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_MIISTSr_REMOTE_FAULT_Rf_GET(r) ((((r).g_miists[0]) >> 4) & 0x1)
#define BCM53115_A0_G_MIISTSr_REMOTE_FAULT_Rf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists[0]) >> 5) & 0x1)
#define BCM53115_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).g_miists[0]) >> 6) & 0x1)
#define BCM53115_A0_G_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_MIISTSr_RESERVED_Rf_GET(r) ((((r).g_miists[0]) >> 7) & 0x1)
#define BCM53115_A0_G_MIISTSr_RESERVED_Rf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_MIISTSr_EXT_STSf_GET(r) ((((r).g_miists[0]) >> 8) & 0x1)
#define BCM53115_A0_G_MIISTSr_EXT_STSf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_MIISTSr_B100T2_HD_CAPf_GET(r) ((((r).g_miists[0]) >> 9) & 0x1)
#define BCM53115_A0_G_MIISTSr_B100T2_HD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_MIISTSr_B100T2_FD_CAPf_GET(r) ((((r).g_miists[0]) >> 10) & 0x1)
#define BCM53115_A0_G_MIISTSr_B100T2_FD_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_MIISTSr_B10T_CAPf_GET(r) ((((r).g_miists[0]) >> 11) & 0x1)
#define BCM53115_A0_G_MIISTSr_B10T_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 12) & 0x1)
#define BCM53115_A0_G_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_MIISTSr_B100TX_CAPf_GET(r) ((((r).g_miists[0]) >> 13) & 0x1)
#define BCM53115_A0_G_MIISTSr_B100TX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists[0]) >> 14) & 0x1)
#define BCM53115_A0_G_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_MIISTSr_B100T4_CAPf_GET(r) ((((r).g_miists[0]) >> 15) & 0x1)
#define BCM53115_A0_G_MIISTSr_B100T4_CAPf_SET(r,f) (r).g_miists[0]=(((r).g_miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS.
 *
 */
#define BCM53115_A0_READ_G_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_MIISTSr,(r._g_miists),2)
#define BCM53115_A0_WRITE_G_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_MIISTSr,&(r._g_miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTSr BCM53115_A0_G_MIISTSr
#define G_MIISTSr_SIZE BCM53115_A0_G_MIISTSr_SIZE
typedef BCM53115_A0_G_MIISTSr_t G_MIISTSr_t;
#define G_MIISTSr_CLR BCM53115_A0_G_MIISTSr_CLR
#define G_MIISTSr_SET BCM53115_A0_G_MIISTSr_SET
#define G_MIISTSr_GET BCM53115_A0_G_MIISTSr_GET
#define G_MIISTSr_EXT_CAPf_GET BCM53115_A0_G_MIISTSr_EXT_CAPf_GET
#define G_MIISTSr_EXT_CAPf_SET BCM53115_A0_G_MIISTSr_EXT_CAPf_SET
#define G_MIISTSr_JABBER_DETf_GET BCM53115_A0_G_MIISTSr_JABBER_DETf_GET
#define G_MIISTSr_JABBER_DETf_SET BCM53115_A0_G_MIISTSr_JABBER_DETf_SET
#define G_MIISTSr_LINK_STAf_GET BCM53115_A0_G_MIISTSr_LINK_STAf_GET
#define G_MIISTSr_LINK_STAf_SET BCM53115_A0_G_MIISTSr_LINK_STAf_SET
#define G_MIISTSr_AUTO_NEGO_CAPf_GET BCM53115_A0_G_MIISTSr_AUTO_NEGO_CAPf_GET
#define G_MIISTSr_AUTO_NEGO_CAPf_SET BCM53115_A0_G_MIISTSr_AUTO_NEGO_CAPf_SET
#define G_MIISTSr_REMOTE_FAULT_Rf_GET BCM53115_A0_G_MIISTSr_REMOTE_FAULT_Rf_GET
#define G_MIISTSr_REMOTE_FAULT_Rf_SET BCM53115_A0_G_MIISTSr_REMOTE_FAULT_Rf_SET
#define G_MIISTSr_AUTO_NEGO_COMPf_GET BCM53115_A0_G_MIISTSr_AUTO_NEGO_COMPf_GET
#define G_MIISTSr_AUTO_NEGO_COMPf_SET BCM53115_A0_G_MIISTSr_AUTO_NEGO_COMPf_SET
#define G_MIISTSr_MF_PRE_SUPf_GET BCM53115_A0_G_MIISTSr_MF_PRE_SUPf_GET
#define G_MIISTSr_MF_PRE_SUPf_SET BCM53115_A0_G_MIISTSr_MF_PRE_SUPf_SET
#define G_MIISTSr_RESERVED_Rf_GET BCM53115_A0_G_MIISTSr_RESERVED_Rf_GET
#define G_MIISTSr_RESERVED_Rf_SET BCM53115_A0_G_MIISTSr_RESERVED_Rf_SET
#define G_MIISTSr_EXT_STSf_GET BCM53115_A0_G_MIISTSr_EXT_STSf_GET
#define G_MIISTSr_EXT_STSf_SET BCM53115_A0_G_MIISTSr_EXT_STSf_SET
#define G_MIISTSr_B100T2_HD_CAPf_GET BCM53115_A0_G_MIISTSr_B100T2_HD_CAPf_GET
#define G_MIISTSr_B100T2_HD_CAPf_SET BCM53115_A0_G_MIISTSr_B100T2_HD_CAPf_SET
#define G_MIISTSr_B100T2_FD_CAPf_GET BCM53115_A0_G_MIISTSr_B100T2_FD_CAPf_GET
#define G_MIISTSr_B100T2_FD_CAPf_SET BCM53115_A0_G_MIISTSr_B100T2_FD_CAPf_SET
#define G_MIISTSr_B10T_CAPf_GET BCM53115_A0_G_MIISTSr_B10T_CAPf_GET
#define G_MIISTSr_B10T_CAPf_SET BCM53115_A0_G_MIISTSr_B10T_CAPf_SET
#define G_MIISTSr_B10T_FDX_CAPf_GET BCM53115_A0_G_MIISTSr_B10T_FDX_CAPf_GET
#define G_MIISTSr_B10T_FDX_CAPf_SET BCM53115_A0_G_MIISTSr_B10T_FDX_CAPf_SET
#define G_MIISTSr_B100TX_CAPf_GET BCM53115_A0_G_MIISTSr_B100TX_CAPf_GET
#define G_MIISTSr_B100TX_CAPf_SET BCM53115_A0_G_MIISTSr_B100TX_CAPf_SET
#define G_MIISTSr_B100TX_FDX_CAPf_GET BCM53115_A0_G_MIISTSr_B100TX_FDX_CAPf_GET
#define G_MIISTSr_B100TX_FDX_CAPf_SET BCM53115_A0_G_MIISTSr_B100TX_FDX_CAPf_SET
#define G_MIISTSr_B100T4_CAPf_GET BCM53115_A0_G_MIISTSr_B100T4_CAPf_GET
#define G_MIISTSr_B100T4_CAPf_SET BCM53115_A0_G_MIISTSr_B100T4_CAPf_SET
#define READ_G_MIISTSr BCM53115_A0_READ_G_MIISTSr
#define WRITE_G_MIISTSr BCM53115_A0_WRITE_G_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MIISTS_EXT
 * BLOCKS:   CPIC
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT_R   1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED_R       Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM53115_A0_G_MIISTS_EXTr 0x00008802

#define BCM53115_A0_G_MIISTS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT.
 *
 */
typedef union BCM53115_A0_G_MIISTS_EXTr_s {
	uint32_t v[1];
	uint32_t g_miists_ext[1];
	uint32_t _g_miists_ext;
} BCM53115_A0_G_MIISTS_EXTr_t;

#define BCM53115_A0_G_MIISTS_EXTr_CLR(r) (r).g_miists_ext[0] = 0
#define BCM53115_A0_G_MIISTS_EXTr_SET(r,d) (r).g_miists_ext[0] = d
#define BCM53115_A0_G_MIISTS_EXTr_GET(r) (r).g_miists_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MIISTS_EXTr_EXT_CAPf_GET(r) (((r).g_miists_ext[0]) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_EXT_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_MIISTS_EXTr_JABBER_DETf_GET(r) ((((r).g_miists_ext[0]) >> 1) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_JABBER_DETf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_MIISTS_EXTr_LINK_STAf_GET(r) ((((r).g_miists_ext[0]) >> 2) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_LINK_STAf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 3) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_MIISTS_EXTr_REMOTE_FAULT_Rf_GET(r) ((((r).g_miists_ext[0]) >> 4) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_REMOTE_FAULT_Rf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext[0]) >> 5) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_MIISTS_EXTr_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext[0]) >> 6) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_MIISTS_EXTr_RESERVED_Rf_GET(r) ((((r).g_miists_ext[0]) >> 7) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_RESERVED_Rf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_MIISTS_EXTr_EXT_STSf_GET(r) ((((r).g_miists_ext[0]) >> 8) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_EXT_STSf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 9) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 10) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_MIISTS_EXTr_B10T_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_B10T_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_MIISTS_EXTr_B100TX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_B100TX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_MIISTS_EXTr_B100T4_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_MIISTS_EXTr_B100T4_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT.
 *
 */
#define BCM53115_A0_READ_G_MIISTS_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_MIISTS_EXTr,(r._g_miists_ext),2)
#define BCM53115_A0_WRITE_G_MIISTS_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_MIISTS_EXTr,&(r._g_miists_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXTr BCM53115_A0_G_MIISTS_EXTr
#define G_MIISTS_EXTr_SIZE BCM53115_A0_G_MIISTS_EXTr_SIZE
typedef BCM53115_A0_G_MIISTS_EXTr_t G_MIISTS_EXTr_t;
#define G_MIISTS_EXTr_CLR BCM53115_A0_G_MIISTS_EXTr_CLR
#define G_MIISTS_EXTr_SET BCM53115_A0_G_MIISTS_EXTr_SET
#define G_MIISTS_EXTr_GET BCM53115_A0_G_MIISTS_EXTr_GET
#define G_MIISTS_EXTr_EXT_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_EXT_CAPf_GET
#define G_MIISTS_EXTr_EXT_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_EXT_CAPf_SET
#define G_MIISTS_EXTr_JABBER_DETf_GET BCM53115_A0_G_MIISTS_EXTr_JABBER_DETf_GET
#define G_MIISTS_EXTr_JABBER_DETf_SET BCM53115_A0_G_MIISTS_EXTr_JABBER_DETf_SET
#define G_MIISTS_EXTr_LINK_STAf_GET BCM53115_A0_G_MIISTS_EXTr_LINK_STAf_GET
#define G_MIISTS_EXTr_LINK_STAf_SET BCM53115_A0_G_MIISTS_EXTr_LINK_STAf_SET
#define G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXTr_REMOTE_FAULT_Rf_GET BCM53115_A0_G_MIISTS_EXTr_REMOTE_FAULT_Rf_GET
#define G_MIISTS_EXTr_REMOTE_FAULT_Rf_SET BCM53115_A0_G_MIISTS_EXTr_REMOTE_FAULT_Rf_SET
#define G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET BCM53115_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET BCM53115_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXTr_MF_PRE_SUPf_GET BCM53115_A0_G_MIISTS_EXTr_MF_PRE_SUPf_GET
#define G_MIISTS_EXTr_MF_PRE_SUPf_SET BCM53115_A0_G_MIISTS_EXTr_MF_PRE_SUPf_SET
#define G_MIISTS_EXTr_RESERVED_Rf_GET BCM53115_A0_G_MIISTS_EXTr_RESERVED_Rf_GET
#define G_MIISTS_EXTr_RESERVED_Rf_SET BCM53115_A0_G_MIISTS_EXTr_RESERVED_Rf_SET
#define G_MIISTS_EXTr_EXT_STSf_GET BCM53115_A0_G_MIISTS_EXTr_EXT_STSf_GET
#define G_MIISTS_EXTr_EXT_STSf_SET BCM53115_A0_G_MIISTS_EXTr_EXT_STSf_SET
#define G_MIISTS_EXTr_B100T2_HD_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_GET
#define G_MIISTS_EXTr_B100T2_HD_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_SET
#define G_MIISTS_EXTr_B100T2_FD_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_GET
#define G_MIISTS_EXTr_B100T2_FD_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_SET
#define G_MIISTS_EXTr_B10T_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_B10T_CAPf_GET
#define G_MIISTS_EXTr_B10T_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_B10T_CAPf_SET
#define G_MIISTS_EXTr_B10T_FDX_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_GET
#define G_MIISTS_EXTr_B10T_FDX_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_SET
#define G_MIISTS_EXTr_B100TX_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_B100TX_CAPf_GET
#define G_MIISTS_EXTr_B100TX_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_B100TX_CAPf_SET
#define G_MIISTS_EXTr_B100TX_FDX_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXTr_B100TX_FDX_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXTr_B100T4_CAPf_GET BCM53115_A0_G_MIISTS_EXTr_B100T4_CAPf_GET
#define G_MIISTS_EXTr_B100T4_CAPf_SET BCM53115_A0_G_MIISTS_EXTr_B100T4_CAPf_SET
#define READ_G_MIISTS_EXTr BCM53115_A0_READ_G_MIISTS_EXTr
#define WRITE_G_MIISTS_EXTr BCM53115_A0_WRITE_G_MIISTS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MIISTS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MIISTS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT_R   1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED_R       Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM53115_A0_G_MIISTS_EXT_P5r 0x00008502

#define BCM53115_A0_G_MIISTS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_MIISTS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_miists_ext_p5[1];
	uint32_t _g_miists_ext_p5;
} BCM53115_A0_G_MIISTS_EXT_P5r_t;

#define BCM53115_A0_G_MIISTS_EXT_P5r_CLR(r) (r).g_miists_ext_p5[0] = 0
#define BCM53115_A0_G_MIISTS_EXT_P5r_SET(r,d) (r).g_miists_ext_p5[0] = d
#define BCM53115_A0_G_MIISTS_EXT_P5r_GET(r) (r).g_miists_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MIISTS_EXT_P5r_EXT_CAPf_GET(r) (((r).g_miists_ext_p5[0]) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_EXT_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_MIISTS_EXT_P5r_JABBER_DETf_GET(r) ((((r).g_miists_ext_p5[0]) >> 1) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_JABBER_DETf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_MIISTS_EXT_P5r_LINK_STAf_GET(r) ((((r).g_miists_ext_p5[0]) >> 2) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_LINK_STAf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 3) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_MIISTS_EXT_P5r_REMOTE_FAULT_Rf_GET(r) ((((r).g_miists_ext_p5[0]) >> 4) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_REMOTE_FAULT_Rf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 5) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_MIISTS_EXT_P5r_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 6) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_MIISTS_EXT_P5r_RESERVED_Rf_GET(r) ((((r).g_miists_ext_p5[0]) >> 7) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_RESERVED_Rf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_MIISTS_EXT_P5r_EXT_STSf_GET(r) ((((r).g_miists_ext_p5[0]) >> 8) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_EXT_STSf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 9) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 10) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_MIISTS_EXT_P5r_B10T_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_B10T_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_MIISTS_EXT_P5r_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100TX_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100TX_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100T4_CAPf_GET(r) ((((r).g_miists_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_MIISTS_EXT_P5r_B100T4_CAPf_SET(r,f) (r).g_miists_ext_p5[0]=(((r).g_miists_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_MIISTS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_MIISTS_EXT_P5r,(r._g_miists_ext_p5),2)
#define BCM53115_A0_WRITE_G_MIISTS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_MIISTS_EXT_P5r,&(r._g_miists_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXT_P5r BCM53115_A0_G_MIISTS_EXT_P5r
#define G_MIISTS_EXT_P5r_SIZE BCM53115_A0_G_MIISTS_EXT_P5r_SIZE
typedef BCM53115_A0_G_MIISTS_EXT_P5r_t G_MIISTS_EXT_P5r_t;
#define G_MIISTS_EXT_P5r_CLR BCM53115_A0_G_MIISTS_EXT_P5r_CLR
#define G_MIISTS_EXT_P5r_SET BCM53115_A0_G_MIISTS_EXT_P5r_SET
#define G_MIISTS_EXT_P5r_GET BCM53115_A0_G_MIISTS_EXT_P5r_GET
#define G_MIISTS_EXT_P5r_EXT_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_EXT_CAPf_GET
#define G_MIISTS_EXT_P5r_EXT_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_EXT_CAPf_SET
#define G_MIISTS_EXT_P5r_JABBER_DETf_GET BCM53115_A0_G_MIISTS_EXT_P5r_JABBER_DETf_GET
#define G_MIISTS_EXT_P5r_JABBER_DETf_SET BCM53115_A0_G_MIISTS_EXT_P5r_JABBER_DETf_SET
#define G_MIISTS_EXT_P5r_LINK_STAf_GET BCM53115_A0_G_MIISTS_EXT_P5r_LINK_STAf_GET
#define G_MIISTS_EXT_P5r_LINK_STAf_SET BCM53115_A0_G_MIISTS_EXT_P5r_LINK_STAf_SET
#define G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXT_P5r_REMOTE_FAULT_Rf_GET BCM53115_A0_G_MIISTS_EXT_P5r_REMOTE_FAULT_Rf_GET
#define G_MIISTS_EXT_P5r_REMOTE_FAULT_Rf_SET BCM53115_A0_G_MIISTS_EXT_P5r_REMOTE_FAULT_Rf_SET
#define G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXT_P5r_MF_PRE_SUPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_MF_PRE_SUPf_GET
#define G_MIISTS_EXT_P5r_MF_PRE_SUPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_MF_PRE_SUPf_SET
#define G_MIISTS_EXT_P5r_RESERVED_Rf_GET BCM53115_A0_G_MIISTS_EXT_P5r_RESERVED_Rf_GET
#define G_MIISTS_EXT_P5r_RESERVED_Rf_SET BCM53115_A0_G_MIISTS_EXT_P5r_RESERVED_Rf_SET
#define G_MIISTS_EXT_P5r_EXT_STSf_GET BCM53115_A0_G_MIISTS_EXT_P5r_EXT_STSf_GET
#define G_MIISTS_EXT_P5r_EXT_STSf_SET BCM53115_A0_G_MIISTS_EXT_P5r_EXT_STSf_SET
#define G_MIISTS_EXT_P5r_B100T2_HD_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_B100T2_HD_CAPf_GET
#define G_MIISTS_EXT_P5r_B100T2_HD_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_B100T2_HD_CAPf_SET
#define G_MIISTS_EXT_P5r_B100T2_FD_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_B100T2_FD_CAPf_GET
#define G_MIISTS_EXT_P5r_B100T2_FD_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_B100T2_FD_CAPf_SET
#define G_MIISTS_EXT_P5r_B10T_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_B10T_CAPf_GET
#define G_MIISTS_EXT_P5r_B10T_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_B10T_CAPf_SET
#define G_MIISTS_EXT_P5r_B10T_FDX_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_B10T_FDX_CAPf_GET
#define G_MIISTS_EXT_P5r_B10T_FDX_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_B10T_FDX_CAPf_SET
#define G_MIISTS_EXT_P5r_B100TX_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_B100TX_CAPf_GET
#define G_MIISTS_EXT_P5r_B100TX_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_B100TX_CAPf_SET
#define G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXT_P5r_B100T4_CAPf_GET BCM53115_A0_G_MIISTS_EXT_P5r_B100T4_CAPf_GET
#define G_MIISTS_EXT_P5r_B100T4_CAPf_SET BCM53115_A0_G_MIISTS_EXT_P5r_B100T4_CAPf_SET
#define READ_G_MIISTS_EXT_P5r BCM53115_A0_READ_G_MIISTS_EXT_P5r
#define WRITE_G_MIISTS_EXT_P5r BCM53115_A0_WRITE_G_MIISTS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MIISTS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MISC_SHADOW
 * BLOCKS:   GPIC0
 * DESC:     Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM53115_A0_G_MISC_SHADOWr 0x00001038

#define BCM53115_A0_G_MISC_SHADOWr_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW.
 *
 */
typedef union BCM53115_A0_G_MISC_SHADOWr_s {
	uint32_t v[1];
	uint32_t g_misc_shadow[1];
	uint32_t _g_misc_shadow;
} BCM53115_A0_G_MISC_SHADOWr_t;

#define BCM53115_A0_G_MISC_SHADOWr_CLR(r) (r).g_misc_shadow[0] = 0
#define BCM53115_A0_G_MISC_SHADOWr_SET(r,d) (r).g_misc_shadow[0] = d
#define BCM53115_A0_G_MISC_SHADOWr_GET(r) (r).g_misc_shadow[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MISC_SHADOWr_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow[0]) & 0xffff)
#define BCM53115_A0_G_MISC_SHADOWr_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow[0]=(((r).g_misc_shadow[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW.
 *
 */
#define BCM53115_A0_READ_G_MISC_SHADOWr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_MISC_SHADOWr,(r._g_misc_shadow),2)
#define BCM53115_A0_WRITE_G_MISC_SHADOWr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_MISC_SHADOWr,&(r._g_misc_shadow),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOWr BCM53115_A0_G_MISC_SHADOWr
#define G_MISC_SHADOWr_SIZE BCM53115_A0_G_MISC_SHADOWr_SIZE
typedef BCM53115_A0_G_MISC_SHADOWr_t G_MISC_SHADOWr_t;
#define G_MISC_SHADOWr_CLR BCM53115_A0_G_MISC_SHADOWr_CLR
#define G_MISC_SHADOWr_SET BCM53115_A0_G_MISC_SHADOWr_SET
#define G_MISC_SHADOWr_GET BCM53115_A0_G_MISC_SHADOWr_GET
#define G_MISC_SHADOWr_INTERRUPT_MSKf_GET BCM53115_A0_G_MISC_SHADOWr_INTERRUPT_MSKf_GET
#define G_MISC_SHADOWr_INTERRUPT_MSKf_SET BCM53115_A0_G_MISC_SHADOWr_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOWr BCM53115_A0_READ_G_MISC_SHADOWr
#define WRITE_G_MISC_SHADOWr BCM53115_A0_WRITE_G_MISC_SHADOWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MISC_SHADOWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MISC_SHADOW_EXT
 * BLOCKS:   CPIC
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM53115_A0_G_MISC_SHADOW_EXTr 0x00008838

#define BCM53115_A0_G_MISC_SHADOW_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT.
 *
 */
typedef union BCM53115_A0_G_MISC_SHADOW_EXTr_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext[1];
	uint32_t _g_misc_shadow_ext;
} BCM53115_A0_G_MISC_SHADOW_EXTr_t;

#define BCM53115_A0_G_MISC_SHADOW_EXTr_CLR(r) (r).g_misc_shadow_ext[0] = 0
#define BCM53115_A0_G_MISC_SHADOW_EXTr_SET(r,d) (r).g_misc_shadow_ext[0] = d
#define BCM53115_A0_G_MISC_SHADOW_EXTr_GET(r) (r).g_misc_shadow_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext[0]) & 0xffff)
#define BCM53115_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext[0]=(((r).g_misc_shadow_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT.
 *
 */
#define BCM53115_A0_READ_G_MISC_SHADOW_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_MISC_SHADOW_EXTr,(r._g_misc_shadow_ext),2)
#define BCM53115_A0_WRITE_G_MISC_SHADOW_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_MISC_SHADOW_EXTr,&(r._g_misc_shadow_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXTr BCM53115_A0_G_MISC_SHADOW_EXTr
#define G_MISC_SHADOW_EXTr_SIZE BCM53115_A0_G_MISC_SHADOW_EXTr_SIZE
typedef BCM53115_A0_G_MISC_SHADOW_EXTr_t G_MISC_SHADOW_EXTr_t;
#define G_MISC_SHADOW_EXTr_CLR BCM53115_A0_G_MISC_SHADOW_EXTr_CLR
#define G_MISC_SHADOW_EXTr_SET BCM53115_A0_G_MISC_SHADOW_EXTr_SET
#define G_MISC_SHADOW_EXTr_GET BCM53115_A0_G_MISC_SHADOW_EXTr_GET
#define G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET BCM53115_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET BCM53115_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXTr BCM53115_A0_READ_G_MISC_SHADOW_EXTr
#define WRITE_G_MISC_SHADOW_EXTr BCM53115_A0_WRITE_G_MISC_SHADOW_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MISC_SHADOW_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_MISC_SHADOW_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM53115_A0_G_MISC_SHADOW_EXT_P5r 0x00008538

#define BCM53115_A0_G_MISC_SHADOW_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_MISC_SHADOW_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext_p5[1];
	uint32_t _g_misc_shadow_ext_p5;
} BCM53115_A0_G_MISC_SHADOW_EXT_P5r_t;

#define BCM53115_A0_G_MISC_SHADOW_EXT_P5r_CLR(r) (r).g_misc_shadow_ext_p5[0] = 0
#define BCM53115_A0_G_MISC_SHADOW_EXT_P5r_SET(r,d) (r).g_misc_shadow_ext_p5[0] = d
#define BCM53115_A0_G_MISC_SHADOW_EXT_P5r_GET(r) (r).g_misc_shadow_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext_p5[0]=(((r).g_misc_shadow_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_MISC_SHADOW_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_MISC_SHADOW_EXT_P5r,(r._g_misc_shadow_ext_p5),2)
#define BCM53115_A0_WRITE_G_MISC_SHADOW_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_MISC_SHADOW_EXT_P5r,&(r._g_misc_shadow_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXT_P5r BCM53115_A0_G_MISC_SHADOW_EXT_P5r
#define G_MISC_SHADOW_EXT_P5r_SIZE BCM53115_A0_G_MISC_SHADOW_EXT_P5r_SIZE
typedef BCM53115_A0_G_MISC_SHADOW_EXT_P5r_t G_MISC_SHADOW_EXT_P5r_t;
#define G_MISC_SHADOW_EXT_P5r_CLR BCM53115_A0_G_MISC_SHADOW_EXT_P5r_CLR
#define G_MISC_SHADOW_EXT_P5r_SET BCM53115_A0_G_MISC_SHADOW_EXT_P5r_SET
#define G_MISC_SHADOW_EXT_P5r_GET BCM53115_A0_G_MISC_SHADOW_EXT_P5r_GET
#define G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_GET BCM53115_A0_G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_SET BCM53115_A0_G_MISC_SHADOW_EXT_P5r_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXT_P5r BCM53115_A0_READ_G_MISC_SHADOW_EXT_P5r
#define WRITE_G_MISC_SHADOW_EXT_P5r BCM53115_A0_WRITE_G_MISC_SHADOW_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_MISC_SHADOW_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PCTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     10/100/1000 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.
 *     TX_DIS           Disables the transmit function of the port at the MAC level.
 *     RESERVED_R       Reserved.
 *     G_MISTP_STATE    CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3b'b000: No Spanning Tree(default by HW_FWDG_EN).3b'b001: Disable State(default by ~HW_FWDG_EN).3b'b010: Blocking State.3b'b011: Listening State.3b'b100: Learning State.3b'b101: Forwarding State.3b'b110 - 3b'b111: Reserved.Programmed frome the HW_FWDG_EN Strap Option.Can be overwritten subsequently.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PCTLr 0x00000000

#define BCM53115_A0_G_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program G_PCTL.
 *
 */
typedef union BCM53115_A0_G_PCTLr_s {
	uint32_t v[1];
	uint32_t g_pctl[1];
	uint32_t _g_pctl;
} BCM53115_A0_G_PCTLr_t;

#define BCM53115_A0_G_PCTLr_CLR(r) (r).g_pctl[0] = 0
#define BCM53115_A0_G_PCTLr_SET(r,d) (r).g_pctl[0] = d
#define BCM53115_A0_G_PCTLr_GET(r) (r).g_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PCTLr_RX_DISf_GET(r) (((r).g_pctl[0]) & 0x1)
#define BCM53115_A0_G_PCTLr_RX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_PCTLr_TX_DISf_GET(r) ((((r).g_pctl[0]) >> 1) & 0x1)
#define BCM53115_A0_G_PCTLr_TX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_PCTLr_RESERVED_Rf_GET(r) ((((r).g_pctl[0]) >> 2) & 0x7)
#define BCM53115_A0_G_PCTLr_RESERVED_Rf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53115_A0_G_PCTLr_G_MISTP_STATEf_GET(r) ((((r).g_pctl[0]) >> 5) & 0x7)
#define BCM53115_A0_G_PCTLr_G_MISTP_STATEf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access G_PCTL.
 *
 */
#define BCM53115_A0_READ_G_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_PCTLr,(r._g_pctl),1)
#define BCM53115_A0_WRITE_G_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_PCTLr,&(r._g_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PCTLr BCM53115_A0_G_PCTLr
#define G_PCTLr_SIZE BCM53115_A0_G_PCTLr_SIZE
typedef BCM53115_A0_G_PCTLr_t G_PCTLr_t;
#define G_PCTLr_CLR BCM53115_A0_G_PCTLr_CLR
#define G_PCTLr_SET BCM53115_A0_G_PCTLr_SET
#define G_PCTLr_GET BCM53115_A0_G_PCTLr_GET
#define G_PCTLr_RX_DISf_GET BCM53115_A0_G_PCTLr_RX_DISf_GET
#define G_PCTLr_RX_DISf_SET BCM53115_A0_G_PCTLr_RX_DISf_SET
#define G_PCTLr_TX_DISf_GET BCM53115_A0_G_PCTLr_TX_DISf_GET
#define G_PCTLr_TX_DISf_SET BCM53115_A0_G_PCTLr_TX_DISf_SET
#define G_PCTLr_RESERVED_Rf_GET BCM53115_A0_G_PCTLr_RESERVED_Rf_GET
#define G_PCTLr_RESERVED_Rf_SET BCM53115_A0_G_PCTLr_RESERVED_Rf_SET
#define G_PCTLr_G_MISTP_STATEf_GET BCM53115_A0_G_PCTLr_G_MISTP_STATEf_GET
#define G_PCTLr_G_MISTP_STATEf_SET BCM53115_A0_G_PCTLr_G_MISTP_STATEf_SET
#define READ_G_PCTLr BCM53115_A0_READ_G_PCTLr
#define WRITE_G_PCTLr BCM53115_A0_WRITE_G_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHYIDH
 * BLOCKS:   GPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI_HI           Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHYIDHr 0x00001004

#define BCM53115_A0_G_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH.
 *
 */
typedef union BCM53115_A0_G_PHYIDHr_s {
	uint32_t v[1];
	uint32_t g_phyidh[1];
	uint32_t _g_phyidh;
} BCM53115_A0_G_PHYIDHr_t;

#define BCM53115_A0_G_PHYIDHr_CLR(r) (r).g_phyidh[0] = 0
#define BCM53115_A0_G_PHYIDHr_SET(r,d) (r).g_phyidh[0] = d
#define BCM53115_A0_G_PHYIDHr_GET(r) (r).g_phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHYIDHr_OUI_HIf_GET(r) (((r).g_phyidh[0]) & 0xffff)
#define BCM53115_A0_G_PHYIDHr_OUI_HIf_SET(r,f) (r).g_phyidh[0]=(((r).g_phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH.
 *
 */
#define BCM53115_A0_READ_G_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_PHYIDHr,(r._g_phyidh),2)
#define BCM53115_A0_WRITE_G_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_PHYIDHr,&(r._g_phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDHr BCM53115_A0_G_PHYIDHr
#define G_PHYIDHr_SIZE BCM53115_A0_G_PHYIDHr_SIZE
typedef BCM53115_A0_G_PHYIDHr_t G_PHYIDHr_t;
#define G_PHYIDHr_CLR BCM53115_A0_G_PHYIDHr_CLR
#define G_PHYIDHr_SET BCM53115_A0_G_PHYIDHr_SET
#define G_PHYIDHr_GET BCM53115_A0_G_PHYIDHr_GET
#define G_PHYIDHr_OUI_HIf_GET BCM53115_A0_G_PHYIDHr_OUI_HIf_GET
#define G_PHYIDHr_OUI_HIf_SET BCM53115_A0_G_PHYIDHr_OUI_HIf_SET
#define READ_G_PHYIDHr BCM53115_A0_READ_G_PHYIDHr
#define WRITE_G_PHYIDHr BCM53115_A0_WRITE_G_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHYIDH_EXT
 * BLOCKS:   CPIC
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI_HI           Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHYIDH_EXTr 0x00008804

#define BCM53115_A0_G_PHYIDH_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT.
 *
 */
typedef union BCM53115_A0_G_PHYIDH_EXTr_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext[1];
	uint32_t _g_phyidh_ext;
} BCM53115_A0_G_PHYIDH_EXTr_t;

#define BCM53115_A0_G_PHYIDH_EXTr_CLR(r) (r).g_phyidh_ext[0] = 0
#define BCM53115_A0_G_PHYIDH_EXTr_SET(r,d) (r).g_phyidh_ext[0] = d
#define BCM53115_A0_G_PHYIDH_EXTr_GET(r) (r).g_phyidh_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHYIDH_EXTr_OUI_HIf_GET(r) (((r).g_phyidh_ext[0]) & 0xffff)
#define BCM53115_A0_G_PHYIDH_EXTr_OUI_HIf_SET(r,f) (r).g_phyidh_ext[0]=(((r).g_phyidh_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT.
 *
 */
#define BCM53115_A0_READ_G_PHYIDH_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_PHYIDH_EXTr,(r._g_phyidh_ext),2)
#define BCM53115_A0_WRITE_G_PHYIDH_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_PHYIDH_EXTr,&(r._g_phyidh_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXTr BCM53115_A0_G_PHYIDH_EXTr
#define G_PHYIDH_EXTr_SIZE BCM53115_A0_G_PHYIDH_EXTr_SIZE
typedef BCM53115_A0_G_PHYIDH_EXTr_t G_PHYIDH_EXTr_t;
#define G_PHYIDH_EXTr_CLR BCM53115_A0_G_PHYIDH_EXTr_CLR
#define G_PHYIDH_EXTr_SET BCM53115_A0_G_PHYIDH_EXTr_SET
#define G_PHYIDH_EXTr_GET BCM53115_A0_G_PHYIDH_EXTr_GET
#define G_PHYIDH_EXTr_OUI_HIf_GET BCM53115_A0_G_PHYIDH_EXTr_OUI_HIf_GET
#define G_PHYIDH_EXTr_OUI_HIf_SET BCM53115_A0_G_PHYIDH_EXTr_OUI_HIf_SET
#define READ_G_PHYIDH_EXTr BCM53115_A0_READ_G_PHYIDH_EXTr
#define WRITE_G_PHYIDH_EXTr BCM53115_A0_WRITE_G_PHYIDH_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHYIDH_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHYIDH_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI_HI           Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHYIDH_EXT_P5r 0x00008504

#define BCM53115_A0_G_PHYIDH_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_PHYIDH_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext_p5[1];
	uint32_t _g_phyidh_ext_p5;
} BCM53115_A0_G_PHYIDH_EXT_P5r_t;

#define BCM53115_A0_G_PHYIDH_EXT_P5r_CLR(r) (r).g_phyidh_ext_p5[0] = 0
#define BCM53115_A0_G_PHYIDH_EXT_P5r_SET(r,d) (r).g_phyidh_ext_p5[0] = d
#define BCM53115_A0_G_PHYIDH_EXT_P5r_GET(r) (r).g_phyidh_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHYIDH_EXT_P5r_OUI_HIf_GET(r) (((r).g_phyidh_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_PHYIDH_EXT_P5r_OUI_HIf_SET(r,f) (r).g_phyidh_ext_p5[0]=(((r).g_phyidh_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_PHYIDH_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_PHYIDH_EXT_P5r,(r._g_phyidh_ext_p5),2)
#define BCM53115_A0_WRITE_G_PHYIDH_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_PHYIDH_EXT_P5r,&(r._g_phyidh_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXT_P5r BCM53115_A0_G_PHYIDH_EXT_P5r
#define G_PHYIDH_EXT_P5r_SIZE BCM53115_A0_G_PHYIDH_EXT_P5r_SIZE
typedef BCM53115_A0_G_PHYIDH_EXT_P5r_t G_PHYIDH_EXT_P5r_t;
#define G_PHYIDH_EXT_P5r_CLR BCM53115_A0_G_PHYIDH_EXT_P5r_CLR
#define G_PHYIDH_EXT_P5r_SET BCM53115_A0_G_PHYIDH_EXT_P5r_SET
#define G_PHYIDH_EXT_P5r_GET BCM53115_A0_G_PHYIDH_EXT_P5r_GET
#define G_PHYIDH_EXT_P5r_OUI_HIf_GET BCM53115_A0_G_PHYIDH_EXT_P5r_OUI_HIf_GET
#define G_PHYIDH_EXT_P5r_OUI_HIf_SET BCM53115_A0_G_PHYIDH_EXT_P5r_OUI_HIf_SET
#define READ_G_PHYIDH_EXT_P5r BCM53115_A0_READ_G_PHYIDH_EXT_P5r
#define WRITE_G_PHYIDH_EXT_P5r BCM53115_A0_WRITE_G_PHYIDH_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHYIDH_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHYIDL
 * BLOCKS:   GPIC0
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI_LOW          Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHYIDLr 0x00001006

#define BCM53115_A0_G_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL.
 *
 */
typedef union BCM53115_A0_G_PHYIDLr_s {
	uint32_t v[1];
	uint32_t g_phyidl[1];
	uint32_t _g_phyidl;
} BCM53115_A0_G_PHYIDLr_t;

#define BCM53115_A0_G_PHYIDLr_CLR(r) (r).g_phyidl[0] = 0
#define BCM53115_A0_G_PHYIDLr_SET(r,d) (r).g_phyidl[0] = d
#define BCM53115_A0_G_PHYIDLr_GET(r) (r).g_phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHYIDLr_REVISIONf_GET(r) (((r).g_phyidl[0]) & 0xf)
#define BCM53115_A0_G_PHYIDLr_REVISIONf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_G_PHYIDLr_MODELf_GET(r) ((((r).g_phyidl[0]) >> 4) & 0x3f)
#define BCM53115_A0_G_PHYIDLr_MODELf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53115_A0_G_PHYIDLr_OUI_LOWf_GET(r) ((((r).g_phyidl[0]) >> 10) & 0x3f)
#define BCM53115_A0_G_PHYIDLr_OUI_LOWf_SET(r,f) (r).g_phyidl[0]=(((r).g_phyidl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL.
 *
 */
#define BCM53115_A0_READ_G_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_PHYIDLr,(r._g_phyidl),2)
#define BCM53115_A0_WRITE_G_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_PHYIDLr,&(r._g_phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDLr BCM53115_A0_G_PHYIDLr
#define G_PHYIDLr_SIZE BCM53115_A0_G_PHYIDLr_SIZE
typedef BCM53115_A0_G_PHYIDLr_t G_PHYIDLr_t;
#define G_PHYIDLr_CLR BCM53115_A0_G_PHYIDLr_CLR
#define G_PHYIDLr_SET BCM53115_A0_G_PHYIDLr_SET
#define G_PHYIDLr_GET BCM53115_A0_G_PHYIDLr_GET
#define G_PHYIDLr_REVISIONf_GET BCM53115_A0_G_PHYIDLr_REVISIONf_GET
#define G_PHYIDLr_REVISIONf_SET BCM53115_A0_G_PHYIDLr_REVISIONf_SET
#define G_PHYIDLr_MODELf_GET BCM53115_A0_G_PHYIDLr_MODELf_GET
#define G_PHYIDLr_MODELf_SET BCM53115_A0_G_PHYIDLr_MODELf_SET
#define G_PHYIDLr_OUI_LOWf_GET BCM53115_A0_G_PHYIDLr_OUI_LOWf_GET
#define G_PHYIDLr_OUI_LOWf_SET BCM53115_A0_G_PHYIDLr_OUI_LOWf_SET
#define READ_G_PHYIDLr BCM53115_A0_READ_G_PHYIDLr
#define WRITE_G_PHYIDLr BCM53115_A0_WRITE_G_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHYIDL_EXT
 * BLOCKS:   CPIC
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI_LOW          Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHYIDL_EXTr 0x00008806

#define BCM53115_A0_G_PHYIDL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT.
 *
 */
typedef union BCM53115_A0_G_PHYIDL_EXTr_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext[1];
	uint32_t _g_phyidl_ext;
} BCM53115_A0_G_PHYIDL_EXTr_t;

#define BCM53115_A0_G_PHYIDL_EXTr_CLR(r) (r).g_phyidl_ext[0] = 0
#define BCM53115_A0_G_PHYIDL_EXTr_SET(r,d) (r).g_phyidl_ext[0] = d
#define BCM53115_A0_G_PHYIDL_EXTr_GET(r) (r).g_phyidl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHYIDL_EXTr_REVISIONf_GET(r) (((r).g_phyidl_ext[0]) & 0xf)
#define BCM53115_A0_G_PHYIDL_EXTr_REVISIONf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_G_PHYIDL_EXTr_MODELf_GET(r) ((((r).g_phyidl_ext[0]) >> 4) & 0x3f)
#define BCM53115_A0_G_PHYIDL_EXTr_MODELf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53115_A0_G_PHYIDL_EXTr_OUI_LOWf_GET(r) ((((r).g_phyidl_ext[0]) >> 10) & 0x3f)
#define BCM53115_A0_G_PHYIDL_EXTr_OUI_LOWf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT.
 *
 */
#define BCM53115_A0_READ_G_PHYIDL_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_PHYIDL_EXTr,(r._g_phyidl_ext),2)
#define BCM53115_A0_WRITE_G_PHYIDL_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_PHYIDL_EXTr,&(r._g_phyidl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXTr BCM53115_A0_G_PHYIDL_EXTr
#define G_PHYIDL_EXTr_SIZE BCM53115_A0_G_PHYIDL_EXTr_SIZE
typedef BCM53115_A0_G_PHYIDL_EXTr_t G_PHYIDL_EXTr_t;
#define G_PHYIDL_EXTr_CLR BCM53115_A0_G_PHYIDL_EXTr_CLR
#define G_PHYIDL_EXTr_SET BCM53115_A0_G_PHYIDL_EXTr_SET
#define G_PHYIDL_EXTr_GET BCM53115_A0_G_PHYIDL_EXTr_GET
#define G_PHYIDL_EXTr_REVISIONf_GET BCM53115_A0_G_PHYIDL_EXTr_REVISIONf_GET
#define G_PHYIDL_EXTr_REVISIONf_SET BCM53115_A0_G_PHYIDL_EXTr_REVISIONf_SET
#define G_PHYIDL_EXTr_MODELf_GET BCM53115_A0_G_PHYIDL_EXTr_MODELf_GET
#define G_PHYIDL_EXTr_MODELf_SET BCM53115_A0_G_PHYIDL_EXTr_MODELf_SET
#define G_PHYIDL_EXTr_OUI_LOWf_GET BCM53115_A0_G_PHYIDL_EXTr_OUI_LOWf_GET
#define G_PHYIDL_EXTr_OUI_LOWf_SET BCM53115_A0_G_PHYIDL_EXTr_OUI_LOWf_SET
#define READ_G_PHYIDL_EXTr BCM53115_A0_READ_G_PHYIDL_EXTr
#define WRITE_G_PHYIDL_EXTr BCM53115_A0_WRITE_G_PHYIDL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHYIDL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHYIDL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI_LOW          Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHYIDL_EXT_P5r 0x00008506

#define BCM53115_A0_G_PHYIDL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_PHYIDL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext_p5[1];
	uint32_t _g_phyidl_ext_p5;
} BCM53115_A0_G_PHYIDL_EXT_P5r_t;

#define BCM53115_A0_G_PHYIDL_EXT_P5r_CLR(r) (r).g_phyidl_ext_p5[0] = 0
#define BCM53115_A0_G_PHYIDL_EXT_P5r_SET(r,d) (r).g_phyidl_ext_p5[0] = d
#define BCM53115_A0_G_PHYIDL_EXT_P5r_GET(r) (r).g_phyidl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHYIDL_EXT_P5r_REVISIONf_GET(r) (((r).g_phyidl_ext_p5[0]) & 0xf)
#define BCM53115_A0_G_PHYIDL_EXT_P5r_REVISIONf_SET(r,f) (r).g_phyidl_ext_p5[0]=(((r).g_phyidl_ext_p5[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_G_PHYIDL_EXT_P5r_MODELf_GET(r) ((((r).g_phyidl_ext_p5[0]) >> 4) & 0x3f)
#define BCM53115_A0_G_PHYIDL_EXT_P5r_MODELf_SET(r,f) (r).g_phyidl_ext_p5[0]=(((r).g_phyidl_ext_p5[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53115_A0_G_PHYIDL_EXT_P5r_OUI_LOWf_GET(r) ((((r).g_phyidl_ext_p5[0]) >> 10) & 0x3f)
#define BCM53115_A0_G_PHYIDL_EXT_P5r_OUI_LOWf_SET(r,f) (r).g_phyidl_ext_p5[0]=(((r).g_phyidl_ext_p5[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_PHYIDL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_PHYIDL_EXT_P5r,(r._g_phyidl_ext_p5),2)
#define BCM53115_A0_WRITE_G_PHYIDL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_PHYIDL_EXT_P5r,&(r._g_phyidl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXT_P5r BCM53115_A0_G_PHYIDL_EXT_P5r
#define G_PHYIDL_EXT_P5r_SIZE BCM53115_A0_G_PHYIDL_EXT_P5r_SIZE
typedef BCM53115_A0_G_PHYIDL_EXT_P5r_t G_PHYIDL_EXT_P5r_t;
#define G_PHYIDL_EXT_P5r_CLR BCM53115_A0_G_PHYIDL_EXT_P5r_CLR
#define G_PHYIDL_EXT_P5r_SET BCM53115_A0_G_PHYIDL_EXT_P5r_SET
#define G_PHYIDL_EXT_P5r_GET BCM53115_A0_G_PHYIDL_EXT_P5r_GET
#define G_PHYIDL_EXT_P5r_REVISIONf_GET BCM53115_A0_G_PHYIDL_EXT_P5r_REVISIONf_GET
#define G_PHYIDL_EXT_P5r_REVISIONf_SET BCM53115_A0_G_PHYIDL_EXT_P5r_REVISIONf_SET
#define G_PHYIDL_EXT_P5r_MODELf_GET BCM53115_A0_G_PHYIDL_EXT_P5r_MODELf_GET
#define G_PHYIDL_EXT_P5r_MODELf_SET BCM53115_A0_G_PHYIDL_EXT_P5r_MODELf_SET
#define G_PHYIDL_EXT_P5r_OUI_LOWf_GET BCM53115_A0_G_PHYIDL_EXT_P5r_OUI_LOWf_GET
#define G_PHYIDL_EXT_P5r_OUI_LOWf_SET BCM53115_A0_G_PHYIDL_EXT_P5r_OUI_LOWf_SET
#define READ_G_PHYIDL_EXT_P5r BCM53115_A0_READ_G_PHYIDL_EXT_P5r
#define WRITE_G_PHYIDL_EXT_P5r BCM53115_A0_WRITE_G_PHYIDL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHYIDL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHY_EXT_CTL
 * BLOCKS:   GPIC0
 * DESC:     PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHY_EXT_CTLr 0x00001020

#define BCM53115_A0_G_PHY_EXT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL.
 *
 */
typedef union BCM53115_A0_G_PHY_EXT_CTLr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl[1];
	uint32_t _g_phy_ext_ctl;
} BCM53115_A0_G_PHY_EXT_CTLr_t;

#define BCM53115_A0_G_PHY_EXT_CTLr_CLR(r) (r).g_phy_ext_ctl[0] = 0
#define BCM53115_A0_G_PHY_EXT_CTLr_SET(r,d) (r).g_phy_ext_ctl[0] = d
#define BCM53115_A0_G_PHY_EXT_CTLr_GET(r) (r).g_phy_ext_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl[0]) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 1) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 2) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 3) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 4) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 5) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 6) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 7) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl[0]) >> 8) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 9) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 10) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 11) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 12) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 13) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 14) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl[0]) >> 15) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl[0]=(((r).g_phy_ext_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL.
 *
 */
#define BCM53115_A0_READ_G_PHY_EXT_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_PHY_EXT_CTLr,(r._g_phy_ext_ctl),2)
#define BCM53115_A0_WRITE_G_PHY_EXT_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_PHY_EXT_CTLr,&(r._g_phy_ext_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTLr BCM53115_A0_G_PHY_EXT_CTLr
#define G_PHY_EXT_CTLr_SIZE BCM53115_A0_G_PHY_EXT_CTLr_SIZE
typedef BCM53115_A0_G_PHY_EXT_CTLr_t G_PHY_EXT_CTLr_t;
#define G_PHY_EXT_CTLr_CLR BCM53115_A0_G_PHY_EXT_CTLr_CLR
#define G_PHY_EXT_CTLr_SET BCM53115_A0_G_PHY_EXT_CTLr_SET
#define G_PHY_EXT_CTLr_GET BCM53115_A0_G_PHY_EXT_CTLr_GET
#define G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET BCM53115_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET BCM53115_A0_G_PHY_EXT_CTLr_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET BCM53115_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET BCM53115_A0_G_PHY_EXT_CTLr_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET BCM53115_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET BCM53115_A0_G_PHY_EXT_CTLr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET BCM53115_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET BCM53115_A0_G_PHY_EXT_CTLr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTLr_FORCE_LED_ONf_GET BCM53115_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTLr_FORCE_LED_ONf_SET BCM53115_A0_G_PHY_EXT_CTLr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET BCM53115_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET BCM53115_A0_G_PHY_EXT_CTLr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET BCM53115_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET BCM53115_A0_G_PHY_EXT_CTLr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET BCM53115_A0_G_PHY_EXT_CTLr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET BCM53115_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET BCM53115_A0_G_PHY_EXT_CTLr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTLr_INTERRUPT_DISf_GET BCM53115_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTLr_INTERRUPT_DISf_SET BCM53115_A0_G_PHY_EXT_CTLr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTLr_TRANSMIT_DISf_GET BCM53115_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTLr_TRANSMIT_DISf_SET BCM53115_A0_G_PHY_EXT_CTLr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET BCM53115_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET BCM53115_A0_G_PHY_EXT_CTLr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET BCM53115_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET BCM53115_A0_G_PHY_EXT_CTLr_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTLr BCM53115_A0_READ_G_PHY_EXT_CTLr
#define WRITE_G_PHY_EXT_CTLr BCM53115_A0_WRITE_G_PHY_EXT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHY_EXT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT
 * BLOCKS:   CPIC
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr 0x00008820

#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT.
 *
 */
typedef union BCM53115_A0_G_PHY_EXT_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext[1];
	uint32_t _g_phy_ext_ctl_ext;
} BCM53115_A0_G_PHY_EXT_CTL_EXTr_t;

#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_CLR(r) (r).g_phy_ext_ctl_ext[0] = 0
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_SET(r,d) (r).g_phy_ext_ctl_ext[0] = d
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_GET(r) (r).g_phy_ext_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext[0]) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 1) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 2) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 3) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 4) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 5) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 6) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 7) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 8) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 9) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 10) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT.
 *
 */
#define BCM53115_A0_READ_G_PHY_EXT_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_PHY_EXT_CTL_EXTr,(r._g_phy_ext_ctl_ext),2)
#define BCM53115_A0_WRITE_G_PHY_EXT_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_PHY_EXT_CTL_EXTr,&(r._g_phy_ext_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXTr BCM53115_A0_G_PHY_EXT_CTL_EXTr
#define G_PHY_EXT_CTL_EXTr_SIZE BCM53115_A0_G_PHY_EXT_CTL_EXTr_SIZE
typedef BCM53115_A0_G_PHY_EXT_CTL_EXTr_t G_PHY_EXT_CTL_EXTr_t;
#define G_PHY_EXT_CTL_EXTr_CLR BCM53115_A0_G_PHY_EXT_CTL_EXTr_CLR
#define G_PHY_EXT_CTL_EXTr_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_SET
#define G_PHY_EXT_CTL_EXTr_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_GET
#define G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET BCM53115_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET BCM53115_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXTr BCM53115_A0_READ_G_PHY_EXT_CTL_EXTr
#define WRITE_G_PHY_EXT_CTL_EXTr BCM53115_A0_WRITE_G_PHY_EXT_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHY_EXT_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r 0x00008520

#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext_p5[1];
	uint32_t _g_phy_ext_ctl_ext_p5;
} BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_t;

#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_CLR(r) (r).g_phy_ext_ctl_ext_p5[0] = 0
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_SET(r,d) (r).g_phy_ext_ctl_ext_p5[0] = d
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_GET(r) (r).g_phy_ext_ctl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext_p5[0]) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 1) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 2) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 3) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 4) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 5) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 6) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 7) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 8) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 9) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 10) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext_p5[0]=(((r).g_phy_ext_ctl_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_PHY_EXT_CTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r,(r._g_phy_ext_ctl_ext_p5),2)
#define BCM53115_A0_WRITE_G_PHY_EXT_CTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r,&(r._g_phy_ext_ctl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXT_P5r BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r
#define G_PHY_EXT_CTL_EXT_P5r_SIZE BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_SIZE
typedef BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_t G_PHY_EXT_CTL_EXT_P5r_t;
#define G_PHY_EXT_CTL_EXT_P5r_CLR BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_CLR
#define G_PHY_EXT_CTL_EXT_P5r_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_SET
#define G_PHY_EXT_CTL_EXT_P5r_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_GET
#define G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_GET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_SET BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXT_P5r BCM53115_A0_READ_G_PHY_EXT_CTL_EXT_P5r
#define WRITE_G_PHY_EXT_CTL_EXT_P5r BCM53115_A0_WRITE_G_PHY_EXT_CTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHY_EXT_CTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHY_EXT_STS
 * BLOCKS:   GPIC0
 * DESC:     PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK_R           1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHY_EXT_STSr 0x00001022

#define BCM53115_A0_G_PHY_EXT_STSr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS.
 *
 */
typedef union BCM53115_A0_G_PHY_EXT_STSr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts[1];
	uint32_t _g_phy_ext_sts;
} BCM53115_A0_G_PHY_EXT_STSr_t;

#define BCM53115_A0_G_PHY_EXT_STSr_CLR(r) (r).g_phy_ext_sts[0] = 0
#define BCM53115_A0_G_PHY_EXT_STSr_SET(r,d) (r).g_phy_ext_sts[0] = d
#define BCM53115_A0_G_PHY_EXT_STSr_GET(r) (r).g_phy_ext_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts[0]) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 1) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 2) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_PHY_EXT_STSr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 3) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 4) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 5) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 6) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts[0]) >> 7) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_PHY_EXT_STSr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 8) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_PHY_EXT_STSr_LOCK_Rf_GET(r) ((((r).g_phy_ext_sts[0]) >> 9) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_LOCK_Rf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 10) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 11) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts[0]) >> 12) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts[0]) >> 13) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts[0]) >> 14) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts[0]) >> 15) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts[0]=(((r).g_phy_ext_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS.
 *
 */
#define BCM53115_A0_READ_G_PHY_EXT_STSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_PHY_EXT_STSr,(r._g_phy_ext_sts),2)
#define BCM53115_A0_WRITE_G_PHY_EXT_STSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_PHY_EXT_STSr,&(r._g_phy_ext_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STSr BCM53115_A0_G_PHY_EXT_STSr
#define G_PHY_EXT_STSr_SIZE BCM53115_A0_G_PHY_EXT_STSr_SIZE
typedef BCM53115_A0_G_PHY_EXT_STSr_t G_PHY_EXT_STSr_t;
#define G_PHY_EXT_STSr_CLR BCM53115_A0_G_PHY_EXT_STSr_CLR
#define G_PHY_EXT_STSr_SET BCM53115_A0_G_PHY_EXT_STSr_SET
#define G_PHY_EXT_STSr_GET BCM53115_A0_G_PHY_EXT_STSr_GET
#define G_PHY_EXT_STSr_MLT3_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STSr_MLT3_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STSr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STSr_LCK_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STSr_LCK_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STSr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STSr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STSr_REC_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STSr_REC_ERR_DETf_GET
#define G_PHY_EXT_STSr_REC_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STSr_REC_ERR_DETf_SET
#define G_PHY_EXT_STSr_BAD_ESD_DETf_GET BCM53115_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STSr_BAD_ESD_DETf_SET BCM53115_A0_G_PHY_EXT_STSr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STSr_BAD_SSD_DETf_GET BCM53115_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STSr_BAD_SSD_DETf_SET BCM53115_A0_G_PHY_EXT_STSr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STSr_CARR_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STSr_CARR_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STSr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STSr_CRC_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STSr_CRC_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STSr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STSr_LINK_STSf_GET BCM53115_A0_G_PHY_EXT_STSr_LINK_STSf_GET
#define G_PHY_EXT_STSr_LINK_STSf_SET BCM53115_A0_G_PHY_EXT_STSr_LINK_STSf_SET
#define G_PHY_EXT_STSr_LOCK_Rf_GET BCM53115_A0_G_PHY_EXT_STSr_LOCK_Rf_GET
#define G_PHY_EXT_STSr_LOCK_Rf_SET BCM53115_A0_G_PHY_EXT_STSr_LOCK_Rf_SET
#define G_PHY_EXT_STSr_LOCAL_REC_STSf_GET BCM53115_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STSr_LOCAL_REC_STSf_SET BCM53115_A0_G_PHY_EXT_STSr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STSr_REMOTE_REC_STSf_GET BCM53115_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STSr_REMOTE_REC_STSf_SET BCM53115_A0_G_PHY_EXT_STSr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STSr_INTERRUPT_STSf_GET BCM53115_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STSr_INTERRUPT_STSf_SET BCM53115_A0_G_PHY_EXT_STSr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STSr_MDI_CROS_STATEf_GET BCM53115_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STSr_MDI_CROS_STATEf_SET BCM53115_A0_G_PHY_EXT_STSr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET BCM53115_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET BCM53115_A0_G_PHY_EXT_STSr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET BCM53115_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET BCM53115_A0_G_PHY_EXT_STSr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STSr BCM53115_A0_READ_G_PHY_EXT_STSr
#define WRITE_G_PHY_EXT_STSr BCM53115_A0_WRITE_G_PHY_EXT_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHY_EXT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHY_EXT_STS_EXT
 * BLOCKS:   CPIC
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK_R           1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHY_EXT_STS_EXTr 0x00008822

#define BCM53115_A0_G_PHY_EXT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT.
 *
 */
typedef union BCM53115_A0_G_PHY_EXT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext[1];
	uint32_t _g_phy_ext_sts_ext;
} BCM53115_A0_G_PHY_EXT_STS_EXTr_t;

#define BCM53115_A0_G_PHY_EXT_STS_EXTr_CLR(r) (r).g_phy_ext_sts_ext[0] = 0
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_SET(r,d) (r).g_phy_ext_sts_ext[0] = d
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_GET(r) (r).g_phy_ext_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext[0]) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 1) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 2) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 3) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 4) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 5) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 6) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 7) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 8) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_LOCK_Rf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 9) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_LOCK_Rf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 10) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 11) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 12) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 13) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 14) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 15) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT.
 *
 */
#define BCM53115_A0_READ_G_PHY_EXT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_PHY_EXT_STS_EXTr,(r._g_phy_ext_sts_ext),2)
#define BCM53115_A0_WRITE_G_PHY_EXT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_PHY_EXT_STS_EXTr,&(r._g_phy_ext_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXTr BCM53115_A0_G_PHY_EXT_STS_EXTr
#define G_PHY_EXT_STS_EXTr_SIZE BCM53115_A0_G_PHY_EXT_STS_EXTr_SIZE
typedef BCM53115_A0_G_PHY_EXT_STS_EXTr_t G_PHY_EXT_STS_EXTr_t;
#define G_PHY_EXT_STS_EXTr_CLR BCM53115_A0_G_PHY_EXT_STS_EXTr_CLR
#define G_PHY_EXT_STS_EXTr_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_SET
#define G_PHY_EXT_STS_EXTr_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_GET
#define G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_LINK_STSf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_GET
#define G_PHY_EXT_STS_EXTr_LINK_STSf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_SET
#define G_PHY_EXT_STS_EXTr_LOCK_Rf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_LOCK_Rf_GET
#define G_PHY_EXT_STS_EXTr_LOCK_Rf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_LOCK_Rf_SET
#define G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET BCM53115_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET BCM53115_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXTr BCM53115_A0_READ_G_PHY_EXT_STS_EXTr
#define WRITE_G_PHY_EXT_STS_EXTr BCM53115_A0_WRITE_G_PHY_EXT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHY_EXT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_PHY_EXT_STS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK_R           1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r 0x00008522

#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext_p5[1];
	uint32_t _g_phy_ext_sts_ext_p5;
} BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_t;

#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CLR(r) (r).g_phy_ext_sts_ext_p5[0] = 0
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_SET(r,d) (r).g_phy_ext_sts_ext_p5[0] = d
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_GET(r) (r).g_phy_ext_sts_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext_p5[0]) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 1) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 2) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 3) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 4) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 5) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 6) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 7) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 8) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LOCK_Rf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 9) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LOCK_Rf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 10) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 11) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 12) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 13) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 14) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext_p5[0]) >> 15) & 0x1)
#define BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext_p5[0]=(((r).g_phy_ext_sts_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_PHY_EXT_STS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_PHY_EXT_STS_EXT_P5r,(r._g_phy_ext_sts_ext_p5),2)
#define BCM53115_A0_WRITE_G_PHY_EXT_STS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_PHY_EXT_STS_EXT_P5r,&(r._g_phy_ext_sts_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXT_P5r BCM53115_A0_G_PHY_EXT_STS_EXT_P5r
#define G_PHY_EXT_STS_EXT_P5r_SIZE BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_SIZE
typedef BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_t G_PHY_EXT_STS_EXT_P5r_t;
#define G_PHY_EXT_STS_EXT_P5r_CLR BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CLR
#define G_PHY_EXT_STS_EXT_P5r_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_SET
#define G_PHY_EXT_STS_EXT_P5r_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_GET
#define G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXT_P5r_LINK_STSf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LINK_STSf_GET
#define G_PHY_EXT_STS_EXT_P5r_LINK_STSf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LINK_STSf_SET
#define G_PHY_EXT_STS_EXT_P5r_LOCK_Rf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LOCK_Rf_GET
#define G_PHY_EXT_STS_EXT_P5r_LOCK_Rf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LOCK_Rf_SET
#define G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_GET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_SET BCM53115_A0_G_PHY_EXT_STS_EXT_P5r_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXT_P5r BCM53115_A0_READ_G_PHY_EXT_STS_EXT_P5r
#define WRITE_G_PHY_EXT_STS_EXT_P5r BCM53115_A0_WRITE_G_PHY_EXT_STS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_PHY_EXT_STS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_REC_ERR_CNT
 * BLOCKS:   GPIC0
 * DESC:     Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM53115_A0_G_REC_ERR_CNTr 0x00001024

#define BCM53115_A0_G_REC_ERR_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT.
 *
 */
typedef union BCM53115_A0_G_REC_ERR_CNTr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt[1];
	uint32_t _g_rec_err_cnt;
} BCM53115_A0_G_REC_ERR_CNTr_t;

#define BCM53115_A0_G_REC_ERR_CNTr_CLR(r) (r).g_rec_err_cnt[0] = 0
#define BCM53115_A0_G_REC_ERR_CNTr_SET(r,d) (r).g_rec_err_cnt[0] = d
#define BCM53115_A0_G_REC_ERR_CNTr_GET(r) (r).g_rec_err_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt[0]) & 0xffff)
#define BCM53115_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt[0]=(((r).g_rec_err_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT.
 *
 */
#define BCM53115_A0_READ_G_REC_ERR_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_REC_ERR_CNTr,(r._g_rec_err_cnt),2)
#define BCM53115_A0_WRITE_G_REC_ERR_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_REC_ERR_CNTr,&(r._g_rec_err_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNTr BCM53115_A0_G_REC_ERR_CNTr
#define G_REC_ERR_CNTr_SIZE BCM53115_A0_G_REC_ERR_CNTr_SIZE
typedef BCM53115_A0_G_REC_ERR_CNTr_t G_REC_ERR_CNTr_t;
#define G_REC_ERR_CNTr_CLR BCM53115_A0_G_REC_ERR_CNTr_CLR
#define G_REC_ERR_CNTr_SET BCM53115_A0_G_REC_ERR_CNTr_SET
#define G_REC_ERR_CNTr_GET BCM53115_A0_G_REC_ERR_CNTr_GET
#define G_REC_ERR_CNTr_REC_ERR_CNTf_GET BCM53115_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNTr_REC_ERR_CNTf_SET BCM53115_A0_G_REC_ERR_CNTr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNTr BCM53115_A0_READ_G_REC_ERR_CNTr
#define WRITE_G_REC_ERR_CNTr BCM53115_A0_WRITE_G_REC_ERR_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_REC_ERR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_REC_ERR_CNT_EXT
 * BLOCKS:   CPIC
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM53115_A0_G_REC_ERR_CNT_EXTr 0x00008824

#define BCM53115_A0_G_REC_ERR_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT.
 *
 */
typedef union BCM53115_A0_G_REC_ERR_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext[1];
	uint32_t _g_rec_err_cnt_ext;
} BCM53115_A0_G_REC_ERR_CNT_EXTr_t;

#define BCM53115_A0_G_REC_ERR_CNT_EXTr_CLR(r) (r).g_rec_err_cnt_ext[0] = 0
#define BCM53115_A0_G_REC_ERR_CNT_EXTr_SET(r,d) (r).g_rec_err_cnt_ext[0] = d
#define BCM53115_A0_G_REC_ERR_CNT_EXTr_GET(r) (r).g_rec_err_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext[0]) & 0xffff)
#define BCM53115_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext[0]=(((r).g_rec_err_cnt_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT.
 *
 */
#define BCM53115_A0_READ_G_REC_ERR_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_REC_ERR_CNT_EXTr,(r._g_rec_err_cnt_ext),2)
#define BCM53115_A0_WRITE_G_REC_ERR_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_REC_ERR_CNT_EXTr,&(r._g_rec_err_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXTr BCM53115_A0_G_REC_ERR_CNT_EXTr
#define G_REC_ERR_CNT_EXTr_SIZE BCM53115_A0_G_REC_ERR_CNT_EXTr_SIZE
typedef BCM53115_A0_G_REC_ERR_CNT_EXTr_t G_REC_ERR_CNT_EXTr_t;
#define G_REC_ERR_CNT_EXTr_CLR BCM53115_A0_G_REC_ERR_CNT_EXTr_CLR
#define G_REC_ERR_CNT_EXTr_SET BCM53115_A0_G_REC_ERR_CNT_EXTr_SET
#define G_REC_ERR_CNT_EXTr_GET BCM53115_A0_G_REC_ERR_CNT_EXTr_GET
#define G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET BCM53115_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET BCM53115_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXTr BCM53115_A0_READ_G_REC_ERR_CNT_EXTr
#define WRITE_G_REC_ERR_CNT_EXTr BCM53115_A0_WRITE_G_REC_ERR_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_REC_ERR_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_REC_ERR_CNT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM53115_A0_G_REC_ERR_CNT_EXT_P5r 0x00008524

#define BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext_p5[1];
	uint32_t _g_rec_err_cnt_ext_p5;
} BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_t;

#define BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_CLR(r) (r).g_rec_err_cnt_ext_p5[0] = 0
#define BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_SET(r,d) (r).g_rec_err_cnt_ext_p5[0] = d
#define BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_GET(r) (r).g_rec_err_cnt_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext_p5[0]=(((r).g_rec_err_cnt_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_REC_ERR_CNT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_REC_ERR_CNT_EXT_P5r,(r._g_rec_err_cnt_ext_p5),2)
#define BCM53115_A0_WRITE_G_REC_ERR_CNT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_REC_ERR_CNT_EXT_P5r,&(r._g_rec_err_cnt_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXT_P5r BCM53115_A0_G_REC_ERR_CNT_EXT_P5r
#define G_REC_ERR_CNT_EXT_P5r_SIZE BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_SIZE
typedef BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_t G_REC_ERR_CNT_EXT_P5r_t;
#define G_REC_ERR_CNT_EXT_P5r_CLR BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_CLR
#define G_REC_ERR_CNT_EXT_P5r_SET BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_SET
#define G_REC_ERR_CNT_EXT_P5r_GET BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_GET
#define G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_GET BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_SET BCM53115_A0_G_REC_ERR_CNT_EXT_P5r_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXT_P5r BCM53115_A0_READ_G_REC_ERR_CNT_EXT_P5r
#define WRITE_G_REC_ERR_CNT_EXT_P5r BCM53115_A0_WRITE_G_REC_ERR_CNT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_REC_ERR_CNT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_REC_NOTOK_CNT
 * BLOCKS:   GPIC0
 * DESC:     Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM53115_A0_G_REC_NOTOK_CNTr 0x00001028

#define BCM53115_A0_G_REC_NOTOK_CNTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT.
 *
 */
typedef union BCM53115_A0_G_REC_NOTOK_CNTr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt[1];
	uint32_t _g_rec_notok_cnt;
} BCM53115_A0_G_REC_NOTOK_CNTr_t;

#define BCM53115_A0_G_REC_NOTOK_CNTr_CLR(r) (r).g_rec_notok_cnt[0] = 0
#define BCM53115_A0_G_REC_NOTOK_CNTr_SET(r,d) (r).g_rec_notok_cnt[0] = d
#define BCM53115_A0_G_REC_NOTOK_CNTr_GET(r) (r).g_rec_notok_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt[0]) & 0xff)
#define BCM53115_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt[0]=(((r).g_rec_notok_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt[0]) >> 8) & 0xff)
#define BCM53115_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt[0]=(((r).g_rec_notok_cnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT.
 *
 */
#define BCM53115_A0_READ_G_REC_NOTOK_CNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_REC_NOTOK_CNTr,(r._g_rec_notok_cnt),2)
#define BCM53115_A0_WRITE_G_REC_NOTOK_CNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_REC_NOTOK_CNTr,&(r._g_rec_notok_cnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNTr BCM53115_A0_G_REC_NOTOK_CNTr
#define G_REC_NOTOK_CNTr_SIZE BCM53115_A0_G_REC_NOTOK_CNTr_SIZE
typedef BCM53115_A0_G_REC_NOTOK_CNTr_t G_REC_NOTOK_CNTr_t;
#define G_REC_NOTOK_CNTr_CLR BCM53115_A0_G_REC_NOTOK_CNTr_CLR
#define G_REC_NOTOK_CNTr_SET BCM53115_A0_G_REC_NOTOK_CNTr_SET
#define G_REC_NOTOK_CNTr_GET BCM53115_A0_G_REC_NOTOK_CNTr_GET
#define G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET BCM53115_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET BCM53115_A0_G_REC_NOTOK_CNTr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET BCM53115_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET BCM53115_A0_G_REC_NOTOK_CNTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNTr BCM53115_A0_READ_G_REC_NOTOK_CNTr
#define WRITE_G_REC_NOTOK_CNTr BCM53115_A0_WRITE_G_REC_NOTOK_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_REC_NOTOK_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT
 * BLOCKS:   CPIC
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr 0x00008828

#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT.
 *
 */
typedef union BCM53115_A0_G_REC_NOTOK_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext[1];
	uint32_t _g_rec_notok_cnt_ext;
} BCM53115_A0_G_REC_NOTOK_CNT_EXTr_t;

#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr_CLR(r) (r).g_rec_notok_cnt_ext[0] = 0
#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr_SET(r,d) (r).g_rec_notok_cnt_ext[0] = d
#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr_GET(r) (r).g_rec_notok_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext[0]) & 0xff)
#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext[0]=(((r).g_rec_notok_cnt_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext[0]) >> 8) & 0xff)
#define BCM53115_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext[0]=(((r).g_rec_notok_cnt_ext[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT.
 *
 */
#define BCM53115_A0_READ_G_REC_NOTOK_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_REC_NOTOK_CNT_EXTr,(r._g_rec_notok_cnt_ext),2)
#define BCM53115_A0_WRITE_G_REC_NOTOK_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_REC_NOTOK_CNT_EXTr,&(r._g_rec_notok_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXTr BCM53115_A0_G_REC_NOTOK_CNT_EXTr
#define G_REC_NOTOK_CNT_EXTr_SIZE BCM53115_A0_G_REC_NOTOK_CNT_EXTr_SIZE
typedef BCM53115_A0_G_REC_NOTOK_CNT_EXTr_t G_REC_NOTOK_CNT_EXTr_t;
#define G_REC_NOTOK_CNT_EXTr_CLR BCM53115_A0_G_REC_NOTOK_CNT_EXTr_CLR
#define G_REC_NOTOK_CNT_EXTr_SET BCM53115_A0_G_REC_NOTOK_CNT_EXTr_SET
#define G_REC_NOTOK_CNT_EXTr_GET BCM53115_A0_G_REC_NOTOK_CNT_EXTr_GET
#define G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET BCM53115_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET BCM53115_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET BCM53115_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET BCM53115_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXTr BCM53115_A0_READ_G_REC_NOTOK_CNT_EXTr
#define WRITE_G_REC_NOTOK_CNT_EXTr BCM53115_A0_WRITE_G_REC_NOTOK_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_REC_NOTOK_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r 0x00008528

#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext_p5[1];
	uint32_t _g_rec_notok_cnt_ext_p5;
} BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_t;

#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_CLR(r) (r).g_rec_notok_cnt_ext_p5[0] = 0
#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_SET(r,d) (r).g_rec_notok_cnt_ext_p5[0] = d
#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_GET(r) (r).g_rec_notok_cnt_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext_p5[0]) & 0xff)
#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_p5[0]=(((r).g_rec_notok_cnt_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext_p5[0]) >> 8) & 0xff)
#define BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext_p5[0]=(((r).g_rec_notok_cnt_ext_p5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_REC_NOTOK_CNT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r,(r._g_rec_notok_cnt_ext_p5),2)
#define BCM53115_A0_WRITE_G_REC_NOTOK_CNT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r,&(r._g_rec_notok_cnt_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXT_P5r BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r
#define G_REC_NOTOK_CNT_EXT_P5r_SIZE BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_SIZE
typedef BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_t G_REC_NOTOK_CNT_EXT_P5r_t;
#define G_REC_NOTOK_CNT_EXT_P5r_CLR BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_CLR
#define G_REC_NOTOK_CNT_EXT_P5r_SET BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_SET
#define G_REC_NOTOK_CNT_EXT_P5r_GET BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_GET
#define G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_GET BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_SET BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_GET BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_SET BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXT_P5r BCM53115_A0_READ_G_REC_NOTOK_CNT_EXT_P5r
#define WRITE_G_REC_NOTOK_CNT_EXT_P5r BCM53115_A0_WRITE_G_REC_NOTOK_CNT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_REC_NOTOK_CNT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_TEST1
 * BLOCKS:   GPIC0
 * DESC:     Test Register 1
 * SIZE:     16
 * FIELDS:
 *     TEST_R           
 *
 ******************************************************************************/
#define BCM53115_A0_G_TEST1r 0x0000103c

#define BCM53115_A0_G_TEST1r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1.
 *
 */
typedef union BCM53115_A0_G_TEST1r_s {
	uint32_t v[1];
	uint32_t g_test1[1];
	uint32_t _g_test1;
} BCM53115_A0_G_TEST1r_t;

#define BCM53115_A0_G_TEST1r_CLR(r) (r).g_test1[0] = 0
#define BCM53115_A0_G_TEST1r_SET(r,d) (r).g_test1[0] = d
#define BCM53115_A0_G_TEST1r_GET(r) (r).g_test1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_TEST1r_TEST_Rf_GET(r) (((r).g_test1[0]) & 0xffff)
#define BCM53115_A0_G_TEST1r_TEST_Rf_SET(r,f) (r).g_test1[0]=(((r).g_test1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST1.
 *
 */
#define BCM53115_A0_READ_G_TEST1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_TEST1r,(r._g_test1),2)
#define BCM53115_A0_WRITE_G_TEST1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_TEST1r,&(r._g_test1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1r BCM53115_A0_G_TEST1r
#define G_TEST1r_SIZE BCM53115_A0_G_TEST1r_SIZE
typedef BCM53115_A0_G_TEST1r_t G_TEST1r_t;
#define G_TEST1r_CLR BCM53115_A0_G_TEST1r_CLR
#define G_TEST1r_SET BCM53115_A0_G_TEST1r_SET
#define G_TEST1r_GET BCM53115_A0_G_TEST1r_GET
#define G_TEST1r_TEST_Rf_GET BCM53115_A0_G_TEST1r_TEST_Rf_GET
#define G_TEST1r_TEST_Rf_SET BCM53115_A0_G_TEST1r_TEST_Rf_SET
#define READ_G_TEST1r BCM53115_A0_READ_G_TEST1r
#define WRITE_G_TEST1r BCM53115_A0_WRITE_G_TEST1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_TEST1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_TEST1_EXT
 * BLOCKS:   CPIC
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     TEST_R           
 *
 ******************************************************************************/
#define BCM53115_A0_G_TEST1_EXTr 0x0000883c

#define BCM53115_A0_G_TEST1_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT.
 *
 */
typedef union BCM53115_A0_G_TEST1_EXTr_s {
	uint32_t v[1];
	uint32_t g_test1_ext[1];
	uint32_t _g_test1_ext;
} BCM53115_A0_G_TEST1_EXTr_t;

#define BCM53115_A0_G_TEST1_EXTr_CLR(r) (r).g_test1_ext[0] = 0
#define BCM53115_A0_G_TEST1_EXTr_SET(r,d) (r).g_test1_ext[0] = d
#define BCM53115_A0_G_TEST1_EXTr_GET(r) (r).g_test1_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_TEST1_EXTr_TEST_Rf_GET(r) (((r).g_test1_ext[0]) & 0xffff)
#define BCM53115_A0_G_TEST1_EXTr_TEST_Rf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST1_EXT.
 *
 */
#define BCM53115_A0_READ_G_TEST1_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_TEST1_EXTr,(r._g_test1_ext),2)
#define BCM53115_A0_WRITE_G_TEST1_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_TEST1_EXTr,&(r._g_test1_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXTr BCM53115_A0_G_TEST1_EXTr
#define G_TEST1_EXTr_SIZE BCM53115_A0_G_TEST1_EXTr_SIZE
typedef BCM53115_A0_G_TEST1_EXTr_t G_TEST1_EXTr_t;
#define G_TEST1_EXTr_CLR BCM53115_A0_G_TEST1_EXTr_CLR
#define G_TEST1_EXTr_SET BCM53115_A0_G_TEST1_EXTr_SET
#define G_TEST1_EXTr_GET BCM53115_A0_G_TEST1_EXTr_GET
#define G_TEST1_EXTr_TEST_Rf_GET BCM53115_A0_G_TEST1_EXTr_TEST_Rf_GET
#define G_TEST1_EXTr_TEST_Rf_SET BCM53115_A0_G_TEST1_EXTr_TEST_Rf_SET
#define READ_G_TEST1_EXTr BCM53115_A0_READ_G_TEST1_EXTr
#define WRITE_G_TEST1_EXTr BCM53115_A0_WRITE_G_TEST1_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_TEST1_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_TEST1_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     TEST_R           
 *
 ******************************************************************************/
#define BCM53115_A0_G_TEST1_EXT_P5r 0x0000853c

#define BCM53115_A0_G_TEST1_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_TEST1_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_test1_ext_p5[1];
	uint32_t _g_test1_ext_p5;
} BCM53115_A0_G_TEST1_EXT_P5r_t;

#define BCM53115_A0_G_TEST1_EXT_P5r_CLR(r) (r).g_test1_ext_p5[0] = 0
#define BCM53115_A0_G_TEST1_EXT_P5r_SET(r,d) (r).g_test1_ext_p5[0] = d
#define BCM53115_A0_G_TEST1_EXT_P5r_GET(r) (r).g_test1_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_TEST1_EXT_P5r_TEST_Rf_GET(r) (((r).g_test1_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_TEST1_EXT_P5r_TEST_Rf_SET(r,f) (r).g_test1_ext_p5[0]=(((r).g_test1_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST1_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_TEST1_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_TEST1_EXT_P5r,(r._g_test1_ext_p5),2)
#define BCM53115_A0_WRITE_G_TEST1_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_TEST1_EXT_P5r,&(r._g_test1_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXT_P5r BCM53115_A0_G_TEST1_EXT_P5r
#define G_TEST1_EXT_P5r_SIZE BCM53115_A0_G_TEST1_EXT_P5r_SIZE
typedef BCM53115_A0_G_TEST1_EXT_P5r_t G_TEST1_EXT_P5r_t;
#define G_TEST1_EXT_P5r_CLR BCM53115_A0_G_TEST1_EXT_P5r_CLR
#define G_TEST1_EXT_P5r_SET BCM53115_A0_G_TEST1_EXT_P5r_SET
#define G_TEST1_EXT_P5r_GET BCM53115_A0_G_TEST1_EXT_P5r_GET
#define G_TEST1_EXT_P5r_TEST_Rf_GET BCM53115_A0_G_TEST1_EXT_P5r_TEST_Rf_GET
#define G_TEST1_EXT_P5r_TEST_Rf_SET BCM53115_A0_G_TEST1_EXT_P5r_TEST_Rf_SET
#define READ_G_TEST1_EXT_P5r BCM53115_A0_READ_G_TEST1_EXT_P5r
#define WRITE_G_TEST1_EXT_P5r BCM53115_A0_WRITE_G_TEST1_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_TEST1_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_TEST2
 * BLOCKS:   GPIC0
 * DESC:     Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST_R           
 *
 ******************************************************************************/
#define BCM53115_A0_G_TEST2r 0x0000103e

#define BCM53115_A0_G_TEST2r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2.
 *
 */
typedef union BCM53115_A0_G_TEST2r_s {
	uint32_t v[1];
	uint32_t g_test2[1];
	uint32_t _g_test2;
} BCM53115_A0_G_TEST2r_t;

#define BCM53115_A0_G_TEST2r_CLR(r) (r).g_test2[0] = 0
#define BCM53115_A0_G_TEST2r_SET(r,d) (r).g_test2[0] = d
#define BCM53115_A0_G_TEST2r_GET(r) (r).g_test2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_TEST2r_TEST_Rf_GET(r) (((r).g_test2[0]) & 0xffff)
#define BCM53115_A0_G_TEST2r_TEST_Rf_SET(r,f) (r).g_test2[0]=(((r).g_test2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2.
 *
 */
#define BCM53115_A0_READ_G_TEST2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_G_TEST2r,(r._g_test2),2)
#define BCM53115_A0_WRITE_G_TEST2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_G_TEST2r,&(r._g_test2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2r BCM53115_A0_G_TEST2r
#define G_TEST2r_SIZE BCM53115_A0_G_TEST2r_SIZE
typedef BCM53115_A0_G_TEST2r_t G_TEST2r_t;
#define G_TEST2r_CLR BCM53115_A0_G_TEST2r_CLR
#define G_TEST2r_SET BCM53115_A0_G_TEST2r_SET
#define G_TEST2r_GET BCM53115_A0_G_TEST2r_GET
#define G_TEST2r_TEST_Rf_GET BCM53115_A0_G_TEST2r_TEST_Rf_GET
#define G_TEST2r_TEST_Rf_SET BCM53115_A0_G_TEST2r_TEST_Rf_SET
#define READ_G_TEST2r BCM53115_A0_READ_G_TEST2r
#define WRITE_G_TEST2r BCM53115_A0_WRITE_G_TEST2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_TEST2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_TEST2_EXT
 * BLOCKS:   CPIC
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST_R           
 *
 ******************************************************************************/
#define BCM53115_A0_G_TEST2_EXTr 0x0000883e

#define BCM53115_A0_G_TEST2_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT.
 *
 */
typedef union BCM53115_A0_G_TEST2_EXTr_s {
	uint32_t v[1];
	uint32_t g_test2_ext[1];
	uint32_t _g_test2_ext;
} BCM53115_A0_G_TEST2_EXTr_t;

#define BCM53115_A0_G_TEST2_EXTr_CLR(r) (r).g_test2_ext[0] = 0
#define BCM53115_A0_G_TEST2_EXTr_SET(r,d) (r).g_test2_ext[0] = d
#define BCM53115_A0_G_TEST2_EXTr_GET(r) (r).g_test2_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_TEST2_EXTr_TEST_Rf_GET(r) (((r).g_test2_ext[0]) & 0xffff)
#define BCM53115_A0_G_TEST2_EXTr_TEST_Rf_SET(r,f) (r).g_test2_ext[0]=(((r).g_test2_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT.
 *
 */
#define BCM53115_A0_READ_G_TEST2_EXTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_TEST2_EXTr,(r._g_test2_ext),2)
#define BCM53115_A0_WRITE_G_TEST2_EXTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_TEST2_EXTr,&(r._g_test2_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXTr BCM53115_A0_G_TEST2_EXTr
#define G_TEST2_EXTr_SIZE BCM53115_A0_G_TEST2_EXTr_SIZE
typedef BCM53115_A0_G_TEST2_EXTr_t G_TEST2_EXTr_t;
#define G_TEST2_EXTr_CLR BCM53115_A0_G_TEST2_EXTr_CLR
#define G_TEST2_EXTr_SET BCM53115_A0_G_TEST2_EXTr_SET
#define G_TEST2_EXTr_GET BCM53115_A0_G_TEST2_EXTr_GET
#define G_TEST2_EXTr_TEST_Rf_GET BCM53115_A0_G_TEST2_EXTr_TEST_Rf_GET
#define G_TEST2_EXTr_TEST_Rf_SET BCM53115_A0_G_TEST2_EXTr_TEST_Rf_SET
#define READ_G_TEST2_EXTr BCM53115_A0_READ_G_TEST2_EXTr
#define WRITE_G_TEST2_EXTr BCM53115_A0_WRITE_G_TEST2_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_TEST2_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  G_TEST2_EXT_P5
 * BLOCKS:   SYS
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST_R           
 *
 ******************************************************************************/
#define BCM53115_A0_G_TEST2_EXT_P5r 0x0000853e

#define BCM53115_A0_G_TEST2_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT_P5.
 *
 */
typedef union BCM53115_A0_G_TEST2_EXT_P5r_s {
	uint32_t v[1];
	uint32_t g_test2_ext_p5[1];
	uint32_t _g_test2_ext_p5;
} BCM53115_A0_G_TEST2_EXT_P5r_t;

#define BCM53115_A0_G_TEST2_EXT_P5r_CLR(r) (r).g_test2_ext_p5[0] = 0
#define BCM53115_A0_G_TEST2_EXT_P5r_SET(r,d) (r).g_test2_ext_p5[0] = d
#define BCM53115_A0_G_TEST2_EXT_P5r_GET(r) (r).g_test2_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_G_TEST2_EXT_P5r_TEST_Rf_GET(r) (((r).g_test2_ext_p5[0]) & 0xffff)
#define BCM53115_A0_G_TEST2_EXT_P5r_TEST_Rf_SET(r,f) (r).g_test2_ext_p5[0]=(((r).g_test2_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT_P5.
 *
 */
#define BCM53115_A0_READ_G_TEST2_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_G_TEST2_EXT_P5r,(r._g_test2_ext_p5),2)
#define BCM53115_A0_WRITE_G_TEST2_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_G_TEST2_EXT_P5r,&(r._g_test2_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXT_P5r BCM53115_A0_G_TEST2_EXT_P5r
#define G_TEST2_EXT_P5r_SIZE BCM53115_A0_G_TEST2_EXT_P5r_SIZE
typedef BCM53115_A0_G_TEST2_EXT_P5r_t G_TEST2_EXT_P5r_t;
#define G_TEST2_EXT_P5r_CLR BCM53115_A0_G_TEST2_EXT_P5r_CLR
#define G_TEST2_EXT_P5r_SET BCM53115_A0_G_TEST2_EXT_P5r_SET
#define G_TEST2_EXT_P5r_GET BCM53115_A0_G_TEST2_EXT_P5r_GET
#define G_TEST2_EXT_P5r_TEST_Rf_GET BCM53115_A0_G_TEST2_EXT_P5r_TEST_Rf_GET
#define G_TEST2_EXT_P5r_TEST_Rf_SET BCM53115_A0_G_TEST2_EXT_P5r_TEST_Rf_SET
#define READ_G_TEST2_EXT_P5r BCM53115_A0_READ_G_TEST2_EXT_P5r
#define WRITE_G_TEST2_EXT_P5r BCM53115_A0_WRITE_G_TEST2_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_G_TEST2_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  HL_PRTC_CTRL
 * BLOCKS:   SYS
 * DESC:     High Level Protocol Control Register
 * SIZE:     32
 * FIELDS:
 *     ARP_EN           ARP Snooping Enable1: ARP frames will be forwarded by L2 result and also copied to CPU.0: ARP frames will be forwarded by L2 result .
 *     RARP_EN          RARP Snooping Enable1: RARP frames will be forwarded by L2 result and also copied to CPU.0: RARP frames will be forwarded by L2 result .
 *     DHCP_EN          DHCP Snooping Enable1: DHCP frames will be forwarded by L2 result and also copied to CPU.0: DHCP frames will be forwarded by L2 result.
 *     ICMPV4_EN        ICMPv4 Snooping Enable1: ICMPv4 frames will be forwarded by L2 result and also copied to CPU.0: ICMPv4 frames will be forwarded by L2 result.
 *     ICMPV6_EN        
 *     ICMPV6_FWD_MODE  
 *     RESERVED_R       Reserved
 *     IGMP_DIP_EN      IGMP L3 DIP Checking EnableIn addition to the IP datagram with a protocol value of 2, IGMP will be classified by matching its DIP with the Class D IP address (224.0.0.0 ~ 239.255.255.255).
 *     IGMP_RPTLVE_EN   
 *     IGMP_RPTLVE_FWD_MODE 
 *     IGMP_QRY_EN      
 *     IGMP_QRY_FWD_MODE 
 *     IGMP_UKN_EN      
 *     IGMP_UKN_FWD_MODE 
 *     MLD_RPTDONE_EN   
 *     MLD_RPTDONE_FWD_MODE 
 *     MLD_QRY_EN       
 *     MLD_QRY_FWD_MODE 
 *
 ******************************************************************************/
#define BCM53115_A0_HL_PRTC_CTRLr 0x00000250

#define BCM53115_A0_HL_PRTC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program HL_PRTC_CTRL.
 *
 */
typedef union BCM53115_A0_HL_PRTC_CTRLr_s {
	uint32_t v[1];
	uint32_t hl_prtc_ctrl[1];
	uint32_t _hl_prtc_ctrl;
} BCM53115_A0_HL_PRTC_CTRLr_t;

#define BCM53115_A0_HL_PRTC_CTRLr_CLR(r) (r).hl_prtc_ctrl[0] = 0
#define BCM53115_A0_HL_PRTC_CTRLr_SET(r,d) (r).hl_prtc_ctrl[0] = d
#define BCM53115_A0_HL_PRTC_CTRLr_GET(r) (r).hl_prtc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_HL_PRTC_CTRLr_ARP_ENf_GET(r) (((r).hl_prtc_ctrl[0]) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_ARP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_HL_PRTC_CTRLr_RARP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_RARP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_HL_PRTC_CTRLr_DHCP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_DHCP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_HL_PRTC_CTRLr_ICMPV4_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 3) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_ICMPV4_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_HL_PRTC_CTRLr_ICMPV6_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 4) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_ICMPV6_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 5) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_HL_PRTC_CTRLr_RESERVED_Rf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 6) & 0x3)
#define BCM53115_A0_HL_PRTC_CTRLr_RESERVED_Rf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 8) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 9) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 10) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 11) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 12) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 13) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 14) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 15) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 16) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 17) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53115_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 18) & 0x1)
#define BCM53115_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access HL_PRTC_CTRL.
 *
 */
#define BCM53115_A0_READ_HL_PRTC_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_HL_PRTC_CTRLr,(r._hl_prtc_ctrl),4)
#define BCM53115_A0_WRITE_HL_PRTC_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_HL_PRTC_CTRLr,&(r._hl_prtc_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HL_PRTC_CTRLr BCM53115_A0_HL_PRTC_CTRLr
#define HL_PRTC_CTRLr_SIZE BCM53115_A0_HL_PRTC_CTRLr_SIZE
typedef BCM53115_A0_HL_PRTC_CTRLr_t HL_PRTC_CTRLr_t;
#define HL_PRTC_CTRLr_CLR BCM53115_A0_HL_PRTC_CTRLr_CLR
#define HL_PRTC_CTRLr_SET BCM53115_A0_HL_PRTC_CTRLr_SET
#define HL_PRTC_CTRLr_GET BCM53115_A0_HL_PRTC_CTRLr_GET
#define HL_PRTC_CTRLr_ARP_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_ARP_ENf_GET
#define HL_PRTC_CTRLr_ARP_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_ARP_ENf_SET
#define HL_PRTC_CTRLr_RARP_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_RARP_ENf_GET
#define HL_PRTC_CTRLr_RARP_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_RARP_ENf_SET
#define HL_PRTC_CTRLr_DHCP_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_DHCP_ENf_GET
#define HL_PRTC_CTRLr_DHCP_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_DHCP_ENf_SET
#define HL_PRTC_CTRLr_ICMPV4_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_ICMPV4_ENf_GET
#define HL_PRTC_CTRLr_ICMPV4_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_ICMPV4_ENf_SET
#define HL_PRTC_CTRLr_ICMPV6_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_ICMPV6_ENf_GET
#define HL_PRTC_CTRLr_ICMPV6_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_ICMPV6_ENf_SET
#define HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET BCM53115_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET
#define HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET BCM53115_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET
#define HL_PRTC_CTRLr_RESERVED_Rf_GET BCM53115_A0_HL_PRTC_CTRLr_RESERVED_Rf_GET
#define HL_PRTC_CTRLr_RESERVED_Rf_SET BCM53115_A0_HL_PRTC_CTRLr_RESERVED_Rf_SET
#define HL_PRTC_CTRLr_IGMP_DIP_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_GET
#define HL_PRTC_CTRLr_IGMP_DIP_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_SET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET BCM53115_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET BCM53115_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET
#define HL_PRTC_CTRLr_IGMP_QRY_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_GET
#define HL_PRTC_CTRLr_IGMP_QRY_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_SET
#define HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET BCM53115_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET BCM53115_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET
#define HL_PRTC_CTRLr_IGMP_UKN_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_GET
#define HL_PRTC_CTRLr_IGMP_UKN_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_SET
#define HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET BCM53115_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET BCM53115_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET
#define HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET
#define HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET
#define HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET BCM53115_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET
#define HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET BCM53115_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET
#define HL_PRTC_CTRLr_MLD_QRY_ENf_GET BCM53115_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_GET
#define HL_PRTC_CTRLr_MLD_QRY_ENf_SET BCM53115_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_SET
#define HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET BCM53115_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET
#define HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET BCM53115_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET
#define READ_HL_PRTC_CTRLr BCM53115_A0_READ_HL_PRTC_CTRLr
#define WRITE_HL_PRTC_CTRLr BCM53115_A0_WRITE_HL_PRTC_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_HL_PRTC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_MSK       Ingress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to theMIRROR_CAPTURE_PORT.Bits 0-5 = Port 0-5Bit 8= IMP.
 *     RESERVED_R       Reserved
 *     IN_DIV_EN        Ingress Divider Enable.Mirror every nth received frame (n=IN_MIRROR_DIV) that has passed through the IN_MIRROR_FILTER.
 *     IN_MIR_FLTR      Ingress Mirror Filter.Defines the conditions under which frames received on a port that has been selected in the IN_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all ingress frames.01: Mirror all received frames with DA = IN_MIRROR_MAC.10: Mirror all received frames with SA = IN_MIRROR_MAC.11: Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_IGMIRCTLr 0x00000212

#define BCM53115_A0_IGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRCTL.
 *
 */
typedef union BCM53115_A0_IGMIRCTLr_s {
	uint32_t v[1];
	uint32_t igmirctl[1];
	uint32_t _igmirctl;
} BCM53115_A0_IGMIRCTLr_t;

#define BCM53115_A0_IGMIRCTLr_CLR(r) (r).igmirctl[0] = 0
#define BCM53115_A0_IGMIRCTLr_SET(r,d) (r).igmirctl[0] = d
#define BCM53115_A0_IGMIRCTLr_GET(r) (r).igmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IGMIRCTLr_IN_MIR_MSKf_GET(r) (((r).igmirctl[0]) & 0x1ff)
#define BCM53115_A0_IGMIRCTLr_IN_MIR_MSKf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_IGMIRCTLr_RESERVED_Rf_GET(r) ((((r).igmirctl[0]) >> 9) & 0xf)
#define BCM53115_A0_IGMIRCTLr_RESERVED_Rf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53115_A0_IGMIRCTLr_IN_DIV_ENf_GET(r) ((((r).igmirctl[0]) >> 13) & 0x1)
#define BCM53115_A0_IGMIRCTLr_IN_DIV_ENf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_IGMIRCTLr_IN_MIR_FLTRf_GET(r) ((((r).igmirctl[0]) >> 14) & 0x3)
#define BCM53115_A0_IGMIRCTLr_IN_MIR_FLTRf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IGMIRCTL.
 *
 */
#define BCM53115_A0_READ_IGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IGMIRCTLr,(r._igmirctl),2)
#define BCM53115_A0_WRITE_IGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IGMIRCTLr,&(r._igmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRCTLr BCM53115_A0_IGMIRCTLr
#define IGMIRCTLr_SIZE BCM53115_A0_IGMIRCTLr_SIZE
typedef BCM53115_A0_IGMIRCTLr_t IGMIRCTLr_t;
#define IGMIRCTLr_CLR BCM53115_A0_IGMIRCTLr_CLR
#define IGMIRCTLr_SET BCM53115_A0_IGMIRCTLr_SET
#define IGMIRCTLr_GET BCM53115_A0_IGMIRCTLr_GET
#define IGMIRCTLr_IN_MIR_MSKf_GET BCM53115_A0_IGMIRCTLr_IN_MIR_MSKf_GET
#define IGMIRCTLr_IN_MIR_MSKf_SET BCM53115_A0_IGMIRCTLr_IN_MIR_MSKf_SET
#define IGMIRCTLr_RESERVED_Rf_GET BCM53115_A0_IGMIRCTLr_RESERVED_Rf_GET
#define IGMIRCTLr_RESERVED_Rf_SET BCM53115_A0_IGMIRCTLr_RESERVED_Rf_SET
#define IGMIRCTLr_IN_DIV_ENf_GET BCM53115_A0_IGMIRCTLr_IN_DIV_ENf_GET
#define IGMIRCTLr_IN_DIV_ENf_SET BCM53115_A0_IGMIRCTLr_IN_DIV_ENf_SET
#define IGMIRCTLr_IN_MIR_FLTRf_GET BCM53115_A0_IGMIRCTLr_IN_MIR_FLTRf_GET
#define IGMIRCTLr_IN_MIR_FLTRf_SET BCM53115_A0_IGMIRCTLr_IN_MIR_FLTRf_SET
#define READ_IGMIRCTLr BCM53115_A0_READ_IGMIRCTLr
#define WRITE_IGMIRCTLr BCM53115_A0_WRITE_IGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_DIV       Ingress Mirror Divider.Receive frames that have passed the IN_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the IN_DIV_EN bit in the Ingress Mirror Control register is set, frames that pass the IN_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = IN_MIRROR_DIV) will be mirrored.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_IGMIRDIVr 0x00000214

#define BCM53115_A0_IGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRDIV.
 *
 */
typedef union BCM53115_A0_IGMIRDIVr_s {
	uint32_t v[1];
	uint32_t igmirdiv[1];
	uint32_t _igmirdiv;
} BCM53115_A0_IGMIRDIVr_t;

#define BCM53115_A0_IGMIRDIVr_CLR(r) (r).igmirdiv[0] = 0
#define BCM53115_A0_IGMIRDIVr_SET(r,d) (r).igmirdiv[0] = d
#define BCM53115_A0_IGMIRDIVr_GET(r) (r).igmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IGMIRDIVr_IN_MIR_DIVf_GET(r) (((r).igmirdiv[0]) & 0x3ff)
#define BCM53115_A0_IGMIRDIVr_IN_MIR_DIVf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53115_A0_IGMIRDIVr_RESERVED_Rf_GET(r) ((((r).igmirdiv[0]) >> 10) & 0x3f)
#define BCM53115_A0_IGMIRDIVr_RESERVED_Rf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access IGMIRDIV.
 *
 */
#define BCM53115_A0_READ_IGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IGMIRDIVr,(r._igmirdiv),2)
#define BCM53115_A0_WRITE_IGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IGMIRDIVr,&(r._igmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRDIVr BCM53115_A0_IGMIRDIVr
#define IGMIRDIVr_SIZE BCM53115_A0_IGMIRDIVr_SIZE
typedef BCM53115_A0_IGMIRDIVr_t IGMIRDIVr_t;
#define IGMIRDIVr_CLR BCM53115_A0_IGMIRDIVr_CLR
#define IGMIRDIVr_SET BCM53115_A0_IGMIRDIVr_SET
#define IGMIRDIVr_GET BCM53115_A0_IGMIRDIVr_GET
#define IGMIRDIVr_IN_MIR_DIVf_GET BCM53115_A0_IGMIRDIVr_IN_MIR_DIVf_GET
#define IGMIRDIVr_IN_MIR_DIVf_SET BCM53115_A0_IGMIRDIVr_IN_MIR_DIVf_SET
#define IGMIRDIVr_RESERVED_Rf_GET BCM53115_A0_IGMIRDIVr_RESERVED_Rf_GET
#define IGMIRDIVr_RESERVED_Rf_SET BCM53115_A0_IGMIRDIVr_RESERVED_Rf_SET
#define READ_IGMIRDIVr BCM53115_A0_READ_IGMIRDIVr
#define WRITE_IGMIRDIVr BCM53115_A0_WRITE_IGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Mac Address Register
 * SIZE:     48
 * FIELDS:
 *     IN_MIR_MAC       
 *
 ******************************************************************************/
#define BCM53115_A0_IGMIRMACr 0x00000216

#define BCM53115_A0_IGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program IGMIRMAC.
 *
 */
typedef union BCM53115_A0_IGMIRMACr_s {
	uint32_t v[2];
	uint32_t igmirmac[2];
	uint32_t _igmirmac;
} BCM53115_A0_IGMIRMACr_t;

#define BCM53115_A0_IGMIRMACr_CLR(r) CDK_MEMSET(&((r)._igmirmac), 0, sizeof(BCM53115_A0_IGMIRMACr_t))
#define BCM53115_A0_IGMIRMACr_SET(r,i,d) (r).igmirmac[i] = d
#define BCM53115_A0_IGMIRMACr_GET(r,i) (r).igmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IGMIRMACr_IN_MIR_MACf_GET(r,a) cdk_field_get((r).igmirmac,0,47,a)
#define BCM53115_A0_IGMIRMACr_IN_MIR_MACf_SET(r,a) cdk_field_set((r).igmirmac,0,47,a)

/*
 * These macros can be used to access IGMIRMAC.
 *
 */
#define BCM53115_A0_READ_IGMIRMACr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IGMIRMACr,(r._igmirmac),6)
#define BCM53115_A0_WRITE_IGMIRMACr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IGMIRMACr,&(r._igmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRMACr BCM53115_A0_IGMIRMACr
#define IGMIRMACr_SIZE BCM53115_A0_IGMIRMACr_SIZE
typedef BCM53115_A0_IGMIRMACr_t IGMIRMACr_t;
#define IGMIRMACr_CLR BCM53115_A0_IGMIRMACr_CLR
#define IGMIRMACr_SET BCM53115_A0_IGMIRMACr_SET
#define IGMIRMACr_GET BCM53115_A0_IGMIRMACr_GET
#define IGMIRMACr_IN_MIR_MACf_GET BCM53115_A0_IGMIRMACr_IN_MIR_MACf_GET
#define IGMIRMACr_IN_MIR_MACf_SET BCM53115_A0_IGMIRMACr_IN_MIR_MACf_SET
#define READ_IGMIRMACr BCM53115_A0_READ_IGMIRMACr
#define WRITE_IGMIRMACr BCM53115_A0_WRITE_IGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IMP0_PRT_ID
 * BLOCKS:   SYS
 * DESC:     IMP/IMP0 Port ID Register
 * SIZE:     8
 * FIELDS:
 *     IMP0_PRT_ID      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_IMP0_PRT_IDr 0x00000201

#define BCM53115_A0_IMP0_PRT_IDr_SIZE 1

/*
 * This structure should be used to declare and program IMP0_PRT_ID.
 *
 */
typedef union BCM53115_A0_IMP0_PRT_IDr_s {
	uint32_t v[1];
	uint32_t imp0_prt_id[1];
	uint32_t _imp0_prt_id;
} BCM53115_A0_IMP0_PRT_IDr_t;

#define BCM53115_A0_IMP0_PRT_IDr_CLR(r) (r).imp0_prt_id[0] = 0
#define BCM53115_A0_IMP0_PRT_IDr_SET(r,d) (r).imp0_prt_id[0] = d
#define BCM53115_A0_IMP0_PRT_IDr_GET(r) (r).imp0_prt_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_GET(r) (((r).imp0_prt_id[0]) & 0xf)
#define BCM53115_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_SET(r,f) (r).imp0_prt_id[0]=(((r).imp0_prt_id[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_IMP0_PRT_IDr_RESERVED_Rf_GET(r) ((((r).imp0_prt_id[0]) >> 4) & 0xf)
#define BCM53115_A0_IMP0_PRT_IDr_RESERVED_Rf_SET(r,f) (r).imp0_prt_id[0]=(((r).imp0_prt_id[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP0_PRT_ID.
 *
 */
#define BCM53115_A0_READ_IMP0_PRT_IDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IMP0_PRT_IDr,(r._imp0_prt_id),1)
#define BCM53115_A0_WRITE_IMP0_PRT_IDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IMP0_PRT_IDr,&(r._imp0_prt_id),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP0_PRT_IDr BCM53115_A0_IMP0_PRT_IDr
#define IMP0_PRT_IDr_SIZE BCM53115_A0_IMP0_PRT_IDr_SIZE
typedef BCM53115_A0_IMP0_PRT_IDr_t IMP0_PRT_IDr_t;
#define IMP0_PRT_IDr_CLR BCM53115_A0_IMP0_PRT_IDr_CLR
#define IMP0_PRT_IDr_SET BCM53115_A0_IMP0_PRT_IDr_SET
#define IMP0_PRT_IDr_GET BCM53115_A0_IMP0_PRT_IDr_GET
#define IMP0_PRT_IDr_IMP0_PRT_IDf_GET BCM53115_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_GET
#define IMP0_PRT_IDr_IMP0_PRT_IDf_SET BCM53115_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_SET
#define IMP0_PRT_IDr_RESERVED_Rf_GET BCM53115_A0_IMP0_PRT_IDr_RESERVED_Rf_GET
#define IMP0_PRT_IDr_RESERVED_Rf_SET BCM53115_A0_IMP0_PRT_IDr_RESERVED_Rf_SET
#define READ_IMP0_PRT_IDr BCM53115_A0_READ_IMP0_PRT_IDr
#define WRITE_IMP0_PRT_IDr BCM53115_A0_WRITE_IMP0_PRT_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IMP0_PRT_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IMP1_EGRESS_RATE_CTRL_CFG_REG
 * BLOCKS:   SYS
 * DESC:     IMP1 Egress Rate Control Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     RATE_INDEX       
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr 0x000041c1

#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_SIZE 1

/*
 * This structure should be used to declare and program IMP1_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
typedef union BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_s {
	uint32_t v[1];
	uint32_t imp1_egress_rate_ctrl_cfg_reg[1];
	uint32_t _imp1_egress_rate_ctrl_cfg_reg;
} BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_t;

#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_CLR(r) (r).imp1_egress_rate_ctrl_cfg_reg[0] = 0
#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_SET(r,d) (r).imp1_egress_rate_ctrl_cfg_reg[0] = d
#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_GET(r) (r).imp1_egress_rate_ctrl_cfg_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET(r) (((r).imp1_egress_rate_ctrl_cfg_reg[0]) & 0x3f)
#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET(r,f) (r).imp1_egress_rate_ctrl_cfg_reg[0]=(((r).imp1_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_GET(r) ((((r).imp1_egress_rate_ctrl_cfg_reg[0]) >> 6) & 0x3)
#define BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_SET(r,f) (r).imp1_egress_rate_ctrl_cfg_reg[0]=(((r).imp1_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access IMP1_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
#define BCM53115_A0_READ_IMP1_EGRESS_RATE_CTRL_CFG_REGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr,(r._imp1_egress_rate_ctrl_cfg_reg),1)
#define BCM53115_A0_WRITE_IMP1_EGRESS_RATE_CTRL_CFG_REGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr,&(r._imp1_egress_rate_ctrl_cfg_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP1_EGRESS_RATE_CTRL_CFG_REGr BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_SIZE BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_SIZE
typedef BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_t IMP1_EGRESS_RATE_CTRL_CFG_REGr_t;
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_CLR BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_CLR
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_SET BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_SET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_GET BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_GET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_GET BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_GET
#define IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_SET BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_SET
#define READ_IMP1_EGRESS_RATE_CTRL_CFG_REGr BCM53115_A0_READ_IMP1_EGRESS_RATE_CTRL_CFG_REGr
#define WRITE_IMP1_EGRESS_RATE_CTRL_CFG_REGr BCM53115_A0_WRITE_IMP1_EGRESS_RATE_CTRL_CFG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IMP1_EGRESS_RATE_CTRL_CFG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IMP1_PRT_ID
 * BLOCKS:   SYS
 * DESC:     IMP1 Port ID Register
 * SIZE:     8
 * FIELDS:
 *     IMP1_PRT_ID      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_IMP1_PRT_IDr 0x00000202

#define BCM53115_A0_IMP1_PRT_IDr_SIZE 1

/*
 * This structure should be used to declare and program IMP1_PRT_ID.
 *
 */
typedef union BCM53115_A0_IMP1_PRT_IDr_s {
	uint32_t v[1];
	uint32_t imp1_prt_id[1];
	uint32_t _imp1_prt_id;
} BCM53115_A0_IMP1_PRT_IDr_t;

#define BCM53115_A0_IMP1_PRT_IDr_CLR(r) (r).imp1_prt_id[0] = 0
#define BCM53115_A0_IMP1_PRT_IDr_SET(r,d) (r).imp1_prt_id[0] = d
#define BCM53115_A0_IMP1_PRT_IDr_GET(r) (r).imp1_prt_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_GET(r) (((r).imp1_prt_id[0]) & 0xf)
#define BCM53115_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_SET(r,f) (r).imp1_prt_id[0]=(((r).imp1_prt_id[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_IMP1_PRT_IDr_RESERVED_Rf_GET(r) ((((r).imp1_prt_id[0]) >> 4) & 0xf)
#define BCM53115_A0_IMP1_PRT_IDr_RESERVED_Rf_SET(r,f) (r).imp1_prt_id[0]=(((r).imp1_prt_id[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP1_PRT_ID.
 *
 */
#define BCM53115_A0_READ_IMP1_PRT_IDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IMP1_PRT_IDr,(r._imp1_prt_id),1)
#define BCM53115_A0_WRITE_IMP1_PRT_IDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IMP1_PRT_IDr,&(r._imp1_prt_id),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP1_PRT_IDr BCM53115_A0_IMP1_PRT_IDr
#define IMP1_PRT_IDr_SIZE BCM53115_A0_IMP1_PRT_IDr_SIZE
typedef BCM53115_A0_IMP1_PRT_IDr_t IMP1_PRT_IDr_t;
#define IMP1_PRT_IDr_CLR BCM53115_A0_IMP1_PRT_IDr_CLR
#define IMP1_PRT_IDr_SET BCM53115_A0_IMP1_PRT_IDr_SET
#define IMP1_PRT_IDr_GET BCM53115_A0_IMP1_PRT_IDr_GET
#define IMP1_PRT_IDr_IMP1_PRT_IDf_GET BCM53115_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_GET
#define IMP1_PRT_IDr_IMP1_PRT_IDf_SET BCM53115_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_SET
#define IMP1_PRT_IDr_RESERVED_Rf_GET BCM53115_A0_IMP1_PRT_IDr_RESERVED_Rf_GET
#define IMP1_PRT_IDr_RESERVED_Rf_SET BCM53115_A0_IMP1_PRT_IDr_RESERVED_Rf_SET
#define READ_IMP1_PRT_IDr BCM53115_A0_READ_IMP1_PRT_IDr
#define WRITE_IMP1_PRT_IDr BCM53115_A0_WRITE_IMP1_PRT_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IMP1_PRT_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IMP_CTL
 * BLOCKS:   CPIC
 * DESC:     IMP Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC levelnot release for custom.
 *     TX_DIS           Disables the transmit function of the port at the MAC levelnot release for custom.
 *     RX_BCST_EN       Receive Broadcast Enable.Allow broadcast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RX_MCST_EN       Receive Multicast Enable.Allow multicast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port, and the frame was flodded due to no matching address table entry.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RX_UCST_EN       Receive Unicast Enable.Allow unicast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port, and the frame was flooded due to no matching address table entry.When cleared, unicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_IMP_CTLr 0x00000008

#define BCM53115_A0_IMP_CTLr_SIZE 1

/*
 * This structure should be used to declare and program IMP_CTL.
 *
 */
typedef union BCM53115_A0_IMP_CTLr_s {
	uint32_t v[1];
	uint32_t imp_ctl[1];
	uint32_t _imp_ctl;
} BCM53115_A0_IMP_CTLr_t;

#define BCM53115_A0_IMP_CTLr_CLR(r) (r).imp_ctl[0] = 0
#define BCM53115_A0_IMP_CTLr_SET(r,d) (r).imp_ctl[0] = d
#define BCM53115_A0_IMP_CTLr_GET(r) (r).imp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IMP_CTLr_RX_DISf_GET(r) (((r).imp_ctl[0]) & 0x1)
#define BCM53115_A0_IMP_CTLr_RX_DISf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_IMP_CTLr_TX_DISf_GET(r) ((((r).imp_ctl[0]) >> 1) & 0x1)
#define BCM53115_A0_IMP_CTLr_TX_DISf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_IMP_CTLr_RX_BCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 2) & 0x1)
#define BCM53115_A0_IMP_CTLr_RX_BCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_IMP_CTLr_RX_MCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 3) & 0x1)
#define BCM53115_A0_IMP_CTLr_RX_MCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_IMP_CTLr_RX_UCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 4) & 0x1)
#define BCM53115_A0_IMP_CTLr_RX_UCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_IMP_CTLr_RESERVED_Rf_GET(r) ((((r).imp_ctl[0]) >> 5) & 0x7)
#define BCM53115_A0_IMP_CTLr_RESERVED_Rf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access IMP_CTL.
 *
 */
#define BCM53115_A0_READ_IMP_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IMP_CTLr,(r._imp_ctl),1)
#define BCM53115_A0_WRITE_IMP_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IMP_CTLr,&(r._imp_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_CTLr BCM53115_A0_IMP_CTLr
#define IMP_CTLr_SIZE BCM53115_A0_IMP_CTLr_SIZE
typedef BCM53115_A0_IMP_CTLr_t IMP_CTLr_t;
#define IMP_CTLr_CLR BCM53115_A0_IMP_CTLr_CLR
#define IMP_CTLr_SET BCM53115_A0_IMP_CTLr_SET
#define IMP_CTLr_GET BCM53115_A0_IMP_CTLr_GET
#define IMP_CTLr_RX_DISf_GET BCM53115_A0_IMP_CTLr_RX_DISf_GET
#define IMP_CTLr_RX_DISf_SET BCM53115_A0_IMP_CTLr_RX_DISf_SET
#define IMP_CTLr_TX_DISf_GET BCM53115_A0_IMP_CTLr_TX_DISf_GET
#define IMP_CTLr_TX_DISf_SET BCM53115_A0_IMP_CTLr_TX_DISf_SET
#define IMP_CTLr_RX_BCST_ENf_GET BCM53115_A0_IMP_CTLr_RX_BCST_ENf_GET
#define IMP_CTLr_RX_BCST_ENf_SET BCM53115_A0_IMP_CTLr_RX_BCST_ENf_SET
#define IMP_CTLr_RX_MCST_ENf_GET BCM53115_A0_IMP_CTLr_RX_MCST_ENf_GET
#define IMP_CTLr_RX_MCST_ENf_SET BCM53115_A0_IMP_CTLr_RX_MCST_ENf_SET
#define IMP_CTLr_RX_UCST_ENf_GET BCM53115_A0_IMP_CTLr_RX_UCST_ENf_GET
#define IMP_CTLr_RX_UCST_ENf_SET BCM53115_A0_IMP_CTLr_RX_UCST_ENf_SET
#define IMP_CTLr_RESERVED_Rf_GET BCM53115_A0_IMP_CTLr_RESERVED_Rf_GET
#define IMP_CTLr_RESERVED_Rf_SET BCM53115_A0_IMP_CTLr_RESERVED_Rf_SET
#define READ_IMP_CTLr BCM53115_A0_READ_IMP_CTLr
#define WRITE_IMP_CTLr BCM53115_A0_WRITE_IMP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IMP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IMP_EGRESS_RATE_CTRL_CFG_REG
 * BLOCKS:   SYS
 * DESC:     IMP0 Egress Rate Control Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     RATE_INDEX       
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr 0x000041c0

#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE 1

/*
 * This structure should be used to declare and program IMP_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
typedef union BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_s {
	uint32_t v[1];
	uint32_t imp_egress_rate_ctrl_cfg_reg[1];
	uint32_t _imp_egress_rate_ctrl_cfg_reg;
} BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_t;

#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR(r) (r).imp_egress_rate_ctrl_cfg_reg[0] = 0
#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SET(r,d) (r).imp_egress_rate_ctrl_cfg_reg[0] = d
#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_GET(r) (r).imp_egress_rate_ctrl_cfg_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET(r) (((r).imp_egress_rate_ctrl_cfg_reg[0]) & 0x3f)
#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET(r,f) (r).imp_egress_rate_ctrl_cfg_reg[0]=(((r).imp_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_GET(r) ((((r).imp_egress_rate_ctrl_cfg_reg[0]) >> 6) & 0x3)
#define BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_SET(r,f) (r).imp_egress_rate_ctrl_cfg_reg[0]=(((r).imp_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access IMP_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
#define BCM53115_A0_READ_IMP_EGRESS_RATE_CTRL_CFG_REGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr,(r._imp_egress_rate_ctrl_cfg_reg),1)
#define BCM53115_A0_WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr,&(r._imp_egress_rate_ctrl_cfg_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE
typedef BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_t IMP_EGRESS_RATE_CTRL_CFG_REGr_t;
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_SET BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_GET BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_GET BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_SET BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVED_Rf_SET
#define READ_IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53115_A0_READ_IMP_EGRESS_RATE_CTRL_CFG_REGr
#define WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53115_A0_WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IMP_RGMII_CTL_GP
 * BLOCKS:   CPIC
 * DESC:     IMP RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     TIM_SEL          1: RGMII tx_clk delayed timing mode0: RGMII tx_clk aligned timing modedefault value by strap pin gtx_0_setup.
 *     DLL_RXC_BYPASS   1: clock delay by DLL is enabled0: clock delay by DLL is disabled (Normal Mode)default value by strap pin grx_0_setup.
 *     DLL_IQQD         1: In the IDDQ mode, power is down0: Normal function mode
 *     RESERVED_1R      Reserved
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_IMP_RGMII_CTL_GPr 0x00000060

#define BCM53115_A0_IMP_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program IMP_RGMII_CTL_GP.
 *
 */
typedef union BCM53115_A0_IMP_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t imp_rgmii_ctl_gp[1];
	uint32_t _imp_rgmii_ctl_gp;
} BCM53115_A0_IMP_RGMII_CTL_GPr_t;

#define BCM53115_A0_IMP_RGMII_CTL_GPr_CLR(r) (r).imp_rgmii_ctl_gp[0] = 0
#define BCM53115_A0_IMP_RGMII_CTL_GPr_SET(r,d) (r).imp_rgmii_ctl_gp[0] = d
#define BCM53115_A0_IMP_RGMII_CTL_GPr_GET(r) (r).imp_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IMP_RGMII_CTL_GPr_TIM_SELf_GET(r) (((r).imp_rgmii_ctl_gp[0]) & 0x1)
#define BCM53115_A0_IMP_RGMII_CTL_GPr_TIM_SELf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_IMP_RGMII_CTL_GPr_DLL_RXC_BYPASSf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM53115_A0_IMP_RGMII_CTL_GPr_DLL_RXC_BYPASSf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_IMP_RGMII_CTL_GPr_DLL_IQQDf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM53115_A0_IMP_RGMII_CTL_GPr_DLL_IQQDf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_IMP_RGMII_CTL_GPr_RESERVED_1Rf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 3) & 0x1)
#define BCM53115_A0_IMP_RGMII_CTL_GPr_RESERVED_1Rf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_IMP_RGMII_CTL_GPr_RESERVED_2Rf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 4) & 0xf)
#define BCM53115_A0_IMP_RGMII_CTL_GPr_RESERVED_2Rf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP_RGMII_CTL_GP.
 *
 */
#define BCM53115_A0_READ_IMP_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IMP_RGMII_CTL_GPr,(r._imp_rgmii_ctl_gp),1)
#define BCM53115_A0_WRITE_IMP_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IMP_RGMII_CTL_GPr,&(r._imp_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_RGMII_CTL_GPr BCM53115_A0_IMP_RGMII_CTL_GPr
#define IMP_RGMII_CTL_GPr_SIZE BCM53115_A0_IMP_RGMII_CTL_GPr_SIZE
typedef BCM53115_A0_IMP_RGMII_CTL_GPr_t IMP_RGMII_CTL_GPr_t;
#define IMP_RGMII_CTL_GPr_CLR BCM53115_A0_IMP_RGMII_CTL_GPr_CLR
#define IMP_RGMII_CTL_GPr_SET BCM53115_A0_IMP_RGMII_CTL_GPr_SET
#define IMP_RGMII_CTL_GPr_GET BCM53115_A0_IMP_RGMII_CTL_GPr_GET
#define IMP_RGMII_CTL_GPr_TIM_SELf_GET BCM53115_A0_IMP_RGMII_CTL_GPr_TIM_SELf_GET
#define IMP_RGMII_CTL_GPr_TIM_SELf_SET BCM53115_A0_IMP_RGMII_CTL_GPr_TIM_SELf_SET
#define IMP_RGMII_CTL_GPr_DLL_RXC_BYPASSf_GET BCM53115_A0_IMP_RGMII_CTL_GPr_DLL_RXC_BYPASSf_GET
#define IMP_RGMII_CTL_GPr_DLL_RXC_BYPASSf_SET BCM53115_A0_IMP_RGMII_CTL_GPr_DLL_RXC_BYPASSf_SET
#define IMP_RGMII_CTL_GPr_DLL_IQQDf_GET BCM53115_A0_IMP_RGMII_CTL_GPr_DLL_IQQDf_GET
#define IMP_RGMII_CTL_GPr_DLL_IQQDf_SET BCM53115_A0_IMP_RGMII_CTL_GPr_DLL_IQQDf_SET
#define IMP_RGMII_CTL_GPr_RESERVED_1Rf_GET BCM53115_A0_IMP_RGMII_CTL_GPr_RESERVED_1Rf_GET
#define IMP_RGMII_CTL_GPr_RESERVED_1Rf_SET BCM53115_A0_IMP_RGMII_CTL_GPr_RESERVED_1Rf_SET
#define IMP_RGMII_CTL_GPr_RESERVED_2Rf_GET BCM53115_A0_IMP_RGMII_CTL_GPr_RESERVED_2Rf_GET
#define IMP_RGMII_CTL_GPr_RESERVED_2Rf_SET BCM53115_A0_IMP_RGMII_CTL_GPr_RESERVED_2Rf_SET
#define READ_IMP_RGMII_CTL_GPr BCM53115_A0_READ_IMP_RGMII_CTL_GPr
#define WRITE_IMP_RGMII_CTL_GPr BCM53115_A0_WRITE_IMP_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IMP_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IMP_RGMII_TIME_DLY_GP
 * BLOCKS:   SYS
 * DESC:     IMP Port RGMII TIMING DELAY register
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr 0x00000068

#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program IMP_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t imp_rgmii_time_dly_gp[1];
	uint32_t _imp_rgmii_time_dly_gp;
} BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_t;

#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_CLR(r) (r).imp_rgmii_time_dly_gp[0] = 0
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_SET(r,d) (r).imp_rgmii_time_dly_gp[0] = d
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_GET(r) (r).imp_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).imp_rgmii_time_dly_gp[0]) & 0xf)
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).imp_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).imp_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access IMP_RGMII_TIME_DLY_GP.
 *
 */
#define BCM53115_A0_READ_IMP_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IMP_RGMII_TIME_DLY_GPr,(r._imp_rgmii_time_dly_gp),1)
#define BCM53115_A0_WRITE_IMP_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IMP_RGMII_TIME_DLY_GPr,&(r._imp_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_RGMII_TIME_DLY_GPr BCM53115_A0_IMP_RGMII_TIME_DLY_GPr
#define IMP_RGMII_TIME_DLY_GPr_SIZE BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_SIZE
typedef BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_t IMP_RGMII_TIME_DLY_GPr_t;
#define IMP_RGMII_TIME_DLY_GPr_CLR BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_CLR
#define IMP_RGMII_TIME_DLY_GPr_SET BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_SET
#define IMP_RGMII_TIME_DLY_GPr_GET BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM53115_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_IMP_RGMII_TIME_DLY_GPr BCM53115_A0_READ_IMP_RGMII_TIME_DLY_GPr
#define WRITE_IMP_RGMII_TIME_DLY_GPr BCM53115_A0_WRITE_IMP_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IMP_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  IPG_SHRNK_CTRL
 * BLOCKS:   SYS
 * DESC:     IPG Shrink Control Register
 * SIZE:     32
 * FIELDS:
 *     IPG_SHKCTRL      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_IPG_SHRNK_CTRLr 0x0000020c

#define BCM53115_A0_IPG_SHRNK_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program IPG_SHRNK_CTRL.
 *
 */
typedef union BCM53115_A0_IPG_SHRNK_CTRLr_s {
	uint32_t v[1];
	uint32_t ipg_shrnk_ctrl[1];
	uint32_t _ipg_shrnk_ctrl;
} BCM53115_A0_IPG_SHRNK_CTRLr_t;

#define BCM53115_A0_IPG_SHRNK_CTRLr_CLR(r) (r).ipg_shrnk_ctrl[0] = 0
#define BCM53115_A0_IPG_SHRNK_CTRLr_SET(r,d) (r).ipg_shrnk_ctrl[0] = d
#define BCM53115_A0_IPG_SHRNK_CTRLr_GET(r) (r).ipg_shrnk_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET(r) (((r).ipg_shrnk_ctrl[0]) & 0x3ffff)
#define BCM53115_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET(r,f) (r).ipg_shrnk_ctrl[0]=(((r).ipg_shrnk_ctrl[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53115_A0_IPG_SHRNK_CTRLr_RESERVED_Rf_GET(r) ((((r).ipg_shrnk_ctrl[0]) >> 18) & 0x3fff)
#define BCM53115_A0_IPG_SHRNK_CTRLr_RESERVED_Rf_SET(r,f) (r).ipg_shrnk_ctrl[0]=(((r).ipg_shrnk_ctrl[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IPG_SHRNK_CTRL.
 *
 */
#define BCM53115_A0_READ_IPG_SHRNK_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_IPG_SHRNK_CTRLr,(r._ipg_shrnk_ctrl),4)
#define BCM53115_A0_WRITE_IPG_SHRNK_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_IPG_SHRNK_CTRLr,&(r._ipg_shrnk_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPG_SHRNK_CTRLr BCM53115_A0_IPG_SHRNK_CTRLr
#define IPG_SHRNK_CTRLr_SIZE BCM53115_A0_IPG_SHRNK_CTRLr_SIZE
typedef BCM53115_A0_IPG_SHRNK_CTRLr_t IPG_SHRNK_CTRLr_t;
#define IPG_SHRNK_CTRLr_CLR BCM53115_A0_IPG_SHRNK_CTRLr_CLR
#define IPG_SHRNK_CTRLr_SET BCM53115_A0_IPG_SHRNK_CTRLr_SET
#define IPG_SHRNK_CTRLr_GET BCM53115_A0_IPG_SHRNK_CTRLr_GET
#define IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET BCM53115_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET
#define IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET BCM53115_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET
#define IPG_SHRNK_CTRLr_RESERVED_Rf_GET BCM53115_A0_IPG_SHRNK_CTRLr_RESERVED_Rf_GET
#define IPG_SHRNK_CTRLr_RESERVED_Rf_SET BCM53115_A0_IPG_SHRNK_CTRLr_RESERVED_Rf_SET
#define READ_IPG_SHRNK_CTRLr BCM53115_A0_READ_IPG_SHRNK_CTRLr
#define WRITE_IPG_SHRNK_CTRLr BCM53115_A0_WRITE_IPG_SHRNK_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_IPG_SHRNK_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ISP_SEL_PORTMAP
 * BLOCKS:   SYS
 * DESC:     ISP Port Selection Portmap Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_PORTMAP      Portmap to define which port as ISP-port.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_ISP_SEL_PORTMAPr 0x00003432

#define BCM53115_A0_ISP_SEL_PORTMAPr_SIZE 2

/*
 * This structure should be used to declare and program ISP_SEL_PORTMAP.
 *
 */
typedef union BCM53115_A0_ISP_SEL_PORTMAPr_s {
	uint32_t v[1];
	uint32_t isp_sel_portmap[1];
	uint32_t _isp_sel_portmap;
} BCM53115_A0_ISP_SEL_PORTMAPr_t;

#define BCM53115_A0_ISP_SEL_PORTMAPr_CLR(r) (r).isp_sel_portmap[0] = 0
#define BCM53115_A0_ISP_SEL_PORTMAPr_SET(r,d) (r).isp_sel_portmap[0] = d
#define BCM53115_A0_ISP_SEL_PORTMAPr_GET(r) (r).isp_sel_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET(r) (((r).isp_sel_portmap[0]) & 0x1ff)
#define BCM53115_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ISP_SEL_PORTMAPr_RESERVED_Rf_GET(r) ((((r).isp_sel_portmap[0]) >> 9) & 0x7f)
#define BCM53115_A0_ISP_SEL_PORTMAPr_RESERVED_Rf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ISP_SEL_PORTMAP.
 *
 */
#define BCM53115_A0_READ_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ISP_SEL_PORTMAPr,(r._isp_sel_portmap),2)
#define BCM53115_A0_WRITE_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ISP_SEL_PORTMAPr,&(r._isp_sel_portmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_SEL_PORTMAPr BCM53115_A0_ISP_SEL_PORTMAPr
#define ISP_SEL_PORTMAPr_SIZE BCM53115_A0_ISP_SEL_PORTMAPr_SIZE
typedef BCM53115_A0_ISP_SEL_PORTMAPr_t ISP_SEL_PORTMAPr_t;
#define ISP_SEL_PORTMAPr_CLR BCM53115_A0_ISP_SEL_PORTMAPr_CLR
#define ISP_SEL_PORTMAPr_SET BCM53115_A0_ISP_SEL_PORTMAPr_SET
#define ISP_SEL_PORTMAPr_GET BCM53115_A0_ISP_SEL_PORTMAPr_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET BCM53115_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET BCM53115_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET
#define ISP_SEL_PORTMAPr_RESERVED_Rf_GET BCM53115_A0_ISP_SEL_PORTMAPr_RESERVED_Rf_GET
#define ISP_SEL_PORTMAPr_RESERVED_Rf_SET BCM53115_A0_ISP_SEL_PORTMAPr_RESERVED_Rf_SET
#define READ_ISP_SEL_PORTMAPr BCM53115_A0_READ_ISP_SEL_PORTMAPr
#define WRITE_ISP_SEL_PORTMAPr BCM53115_A0_WRITE_ISP_SEL_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ISP_SEL_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  InRangeErrCount
 * BLOCKS:   GPIC0 CPIC
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_INRANGEERRCOUNTr 0x000020b0

#define BCM53115_A0_INRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrCount.
 *
 */
typedef union BCM53115_A0_INRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t inrangeerrcount[1];
	uint32_t _inrangeerrcount;
} BCM53115_A0_INRANGEERRCOUNTr_t;

#define BCM53115_A0_INRANGEERRCOUNTr_CLR(r) (r).inrangeerrcount[0] = 0
#define BCM53115_A0_INRANGEERRCOUNTr_SET(r,d) (r).inrangeerrcount[0] = d
#define BCM53115_A0_INRANGEERRCOUNTr_GET(r) (r).inrangeerrcount[0]


/*
 * These macros can be used to access InRangeErrCount.
 *
 */
#define BCM53115_A0_READ_INRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_INRANGEERRCOUNTr,(r._inrangeerrcount),4)
#define BCM53115_A0_WRITE_INRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_INRANGEERRCOUNTr,&(r._inrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRCOUNTr BCM53115_A0_INRANGEERRCOUNTr
#define INRANGEERRCOUNTr_SIZE BCM53115_A0_INRANGEERRCOUNTr_SIZE
typedef BCM53115_A0_INRANGEERRCOUNTr_t INRANGEERRCOUNTr_t;
#define INRANGEERRCOUNTr_CLR BCM53115_A0_INRANGEERRCOUNTr_CLR
#define INRANGEERRCOUNTr_SET BCM53115_A0_INRANGEERRCOUNTr_SET
#define INRANGEERRCOUNTr_GET BCM53115_A0_INRANGEERRCOUNTr_GET
#define READ_INRANGEERRCOUNTr BCM53115_A0_READ_INRANGEERRCOUNTr
#define WRITE_INRANGEERRCOUNTr BCM53115_A0_WRITE_INRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_INRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  JUMBO_PORT_MASK
 * BLOCKS:   SYS
 * DESC:     Jumbo Frame Port Mask Registers
 * SIZE:     32
 * FIELDS:
 *     JUMBO_FM_PORT_MASK Jumbo Frame Port Mask.Ports defined in the Jumbo Frame Port Mask Register can Receive/Transmit Jumbo Frame ( Frame Size over 1522 bytes and less than 9728 bytes).Bit7:0 = Port 7-0 in chip 0.0 : Disable Jumbo Frame Capability,1 : Enable Jumbo Frame Capability,Jumbo Frames can be allowed to be delivered among these Ports. Non-Jumbo Frame will not be constrained by the register.
 *     RESERVED_0R      Reserved.
 *     EN_10_100_JUMBO  Enable 10/100 Port can receive and transmit jumbo frame Only Giga Port can #receive jumbo frame as default.
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_JUMBO_PORT_MASKr 0x00004001

#define BCM53115_A0_JUMBO_PORT_MASKr_SIZE 4

/*
 * This structure should be used to declare and program JUMBO_PORT_MASK.
 *
 */
typedef union BCM53115_A0_JUMBO_PORT_MASKr_s {
	uint32_t v[1];
	uint32_t jumbo_port_mask[1];
	uint32_t _jumbo_port_mask;
} BCM53115_A0_JUMBO_PORT_MASKr_t;

#define BCM53115_A0_JUMBO_PORT_MASKr_CLR(r) (r).jumbo_port_mask[0] = 0
#define BCM53115_A0_JUMBO_PORT_MASKr_SET(r,d) (r).jumbo_port_mask[0] = d
#define BCM53115_A0_JUMBO_PORT_MASKr_GET(r) (r).jumbo_port_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET(r) (((r).jumbo_port_mask[0]) & 0x1ff)
#define BCM53115_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_JUMBO_PORT_MASKr_RESERVED_0Rf_GET(r) ((((r).jumbo_port_mask[0]) >> 9) & 0x7fff)
#define BCM53115_A0_JUMBO_PORT_MASKr_RESERVED_0Rf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7fff << 9)) | ((((uint32_t)f) & 0x7fff) << 9))
#define BCM53115_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET(r) ((((r).jumbo_port_mask[0]) >> 24) & 0x1)
#define BCM53115_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_JUMBO_PORT_MASKr_RESERVED_1Rf_GET(r) ((((r).jumbo_port_mask[0]) >> 25) & 0x7f)
#define BCM53115_A0_JUMBO_PORT_MASKr_RESERVED_1Rf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access JUMBO_PORT_MASK.
 *
 */
#define BCM53115_A0_READ_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_read(u,BCM53115_A0_JUMBO_PORT_MASKr,(r._jumbo_port_mask),4)
#define BCM53115_A0_WRITE_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_write(u,BCM53115_A0_JUMBO_PORT_MASKr,&(r._jumbo_port_mask),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBO_PORT_MASKr BCM53115_A0_JUMBO_PORT_MASKr
#define JUMBO_PORT_MASKr_SIZE BCM53115_A0_JUMBO_PORT_MASKr_SIZE
typedef BCM53115_A0_JUMBO_PORT_MASKr_t JUMBO_PORT_MASKr_t;
#define JUMBO_PORT_MASKr_CLR BCM53115_A0_JUMBO_PORT_MASKr_CLR
#define JUMBO_PORT_MASKr_SET BCM53115_A0_JUMBO_PORT_MASKr_SET
#define JUMBO_PORT_MASKr_GET BCM53115_A0_JUMBO_PORT_MASKr_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET BCM53115_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET BCM53115_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET
#define JUMBO_PORT_MASKr_RESERVED_0Rf_GET BCM53115_A0_JUMBO_PORT_MASKr_RESERVED_0Rf_GET
#define JUMBO_PORT_MASKr_RESERVED_0Rf_SET BCM53115_A0_JUMBO_PORT_MASKr_RESERVED_0Rf_SET
#define JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET BCM53115_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET
#define JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET BCM53115_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET
#define JUMBO_PORT_MASKr_RESERVED_1Rf_GET BCM53115_A0_JUMBO_PORT_MASKr_RESERVED_1Rf_GET
#define JUMBO_PORT_MASKr_RESERVED_1Rf_SET BCM53115_A0_JUMBO_PORT_MASKr_RESERVED_1Rf_SET
#define READ_JUMBO_PORT_MASKr BCM53115_A0_READ_JUMBO_PORT_MASKr
#define WRITE_JUMBO_PORT_MASKr BCM53115_A0_WRITE_JUMBO_PORT_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_JUMBO_PORT_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  JumboPkt
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_JUMBOPKTr 0x000020a8

#define BCM53115_A0_JUMBOPKTr_SIZE 4

/*
 * This structure should be used to declare and program JumboPkt.
 *
 */
typedef union BCM53115_A0_JUMBOPKTr_s {
	uint32_t v[1];
	uint32_t jumbopkt[1];
	uint32_t _jumbopkt;
} BCM53115_A0_JUMBOPKTr_t;

#define BCM53115_A0_JUMBOPKTr_CLR(r) (r).jumbopkt[0] = 0
#define BCM53115_A0_JUMBOPKTr_SET(r,d) (r).jumbopkt[0] = d
#define BCM53115_A0_JUMBOPKTr_GET(r) (r).jumbopkt[0]


/*
 * These macros can be used to access JumboPkt.
 *
 */
#define BCM53115_A0_READ_JUMBOPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_JUMBOPKTr,(r._jumbopkt),4)
#define BCM53115_A0_WRITE_JUMBOPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_JUMBOPKTr,&(r._jumbopkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBOPKTr BCM53115_A0_JUMBOPKTr
#define JUMBOPKTr_SIZE BCM53115_A0_JUMBOPKTr_SIZE
typedef BCM53115_A0_JUMBOPKTr_t JUMBOPKTr_t;
#define JUMBOPKTr_CLR BCM53115_A0_JUMBOPKTr_CLR
#define JUMBOPKTr_SET BCM53115_A0_JUMBOPKTr_SET
#define JUMBOPKTr_GET BCM53115_A0_JUMBOPKTr_GET
#define READ_JUMBOPKTr BCM53115_A0_READ_JUMBOPKTr
#define WRITE_JUMBOPKTr BCM53115_A0_WRITE_JUMBOPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_JUMBOPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  L2_ARL
 * BLOCKS:   SYS
 * DESC:     ARL Table
 * SIZE:     65
 * FIELDS:
 *     MACADDR_47_12    Source Address[47:12]
 *     VID_R            VLAN ID
 *     PORTID_R         Multicast Portmap
 *     RESERVED_R       Reserved
 *     CONTROL          ARL control :2b'b00 : Normal ARL function.2b'b01 : Drop if MAC_DA match.(Please also set the "Static" bit)2b'b01 : Drop if MAC_SA match.(Please also set the "Static" bit)2b'b11 : Forward the destination port specified by ARL, Also send a copy to CPU.
 *     PRIORITY_R       Traffic Class
 *     AGE              Age status
 *     STATIC           Static status
 *     VALID_R          Valid status
 *
 ******************************************************************************/
#define BCM53115_A0_L2_ARLm 0x12120808

#define BCM53115_A0_L2_ARLm_MIN 0
#define BCM53115_A0_L2_ARLm_MAX 4095
#define BCM53115_A0_L2_ARLm_CMAX(u) 4095
#define BCM53115_A0_L2_ARLm_SIZE 9

/*
 * This structure should be used to declare and program L2_ARL.
 *
 */
typedef union BCM53115_A0_L2_ARLm_s {
	uint32_t v[3];
	uint32_t l2_arl[3];
	uint32_t _l2_arl;
} BCM53115_A0_L2_ARLm_t;

#define BCM53115_A0_L2_ARLm_CLR(r) CDK_MEMSET(&((r)._l2_arl), 0, sizeof(BCM53115_A0_L2_ARLm_t))
#define BCM53115_A0_L2_ARLm_SET(r,i,d) (r).l2_arl[i] = d
#define BCM53115_A0_L2_ARLm_GET(r,i) (r).l2_arl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_L2_ARLm_MACADDR_47_12f_GET(r,a) cdk_field_get((r).l2_arl,2,37,a)
#define BCM53115_A0_L2_ARLm_MACADDR_47_12f_SET(r,a) cdk_field_set((r).l2_arl,2,37,a)
#define BCM53115_A0_L2_ARLm_VID_Rf_GET(r) ((((r).l2_arl[1]) >> 6) & 0xfff)
#define BCM53115_A0_L2_ARLm_VID_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM53115_A0_L2_ARLm_PORTID_Rf_GET(r) ((((r).l2_arl[1]) >> 18) & 0xf)
#define BCM53115_A0_L2_ARLm_PORTID_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xf << 18)) | ((((uint32_t)f) & 0xf) << 18))
#define BCM53115_A0_L2_ARLm_RESERVED_Rf_GET(r) ((((r).l2_arl[1]) >> 22) & 0x7)
#define BCM53115_A0_L2_ARLm_RESERVED_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7 << 22)) | ((((uint32_t)f) & 0x7) << 22))
#define BCM53115_A0_L2_ARLm_CONTROLf_GET(r) ((((r).l2_arl[1]) >> 25) & 0x3)
#define BCM53115_A0_L2_ARLm_CONTROLf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53115_A0_L2_ARLm_PRIORITY_Rf_GET(r) ((((r).l2_arl[1]) >> 27) & 0x7)
#define BCM53115_A0_L2_ARLm_PRIORITY_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53115_A0_L2_ARLm_AGEf_GET(r) ((((r).l2_arl[1]) >> 30) & 0x1)
#define BCM53115_A0_L2_ARLm_AGEf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53115_A0_L2_ARLm_STATICf_GET(r) ((((r).l2_arl[1]) >> 31) & 0x1)
#define BCM53115_A0_L2_ARLm_STATICf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53115_A0_L2_ARLm_VALID_Rf_GET(r) (((r).l2_arl[2]) & 0x1)
#define BCM53115_A0_L2_ARLm_VALID_Rf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access L2_ARL.
 *
 */
#define BCM53115_A0_READ_L2_ARLm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_L2_ARLm,i,(m),9)
#define BCM53115_A0_WRITE_L2_ARLm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_L2_ARLm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ARLm BCM53115_A0_L2_ARLm
#define L2_ARLm_MIN BCM53115_A0_L2_ARLm_MIN
#define L2_ARLm_MAX BCM53115_A0_L2_ARLm_MAX
#define L2_ARLm_CMAX(u) BCM53115_A0_L2_ARLm_CMAX(u)
#define L2_ARLm_SIZE BCM53115_A0_L2_ARLm_SIZE
typedef BCM53115_A0_L2_ARLm_t L2_ARLm_t;
#define L2_ARLm_CLR BCM53115_A0_L2_ARLm_CLR
#define L2_ARLm_SET BCM53115_A0_L2_ARLm_SET
#define L2_ARLm_GET BCM53115_A0_L2_ARLm_GET
#define L2_ARLm_MACADDR_47_12f_GET BCM53115_A0_L2_ARLm_MACADDR_47_12f_GET
#define L2_ARLm_MACADDR_47_12f_SET BCM53115_A0_L2_ARLm_MACADDR_47_12f_SET
#define L2_ARLm_VID_Rf_GET BCM53115_A0_L2_ARLm_VID_Rf_GET
#define L2_ARLm_VID_Rf_SET BCM53115_A0_L2_ARLm_VID_Rf_SET
#define L2_ARLm_PORTID_Rf_GET BCM53115_A0_L2_ARLm_PORTID_Rf_GET
#define L2_ARLm_PORTID_Rf_SET BCM53115_A0_L2_ARLm_PORTID_Rf_SET
#define L2_ARLm_RESERVED_Rf_GET BCM53115_A0_L2_ARLm_RESERVED_Rf_GET
#define L2_ARLm_RESERVED_Rf_SET BCM53115_A0_L2_ARLm_RESERVED_Rf_SET
#define L2_ARLm_CONTROLf_GET BCM53115_A0_L2_ARLm_CONTROLf_GET
#define L2_ARLm_CONTROLf_SET BCM53115_A0_L2_ARLm_CONTROLf_SET
#define L2_ARLm_PRIORITY_Rf_GET BCM53115_A0_L2_ARLm_PRIORITY_Rf_GET
#define L2_ARLm_PRIORITY_Rf_SET BCM53115_A0_L2_ARLm_PRIORITY_Rf_SET
#define L2_ARLm_AGEf_GET BCM53115_A0_L2_ARLm_AGEf_GET
#define L2_ARLm_AGEf_SET BCM53115_A0_L2_ARLm_AGEf_SET
#define L2_ARLm_STATICf_GET BCM53115_A0_L2_ARLm_STATICf_GET
#define L2_ARLm_STATICf_SET BCM53115_A0_L2_ARLm_STATICf_SET
#define L2_ARLm_VALID_Rf_GET BCM53115_A0_L2_ARLm_VALID_Rf_GET
#define L2_ARLm_VALID_Rf_SET BCM53115_A0_L2_ARLm_VALID_Rf_SET
#define READ_L2_ARLm BCM53115_A0_READ_L2_ARLm
#define WRITE_L2_ARLm BCM53115_A0_WRITE_L2_ARLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_L2_ARLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_EN_MAP
 * BLOCKS:   SYS
 * DESC:     LED Enable Map register
 * SIZE:     16
 * FIELDS:
 *     LED_EN_MAP       Per port enable function bit,1: Enable LED function1: Disable LED function
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_LED_EN_MAPr 0x00000016

#define BCM53115_A0_LED_EN_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_EN_MAP.
 *
 */
typedef union BCM53115_A0_LED_EN_MAPr_s {
	uint32_t v[1];
	uint32_t led_en_map[1];
	uint32_t _led_en_map;
} BCM53115_A0_LED_EN_MAPr_t;

#define BCM53115_A0_LED_EN_MAPr_CLR(r) (r).led_en_map[0] = 0
#define BCM53115_A0_LED_EN_MAPr_SET(r,d) (r).led_en_map[0] = d
#define BCM53115_A0_LED_EN_MAPr_GET(r) (r).led_en_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_EN_MAPr_LED_EN_MAPf_GET(r) (((r).led_en_map[0]) & 0x1ff)
#define BCM53115_A0_LED_EN_MAPr_LED_EN_MAPf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_LED_EN_MAPr_RESERVED_Rf_GET(r) ((((r).led_en_map[0]) >> 9) & 0x7f)
#define BCM53115_A0_LED_EN_MAPr_RESERVED_Rf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_EN_MAP.
 *
 */
#define BCM53115_A0_READ_LED_EN_MAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_EN_MAPr,(r._led_en_map),2)
#define BCM53115_A0_WRITE_LED_EN_MAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_EN_MAPr,&(r._led_en_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_EN_MAPr BCM53115_A0_LED_EN_MAPr
#define LED_EN_MAPr_SIZE BCM53115_A0_LED_EN_MAPr_SIZE
typedef BCM53115_A0_LED_EN_MAPr_t LED_EN_MAPr_t;
#define LED_EN_MAPr_CLR BCM53115_A0_LED_EN_MAPr_CLR
#define LED_EN_MAPr_SET BCM53115_A0_LED_EN_MAPr_SET
#define LED_EN_MAPr_GET BCM53115_A0_LED_EN_MAPr_GET
#define LED_EN_MAPr_LED_EN_MAPf_GET BCM53115_A0_LED_EN_MAPr_LED_EN_MAPf_GET
#define LED_EN_MAPr_LED_EN_MAPf_SET BCM53115_A0_LED_EN_MAPr_LED_EN_MAPf_SET
#define LED_EN_MAPr_RESERVED_Rf_GET BCM53115_A0_LED_EN_MAPr_RESERVED_Rf_GET
#define LED_EN_MAPr_RESERVED_Rf_SET BCM53115_A0_LED_EN_MAPr_RESERVED_Rf_SET
#define READ_LED_EN_MAPr BCM53115_A0_READ_LED_EN_MAPr
#define WRITE_LED_EN_MAPr BCM53115_A0_WRITE_LED_EN_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_EN_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_FUNC0_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 0 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0        default : ledmode=00 : 16'h0121;          ledmode=01 : 16'h0C41;          ledmode=10 : 16'h0124;          ledmode=11 : 16'h0C04;
 *
 ******************************************************************************/
#define BCM53115_A0_LED_FUNC0_CTLr 0x00000010

#define BCM53115_A0_LED_FUNC0_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC0_CTL.
 *
 */
typedef union BCM53115_A0_LED_FUNC0_CTLr_s {
	uint32_t v[1];
	uint32_t led_func0_ctl[1];
	uint32_t _led_func0_ctl;
} BCM53115_A0_LED_FUNC0_CTLr_t;

#define BCM53115_A0_LED_FUNC0_CTLr_CLR(r) (r).led_func0_ctl[0] = 0
#define BCM53115_A0_LED_FUNC0_CTLr_SET(r,d) (r).led_func0_ctl[0] = d
#define BCM53115_A0_LED_FUNC0_CTLr_GET(r) (r).led_func0_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET(r) (((r).led_func0_ctl[0]) & 0xffff)
#define BCM53115_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC0_CTL.
 *
 */
#define BCM53115_A0_READ_LED_FUNC0_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_FUNC0_CTLr,(r._led_func0_ctl),2)
#define BCM53115_A0_WRITE_LED_FUNC0_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_FUNC0_CTLr,&(r._led_func0_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC0_CTLr BCM53115_A0_LED_FUNC0_CTLr
#define LED_FUNC0_CTLr_SIZE BCM53115_A0_LED_FUNC0_CTLr_SIZE
typedef BCM53115_A0_LED_FUNC0_CTLr_t LED_FUNC0_CTLr_t;
#define LED_FUNC0_CTLr_CLR BCM53115_A0_LED_FUNC0_CTLr_CLR
#define LED_FUNC0_CTLr_SET BCM53115_A0_LED_FUNC0_CTLr_SET
#define LED_FUNC0_CTLr_GET BCM53115_A0_LED_FUNC0_CTLr_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_GET BCM53115_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_SET BCM53115_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET
#define READ_LED_FUNC0_CTLr BCM53115_A0_READ_LED_FUNC0_CTLr
#define WRITE_LED_FUNC0_CTLr BCM53115_A0_WRITE_LED_FUNC0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_FUNC0_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_FUNC1_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 1 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0        default : ledmode=00 : 16'h0321;          ledmode=01 : 16'h3041;          ledmode=10 : 16'h0324;          ledmode=11 : 16'h2C04;
 *
 ******************************************************************************/
#define BCM53115_A0_LED_FUNC1_CTLr 0x00000012

#define BCM53115_A0_LED_FUNC1_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC1_CTL.
 *
 */
typedef union BCM53115_A0_LED_FUNC1_CTLr_s {
	uint32_t v[1];
	uint32_t led_func1_ctl[1];
	uint32_t _led_func1_ctl;
} BCM53115_A0_LED_FUNC1_CTLr_t;

#define BCM53115_A0_LED_FUNC1_CTLr_CLR(r) (r).led_func1_ctl[0] = 0
#define BCM53115_A0_LED_FUNC1_CTLr_SET(r,d) (r).led_func1_ctl[0] = d
#define BCM53115_A0_LED_FUNC1_CTLr_GET(r) (r).led_func1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_FUNC1_CTLr_LED_FUNC0f_GET(r) (((r).led_func1_ctl[0]) & 0xffff)
#define BCM53115_A0_LED_FUNC1_CTLr_LED_FUNC0f_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC1_CTL.
 *
 */
#define BCM53115_A0_READ_LED_FUNC1_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_FUNC1_CTLr,(r._led_func1_ctl),2)
#define BCM53115_A0_WRITE_LED_FUNC1_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_FUNC1_CTLr,&(r._led_func1_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC1_CTLr BCM53115_A0_LED_FUNC1_CTLr
#define LED_FUNC1_CTLr_SIZE BCM53115_A0_LED_FUNC1_CTLr_SIZE
typedef BCM53115_A0_LED_FUNC1_CTLr_t LED_FUNC1_CTLr_t;
#define LED_FUNC1_CTLr_CLR BCM53115_A0_LED_FUNC1_CTLr_CLR
#define LED_FUNC1_CTLr_SET BCM53115_A0_LED_FUNC1_CTLr_SET
#define LED_FUNC1_CTLr_GET BCM53115_A0_LED_FUNC1_CTLr_GET
#define LED_FUNC1_CTLr_LED_FUNC0f_GET BCM53115_A0_LED_FUNC1_CTLr_LED_FUNC0f_GET
#define LED_FUNC1_CTLr_LED_FUNC0f_SET BCM53115_A0_LED_FUNC1_CTLr_LED_FUNC0f_SET
#define READ_LED_FUNC1_CTLr BCM53115_A0_READ_LED_FUNC1_CTLr
#define WRITE_LED_FUNC1_CTLr BCM53115_A0_WRITE_LED_FUNC1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_FUNC1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_FUNC_MAP
 * BLOCKS:   SYS
 * DESC:     LED Function Map register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC_MAP     Per port select function bit.1: select function 1,0: select function 0.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_LED_FUNC_MAPr 0x00000014

#define BCM53115_A0_LED_FUNC_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC_MAP.
 *
 */
typedef union BCM53115_A0_LED_FUNC_MAPr_s {
	uint32_t v[1];
	uint32_t led_func_map[1];
	uint32_t _led_func_map;
} BCM53115_A0_LED_FUNC_MAPr_t;

#define BCM53115_A0_LED_FUNC_MAPr_CLR(r) (r).led_func_map[0] = 0
#define BCM53115_A0_LED_FUNC_MAPr_SET(r,d) (r).led_func_map[0] = d
#define BCM53115_A0_LED_FUNC_MAPr_GET(r) (r).led_func_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET(r) (((r).led_func_map[0]) & 0x1ff)
#define BCM53115_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_LED_FUNC_MAPr_RESERVED_Rf_GET(r) ((((r).led_func_map[0]) >> 9) & 0x7f)
#define BCM53115_A0_LED_FUNC_MAPr_RESERVED_Rf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_FUNC_MAP.
 *
 */
#define BCM53115_A0_READ_LED_FUNC_MAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_FUNC_MAPr,(r._led_func_map),2)
#define BCM53115_A0_WRITE_LED_FUNC_MAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_FUNC_MAPr,&(r._led_func_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC_MAPr BCM53115_A0_LED_FUNC_MAPr
#define LED_FUNC_MAPr_SIZE BCM53115_A0_LED_FUNC_MAPr_SIZE
typedef BCM53115_A0_LED_FUNC_MAPr_t LED_FUNC_MAPr_t;
#define LED_FUNC_MAPr_CLR BCM53115_A0_LED_FUNC_MAPr_CLR
#define LED_FUNC_MAPr_SET BCM53115_A0_LED_FUNC_MAPr_SET
#define LED_FUNC_MAPr_GET BCM53115_A0_LED_FUNC_MAPr_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_GET BCM53115_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_SET BCM53115_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET
#define LED_FUNC_MAPr_RESERVED_Rf_GET BCM53115_A0_LED_FUNC_MAPr_RESERVED_Rf_GET
#define LED_FUNC_MAPr_RESERVED_Rf_SET BCM53115_A0_LED_FUNC_MAPr_RESERVED_Rf_SET
#define READ_LED_FUNC_MAPr BCM53115_A0_READ_LED_FUNC_MAPr
#define WRITE_LED_FUNC_MAPr BCM53115_A0_WRITE_LED_FUNC_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_FUNC_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_MODE_MAP_0
 * BLOCKS:   SYS
 * DESC:     LED Mode map 0 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP     Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_LED_MODE_MAP_0r 0x00000018

#define BCM53115_A0_LED_MODE_MAP_0r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_0.
 *
 */
typedef union BCM53115_A0_LED_MODE_MAP_0r_s {
	uint32_t v[1];
	uint32_t led_mode_map_0[1];
	uint32_t _led_mode_map_0;
} BCM53115_A0_LED_MODE_MAP_0r_t;

#define BCM53115_A0_LED_MODE_MAP_0r_CLR(r) (r).led_mode_map_0[0] = 0
#define BCM53115_A0_LED_MODE_MAP_0r_SET(r,d) (r).led_mode_map_0[0] = d
#define BCM53115_A0_LED_MODE_MAP_0r_GET(r) (r).led_mode_map_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_GET(r) (((r).led_mode_map_0[0]) & 0x1ff)
#define BCM53115_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_LED_MODE_MAP_0r_RESERVED_Rf_GET(r) ((((r).led_mode_map_0[0]) >> 9) & 0x7f)
#define BCM53115_A0_LED_MODE_MAP_0r_RESERVED_Rf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_0.
 *
 */
#define BCM53115_A0_READ_LED_MODE_MAP_0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_MODE_MAP_0r,(r._led_mode_map_0),2)
#define BCM53115_A0_WRITE_LED_MODE_MAP_0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_MODE_MAP_0r,&(r._led_mode_map_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_0r BCM53115_A0_LED_MODE_MAP_0r
#define LED_MODE_MAP_0r_SIZE BCM53115_A0_LED_MODE_MAP_0r_SIZE
typedef BCM53115_A0_LED_MODE_MAP_0r_t LED_MODE_MAP_0r_t;
#define LED_MODE_MAP_0r_CLR BCM53115_A0_LED_MODE_MAP_0r_CLR
#define LED_MODE_MAP_0r_SET BCM53115_A0_LED_MODE_MAP_0r_SET
#define LED_MODE_MAP_0r_GET BCM53115_A0_LED_MODE_MAP_0r_GET
#define LED_MODE_MAP_0r_LED_MODE_MAPf_GET BCM53115_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_GET
#define LED_MODE_MAP_0r_LED_MODE_MAPf_SET BCM53115_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_SET
#define LED_MODE_MAP_0r_RESERVED_Rf_GET BCM53115_A0_LED_MODE_MAP_0r_RESERVED_Rf_GET
#define LED_MODE_MAP_0r_RESERVED_Rf_SET BCM53115_A0_LED_MODE_MAP_0r_RESERVED_Rf_SET
#define READ_LED_MODE_MAP_0r BCM53115_A0_READ_LED_MODE_MAP_0r
#define WRITE_LED_MODE_MAP_0r BCM53115_A0_WRITE_LED_MODE_MAP_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_MODE_MAP_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_MODE_MAP_1
 * BLOCKS:   SYS
 * DESC:     LED Mode map 1 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP     Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_LED_MODE_MAP_1r 0x0000001a

#define BCM53115_A0_LED_MODE_MAP_1r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_1.
 *
 */
typedef union BCM53115_A0_LED_MODE_MAP_1r_s {
	uint32_t v[1];
	uint32_t led_mode_map_1[1];
	uint32_t _led_mode_map_1;
} BCM53115_A0_LED_MODE_MAP_1r_t;

#define BCM53115_A0_LED_MODE_MAP_1r_CLR(r) (r).led_mode_map_1[0] = 0
#define BCM53115_A0_LED_MODE_MAP_1r_SET(r,d) (r).led_mode_map_1[0] = d
#define BCM53115_A0_LED_MODE_MAP_1r_GET(r) (r).led_mode_map_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_GET(r) (((r).led_mode_map_1[0]) & 0x1ff)
#define BCM53115_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_LED_MODE_MAP_1r_RESERVED_Rf_GET(r) ((((r).led_mode_map_1[0]) >> 9) & 0x7f)
#define BCM53115_A0_LED_MODE_MAP_1r_RESERVED_Rf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_1.
 *
 */
#define BCM53115_A0_READ_LED_MODE_MAP_1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_MODE_MAP_1r,(r._led_mode_map_1),2)
#define BCM53115_A0_WRITE_LED_MODE_MAP_1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_MODE_MAP_1r,&(r._led_mode_map_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_1r BCM53115_A0_LED_MODE_MAP_1r
#define LED_MODE_MAP_1r_SIZE BCM53115_A0_LED_MODE_MAP_1r_SIZE
typedef BCM53115_A0_LED_MODE_MAP_1r_t LED_MODE_MAP_1r_t;
#define LED_MODE_MAP_1r_CLR BCM53115_A0_LED_MODE_MAP_1r_CLR
#define LED_MODE_MAP_1r_SET BCM53115_A0_LED_MODE_MAP_1r_SET
#define LED_MODE_MAP_1r_GET BCM53115_A0_LED_MODE_MAP_1r_GET
#define LED_MODE_MAP_1r_LED_MODE_MAPf_GET BCM53115_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_GET
#define LED_MODE_MAP_1r_LED_MODE_MAPf_SET BCM53115_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_SET
#define LED_MODE_MAP_1r_RESERVED_Rf_GET BCM53115_A0_LED_MODE_MAP_1r_RESERVED_Rf_GET
#define LED_MODE_MAP_1r_RESERVED_Rf_SET BCM53115_A0_LED_MODE_MAP_1r_RESERVED_Rf_SET
#define READ_LED_MODE_MAP_1r BCM53115_A0_READ_LED_MODE_MAP_1r
#define WRITE_LED_MODE_MAP_1r BCM53115_A0_WRITE_LED_MODE_MAP_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_MODE_MAP_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_OUTPUT_ENABLE
 * BLOCKS:   SYS
 * DESC:     LED Output Enable Register
 * SIZE:     8
 * FIELDS:
 *     OE_PHY_LED       
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_LED_OUTPUT_ENABLEr 0x0000001c

#define BCM53115_A0_LED_OUTPUT_ENABLEr_SIZE 1

/*
 * This structure should be used to declare and program LED_OUTPUT_ENABLE.
 *
 */
typedef union BCM53115_A0_LED_OUTPUT_ENABLEr_s {
	uint32_t v[1];
	uint32_t led_output_enable[1];
	uint32_t _led_output_enable;
} BCM53115_A0_LED_OUTPUT_ENABLEr_t;

#define BCM53115_A0_LED_OUTPUT_ENABLEr_CLR(r) (r).led_output_enable[0] = 0
#define BCM53115_A0_LED_OUTPUT_ENABLEr_SET(r,d) (r).led_output_enable[0] = d
#define BCM53115_A0_LED_OUTPUT_ENABLEr_GET(r) (r).led_output_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_OUTPUT_ENABLEr_OE_PHY_LEDf_GET(r) (((r).led_output_enable[0]) & 0x1)
#define BCM53115_A0_LED_OUTPUT_ENABLEr_OE_PHY_LEDf_SET(r,f) (r).led_output_enable[0]=(((r).led_output_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_LED_OUTPUT_ENABLEr_RESERVED_Rf_GET(r) ((((r).led_output_enable[0]) >> 1) & 0x7f)
#define BCM53115_A0_LED_OUTPUT_ENABLEr_RESERVED_Rf_SET(r,f) (r).led_output_enable[0]=(((r).led_output_enable[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access LED_OUTPUT_ENABLE.
 *
 */
#define BCM53115_A0_READ_LED_OUTPUT_ENABLEr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_OUTPUT_ENABLEr,(r._led_output_enable),1)
#define BCM53115_A0_WRITE_LED_OUTPUT_ENABLEr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_OUTPUT_ENABLEr,&(r._led_output_enable),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_OUTPUT_ENABLEr BCM53115_A0_LED_OUTPUT_ENABLEr
#define LED_OUTPUT_ENABLEr_SIZE BCM53115_A0_LED_OUTPUT_ENABLEr_SIZE
typedef BCM53115_A0_LED_OUTPUT_ENABLEr_t LED_OUTPUT_ENABLEr_t;
#define LED_OUTPUT_ENABLEr_CLR BCM53115_A0_LED_OUTPUT_ENABLEr_CLR
#define LED_OUTPUT_ENABLEr_SET BCM53115_A0_LED_OUTPUT_ENABLEr_SET
#define LED_OUTPUT_ENABLEr_GET BCM53115_A0_LED_OUTPUT_ENABLEr_GET
#define LED_OUTPUT_ENABLEr_OE_PHY_LEDf_GET BCM53115_A0_LED_OUTPUT_ENABLEr_OE_PHY_LEDf_GET
#define LED_OUTPUT_ENABLEr_OE_PHY_LEDf_SET BCM53115_A0_LED_OUTPUT_ENABLEr_OE_PHY_LEDf_SET
#define LED_OUTPUT_ENABLEr_RESERVED_Rf_GET BCM53115_A0_LED_OUTPUT_ENABLEr_RESERVED_Rf_GET
#define LED_OUTPUT_ENABLEr_RESERVED_Rf_SET BCM53115_A0_LED_OUTPUT_ENABLEr_RESERVED_Rf_SET
#define READ_LED_OUTPUT_ENABLEr BCM53115_A0_READ_LED_OUTPUT_ENABLEr
#define WRITE_LED_OUTPUT_ENABLEr BCM53115_A0_WRITE_LED_OUTPUT_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_OUTPUT_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_PORTMAP
 * BLOCKS:   SYS
 * DESC:     LED Waming Portmap Registers
 * SIZE:     16
 * FIELDS:
 *     LED_WARNING_PORTMAP 
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_LED_PORTMAPr 0x00007203

#define BCM53115_A0_LED_PORTMAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_PORTMAP.
 *
 */
typedef union BCM53115_A0_LED_PORTMAPr_s {
	uint32_t v[1];
	uint32_t led_portmap[1];
	uint32_t _led_portmap;
} BCM53115_A0_LED_PORTMAPr_t;

#define BCM53115_A0_LED_PORTMAPr_CLR(r) (r).led_portmap[0] = 0
#define BCM53115_A0_LED_PORTMAPr_SET(r,d) (r).led_portmap[0] = d
#define BCM53115_A0_LED_PORTMAPr_GET(r) (r).led_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_GET(r) (((r).led_portmap[0]) & 0x1ff)
#define BCM53115_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_SET(r,f) (r).led_portmap[0]=(((r).led_portmap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_LED_PORTMAPr_RESERVED_Rf_GET(r) ((((r).led_portmap[0]) >> 9) & 0x7f)
#define BCM53115_A0_LED_PORTMAPr_RESERVED_Rf_SET(r,f) (r).led_portmap[0]=(((r).led_portmap[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_PORTMAP.
 *
 */
#define BCM53115_A0_READ_LED_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_PORTMAPr,(r._led_portmap),2)
#define BCM53115_A0_WRITE_LED_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_PORTMAPr,&(r._led_portmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_PORTMAPr BCM53115_A0_LED_PORTMAPr
#define LED_PORTMAPr_SIZE BCM53115_A0_LED_PORTMAPr_SIZE
typedef BCM53115_A0_LED_PORTMAPr_t LED_PORTMAPr_t;
#define LED_PORTMAPr_CLR BCM53115_A0_LED_PORTMAPr_CLR
#define LED_PORTMAPr_SET BCM53115_A0_LED_PORTMAPr_SET
#define LED_PORTMAPr_GET BCM53115_A0_LED_PORTMAPr_GET
#define LED_PORTMAPr_LED_WARNING_PORTMAPf_GET BCM53115_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_GET
#define LED_PORTMAPr_LED_WARNING_PORTMAPf_SET BCM53115_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_SET
#define LED_PORTMAPr_RESERVED_Rf_GET BCM53115_A0_LED_PORTMAPr_RESERVED_Rf_GET
#define LED_PORTMAPr_RESERVED_Rf_SET BCM53115_A0_LED_PORTMAPr_RESERVED_Rf_SET
#define READ_LED_PORTMAPr BCM53115_A0_READ_LED_PORTMAPr
#define WRITE_LED_PORTMAPr BCM53115_A0_WRITE_LED_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LED_REFLSH_CTL
 * BLOCKS:   SYS
 * DESC:     LED Configuration Register
 * SIZE:     8
 * FIELDS:
 *     LED_RFS_STOP     LED reflsh control register.reflsh time = (N+1)*10ns000 : no reflsh;001 : 20ms/25Hz;010 : 30ms/16Hz;011 : 40ms/12Hz;100 : 50ms/10Hz;101 : 60ms/8Hz;110 : 70ms/7Hz;111 : 80ms/6Hz.
 *     LED_NORM_CD_EN   
 *     LED_POST_CD_EN   
 *     LED_PSCAN_EN     
 *     LED_POST_EXEC    
 *     LED_EN           Enable LED.
 *
 ******************************************************************************/
#define BCM53115_A0_LED_REFLSH_CTLr 0x0000000f

#define BCM53115_A0_LED_REFLSH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program LED_REFLSH_CTL.
 *
 */
typedef union BCM53115_A0_LED_REFLSH_CTLr_s {
	uint32_t v[1];
	uint32_t led_reflsh_ctl[1];
	uint32_t _led_reflsh_ctl;
} BCM53115_A0_LED_REFLSH_CTLr_t;

#define BCM53115_A0_LED_REFLSH_CTLr_CLR(r) (r).led_reflsh_ctl[0] = 0
#define BCM53115_A0_LED_REFLSH_CTLr_SET(r,d) (r).led_reflsh_ctl[0] = d
#define BCM53115_A0_LED_REFLSH_CTLr_GET(r) (r).led_reflsh_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET(r) (((r).led_reflsh_ctl[0]) & 0x7)
#define BCM53115_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 3) & 0x1)
#define BCM53115_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 4) & 0x1)
#define BCM53115_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 5) & 0x1)
#define BCM53115_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_LED_REFLSH_CTLr_LED_POST_EXECf_GET(r) ((((r).led_reflsh_ctl[0]) >> 6) & 0x1)
#define BCM53115_A0_LED_REFLSH_CTLr_LED_POST_EXECf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_LED_REFLSH_CTLr_LED_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 7) & 0x1)
#define BCM53115_A0_LED_REFLSH_CTLr_LED_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access LED_REFLSH_CTL.
 *
 */
#define BCM53115_A0_READ_LED_REFLSH_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LED_REFLSH_CTLr,(r._led_reflsh_ctl),1)
#define BCM53115_A0_WRITE_LED_REFLSH_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LED_REFLSH_CTLr,&(r._led_reflsh_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_REFLSH_CTLr BCM53115_A0_LED_REFLSH_CTLr
#define LED_REFLSH_CTLr_SIZE BCM53115_A0_LED_REFLSH_CTLr_SIZE
typedef BCM53115_A0_LED_REFLSH_CTLr_t LED_REFLSH_CTLr_t;
#define LED_REFLSH_CTLr_CLR BCM53115_A0_LED_REFLSH_CTLr_CLR
#define LED_REFLSH_CTLr_SET BCM53115_A0_LED_REFLSH_CTLr_SET
#define LED_REFLSH_CTLr_GET BCM53115_A0_LED_REFLSH_CTLr_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_GET BCM53115_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_SET BCM53115_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET
#define LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET BCM53115_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET
#define LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET BCM53115_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET
#define LED_REFLSH_CTLr_LED_POST_CD_ENf_GET BCM53115_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_GET
#define LED_REFLSH_CTLr_LED_POST_CD_ENf_SET BCM53115_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_SET
#define LED_REFLSH_CTLr_LED_PSCAN_ENf_GET BCM53115_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_GET
#define LED_REFLSH_CTLr_LED_PSCAN_ENf_SET BCM53115_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_SET
#define LED_REFLSH_CTLr_LED_POST_EXECf_GET BCM53115_A0_LED_REFLSH_CTLr_LED_POST_EXECf_GET
#define LED_REFLSH_CTLr_LED_POST_EXECf_SET BCM53115_A0_LED_REFLSH_CTLr_LED_POST_EXECf_SET
#define LED_REFLSH_CTLr_LED_ENf_GET BCM53115_A0_LED_REFLSH_CTLr_LED_ENf_GET
#define LED_REFLSH_CTLr_LED_ENf_SET BCM53115_A0_LED_REFLSH_CTLr_LED_ENf_SET
#define READ_LED_REFLSH_CTLr BCM53115_A0_READ_LED_REFLSH_CTLr
#define WRITE_LED_REFLSH_CTLr BCM53115_A0_WRITE_LED_REFLSH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LED_REFLSH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LNKSTS
 * BLOCKS:   SYS
 * DESC:     LinkStatus Summary Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS          Link Status.9bit field indicating the Link Status for each 10/100/1000 BASE-T port, (bits 0-7 = 10/100/1000 BASE-T, bit 8 IMP port ).0 = Link Fail1 = Link Pass
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_LNKSTSr 0x00000100

#define BCM53115_A0_LNKSTSr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTS.
 *
 */
typedef union BCM53115_A0_LNKSTSr_s {
	uint32_t v[1];
	uint32_t lnksts[1];
	uint32_t _lnksts;
} BCM53115_A0_LNKSTSr_t;

#define BCM53115_A0_LNKSTSr_CLR(r) (r).lnksts[0] = 0
#define BCM53115_A0_LNKSTSr_SET(r,d) (r).lnksts[0] = d
#define BCM53115_A0_LNKSTSr_GET(r) (r).lnksts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LNKSTSr_LNK_STSf_GET(r) (((r).lnksts[0]) & 0x1ff)
#define BCM53115_A0_LNKSTSr_LNK_STSf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_LNKSTSr_RESERVED_Rf_GET(r) ((((r).lnksts[0]) >> 9) & 0x7f)
#define BCM53115_A0_LNKSTSr_RESERVED_Rf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTS.
 *
 */
#define BCM53115_A0_READ_LNKSTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LNKSTSr,(r._lnksts),2)
#define BCM53115_A0_WRITE_LNKSTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LNKSTSr,&(r._lnksts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSr BCM53115_A0_LNKSTSr
#define LNKSTSr_SIZE BCM53115_A0_LNKSTSr_SIZE
typedef BCM53115_A0_LNKSTSr_t LNKSTSr_t;
#define LNKSTSr_CLR BCM53115_A0_LNKSTSr_CLR
#define LNKSTSr_SET BCM53115_A0_LNKSTSr_SET
#define LNKSTSr_GET BCM53115_A0_LNKSTSr_GET
#define LNKSTSr_LNK_STSf_GET BCM53115_A0_LNKSTSr_LNK_STSf_GET
#define LNKSTSr_LNK_STSf_SET BCM53115_A0_LNKSTSr_LNK_STSf_SET
#define LNKSTSr_RESERVED_Rf_GET BCM53115_A0_LNKSTSr_RESERVED_Rf_GET
#define LNKSTSr_RESERVED_Rf_SET BCM53115_A0_LNKSTSr_RESERVED_Rf_SET
#define READ_LNKSTSr BCM53115_A0_READ_LNKSTSr
#define WRITE_LNKSTSr BCM53115_A0_WRITE_LNKSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LNKSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LNKSTSCHG
 * BLOCKS:   SYS
 * DESC:     Link Status Change Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS_CHG      Link Status Change.9 bit field indicating that the Link Status for an individual 10/100/1000BASE-T port had changed since the last read operation (bits 0-23 = 10/100/1000BASE- T ports, bit 8 = IMP port). Upon change of link status, a bit remains set until cleared by a read operation.0 = Link Status Constant,1 = Link Status Change.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_LNKSTSCHGr 0x00000102

#define BCM53115_A0_LNKSTSCHGr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTSCHG.
 *
 */
typedef union BCM53115_A0_LNKSTSCHGr_s {
	uint32_t v[1];
	uint32_t lnkstschg[1];
	uint32_t _lnkstschg;
} BCM53115_A0_LNKSTSCHGr_t;

#define BCM53115_A0_LNKSTSCHGr_CLR(r) (r).lnkstschg[0] = 0
#define BCM53115_A0_LNKSTSCHGr_SET(r,d) (r).lnkstschg[0] = d
#define BCM53115_A0_LNKSTSCHGr_GET(r) (r).lnkstschg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LNKSTSCHGr_LNK_STS_CHGf_GET(r) (((r).lnkstschg[0]) & 0x1ff)
#define BCM53115_A0_LNKSTSCHGr_LNK_STS_CHGf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_LNKSTSCHGr_RESERVED_Rf_GET(r) ((((r).lnkstschg[0]) >> 9) & 0x7f)
#define BCM53115_A0_LNKSTSCHGr_RESERVED_Rf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTSCHG.
 *
 */
#define BCM53115_A0_READ_LNKSTSCHGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LNKSTSCHGr,(r._lnkstschg),2)
#define BCM53115_A0_WRITE_LNKSTSCHGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LNKSTSCHGr,&(r._lnkstschg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSCHGr BCM53115_A0_LNKSTSCHGr
#define LNKSTSCHGr_SIZE BCM53115_A0_LNKSTSCHGr_SIZE
typedef BCM53115_A0_LNKSTSCHGr_t LNKSTSCHGr_t;
#define LNKSTSCHGr_CLR BCM53115_A0_LNKSTSCHGr_CLR
#define LNKSTSCHGr_SET BCM53115_A0_LNKSTSCHGr_SET
#define LNKSTSCHGr_GET BCM53115_A0_LNKSTSCHGr_GET
#define LNKSTSCHGr_LNK_STS_CHGf_GET BCM53115_A0_LNKSTSCHGr_LNK_STS_CHGf_GET
#define LNKSTSCHGr_LNK_STS_CHGf_SET BCM53115_A0_LNKSTSCHGr_LNK_STS_CHGf_SET
#define LNKSTSCHGr_RESERVED_Rf_GET BCM53115_A0_LNKSTSCHGr_RESERVED_Rf_GET
#define LNKSTSCHGr_RESERVED_Rf_SET BCM53115_A0_LNKSTSCHGr_RESERVED_Rf_SET
#define READ_LNKSTSCHGr BCM53115_A0_READ_LNKSTSCHGr
#define WRITE_LNKSTSCHGr BCM53115_A0_WRITE_LNKSTSCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LNKSTSCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LPDET_CFG
 * BLOCKS:   SYS
 * DESC:     Loop Detection Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     DFQ_SEL          
 *     OV_PAUSE_ON      
 *     LED_RST_CTL      
 *     EN_LP_MII        
 *     EN_LPDET         
 *     EN_TXPASS        
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_LPDET_CFGr 0x00007200

#define BCM53115_A0_LPDET_CFGr_SIZE 2

/*
 * This structure should be used to declare and program LPDET_CFG.
 *
 */
typedef union BCM53115_A0_LPDET_CFGr_s {
	uint32_t v[1];
	uint32_t lpdet_cfg[1];
	uint32_t _lpdet_cfg;
} BCM53115_A0_LPDET_CFGr_t;

#define BCM53115_A0_LPDET_CFGr_CLR(r) (r).lpdet_cfg[0] = 0
#define BCM53115_A0_LPDET_CFGr_SET(r,d) (r).lpdet_cfg[0] = d
#define BCM53115_A0_LPDET_CFGr_GET(r) (r).lpdet_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LPDET_CFGr_DFQ_SELf_GET(r) (((r).lpdet_cfg[0]) & 0x3)
#define BCM53115_A0_LPDET_CFGr_DFQ_SELf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_LPDET_CFGr_OV_PAUSE_ONf_GET(r) ((((r).lpdet_cfg[0]) >> 2) & 0x1)
#define BCM53115_A0_LPDET_CFGr_OV_PAUSE_ONf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_LPDET_CFGr_LED_RST_CTLf_GET(r) ((((r).lpdet_cfg[0]) >> 3) & 0xff)
#define BCM53115_A0_LPDET_CFGr_LED_RST_CTLf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCM53115_A0_LPDET_CFGr_EN_LP_MIIf_GET(r) ((((r).lpdet_cfg[0]) >> 11) & 0x1)
#define BCM53115_A0_LPDET_CFGr_EN_LP_MIIf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_LPDET_CFGr_EN_LPDETf_GET(r) ((((r).lpdet_cfg[0]) >> 12) & 0x1)
#define BCM53115_A0_LPDET_CFGr_EN_LPDETf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53115_A0_LPDET_CFGr_EN_TXPASSf_GET(r) ((((r).lpdet_cfg[0]) >> 13) & 0x1)
#define BCM53115_A0_LPDET_CFGr_EN_TXPASSf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53115_A0_LPDET_CFGr_RESERVED_Rf_GET(r) ((((r).lpdet_cfg[0]) >> 14) & 0x3)
#define BCM53115_A0_LPDET_CFGr_RESERVED_Rf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access LPDET_CFG.
 *
 */
#define BCM53115_A0_READ_LPDET_CFGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LPDET_CFGr,(r._lpdet_cfg),2)
#define BCM53115_A0_WRITE_LPDET_CFGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LPDET_CFGr,&(r._lpdet_cfg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPDET_CFGr BCM53115_A0_LPDET_CFGr
#define LPDET_CFGr_SIZE BCM53115_A0_LPDET_CFGr_SIZE
typedef BCM53115_A0_LPDET_CFGr_t LPDET_CFGr_t;
#define LPDET_CFGr_CLR BCM53115_A0_LPDET_CFGr_CLR
#define LPDET_CFGr_SET BCM53115_A0_LPDET_CFGr_SET
#define LPDET_CFGr_GET BCM53115_A0_LPDET_CFGr_GET
#define LPDET_CFGr_DFQ_SELf_GET BCM53115_A0_LPDET_CFGr_DFQ_SELf_GET
#define LPDET_CFGr_DFQ_SELf_SET BCM53115_A0_LPDET_CFGr_DFQ_SELf_SET
#define LPDET_CFGr_OV_PAUSE_ONf_GET BCM53115_A0_LPDET_CFGr_OV_PAUSE_ONf_GET
#define LPDET_CFGr_OV_PAUSE_ONf_SET BCM53115_A0_LPDET_CFGr_OV_PAUSE_ONf_SET
#define LPDET_CFGr_LED_RST_CTLf_GET BCM53115_A0_LPDET_CFGr_LED_RST_CTLf_GET
#define LPDET_CFGr_LED_RST_CTLf_SET BCM53115_A0_LPDET_CFGr_LED_RST_CTLf_SET
#define LPDET_CFGr_EN_LP_MIIf_GET BCM53115_A0_LPDET_CFGr_EN_LP_MIIf_GET
#define LPDET_CFGr_EN_LP_MIIf_SET BCM53115_A0_LPDET_CFGr_EN_LP_MIIf_SET
#define LPDET_CFGr_EN_LPDETf_GET BCM53115_A0_LPDET_CFGr_EN_LPDETf_GET
#define LPDET_CFGr_EN_LPDETf_SET BCM53115_A0_LPDET_CFGr_EN_LPDETf_SET
#define LPDET_CFGr_EN_TXPASSf_GET BCM53115_A0_LPDET_CFGr_EN_TXPASSf_GET
#define LPDET_CFGr_EN_TXPASSf_SET BCM53115_A0_LPDET_CFGr_EN_TXPASSf_SET
#define LPDET_CFGr_RESERVED_Rf_GET BCM53115_A0_LPDET_CFGr_RESERVED_Rf_GET
#define LPDET_CFGr_RESERVED_Rf_SET BCM53115_A0_LPDET_CFGr_RESERVED_Rf_SET
#define READ_LPDET_CFGr BCM53115_A0_READ_LPDET_CFGr
#define WRITE_LPDET_CFGr BCM53115_A0_WRITE_LPDET_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LPDET_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LPDET_SA
 * BLOCKS:   SYS
 * DESC:     Loop Detect Frame SA Registers
 * SIZE:     48
 * FIELDS:
 *     LPDET_SA         
 *
 ******************************************************************************/
#define BCM53115_A0_LPDET_SAr 0x00007211

#define BCM53115_A0_LPDET_SAr_SIZE 6

/*
 * This structure should be used to declare and program LPDET_SA.
 *
 */
typedef union BCM53115_A0_LPDET_SAr_s {
	uint32_t v[2];
	uint32_t lpdet_sa[2];
	uint32_t _lpdet_sa;
} BCM53115_A0_LPDET_SAr_t;

#define BCM53115_A0_LPDET_SAr_CLR(r) CDK_MEMSET(&((r)._lpdet_sa), 0, sizeof(BCM53115_A0_LPDET_SAr_t))
#define BCM53115_A0_LPDET_SAr_SET(r,i,d) (r).lpdet_sa[i] = d
#define BCM53115_A0_LPDET_SAr_GET(r,i) (r).lpdet_sa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LPDET_SAr_LPDET_SAf_GET(r,a) cdk_field_get((r).lpdet_sa,0,47,a)
#define BCM53115_A0_LPDET_SAr_LPDET_SAf_SET(r,a) cdk_field_set((r).lpdet_sa,0,47,a)

/*
 * These macros can be used to access LPDET_SA.
 *
 */
#define BCM53115_A0_READ_LPDET_SAr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LPDET_SAr,(r._lpdet_sa),6)
#define BCM53115_A0_WRITE_LPDET_SAr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LPDET_SAr,&(r._lpdet_sa),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPDET_SAr BCM53115_A0_LPDET_SAr
#define LPDET_SAr_SIZE BCM53115_A0_LPDET_SAr_SIZE
typedef BCM53115_A0_LPDET_SAr_t LPDET_SAr_t;
#define LPDET_SAr_CLR BCM53115_A0_LPDET_SAr_CLR
#define LPDET_SAr_SET BCM53115_A0_LPDET_SAr_SET
#define LPDET_SAr_GET BCM53115_A0_LPDET_SAr_GET
#define LPDET_SAr_LPDET_SAf_GET BCM53115_A0_LPDET_SAr_LPDET_SAf_GET
#define LPDET_SAr_LPDET_SAf_SET BCM53115_A0_LPDET_SAr_LPDET_SAf_SET
#define READ_LPDET_SAr BCM53115_A0_READ_LPDET_SAr
#define WRITE_LPDET_SAr BCM53115_A0_WRITE_LPDET_SAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LPDET_SAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LSA_MII_PORT
 * BLOCKS:   SYS
 * DESC:     Last Source Address MII Port
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address Port nWhere :n=0-8 for 0-8 port.
 *
 ******************************************************************************/
#define BCM53115_A0_LSA_MII_PORTr 0x00000140

#define BCM53115_A0_LSA_MII_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_MII_PORT.
 *
 */
typedef union BCM53115_A0_LSA_MII_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_mii_port[2];
	uint32_t _lsa_mii_port;
} BCM53115_A0_LSA_MII_PORTr_t;

#define BCM53115_A0_LSA_MII_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_mii_port), 0, sizeof(BCM53115_A0_LSA_MII_PORTr_t))
#define BCM53115_A0_LSA_MII_PORTr_SET(r,i,d) (r).lsa_mii_port[i] = d
#define BCM53115_A0_LSA_MII_PORTr_GET(r,i) (r).lsa_mii_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LSA_MII_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_mii_port,0,47,a)
#define BCM53115_A0_LSA_MII_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_mii_port,0,47,a)

/*
 * These macros can be used to access LSA_MII_PORT.
 *
 */
#define BCM53115_A0_READ_LSA_MII_PORTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_LSA_MII_PORTr,(r._lsa_mii_port),6)
#define BCM53115_A0_WRITE_LSA_MII_PORTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_LSA_MII_PORTr,&(r._lsa_mii_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_MII_PORTr BCM53115_A0_LSA_MII_PORTr
#define LSA_MII_PORTr_SIZE BCM53115_A0_LSA_MII_PORTr_SIZE
typedef BCM53115_A0_LSA_MII_PORTr_t LSA_MII_PORTr_t;
#define LSA_MII_PORTr_CLR BCM53115_A0_LSA_MII_PORTr_CLR
#define LSA_MII_PORTr_SET BCM53115_A0_LSA_MII_PORTr_SET
#define LSA_MII_PORTr_GET BCM53115_A0_LSA_MII_PORTr_GET
#define LSA_MII_PORTr_LST_ADDRf_GET BCM53115_A0_LSA_MII_PORTr_LST_ADDRf_GET
#define LSA_MII_PORTr_LST_ADDRf_SET BCM53115_A0_LSA_MII_PORTr_LST_ADDRf_SET
#define READ_LSA_MII_PORTr BCM53115_A0_READ_LSA_MII_PORTr
#define WRITE_LSA_MII_PORTr BCM53115_A0_WRITE_LSA_MII_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LSA_MII_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  LSA_PORT
 * BLOCKS:   CPIC GPIC0
 * DESC:     Last Source Address Port X
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address Port nWhere :n=0-8 for 0-8 port.
 *
 ******************************************************************************/
#define BCM53115_A0_LSA_PORTr 0x00000110

#define BCM53115_A0_LSA_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_PORT.
 *
 */
typedef union BCM53115_A0_LSA_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_port[2];
	uint32_t _lsa_port;
} BCM53115_A0_LSA_PORTr_t;

#define BCM53115_A0_LSA_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_port), 0, sizeof(BCM53115_A0_LSA_PORTr_t))
#define BCM53115_A0_LSA_PORTr_SET(r,i,d) (r).lsa_port[i] = d
#define BCM53115_A0_LSA_PORTr_GET(r,i) (r).lsa_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_LSA_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_port,0,47,a)
#define BCM53115_A0_LSA_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_port,0,47,a)

/*
 * These macros can be used to access LSA_PORT.
 *
 */
#define BCM53115_A0_READ_LSA_PORTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_LSA_PORTr,(r._lsa_port),6)
#define BCM53115_A0_WRITE_LSA_PORTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_LSA_PORTr,&(r._lsa_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_PORTr BCM53115_A0_LSA_PORTr
#define LSA_PORTr_SIZE BCM53115_A0_LSA_PORTr_SIZE
typedef BCM53115_A0_LSA_PORTr_t LSA_PORTr_t;
#define LSA_PORTr_CLR BCM53115_A0_LSA_PORTr_CLR
#define LSA_PORTr_SET BCM53115_A0_LSA_PORTr_SET
#define LSA_PORTr_GET BCM53115_A0_LSA_PORTr_GET
#define LSA_PORTr_LST_ADDRf_GET BCM53115_A0_LSA_PORTr_LST_ADDRf_GET
#define LSA_PORTr_LST_ADDRf_SET BCM53115_A0_LSA_PORTr_LST_ADDRf_SET
#define READ_LSA_PORTr BCM53115_A0_READ_LSA_PORTr
#define WRITE_LSA_PORTr BCM53115_A0_WRITE_LSA_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_LSA_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MAC_TRUNK_CTL
 * BLOCKS:   SYS
 * DESC:     MAC Trunk Control Register
 * SIZE:     8
 * FIELDS:
 *     HASH_SEL         index selection00 : use hash DA ^ SA) to generate index. ( default=0 )01 : use hash(DA) to generate index.10 : Use hash (SA) to generate index.
 *     SERVER_0         Reserved
 *     EN_TRUNK_LOCAL   Enable Mac trunking .BCM5395  support 4 trunking groups. The trunking group can support up to 2 ports as defined trunking group register.
 *     SERVER_1         Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MAC_TRUNK_CTLr 0x00003200

#define BCM53115_A0_MAC_TRUNK_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MAC_TRUNK_CTL.
 *
 */
typedef union BCM53115_A0_MAC_TRUNK_CTLr_s {
	uint32_t v[1];
	uint32_t mac_trunk_ctl[1];
	uint32_t _mac_trunk_ctl;
} BCM53115_A0_MAC_TRUNK_CTLr_t;

#define BCM53115_A0_MAC_TRUNK_CTLr_CLR(r) (r).mac_trunk_ctl[0] = 0
#define BCM53115_A0_MAC_TRUNK_CTLr_SET(r,d) (r).mac_trunk_ctl[0] = d
#define BCM53115_A0_MAC_TRUNK_CTLr_GET(r) (r).mac_trunk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MAC_TRUNK_CTLr_HASH_SELf_GET(r) (((r).mac_trunk_ctl[0]) & 0x3)
#define BCM53115_A0_MAC_TRUNK_CTLr_HASH_SELf_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_MAC_TRUNK_CTLr_SERVER_0f_GET(r) ((((r).mac_trunk_ctl[0]) >> 2) & 0x1)
#define BCM53115_A0_MAC_TRUNK_CTLr_SERVER_0f_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET(r) ((((r).mac_trunk_ctl[0]) >> 3) & 0x1)
#define BCM53115_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_MAC_TRUNK_CTLr_SERVER_1f_GET(r) ((((r).mac_trunk_ctl[0]) >> 4) & 0xf)
#define BCM53115_A0_MAC_TRUNK_CTLr_SERVER_1f_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access MAC_TRUNK_CTL.
 *
 */
#define BCM53115_A0_READ_MAC_TRUNK_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MAC_TRUNK_CTLr,(r._mac_trunk_ctl),1)
#define BCM53115_A0_WRITE_MAC_TRUNK_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MAC_TRUNK_CTLr,&(r._mac_trunk_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TRUNK_CTLr BCM53115_A0_MAC_TRUNK_CTLr
#define MAC_TRUNK_CTLr_SIZE BCM53115_A0_MAC_TRUNK_CTLr_SIZE
typedef BCM53115_A0_MAC_TRUNK_CTLr_t MAC_TRUNK_CTLr_t;
#define MAC_TRUNK_CTLr_CLR BCM53115_A0_MAC_TRUNK_CTLr_CLR
#define MAC_TRUNK_CTLr_SET BCM53115_A0_MAC_TRUNK_CTLr_SET
#define MAC_TRUNK_CTLr_GET BCM53115_A0_MAC_TRUNK_CTLr_GET
#define MAC_TRUNK_CTLr_HASH_SELf_GET BCM53115_A0_MAC_TRUNK_CTLr_HASH_SELf_GET
#define MAC_TRUNK_CTLr_HASH_SELf_SET BCM53115_A0_MAC_TRUNK_CTLr_HASH_SELf_SET
#define MAC_TRUNK_CTLr_SERVER_0f_GET BCM53115_A0_MAC_TRUNK_CTLr_SERVER_0f_GET
#define MAC_TRUNK_CTLr_SERVER_0f_SET BCM53115_A0_MAC_TRUNK_CTLr_SERVER_0f_SET
#define MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET BCM53115_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET
#define MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET BCM53115_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET
#define MAC_TRUNK_CTLr_SERVER_1f_GET BCM53115_A0_MAC_TRUNK_CTLr_SERVER_1f_GET
#define MAC_TRUNK_CTLr_SERVER_1f_SET BCM53115_A0_MAC_TRUNK_CTLr_SERVER_1f_SET
#define READ_MAC_TRUNK_CTLr BCM53115_A0_READ_MAC_TRUNK_CTLr
#define WRITE_MAC_TRUNK_CTLr BCM53115_A0_WRITE_MAC_TRUNK_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MAC_TRUNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MAX_ICMPV4_SIZE_REG
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv4 Size Register
 * SIZE:     32
 * FIELDS:
 *     MAX_ICMPV4_SIZE  
 *
 ******************************************************************************/
#define BCM53115_A0_MAX_ICMPV4_SIZE_REGr 0x00003608

#define BCM53115_A0_MAX_ICMPV4_SIZE_REGr_SIZE 4

/*
 * This structure should be used to declare and program MAX_ICMPV4_SIZE_REG.
 *
 */
typedef union BCM53115_A0_MAX_ICMPV4_SIZE_REGr_s {
	uint32_t v[1];
	uint32_t max_icmpv4_size_reg[1];
	uint32_t _max_icmpv4_size_reg;
} BCM53115_A0_MAX_ICMPV4_SIZE_REGr_t;

#define BCM53115_A0_MAX_ICMPV4_SIZE_REGr_CLR(r) (r).max_icmpv4_size_reg[0] = 0
#define BCM53115_A0_MAX_ICMPV4_SIZE_REGr_SET(r,d) (r).max_icmpv4_size_reg[0] = d
#define BCM53115_A0_MAX_ICMPV4_SIZE_REGr_GET(r) (r).max_icmpv4_size_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET(r) ((r).max_icmpv4_size_reg[0])
#define BCM53115_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET(r,f) (r).max_icmpv4_size_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access MAX_ICMPV4_SIZE_REG.
 *
 */
#define BCM53115_A0_READ_MAX_ICMPV4_SIZE_REGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MAX_ICMPV4_SIZE_REGr,(r._max_icmpv4_size_reg),4)
#define BCM53115_A0_WRITE_MAX_ICMPV4_SIZE_REGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MAX_ICMPV4_SIZE_REGr,&(r._max_icmpv4_size_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV4_SIZE_REGr BCM53115_A0_MAX_ICMPV4_SIZE_REGr
#define MAX_ICMPV4_SIZE_REGr_SIZE BCM53115_A0_MAX_ICMPV4_SIZE_REGr_SIZE
typedef BCM53115_A0_MAX_ICMPV4_SIZE_REGr_t MAX_ICMPV4_SIZE_REGr_t;
#define MAX_ICMPV4_SIZE_REGr_CLR BCM53115_A0_MAX_ICMPV4_SIZE_REGr_CLR
#define MAX_ICMPV4_SIZE_REGr_SET BCM53115_A0_MAX_ICMPV4_SIZE_REGr_SET
#define MAX_ICMPV4_SIZE_REGr_GET BCM53115_A0_MAX_ICMPV4_SIZE_REGr_GET
#define MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET BCM53115_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET
#define MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET BCM53115_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET
#define READ_MAX_ICMPV4_SIZE_REGr BCM53115_A0_READ_MAX_ICMPV4_SIZE_REGr
#define WRITE_MAX_ICMPV4_SIZE_REGr BCM53115_A0_WRITE_MAX_ICMPV4_SIZE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MAX_ICMPV4_SIZE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MAX_ICMPV6_SIZE_REG
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv6 Size Register
 * SIZE:     32
 * FIELDS:
 *     MAX_ICMPV6_SIZE  
 *
 ******************************************************************************/
#define BCM53115_A0_MAX_ICMPV6_SIZE_REGr 0x0000360c

#define BCM53115_A0_MAX_ICMPV6_SIZE_REGr_SIZE 4

/*
 * This structure should be used to declare and program MAX_ICMPV6_SIZE_REG.
 *
 */
typedef union BCM53115_A0_MAX_ICMPV6_SIZE_REGr_s {
	uint32_t v[1];
	uint32_t max_icmpv6_size_reg[1];
	uint32_t _max_icmpv6_size_reg;
} BCM53115_A0_MAX_ICMPV6_SIZE_REGr_t;

#define BCM53115_A0_MAX_ICMPV6_SIZE_REGr_CLR(r) (r).max_icmpv6_size_reg[0] = 0
#define BCM53115_A0_MAX_ICMPV6_SIZE_REGr_SET(r,d) (r).max_icmpv6_size_reg[0] = d
#define BCM53115_A0_MAX_ICMPV6_SIZE_REGr_GET(r) (r).max_icmpv6_size_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET(r) ((r).max_icmpv6_size_reg[0])
#define BCM53115_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET(r,f) (r).max_icmpv6_size_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access MAX_ICMPV6_SIZE_REG.
 *
 */
#define BCM53115_A0_READ_MAX_ICMPV6_SIZE_REGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MAX_ICMPV6_SIZE_REGr,(r._max_icmpv6_size_reg),4)
#define BCM53115_A0_WRITE_MAX_ICMPV6_SIZE_REGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MAX_ICMPV6_SIZE_REGr,&(r._max_icmpv6_size_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV6_SIZE_REGr BCM53115_A0_MAX_ICMPV6_SIZE_REGr
#define MAX_ICMPV6_SIZE_REGr_SIZE BCM53115_A0_MAX_ICMPV6_SIZE_REGr_SIZE
typedef BCM53115_A0_MAX_ICMPV6_SIZE_REGr_t MAX_ICMPV6_SIZE_REGr_t;
#define MAX_ICMPV6_SIZE_REGr_CLR BCM53115_A0_MAX_ICMPV6_SIZE_REGr_CLR
#define MAX_ICMPV6_SIZE_REGr_SET BCM53115_A0_MAX_ICMPV6_SIZE_REGr_SET
#define MAX_ICMPV6_SIZE_REGr_GET BCM53115_A0_MAX_ICMPV6_SIZE_REGr_GET
#define MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET BCM53115_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET
#define MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET BCM53115_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET
#define READ_MAX_ICMPV6_SIZE_REGr BCM53115_A0_READ_MAX_ICMPV6_SIZE_REGr
#define WRITE_MAX_ICMPV6_SIZE_REGr BCM53115_A0_WRITE_MAX_ICMPV6_SIZE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MAX_ICMPV6_SIZE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MDIO_ADDR_P8
 * BLOCKS:   SYS
 * DESC:     MDIO Port 8 Address Registrer
 * SIZE:     8
 * FIELDS:
 *     ADDR_P8          Port 8 MDIO Scan ADDRESS.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MDIO_ADDR_P8r 0x00000078

#define BCM53115_A0_MDIO_ADDR_P8r_SIZE 1

/*
 * This structure should be used to declare and program MDIO_ADDR_P8.
 *
 */
typedef union BCM53115_A0_MDIO_ADDR_P8r_s {
	uint32_t v[1];
	uint32_t mdio_addr_p8[1];
	uint32_t _mdio_addr_p8;
} BCM53115_A0_MDIO_ADDR_P8r_t;

#define BCM53115_A0_MDIO_ADDR_P8r_CLR(r) (r).mdio_addr_p8[0] = 0
#define BCM53115_A0_MDIO_ADDR_P8r_SET(r,d) (r).mdio_addr_p8[0] = d
#define BCM53115_A0_MDIO_ADDR_P8r_GET(r) (r).mdio_addr_p8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MDIO_ADDR_P8r_ADDR_P8f_GET(r) (((r).mdio_addr_p8[0]) & 0x1f)
#define BCM53115_A0_MDIO_ADDR_P8r_ADDR_P8f_SET(r,f) (r).mdio_addr_p8[0]=(((r).mdio_addr_p8[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_MDIO_ADDR_P8r_RESERVED_Rf_GET(r) ((((r).mdio_addr_p8[0]) >> 5) & 0x7)
#define BCM53115_A0_MDIO_ADDR_P8r_RESERVED_Rf_SET(r,f) (r).mdio_addr_p8[0]=(((r).mdio_addr_p8[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_ADDR_P8.
 *
 */
#define BCM53115_A0_READ_MDIO_ADDR_P8r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MDIO_ADDR_P8r,(r._mdio_addr_p8),1)
#define BCM53115_A0_WRITE_MDIO_ADDR_P8r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MDIO_ADDR_P8r,&(r._mdio_addr_p8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_ADDR_P8r BCM53115_A0_MDIO_ADDR_P8r
#define MDIO_ADDR_P8r_SIZE BCM53115_A0_MDIO_ADDR_P8r_SIZE
typedef BCM53115_A0_MDIO_ADDR_P8r_t MDIO_ADDR_P8r_t;
#define MDIO_ADDR_P8r_CLR BCM53115_A0_MDIO_ADDR_P8r_CLR
#define MDIO_ADDR_P8r_SET BCM53115_A0_MDIO_ADDR_P8r_SET
#define MDIO_ADDR_P8r_GET BCM53115_A0_MDIO_ADDR_P8r_GET
#define MDIO_ADDR_P8r_ADDR_P8f_GET BCM53115_A0_MDIO_ADDR_P8r_ADDR_P8f_GET
#define MDIO_ADDR_P8r_ADDR_P8f_SET BCM53115_A0_MDIO_ADDR_P8r_ADDR_P8f_SET
#define MDIO_ADDR_P8r_RESERVED_Rf_GET BCM53115_A0_MDIO_ADDR_P8r_RESERVED_Rf_GET
#define MDIO_ADDR_P8r_RESERVED_Rf_SET BCM53115_A0_MDIO_ADDR_P8r_RESERVED_Rf_SET
#define READ_MDIO_ADDR_P8r BCM53115_A0_READ_MDIO_ADDR_P8r
#define WRITE_MDIO_ADDR_P8r BCM53115_A0_WRITE_MDIO_ADDR_P8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MDIO_ADDR_P8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MDIO_ADDR_WAN
 * BLOCKS:   SYS
 * DESC:     MDIO WAN Port Address Registrer
 * SIZE:     8
 * FIELDS:
 *     ADDR_WAN         Wan-Port MDIO Scan ADDRESS (valid for 5397 only).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MDIO_ADDR_WANr 0x00000075

#define BCM53115_A0_MDIO_ADDR_WANr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_ADDR_WAN.
 *
 */
typedef union BCM53115_A0_MDIO_ADDR_WANr_s {
	uint32_t v[1];
	uint32_t mdio_addr_wan[1];
	uint32_t _mdio_addr_wan;
} BCM53115_A0_MDIO_ADDR_WANr_t;

#define BCM53115_A0_MDIO_ADDR_WANr_CLR(r) (r).mdio_addr_wan[0] = 0
#define BCM53115_A0_MDIO_ADDR_WANr_SET(r,d) (r).mdio_addr_wan[0] = d
#define BCM53115_A0_MDIO_ADDR_WANr_GET(r) (r).mdio_addr_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MDIO_ADDR_WANr_ADDR_WANf_GET(r) (((r).mdio_addr_wan[0]) & 0x1f)
#define BCM53115_A0_MDIO_ADDR_WANr_ADDR_WANf_SET(r,f) (r).mdio_addr_wan[0]=(((r).mdio_addr_wan[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_MDIO_ADDR_WANr_RESERVED_Rf_GET(r) ((((r).mdio_addr_wan[0]) >> 5) & 0x7)
#define BCM53115_A0_MDIO_ADDR_WANr_RESERVED_Rf_SET(r,f) (r).mdio_addr_wan[0]=(((r).mdio_addr_wan[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_ADDR_WAN.
 *
 */
#define BCM53115_A0_READ_MDIO_ADDR_WANr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MDIO_ADDR_WANr,(r._mdio_addr_wan),1)
#define BCM53115_A0_WRITE_MDIO_ADDR_WANr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MDIO_ADDR_WANr,&(r._mdio_addr_wan),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_ADDR_WANr BCM53115_A0_MDIO_ADDR_WANr
#define MDIO_ADDR_WANr_SIZE BCM53115_A0_MDIO_ADDR_WANr_SIZE
typedef BCM53115_A0_MDIO_ADDR_WANr_t MDIO_ADDR_WANr_t;
#define MDIO_ADDR_WANr_CLR BCM53115_A0_MDIO_ADDR_WANr_CLR
#define MDIO_ADDR_WANr_SET BCM53115_A0_MDIO_ADDR_WANr_SET
#define MDIO_ADDR_WANr_GET BCM53115_A0_MDIO_ADDR_WANr_GET
#define MDIO_ADDR_WANr_ADDR_WANf_GET BCM53115_A0_MDIO_ADDR_WANr_ADDR_WANf_GET
#define MDIO_ADDR_WANr_ADDR_WANf_SET BCM53115_A0_MDIO_ADDR_WANr_ADDR_WANf_SET
#define MDIO_ADDR_WANr_RESERVED_Rf_GET BCM53115_A0_MDIO_ADDR_WANr_RESERVED_Rf_GET
#define MDIO_ADDR_WANr_RESERVED_Rf_SET BCM53115_A0_MDIO_ADDR_WANr_RESERVED_Rf_SET
#define READ_MDIO_ADDR_WANr BCM53115_A0_READ_MDIO_ADDR_WANr
#define WRITE_MDIO_ADDR_WANr BCM53115_A0_WRITE_MDIO_ADDR_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MDIO_ADDR_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_ADDR
 * BLOCKS:   SYS
 * DESC:     Memory Debug Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     MEM_RW           '1' causes a read operation while '0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the Debugged memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_ADDRr 0x00000801

#define BCM53115_A0_MEM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR.
 *
 */
typedef union BCM53115_A0_MEM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_addr[1];
	uint32_t _mem_addr;
} BCM53115_A0_MEM_ADDRr_t;

#define BCM53115_A0_MEM_ADDRr_CLR(r) (r).mem_addr[0] = 0
#define BCM53115_A0_MEM_ADDRr_SET(r,d) (r).mem_addr[0] = d
#define BCM53115_A0_MEM_ADDRr_GET(r) (r).mem_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_ADDRr_MEM_ADRf_GET(r) (((r).mem_addr[0]) & 0x3fff)
#define BCM53115_A0_MEM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53115_A0_MEM_ADDRr_MEM_RWf_GET(r) ((((r).mem_addr[0]) >> 14) & 0x1)
#define BCM53115_A0_MEM_ADDRr_MEM_RWf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_MEM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_addr[0]) >> 15) & 0x1)
#define BCM53115_A0_MEM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_ADDR.
 *
 */
#define BCM53115_A0_READ_MEM_ADDRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_ADDRr,(r._mem_addr),2)
#define BCM53115_A0_WRITE_MEM_ADDRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_ADDRr,&(r._mem_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDRr BCM53115_A0_MEM_ADDRr
#define MEM_ADDRr_SIZE BCM53115_A0_MEM_ADDRr_SIZE
typedef BCM53115_A0_MEM_ADDRr_t MEM_ADDRr_t;
#define MEM_ADDRr_CLR BCM53115_A0_MEM_ADDRr_CLR
#define MEM_ADDRr_SET BCM53115_A0_MEM_ADDRr_SET
#define MEM_ADDRr_GET BCM53115_A0_MEM_ADDRr_GET
#define MEM_ADDRr_MEM_ADRf_GET BCM53115_A0_MEM_ADDRr_MEM_ADRf_GET
#define MEM_ADDRr_MEM_ADRf_SET BCM53115_A0_MEM_ADDRr_MEM_ADRf_SET
#define MEM_ADDRr_MEM_RWf_GET BCM53115_A0_MEM_ADDRr_MEM_RWf_GET
#define MEM_ADDRr_MEM_RWf_SET BCM53115_A0_MEM_ADDRr_MEM_RWf_SET
#define MEM_ADDRr_MEM_STDNf_GET BCM53115_A0_MEM_ADDRr_MEM_STDNf_GET
#define MEM_ADDRr_MEM_STDNf_SET BCM53115_A0_MEM_ADDRr_MEM_STDNf_SET
#define READ_MEM_ADDRr BCM53115_A0_READ_MEM_ADDRr
#define WRITE_MEM_ADDRr BCM53115_A0_WRITE_MEM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_BFC_ADDR
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     BFC_ADDR         Specifies the next memmory address to read or write.
 *     RW_CTRL          '1' causes read operation while '0' is for write operation.
 *     MEM_REQ          Initiates the read/write operation for the Buffer Control memmory.The bit will clear one the Read/write Operation is completed.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_BFC_ADDRr 0x00000860

#define BCM53115_A0_MEM_BFC_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_BFC_ADDR.
 *
 */
typedef union BCM53115_A0_MEM_BFC_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_bfc_addr[1];
	uint32_t _mem_bfc_addr;
} BCM53115_A0_MEM_BFC_ADDRr_t;

#define BCM53115_A0_MEM_BFC_ADDRr_CLR(r) (r).mem_bfc_addr[0] = 0
#define BCM53115_A0_MEM_BFC_ADDRr_SET(r,d) (r).mem_bfc_addr[0] = d
#define BCM53115_A0_MEM_BFC_ADDRr_GET(r) (r).mem_bfc_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET(r) (((r).mem_bfc_addr[0]) & 0x3fff)
#define BCM53115_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53115_A0_MEM_BFC_ADDRr_RW_CTRLf_GET(r) ((((r).mem_bfc_addr[0]) >> 14) & 0x1)
#define BCM53115_A0_MEM_BFC_ADDRr_RW_CTRLf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_MEM_BFC_ADDRr_MEM_REQf_GET(r) ((((r).mem_bfc_addr[0]) >> 15) & 0x1)
#define BCM53115_A0_MEM_BFC_ADDRr_MEM_REQf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_BFC_ADDR.
 *
 */
#define BCM53115_A0_READ_MEM_BFC_ADDRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_BFC_ADDRr,(r._mem_bfc_addr),2)
#define BCM53115_A0_WRITE_MEM_BFC_ADDRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_BFC_ADDRr,&(r._mem_bfc_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_ADDRr BCM53115_A0_MEM_BFC_ADDRr
#define MEM_BFC_ADDRr_SIZE BCM53115_A0_MEM_BFC_ADDRr_SIZE
typedef BCM53115_A0_MEM_BFC_ADDRr_t MEM_BFC_ADDRr_t;
#define MEM_BFC_ADDRr_CLR BCM53115_A0_MEM_BFC_ADDRr_CLR
#define MEM_BFC_ADDRr_SET BCM53115_A0_MEM_BFC_ADDRr_SET
#define MEM_BFC_ADDRr_GET BCM53115_A0_MEM_BFC_ADDRr_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_GET BCM53115_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_SET BCM53115_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET
#define MEM_BFC_ADDRr_RW_CTRLf_GET BCM53115_A0_MEM_BFC_ADDRr_RW_CTRLf_GET
#define MEM_BFC_ADDRr_RW_CTRLf_SET BCM53115_A0_MEM_BFC_ADDRr_RW_CTRLf_SET
#define MEM_BFC_ADDRr_MEM_REQf_GET BCM53115_A0_MEM_BFC_ADDRr_MEM_REQf_GET
#define MEM_BFC_ADDRr_MEM_REQf_SET BCM53115_A0_MEM_BFC_ADDRr_MEM_REQf_SET
#define READ_MEM_BFC_ADDRr BCM53115_A0_READ_MEM_BFC_ADDRr
#define WRITE_MEM_BFC_ADDRr BCM53115_A0_WRITE_MEM_BFC_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_BFC_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_BFC_DATA
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Data Register
 * SIZE:     64
 * FIELDS:
 *     BFC_DATA         Privides the read from the Buffer Control memmory[63:0].
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_BFC_DATAr 0x00000862

#define BCM53115_A0_MEM_BFC_DATAr_SIZE 8

/*
 * This structure should be used to declare and program MEM_BFC_DATA.
 *
 */
typedef union BCM53115_A0_MEM_BFC_DATAr_s {
	uint32_t v[2];
	uint32_t mem_bfc_data[2];
	uint32_t _mem_bfc_data;
} BCM53115_A0_MEM_BFC_DATAr_t;

#define BCM53115_A0_MEM_BFC_DATAr_CLR(r) CDK_MEMSET(&((r)._mem_bfc_data), 0, sizeof(BCM53115_A0_MEM_BFC_DATAr_t))
#define BCM53115_A0_MEM_BFC_DATAr_SET(r,i,d) (r).mem_bfc_data[i] = d
#define BCM53115_A0_MEM_BFC_DATAr_GET(r,i) (r).mem_bfc_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_BFC_DATAr_BFC_DATAf_GET(r,a) cdk_field_get((r).mem_bfc_data,0,63,a)
#define BCM53115_A0_MEM_BFC_DATAr_BFC_DATAf_SET(r,a) cdk_field_set((r).mem_bfc_data,0,63,a)

/*
 * These macros can be used to access MEM_BFC_DATA.
 *
 */
#define BCM53115_A0_READ_MEM_BFC_DATAr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_BFC_DATAr,(r._mem_bfc_data),8)
#define BCM53115_A0_WRITE_MEM_BFC_DATAr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_BFC_DATAr,&(r._mem_bfc_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_DATAr BCM53115_A0_MEM_BFC_DATAr
#define MEM_BFC_DATAr_SIZE BCM53115_A0_MEM_BFC_DATAr_SIZE
typedef BCM53115_A0_MEM_BFC_DATAr_t MEM_BFC_DATAr_t;
#define MEM_BFC_DATAr_CLR BCM53115_A0_MEM_BFC_DATAr_CLR
#define MEM_BFC_DATAr_SET BCM53115_A0_MEM_BFC_DATAr_SET
#define MEM_BFC_DATAr_GET BCM53115_A0_MEM_BFC_DATAr_GET
#define MEM_BFC_DATAr_BFC_DATAf_GET BCM53115_A0_MEM_BFC_DATAr_BFC_DATAf_GET
#define MEM_BFC_DATAr_BFC_DATAf_SET BCM53115_A0_MEM_BFC_DATAr_BFC_DATAf_SET
#define READ_MEM_BFC_DATAr BCM53115_A0_READ_MEM_BFC_DATAr
#define WRITE_MEM_BFC_DATAr BCM53115_A0_WRITE_MEM_BFC_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_BFC_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_BTM_DATA0
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register 0
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[63:0]Note: Buffer Tag Memory Register Only For Read.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_BTM_DATA0r 0x00000850

#define BCM53115_A0_MEM_BTM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_BTM_DATA0.
 *
 */
typedef union BCM53115_A0_MEM_BTM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_btm_data0[2];
	uint32_t _mem_btm_data0;
} BCM53115_A0_MEM_BTM_DATA0r_t;

#define BCM53115_A0_MEM_BTM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_btm_data0), 0, sizeof(BCM53115_A0_MEM_BTM_DATA0r_t))
#define BCM53115_A0_MEM_BTM_DATA0r_SET(r,i,d) (r).mem_btm_data0[i] = d
#define BCM53115_A0_MEM_BTM_DATA0r_GET(r,i) (r).mem_btm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_BTM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_btm_data0,0,63,a)
#define BCM53115_A0_MEM_BTM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_btm_data0,0,63,a)

/*
 * These macros can be used to access MEM_BTM_DATA0.
 *
 */
#define BCM53115_A0_READ_MEM_BTM_DATA0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_BTM_DATA0r,(r._mem_btm_data0),8)
#define BCM53115_A0_WRITE_MEM_BTM_DATA0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_BTM_DATA0r,&(r._mem_btm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATA0r BCM53115_A0_MEM_BTM_DATA0r
#define MEM_BTM_DATA0r_SIZE BCM53115_A0_MEM_BTM_DATA0r_SIZE
typedef BCM53115_A0_MEM_BTM_DATA0r_t MEM_BTM_DATA0r_t;
#define MEM_BTM_DATA0r_CLR BCM53115_A0_MEM_BTM_DATA0r_CLR
#define MEM_BTM_DATA0r_SET BCM53115_A0_MEM_BTM_DATA0r_SET
#define MEM_BTM_DATA0r_GET BCM53115_A0_MEM_BTM_DATA0r_GET
#define MEM_BTM_DATA0r_MEM_DATAf_GET BCM53115_A0_MEM_BTM_DATA0r_MEM_DATAf_GET
#define MEM_BTM_DATA0r_MEM_DATAf_SET BCM53115_A0_MEM_BTM_DATA0r_MEM_DATAf_SET
#define READ_MEM_BTM_DATA0r BCM53115_A0_READ_MEM_BTM_DATA0r
#define WRITE_MEM_BTM_DATA0r BCM53115_A0_WRITE_MEM_BTM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_BTM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_BTM_DATA1
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register 1
 * SIZE:     8
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[71:64]Note: Buffer Tag Memory Register Only For Read.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_BTM_DATA1r 0x00000858

#define BCM53115_A0_MEM_BTM_DATA1r_SIZE 1

/*
 * This structure should be used to declare and program MEM_BTM_DATA1.
 *
 */
typedef union BCM53115_A0_MEM_BTM_DATA1r_s {
	uint32_t v[1];
	uint32_t mem_btm_data1[1];
	uint32_t _mem_btm_data1;
} BCM53115_A0_MEM_BTM_DATA1r_t;

#define BCM53115_A0_MEM_BTM_DATA1r_CLR(r) (r).mem_btm_data1[0] = 0
#define BCM53115_A0_MEM_BTM_DATA1r_SET(r,d) (r).mem_btm_data1[0] = d
#define BCM53115_A0_MEM_BTM_DATA1r_GET(r) (r).mem_btm_data1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_BTM_DATA1r_MEM_DATAf_GET(r) (((r).mem_btm_data1[0]) & 0xff)
#define BCM53115_A0_MEM_BTM_DATA1r_MEM_DATAf_SET(r,f) (r).mem_btm_data1[0]=(((r).mem_btm_data1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MEM_BTM_DATA1.
 *
 */
#define BCM53115_A0_READ_MEM_BTM_DATA1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_BTM_DATA1r,(r._mem_btm_data1),1)
#define BCM53115_A0_WRITE_MEM_BTM_DATA1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_BTM_DATA1r,&(r._mem_btm_data1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATA1r BCM53115_A0_MEM_BTM_DATA1r
#define MEM_BTM_DATA1r_SIZE BCM53115_A0_MEM_BTM_DATA1r_SIZE
typedef BCM53115_A0_MEM_BTM_DATA1r_t MEM_BTM_DATA1r_t;
#define MEM_BTM_DATA1r_CLR BCM53115_A0_MEM_BTM_DATA1r_CLR
#define MEM_BTM_DATA1r_SET BCM53115_A0_MEM_BTM_DATA1r_SET
#define MEM_BTM_DATA1r_GET BCM53115_A0_MEM_BTM_DATA1r_GET
#define MEM_BTM_DATA1r_MEM_DATAf_GET BCM53115_A0_MEM_BTM_DATA1r_MEM_DATAf_GET
#define MEM_BTM_DATA1r_MEM_DATAf_SET BCM53115_A0_MEM_BTM_DATA1r_MEM_DATAf_SET
#define READ_MEM_BTM_DATA1r BCM53115_A0_READ_MEM_BTM_DATA1r
#define WRITE_MEM_BTM_DATA1r BCM53115_A0_WRITE_MEM_BTM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_BTM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     RESERVED_1R      Reserved
 *     MEM_TYPE         Indicate the memory for the Debugged memory.10 : VLAN Memory,11 : ARL Memory.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_CTRLr 0x00000800

#define BCM53115_A0_MEM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program MEM_CTRL.
 *
 */
typedef union BCM53115_A0_MEM_CTRLr_s {
	uint32_t v[1];
	uint32_t mem_ctrl[1];
	uint32_t _mem_ctrl;
} BCM53115_A0_MEM_CTRLr_t;

#define BCM53115_A0_MEM_CTRLr_CLR(r) (r).mem_ctrl[0] = 0
#define BCM53115_A0_MEM_CTRLr_SET(r,d) (r).mem_ctrl[0] = d
#define BCM53115_A0_MEM_CTRLr_GET(r) (r).mem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_CTRLr_RESERVED_0Rf_GET(r) (((r).mem_ctrl[0]) & 0xf)
#define BCM53115_A0_MEM_CTRLr_RESERVED_0Rf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_MEM_CTRLr_RESERVED_1Rf_GET(r) ((((r).mem_ctrl[0]) >> 4) & 0x3)
#define BCM53115_A0_MEM_CTRLr_RESERVED_1Rf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53115_A0_MEM_CTRLr_MEM_TYPEf_GET(r) ((((r).mem_ctrl[0]) >> 6) & 0x3)
#define BCM53115_A0_MEM_CTRLr_MEM_TYPEf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MEM_CTRL.
 *
 */
#define BCM53115_A0_READ_MEM_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_CTRLr,(r._mem_ctrl),1)
#define BCM53115_A0_WRITE_MEM_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_CTRLr,&(r._mem_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_CTRLr BCM53115_A0_MEM_CTRLr
#define MEM_CTRLr_SIZE BCM53115_A0_MEM_CTRLr_SIZE
typedef BCM53115_A0_MEM_CTRLr_t MEM_CTRLr_t;
#define MEM_CTRLr_CLR BCM53115_A0_MEM_CTRLr_CLR
#define MEM_CTRLr_SET BCM53115_A0_MEM_CTRLr_SET
#define MEM_CTRLr_GET BCM53115_A0_MEM_CTRLr_GET
#define MEM_CTRLr_RESERVED_0Rf_GET BCM53115_A0_MEM_CTRLr_RESERVED_0Rf_GET
#define MEM_CTRLr_RESERVED_0Rf_SET BCM53115_A0_MEM_CTRLr_RESERVED_0Rf_SET
#define MEM_CTRLr_RESERVED_1Rf_GET BCM53115_A0_MEM_CTRLr_RESERVED_1Rf_GET
#define MEM_CTRLr_RESERVED_1Rf_SET BCM53115_A0_MEM_CTRLr_RESERVED_1Rf_SET
#define MEM_CTRLr_MEM_TYPEf_GET BCM53115_A0_MEM_CTRLr_MEM_TYPEf_GET
#define MEM_CTRLr_MEM_TYPEf_SET BCM53115_A0_MEM_CTRLr_MEM_TYPEf_SET
#define READ_MEM_CTRLr BCM53115_A0_READ_MEM_CTRLr
#define WRITE_MEM_CTRLr BCM53115_A0_WRITE_MEM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_DEBUG_DATA_0_0
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 0_0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory [63:0]Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_DEBUG_DATA_0_0r 0x00000808

#define BCM53115_A0_MEM_DEBUG_DATA_0_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_0_0.
 *
 */
typedef union BCM53115_A0_MEM_DEBUG_DATA_0_0r_s {
	uint32_t v[2];
	uint32_t mem_debug_data_0_0[2];
	uint32_t _mem_debug_data_0_0;
} BCM53115_A0_MEM_DEBUG_DATA_0_0r_t;

#define BCM53115_A0_MEM_DEBUG_DATA_0_0r_CLR(r) CDK_MEMSET(&((r)._mem_debug_data_0_0), 0, sizeof(BCM53115_A0_MEM_DEBUG_DATA_0_0r_t))
#define BCM53115_A0_MEM_DEBUG_DATA_0_0r_SET(r,i,d) (r).mem_debug_data_0_0[i] = d
#define BCM53115_A0_MEM_DEBUG_DATA_0_0r_GET(r,i) (r).mem_debug_data_0_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_GET(r,a) cdk_field_get((r).mem_debug_data_0_0,0,63,a)
#define BCM53115_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_SET(r,a) cdk_field_set((r).mem_debug_data_0_0,0,63,a)

/*
 * These macros can be used to access MEM_DEBUG_DATA_0_0.
 *
 */
#define BCM53115_A0_READ_MEM_DEBUG_DATA_0_0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_DEBUG_DATA_0_0r,(r._mem_debug_data_0_0),8)
#define BCM53115_A0_WRITE_MEM_DEBUG_DATA_0_0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_DEBUG_DATA_0_0r,&(r._mem_debug_data_0_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_0_0r BCM53115_A0_MEM_DEBUG_DATA_0_0r
#define MEM_DEBUG_DATA_0_0r_SIZE BCM53115_A0_MEM_DEBUG_DATA_0_0r_SIZE
typedef BCM53115_A0_MEM_DEBUG_DATA_0_0r_t MEM_DEBUG_DATA_0_0r_t;
#define MEM_DEBUG_DATA_0_0r_CLR BCM53115_A0_MEM_DEBUG_DATA_0_0r_CLR
#define MEM_DEBUG_DATA_0_0r_SET BCM53115_A0_MEM_DEBUG_DATA_0_0r_SET
#define MEM_DEBUG_DATA_0_0r_GET BCM53115_A0_MEM_DEBUG_DATA_0_0r_GET
#define MEM_DEBUG_DATA_0_0r_MEM_DATf_GET BCM53115_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_GET
#define MEM_DEBUG_DATA_0_0r_MEM_DATf_SET BCM53115_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_0_0r BCM53115_A0_READ_MEM_DEBUG_DATA_0_0r
#define WRITE_MEM_DEBUG_DATA_0_0r BCM53115_A0_WRITE_MEM_DEBUG_DATA_0_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_DEBUG_DATA_0_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_DEBUG_DATA_0_1
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 0_1 Register
 * SIZE:     16
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory[75:64]Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_DEBUG_DATA_0_1r 0x00000810

#define BCM53115_A0_MEM_DEBUG_DATA_0_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_0_1.
 *
 */
typedef union BCM53115_A0_MEM_DEBUG_DATA_0_1r_s {
	uint32_t v[1];
	uint32_t mem_debug_data_0_1[1];
	uint32_t _mem_debug_data_0_1;
} BCM53115_A0_MEM_DEBUG_DATA_0_1r_t;

#define BCM53115_A0_MEM_DEBUG_DATA_0_1r_CLR(r) (r).mem_debug_data_0_1[0] = 0
#define BCM53115_A0_MEM_DEBUG_DATA_0_1r_SET(r,d) (r).mem_debug_data_0_1[0] = d
#define BCM53115_A0_MEM_DEBUG_DATA_0_1r_GET(r) (r).mem_debug_data_0_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_GET(r) (((r).mem_debug_data_0_1[0]) & 0xffff)
#define BCM53115_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_SET(r,f) (r).mem_debug_data_0_1[0]=(((r).mem_debug_data_0_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_DEBUG_DATA_0_1.
 *
 */
#define BCM53115_A0_READ_MEM_DEBUG_DATA_0_1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_DEBUG_DATA_0_1r,(r._mem_debug_data_0_1),2)
#define BCM53115_A0_WRITE_MEM_DEBUG_DATA_0_1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_DEBUG_DATA_0_1r,&(r._mem_debug_data_0_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_0_1r BCM53115_A0_MEM_DEBUG_DATA_0_1r
#define MEM_DEBUG_DATA_0_1r_SIZE BCM53115_A0_MEM_DEBUG_DATA_0_1r_SIZE
typedef BCM53115_A0_MEM_DEBUG_DATA_0_1r_t MEM_DEBUG_DATA_0_1r_t;
#define MEM_DEBUG_DATA_0_1r_CLR BCM53115_A0_MEM_DEBUG_DATA_0_1r_CLR
#define MEM_DEBUG_DATA_0_1r_SET BCM53115_A0_MEM_DEBUG_DATA_0_1r_SET
#define MEM_DEBUG_DATA_0_1r_GET BCM53115_A0_MEM_DEBUG_DATA_0_1r_GET
#define MEM_DEBUG_DATA_0_1r_MEM_DATf_GET BCM53115_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_GET
#define MEM_DEBUG_DATA_0_1r_MEM_DATf_SET BCM53115_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_0_1r BCM53115_A0_READ_MEM_DEBUG_DATA_0_1r
#define WRITE_MEM_DEBUG_DATA_0_1r BCM53115_A0_WRITE_MEM_DEBUG_DATA_0_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_DEBUG_DATA_0_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_DEBUG_DATA_1_0
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 1_0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory [63:0]Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_DEBUG_DATA_1_0r 0x00000812

#define BCM53115_A0_MEM_DEBUG_DATA_1_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_1_0.
 *
 */
typedef union BCM53115_A0_MEM_DEBUG_DATA_1_0r_s {
	uint32_t v[2];
	uint32_t mem_debug_data_1_0[2];
	uint32_t _mem_debug_data_1_0;
} BCM53115_A0_MEM_DEBUG_DATA_1_0r_t;

#define BCM53115_A0_MEM_DEBUG_DATA_1_0r_CLR(r) CDK_MEMSET(&((r)._mem_debug_data_1_0), 0, sizeof(BCM53115_A0_MEM_DEBUG_DATA_1_0r_t))
#define BCM53115_A0_MEM_DEBUG_DATA_1_0r_SET(r,i,d) (r).mem_debug_data_1_0[i] = d
#define BCM53115_A0_MEM_DEBUG_DATA_1_0r_GET(r,i) (r).mem_debug_data_1_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_GET(r,a) cdk_field_get((r).mem_debug_data_1_0,0,63,a)
#define BCM53115_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_SET(r,a) cdk_field_set((r).mem_debug_data_1_0,0,63,a)

/*
 * These macros can be used to access MEM_DEBUG_DATA_1_0.
 *
 */
#define BCM53115_A0_READ_MEM_DEBUG_DATA_1_0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_DEBUG_DATA_1_0r,(r._mem_debug_data_1_0),8)
#define BCM53115_A0_WRITE_MEM_DEBUG_DATA_1_0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_DEBUG_DATA_1_0r,&(r._mem_debug_data_1_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_1_0r BCM53115_A0_MEM_DEBUG_DATA_1_0r
#define MEM_DEBUG_DATA_1_0r_SIZE BCM53115_A0_MEM_DEBUG_DATA_1_0r_SIZE
typedef BCM53115_A0_MEM_DEBUG_DATA_1_0r_t MEM_DEBUG_DATA_1_0r_t;
#define MEM_DEBUG_DATA_1_0r_CLR BCM53115_A0_MEM_DEBUG_DATA_1_0r_CLR
#define MEM_DEBUG_DATA_1_0r_SET BCM53115_A0_MEM_DEBUG_DATA_1_0r_SET
#define MEM_DEBUG_DATA_1_0r_GET BCM53115_A0_MEM_DEBUG_DATA_1_0r_GET
#define MEM_DEBUG_DATA_1_0r_MEM_DATf_GET BCM53115_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_GET
#define MEM_DEBUG_DATA_1_0r_MEM_DATf_SET BCM53115_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_1_0r BCM53115_A0_READ_MEM_DEBUG_DATA_1_0r
#define WRITE_MEM_DEBUG_DATA_1_0r BCM53115_A0_WRITE_MEM_DEBUG_DATA_1_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_DEBUG_DATA_1_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_DEBUG_DATA_1_1
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 1_1 Register
 * SIZE:     16
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory[75:64]Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_DEBUG_DATA_1_1r 0x0000081a

#define BCM53115_A0_MEM_DEBUG_DATA_1_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_1_1.
 *
 */
typedef union BCM53115_A0_MEM_DEBUG_DATA_1_1r_s {
	uint32_t v[1];
	uint32_t mem_debug_data_1_1[1];
	uint32_t _mem_debug_data_1_1;
} BCM53115_A0_MEM_DEBUG_DATA_1_1r_t;

#define BCM53115_A0_MEM_DEBUG_DATA_1_1r_CLR(r) (r).mem_debug_data_1_1[0] = 0
#define BCM53115_A0_MEM_DEBUG_DATA_1_1r_SET(r,d) (r).mem_debug_data_1_1[0] = d
#define BCM53115_A0_MEM_DEBUG_DATA_1_1r_GET(r) (r).mem_debug_data_1_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_GET(r) (((r).mem_debug_data_1_1[0]) & 0xffff)
#define BCM53115_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_SET(r,f) (r).mem_debug_data_1_1[0]=(((r).mem_debug_data_1_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_DEBUG_DATA_1_1.
 *
 */
#define BCM53115_A0_READ_MEM_DEBUG_DATA_1_1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_DEBUG_DATA_1_1r,(r._mem_debug_data_1_1),2)
#define BCM53115_A0_WRITE_MEM_DEBUG_DATA_1_1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_DEBUG_DATA_1_1r,&(r._mem_debug_data_1_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_1_1r BCM53115_A0_MEM_DEBUG_DATA_1_1r
#define MEM_DEBUG_DATA_1_1r_SIZE BCM53115_A0_MEM_DEBUG_DATA_1_1r_SIZE
typedef BCM53115_A0_MEM_DEBUG_DATA_1_1r_t MEM_DEBUG_DATA_1_1r_t;
#define MEM_DEBUG_DATA_1_1r_CLR BCM53115_A0_MEM_DEBUG_DATA_1_1r_CLR
#define MEM_DEBUG_DATA_1_1r_SET BCM53115_A0_MEM_DEBUG_DATA_1_1r_SET
#define MEM_DEBUG_DATA_1_1r_GET BCM53115_A0_MEM_DEBUG_DATA_1_1r_GET
#define MEM_DEBUG_DATA_1_1r_MEM_DATf_GET BCM53115_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_GET
#define MEM_DEBUG_DATA_1_1r_MEM_DATf_SET BCM53115_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_1_1r BCM53115_A0_READ_MEM_DEBUG_DATA_1_1r
#define WRITE_MEM_DEBUG_DATA_1_1r BCM53115_A0_WRITE_MEM_DEBUG_DATA_1_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_DEBUG_DATA_1_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_FRM_ADDR
 * BLOCKS:   SYS
 * DESC:     Frame Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     RESERVED_R       
 *     MEM_RW           1' causes a read operation while 0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the Debugged memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_FRM_ADDRr 0x00000820

#define BCM53115_A0_MEM_FRM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_FRM_ADDR.
 *
 */
typedef union BCM53115_A0_MEM_FRM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_frm_addr[1];
	uint32_t _mem_frm_addr;
} BCM53115_A0_MEM_FRM_ADDRr_t;

#define BCM53115_A0_MEM_FRM_ADDRr_CLR(r) (r).mem_frm_addr[0] = 0
#define BCM53115_A0_MEM_FRM_ADDRr_SET(r,d) (r).mem_frm_addr[0] = d
#define BCM53115_A0_MEM_FRM_ADDRr_GET(r) (r).mem_frm_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_FRM_ADDRr_MEM_ADRf_GET(r) (((r).mem_frm_addr[0]) & 0xfff)
#define BCM53115_A0_MEM_FRM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_MEM_FRM_ADDRr_RESERVED_Rf_GET(r) ((((r).mem_frm_addr[0]) >> 12) & 0x3)
#define BCM53115_A0_MEM_FRM_ADDRr_RESERVED_Rf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53115_A0_MEM_FRM_ADDRr_MEM_RWf_GET(r) ((((r).mem_frm_addr[0]) >> 14) & 0x1)
#define BCM53115_A0_MEM_FRM_ADDRr_MEM_RWf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_MEM_FRM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_frm_addr[0]) >> 15) & 0x1)
#define BCM53115_A0_MEM_FRM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_FRM_ADDR.
 *
 */
#define BCM53115_A0_READ_MEM_FRM_ADDRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_FRM_ADDRr,(r._mem_frm_addr),2)
#define BCM53115_A0_WRITE_MEM_FRM_ADDRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_FRM_ADDRr,&(r._mem_frm_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_ADDRr BCM53115_A0_MEM_FRM_ADDRr
#define MEM_FRM_ADDRr_SIZE BCM53115_A0_MEM_FRM_ADDRr_SIZE
typedef BCM53115_A0_MEM_FRM_ADDRr_t MEM_FRM_ADDRr_t;
#define MEM_FRM_ADDRr_CLR BCM53115_A0_MEM_FRM_ADDRr_CLR
#define MEM_FRM_ADDRr_SET BCM53115_A0_MEM_FRM_ADDRr_SET
#define MEM_FRM_ADDRr_GET BCM53115_A0_MEM_FRM_ADDRr_GET
#define MEM_FRM_ADDRr_MEM_ADRf_GET BCM53115_A0_MEM_FRM_ADDRr_MEM_ADRf_GET
#define MEM_FRM_ADDRr_MEM_ADRf_SET BCM53115_A0_MEM_FRM_ADDRr_MEM_ADRf_SET
#define MEM_FRM_ADDRr_RESERVED_Rf_GET BCM53115_A0_MEM_FRM_ADDRr_RESERVED_Rf_GET
#define MEM_FRM_ADDRr_RESERVED_Rf_SET BCM53115_A0_MEM_FRM_ADDRr_RESERVED_Rf_SET
#define MEM_FRM_ADDRr_MEM_RWf_GET BCM53115_A0_MEM_FRM_ADDRr_MEM_RWf_GET
#define MEM_FRM_ADDRr_MEM_RWf_SET BCM53115_A0_MEM_FRM_ADDRr_MEM_RWf_SET
#define MEM_FRM_ADDRr_MEM_STDNf_GET BCM53115_A0_MEM_FRM_ADDRr_MEM_STDNf_GET
#define MEM_FRM_ADDRr_MEM_STDNf_SET BCM53115_A0_MEM_FRM_ADDRr_MEM_STDNf_SET
#define READ_MEM_FRM_ADDRr BCM53115_A0_READ_MEM_FRM_ADDRr
#define WRITE_MEM_FRM_ADDRr BCM53115_A0_WRITE_MEM_FRM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_FRM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_FRM_DATA0
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 1st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[63:0].
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_FRM_DATA0r 0x00000830

#define BCM53115_A0_MEM_FRM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA0.
 *
 */
typedef union BCM53115_A0_MEM_FRM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_frm_data0[2];
	uint32_t _mem_frm_data0;
} BCM53115_A0_MEM_FRM_DATA0r_t;

#define BCM53115_A0_MEM_FRM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data0), 0, sizeof(BCM53115_A0_MEM_FRM_DATA0r_t))
#define BCM53115_A0_MEM_FRM_DATA0r_SET(r,i,d) (r).mem_frm_data0[i] = d
#define BCM53115_A0_MEM_FRM_DATA0r_GET(r,i) (r).mem_frm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_FRM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data0,0,63,a)
#define BCM53115_A0_MEM_FRM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data0,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA0.
 *
 */
#define BCM53115_A0_READ_MEM_FRM_DATA0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_FRM_DATA0r,(r._mem_frm_data0),8)
#define BCM53115_A0_WRITE_MEM_FRM_DATA0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_FRM_DATA0r,&(r._mem_frm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA0r BCM53115_A0_MEM_FRM_DATA0r
#define MEM_FRM_DATA0r_SIZE BCM53115_A0_MEM_FRM_DATA0r_SIZE
typedef BCM53115_A0_MEM_FRM_DATA0r_t MEM_FRM_DATA0r_t;
#define MEM_FRM_DATA0r_CLR BCM53115_A0_MEM_FRM_DATA0r_CLR
#define MEM_FRM_DATA0r_SET BCM53115_A0_MEM_FRM_DATA0r_SET
#define MEM_FRM_DATA0r_GET BCM53115_A0_MEM_FRM_DATA0r_GET
#define MEM_FRM_DATA0r_MEM_DATAf_GET BCM53115_A0_MEM_FRM_DATA0r_MEM_DATAf_GET
#define MEM_FRM_DATA0r_MEM_DATAf_SET BCM53115_A0_MEM_FRM_DATA0r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA0r BCM53115_A0_READ_MEM_FRM_DATA0r
#define WRITE_MEM_FRM_DATA0r BCM53115_A0_WRITE_MEM_FRM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_FRM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_FRM_DATA1
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 2st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[127:64].
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_FRM_DATA1r 0x00000838

#define BCM53115_A0_MEM_FRM_DATA1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA1.
 *
 */
typedef union BCM53115_A0_MEM_FRM_DATA1r_s {
	uint32_t v[2];
	uint32_t mem_frm_data1[2];
	uint32_t _mem_frm_data1;
} BCM53115_A0_MEM_FRM_DATA1r_t;

#define BCM53115_A0_MEM_FRM_DATA1r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data1), 0, sizeof(BCM53115_A0_MEM_FRM_DATA1r_t))
#define BCM53115_A0_MEM_FRM_DATA1r_SET(r,i,d) (r).mem_frm_data1[i] = d
#define BCM53115_A0_MEM_FRM_DATA1r_GET(r,i) (r).mem_frm_data1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_FRM_DATA1r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data1,0,63,a)
#define BCM53115_A0_MEM_FRM_DATA1r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data1,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA1.
 *
 */
#define BCM53115_A0_READ_MEM_FRM_DATA1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_FRM_DATA1r,(r._mem_frm_data1),8)
#define BCM53115_A0_WRITE_MEM_FRM_DATA1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_FRM_DATA1r,&(r._mem_frm_data1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA1r BCM53115_A0_MEM_FRM_DATA1r
#define MEM_FRM_DATA1r_SIZE BCM53115_A0_MEM_FRM_DATA1r_SIZE
typedef BCM53115_A0_MEM_FRM_DATA1r_t MEM_FRM_DATA1r_t;
#define MEM_FRM_DATA1r_CLR BCM53115_A0_MEM_FRM_DATA1r_CLR
#define MEM_FRM_DATA1r_SET BCM53115_A0_MEM_FRM_DATA1r_SET
#define MEM_FRM_DATA1r_GET BCM53115_A0_MEM_FRM_DATA1r_GET
#define MEM_FRM_DATA1r_MEM_DATAf_GET BCM53115_A0_MEM_FRM_DATA1r_MEM_DATAf_GET
#define MEM_FRM_DATA1r_MEM_DATAf_SET BCM53115_A0_MEM_FRM_DATA1r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA1r BCM53115_A0_READ_MEM_FRM_DATA1r
#define WRITE_MEM_FRM_DATA1r BCM53115_A0_WRITE_MEM_FRM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_FRM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_FRM_DATA2
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 3st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[191:128].
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_FRM_DATA2r 0x00000840

#define BCM53115_A0_MEM_FRM_DATA2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA2.
 *
 */
typedef union BCM53115_A0_MEM_FRM_DATA2r_s {
	uint32_t v[2];
	uint32_t mem_frm_data2[2];
	uint32_t _mem_frm_data2;
} BCM53115_A0_MEM_FRM_DATA2r_t;

#define BCM53115_A0_MEM_FRM_DATA2r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data2), 0, sizeof(BCM53115_A0_MEM_FRM_DATA2r_t))
#define BCM53115_A0_MEM_FRM_DATA2r_SET(r,i,d) (r).mem_frm_data2[i] = d
#define BCM53115_A0_MEM_FRM_DATA2r_GET(r,i) (r).mem_frm_data2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_FRM_DATA2r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data2,0,63,a)
#define BCM53115_A0_MEM_FRM_DATA2r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data2,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA2.
 *
 */
#define BCM53115_A0_READ_MEM_FRM_DATA2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_FRM_DATA2r,(r._mem_frm_data2),8)
#define BCM53115_A0_WRITE_MEM_FRM_DATA2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_FRM_DATA2r,&(r._mem_frm_data2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA2r BCM53115_A0_MEM_FRM_DATA2r
#define MEM_FRM_DATA2r_SIZE BCM53115_A0_MEM_FRM_DATA2r_SIZE
typedef BCM53115_A0_MEM_FRM_DATA2r_t MEM_FRM_DATA2r_t;
#define MEM_FRM_DATA2r_CLR BCM53115_A0_MEM_FRM_DATA2r_CLR
#define MEM_FRM_DATA2r_SET BCM53115_A0_MEM_FRM_DATA2r_SET
#define MEM_FRM_DATA2r_GET BCM53115_A0_MEM_FRM_DATA2r_GET
#define MEM_FRM_DATA2r_MEM_DATAf_GET BCM53115_A0_MEM_FRM_DATA2r_MEM_DATAf_GET
#define MEM_FRM_DATA2r_MEM_DATAf_SET BCM53115_A0_MEM_FRM_DATA2r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA2r BCM53115_A0_READ_MEM_FRM_DATA2r
#define WRITE_MEM_FRM_DATA2r BCM53115_A0_WRITE_MEM_FRM_DATA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_FRM_DATA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_FRM_DATA3
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 4th Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[255:192].
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_FRM_DATA3r 0x00000848

#define BCM53115_A0_MEM_FRM_DATA3r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA3.
 *
 */
typedef union BCM53115_A0_MEM_FRM_DATA3r_s {
	uint32_t v[2];
	uint32_t mem_frm_data3[2];
	uint32_t _mem_frm_data3;
} BCM53115_A0_MEM_FRM_DATA3r_t;

#define BCM53115_A0_MEM_FRM_DATA3r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data3), 0, sizeof(BCM53115_A0_MEM_FRM_DATA3r_t))
#define BCM53115_A0_MEM_FRM_DATA3r_SET(r,i,d) (r).mem_frm_data3[i] = d
#define BCM53115_A0_MEM_FRM_DATA3r_GET(r,i) (r).mem_frm_data3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_FRM_DATA3r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data3,0,63,a)
#define BCM53115_A0_MEM_FRM_DATA3r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data3,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA3.
 *
 */
#define BCM53115_A0_READ_MEM_FRM_DATA3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_FRM_DATA3r,(r._mem_frm_data3),8)
#define BCM53115_A0_WRITE_MEM_FRM_DATA3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_FRM_DATA3r,&(r._mem_frm_data3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA3r BCM53115_A0_MEM_FRM_DATA3r
#define MEM_FRM_DATA3r_SIZE BCM53115_A0_MEM_FRM_DATA3r_SIZE
typedef BCM53115_A0_MEM_FRM_DATA3r_t MEM_FRM_DATA3r_t;
#define MEM_FRM_DATA3r_CLR BCM53115_A0_MEM_FRM_DATA3r_CLR
#define MEM_FRM_DATA3r_SET BCM53115_A0_MEM_FRM_DATA3r_SET
#define MEM_FRM_DATA3r_GET BCM53115_A0_MEM_FRM_DATA3r_GET
#define MEM_FRM_DATA3r_MEM_DATAf_GET BCM53115_A0_MEM_FRM_DATA3r_MEM_DATAf_GET
#define MEM_FRM_DATA3r_MEM_DATAf_SET BCM53115_A0_MEM_FRM_DATA3r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA3r BCM53115_A0_READ_MEM_FRM_DATA3r
#define WRITE_MEM_FRM_DATA3r BCM53115_A0_WRITE_MEM_FRM_DATA3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_FRM_DATA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MEM_TEST_CTL
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Registrer
 * SIZE:     64
 * FIELDS:
 *     ARL_TM           
 *     BT_TM            
 *     PB_TM            
 *     TXQ_TM           
 *     ACTRAT_TM        
 *     EVT_TM           
 *     STA_TM           
 *     VL_TM            
 *     RESERVED0_R      
 *     TCAM_TM          
 *     RESERVED1_R      Reserved
 *     OTP_CPU_IF_EN    Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MEM_TEST_CTLr 0x000000e0

#define BCM53115_A0_MEM_TEST_CTLr_SIZE 8

/*
 * This structure should be used to declare and program MEM_TEST_CTL.
 *
 */
typedef union BCM53115_A0_MEM_TEST_CTLr_s {
	uint32_t v[2];
	uint32_t mem_test_ctl[2];
	uint32_t _mem_test_ctl;
} BCM53115_A0_MEM_TEST_CTLr_t;

#define BCM53115_A0_MEM_TEST_CTLr_CLR(r) CDK_MEMSET(&((r)._mem_test_ctl), 0, sizeof(BCM53115_A0_MEM_TEST_CTLr_t))
#define BCM53115_A0_MEM_TEST_CTLr_SET(r,i,d) (r).mem_test_ctl[i] = d
#define BCM53115_A0_MEM_TEST_CTLr_GET(r,i) (r).mem_test_ctl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MEM_TEST_CTLr_ARL_TMf_GET(r) (((r).mem_test_ctl[0]) & 0xff)
#define BCM53115_A0_MEM_TEST_CTLr_ARL_TMf_SET(r,f) (r).mem_test_ctl[0]=(((r).mem_test_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_MEM_TEST_CTLr_BT_TMf_GET(r) ((((r).mem_test_ctl[0]) >> 8) & 0xff)
#define BCM53115_A0_MEM_TEST_CTLr_BT_TMf_SET(r,f) (r).mem_test_ctl[0]=(((r).mem_test_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53115_A0_MEM_TEST_CTLr_PB_TMf_GET(r) ((((r).mem_test_ctl[0]) >> 16) & 0xff)
#define BCM53115_A0_MEM_TEST_CTLr_PB_TMf_SET(r,f) (r).mem_test_ctl[0]=(((r).mem_test_ctl[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53115_A0_MEM_TEST_CTLr_TXQ_TMf_GET(r) ((((r).mem_test_ctl[0]) >> 24) & 0xff)
#define BCM53115_A0_MEM_TEST_CTLr_TXQ_TMf_SET(r,f) (r).mem_test_ctl[0]=(((r).mem_test_ctl[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53115_A0_MEM_TEST_CTLr_ACTRAT_TMf_GET(r) (((r).mem_test_ctl[1]) & 0xf)
#define BCM53115_A0_MEM_TEST_CTLr_ACTRAT_TMf_SET(r,f) (r).mem_test_ctl[1]=(((r).mem_test_ctl[1] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_MEM_TEST_CTLr_EVT_TMf_GET(r) ((((r).mem_test_ctl[1]) >> 4) & 0xf)
#define BCM53115_A0_MEM_TEST_CTLr_EVT_TMf_SET(r,f) (r).mem_test_ctl[1]=(((r).mem_test_ctl[1] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_MEM_TEST_CTLr_STA_TMf_GET(r) ((((r).mem_test_ctl[1]) >> 8) & 0xf)
#define BCM53115_A0_MEM_TEST_CTLr_STA_TMf_SET(r,f) (r).mem_test_ctl[1]=(((r).mem_test_ctl[1] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_MEM_TEST_CTLr_VL_TMf_GET(r) ((((r).mem_test_ctl[1]) >> 12) & 0xf)
#define BCM53115_A0_MEM_TEST_CTLr_VL_TMf_SET(r,f) (r).mem_test_ctl[1]=(((r).mem_test_ctl[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53115_A0_MEM_TEST_CTLr_RESERVED0_Rf_GET(r) ((((r).mem_test_ctl[1]) >> 16) & 0x7)
#define BCM53115_A0_MEM_TEST_CTLr_RESERVED0_Rf_SET(r,f) (r).mem_test_ctl[1]=(((r).mem_test_ctl[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53115_A0_MEM_TEST_CTLr_TCAM_TMf_GET(r) ((((r).mem_test_ctl[1]) >> 19) & 0x7ff)
#define BCM53115_A0_MEM_TEST_CTLr_TCAM_TMf_SET(r,f) (r).mem_test_ctl[1]=(((r).mem_test_ctl[1] & ~((uint32_t)0x7ff << 19)) | ((((uint32_t)f) & 0x7ff) << 19))
#define BCM53115_A0_MEM_TEST_CTLr_RESERVED1_Rf_GET(r) ((((r).mem_test_ctl[1]) >> 30) & 0x1)
#define BCM53115_A0_MEM_TEST_CTLr_RESERVED1_Rf_SET(r,f) (r).mem_test_ctl[1]=(((r).mem_test_ctl[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53115_A0_MEM_TEST_CTLr_OTP_CPU_IF_ENf_GET(r) ((((r).mem_test_ctl[1]) >> 31) & 0x1)
#define BCM53115_A0_MEM_TEST_CTLr_OTP_CPU_IF_ENf_SET(r,f) (r).mem_test_ctl[1]=(((r).mem_test_ctl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access MEM_TEST_CTL.
 *
 */
#define BCM53115_A0_READ_MEM_TEST_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MEM_TEST_CTLr,(r._mem_test_ctl),8)
#define BCM53115_A0_WRITE_MEM_TEST_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MEM_TEST_CTLr,&(r._mem_test_ctl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_TEST_CTLr BCM53115_A0_MEM_TEST_CTLr
#define MEM_TEST_CTLr_SIZE BCM53115_A0_MEM_TEST_CTLr_SIZE
typedef BCM53115_A0_MEM_TEST_CTLr_t MEM_TEST_CTLr_t;
#define MEM_TEST_CTLr_CLR BCM53115_A0_MEM_TEST_CTLr_CLR
#define MEM_TEST_CTLr_SET BCM53115_A0_MEM_TEST_CTLr_SET
#define MEM_TEST_CTLr_GET BCM53115_A0_MEM_TEST_CTLr_GET
#define MEM_TEST_CTLr_ARL_TMf_GET BCM53115_A0_MEM_TEST_CTLr_ARL_TMf_GET
#define MEM_TEST_CTLr_ARL_TMf_SET BCM53115_A0_MEM_TEST_CTLr_ARL_TMf_SET
#define MEM_TEST_CTLr_BT_TMf_GET BCM53115_A0_MEM_TEST_CTLr_BT_TMf_GET
#define MEM_TEST_CTLr_BT_TMf_SET BCM53115_A0_MEM_TEST_CTLr_BT_TMf_SET
#define MEM_TEST_CTLr_PB_TMf_GET BCM53115_A0_MEM_TEST_CTLr_PB_TMf_GET
#define MEM_TEST_CTLr_PB_TMf_SET BCM53115_A0_MEM_TEST_CTLr_PB_TMf_SET
#define MEM_TEST_CTLr_TXQ_TMf_GET BCM53115_A0_MEM_TEST_CTLr_TXQ_TMf_GET
#define MEM_TEST_CTLr_TXQ_TMf_SET BCM53115_A0_MEM_TEST_CTLr_TXQ_TMf_SET
#define MEM_TEST_CTLr_ACTRAT_TMf_GET BCM53115_A0_MEM_TEST_CTLr_ACTRAT_TMf_GET
#define MEM_TEST_CTLr_ACTRAT_TMf_SET BCM53115_A0_MEM_TEST_CTLr_ACTRAT_TMf_SET
#define MEM_TEST_CTLr_EVT_TMf_GET BCM53115_A0_MEM_TEST_CTLr_EVT_TMf_GET
#define MEM_TEST_CTLr_EVT_TMf_SET BCM53115_A0_MEM_TEST_CTLr_EVT_TMf_SET
#define MEM_TEST_CTLr_STA_TMf_GET BCM53115_A0_MEM_TEST_CTLr_STA_TMf_GET
#define MEM_TEST_CTLr_STA_TMf_SET BCM53115_A0_MEM_TEST_CTLr_STA_TMf_SET
#define MEM_TEST_CTLr_VL_TMf_GET BCM53115_A0_MEM_TEST_CTLr_VL_TMf_GET
#define MEM_TEST_CTLr_VL_TMf_SET BCM53115_A0_MEM_TEST_CTLr_VL_TMf_SET
#define MEM_TEST_CTLr_RESERVED0_Rf_GET BCM53115_A0_MEM_TEST_CTLr_RESERVED0_Rf_GET
#define MEM_TEST_CTLr_RESERVED0_Rf_SET BCM53115_A0_MEM_TEST_CTLr_RESERVED0_Rf_SET
#define MEM_TEST_CTLr_TCAM_TMf_GET BCM53115_A0_MEM_TEST_CTLr_TCAM_TMf_GET
#define MEM_TEST_CTLr_TCAM_TMf_SET BCM53115_A0_MEM_TEST_CTLr_TCAM_TMf_SET
#define MEM_TEST_CTLr_RESERVED1_Rf_GET BCM53115_A0_MEM_TEST_CTLr_RESERVED1_Rf_GET
#define MEM_TEST_CTLr_RESERVED1_Rf_SET BCM53115_A0_MEM_TEST_CTLr_RESERVED1_Rf_SET
#define MEM_TEST_CTLr_OTP_CPU_IF_ENf_GET BCM53115_A0_MEM_TEST_CTLr_OTP_CPU_IF_ENf_GET
#define MEM_TEST_CTLr_OTP_CPU_IF_ENf_SET BCM53115_A0_MEM_TEST_CTLr_OTP_CPU_IF_ENf_SET
#define READ_MEM_TEST_CTLr BCM53115_A0_READ_MEM_TEST_CTLr
#define WRITE_MEM_TEST_CTLr BCM53115_A0_WRITE_MEM_TEST_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MEM_TEST_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MIB_GD_FM_MAX_SIZE
 * BLOCKS:   SYS
 * DESC:     Jumbo MIB Good Frame Max Size Registers
 * SIZE:     16
 * FIELDS:
 *     MAX_SIZE         Good Frame Max Size.The Register defines the Good Frame Max Size for MIB counter.The Register should be in the range d9724 ~ d1518 Good Frame Length Range in MIBTagged Packets : (Good Frame Max Size + 4) ~ 64 bytesUntagged Packets : Good Frame Max Size ~ 64 bytesThe Register setting will affect those MIB counting includingin RxSAChangeRxGoodOctetsRxUnicastPktsRxMulticastPktsRxBroadcastPktsRxOverSizePkts
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr 0x00004005

#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr_SIZE 2

/*
 * This structure should be used to declare and program MIB_GD_FM_MAX_SIZE.
 *
 */
typedef union BCM53115_A0_MIB_GD_FM_MAX_SIZEr_s {
	uint32_t v[1];
	uint32_t mib_gd_fm_max_size[1];
	uint32_t _mib_gd_fm_max_size;
} BCM53115_A0_MIB_GD_FM_MAX_SIZEr_t;

#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr_CLR(r) (r).mib_gd_fm_max_size[0] = 0
#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr_SET(r,d) (r).mib_gd_fm_max_size[0] = d
#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr_GET(r) (r).mib_gd_fm_max_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET(r) (((r).mib_gd_fm_max_size[0]) & 0x3fff)
#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_GET(r) ((((r).mib_gd_fm_max_size[0]) >> 14) & 0x3)
#define BCM53115_A0_MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access MIB_GD_FM_MAX_SIZE.
 *
 */
#define BCM53115_A0_READ_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MIB_GD_FM_MAX_SIZEr,(r._mib_gd_fm_max_size),2)
#define BCM53115_A0_WRITE_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MIB_GD_FM_MAX_SIZEr,&(r._mib_gd_fm_max_size),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_GD_FM_MAX_SIZEr BCM53115_A0_MIB_GD_FM_MAX_SIZEr
#define MIB_GD_FM_MAX_SIZEr_SIZE BCM53115_A0_MIB_GD_FM_MAX_SIZEr_SIZE
typedef BCM53115_A0_MIB_GD_FM_MAX_SIZEr_t MIB_GD_FM_MAX_SIZEr_t;
#define MIB_GD_FM_MAX_SIZEr_CLR BCM53115_A0_MIB_GD_FM_MAX_SIZEr_CLR
#define MIB_GD_FM_MAX_SIZEr_SET BCM53115_A0_MIB_GD_FM_MAX_SIZEr_SET
#define MIB_GD_FM_MAX_SIZEr_GET BCM53115_A0_MIB_GD_FM_MAX_SIZEr_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET BCM53115_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET BCM53115_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET
#define MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_GET BCM53115_A0_MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_GET
#define MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_SET BCM53115_A0_MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_SET
#define READ_MIB_GD_FM_MAX_SIZEr BCM53115_A0_READ_MIB_GD_FM_MAX_SIZEr
#define WRITE_MIB_GD_FM_MAX_SIZEr BCM53115_A0_WRITE_MIB_GD_FM_MAX_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MIB_GD_FM_MAX_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MIB_SNAPSHOT_CTL
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Control Register
 * SIZE:     8
 * FIELDS:
 *     SNAPSHOT_PORT    Port munber for MIB snapshot function.
 *     RESERVED_R       
 *     SNAPSHOT_MIRROR  1'b1 : enable read address to port MIB, but from MIB snapshot memory.1'b0 : enable to read from port MIB memory.
 *     SNAPSHOT_STDONE  Write 1'b1 to initiate MIB snapshot access clear to 1'b0 when MIB snapshot access is done.
 *
 ******************************************************************************/
#define BCM53115_A0_MIB_SNAPSHOT_CTLr 0x00007000

#define BCM53115_A0_MIB_SNAPSHOT_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MIB_SNAPSHOT_CTL.
 *
 */
typedef union BCM53115_A0_MIB_SNAPSHOT_CTLr_s {
	uint32_t v[1];
	uint32_t mib_snapshot_ctl[1];
	uint32_t _mib_snapshot_ctl;
} BCM53115_A0_MIB_SNAPSHOT_CTLr_t;

#define BCM53115_A0_MIB_SNAPSHOT_CTLr_CLR(r) (r).mib_snapshot_ctl[0] = 0
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_SET(r,d) (r).mib_snapshot_ctl[0] = d
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_GET(r) (r).mib_snapshot_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET(r) (((r).mib_snapshot_ctl[0]) & 0xf)
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_RESERVED_Rf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 4) & 0x3)
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_RESERVED_Rf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 6) & 0x1)
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 7) & 0x1)
#define BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIB_SNAPSHOT_CTL.
 *
 */
#define BCM53115_A0_READ_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MIB_SNAPSHOT_CTLr,(r._mib_snapshot_ctl),1)
#define BCM53115_A0_WRITE_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MIB_SNAPSHOT_CTLr,&(r._mib_snapshot_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_SNAPSHOT_CTLr BCM53115_A0_MIB_SNAPSHOT_CTLr
#define MIB_SNAPSHOT_CTLr_SIZE BCM53115_A0_MIB_SNAPSHOT_CTLr_SIZE
typedef BCM53115_A0_MIB_SNAPSHOT_CTLr_t MIB_SNAPSHOT_CTLr_t;
#define MIB_SNAPSHOT_CTLr_CLR BCM53115_A0_MIB_SNAPSHOT_CTLr_CLR
#define MIB_SNAPSHOT_CTLr_SET BCM53115_A0_MIB_SNAPSHOT_CTLr_SET
#define MIB_SNAPSHOT_CTLr_GET BCM53115_A0_MIB_SNAPSHOT_CTLr_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET
#define MIB_SNAPSHOT_CTLr_RESERVED_Rf_GET BCM53115_A0_MIB_SNAPSHOT_CTLr_RESERVED_Rf_GET
#define MIB_SNAPSHOT_CTLr_RESERVED_Rf_SET BCM53115_A0_MIB_SNAPSHOT_CTLr_RESERVED_Rf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET BCM53115_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET
#define READ_MIB_SNAPSHOT_CTLr BCM53115_A0_READ_MIB_SNAPSHOT_CTLr
#define WRITE_MIB_SNAPSHOT_CTLr BCM53115_A0_WRITE_MIB_SNAPSHOT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MIB_SNAPSHOT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MINIMUM_TCP_HDR_SZ
 * BLOCKS:   SYS
 * DESC:     Minimum TCP Header Size Register
 * SIZE:     8
 * FIELDS:
 *     MIN_TCP_HDR_SZ   Minimun TCP header size allowed (0~255 bytes).
 *
 ******************************************************************************/
#define BCM53115_A0_MINIMUM_TCP_HDR_SZr 0x00003604

#define BCM53115_A0_MINIMUM_TCP_HDR_SZr_SIZE 1

/*
 * This structure should be used to declare and program MINIMUM_TCP_HDR_SZ.
 *
 */
typedef union BCM53115_A0_MINIMUM_TCP_HDR_SZr_s {
	uint32_t v[1];
	uint32_t minimum_tcp_hdr_sz[1];
	uint32_t _minimum_tcp_hdr_sz;
} BCM53115_A0_MINIMUM_TCP_HDR_SZr_t;

#define BCM53115_A0_MINIMUM_TCP_HDR_SZr_CLR(r) (r).minimum_tcp_hdr_sz[0] = 0
#define BCM53115_A0_MINIMUM_TCP_HDR_SZr_SET(r,d) (r).minimum_tcp_hdr_sz[0] = d
#define BCM53115_A0_MINIMUM_TCP_HDR_SZr_GET(r) (r).minimum_tcp_hdr_sz[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET(r) (((r).minimum_tcp_hdr_sz[0]) & 0xff)
#define BCM53115_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET(r,f) (r).minimum_tcp_hdr_sz[0]=(((r).minimum_tcp_hdr_sz[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MINIMUM_TCP_HDR_SZ.
 *
 */
#define BCM53115_A0_READ_MINIMUM_TCP_HDR_SZr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MINIMUM_TCP_HDR_SZr,(r._minimum_tcp_hdr_sz),1)
#define BCM53115_A0_WRITE_MINIMUM_TCP_HDR_SZr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MINIMUM_TCP_HDR_SZr,&(r._minimum_tcp_hdr_sz),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINIMUM_TCP_HDR_SZr BCM53115_A0_MINIMUM_TCP_HDR_SZr
#define MINIMUM_TCP_HDR_SZr_SIZE BCM53115_A0_MINIMUM_TCP_HDR_SZr_SIZE
typedef BCM53115_A0_MINIMUM_TCP_HDR_SZr_t MINIMUM_TCP_HDR_SZr_t;
#define MINIMUM_TCP_HDR_SZr_CLR BCM53115_A0_MINIMUM_TCP_HDR_SZr_CLR
#define MINIMUM_TCP_HDR_SZr_SET BCM53115_A0_MINIMUM_TCP_HDR_SZr_SET
#define MINIMUM_TCP_HDR_SZr_GET BCM53115_A0_MINIMUM_TCP_HDR_SZr_GET
#define MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET BCM53115_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET
#define MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET BCM53115_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET
#define READ_MINIMUM_TCP_HDR_SZr BCM53115_A0_READ_MINIMUM_TCP_HDR_SZr
#define WRITE_MINIMUM_TCP_HDR_SZr BCM53115_A0_WRITE_MINIMUM_TCP_HDR_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MINIMUM_TCP_HDR_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MIRCAPCTL
 * BLOCKS:   SYS
 * DESC:     Mirror Capture Control Register
 * SIZE:     16
 * FIELDS:
 *     SMIR_CAP_PORT    Mirror Capture Port ID.Port ID which identifies the single unique port which is designated as the port to which all ingress and/or egress traffic is mirrored on this chip/system.
 *     RESERVED_0R      Reserved
 *     RESERVED_1R      Reserved
 *     BLK_NOT_MIR      When Enabled, all traffic to Mirror_Capture_Port will be blocked except mirror traffic.
 *     MIR_EN           Global enable/disable for all mirroring on this chip.When reset, mirroring is disabled.When set, mirroring is enabled according to the ingress and egress control rules, to the port designated by the MIRROR_CAPTURE_PORT.
 *
 ******************************************************************************/
#define BCM53115_A0_MIRCAPCTLr 0x00000210

#define BCM53115_A0_MIRCAPCTLr_SIZE 2

/*
 * This structure should be used to declare and program MIRCAPCTL.
 *
 */
typedef union BCM53115_A0_MIRCAPCTLr_s {
	uint32_t v[1];
	uint32_t mircapctl[1];
	uint32_t _mircapctl;
} BCM53115_A0_MIRCAPCTLr_t;

#define BCM53115_A0_MIRCAPCTLr_CLR(r) (r).mircapctl[0] = 0
#define BCM53115_A0_MIRCAPCTLr_SET(r,d) (r).mircapctl[0] = d
#define BCM53115_A0_MIRCAPCTLr_GET(r) (r).mircapctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET(r) (((r).mircapctl[0]) & 0xf)
#define BCM53115_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_MIRCAPCTLr_RESERVED_0Rf_GET(r) ((((r).mircapctl[0]) >> 4) & 0x3)
#define BCM53115_A0_MIRCAPCTLr_RESERVED_0Rf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53115_A0_MIRCAPCTLr_RESERVED_1Rf_GET(r) ((((r).mircapctl[0]) >> 6) & 0xff)
#define BCM53115_A0_MIRCAPCTLr_RESERVED_1Rf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCM53115_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET(r) ((((r).mircapctl[0]) >> 14) & 0x1)
#define BCM53115_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_MIRCAPCTLr_MIR_ENf_GET(r) ((((r).mircapctl[0]) >> 15) & 0x1)
#define BCM53115_A0_MIRCAPCTLr_MIR_ENf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIRCAPCTL.
 *
 */
#define BCM53115_A0_READ_MIRCAPCTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MIRCAPCTLr,(r._mircapctl),2)
#define BCM53115_A0_WRITE_MIRCAPCTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MIRCAPCTLr,&(r._mircapctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRCAPCTLr BCM53115_A0_MIRCAPCTLr
#define MIRCAPCTLr_SIZE BCM53115_A0_MIRCAPCTLr_SIZE
typedef BCM53115_A0_MIRCAPCTLr_t MIRCAPCTLr_t;
#define MIRCAPCTLr_CLR BCM53115_A0_MIRCAPCTLr_CLR
#define MIRCAPCTLr_SET BCM53115_A0_MIRCAPCTLr_SET
#define MIRCAPCTLr_GET BCM53115_A0_MIRCAPCTLr_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_GET BCM53115_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_SET BCM53115_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET
#define MIRCAPCTLr_RESERVED_0Rf_GET BCM53115_A0_MIRCAPCTLr_RESERVED_0Rf_GET
#define MIRCAPCTLr_RESERVED_0Rf_SET BCM53115_A0_MIRCAPCTLr_RESERVED_0Rf_SET
#define MIRCAPCTLr_RESERVED_1Rf_GET BCM53115_A0_MIRCAPCTLr_RESERVED_1Rf_GET
#define MIRCAPCTLr_RESERVED_1Rf_SET BCM53115_A0_MIRCAPCTLr_RESERVED_1Rf_SET
#define MIRCAPCTLr_BLK_NOT_MIRf_GET BCM53115_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET
#define MIRCAPCTLr_BLK_NOT_MIRf_SET BCM53115_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET
#define MIRCAPCTLr_MIR_ENf_GET BCM53115_A0_MIRCAPCTLr_MIR_ENf_GET
#define MIRCAPCTLr_MIR_ENf_SET BCM53115_A0_MIRCAPCTLr_MIR_ENf_SET
#define READ_MIRCAPCTLr BCM53115_A0_READ_MIRCAPCTLr
#define WRITE_MIRCAPCTLr BCM53115_A0_WRITE_MIRCAPCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MIRCAPCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MLF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Multicast Lookup Failed Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     MUL_LOOKUP_FAIL_FRW_MAP Multicast Lookup Failed Forward Map.When Multicat lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register setting.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MLF_DROP_MAPr 0x00000034

#define BCM53115_A0_MLF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_DROP_MAP.
 *
 */
typedef union BCM53115_A0_MLF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_drop_map[1];
	uint32_t _mlf_drop_map;
} BCM53115_A0_MLF_DROP_MAPr_t;

#define BCM53115_A0_MLF_DROP_MAPr_CLR(r) (r).mlf_drop_map[0] = 0
#define BCM53115_A0_MLF_DROP_MAPr_SET(r,d) (r).mlf_drop_map[0] = d
#define BCM53115_A0_MLF_DROP_MAPr_GET(r) (r).mlf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET(r) (((r).mlf_drop_map[0]) & 0x1ff)
#define BCM53115_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_MLF_DROP_MAPr_RESERVED_Rf_GET(r) ((((r).mlf_drop_map[0]) >> 9) & 0x7f)
#define BCM53115_A0_MLF_DROP_MAPr_RESERVED_Rf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_DROP_MAP.
 *
 */
#define BCM53115_A0_READ_MLF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MLF_DROP_MAPr,(r._mlf_drop_map),2)
#define BCM53115_A0_WRITE_MLF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MLF_DROP_MAPr,&(r._mlf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_DROP_MAPr BCM53115_A0_MLF_DROP_MAPr
#define MLF_DROP_MAPr_SIZE BCM53115_A0_MLF_DROP_MAPr_SIZE
typedef BCM53115_A0_MLF_DROP_MAPr_t MLF_DROP_MAPr_t;
#define MLF_DROP_MAPr_CLR BCM53115_A0_MLF_DROP_MAPr_CLR
#define MLF_DROP_MAPr_SET BCM53115_A0_MLF_DROP_MAPr_SET
#define MLF_DROP_MAPr_GET BCM53115_A0_MLF_DROP_MAPr_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET BCM53115_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET BCM53115_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET
#define MLF_DROP_MAPr_RESERVED_Rf_GET BCM53115_A0_MLF_DROP_MAPr_RESERVED_Rf_GET
#define MLF_DROP_MAPr_RESERVED_Rf_SET BCM53115_A0_MLF_DROP_MAPr_RESERVED_Rf_SET
#define READ_MLF_DROP_MAPr BCM53115_A0_READ_MLF_DROP_MAPr
#define WRITE_MLF_DROP_MAPr BCM53115_A0_WRITE_MLF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MLF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MLF_IPMC_FWD_MAP
 * BLOCKS:   SYS
 * DESC:     IPMC Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     MLF_IPMC_FWD_MAP IPMC Forward map.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MLF_IPMC_FWD_MAPr 0x00000036

#define BCM53115_A0_MLF_IPMC_FWD_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_IPMC_FWD_MAP.
 *
 */
typedef union BCM53115_A0_MLF_IPMC_FWD_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_ipmc_fwd_map[1];
	uint32_t _mlf_ipmc_fwd_map;
} BCM53115_A0_MLF_IPMC_FWD_MAPr_t;

#define BCM53115_A0_MLF_IPMC_FWD_MAPr_CLR(r) (r).mlf_ipmc_fwd_map[0] = 0
#define BCM53115_A0_MLF_IPMC_FWD_MAPr_SET(r,d) (r).mlf_ipmc_fwd_map[0] = d
#define BCM53115_A0_MLF_IPMC_FWD_MAPr_GET(r) (r).mlf_ipmc_fwd_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET(r) (((r).mlf_ipmc_fwd_map[0]) & 0x1ff)
#define BCM53115_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_MLF_IPMC_FWD_MAPr_RESERVED_Rf_GET(r) ((((r).mlf_ipmc_fwd_map[0]) >> 9) & 0x7f)
#define BCM53115_A0_MLF_IPMC_FWD_MAPr_RESERVED_Rf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_IPMC_FWD_MAP.
 *
 */
#define BCM53115_A0_READ_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MLF_IPMC_FWD_MAPr,(r._mlf_ipmc_fwd_map),2)
#define BCM53115_A0_WRITE_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MLF_IPMC_FWD_MAPr,&(r._mlf_ipmc_fwd_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_IPMC_FWD_MAPr BCM53115_A0_MLF_IPMC_FWD_MAPr
#define MLF_IPMC_FWD_MAPr_SIZE BCM53115_A0_MLF_IPMC_FWD_MAPr_SIZE
typedef BCM53115_A0_MLF_IPMC_FWD_MAPr_t MLF_IPMC_FWD_MAPr_t;
#define MLF_IPMC_FWD_MAPr_CLR BCM53115_A0_MLF_IPMC_FWD_MAPr_CLR
#define MLF_IPMC_FWD_MAPr_SET BCM53115_A0_MLF_IPMC_FWD_MAPr_SET
#define MLF_IPMC_FWD_MAPr_GET BCM53115_A0_MLF_IPMC_FWD_MAPr_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET BCM53115_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET BCM53115_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET
#define MLF_IPMC_FWD_MAPr_RESERVED_Rf_GET BCM53115_A0_MLF_IPMC_FWD_MAPr_RESERVED_Rf_GET
#define MLF_IPMC_FWD_MAPr_RESERVED_Rf_SET BCM53115_A0_MLF_IPMC_FWD_MAPr_RESERVED_Rf_SET
#define READ_MLF_IPMC_FWD_MAPr BCM53115_A0_READ_MLF_IPMC_FWD_MAPr
#define WRITE_MLF_IPMC_FWD_MAPr BCM53115_A0_WRITE_MLF_IPMC_FWD_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MLF_IPMC_FWD_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MODEL_ID
 * BLOCKS:   SYS
 * DESC:     Model ID Register
 * SIZE:     32
 * FIELDS:
 *     MODELID          Chip Model ID
 *
 ******************************************************************************/
#define BCM53115_A0_MODEL_IDr 0x00000230

#define BCM53115_A0_MODEL_IDr_SIZE 4

/*
 * This structure should be used to declare and program MODEL_ID.
 *
 */
typedef union BCM53115_A0_MODEL_IDr_s {
	uint32_t v[1];
	uint32_t model_id[1];
	uint32_t _model_id;
} BCM53115_A0_MODEL_IDr_t;

#define BCM53115_A0_MODEL_IDr_CLR(r) (r).model_id[0] = 0
#define BCM53115_A0_MODEL_IDr_SET(r,d) (r).model_id[0] = d
#define BCM53115_A0_MODEL_IDr_GET(r) (r).model_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MODEL_IDr_MODELIDf_GET(r) ((r).model_id[0])
#define BCM53115_A0_MODEL_IDr_MODELIDf_SET(r,f) (r).model_id[0]=((uint32_t)f)

/*
 * These macros can be used to access MODEL_ID.
 *
 */
#define BCM53115_A0_READ_MODEL_IDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MODEL_IDr,(r._model_id),4)
#define BCM53115_A0_WRITE_MODEL_IDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MODEL_IDr,&(r._model_id),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODEL_IDr BCM53115_A0_MODEL_IDr
#define MODEL_IDr_SIZE BCM53115_A0_MODEL_IDr_SIZE
typedef BCM53115_A0_MODEL_IDr_t MODEL_IDr_t;
#define MODEL_IDr_CLR BCM53115_A0_MODEL_IDr_CLR
#define MODEL_IDr_SET BCM53115_A0_MODEL_IDr_SET
#define MODEL_IDr_GET BCM53115_A0_MODEL_IDr_GET
#define MODEL_IDr_MODELIDf_GET BCM53115_A0_MODEL_IDr_MODELIDf_GET
#define MODEL_IDr_MODELIDf_SET BCM53115_A0_MODEL_IDr_MODELIDf_SET
#define READ_MODEL_IDr BCM53115_A0_READ_MODEL_IDr
#define WRITE_MODEL_IDr BCM53115_A0_WRITE_MODEL_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MODEL_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MODULE_ID0
 * BLOCKS:   SYS
 * DESC:     Module ID 0 Registers
 * SIZE:     48
 * FIELDS:
 *     MID_SA           
 *
 ******************************************************************************/
#define BCM53115_A0_MODULE_ID0r 0x00007205

#define BCM53115_A0_MODULE_ID0r_SIZE 6

/*
 * This structure should be used to declare and program MODULE_ID0.
 *
 */
typedef union BCM53115_A0_MODULE_ID0r_s {
	uint32_t v[2];
	uint32_t module_id0[2];
	uint32_t _module_id0;
} BCM53115_A0_MODULE_ID0r_t;

#define BCM53115_A0_MODULE_ID0r_CLR(r) CDK_MEMSET(&((r)._module_id0), 0, sizeof(BCM53115_A0_MODULE_ID0r_t))
#define BCM53115_A0_MODULE_ID0r_SET(r,i,d) (r).module_id0[i] = d
#define BCM53115_A0_MODULE_ID0r_GET(r,i) (r).module_id0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MODULE_ID0r_MID_SAf_GET(r,a) cdk_field_get((r).module_id0,0,47,a)
#define BCM53115_A0_MODULE_ID0r_MID_SAf_SET(r,a) cdk_field_set((r).module_id0,0,47,a)

/*
 * These macros can be used to access MODULE_ID0.
 *
 */
#define BCM53115_A0_READ_MODULE_ID0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MODULE_ID0r,(r._module_id0),6)
#define BCM53115_A0_WRITE_MODULE_ID0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MODULE_ID0r,&(r._module_id0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODULE_ID0r BCM53115_A0_MODULE_ID0r
#define MODULE_ID0r_SIZE BCM53115_A0_MODULE_ID0r_SIZE
typedef BCM53115_A0_MODULE_ID0r_t MODULE_ID0r_t;
#define MODULE_ID0r_CLR BCM53115_A0_MODULE_ID0r_CLR
#define MODULE_ID0r_SET BCM53115_A0_MODULE_ID0r_SET
#define MODULE_ID0r_GET BCM53115_A0_MODULE_ID0r_GET
#define MODULE_ID0r_MID_SAf_GET BCM53115_A0_MODULE_ID0r_MID_SAf_GET
#define MODULE_ID0r_MID_SAf_SET BCM53115_A0_MODULE_ID0r_MID_SAf_SET
#define READ_MODULE_ID0r BCM53115_A0_READ_MODULE_ID0r
#define WRITE_MODULE_ID0r BCM53115_A0_WRITE_MODULE_ID0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MODULE_ID0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MODULE_ID1
 * BLOCKS:   SYS
 * DESC:     Module ID 1 Registers
 * SIZE:     48
 * FIELDS:
 *     MID_CRC          32 bits CRC for module ID.
 *     MID_PORTNUM      8 bit portnum for module ID.
 *     RESERVED_R       Reserved.
 *     MID_AVAIL        module ID available , once 1 st packet received.1 : available.0 : unavailable, wait for 1st packet.
 *
 ******************************************************************************/
#define BCM53115_A0_MODULE_ID1r 0x0000720b

#define BCM53115_A0_MODULE_ID1r_SIZE 6

/*
 * This structure should be used to declare and program MODULE_ID1.
 *
 */
typedef union BCM53115_A0_MODULE_ID1r_s {
	uint32_t v[2];
	uint32_t module_id1[2];
	uint32_t _module_id1;
} BCM53115_A0_MODULE_ID1r_t;

#define BCM53115_A0_MODULE_ID1r_CLR(r) CDK_MEMSET(&((r)._module_id1), 0, sizeof(BCM53115_A0_MODULE_ID1r_t))
#define BCM53115_A0_MODULE_ID1r_SET(r,i,d) (r).module_id1[i] = d
#define BCM53115_A0_MODULE_ID1r_GET(r,i) (r).module_id1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MODULE_ID1r_MID_CRCf_GET(r) ((r).module_id1[0])
#define BCM53115_A0_MODULE_ID1r_MID_CRCf_SET(r,f) (r).module_id1[0]=((uint32_t)f)
#define BCM53115_A0_MODULE_ID1r_MID_PORTNUMf_GET(r) (((r).module_id1[1]) & 0xff)
#define BCM53115_A0_MODULE_ID1r_MID_PORTNUMf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_MODULE_ID1r_RESERVED_Rf_GET(r) ((((r).module_id1[1]) >> 8) & 0x7f)
#define BCM53115_A0_MODULE_ID1r_RESERVED_Rf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM53115_A0_MODULE_ID1r_MID_AVAILf_GET(r) ((((r).module_id1[1]) >> 15) & 0x1)
#define BCM53115_A0_MODULE_ID1r_MID_AVAILf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MODULE_ID1.
 *
 */
#define BCM53115_A0_READ_MODULE_ID1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MODULE_ID1r,(r._module_id1),6)
#define BCM53115_A0_WRITE_MODULE_ID1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MODULE_ID1r,&(r._module_id1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODULE_ID1r BCM53115_A0_MODULE_ID1r
#define MODULE_ID1r_SIZE BCM53115_A0_MODULE_ID1r_SIZE
typedef BCM53115_A0_MODULE_ID1r_t MODULE_ID1r_t;
#define MODULE_ID1r_CLR BCM53115_A0_MODULE_ID1r_CLR
#define MODULE_ID1r_SET BCM53115_A0_MODULE_ID1r_SET
#define MODULE_ID1r_GET BCM53115_A0_MODULE_ID1r_GET
#define MODULE_ID1r_MID_CRCf_GET BCM53115_A0_MODULE_ID1r_MID_CRCf_GET
#define MODULE_ID1r_MID_CRCf_SET BCM53115_A0_MODULE_ID1r_MID_CRCf_SET
#define MODULE_ID1r_MID_PORTNUMf_GET BCM53115_A0_MODULE_ID1r_MID_PORTNUMf_GET
#define MODULE_ID1r_MID_PORTNUMf_SET BCM53115_A0_MODULE_ID1r_MID_PORTNUMf_SET
#define MODULE_ID1r_RESERVED_Rf_GET BCM53115_A0_MODULE_ID1r_RESERVED_Rf_GET
#define MODULE_ID1r_RESERVED_Rf_SET BCM53115_A0_MODULE_ID1r_RESERVED_Rf_SET
#define MODULE_ID1r_MID_AVAILf_GET BCM53115_A0_MODULE_ID1r_MID_AVAILf_GET
#define MODULE_ID1r_MID_AVAILf_SET BCM53115_A0_MODULE_ID1r_MID_AVAILf_SET
#define READ_MODULE_ID1r BCM53115_A0_READ_MODULE_ID1r
#define WRITE_MODULE_ID1r BCM53115_A0_WRITE_MODULE_ID1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MODULE_ID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MPORTVEC0
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 0.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 0 register will be forwarded to each port with a bit set in the Multiport Vector 0 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MPORTVEC0r 0x00000418

#define BCM53115_A0_MPORTVEC0r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC0.
 *
 */
typedef union BCM53115_A0_MPORTVEC0r_s {
	uint32_t v[1];
	uint32_t mportvec0[1];
	uint32_t _mportvec0;
} BCM53115_A0_MPORTVEC0r_t;

#define BCM53115_A0_MPORTVEC0r_CLR(r) (r).mportvec0[0] = 0
#define BCM53115_A0_MPORTVEC0r_SET(r,d) (r).mportvec0[0] = d
#define BCM53115_A0_MPORTVEC0r_GET(r) (r).mportvec0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MPORTVEC0r_PORT_VCTRf_GET(r) (((r).mportvec0[0]) & 0x1ff)
#define BCM53115_A0_MPORTVEC0r_PORT_VCTRf_SET(r,f) (r).mportvec0[0]=(((r).mportvec0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_MPORTVEC0r_RESERVED_Rf_GET(r) ((((r).mportvec0[0]) >> 9) & 0x7fffff)
#define BCM53115_A0_MPORTVEC0r_RESERVED_Rf_SET(r,f) (r).mportvec0[0]=(((r).mportvec0[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC0.
 *
 */
#define BCM53115_A0_READ_MPORTVEC0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MPORTVEC0r,(r._mportvec0),4)
#define BCM53115_A0_WRITE_MPORTVEC0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MPORTVEC0r,&(r._mportvec0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC0r BCM53115_A0_MPORTVEC0r
#define MPORTVEC0r_SIZE BCM53115_A0_MPORTVEC0r_SIZE
typedef BCM53115_A0_MPORTVEC0r_t MPORTVEC0r_t;
#define MPORTVEC0r_CLR BCM53115_A0_MPORTVEC0r_CLR
#define MPORTVEC0r_SET BCM53115_A0_MPORTVEC0r_SET
#define MPORTVEC0r_GET BCM53115_A0_MPORTVEC0r_GET
#define MPORTVEC0r_PORT_VCTRf_GET BCM53115_A0_MPORTVEC0r_PORT_VCTRf_GET
#define MPORTVEC0r_PORT_VCTRf_SET BCM53115_A0_MPORTVEC0r_PORT_VCTRf_SET
#define MPORTVEC0r_RESERVED_Rf_GET BCM53115_A0_MPORTVEC0r_RESERVED_Rf_GET
#define MPORTVEC0r_RESERVED_Rf_SET BCM53115_A0_MPORTVEC0r_RESERVED_Rf_SET
#define READ_MPORTVEC0r BCM53115_A0_READ_MPORTVEC0r
#define WRITE_MPORTVEC0r BCM53115_A0_WRITE_MPORTVEC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MPORTVEC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MPORTVEC1
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 1A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 1 register will be forwarded to each port with a bit set in the Multiport Vector 1 bit map.Bit 8: Management Port (MII Management )
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MPORTVEC1r 0x00000428

#define BCM53115_A0_MPORTVEC1r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC1.
 *
 */
typedef union BCM53115_A0_MPORTVEC1r_s {
	uint32_t v[1];
	uint32_t mportvec1[1];
	uint32_t _mportvec1;
} BCM53115_A0_MPORTVEC1r_t;

#define BCM53115_A0_MPORTVEC1r_CLR(r) (r).mportvec1[0] = 0
#define BCM53115_A0_MPORTVEC1r_SET(r,d) (r).mportvec1[0] = d
#define BCM53115_A0_MPORTVEC1r_GET(r) (r).mportvec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MPORTVEC1r_PORT_VCTRf_GET(r) (((r).mportvec1[0]) & 0x1ff)
#define BCM53115_A0_MPORTVEC1r_PORT_VCTRf_SET(r,f) (r).mportvec1[0]=(((r).mportvec1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_MPORTVEC1r_RESERVED_Rf_GET(r) ((((r).mportvec1[0]) >> 9) & 0x7fffff)
#define BCM53115_A0_MPORTVEC1r_RESERVED_Rf_SET(r,f) (r).mportvec1[0]=(((r).mportvec1[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC1.
 *
 */
#define BCM53115_A0_READ_MPORTVEC1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MPORTVEC1r,(r._mportvec1),4)
#define BCM53115_A0_WRITE_MPORTVEC1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MPORTVEC1r,&(r._mportvec1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC1r BCM53115_A0_MPORTVEC1r
#define MPORTVEC1r_SIZE BCM53115_A0_MPORTVEC1r_SIZE
typedef BCM53115_A0_MPORTVEC1r_t MPORTVEC1r_t;
#define MPORTVEC1r_CLR BCM53115_A0_MPORTVEC1r_CLR
#define MPORTVEC1r_SET BCM53115_A0_MPORTVEC1r_SET
#define MPORTVEC1r_GET BCM53115_A0_MPORTVEC1r_GET
#define MPORTVEC1r_PORT_VCTRf_GET BCM53115_A0_MPORTVEC1r_PORT_VCTRf_GET
#define MPORTVEC1r_PORT_VCTRf_SET BCM53115_A0_MPORTVEC1r_PORT_VCTRf_SET
#define MPORTVEC1r_RESERVED_Rf_GET BCM53115_A0_MPORTVEC1r_RESERVED_Rf_GET
#define MPORTVEC1r_RESERVED_Rf_SET BCM53115_A0_MPORTVEC1r_RESERVED_Rf_SET
#define READ_MPORTVEC1r BCM53115_A0_READ_MPORTVEC1r
#define WRITE_MPORTVEC1r BCM53115_A0_WRITE_MPORTVEC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MPORTVEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MPORTVEC2
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 2.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 2 register will be forwarded to each port with a bit set in the Multiport Vector 2 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MPORTVEC2r 0x00000438

#define BCM53115_A0_MPORTVEC2r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC2.
 *
 */
typedef union BCM53115_A0_MPORTVEC2r_s {
	uint32_t v[1];
	uint32_t mportvec2[1];
	uint32_t _mportvec2;
} BCM53115_A0_MPORTVEC2r_t;

#define BCM53115_A0_MPORTVEC2r_CLR(r) (r).mportvec2[0] = 0
#define BCM53115_A0_MPORTVEC2r_SET(r,d) (r).mportvec2[0] = d
#define BCM53115_A0_MPORTVEC2r_GET(r) (r).mportvec2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MPORTVEC2r_PORT_VCTRf_GET(r) (((r).mportvec2[0]) & 0x1ff)
#define BCM53115_A0_MPORTVEC2r_PORT_VCTRf_SET(r,f) (r).mportvec2[0]=(((r).mportvec2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_MPORTVEC2r_RESERVED_Rf_GET(r) ((((r).mportvec2[0]) >> 9) & 0x7fffff)
#define BCM53115_A0_MPORTVEC2r_RESERVED_Rf_SET(r,f) (r).mportvec2[0]=(((r).mportvec2[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC2.
 *
 */
#define BCM53115_A0_READ_MPORTVEC2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MPORTVEC2r,(r._mportvec2),4)
#define BCM53115_A0_WRITE_MPORTVEC2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MPORTVEC2r,&(r._mportvec2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC2r BCM53115_A0_MPORTVEC2r
#define MPORTVEC2r_SIZE BCM53115_A0_MPORTVEC2r_SIZE
typedef BCM53115_A0_MPORTVEC2r_t MPORTVEC2r_t;
#define MPORTVEC2r_CLR BCM53115_A0_MPORTVEC2r_CLR
#define MPORTVEC2r_SET BCM53115_A0_MPORTVEC2r_SET
#define MPORTVEC2r_GET BCM53115_A0_MPORTVEC2r_GET
#define MPORTVEC2r_PORT_VCTRf_GET BCM53115_A0_MPORTVEC2r_PORT_VCTRf_GET
#define MPORTVEC2r_PORT_VCTRf_SET BCM53115_A0_MPORTVEC2r_PORT_VCTRf_SET
#define MPORTVEC2r_RESERVED_Rf_GET BCM53115_A0_MPORTVEC2r_RESERVED_Rf_GET
#define MPORTVEC2r_RESERVED_Rf_SET BCM53115_A0_MPORTVEC2r_RESERVED_Rf_SET
#define READ_MPORTVEC2r BCM53115_A0_READ_MPORTVEC2r
#define WRITE_MPORTVEC2r BCM53115_A0_WRITE_MPORTVEC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MPORTVEC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MPORTVEC3
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 3 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 3.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 3 register will be forwarded to each port with a bit set in the Multiport Vector 3 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MPORTVEC3r 0x00000448

#define BCM53115_A0_MPORTVEC3r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC3.
 *
 */
typedef union BCM53115_A0_MPORTVEC3r_s {
	uint32_t v[1];
	uint32_t mportvec3[1];
	uint32_t _mportvec3;
} BCM53115_A0_MPORTVEC3r_t;

#define BCM53115_A0_MPORTVEC3r_CLR(r) (r).mportvec3[0] = 0
#define BCM53115_A0_MPORTVEC3r_SET(r,d) (r).mportvec3[0] = d
#define BCM53115_A0_MPORTVEC3r_GET(r) (r).mportvec3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MPORTVEC3r_PORT_VCTRf_GET(r) (((r).mportvec3[0]) & 0x1ff)
#define BCM53115_A0_MPORTVEC3r_PORT_VCTRf_SET(r,f) (r).mportvec3[0]=(((r).mportvec3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_MPORTVEC3r_RESERVED_Rf_GET(r) ((((r).mportvec3[0]) >> 9) & 0x7fffff)
#define BCM53115_A0_MPORTVEC3r_RESERVED_Rf_SET(r,f) (r).mportvec3[0]=(((r).mportvec3[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC3.
 *
 */
#define BCM53115_A0_READ_MPORTVEC3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MPORTVEC3r,(r._mportvec3),4)
#define BCM53115_A0_WRITE_MPORTVEC3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MPORTVEC3r,&(r._mportvec3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC3r BCM53115_A0_MPORTVEC3r
#define MPORTVEC3r_SIZE BCM53115_A0_MPORTVEC3r_SIZE
typedef BCM53115_A0_MPORTVEC3r_t MPORTVEC3r_t;
#define MPORTVEC3r_CLR BCM53115_A0_MPORTVEC3r_CLR
#define MPORTVEC3r_SET BCM53115_A0_MPORTVEC3r_SET
#define MPORTVEC3r_GET BCM53115_A0_MPORTVEC3r_GET
#define MPORTVEC3r_PORT_VCTRf_GET BCM53115_A0_MPORTVEC3r_PORT_VCTRf_GET
#define MPORTVEC3r_PORT_VCTRf_SET BCM53115_A0_MPORTVEC3r_PORT_VCTRf_SET
#define MPORTVEC3r_RESERVED_Rf_GET BCM53115_A0_MPORTVEC3r_RESERVED_Rf_GET
#define MPORTVEC3r_RESERVED_Rf_SET BCM53115_A0_MPORTVEC3r_RESERVED_Rf_SET
#define READ_MPORTVEC3r BCM53115_A0_READ_MPORTVEC3r
#define WRITE_MPORTVEC3r BCM53115_A0_WRITE_MPORTVEC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MPORTVEC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MPORTVEC4
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 4 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 4.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 4 register will be forwarded to each port with a bit set in the Multiport Vector 4 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MPORTVEC4r 0x00000458

#define BCM53115_A0_MPORTVEC4r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC4.
 *
 */
typedef union BCM53115_A0_MPORTVEC4r_s {
	uint32_t v[1];
	uint32_t mportvec4[1];
	uint32_t _mportvec4;
} BCM53115_A0_MPORTVEC4r_t;

#define BCM53115_A0_MPORTVEC4r_CLR(r) (r).mportvec4[0] = 0
#define BCM53115_A0_MPORTVEC4r_SET(r,d) (r).mportvec4[0] = d
#define BCM53115_A0_MPORTVEC4r_GET(r) (r).mportvec4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MPORTVEC4r_PORT_VCTRf_GET(r) (((r).mportvec4[0]) & 0x1ff)
#define BCM53115_A0_MPORTVEC4r_PORT_VCTRf_SET(r,f) (r).mportvec4[0]=(((r).mportvec4[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_MPORTVEC4r_RESERVED_Rf_GET(r) ((((r).mportvec4[0]) >> 9) & 0x7fffff)
#define BCM53115_A0_MPORTVEC4r_RESERVED_Rf_SET(r,f) (r).mportvec4[0]=(((r).mportvec4[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC4.
 *
 */
#define BCM53115_A0_READ_MPORTVEC4r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MPORTVEC4r,(r._mportvec4),4)
#define BCM53115_A0_WRITE_MPORTVEC4r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MPORTVEC4r,&(r._mportvec4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC4r BCM53115_A0_MPORTVEC4r
#define MPORTVEC4r_SIZE BCM53115_A0_MPORTVEC4r_SIZE
typedef BCM53115_A0_MPORTVEC4r_t MPORTVEC4r_t;
#define MPORTVEC4r_CLR BCM53115_A0_MPORTVEC4r_CLR
#define MPORTVEC4r_SET BCM53115_A0_MPORTVEC4r_SET
#define MPORTVEC4r_GET BCM53115_A0_MPORTVEC4r_GET
#define MPORTVEC4r_PORT_VCTRf_GET BCM53115_A0_MPORTVEC4r_PORT_VCTRf_GET
#define MPORTVEC4r_PORT_VCTRf_SET BCM53115_A0_MPORTVEC4r_PORT_VCTRf_SET
#define MPORTVEC4r_RESERVED_Rf_GET BCM53115_A0_MPORTVEC4r_RESERVED_Rf_GET
#define MPORTVEC4r_RESERVED_Rf_SET BCM53115_A0_MPORTVEC4r_RESERVED_Rf_SET
#define READ_MPORTVEC4r BCM53115_A0_READ_MPORTVEC4r
#define WRITE_MPORTVEC4r BCM53115_A0_WRITE_MPORTVEC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MPORTVEC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MPORTVEC5
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 5 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 5.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 5 register will be forwarded to each port with a bit set in the Multiport Vector 5 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MPORTVEC5r 0x00000468

#define BCM53115_A0_MPORTVEC5r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC5.
 *
 */
typedef union BCM53115_A0_MPORTVEC5r_s {
	uint32_t v[1];
	uint32_t mportvec5[1];
	uint32_t _mportvec5;
} BCM53115_A0_MPORTVEC5r_t;

#define BCM53115_A0_MPORTVEC5r_CLR(r) (r).mportvec5[0] = 0
#define BCM53115_A0_MPORTVEC5r_SET(r,d) (r).mportvec5[0] = d
#define BCM53115_A0_MPORTVEC5r_GET(r) (r).mportvec5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MPORTVEC5r_PORT_VCTRf_GET(r) (((r).mportvec5[0]) & 0x1ff)
#define BCM53115_A0_MPORTVEC5r_PORT_VCTRf_SET(r,f) (r).mportvec5[0]=(((r).mportvec5[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_MPORTVEC5r_RESERVED_Rf_GET(r) ((((r).mportvec5[0]) >> 9) & 0x7fffff)
#define BCM53115_A0_MPORTVEC5r_RESERVED_Rf_SET(r,f) (r).mportvec5[0]=(((r).mportvec5[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC5.
 *
 */
#define BCM53115_A0_READ_MPORTVEC5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MPORTVEC5r,(r._mportvec5),4)
#define BCM53115_A0_WRITE_MPORTVEC5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MPORTVEC5r,&(r._mportvec5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC5r BCM53115_A0_MPORTVEC5r
#define MPORTVEC5r_SIZE BCM53115_A0_MPORTVEC5r_SIZE
typedef BCM53115_A0_MPORTVEC5r_t MPORTVEC5r_t;
#define MPORTVEC5r_CLR BCM53115_A0_MPORTVEC5r_CLR
#define MPORTVEC5r_SET BCM53115_A0_MPORTVEC5r_SET
#define MPORTVEC5r_GET BCM53115_A0_MPORTVEC5r_GET
#define MPORTVEC5r_PORT_VCTRf_GET BCM53115_A0_MPORTVEC5r_PORT_VCTRf_GET
#define MPORTVEC5r_PORT_VCTRf_SET BCM53115_A0_MPORTVEC5r_PORT_VCTRf_SET
#define MPORTVEC5r_RESERVED_Rf_GET BCM53115_A0_MPORTVEC5r_RESERVED_Rf_GET
#define MPORTVEC5r_RESERVED_Rf_SET BCM53115_A0_MPORTVEC5r_RESERVED_Rf_SET
#define READ_MPORTVEC5r BCM53115_A0_READ_MPORTVEC5r
#define WRITE_MPORTVEC5r BCM53115_A0_WRITE_MPORTVEC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MPORTVEC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MST_AGE
 * BLOCKS:   SYS
 * DESC:     MST Ageing Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_EN_PRT       Per-spannibg tree aging enable.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MST_AGEr 0x00004302

#define BCM53115_A0_MST_AGEr_SIZE 4

/*
 * This structure should be used to declare and program MST_AGE.
 *
 */
typedef union BCM53115_A0_MST_AGEr_s {
	uint32_t v[1];
	uint32_t mst_age[1];
	uint32_t _mst_age;
} BCM53115_A0_MST_AGEr_t;

#define BCM53115_A0_MST_AGEr_CLR(r) (r).mst_age[0] = 0
#define BCM53115_A0_MST_AGEr_SET(r,d) (r).mst_age[0] = d
#define BCM53115_A0_MST_AGEr_GET(r) (r).mst_age[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MST_AGEr_AGE_EN_PRTf_GET(r) (((r).mst_age[0]) & 0xff)
#define BCM53115_A0_MST_AGEr_AGE_EN_PRTf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_MST_AGEr_RESERVED_Rf_GET(r) ((((r).mst_age[0]) >> 8) & 0xffffff)
#define BCM53115_A0_MST_AGEr_RESERVED_Rf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access MST_AGE.
 *
 */
#define BCM53115_A0_READ_MST_AGEr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MST_AGEr,(r._mst_age),4)
#define BCM53115_A0_WRITE_MST_AGEr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MST_AGEr,&(r._mst_age),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_AGEr BCM53115_A0_MST_AGEr
#define MST_AGEr_SIZE BCM53115_A0_MST_AGEr_SIZE
typedef BCM53115_A0_MST_AGEr_t MST_AGEr_t;
#define MST_AGEr_CLR BCM53115_A0_MST_AGEr_CLR
#define MST_AGEr_SET BCM53115_A0_MST_AGEr_SET
#define MST_AGEr_GET BCM53115_A0_MST_AGEr_GET
#define MST_AGEr_AGE_EN_PRTf_GET BCM53115_A0_MST_AGEr_AGE_EN_PRTf_GET
#define MST_AGEr_AGE_EN_PRTf_SET BCM53115_A0_MST_AGEr_AGE_EN_PRTf_SET
#define MST_AGEr_RESERVED_Rf_GET BCM53115_A0_MST_AGEr_RESERVED_Rf_GET
#define MST_AGEr_RESERVED_Rf_SET BCM53115_A0_MST_AGEr_RESERVED_Rf_SET
#define READ_MST_AGEr BCM53115_A0_READ_MST_AGEr
#define WRITE_MST_AGEr BCM53115_A0_WRITE_MST_AGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MST_AGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MST_CON
 * BLOCKS:   SYS
 * DESC:     MST Control Registers
 * SIZE:     8
 * FIELDS:
 *     EN_802_1S        
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MST_CONr 0x00004300

#define BCM53115_A0_MST_CONr_SIZE 1

/*
 * This structure should be used to declare and program MST_CON.
 *
 */
typedef union BCM53115_A0_MST_CONr_s {
	uint32_t v[1];
	uint32_t mst_con[1];
	uint32_t _mst_con;
} BCM53115_A0_MST_CONr_t;

#define BCM53115_A0_MST_CONr_CLR(r) (r).mst_con[0] = 0
#define BCM53115_A0_MST_CONr_SET(r,d) (r).mst_con[0] = d
#define BCM53115_A0_MST_CONr_GET(r) (r).mst_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MST_CONr_EN_802_1Sf_GET(r) (((r).mst_con[0]) & 0x1)
#define BCM53115_A0_MST_CONr_EN_802_1Sf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_MST_CONr_RESERVED_Rf_GET(r) ((((r).mst_con[0]) >> 1) & 0x7f)
#define BCM53115_A0_MST_CONr_RESERVED_Rf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access MST_CON.
 *
 */
#define BCM53115_A0_READ_MST_CONr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MST_CONr,(r._mst_con),1)
#define BCM53115_A0_WRITE_MST_CONr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MST_CONr,&(r._mst_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_CONr BCM53115_A0_MST_CONr
#define MST_CONr_SIZE BCM53115_A0_MST_CONr_SIZE
typedef BCM53115_A0_MST_CONr_t MST_CONr_t;
#define MST_CONr_CLR BCM53115_A0_MST_CONr_CLR
#define MST_CONr_SET BCM53115_A0_MST_CONr_SET
#define MST_CONr_GET BCM53115_A0_MST_CONr_GET
#define MST_CONr_EN_802_1Sf_GET BCM53115_A0_MST_CONr_EN_802_1Sf_GET
#define MST_CONr_EN_802_1Sf_SET BCM53115_A0_MST_CONr_EN_802_1Sf_SET
#define MST_CONr_RESERVED_Rf_GET BCM53115_A0_MST_CONr_RESERVED_Rf_GET
#define MST_CONr_RESERVED_Rf_SET BCM53115_A0_MST_CONr_RESERVED_Rf_SET
#define READ_MST_CONr BCM53115_A0_READ_MST_CONr
#define WRITE_MST_CONr BCM53115_A0_WRITE_MST_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MST_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MST_TBL
 * BLOCKS:   SYS
 * DESC:     MST Table N Enable Registers
 * SIZE:     32
 * FIELDS:
 *     SPT_STA0         Spanning tree state for port 0.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA1         Spanning tree state for port 1.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA2         Spanning tree state for port 2.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA3         Spanning tree state for port 3.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA4         Spanning tree state for port 4.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA5         Spanning tree state for port 5.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     RESERVED_R       
 *     MST_TAB_RSRV     Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_MST_TBLr 0x00004310

#define BCM53115_A0_MST_TBLr_SIZE 4

/*
 * This structure should be used to declare and program MST_TBL.
 *
 */
typedef union BCM53115_A0_MST_TBLr_s {
	uint32_t v[1];
	uint32_t mst_tbl[1];
	uint32_t _mst_tbl;
} BCM53115_A0_MST_TBLr_t;

#define BCM53115_A0_MST_TBLr_CLR(r) (r).mst_tbl[0] = 0
#define BCM53115_A0_MST_TBLr_SET(r,d) (r).mst_tbl[0] = d
#define BCM53115_A0_MST_TBLr_GET(r) (r).mst_tbl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MST_TBLr_SPT_STA0f_GET(r) (((r).mst_tbl[0]) & 0x7)
#define BCM53115_A0_MST_TBLr_SPT_STA0f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_MST_TBLr_SPT_STA1f_GET(r) ((((r).mst_tbl[0]) >> 3) & 0x7)
#define BCM53115_A0_MST_TBLr_SPT_STA1f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_MST_TBLr_SPT_STA2f_GET(r) ((((r).mst_tbl[0]) >> 6) & 0x7)
#define BCM53115_A0_MST_TBLr_SPT_STA2f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_MST_TBLr_SPT_STA3f_GET(r) ((((r).mst_tbl[0]) >> 9) & 0x7)
#define BCM53115_A0_MST_TBLr_SPT_STA3f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53115_A0_MST_TBLr_SPT_STA4f_GET(r) ((((r).mst_tbl[0]) >> 12) & 0x7)
#define BCM53115_A0_MST_TBLr_SPT_STA4f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_MST_TBLr_SPT_STA5f_GET(r) ((((r).mst_tbl[0]) >> 15) & 0x7)
#define BCM53115_A0_MST_TBLr_SPT_STA5f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53115_A0_MST_TBLr_RESERVED_Rf_GET(r) ((((r).mst_tbl[0]) >> 18) & 0x1ff)
#define BCM53115_A0_MST_TBLr_RESERVED_Rf_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x1ff << 18)) | ((((uint32_t)f) & 0x1ff) << 18))
#define BCM53115_A0_MST_TBLr_MST_TAB_RSRVf_GET(r) ((((r).mst_tbl[0]) >> 27) & 0x1f)
#define BCM53115_A0_MST_TBLr_MST_TAB_RSRVf_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access MST_TBL.
 *
 */
#define BCM53115_A0_READ_MST_TBLr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_MST_TBLr+(4*(i)),(r._mst_tbl),4)
#define BCM53115_A0_WRITE_MST_TBLr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_MST_TBLr+(4*(i)),&(r._mst_tbl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_TBLr BCM53115_A0_MST_TBLr
#define MST_TBLr_SIZE BCM53115_A0_MST_TBLr_SIZE
typedef BCM53115_A0_MST_TBLr_t MST_TBLr_t;
#define MST_TBLr_CLR BCM53115_A0_MST_TBLr_CLR
#define MST_TBLr_SET BCM53115_A0_MST_TBLr_SET
#define MST_TBLr_GET BCM53115_A0_MST_TBLr_GET
#define MST_TBLr_SPT_STA0f_GET BCM53115_A0_MST_TBLr_SPT_STA0f_GET
#define MST_TBLr_SPT_STA0f_SET BCM53115_A0_MST_TBLr_SPT_STA0f_SET
#define MST_TBLr_SPT_STA1f_GET BCM53115_A0_MST_TBLr_SPT_STA1f_GET
#define MST_TBLr_SPT_STA1f_SET BCM53115_A0_MST_TBLr_SPT_STA1f_SET
#define MST_TBLr_SPT_STA2f_GET BCM53115_A0_MST_TBLr_SPT_STA2f_GET
#define MST_TBLr_SPT_STA2f_SET BCM53115_A0_MST_TBLr_SPT_STA2f_SET
#define MST_TBLr_SPT_STA3f_GET BCM53115_A0_MST_TBLr_SPT_STA3f_GET
#define MST_TBLr_SPT_STA3f_SET BCM53115_A0_MST_TBLr_SPT_STA3f_SET
#define MST_TBLr_SPT_STA4f_GET BCM53115_A0_MST_TBLr_SPT_STA4f_GET
#define MST_TBLr_SPT_STA4f_SET BCM53115_A0_MST_TBLr_SPT_STA4f_SET
#define MST_TBLr_SPT_STA5f_GET BCM53115_A0_MST_TBLr_SPT_STA5f_GET
#define MST_TBLr_SPT_STA5f_SET BCM53115_A0_MST_TBLr_SPT_STA5f_SET
#define MST_TBLr_RESERVED_Rf_GET BCM53115_A0_MST_TBLr_RESERVED_Rf_GET
#define MST_TBLr_RESERVED_Rf_SET BCM53115_A0_MST_TBLr_RESERVED_Rf_SET
#define MST_TBLr_MST_TAB_RSRVf_GET BCM53115_A0_MST_TBLr_MST_TAB_RSRVf_GET
#define MST_TBLr_MST_TAB_RSRVf_SET BCM53115_A0_MST_TBLr_MST_TAB_RSRVf_SET
#define READ_MST_TBLr BCM53115_A0_READ_MST_TBLr
#define WRITE_MST_TBLr BCM53115_A0_WRITE_MST_TBLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MST_TBLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MULTIPORT_ADDR0
 * BLOCKS:   SYS
 * DESC:     Multiport Address 0 Register (Default for TS)
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 0.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 0 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 0Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 0 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53115_A0_MULTIPORT_ADDR0r 0x00000410

#define BCM53115_A0_MULTIPORT_ADDR0r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR0.
 *
 */
typedef union BCM53115_A0_MULTIPORT_ADDR0r_s {
	uint32_t v[2];
	uint32_t multiport_addr0[2];
	uint32_t _multiport_addr0;
} BCM53115_A0_MULTIPORT_ADDR0r_t;

#define BCM53115_A0_MULTIPORT_ADDR0r_CLR(r) CDK_MEMSET(&((r)._multiport_addr0), 0, sizeof(BCM53115_A0_MULTIPORT_ADDR0r_t))
#define BCM53115_A0_MULTIPORT_ADDR0r_SET(r,i,d) (r).multiport_addr0[i] = d
#define BCM53115_A0_MULTIPORT_ADDR0r_GET(r,i) (r).multiport_addr0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr0,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr0,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr0[1]) >> 16) & 0xffff)
#define BCM53115_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr0[1]=(((r).multiport_addr0[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR0.
 *
 */
#define BCM53115_A0_READ_MULTIPORT_ADDR0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MULTIPORT_ADDR0r,(r._multiport_addr0),8)
#define BCM53115_A0_WRITE_MULTIPORT_ADDR0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MULTIPORT_ADDR0r,&(r._multiport_addr0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR0r BCM53115_A0_MULTIPORT_ADDR0r
#define MULTIPORT_ADDR0r_SIZE BCM53115_A0_MULTIPORT_ADDR0r_SIZE
typedef BCM53115_A0_MULTIPORT_ADDR0r_t MULTIPORT_ADDR0r_t;
#define MULTIPORT_ADDR0r_CLR BCM53115_A0_MULTIPORT_ADDR0r_CLR
#define MULTIPORT_ADDR0r_SET BCM53115_A0_MULTIPORT_ADDR0r_SET
#define MULTIPORT_ADDR0r_GET BCM53115_A0_MULTIPORT_ADDR0r_GET
#define MULTIPORT_ADDR0r_MPORT_ADDRf_GET BCM53115_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR0r_MPORT_ADDRf_SET BCM53115_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET BCM53115_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET BCM53115_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR0r BCM53115_A0_READ_MULTIPORT_ADDR0r
#define WRITE_MULTIPORT_ADDR0r BCM53115_A0_WRITE_MULTIPORT_ADDR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MULTIPORT_ADDR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MULTIPORT_ADDR1
 * BLOCKS:   SYS
 * DESC:     Multiport Address 1 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 1.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 1Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53115_A0_MULTIPORT_ADDR1r 0x00000420

#define BCM53115_A0_MULTIPORT_ADDR1r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR1.
 *
 */
typedef union BCM53115_A0_MULTIPORT_ADDR1r_s {
	uint32_t v[2];
	uint32_t multiport_addr1[2];
	uint32_t _multiport_addr1;
} BCM53115_A0_MULTIPORT_ADDR1r_t;

#define BCM53115_A0_MULTIPORT_ADDR1r_CLR(r) CDK_MEMSET(&((r)._multiport_addr1), 0, sizeof(BCM53115_A0_MULTIPORT_ADDR1r_t))
#define BCM53115_A0_MULTIPORT_ADDR1r_SET(r,i,d) (r).multiport_addr1[i] = d
#define BCM53115_A0_MULTIPORT_ADDR1r_GET(r,i) (r).multiport_addr1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr1,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr1,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr1[1]) >> 16) & 0xffff)
#define BCM53115_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr1[1]=(((r).multiport_addr1[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR1.
 *
 */
#define BCM53115_A0_READ_MULTIPORT_ADDR1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MULTIPORT_ADDR1r,(r._multiport_addr1),8)
#define BCM53115_A0_WRITE_MULTIPORT_ADDR1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MULTIPORT_ADDR1r,&(r._multiport_addr1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR1r BCM53115_A0_MULTIPORT_ADDR1r
#define MULTIPORT_ADDR1r_SIZE BCM53115_A0_MULTIPORT_ADDR1r_SIZE
typedef BCM53115_A0_MULTIPORT_ADDR1r_t MULTIPORT_ADDR1r_t;
#define MULTIPORT_ADDR1r_CLR BCM53115_A0_MULTIPORT_ADDR1r_CLR
#define MULTIPORT_ADDR1r_SET BCM53115_A0_MULTIPORT_ADDR1r_SET
#define MULTIPORT_ADDR1r_GET BCM53115_A0_MULTIPORT_ADDR1r_GET
#define MULTIPORT_ADDR1r_MPORT_ADDRf_GET BCM53115_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR1r_MPORT_ADDRf_SET BCM53115_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET BCM53115_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET BCM53115_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR1r BCM53115_A0_READ_MULTIPORT_ADDR1r
#define WRITE_MULTIPORT_ADDR1r BCM53115_A0_WRITE_MULTIPORT_ADDR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MULTIPORT_ADDR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MULTIPORT_ADDR2
 * BLOCKS:   SYS
 * DESC:     Multiport Address 2 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 2.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 2Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53115_A0_MULTIPORT_ADDR2r 0x00000430

#define BCM53115_A0_MULTIPORT_ADDR2r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR2.
 *
 */
typedef union BCM53115_A0_MULTIPORT_ADDR2r_s {
	uint32_t v[2];
	uint32_t multiport_addr2[2];
	uint32_t _multiport_addr2;
} BCM53115_A0_MULTIPORT_ADDR2r_t;

#define BCM53115_A0_MULTIPORT_ADDR2r_CLR(r) CDK_MEMSET(&((r)._multiport_addr2), 0, sizeof(BCM53115_A0_MULTIPORT_ADDR2r_t))
#define BCM53115_A0_MULTIPORT_ADDR2r_SET(r,i,d) (r).multiport_addr2[i] = d
#define BCM53115_A0_MULTIPORT_ADDR2r_GET(r,i) (r).multiport_addr2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr2,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr2,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr2[1]) >> 16) & 0xffff)
#define BCM53115_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr2[1]=(((r).multiport_addr2[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR2.
 *
 */
#define BCM53115_A0_READ_MULTIPORT_ADDR2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MULTIPORT_ADDR2r,(r._multiport_addr2),8)
#define BCM53115_A0_WRITE_MULTIPORT_ADDR2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MULTIPORT_ADDR2r,&(r._multiport_addr2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR2r BCM53115_A0_MULTIPORT_ADDR2r
#define MULTIPORT_ADDR2r_SIZE BCM53115_A0_MULTIPORT_ADDR2r_SIZE
typedef BCM53115_A0_MULTIPORT_ADDR2r_t MULTIPORT_ADDR2r_t;
#define MULTIPORT_ADDR2r_CLR BCM53115_A0_MULTIPORT_ADDR2r_CLR
#define MULTIPORT_ADDR2r_SET BCM53115_A0_MULTIPORT_ADDR2r_SET
#define MULTIPORT_ADDR2r_GET BCM53115_A0_MULTIPORT_ADDR2r_GET
#define MULTIPORT_ADDR2r_MPORT_ADDRf_GET BCM53115_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR2r_MPORT_ADDRf_SET BCM53115_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET BCM53115_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET BCM53115_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR2r BCM53115_A0_READ_MULTIPORT_ADDR2r
#define WRITE_MULTIPORT_ADDR2r BCM53115_A0_WRITE_MULTIPORT_ADDR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MULTIPORT_ADDR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MULTIPORT_ADDR3
 * BLOCKS:   SYS
 * DESC:     Multiport Address 3 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 3.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 3 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 3Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 3 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53115_A0_MULTIPORT_ADDR3r 0x00000440

#define BCM53115_A0_MULTIPORT_ADDR3r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR3.
 *
 */
typedef union BCM53115_A0_MULTIPORT_ADDR3r_s {
	uint32_t v[2];
	uint32_t multiport_addr3[2];
	uint32_t _multiport_addr3;
} BCM53115_A0_MULTIPORT_ADDR3r_t;

#define BCM53115_A0_MULTIPORT_ADDR3r_CLR(r) CDK_MEMSET(&((r)._multiport_addr3), 0, sizeof(BCM53115_A0_MULTIPORT_ADDR3r_t))
#define BCM53115_A0_MULTIPORT_ADDR3r_SET(r,i,d) (r).multiport_addr3[i] = d
#define BCM53115_A0_MULTIPORT_ADDR3r_GET(r,i) (r).multiport_addr3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr3,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr3,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr3[1]) >> 16) & 0xffff)
#define BCM53115_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr3[1]=(((r).multiport_addr3[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR3.
 *
 */
#define BCM53115_A0_READ_MULTIPORT_ADDR3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MULTIPORT_ADDR3r,(r._multiport_addr3),8)
#define BCM53115_A0_WRITE_MULTIPORT_ADDR3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MULTIPORT_ADDR3r,&(r._multiport_addr3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR3r BCM53115_A0_MULTIPORT_ADDR3r
#define MULTIPORT_ADDR3r_SIZE BCM53115_A0_MULTIPORT_ADDR3r_SIZE
typedef BCM53115_A0_MULTIPORT_ADDR3r_t MULTIPORT_ADDR3r_t;
#define MULTIPORT_ADDR3r_CLR BCM53115_A0_MULTIPORT_ADDR3r_CLR
#define MULTIPORT_ADDR3r_SET BCM53115_A0_MULTIPORT_ADDR3r_SET
#define MULTIPORT_ADDR3r_GET BCM53115_A0_MULTIPORT_ADDR3r_GET
#define MULTIPORT_ADDR3r_MPORT_ADDRf_GET BCM53115_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR3r_MPORT_ADDRf_SET BCM53115_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET BCM53115_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET BCM53115_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR3r BCM53115_A0_READ_MULTIPORT_ADDR3r
#define WRITE_MULTIPORT_ADDR3r BCM53115_A0_WRITE_MULTIPORT_ADDR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MULTIPORT_ADDR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MULTIPORT_ADDR4
 * BLOCKS:   SYS
 * DESC:     Multiport Address 4 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 4.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 4 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 4Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 4 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53115_A0_MULTIPORT_ADDR4r 0x00000450

#define BCM53115_A0_MULTIPORT_ADDR4r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR4.
 *
 */
typedef union BCM53115_A0_MULTIPORT_ADDR4r_s {
	uint32_t v[2];
	uint32_t multiport_addr4[2];
	uint32_t _multiport_addr4;
} BCM53115_A0_MULTIPORT_ADDR4r_t;

#define BCM53115_A0_MULTIPORT_ADDR4r_CLR(r) CDK_MEMSET(&((r)._multiport_addr4), 0, sizeof(BCM53115_A0_MULTIPORT_ADDR4r_t))
#define BCM53115_A0_MULTIPORT_ADDR4r_SET(r,i,d) (r).multiport_addr4[i] = d
#define BCM53115_A0_MULTIPORT_ADDR4r_GET(r,i) (r).multiport_addr4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr4,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr4,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr4[1]) >> 16) & 0xffff)
#define BCM53115_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr4[1]=(((r).multiport_addr4[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR4.
 *
 */
#define BCM53115_A0_READ_MULTIPORT_ADDR4r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MULTIPORT_ADDR4r,(r._multiport_addr4),8)
#define BCM53115_A0_WRITE_MULTIPORT_ADDR4r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MULTIPORT_ADDR4r,&(r._multiport_addr4),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR4r BCM53115_A0_MULTIPORT_ADDR4r
#define MULTIPORT_ADDR4r_SIZE BCM53115_A0_MULTIPORT_ADDR4r_SIZE
typedef BCM53115_A0_MULTIPORT_ADDR4r_t MULTIPORT_ADDR4r_t;
#define MULTIPORT_ADDR4r_CLR BCM53115_A0_MULTIPORT_ADDR4r_CLR
#define MULTIPORT_ADDR4r_SET BCM53115_A0_MULTIPORT_ADDR4r_SET
#define MULTIPORT_ADDR4r_GET BCM53115_A0_MULTIPORT_ADDR4r_GET
#define MULTIPORT_ADDR4r_MPORT_ADDRf_GET BCM53115_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR4r_MPORT_ADDRf_SET BCM53115_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET BCM53115_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET BCM53115_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR4r BCM53115_A0_READ_MULTIPORT_ADDR4r
#define WRITE_MULTIPORT_ADDR4r BCM53115_A0_WRITE_MULTIPORT_ADDR4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MULTIPORT_ADDR4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MULTIPORT_ADDR5
 * BLOCKS:   SYS
 * DESC:     Multiport Address 5 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 5.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 5 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 5Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 5 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53115_A0_MULTIPORT_ADDR5r 0x00000460

#define BCM53115_A0_MULTIPORT_ADDR5r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR5.
 *
 */
typedef union BCM53115_A0_MULTIPORT_ADDR5r_s {
	uint32_t v[2];
	uint32_t multiport_addr5[2];
	uint32_t _multiport_addr5;
} BCM53115_A0_MULTIPORT_ADDR5r_t;

#define BCM53115_A0_MULTIPORT_ADDR5r_CLR(r) CDK_MEMSET(&((r)._multiport_addr5), 0, sizeof(BCM53115_A0_MULTIPORT_ADDR5r_t))
#define BCM53115_A0_MULTIPORT_ADDR5r_SET(r,i,d) (r).multiport_addr5[i] = d
#define BCM53115_A0_MULTIPORT_ADDR5r_GET(r,i) (r).multiport_addr5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr5,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr5,0,47,a)
#define BCM53115_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr5[1]) >> 16) & 0xffff)
#define BCM53115_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr5[1]=(((r).multiport_addr5[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR5.
 *
 */
#define BCM53115_A0_READ_MULTIPORT_ADDR5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_MULTIPORT_ADDR5r,(r._multiport_addr5),8)
#define BCM53115_A0_WRITE_MULTIPORT_ADDR5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_MULTIPORT_ADDR5r,&(r._multiport_addr5),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR5r BCM53115_A0_MULTIPORT_ADDR5r
#define MULTIPORT_ADDR5r_SIZE BCM53115_A0_MULTIPORT_ADDR5r_SIZE
typedef BCM53115_A0_MULTIPORT_ADDR5r_t MULTIPORT_ADDR5r_t;
#define MULTIPORT_ADDR5r_CLR BCM53115_A0_MULTIPORT_ADDR5r_CLR
#define MULTIPORT_ADDR5r_SET BCM53115_A0_MULTIPORT_ADDR5r_SET
#define MULTIPORT_ADDR5r_GET BCM53115_A0_MULTIPORT_ADDR5r_GET
#define MULTIPORT_ADDR5r_MPORT_ADDRf_GET BCM53115_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR5r_MPORT_ADDRf_SET BCM53115_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET BCM53115_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET BCM53115_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR5r BCM53115_A0_READ_MULTIPORT_ADDR5r
#define WRITE_MULTIPORT_ADDR5r BCM53115_A0_WRITE_MULTIPORT_ADDR5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MULTIPORT_ADDR5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  MULTI_PORT_CTL
 * BLOCKS:   SYS
 * DESC:     Multiport Control Register
 * SIZE:     16
 * FIELDS:
 *     MPORT_CTRL0      Multiport 0 Control .1'b00: Disable Multiport 0 Forward1'b10: Compare MPORT_ADD0 only, Forward based on MPORT_Vector 0 if matched1'b01: Compare MPORT_EYPE0 only, Forward based on MPORT_Vector 0 if matched1'b11: Compare MPORT_EYPE0 and MPORT_ADD0, Forward based on MPORT_Vector 0 if matched
 *     MPORT_CTRL1      Multiport 1 Control .1'b00: Disable Multiport 1 Forward1'b10: Compare MPORT_ADD1 only, Forward based on MPORT_Vector 1 if matched1'b01: Compare MPORT_EYPE1 only, Forward based on MPORT_Vector 1 if matched1'b11: Compare MPORT_EYPE1 and MPORT_ADD1, Forward based on MPORT_Vector 1 if matched
 *     MPORT_CTRL2      Multiport 2 Control .1'b00: Disable Multiport 2 Forward1'b10: Compare MPORT_ADD2 only, Forward based on MPORT_Vector 2 if matched1'b01: Compare MPORT_EYPE2 only, Forward based on MPORT_Vector 2 if matched1'b11: Compare MPORT_EYPE2 and MPORT_ADD2, Forward based on MPORT_Vector 2 if matched
 *     MPORT_CTRL3      Multiport 3 Control .1'b00: Disable Multiport 3 Forward1'b10: Compare MPORT_ADD3 only, Forward based on MPORT_Vector 3 if matched1'b01: Compare MPORT_EYPE3 only, Forward based on MPORT_Vector 3 if matched1'b11: Compare MPORT_EYPE3 and MPORT_ADD3, Forward based on MPORT_Vector 3 if matched
 *     MPORT_CTRL4      Multiport 4 Control .1'b00: Disable Multiport 4 Forward1'b10: Compare MPORT_ADD4 only, Forward based on MPORT_Vector 4 if matched1'b01: Compare MPORT_EYPE4 only, Forward based on MPORT_Vector 4 if matched1'b11: Compare MPORT_EYPE4 and MPORT_ADD4, Forward based on MPORT_Vector 4 if matched
 *     MPORT_CTRL5      Multiport 5 Control .1'b00: Disable Multiport 5 Forward1'b10: Compare MPORT_ADD5 only, Forward based on MPORT_Vector 5 if matched1'b01: Compare MPORT_EYPE5 only, Forward based on MPORT_Vector 5 if matched1'b11: Compare MPORT_EYPE5 and MPORT_ADD5, Forward based on MPORT_Vector 5 if matched
 *     RESERVED_R       Reserved
 *     MPORT0_TS_EN     Mport 0 Time Sync Enable1: Packet will be time stamped if forwarded to CPU.  MPORT_VECTOR0 should be programed to CPU only if the bit is set0: Packet will not be time-stamped
 *
 ******************************************************************************/
#define BCM53115_A0_MULTI_PORT_CTLr 0x0000040e

#define BCM53115_A0_MULTI_PORT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program MULTI_PORT_CTL.
 *
 */
typedef union BCM53115_A0_MULTI_PORT_CTLr_s {
	uint32_t v[1];
	uint32_t multi_port_ctl[1];
	uint32_t _multi_port_ctl;
} BCM53115_A0_MULTI_PORT_CTLr_t;

#define BCM53115_A0_MULTI_PORT_CTLr_CLR(r) (r).multi_port_ctl[0] = 0
#define BCM53115_A0_MULTI_PORT_CTLr_SET(r,d) (r).multi_port_ctl[0] = d
#define BCM53115_A0_MULTI_PORT_CTLr_GET(r) (r).multi_port_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_GET(r) (((r).multi_port_ctl[0]) & 0x3)
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_GET(r) ((((r).multi_port_ctl[0]) >> 2) & 0x3)
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_GET(r) ((((r).multi_port_ctl[0]) >> 4) & 0x3)
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_GET(r) ((((r).multi_port_ctl[0]) >> 6) & 0x3)
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_GET(r) ((((r).multi_port_ctl[0]) >> 8) & 0x3)
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_GET(r) ((((r).multi_port_ctl[0]) >> 10) & 0x3)
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53115_A0_MULTI_PORT_CTLr_RESERVED_Rf_GET(r) ((((r).multi_port_ctl[0]) >> 12) & 0x7)
#define BCM53115_A0_MULTI_PORT_CTLr_RESERVED_Rf_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_GET(r) ((((r).multi_port_ctl[0]) >> 15) & 0x1)
#define BCM53115_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MULTI_PORT_CTL.
 *
 */
#define BCM53115_A0_READ_MULTI_PORT_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_MULTI_PORT_CTLr,(r._multi_port_ctl),2)
#define BCM53115_A0_WRITE_MULTI_PORT_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_MULTI_PORT_CTLr,&(r._multi_port_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTI_PORT_CTLr BCM53115_A0_MULTI_PORT_CTLr
#define MULTI_PORT_CTLr_SIZE BCM53115_A0_MULTI_PORT_CTLr_SIZE
typedef BCM53115_A0_MULTI_PORT_CTLr_t MULTI_PORT_CTLr_t;
#define MULTI_PORT_CTLr_CLR BCM53115_A0_MULTI_PORT_CTLr_CLR
#define MULTI_PORT_CTLr_SET BCM53115_A0_MULTI_PORT_CTLr_SET
#define MULTI_PORT_CTLr_GET BCM53115_A0_MULTI_PORT_CTLr_GET
#define MULTI_PORT_CTLr_MPORT_CTRL0f_GET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL0f_SET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL1f_GET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL1f_SET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL2f_GET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL2f_SET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL3f_GET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL3f_SET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL4f_GET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL4f_SET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL5f_GET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL5f_SET BCM53115_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_SET
#define MULTI_PORT_CTLr_RESERVED_Rf_GET BCM53115_A0_MULTI_PORT_CTLr_RESERVED_Rf_GET
#define MULTI_PORT_CTLr_RESERVED_Rf_SET BCM53115_A0_MULTI_PORT_CTLr_RESERVED_Rf_SET
#define MULTI_PORT_CTLr_MPORT0_TS_ENf_GET BCM53115_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_GET
#define MULTI_PORT_CTLr_MPORT0_TS_ENf_SET BCM53115_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_SET
#define READ_MULTI_PORT_CTLr BCM53115_A0_READ_MULTI_PORT_CTLr
#define WRITE_MULTI_PORT_CTLr BCM53115_A0_WRITE_MULTI_PORT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_MULTI_PORT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  NEW_CTRL
 * BLOCKS:   SYS
 * DESC:     New Control Register
 * SIZE:     8
 * FIELDS:
 *     IP_MC            When set to a '1' it will support the new 4K IP multicast address scheme.
 *     OUTRANGEERR_DISCARD When enabled, the ingress port will discard the frames with length field between 1500 and 1536 (exclude 1500 and 1536) and with good CRC. This option only controls the length field checking but not the frame length checking.
 *     INRANGEERR_DISCARD When enabled, the ingress port will discard the frames with Length field mismatch the frame length.
 *     RESERVED_R       Reserved
 *     UC_FWD_EN        Unicast Forward Enable when ARL Miss.1: To enable DFL packet with unicast destination address to foward to ports defined as page 0,offset 34h.
 *     MC_FWD_EN        Multicast Foward Enable when ARL Miss.1: To enable DFL packet with multicast destination address to foward to the ports defined as page 0,offset 34h.
 *
 ******************************************************************************/
#define BCM53115_A0_NEW_CTRLr 0x00000021

#define BCM53115_A0_NEW_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program NEW_CTRL.
 *
 */
typedef union BCM53115_A0_NEW_CTRLr_s {
	uint32_t v[1];
	uint32_t new_ctrl[1];
	uint32_t _new_ctrl;
} BCM53115_A0_NEW_CTRLr_t;

#define BCM53115_A0_NEW_CTRLr_CLR(r) (r).new_ctrl[0] = 0
#define BCM53115_A0_NEW_CTRLr_SET(r,d) (r).new_ctrl[0] = d
#define BCM53115_A0_NEW_CTRLr_GET(r) (r).new_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_NEW_CTRLr_IP_MCf_GET(r) (((r).new_ctrl[0]) & 0x1)
#define BCM53115_A0_NEW_CTRLr_IP_MCf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_GET(r) ((((r).new_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_NEW_CTRLr_INRANGEERR_DISCARDf_GET(r) ((((r).new_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_NEW_CTRLr_INRANGEERR_DISCARDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_NEW_CTRLr_RESERVED_Rf_GET(r) ((((r).new_ctrl[0]) >> 3) & 0x7)
#define BCM53115_A0_NEW_CTRLr_RESERVED_Rf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_NEW_CTRLr_UC_FWD_ENf_GET(r) ((((r).new_ctrl[0]) >> 6) & 0x1)
#define BCM53115_A0_NEW_CTRLr_UC_FWD_ENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_NEW_CTRLr_MC_FWD_ENf_GET(r) ((((r).new_ctrl[0]) >> 7) & 0x1)
#define BCM53115_A0_NEW_CTRLr_MC_FWD_ENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access NEW_CTRL.
 *
 */
#define BCM53115_A0_READ_NEW_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_NEW_CTRLr,(r._new_ctrl),1)
#define BCM53115_A0_WRITE_NEW_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_NEW_CTRLr,&(r._new_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NEW_CTRLr BCM53115_A0_NEW_CTRLr
#define NEW_CTRLr_SIZE BCM53115_A0_NEW_CTRLr_SIZE
typedef BCM53115_A0_NEW_CTRLr_t NEW_CTRLr_t;
#define NEW_CTRLr_CLR BCM53115_A0_NEW_CTRLr_CLR
#define NEW_CTRLr_SET BCM53115_A0_NEW_CTRLr_SET
#define NEW_CTRLr_GET BCM53115_A0_NEW_CTRLr_GET
#define NEW_CTRLr_IP_MCf_GET BCM53115_A0_NEW_CTRLr_IP_MCf_GET
#define NEW_CTRLr_IP_MCf_SET BCM53115_A0_NEW_CTRLr_IP_MCf_SET
#define NEW_CTRLr_OUTRANGEERR_DISCARDf_GET BCM53115_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_GET
#define NEW_CTRLr_OUTRANGEERR_DISCARDf_SET BCM53115_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_SET
#define NEW_CTRLr_INRANGEERR_DISCARDf_GET BCM53115_A0_NEW_CTRLr_INRANGEERR_DISCARDf_GET
#define NEW_CTRLr_INRANGEERR_DISCARDf_SET BCM53115_A0_NEW_CTRLr_INRANGEERR_DISCARDf_SET
#define NEW_CTRLr_RESERVED_Rf_GET BCM53115_A0_NEW_CTRLr_RESERVED_Rf_GET
#define NEW_CTRLr_RESERVED_Rf_SET BCM53115_A0_NEW_CTRLr_RESERVED_Rf_SET
#define NEW_CTRLr_UC_FWD_ENf_GET BCM53115_A0_NEW_CTRLr_UC_FWD_ENf_GET
#define NEW_CTRLr_UC_FWD_ENf_SET BCM53115_A0_NEW_CTRLr_UC_FWD_ENf_SET
#define NEW_CTRLr_MC_FWD_ENf_GET BCM53115_A0_NEW_CTRLr_MC_FWD_ENf_GET
#define NEW_CTRLr_MC_FWD_ENf_SET BCM53115_A0_NEW_CTRLr_MC_FWD_ENf_SET
#define READ_NEW_CTRLr BCM53115_A0_READ_NEW_CTRLr
#define WRITE_NEW_CTRLr BCM53115_A0_WRITE_NEW_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_NEW_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  OTP_CTL_REG
 * BLOCKS:   SYS
 * DESC:     CPU OTP Control Registers
 * SIZE:     32
 * FIELDS:
 *     START_R          
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_OTP_CTL_REGr 0x0000e000

#define BCM53115_A0_OTP_CTL_REGr_SIZE 4

/*
 * This structure should be used to declare and program OTP_CTL_REG.
 *
 */
typedef union BCM53115_A0_OTP_CTL_REGr_s {
	uint32_t v[1];
	uint32_t otp_ctl_reg[1];
	uint32_t _otp_ctl_reg;
} BCM53115_A0_OTP_CTL_REGr_t;

#define BCM53115_A0_OTP_CTL_REGr_CLR(r) (r).otp_ctl_reg[0] = 0
#define BCM53115_A0_OTP_CTL_REGr_SET(r,d) (r).otp_ctl_reg[0] = d
#define BCM53115_A0_OTP_CTL_REGr_GET(r) (r).otp_ctl_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_OTP_CTL_REGr_START_Rf_GET(r) (((r).otp_ctl_reg[0]) & 0x1)
#define BCM53115_A0_OTP_CTL_REGr_START_Rf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_OTP_CTL_REGr_RESERVED_Rf_GET(r) ((((r).otp_ctl_reg[0]) >> 1) & 0x7fffffff)
#define BCM53115_A0_OTP_CTL_REGr_RESERVED_Rf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access OTP_CTL_REG.
 *
 */
#define BCM53115_A0_READ_OTP_CTL_REGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_OTP_CTL_REGr,(r._otp_ctl_reg),4)
#define BCM53115_A0_WRITE_OTP_CTL_REGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_OTP_CTL_REGr,&(r._otp_ctl_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_CTL_REGr BCM53115_A0_OTP_CTL_REGr
#define OTP_CTL_REGr_SIZE BCM53115_A0_OTP_CTL_REGr_SIZE
typedef BCM53115_A0_OTP_CTL_REGr_t OTP_CTL_REGr_t;
#define OTP_CTL_REGr_CLR BCM53115_A0_OTP_CTL_REGr_CLR
#define OTP_CTL_REGr_SET BCM53115_A0_OTP_CTL_REGr_SET
#define OTP_CTL_REGr_GET BCM53115_A0_OTP_CTL_REGr_GET
#define OTP_CTL_REGr_START_Rf_GET BCM53115_A0_OTP_CTL_REGr_START_Rf_GET
#define OTP_CTL_REGr_START_Rf_SET BCM53115_A0_OTP_CTL_REGr_START_Rf_SET
#define OTP_CTL_REGr_RESERVED_Rf_GET BCM53115_A0_OTP_CTL_REGr_RESERVED_Rf_GET
#define OTP_CTL_REGr_RESERVED_Rf_SET BCM53115_A0_OTP_CTL_REGr_RESERVED_Rf_SET
#define READ_OTP_CTL_REGr BCM53115_A0_READ_OTP_CTL_REGr
#define WRITE_OTP_CTL_REGr BCM53115_A0_WRITE_OTP_CTL_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_OTP_CTL_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  OutRangeErrCount
 * BLOCKS:   GPIC0 CPIC
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_OUTRANGEERRCOUNTr 0x000020b4

#define BCM53115_A0_OUTRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program OutRangeErrCount.
 *
 */
typedef union BCM53115_A0_OUTRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t outrangeerrcount[1];
	uint32_t _outrangeerrcount;
} BCM53115_A0_OUTRANGEERRCOUNTr_t;

#define BCM53115_A0_OUTRANGEERRCOUNTr_CLR(r) (r).outrangeerrcount[0] = 0
#define BCM53115_A0_OUTRANGEERRCOUNTr_SET(r,d) (r).outrangeerrcount[0] = d
#define BCM53115_A0_OUTRANGEERRCOUNTr_GET(r) (r).outrangeerrcount[0]


/*
 * These macros can be used to access OutRangeErrCount.
 *
 */
#define BCM53115_A0_READ_OUTRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_OUTRANGEERRCOUNTr,(r._outrangeerrcount),4)
#define BCM53115_A0_WRITE_OUTRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_OUTRANGEERRCOUNTr,&(r._outrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTRANGEERRCOUNTr BCM53115_A0_OUTRANGEERRCOUNTr
#define OUTRANGEERRCOUNTr_SIZE BCM53115_A0_OUTRANGEERRCOUNTr_SIZE
typedef BCM53115_A0_OUTRANGEERRCOUNTr_t OUTRANGEERRCOUNTr_t;
#define OUTRANGEERRCOUNTr_CLR BCM53115_A0_OUTRANGEERRCOUNTr_CLR
#define OUTRANGEERRCOUNTr_SET BCM53115_A0_OUTRANGEERRCOUNTr_SET
#define OUTRANGEERRCOUNTr_GET BCM53115_A0_OUTRANGEERRCOUNTr_GET
#define READ_OUTRANGEERRCOUNTr BCM53115_A0_READ_OUTRANGEERRCOUNTr
#define WRITE_OUTRANGEERRCOUNTr BCM53115_A0_WRITE_OUTRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_OUTRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  P5_RGMII_TIME_DLY_GP
 * BLOCKS:   SYS
 * DESC:     Port 5 RGMII TIMING DELAY register
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr 0x0000006d

#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program P5_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM53115_A0_P5_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t p5_rgmii_time_dly_gp[1];
	uint32_t _p5_rgmii_time_dly_gp;
} BCM53115_A0_P5_RGMII_TIME_DLY_GPr_t;

#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_CLR(r) (r).p5_rgmii_time_dly_gp[0] = 0
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_SET(r,d) (r).p5_rgmii_time_dly_gp[0] = d
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_GET(r) (r).p5_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).p5_rgmii_time_dly_gp[0]) & 0xf)
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).p5_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).p5_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access P5_RGMII_TIME_DLY_GP.
 *
 */
#define BCM53115_A0_READ_P5_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_P5_RGMII_TIME_DLY_GPr,(r._p5_rgmii_time_dly_gp),1)
#define BCM53115_A0_WRITE_P5_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_P5_RGMII_TIME_DLY_GPr,&(r._p5_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P5_RGMII_TIME_DLY_GPr BCM53115_A0_P5_RGMII_TIME_DLY_GPr
#define P5_RGMII_TIME_DLY_GPr_SIZE BCM53115_A0_P5_RGMII_TIME_DLY_GPr_SIZE
typedef BCM53115_A0_P5_RGMII_TIME_DLY_GPr_t P5_RGMII_TIME_DLY_GPr_t;
#define P5_RGMII_TIME_DLY_GPr_CLR BCM53115_A0_P5_RGMII_TIME_DLY_GPr_CLR
#define P5_RGMII_TIME_DLY_GPr_SET BCM53115_A0_P5_RGMII_TIME_DLY_GPr_SET
#define P5_RGMII_TIME_DLY_GPr_GET BCM53115_A0_P5_RGMII_TIME_DLY_GPr_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM53115_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_P5_RGMII_TIME_DLY_GPr BCM53115_A0_READ_P5_RGMII_TIME_DLY_GPr
#define WRITE_P5_RGMII_TIME_DLY_GPr BCM53115_A0_WRITE_P5_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_P5_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  P8_PCP2TC
 * BLOCKS:   SYS
 * DESC:     Port 8 PCP to TC Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_P8_PCP2TCr 0x00003028

#define BCM53115_A0_P8_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program P8_PCP2TC.
 *
 */
typedef union BCM53115_A0_P8_PCP2TCr_s {
	uint32_t v[1];
	uint32_t p8_pcp2tc[1];
	uint32_t _p8_pcp2tc;
} BCM53115_A0_P8_PCP2TCr_t;

#define BCM53115_A0_P8_PCP2TCr_CLR(r) (r).p8_pcp2tc[0] = 0
#define BCM53115_A0_P8_PCP2TCr_SET(r,d) (r).p8_pcp2tc[0] = d
#define BCM53115_A0_P8_PCP2TCr_GET(r) (r).p8_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_P8_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).p8_pcp2tc[0]) & 0x7)
#define BCM53115_A0_P8_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_P8_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).p8_pcp2tc[0]) >> 3) & 0x7)
#define BCM53115_A0_P8_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_P8_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).p8_pcp2tc[0]) >> 6) & 0x7)
#define BCM53115_A0_P8_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_P8_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).p8_pcp2tc[0]) >> 9) & 0x7)
#define BCM53115_A0_P8_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53115_A0_P8_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).p8_pcp2tc[0]) >> 12) & 0x7)
#define BCM53115_A0_P8_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_P8_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).p8_pcp2tc[0]) >> 15) & 0x7)
#define BCM53115_A0_P8_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53115_A0_P8_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).p8_pcp2tc[0]) >> 18) & 0x7)
#define BCM53115_A0_P8_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53115_A0_P8_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).p8_pcp2tc[0]) >> 21) & 0x7)
#define BCM53115_A0_P8_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_P8_PCP2TCr_RESERVED_Rf_GET(r) ((((r).p8_pcp2tc[0]) >> 24) & 0xff)
#define BCM53115_A0_P8_PCP2TCr_RESERVED_Rf_SET(r,f) (r).p8_pcp2tc[0]=(((r).p8_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access P8_PCP2TC.
 *
 */
#define BCM53115_A0_READ_P8_PCP2TCr(u,r) cdk_robo_reg_read(u,BCM53115_A0_P8_PCP2TCr,(r._p8_pcp2tc),4)
#define BCM53115_A0_WRITE_P8_PCP2TCr(u,r) cdk_robo_reg_write(u,BCM53115_A0_P8_PCP2TCr,&(r._p8_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P8_PCP2TCr BCM53115_A0_P8_PCP2TCr
#define P8_PCP2TCr_SIZE BCM53115_A0_P8_PCP2TCr_SIZE
typedef BCM53115_A0_P8_PCP2TCr_t P8_PCP2TCr_t;
#define P8_PCP2TCr_CLR BCM53115_A0_P8_PCP2TCr_CLR
#define P8_PCP2TCr_SET BCM53115_A0_P8_PCP2TCr_SET
#define P8_PCP2TCr_GET BCM53115_A0_P8_PCP2TCr_GET
#define P8_PCP2TCr_TAG000_PRI_MAPf_GET BCM53115_A0_P8_PCP2TCr_TAG000_PRI_MAPf_GET
#define P8_PCP2TCr_TAG000_PRI_MAPf_SET BCM53115_A0_P8_PCP2TCr_TAG000_PRI_MAPf_SET
#define P8_PCP2TCr_TAG001_PRI_MAPf_GET BCM53115_A0_P8_PCP2TCr_TAG001_PRI_MAPf_GET
#define P8_PCP2TCr_TAG001_PRI_MAPf_SET BCM53115_A0_P8_PCP2TCr_TAG001_PRI_MAPf_SET
#define P8_PCP2TCr_TAG010_PRI_MAPf_GET BCM53115_A0_P8_PCP2TCr_TAG010_PRI_MAPf_GET
#define P8_PCP2TCr_TAG010_PRI_MAPf_SET BCM53115_A0_P8_PCP2TCr_TAG010_PRI_MAPf_SET
#define P8_PCP2TCr_TAG011_PRI_MAPf_GET BCM53115_A0_P8_PCP2TCr_TAG011_PRI_MAPf_GET
#define P8_PCP2TCr_TAG011_PRI_MAPf_SET BCM53115_A0_P8_PCP2TCr_TAG011_PRI_MAPf_SET
#define P8_PCP2TCr_TAG100_PRI_MAPf_GET BCM53115_A0_P8_PCP2TCr_TAG100_PRI_MAPf_GET
#define P8_PCP2TCr_TAG100_PRI_MAPf_SET BCM53115_A0_P8_PCP2TCr_TAG100_PRI_MAPf_SET
#define P8_PCP2TCr_TAG101_PRI_MAPf_GET BCM53115_A0_P8_PCP2TCr_TAG101_PRI_MAPf_GET
#define P8_PCP2TCr_TAG101_PRI_MAPf_SET BCM53115_A0_P8_PCP2TCr_TAG101_PRI_MAPf_SET
#define P8_PCP2TCr_TAG110_PRI_MAPf_GET BCM53115_A0_P8_PCP2TCr_TAG110_PRI_MAPf_GET
#define P8_PCP2TCr_TAG110_PRI_MAPf_SET BCM53115_A0_P8_PCP2TCr_TAG110_PRI_MAPf_SET
#define P8_PCP2TCr_TAG111_PRI_MAPf_GET BCM53115_A0_P8_PCP2TCr_TAG111_PRI_MAPf_GET
#define P8_PCP2TCr_TAG111_PRI_MAPf_SET BCM53115_A0_P8_PCP2TCr_TAG111_PRI_MAPf_SET
#define P8_PCP2TCr_RESERVED_Rf_GET BCM53115_A0_P8_PCP2TCr_RESERVED_Rf_GET
#define P8_PCP2TCr_RESERVED_Rf_SET BCM53115_A0_P8_PCP2TCr_RESERVED_Rf_SET
#define READ_P8_PCP2TCr BCM53115_A0_READ_P8_PCP2TCr
#define WRITE_P8_PCP2TCr BCM53115_A0_WRITE_P8_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_P8_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PAGEREG
 * BLOCKS:   SYS
 * DESC:     PAGE Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       Next Page
 *
 ******************************************************************************/
#define BCM53115_A0_PAGEREGr 0x0000ffff

#define BCM53115_A0_PAGEREGr_SIZE 1

/*
 * This structure should be used to declare and program PAGEREG.
 *
 */
typedef union BCM53115_A0_PAGEREGr_s {
	uint32_t v[1];
	uint32_t pagereg[1];
	uint32_t _pagereg;
} BCM53115_A0_PAGEREGr_t;

#define BCM53115_A0_PAGEREGr_CLR(r) (r).pagereg[0] = 0
#define BCM53115_A0_PAGEREGr_SET(r,d) (r).pagereg[0] = d
#define BCM53115_A0_PAGEREGr_GET(r) (r).pagereg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PAGEREGr_RESERVED_Rf_GET(r) (((r).pagereg[0]) & 0xff)
#define BCM53115_A0_PAGEREGr_RESERVED_Rf_SET(r,f) (r).pagereg[0]=(((r).pagereg[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PAGEREG.
 *
 */
#define BCM53115_A0_READ_PAGEREGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PAGEREGr,(r._pagereg),1)
#define BCM53115_A0_WRITE_PAGEREGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PAGEREGr,&(r._pagereg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAGEREGr BCM53115_A0_PAGEREGr
#define PAGEREGr_SIZE BCM53115_A0_PAGEREGr_SIZE
typedef BCM53115_A0_PAGEREGr_t PAGEREGr_t;
#define PAGEREGr_CLR BCM53115_A0_PAGEREGr_CLR
#define PAGEREGr_SET BCM53115_A0_PAGEREGr_SET
#define PAGEREGr_GET BCM53115_A0_PAGEREGr_GET
#define PAGEREGr_RESERVED_Rf_GET BCM53115_A0_PAGEREGr_RESERVED_Rf_GET
#define PAGEREGr_RESERVED_Rf_SET BCM53115_A0_PAGEREGr_RESERVED_Rf_SET
#define READ_PAGEREGr BCM53115_A0_READ_PAGEREGr
#define WRITE_PAGEREGr BCM53115_A0_WRITE_PAGEREGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PAGEREGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PAUSESTS
 * BLOCKS:   SYS
 * DESC:     Pause Status Summary Register
 * SIZE:     32
 * FIELDS:
 *     PAUSE_STS        PAUSE State.18 bit field indicating the PAUSE state for each 10/100/1000BASE-T port and IMP port.Bit 8- 0 = IMP port, Port 7 - Port 0 Transmit Pause CapabilityBit 17-8 = IMP port, Port 7 - Port 0 Receive Pause Capability0 = Disabled1 = Enabled
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PAUSESTSr 0x0000010a

#define BCM53115_A0_PAUSESTSr_SIZE 4

/*
 * This structure should be used to declare and program PAUSESTS.
 *
 */
typedef union BCM53115_A0_PAUSESTSr_s {
	uint32_t v[1];
	uint32_t pausests[1];
	uint32_t _pausests;
} BCM53115_A0_PAUSESTSr_t;

#define BCM53115_A0_PAUSESTSr_CLR(r) (r).pausests[0] = 0
#define BCM53115_A0_PAUSESTSr_SET(r,d) (r).pausests[0] = d
#define BCM53115_A0_PAUSESTSr_GET(r) (r).pausests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PAUSESTSr_PAUSE_STSf_GET(r) (((r).pausests[0]) & 0x3ffff)
#define BCM53115_A0_PAUSESTSr_PAUSE_STSf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53115_A0_PAUSESTSr_RESERVED_Rf_GET(r) ((((r).pausests[0]) >> 18) & 0x3fff)
#define BCM53115_A0_PAUSESTSr_RESERVED_Rf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PAUSESTS.
 *
 */
#define BCM53115_A0_READ_PAUSESTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PAUSESTSr,(r._pausests),4)
#define BCM53115_A0_WRITE_PAUSESTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PAUSESTSr,&(r._pausests),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSESTSr BCM53115_A0_PAUSESTSr
#define PAUSESTSr_SIZE BCM53115_A0_PAUSESTSr_SIZE
typedef BCM53115_A0_PAUSESTSr_t PAUSESTSr_t;
#define PAUSESTSr_CLR BCM53115_A0_PAUSESTSr_CLR
#define PAUSESTSr_SET BCM53115_A0_PAUSESTSr_SET
#define PAUSESTSr_GET BCM53115_A0_PAUSESTSr_GET
#define PAUSESTSr_PAUSE_STSf_GET BCM53115_A0_PAUSESTSr_PAUSE_STSf_GET
#define PAUSESTSr_PAUSE_STSf_SET BCM53115_A0_PAUSESTSr_PAUSE_STSf_SET
#define PAUSESTSr_RESERVED_Rf_GET BCM53115_A0_PAUSESTSr_RESERVED_Rf_GET
#define PAUSESTSr_RESERVED_Rf_SET BCM53115_A0_PAUSESTSr_RESERVED_Rf_SET
#define READ_PAUSESTSr BCM53115_A0_READ_PAUSESTSr
#define WRITE_PAUSESTSr BCM53115_A0_WRITE_PAUSESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PAUSESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PAUSE_CAP
 * BLOCKS:   SYS
 * DESC:     PAUSE Capability Register
 * SIZE:     32
 * FIELDS:
 *     TX_PAUSE_CAP     Software setting for the capability of Transmitting Pause Frame.Bit 8 = MII Port.Bits 7:0 = Port 8 - Port 0.
 *     RX_PAUSE_CAP     Software setting for the capability of Receiving Pause Frame.Bit 17 = MII Port 1,Bits 16:9 = Port 7- Port 0.
 *     RESERVED_R       Reserved
 *     EN_OVERRIDE      Force the contents of the register to be used.
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PAUSE_CAPr 0x00000028

#define BCM53115_A0_PAUSE_CAPr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CAP.
 *
 */
typedef union BCM53115_A0_PAUSE_CAPr_s {
	uint32_t v[1];
	uint32_t pause_cap[1];
	uint32_t _pause_cap;
} BCM53115_A0_PAUSE_CAPr_t;

#define BCM53115_A0_PAUSE_CAPr_CLR(r) (r).pause_cap[0] = 0
#define BCM53115_A0_PAUSE_CAPr_SET(r,d) (r).pause_cap[0] = d
#define BCM53115_A0_PAUSE_CAPr_GET(r) (r).pause_cap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET(r) (((r).pause_cap[0]) & 0x1ff)
#define BCM53115_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET(r) ((((r).pause_cap[0]) >> 9) & 0x1ff)
#define BCM53115_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53115_A0_PAUSE_CAPr_RESERVED_Rf_GET(r) ((((r).pause_cap[0]) >> 18) & 0x1f)
#define BCM53115_A0_PAUSE_CAPr_RESERVED_Rf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM53115_A0_PAUSE_CAPr_EN_OVERRIDEf_GET(r) ((((r).pause_cap[0]) >> 23) & 0x1)
#define BCM53115_A0_PAUSE_CAPr_EN_OVERRIDEf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53115_A0_PAUSE_CAPr_RESERVED_1Rf_GET(r) ((((r).pause_cap[0]) >> 24) & 0xff)
#define BCM53115_A0_PAUSE_CAPr_RESERVED_1Rf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PAUSE_CAP.
 *
 */
#define BCM53115_A0_READ_PAUSE_CAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PAUSE_CAPr,(r._pause_cap),4)
#define BCM53115_A0_WRITE_PAUSE_CAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PAUSE_CAPr,&(r._pause_cap),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CAPr BCM53115_A0_PAUSE_CAPr
#define PAUSE_CAPr_SIZE BCM53115_A0_PAUSE_CAPr_SIZE
typedef BCM53115_A0_PAUSE_CAPr_t PAUSE_CAPr_t;
#define PAUSE_CAPr_CLR BCM53115_A0_PAUSE_CAPr_CLR
#define PAUSE_CAPr_SET BCM53115_A0_PAUSE_CAPr_SET
#define PAUSE_CAPr_GET BCM53115_A0_PAUSE_CAPr_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_GET BCM53115_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_SET BCM53115_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RX_PAUSE_CAPf_GET BCM53115_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET
#define PAUSE_CAPr_RX_PAUSE_CAPf_SET BCM53115_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RESERVED_Rf_GET BCM53115_A0_PAUSE_CAPr_RESERVED_Rf_GET
#define PAUSE_CAPr_RESERVED_Rf_SET BCM53115_A0_PAUSE_CAPr_RESERVED_Rf_SET
#define PAUSE_CAPr_EN_OVERRIDEf_GET BCM53115_A0_PAUSE_CAPr_EN_OVERRIDEf_GET
#define PAUSE_CAPr_EN_OVERRIDEf_SET BCM53115_A0_PAUSE_CAPr_EN_OVERRIDEf_SET
#define PAUSE_CAPr_RESERVED_1Rf_GET BCM53115_A0_PAUSE_CAPr_RESERVED_1Rf_GET
#define PAUSE_CAPr_RESERVED_1Rf_SET BCM53115_A0_PAUSE_CAPr_RESERVED_1Rf_SET
#define READ_PAUSE_CAPr BCM53115_A0_READ_PAUSE_CAPr
#define WRITE_PAUSE_CAPr BCM53115_A0_WRITE_PAUSE_CAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PAUSE_CAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PAUSE_FRM_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause Frame Detection Control Registrer
 * SIZE:     8
 * FIELDS:
 *     PAUSE_IGNORE_DA  Pause_ignore_Da0: Check DA field on Pause Frame detection1: Ignore DA field on Pause Frame detection
 *     RESERVED_1R      Reserved
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PAUSE_FRM_CTRLr 0x00000080

#define BCM53115_A0_PAUSE_FRM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PAUSE_FRM_CTRL.
 *
 */
typedef union BCM53115_A0_PAUSE_FRM_CTRLr_s {
	uint32_t v[1];
	uint32_t pause_frm_ctrl[1];
	uint32_t _pause_frm_ctrl;
} BCM53115_A0_PAUSE_FRM_CTRLr_t;

#define BCM53115_A0_PAUSE_FRM_CTRLr_CLR(r) (r).pause_frm_ctrl[0] = 0
#define BCM53115_A0_PAUSE_FRM_CTRLr_SET(r,d) (r).pause_frm_ctrl[0] = d
#define BCM53115_A0_PAUSE_FRM_CTRLr_GET(r) (r).pause_frm_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET(r) (((r).pause_frm_ctrl[0]) & 0x1)
#define BCM53115_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_PAUSE_FRM_CTRLr_RESERVED_1Rf_GET(r) ((((r).pause_frm_ctrl[0]) >> 1) & 0x3)
#define BCM53115_A0_PAUSE_FRM_CTRLr_RESERVED_1Rf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53115_A0_PAUSE_FRM_CTRLr_RESERVED_2Rf_GET(r) ((((r).pause_frm_ctrl[0]) >> 3) & 0x1f)
#define BCM53115_A0_PAUSE_FRM_CTRLr_RESERVED_2Rf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access PAUSE_FRM_CTRL.
 *
 */
#define BCM53115_A0_READ_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PAUSE_FRM_CTRLr,(r._pause_frm_ctrl),1)
#define BCM53115_A0_WRITE_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PAUSE_FRM_CTRLr,&(r._pause_frm_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_FRM_CTRLr BCM53115_A0_PAUSE_FRM_CTRLr
#define PAUSE_FRM_CTRLr_SIZE BCM53115_A0_PAUSE_FRM_CTRLr_SIZE
typedef BCM53115_A0_PAUSE_FRM_CTRLr_t PAUSE_FRM_CTRLr_t;
#define PAUSE_FRM_CTRLr_CLR BCM53115_A0_PAUSE_FRM_CTRLr_CLR
#define PAUSE_FRM_CTRLr_SET BCM53115_A0_PAUSE_FRM_CTRLr_SET
#define PAUSE_FRM_CTRLr_GET BCM53115_A0_PAUSE_FRM_CTRLr_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET BCM53115_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET BCM53115_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET
#define PAUSE_FRM_CTRLr_RESERVED_1Rf_GET BCM53115_A0_PAUSE_FRM_CTRLr_RESERVED_1Rf_GET
#define PAUSE_FRM_CTRLr_RESERVED_1Rf_SET BCM53115_A0_PAUSE_FRM_CTRLr_RESERVED_1Rf_SET
#define PAUSE_FRM_CTRLr_RESERVED_2Rf_GET BCM53115_A0_PAUSE_FRM_CTRLr_RESERVED_2Rf_GET
#define PAUSE_FRM_CTRLr_RESERVED_2Rf_SET BCM53115_A0_PAUSE_FRM_CTRLr_RESERVED_2Rf_SET
#define READ_PAUSE_FRM_CTRLr BCM53115_A0_READ_PAUSE_FRM_CTRLr
#define WRITE_PAUSE_FRM_CTRLr BCM53115_A0_WRITE_PAUSE_FRM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PAUSE_FRM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PAUSE_QUANTA
 * BLOCKS:   SYS
 * DESC:     PAUSE Quanta register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_QUANTA     The number of slot times that the transmitter wishes the link partner to suspend its transmission. The same value is common to all ports which have Auto-Negotiated to full duplex with flow control enabled.
 *
 ******************************************************************************/
#define BCM53115_A0_PAUSE_QUANTAr 0x0000000c

#define BCM53115_A0_PAUSE_QUANTAr_SIZE 2

/*
 * This structure should be used to declare and program PAUSE_QUANTA.
 *
 */
typedef union BCM53115_A0_PAUSE_QUANTAr_s {
	uint32_t v[1];
	uint32_t pause_quanta[1];
	uint32_t _pause_quanta;
} BCM53115_A0_PAUSE_QUANTAr_t;

#define BCM53115_A0_PAUSE_QUANTAr_CLR(r) (r).pause_quanta[0] = 0
#define BCM53115_A0_PAUSE_QUANTAr_SET(r,d) (r).pause_quanta[0] = d
#define BCM53115_A0_PAUSE_QUANTAr_GET(r) (r).pause_quanta[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET(r) (((r).pause_quanta[0]) & 0xffff)
#define BCM53115_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET(r,f) (r).pause_quanta[0]=(((r).pause_quanta[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PAUSE_QUANTA.
 *
 */
#define BCM53115_A0_READ_PAUSE_QUANTAr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PAUSE_QUANTAr,(r._pause_quanta),2)
#define BCM53115_A0_WRITE_PAUSE_QUANTAr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PAUSE_QUANTAr,&(r._pause_quanta),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_QUANTAr BCM53115_A0_PAUSE_QUANTAr
#define PAUSE_QUANTAr_SIZE BCM53115_A0_PAUSE_QUANTAr_SIZE
typedef BCM53115_A0_PAUSE_QUANTAr_t PAUSE_QUANTAr_t;
#define PAUSE_QUANTAr_CLR BCM53115_A0_PAUSE_QUANTAr_CLR
#define PAUSE_QUANTAr_SET BCM53115_A0_PAUSE_QUANTAr_SET
#define PAUSE_QUANTAr_GET BCM53115_A0_PAUSE_QUANTAr_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_GET BCM53115_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_SET BCM53115_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET
#define READ_PAUSE_QUANTAr BCM53115_A0_READ_PAUSE_QUANTAr
#define WRITE_PAUSE_QUANTAr BCM53115_A0_WRITE_PAUSE_QUANTAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PAUSE_QUANTAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PBPTRFIFO_0
 * BLOCKS:   SYS
 * DESC:     PBPTRFIFO Status Register 0
 * SIZE:     48
 * FIELDS:
 *     VALID_CNT_P0     
 *     VALID_CNT_P1     
 *     VALID_CNT_P2     
 *     VALID_CNT_P3     
 *     VALID_CNT_P4     
 *     VALID_CNT_P5     
 *
 ******************************************************************************/
#define BCM53115_A0_PBPTRFIFO_0r 0x00000150

#define BCM53115_A0_PBPTRFIFO_0r_SIZE 6

/*
 * This structure should be used to declare and program PBPTRFIFO_0.
 *
 */
typedef union BCM53115_A0_PBPTRFIFO_0r_s {
	uint32_t v[2];
	uint32_t pbptrfifo_0[2];
	uint32_t _pbptrfifo_0;
} BCM53115_A0_PBPTRFIFO_0r_t;

#define BCM53115_A0_PBPTRFIFO_0r_CLR(r) CDK_MEMSET(&((r)._pbptrfifo_0), 0, sizeof(BCM53115_A0_PBPTRFIFO_0r_t))
#define BCM53115_A0_PBPTRFIFO_0r_SET(r,i,d) (r).pbptrfifo_0[i] = d
#define BCM53115_A0_PBPTRFIFO_0r_GET(r,i) (r).pbptrfifo_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P0f_GET(r) (((r).pbptrfifo_0[0]) & 0xff)
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P0f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P1f_GET(r) ((((r).pbptrfifo_0[0]) >> 8) & 0xff)
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P1f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P2f_GET(r) ((((r).pbptrfifo_0[0]) >> 16) & 0xff)
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P2f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P3f_GET(r) ((((r).pbptrfifo_0[0]) >> 24) & 0xff)
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P3f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P4f_GET(r) (((r).pbptrfifo_0[1]) & 0xff)
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P4f_SET(r,f) (r).pbptrfifo_0[1]=(((r).pbptrfifo_0[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P5f_GET(r) ((((r).pbptrfifo_0[1]) >> 8) & 0xff)
#define BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P5f_SET(r,f) (r).pbptrfifo_0[1]=(((r).pbptrfifo_0[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access PBPTRFIFO_0.
 *
 */
#define BCM53115_A0_READ_PBPTRFIFO_0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_PBPTRFIFO_0r,(r._pbptrfifo_0),6)
#define BCM53115_A0_WRITE_PBPTRFIFO_0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_PBPTRFIFO_0r,&(r._pbptrfifo_0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PBPTRFIFO_0r BCM53115_A0_PBPTRFIFO_0r
#define PBPTRFIFO_0r_SIZE BCM53115_A0_PBPTRFIFO_0r_SIZE
typedef BCM53115_A0_PBPTRFIFO_0r_t PBPTRFIFO_0r_t;
#define PBPTRFIFO_0r_CLR BCM53115_A0_PBPTRFIFO_0r_CLR
#define PBPTRFIFO_0r_SET BCM53115_A0_PBPTRFIFO_0r_SET
#define PBPTRFIFO_0r_GET BCM53115_A0_PBPTRFIFO_0r_GET
#define PBPTRFIFO_0r_VALID_CNT_P0f_GET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P0f_GET
#define PBPTRFIFO_0r_VALID_CNT_P0f_SET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P0f_SET
#define PBPTRFIFO_0r_VALID_CNT_P1f_GET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P1f_GET
#define PBPTRFIFO_0r_VALID_CNT_P1f_SET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P1f_SET
#define PBPTRFIFO_0r_VALID_CNT_P2f_GET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P2f_GET
#define PBPTRFIFO_0r_VALID_CNT_P2f_SET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P2f_SET
#define PBPTRFIFO_0r_VALID_CNT_P3f_GET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P3f_GET
#define PBPTRFIFO_0r_VALID_CNT_P3f_SET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P3f_SET
#define PBPTRFIFO_0r_VALID_CNT_P4f_GET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P4f_GET
#define PBPTRFIFO_0r_VALID_CNT_P4f_SET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P4f_SET
#define PBPTRFIFO_0r_VALID_CNT_P5f_GET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P5f_GET
#define PBPTRFIFO_0r_VALID_CNT_P5f_SET BCM53115_A0_PBPTRFIFO_0r_VALID_CNT_P5f_SET
#define READ_PBPTRFIFO_0r BCM53115_A0_READ_PBPTRFIFO_0r
#define WRITE_PBPTRFIFO_0r BCM53115_A0_WRITE_PBPTRFIFO_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PBPTRFIFO_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PBPTRFIFO_1
 * BLOCKS:   SYS
 * DESC:     PBPTRFIFO Status Register 1
 * SIZE:     16
 * FIELDS:
 *     VALID_CNT_P8     
 *     RESERVED_R       
 *
 ******************************************************************************/
#define BCM53115_A0_PBPTRFIFO_1r 0x00000156

#define BCM53115_A0_PBPTRFIFO_1r_SIZE 2

/*
 * This structure should be used to declare and program PBPTRFIFO_1.
 *
 */
typedef union BCM53115_A0_PBPTRFIFO_1r_s {
	uint32_t v[1];
	uint32_t pbptrfifo_1[1];
	uint32_t _pbptrfifo_1;
} BCM53115_A0_PBPTRFIFO_1r_t;

#define BCM53115_A0_PBPTRFIFO_1r_CLR(r) (r).pbptrfifo_1[0] = 0
#define BCM53115_A0_PBPTRFIFO_1r_SET(r,d) (r).pbptrfifo_1[0] = d
#define BCM53115_A0_PBPTRFIFO_1r_GET(r) (r).pbptrfifo_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PBPTRFIFO_1r_VALID_CNT_P8f_GET(r) (((r).pbptrfifo_1[0]) & 0xff)
#define BCM53115_A0_PBPTRFIFO_1r_VALID_CNT_P8f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_PBPTRFIFO_1r_RESERVED_Rf_GET(r) ((((r).pbptrfifo_1[0]) >> 8) & 0xff)
#define BCM53115_A0_PBPTRFIFO_1r_RESERVED_Rf_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access PBPTRFIFO_1.
 *
 */
#define BCM53115_A0_READ_PBPTRFIFO_1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_PBPTRFIFO_1r,(r._pbptrfifo_1),2)
#define BCM53115_A0_WRITE_PBPTRFIFO_1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_PBPTRFIFO_1r,&(r._pbptrfifo_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PBPTRFIFO_1r BCM53115_A0_PBPTRFIFO_1r
#define PBPTRFIFO_1r_SIZE BCM53115_A0_PBPTRFIFO_1r_SIZE
typedef BCM53115_A0_PBPTRFIFO_1r_t PBPTRFIFO_1r_t;
#define PBPTRFIFO_1r_CLR BCM53115_A0_PBPTRFIFO_1r_CLR
#define PBPTRFIFO_1r_SET BCM53115_A0_PBPTRFIFO_1r_SET
#define PBPTRFIFO_1r_GET BCM53115_A0_PBPTRFIFO_1r_GET
#define PBPTRFIFO_1r_VALID_CNT_P8f_GET BCM53115_A0_PBPTRFIFO_1r_VALID_CNT_P8f_GET
#define PBPTRFIFO_1r_VALID_CNT_P8f_SET BCM53115_A0_PBPTRFIFO_1r_VALID_CNT_P8f_SET
#define PBPTRFIFO_1r_RESERVED_Rf_GET BCM53115_A0_PBPTRFIFO_1r_RESERVED_Rf_GET
#define PBPTRFIFO_1r_RESERVED_Rf_SET BCM53115_A0_PBPTRFIFO_1r_RESERVED_Rf_SET
#define READ_PBPTRFIFO_1r BCM53115_A0_READ_PBPTRFIFO_1r
#define WRITE_PBPTRFIFO_1r BCM53115_A0_WRITE_PBPTRFIFO_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PBPTRFIFO_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PHY_PWR_DOWN
 * BLOCKS:   SYS
 * DESC:     PHY Power Down Mode Registrer
 * SIZE:     16
 * FIELDS:
 *     PHY_PWR_DOWN_MODE 
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PHY_PWR_DOWNr 0x0000004c

#define BCM53115_A0_PHY_PWR_DOWNr_SIZE 2

/*
 * This structure should be used to declare and program PHY_PWR_DOWN.
 *
 */
typedef union BCM53115_A0_PHY_PWR_DOWNr_s {
	uint32_t v[1];
	uint32_t phy_pwr_down[1];
	uint32_t _phy_pwr_down;
} BCM53115_A0_PHY_PWR_DOWNr_t;

#define BCM53115_A0_PHY_PWR_DOWNr_CLR(r) (r).phy_pwr_down[0] = 0
#define BCM53115_A0_PHY_PWR_DOWNr_SET(r,d) (r).phy_pwr_down[0] = d
#define BCM53115_A0_PHY_PWR_DOWNr_GET(r) (r).phy_pwr_down[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_MODEf_GET(r) (((r).phy_pwr_down[0]) & 0x1f)
#define BCM53115_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_MODEf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_PHY_PWR_DOWNr_RESERVED_Rf_GET(r) ((((r).phy_pwr_down[0]) >> 5) & 0x7ff)
#define BCM53115_A0_PHY_PWR_DOWNr_RESERVED_Rf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))

/*
 * These macros can be used to access PHY_PWR_DOWN.
 *
 */
#define BCM53115_A0_READ_PHY_PWR_DOWNr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PHY_PWR_DOWNr,(r._phy_pwr_down),2)
#define BCM53115_A0_WRITE_PHY_PWR_DOWNr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PHY_PWR_DOWNr,&(r._phy_pwr_down),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_PWR_DOWNr BCM53115_A0_PHY_PWR_DOWNr
#define PHY_PWR_DOWNr_SIZE BCM53115_A0_PHY_PWR_DOWNr_SIZE
typedef BCM53115_A0_PHY_PWR_DOWNr_t PHY_PWR_DOWNr_t;
#define PHY_PWR_DOWNr_CLR BCM53115_A0_PHY_PWR_DOWNr_CLR
#define PHY_PWR_DOWNr_SET BCM53115_A0_PHY_PWR_DOWNr_SET
#define PHY_PWR_DOWNr_GET BCM53115_A0_PHY_PWR_DOWNr_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_MODEf_GET BCM53115_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_MODEf_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_MODEf_SET BCM53115_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_MODEf_SET
#define PHY_PWR_DOWNr_RESERVED_Rf_GET BCM53115_A0_PHY_PWR_DOWNr_RESERVED_Rf_GET
#define PHY_PWR_DOWNr_RESERVED_Rf_SET BCM53115_A0_PHY_PWR_DOWNr_RESERVED_Rf_SET
#define READ_PHY_PWR_DOWNr BCM53115_A0_READ_PHY_PWR_DOWNr
#define WRITE_PHY_PWR_DOWNr BCM53115_A0_WRITE_PHY_PWR_DOWNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PHY_PWR_DOWNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PLL_FREQ_SEL
 * BLOCKS:   SYS
 * DESC:     Bonding PAD status Registrer(Engineering Use Only)
 * SIZE:     32
 * FIELDS:
 *     CLKSET_KEY       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PLL_FREQ_SELr 0x000000fa

#define BCM53115_A0_PLL_FREQ_SELr_SIZE 4

/*
 * This structure should be used to declare and program PLL_FREQ_SEL.
 *
 */
typedef union BCM53115_A0_PLL_FREQ_SELr_s {
	uint32_t v[1];
	uint32_t pll_freq_sel[1];
	uint32_t _pll_freq_sel;
} BCM53115_A0_PLL_FREQ_SELr_t;

#define BCM53115_A0_PLL_FREQ_SELr_CLR(r) (r).pll_freq_sel[0] = 0
#define BCM53115_A0_PLL_FREQ_SELr_SET(r,d) (r).pll_freq_sel[0] = d
#define BCM53115_A0_PLL_FREQ_SELr_GET(r) (r).pll_freq_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PLL_FREQ_SELr_CLKSET_KEYf_GET(r) ((r).pll_freq_sel[0])
#define BCM53115_A0_PLL_FREQ_SELr_CLKSET_KEYf_SET(r,f) (r).pll_freq_sel[0]=((uint32_t)f)

/*
 * These macros can be used to access PLL_FREQ_SEL.
 *
 */
#define BCM53115_A0_READ_PLL_FREQ_SELr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PLL_FREQ_SELr,(r._pll_freq_sel),4)
#define BCM53115_A0_WRITE_PLL_FREQ_SELr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PLL_FREQ_SELr,&(r._pll_freq_sel),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_FREQ_SELr BCM53115_A0_PLL_FREQ_SELr
#define PLL_FREQ_SELr_SIZE BCM53115_A0_PLL_FREQ_SELr_SIZE
typedef BCM53115_A0_PLL_FREQ_SELr_t PLL_FREQ_SELr_t;
#define PLL_FREQ_SELr_CLR BCM53115_A0_PLL_FREQ_SELr_CLR
#define PLL_FREQ_SELr_SET BCM53115_A0_PLL_FREQ_SELr_SET
#define PLL_FREQ_SELr_GET BCM53115_A0_PLL_FREQ_SELr_GET
#define PLL_FREQ_SELr_CLKSET_KEYf_GET BCM53115_A0_PLL_FREQ_SELr_CLKSET_KEYf_GET
#define PLL_FREQ_SELr_CLKSET_KEYf_SET BCM53115_A0_PLL_FREQ_SELr_CLKSET_KEYf_SET
#define READ_PLL_FREQ_SELr BCM53115_A0_READ_PLL_FREQ_SELr
#define WRITE_PLL_FREQ_SELr BCM53115_A0_WRITE_PLL_FREQ_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PLL_FREQ_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PLL_TEST_CTRL_I
 * BLOCKS:   SYS
 * DESC:     PLL Test Control Register I Registrer
 * SIZE:     8
 * FIELDS:
 *     PLL_SW_RST       
 *     PLL_TEST_EN      
 *     PLL_TEST_SEL     
 *     PLL_VCO_RNG      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PLL_TEST_CTRL_Ir 0x000000d0

#define BCM53115_A0_PLL_TEST_CTRL_Ir_SIZE 1

/*
 * This structure should be used to declare and program PLL_TEST_CTRL_I.
 *
 */
typedef union BCM53115_A0_PLL_TEST_CTRL_Ir_s {
	uint32_t v[1];
	uint32_t pll_test_ctrl_i[1];
	uint32_t _pll_test_ctrl_i;
} BCM53115_A0_PLL_TEST_CTRL_Ir_t;

#define BCM53115_A0_PLL_TEST_CTRL_Ir_CLR(r) (r).pll_test_ctrl_i[0] = 0
#define BCM53115_A0_PLL_TEST_CTRL_Ir_SET(r,d) (r).pll_test_ctrl_i[0] = d
#define BCM53115_A0_PLL_TEST_CTRL_Ir_GET(r) (r).pll_test_ctrl_i[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET(r) (((r).pll_test_ctrl_i[0]) & 0x1)
#define BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 1) & 0x1)
#define BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 2) & 0x7)
#define BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 5) & 0x3)
#define BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53115_A0_PLL_TEST_CTRL_Ir_RESERVED_Rf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 7) & 0x1)
#define BCM53115_A0_PLL_TEST_CTRL_Ir_RESERVED_Rf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PLL_TEST_CTRL_I.
 *
 */
#define BCM53115_A0_READ_PLL_TEST_CTRL_Ir(u,r) cdk_robo_reg_read(u,BCM53115_A0_PLL_TEST_CTRL_Ir,(r._pll_test_ctrl_i),1)
#define BCM53115_A0_WRITE_PLL_TEST_CTRL_Ir(u,r) cdk_robo_reg_write(u,BCM53115_A0_PLL_TEST_CTRL_Ir,&(r._pll_test_ctrl_i),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TEST_CTRL_Ir BCM53115_A0_PLL_TEST_CTRL_Ir
#define PLL_TEST_CTRL_Ir_SIZE BCM53115_A0_PLL_TEST_CTRL_Ir_SIZE
typedef BCM53115_A0_PLL_TEST_CTRL_Ir_t PLL_TEST_CTRL_Ir_t;
#define PLL_TEST_CTRL_Ir_CLR BCM53115_A0_PLL_TEST_CTRL_Ir_CLR
#define PLL_TEST_CTRL_Ir_SET BCM53115_A0_PLL_TEST_CTRL_Ir_SET
#define PLL_TEST_CTRL_Ir_GET BCM53115_A0_PLL_TEST_CTRL_Ir_GET
#define PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET
#define PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET
#define PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET
#define PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET
#define PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET
#define PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET
#define PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET
#define PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET BCM53115_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET
#define PLL_TEST_CTRL_Ir_RESERVED_Rf_GET BCM53115_A0_PLL_TEST_CTRL_Ir_RESERVED_Rf_GET
#define PLL_TEST_CTRL_Ir_RESERVED_Rf_SET BCM53115_A0_PLL_TEST_CTRL_Ir_RESERVED_Rf_SET
#define READ_PLL_TEST_CTRL_Ir BCM53115_A0_READ_PLL_TEST_CTRL_Ir
#define WRITE_PLL_TEST_CTRL_Ir BCM53115_A0_WRITE_PLL_TEST_CTRL_Ir

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PLL_TEST_CTRL_Ir'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PLL_TEST_CTRL_II
 * BLOCKS:   SYS
 * DESC:     PLL Test Control Register II Registrer
 * SIZE:     48
 * FIELDS:
 *     PLL_TEST_CTRL    
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PLL_TEST_CTRL_IIr 0x000000d1

#define BCM53115_A0_PLL_TEST_CTRL_IIr_SIZE 6

/*
 * This structure should be used to declare and program PLL_TEST_CTRL_II.
 *
 */
typedef union BCM53115_A0_PLL_TEST_CTRL_IIr_s {
	uint32_t v[2];
	uint32_t pll_test_ctrl_ii[2];
	uint32_t _pll_test_ctrl_ii;
} BCM53115_A0_PLL_TEST_CTRL_IIr_t;

#define BCM53115_A0_PLL_TEST_CTRL_IIr_CLR(r) CDK_MEMSET(&((r)._pll_test_ctrl_ii), 0, sizeof(BCM53115_A0_PLL_TEST_CTRL_IIr_t))
#define BCM53115_A0_PLL_TEST_CTRL_IIr_SET(r,i,d) (r).pll_test_ctrl_ii[i] = d
#define BCM53115_A0_PLL_TEST_CTRL_IIr_GET(r,i) (r).pll_test_ctrl_ii[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET(r,a) cdk_field_get((r).pll_test_ctrl_ii,0,37,a)
#define BCM53115_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET(r,a) cdk_field_set((r).pll_test_ctrl_ii,0,37,a)
#define BCM53115_A0_PLL_TEST_CTRL_IIr_RESERVED_Rf_GET(r) ((((r).pll_test_ctrl_ii[1]) >> 6) & 0x3ff)
#define BCM53115_A0_PLL_TEST_CTRL_IIr_RESERVED_Rf_SET(r,f) (r).pll_test_ctrl_ii[1]=(((r).pll_test_ctrl_ii[1] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access PLL_TEST_CTRL_II.
 *
 */
#define BCM53115_A0_READ_PLL_TEST_CTRL_IIr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PLL_TEST_CTRL_IIr,(r._pll_test_ctrl_ii),6)
#define BCM53115_A0_WRITE_PLL_TEST_CTRL_IIr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PLL_TEST_CTRL_IIr,&(r._pll_test_ctrl_ii),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TEST_CTRL_IIr BCM53115_A0_PLL_TEST_CTRL_IIr
#define PLL_TEST_CTRL_IIr_SIZE BCM53115_A0_PLL_TEST_CTRL_IIr_SIZE
typedef BCM53115_A0_PLL_TEST_CTRL_IIr_t PLL_TEST_CTRL_IIr_t;
#define PLL_TEST_CTRL_IIr_CLR BCM53115_A0_PLL_TEST_CTRL_IIr_CLR
#define PLL_TEST_CTRL_IIr_SET BCM53115_A0_PLL_TEST_CTRL_IIr_SET
#define PLL_TEST_CTRL_IIr_GET BCM53115_A0_PLL_TEST_CTRL_IIr_GET
#define PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET BCM53115_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET
#define PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET BCM53115_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET
#define PLL_TEST_CTRL_IIr_RESERVED_Rf_GET BCM53115_A0_PLL_TEST_CTRL_IIr_RESERVED_Rf_GET
#define PLL_TEST_CTRL_IIr_RESERVED_Rf_SET BCM53115_A0_PLL_TEST_CTRL_IIr_RESERVED_Rf_SET
#define READ_PLL_TEST_CTRL_IIr BCM53115_A0_READ_PLL_TEST_CTRL_IIr
#define WRITE_PLL_TEST_CTRL_IIr BCM53115_A0_WRITE_PLL_TEST_CTRL_IIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PLL_TEST_CTRL_IIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PN_PCP2TC
 * BLOCKS:   CPIC GPIC0
 * DESC:     Port N(0~4) PCP to TC Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PN_PCP2TCr 0x00003010

#define BCM53115_A0_PN_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program PN_PCP2TC.
 *
 */
typedef union BCM53115_A0_PN_PCP2TCr_s {
	uint32_t v[1];
	uint32_t pn_pcp2tc[1];
	uint32_t _pn_pcp2tc;
} BCM53115_A0_PN_PCP2TCr_t;

#define BCM53115_A0_PN_PCP2TCr_CLR(r) (r).pn_pcp2tc[0] = 0
#define BCM53115_A0_PN_PCP2TCr_SET(r,d) (r).pn_pcp2tc[0] = d
#define BCM53115_A0_PN_PCP2TCr_GET(r) (r).pn_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PN_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).pn_pcp2tc[0]) & 0x7)
#define BCM53115_A0_PN_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_PN_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 3) & 0x7)
#define BCM53115_A0_PN_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_PN_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 6) & 0x7)
#define BCM53115_A0_PN_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_PN_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 9) & 0x7)
#define BCM53115_A0_PN_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53115_A0_PN_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 12) & 0x7)
#define BCM53115_A0_PN_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_PN_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 15) & 0x7)
#define BCM53115_A0_PN_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53115_A0_PN_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 18) & 0x7)
#define BCM53115_A0_PN_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53115_A0_PN_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 21) & 0x7)
#define BCM53115_A0_PN_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_PN_PCP2TCr_RESERVED_Rf_GET(r) ((((r).pn_pcp2tc[0]) >> 24) & 0xff)
#define BCM53115_A0_PN_PCP2TCr_RESERVED_Rf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PN_PCP2TC.
 *
 */
#define BCM53115_A0_READ_PN_PCP2TCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PN_PCP2TCr,(r._pn_pcp2tc),4)
#define BCM53115_A0_WRITE_PN_PCP2TCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PN_PCP2TCr,&(r._pn_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_PCP2TCr BCM53115_A0_PN_PCP2TCr
#define PN_PCP2TCr_SIZE BCM53115_A0_PN_PCP2TCr_SIZE
typedef BCM53115_A0_PN_PCP2TCr_t PN_PCP2TCr_t;
#define PN_PCP2TCr_CLR BCM53115_A0_PN_PCP2TCr_CLR
#define PN_PCP2TCr_SET BCM53115_A0_PN_PCP2TCr_SET
#define PN_PCP2TCr_GET BCM53115_A0_PN_PCP2TCr_GET
#define PN_PCP2TCr_TAG000_PRI_MAPf_GET BCM53115_A0_PN_PCP2TCr_TAG000_PRI_MAPf_GET
#define PN_PCP2TCr_TAG000_PRI_MAPf_SET BCM53115_A0_PN_PCP2TCr_TAG000_PRI_MAPf_SET
#define PN_PCP2TCr_TAG001_PRI_MAPf_GET BCM53115_A0_PN_PCP2TCr_TAG001_PRI_MAPf_GET
#define PN_PCP2TCr_TAG001_PRI_MAPf_SET BCM53115_A0_PN_PCP2TCr_TAG001_PRI_MAPf_SET
#define PN_PCP2TCr_TAG010_PRI_MAPf_GET BCM53115_A0_PN_PCP2TCr_TAG010_PRI_MAPf_GET
#define PN_PCP2TCr_TAG010_PRI_MAPf_SET BCM53115_A0_PN_PCP2TCr_TAG010_PRI_MAPf_SET
#define PN_PCP2TCr_TAG011_PRI_MAPf_GET BCM53115_A0_PN_PCP2TCr_TAG011_PRI_MAPf_GET
#define PN_PCP2TCr_TAG011_PRI_MAPf_SET BCM53115_A0_PN_PCP2TCr_TAG011_PRI_MAPf_SET
#define PN_PCP2TCr_TAG100_PRI_MAPf_GET BCM53115_A0_PN_PCP2TCr_TAG100_PRI_MAPf_GET
#define PN_PCP2TCr_TAG100_PRI_MAPf_SET BCM53115_A0_PN_PCP2TCr_TAG100_PRI_MAPf_SET
#define PN_PCP2TCr_TAG101_PRI_MAPf_GET BCM53115_A0_PN_PCP2TCr_TAG101_PRI_MAPf_GET
#define PN_PCP2TCr_TAG101_PRI_MAPf_SET BCM53115_A0_PN_PCP2TCr_TAG101_PRI_MAPf_SET
#define PN_PCP2TCr_TAG110_PRI_MAPf_GET BCM53115_A0_PN_PCP2TCr_TAG110_PRI_MAPf_GET
#define PN_PCP2TCr_TAG110_PRI_MAPf_SET BCM53115_A0_PN_PCP2TCr_TAG110_PRI_MAPf_SET
#define PN_PCP2TCr_TAG111_PRI_MAPf_GET BCM53115_A0_PN_PCP2TCr_TAG111_PRI_MAPf_GET
#define PN_PCP2TCr_TAG111_PRI_MAPf_SET BCM53115_A0_PN_PCP2TCr_TAG111_PRI_MAPf_SET
#define PN_PCP2TCr_RESERVED_Rf_GET BCM53115_A0_PN_PCP2TCr_RESERVED_Rf_GET
#define PN_PCP2TCr_RESERVED_Rf_SET BCM53115_A0_PN_PCP2TCr_RESERVED_Rf_SET
#define READ_PN_PCP2TCr BCM53115_A0_READ_PN_PCP2TCr
#define WRITE_PN_PCP2TCr BCM53115_A0_WRITE_PN_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PN_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PORT5_RGMII_CTL_GP
 * BLOCKS:   GPIC0
 * DESC:     Port 5 RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     TIM_SEL          1: RGMII tx_clk delayed timing mode0: RGMII tx_clk aligned timing modedefault value by strap pin gtx_0_setup.
 *     RGMIIDLL_RXC_BYPASS 1: clock delay by DLL is enabled0: clock delay by DLL is disabled (Normal Mode)default value by strap pin grx_0_setup.
 *     RESERVED_1R      Reserved
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PORT5_RGMII_CTL_GPr 0x00000065

#define BCM53115_A0_PORT5_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program PORT5_RGMII_CTL_GP.
 *
 */
typedef union BCM53115_A0_PORT5_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t port5_rgmii_ctl_gp[1];
	uint32_t _port5_rgmii_ctl_gp;
} BCM53115_A0_PORT5_RGMII_CTL_GPr_t;

#define BCM53115_A0_PORT5_RGMII_CTL_GPr_CLR(r) (r).port5_rgmii_ctl_gp[0] = 0
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_SET(r,d) (r).port5_rgmii_ctl_gp[0] = d
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_GET(r) (r).port5_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_TIM_SELf_GET(r) (((r).port5_rgmii_ctl_gp[0]) & 0x1)
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_TIM_SELf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_RGMIIDLL_RXC_BYPASSf_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_RGMIIDLL_RXC_BYPASSf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_RESERVED_1Rf_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 2) & 0x3)
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_RESERVED_1Rf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_RESERVED_2Rf_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 4) & 0xf)
#define BCM53115_A0_PORT5_RGMII_CTL_GPr_RESERVED_2Rf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PORT5_RGMII_CTL_GP.
 *
 */
#define BCM53115_A0_READ_PORT5_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PORT5_RGMII_CTL_GPr,(r._port5_rgmii_ctl_gp),1)
#define BCM53115_A0_WRITE_PORT5_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PORT5_RGMII_CTL_GPr,&(r._port5_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT5_RGMII_CTL_GPr BCM53115_A0_PORT5_RGMII_CTL_GPr
#define PORT5_RGMII_CTL_GPr_SIZE BCM53115_A0_PORT5_RGMII_CTL_GPr_SIZE
typedef BCM53115_A0_PORT5_RGMII_CTL_GPr_t PORT5_RGMII_CTL_GPr_t;
#define PORT5_RGMII_CTL_GPr_CLR BCM53115_A0_PORT5_RGMII_CTL_GPr_CLR
#define PORT5_RGMII_CTL_GPr_SET BCM53115_A0_PORT5_RGMII_CTL_GPr_SET
#define PORT5_RGMII_CTL_GPr_GET BCM53115_A0_PORT5_RGMII_CTL_GPr_GET
#define PORT5_RGMII_CTL_GPr_TIM_SELf_GET BCM53115_A0_PORT5_RGMII_CTL_GPr_TIM_SELf_GET
#define PORT5_RGMII_CTL_GPr_TIM_SELf_SET BCM53115_A0_PORT5_RGMII_CTL_GPr_TIM_SELf_SET
#define PORT5_RGMII_CTL_GPr_RGMIIDLL_RXC_BYPASSf_GET BCM53115_A0_PORT5_RGMII_CTL_GPr_RGMIIDLL_RXC_BYPASSf_GET
#define PORT5_RGMII_CTL_GPr_RGMIIDLL_RXC_BYPASSf_SET BCM53115_A0_PORT5_RGMII_CTL_GPr_RGMIIDLL_RXC_BYPASSf_SET
#define PORT5_RGMII_CTL_GPr_RESERVED_1Rf_GET BCM53115_A0_PORT5_RGMII_CTL_GPr_RESERVED_1Rf_GET
#define PORT5_RGMII_CTL_GPr_RESERVED_1Rf_SET BCM53115_A0_PORT5_RGMII_CTL_GPr_RESERVED_1Rf_SET
#define PORT5_RGMII_CTL_GPr_RESERVED_2Rf_GET BCM53115_A0_PORT5_RGMII_CTL_GPr_RESERVED_2Rf_GET
#define PORT5_RGMII_CTL_GPr_RESERVED_2Rf_SET BCM53115_A0_PORT5_RGMII_CTL_GPr_RESERVED_2Rf_SET
#define READ_PORT5_RGMII_CTL_GPr BCM53115_A0_READ_PORT5_RGMII_CTL_GPr
#define WRITE_PORT5_RGMII_CTL_GPr BCM53115_A0_WRITE_PORT5_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PORT5_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PORT_EAP_CON
 * BLOCKS:   GPIC0
 * DESC:     Port EAP Configuration Registers
 * SIZE:     64
 * FIELDS:
 *     EAP_UNI_DA       EAP frame DA register.
 *     EAP_EN_UNI_DA    enable EAP frame with DA.
 *     EAP_BLK_MODE     00: Do not check EAP_BLK_MODE.01: Check EAP_BLK_MODE on ingress port, only frame defined in EAP_GCFG will be forwarded. Otherwise frame will be dropped.10: Reserved11: Check EAP_BLK_MODE on both ingress and egress port.
 *     EAP_MODE         00 : Basic mode, do not check SA,01 : Reserved.10 : Extend mode, check SA & port-number. Drop if SA is unknown.11 : Simplified mode, check SA & port-number. Trap to mgnt-port if SA is unknown.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PORT_EAP_CONr 0x00004220

#define BCM53115_A0_PORT_EAP_CONr_SIZE 8

/*
 * This structure should be used to declare and program PORT_EAP_CON.
 *
 */
typedef union BCM53115_A0_PORT_EAP_CONr_s {
	uint32_t v[2];
	uint32_t port_eap_con[2];
	uint32_t _port_eap_con;
} BCM53115_A0_PORT_EAP_CONr_t;

#define BCM53115_A0_PORT_EAP_CONr_CLR(r) CDK_MEMSET(&((r)._port_eap_con), 0, sizeof(BCM53115_A0_PORT_EAP_CONr_t))
#define BCM53115_A0_PORT_EAP_CONr_SET(r,i,d) (r).port_eap_con[i] = d
#define BCM53115_A0_PORT_EAP_CONr_GET(r,i) (r).port_eap_con[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET(r,a) cdk_field_get((r).port_eap_con,0,47,a)
#define BCM53115_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET(r,a) cdk_field_set((r).port_eap_con,0,47,a)
#define BCM53115_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET(r) ((((r).port_eap_con[1]) >> 16) & 0x1)
#define BCM53115_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET(r) ((((r).port_eap_con[1]) >> 17) & 0x3)
#define BCM53115_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM53115_A0_PORT_EAP_CONr_EAP_MODEf_GET(r) ((((r).port_eap_con[1]) >> 19) & 0x3)
#define BCM53115_A0_PORT_EAP_CONr_EAP_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53115_A0_PORT_EAP_CONr_RESERVED_Rf_GET(r) ((((r).port_eap_con[1]) >> 21) & 0x7ff)
#define BCM53115_A0_PORT_EAP_CONr_RESERVED_Rf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PORT_EAP_CON.
 *
 */
#define BCM53115_A0_READ_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PORT_EAP_CONr,(r._port_eap_con),8)
#define BCM53115_A0_WRITE_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PORT_EAP_CONr,&(r._port_eap_con),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_EAP_CONr BCM53115_A0_PORT_EAP_CONr
#define PORT_EAP_CONr_SIZE BCM53115_A0_PORT_EAP_CONr_SIZE
typedef BCM53115_A0_PORT_EAP_CONr_t PORT_EAP_CONr_t;
#define PORT_EAP_CONr_CLR BCM53115_A0_PORT_EAP_CONr_CLR
#define PORT_EAP_CONr_SET BCM53115_A0_PORT_EAP_CONr_SET
#define PORT_EAP_CONr_GET BCM53115_A0_PORT_EAP_CONr_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_GET BCM53115_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_SET BCM53115_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_GET BCM53115_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_SET BCM53115_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_BLK_MODEf_GET BCM53115_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET
#define PORT_EAP_CONr_EAP_BLK_MODEf_SET BCM53115_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET
#define PORT_EAP_CONr_EAP_MODEf_GET BCM53115_A0_PORT_EAP_CONr_EAP_MODEf_GET
#define PORT_EAP_CONr_EAP_MODEf_SET BCM53115_A0_PORT_EAP_CONr_EAP_MODEf_SET
#define PORT_EAP_CONr_RESERVED_Rf_GET BCM53115_A0_PORT_EAP_CONr_RESERVED_Rf_GET
#define PORT_EAP_CONr_RESERVED_Rf_SET BCM53115_A0_PORT_EAP_CONr_RESERVED_Rf_SET
#define READ_PORT_EAP_CONr BCM53115_A0_READ_PORT_EAP_CONr
#define WRITE_PORT_EAP_CONr BCM53115_A0_WRITE_PORT_EAP_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PORT_EAP_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PORT_ERC_CON
 * BLOCKS:   CPIC GPIC0
 * DESC:     Port Egress Rate Control Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     REF_CNT_R        Refresh count for bucket.
 *     BUCKET_SIZE      Bucket Size.000 : 16KB001 : 20KB,010 : 28KB,011 : 40KB,100 : 76KB,101 : 140KB,110 : 268KB,111 : 500KB.
 *     EGRESS_RC_EN     Egress Rate control Enable.
 *     PORT_ERC_CON_RSRV2 Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PORT_ERC_CONr 0x00004180

#define BCM53115_A0_PORT_ERC_CONr_SIZE 2

/*
 * This structure should be used to declare and program PORT_ERC_CON.
 *
 */
typedef union BCM53115_A0_PORT_ERC_CONr_s {
	uint32_t v[1];
	uint32_t port_erc_con[1];
	uint32_t _port_erc_con;
} BCM53115_A0_PORT_ERC_CONr_t;

#define BCM53115_A0_PORT_ERC_CONr_CLR(r) (r).port_erc_con[0] = 0
#define BCM53115_A0_PORT_ERC_CONr_SET(r,d) (r).port_erc_con[0] = d
#define BCM53115_A0_PORT_ERC_CONr_GET(r) (r).port_erc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PORT_ERC_CONr_REF_CNT_Rf_GET(r) (((r).port_erc_con[0]) & 0xff)
#define BCM53115_A0_PORT_ERC_CONr_REF_CNT_Rf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_PORT_ERC_CONr_BUCKET_SIZEf_GET(r) ((((r).port_erc_con[0]) >> 8) & 0x7)
#define BCM53115_A0_PORT_ERC_CONr_BUCKET_SIZEf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53115_A0_PORT_ERC_CONr_EGRESS_RC_ENf_GET(r) ((((r).port_erc_con[0]) >> 11) & 0x1)
#define BCM53115_A0_PORT_ERC_CONr_EGRESS_RC_ENf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET(r) ((((r).port_erc_con[0]) >> 12) & 0xf)
#define BCM53115_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access PORT_ERC_CON.
 *
 */
#define BCM53115_A0_READ_PORT_ERC_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PORT_ERC_CONr,(r._port_erc_con),2)
#define BCM53115_A0_WRITE_PORT_ERC_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PORT_ERC_CONr,&(r._port_erc_con),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_ERC_CONr BCM53115_A0_PORT_ERC_CONr
#define PORT_ERC_CONr_SIZE BCM53115_A0_PORT_ERC_CONr_SIZE
typedef BCM53115_A0_PORT_ERC_CONr_t PORT_ERC_CONr_t;
#define PORT_ERC_CONr_CLR BCM53115_A0_PORT_ERC_CONr_CLR
#define PORT_ERC_CONr_SET BCM53115_A0_PORT_ERC_CONr_SET
#define PORT_ERC_CONr_GET BCM53115_A0_PORT_ERC_CONr_GET
#define PORT_ERC_CONr_REF_CNT_Rf_GET BCM53115_A0_PORT_ERC_CONr_REF_CNT_Rf_GET
#define PORT_ERC_CONr_REF_CNT_Rf_SET BCM53115_A0_PORT_ERC_CONr_REF_CNT_Rf_SET
#define PORT_ERC_CONr_BUCKET_SIZEf_GET BCM53115_A0_PORT_ERC_CONr_BUCKET_SIZEf_GET
#define PORT_ERC_CONr_BUCKET_SIZEf_SET BCM53115_A0_PORT_ERC_CONr_BUCKET_SIZEf_SET
#define PORT_ERC_CONr_EGRESS_RC_ENf_GET BCM53115_A0_PORT_ERC_CONr_EGRESS_RC_ENf_GET
#define PORT_ERC_CONr_EGRESS_RC_ENf_SET BCM53115_A0_PORT_ERC_CONr_EGRESS_RC_ENf_SET
#define PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET BCM53115_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET
#define PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET BCM53115_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET
#define READ_PORT_ERC_CONr BCM53115_A0_READ_PORT_ERC_CONr
#define WRITE_PORT_ERC_CONr BCM53115_A0_WRITE_PORT_ERC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PORT_ERC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PORT_ERC_CON_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Egress Rate Control Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     REF_CNT_R        Refresh count for bucket.
 *     BUCKET_SIZE      Bucket Size.000 : 16KB001 : 20KB,010 : 28KB,011 : 40KB,100 : 76KB,101 : 140KB,110 : 268KB,111 : 500KB.
 *     EGRESS_RC_EN     Egress Rate control Enable.
 *     PORT_ERC_CON_RSRV2 Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PORT_ERC_CON_IMPr 0x00004190

#define BCM53115_A0_PORT_ERC_CON_IMPr_SIZE 2

/*
 * This structure should be used to declare and program PORT_ERC_CON_IMP.
 *
 */
typedef union BCM53115_A0_PORT_ERC_CON_IMPr_s {
	uint32_t v[1];
	uint32_t port_erc_con_imp[1];
	uint32_t _port_erc_con_imp;
} BCM53115_A0_PORT_ERC_CON_IMPr_t;

#define BCM53115_A0_PORT_ERC_CON_IMPr_CLR(r) (r).port_erc_con_imp[0] = 0
#define BCM53115_A0_PORT_ERC_CON_IMPr_SET(r,d) (r).port_erc_con_imp[0] = d
#define BCM53115_A0_PORT_ERC_CON_IMPr_GET(r) (r).port_erc_con_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PORT_ERC_CON_IMPr_REF_CNT_Rf_GET(r) (((r).port_erc_con_imp[0]) & 0xff)
#define BCM53115_A0_PORT_ERC_CON_IMPr_REF_CNT_Rf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET(r) ((((r).port_erc_con_imp[0]) >> 8) & 0x7)
#define BCM53115_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53115_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET(r) ((((r).port_erc_con_imp[0]) >> 11) & 0x1)
#define BCM53115_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET(r) ((((r).port_erc_con_imp[0]) >> 12) & 0xf)
#define BCM53115_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access PORT_ERC_CON_IMP.
 *
 */
#define BCM53115_A0_READ_PORT_ERC_CON_IMPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PORT_ERC_CON_IMPr,(r._port_erc_con_imp),2)
#define BCM53115_A0_WRITE_PORT_ERC_CON_IMPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PORT_ERC_CON_IMPr,&(r._port_erc_con_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_ERC_CON_IMPr BCM53115_A0_PORT_ERC_CON_IMPr
#define PORT_ERC_CON_IMPr_SIZE BCM53115_A0_PORT_ERC_CON_IMPr_SIZE
typedef BCM53115_A0_PORT_ERC_CON_IMPr_t PORT_ERC_CON_IMPr_t;
#define PORT_ERC_CON_IMPr_CLR BCM53115_A0_PORT_ERC_CON_IMPr_CLR
#define PORT_ERC_CON_IMPr_SET BCM53115_A0_PORT_ERC_CON_IMPr_SET
#define PORT_ERC_CON_IMPr_GET BCM53115_A0_PORT_ERC_CON_IMPr_GET
#define PORT_ERC_CON_IMPr_REF_CNT_Rf_GET BCM53115_A0_PORT_ERC_CON_IMPr_REF_CNT_Rf_GET
#define PORT_ERC_CON_IMPr_REF_CNT_Rf_SET BCM53115_A0_PORT_ERC_CON_IMPr_REF_CNT_Rf_SET
#define PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET BCM53115_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET
#define PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET BCM53115_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET
#define PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET BCM53115_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET
#define PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET BCM53115_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET
#define PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET BCM53115_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET
#define PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET BCM53115_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET
#define READ_PORT_ERC_CON_IMPr BCM53115_A0_READ_PORT_ERC_CON_IMPr
#define WRITE_PORT_ERC_CON_IMPr BCM53115_A0_WRITE_PORT_ERC_CON_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PORT_ERC_CON_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PORT_VLAN_CTL
 * BLOCKS:   CPIC GPIC0
 * DESC:     PORT X VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to 1' to enable forwarding to the egress port. Set 0' inhibit the forwarding.Bit 8: mask for MII port.Bit 0-7: Port 0-7.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PORT_VLAN_CTLr 0x00003100

#define BCM53115_A0_PORT_VLAN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL.
 *
 */
typedef union BCM53115_A0_PORT_VLAN_CTLr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl[1];
	uint32_t _port_vlan_ctl;
} BCM53115_A0_PORT_VLAN_CTLr_t;

#define BCM53115_A0_PORT_VLAN_CTLr_CLR(r) (r).port_vlan_ctl[0] = 0
#define BCM53115_A0_PORT_VLAN_CTLr_SET(r,d) (r).port_vlan_ctl[0] = d
#define BCM53115_A0_PORT_VLAN_CTLr_GET(r) (r).port_vlan_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl[0]) & 0x1ff)
#define BCM53115_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_PORT_VLAN_CTLr_RESERVED_Rf_GET(r) ((((r).port_vlan_ctl[0]) >> 9) & 0x7f)
#define BCM53115_A0_PORT_VLAN_CTLr_RESERVED_Rf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL.
 *
 */
#define BCM53115_A0_READ_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PORT_VLAN_CTLr,(r._port_vlan_ctl),2)
#define BCM53115_A0_WRITE_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PORT_VLAN_CTLr,&(r._port_vlan_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTLr BCM53115_A0_PORT_VLAN_CTLr
#define PORT_VLAN_CTLr_SIZE BCM53115_A0_PORT_VLAN_CTLr_SIZE
typedef BCM53115_A0_PORT_VLAN_CTLr_t PORT_VLAN_CTLr_t;
#define PORT_VLAN_CTLr_CLR BCM53115_A0_PORT_VLAN_CTLr_CLR
#define PORT_VLAN_CTLr_SET BCM53115_A0_PORT_VLAN_CTLr_SET
#define PORT_VLAN_CTLr_GET BCM53115_A0_PORT_VLAN_CTLr_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET BCM53115_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET BCM53115_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTLr_RESERVED_Rf_GET BCM53115_A0_PORT_VLAN_CTLr_RESERVED_Rf_GET
#define PORT_VLAN_CTLr_RESERVED_Rf_SET BCM53115_A0_PORT_VLAN_CTLr_RESERVED_Rf_SET
#define READ_PORT_VLAN_CTLr BCM53115_A0_READ_PORT_VLAN_CTLr
#define WRITE_PORT_VLAN_CTLr BCM53115_A0_WRITE_PORT_VLAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PORT_VLAN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PORT_VLAN_CTL_IMP
 * BLOCKS:   SYS
 * DESC:     PORT 8 VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to 1' to enable forwarding to the egress port. Set 0' inhibit the forwarding.Bit 8: mask for MII port.Bit 0-7: Port 0-7.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PORT_VLAN_CTL_IMPr 0x00003110

#define BCM53115_A0_PORT_VLAN_CTL_IMPr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL_IMP.
 *
 */
typedef union BCM53115_A0_PORT_VLAN_CTL_IMPr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl_imp[1];
	uint32_t _port_vlan_ctl_imp;
} BCM53115_A0_PORT_VLAN_CTL_IMPr_t;

#define BCM53115_A0_PORT_VLAN_CTL_IMPr_CLR(r) (r).port_vlan_ctl_imp[0] = 0
#define BCM53115_A0_PORT_VLAN_CTL_IMPr_SET(r,d) (r).port_vlan_ctl_imp[0] = d
#define BCM53115_A0_PORT_VLAN_CTL_IMPr_GET(r) (r).port_vlan_ctl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl_imp[0]) & 0x1ff)
#define BCM53115_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl_imp[0]=(((r).port_vlan_ctl_imp[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_PORT_VLAN_CTL_IMPr_RESERVED_Rf_GET(r) ((((r).port_vlan_ctl_imp[0]) >> 9) & 0x7f)
#define BCM53115_A0_PORT_VLAN_CTL_IMPr_RESERVED_Rf_SET(r,f) (r).port_vlan_ctl_imp[0]=(((r).port_vlan_ctl_imp[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL_IMP.
 *
 */
#define BCM53115_A0_READ_PORT_VLAN_CTL_IMPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PORT_VLAN_CTL_IMPr,(r._port_vlan_ctl_imp),2)
#define BCM53115_A0_WRITE_PORT_VLAN_CTL_IMPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PORT_VLAN_CTL_IMPr,&(r._port_vlan_ctl_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTL_IMPr BCM53115_A0_PORT_VLAN_CTL_IMPr
#define PORT_VLAN_CTL_IMPr_SIZE BCM53115_A0_PORT_VLAN_CTL_IMPr_SIZE
typedef BCM53115_A0_PORT_VLAN_CTL_IMPr_t PORT_VLAN_CTL_IMPr_t;
#define PORT_VLAN_CTL_IMPr_CLR BCM53115_A0_PORT_VLAN_CTL_IMPr_CLR
#define PORT_VLAN_CTL_IMPr_SET BCM53115_A0_PORT_VLAN_CTL_IMPr_SET
#define PORT_VLAN_CTL_IMPr_GET BCM53115_A0_PORT_VLAN_CTL_IMPr_GET
#define PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET BCM53115_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET BCM53115_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTL_IMPr_RESERVED_Rf_GET BCM53115_A0_PORT_VLAN_CTL_IMPr_RESERVED_Rf_GET
#define PORT_VLAN_CTL_IMPr_RESERVED_Rf_SET BCM53115_A0_PORT_VLAN_CTL_IMPr_RESERVED_Rf_SET
#define READ_PORT_VLAN_CTL_IMPr BCM53115_A0_READ_PORT_VLAN_CTL_IMPr
#define WRITE_PORT_VLAN_CTL_IMPr BCM53115_A0_WRITE_PORT_VLAN_CTL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PORT_VLAN_CTL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PROTECTED_SEL
 * BLOCKS:   SYS
 * DESC:     Protected Port Select Register
 * SIZE:     16
 * FIELDS:
 *     PORT_SEL         Protected Port Selection.When set, the Port will be the protected Port Protected Ports will not be able to Transmit/Receive Frame to/from each other.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PROTECTED_SELr 0x00000024

#define BCM53115_A0_PROTECTED_SELr_SIZE 2

/*
 * This structure should be used to declare and program PROTECTED_SEL.
 *
 */
typedef union BCM53115_A0_PROTECTED_SELr_s {
	uint32_t v[1];
	uint32_t protected_sel[1];
	uint32_t _protected_sel;
} BCM53115_A0_PROTECTED_SELr_t;

#define BCM53115_A0_PROTECTED_SELr_CLR(r) (r).protected_sel[0] = 0
#define BCM53115_A0_PROTECTED_SELr_SET(r,d) (r).protected_sel[0] = d
#define BCM53115_A0_PROTECTED_SELr_GET(r) (r).protected_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PROTECTED_SELr_PORT_SELf_GET(r) (((r).protected_sel[0]) & 0x1ff)
#define BCM53115_A0_PROTECTED_SELr_PORT_SELf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_PROTECTED_SELr_RESERVED_Rf_GET(r) ((((r).protected_sel[0]) >> 9) & 0x7f)
#define BCM53115_A0_PROTECTED_SELr_RESERVED_Rf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PROTECTED_SEL.
 *
 */
#define BCM53115_A0_READ_PROTECTED_SELr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PROTECTED_SELr,(r._protected_sel),2)
#define BCM53115_A0_WRITE_PROTECTED_SELr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PROTECTED_SELr,&(r._protected_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTECTED_SELr BCM53115_A0_PROTECTED_SELr
#define PROTECTED_SELr_SIZE BCM53115_A0_PROTECTED_SELr_SIZE
typedef BCM53115_A0_PROTECTED_SELr_t PROTECTED_SELr_t;
#define PROTECTED_SELr_CLR BCM53115_A0_PROTECTED_SELr_CLR
#define PROTECTED_SELr_SET BCM53115_A0_PROTECTED_SELr_SET
#define PROTECTED_SELr_GET BCM53115_A0_PROTECTED_SELr_GET
#define PROTECTED_SELr_PORT_SELf_GET BCM53115_A0_PROTECTED_SELr_PORT_SELf_GET
#define PROTECTED_SELr_PORT_SELf_SET BCM53115_A0_PROTECTED_SELr_PORT_SELf_SET
#define PROTECTED_SELr_RESERVED_Rf_GET BCM53115_A0_PROTECTED_SELr_RESERVED_Rf_GET
#define PROTECTED_SELr_RESERVED_Rf_SET BCM53115_A0_PROTECTED_SELr_RESERVED_Rf_SET
#define READ_PROTECTED_SELr BCM53115_A0_READ_PROTECTED_SELr
#define WRITE_PROTECTED_SELr BCM53115_A0_WRITE_PROTECTED_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PROTECTED_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PRS_FIFO_DEBUG_CTRL
 * BLOCKS:   SYS
 * DESC:     PRS_FIFO Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     PRS_FIFO_DBG_CTRL 
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr 0x00000870

#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PRS_FIFO_DEBUG_CTRL.
 *
 */
typedef union BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_s {
	uint32_t v[1];
	uint32_t prs_fifo_debug_ctrl[1];
	uint32_t _prs_fifo_debug_ctrl;
} BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_t;

#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_CLR(r) (r).prs_fifo_debug_ctrl[0] = 0
#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_SET(r,d) (r).prs_fifo_debug_ctrl[0] = d
#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_GET(r) (r).prs_fifo_debug_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET(r) (((r).prs_fifo_debug_ctrl[0]) & 0xf)
#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET(r,f) (r).prs_fifo_debug_ctrl[0]=(((r).prs_fifo_debug_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_RESERVED_Rf_GET(r) ((((r).prs_fifo_debug_ctrl[0]) >> 4) & 0xf)
#define BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_RESERVED_Rf_SET(r,f) (r).prs_fifo_debug_ctrl[0]=(((r).prs_fifo_debug_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PRS_FIFO_DEBUG_CTRL.
 *
 */
#define BCM53115_A0_READ_PRS_FIFO_DEBUG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PRS_FIFO_DEBUG_CTRLr,(r._prs_fifo_debug_ctrl),1)
#define BCM53115_A0_WRITE_PRS_FIFO_DEBUG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PRS_FIFO_DEBUG_CTRLr,&(r._prs_fifo_debug_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRS_FIFO_DEBUG_CTRLr BCM53115_A0_PRS_FIFO_DEBUG_CTRLr
#define PRS_FIFO_DEBUG_CTRLr_SIZE BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_SIZE
typedef BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_t PRS_FIFO_DEBUG_CTRLr_t;
#define PRS_FIFO_DEBUG_CTRLr_CLR BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_CLR
#define PRS_FIFO_DEBUG_CTRLr_SET BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_SET
#define PRS_FIFO_DEBUG_CTRLr_GET BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_GET
#define PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET
#define PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET
#define PRS_FIFO_DEBUG_CTRLr_RESERVED_Rf_GET BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_RESERVED_Rf_GET
#define PRS_FIFO_DEBUG_CTRLr_RESERVED_Rf_SET BCM53115_A0_PRS_FIFO_DEBUG_CTRLr_RESERVED_Rf_SET
#define READ_PRS_FIFO_DEBUG_CTRLr BCM53115_A0_READ_PRS_FIFO_DEBUG_CTRLr
#define WRITE_PRS_FIFO_DEBUG_CTRLr BCM53115_A0_WRITE_PRS_FIFO_DEBUG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PRS_FIFO_DEBUG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  PRS_FIFO_DEBUG_DATA
 * BLOCKS:   SYS
 * DESC:     PRS_FIFO Debug Data Register
 * SIZE:     64
 * FIELDS:
 *     PRS_FIFO_DBG_DATA 
 *
 ******************************************************************************/
#define BCM53115_A0_PRS_FIFO_DEBUG_DATAr 0x00000871

#define BCM53115_A0_PRS_FIFO_DEBUG_DATAr_SIZE 8

/*
 * This structure should be used to declare and program PRS_FIFO_DEBUG_DATA.
 *
 */
typedef union BCM53115_A0_PRS_FIFO_DEBUG_DATAr_s {
	uint32_t v[2];
	uint32_t prs_fifo_debug_data[2];
	uint32_t _prs_fifo_debug_data;
} BCM53115_A0_PRS_FIFO_DEBUG_DATAr_t;

#define BCM53115_A0_PRS_FIFO_DEBUG_DATAr_CLR(r) CDK_MEMSET(&((r)._prs_fifo_debug_data), 0, sizeof(BCM53115_A0_PRS_FIFO_DEBUG_DATAr_t))
#define BCM53115_A0_PRS_FIFO_DEBUG_DATAr_SET(r,i,d) (r).prs_fifo_debug_data[i] = d
#define BCM53115_A0_PRS_FIFO_DEBUG_DATAr_GET(r,i) (r).prs_fifo_debug_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET(r,a) cdk_field_get((r).prs_fifo_debug_data,0,63,a)
#define BCM53115_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET(r,a) cdk_field_set((r).prs_fifo_debug_data,0,63,a)

/*
 * These macros can be used to access PRS_FIFO_DEBUG_DATA.
 *
 */
#define BCM53115_A0_READ_PRS_FIFO_DEBUG_DATAr(u,r) cdk_robo_reg_read(u,BCM53115_A0_PRS_FIFO_DEBUG_DATAr,(r._prs_fifo_debug_data),8)
#define BCM53115_A0_WRITE_PRS_FIFO_DEBUG_DATAr(u,r) cdk_robo_reg_write(u,BCM53115_A0_PRS_FIFO_DEBUG_DATAr,&(r._prs_fifo_debug_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRS_FIFO_DEBUG_DATAr BCM53115_A0_PRS_FIFO_DEBUG_DATAr
#define PRS_FIFO_DEBUG_DATAr_SIZE BCM53115_A0_PRS_FIFO_DEBUG_DATAr_SIZE
typedef BCM53115_A0_PRS_FIFO_DEBUG_DATAr_t PRS_FIFO_DEBUG_DATAr_t;
#define PRS_FIFO_DEBUG_DATAr_CLR BCM53115_A0_PRS_FIFO_DEBUG_DATAr_CLR
#define PRS_FIFO_DEBUG_DATAr_SET BCM53115_A0_PRS_FIFO_DEBUG_DATAr_SET
#define PRS_FIFO_DEBUG_DATAr_GET BCM53115_A0_PRS_FIFO_DEBUG_DATAr_GET
#define PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET BCM53115_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET
#define PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET BCM53115_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET
#define READ_PRS_FIFO_DEBUG_DATAr BCM53115_A0_READ_PRS_FIFO_DEBUG_DATAr
#define WRITE_PRS_FIFO_DEBUG_DATAr BCM53115_A0_WRITE_PRS_FIFO_DEBUG_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PRS_FIFO_DEBUG_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  Pkts1024toMaxPktOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_PKTS1024TOMAXPKTOCTETSr 0x00002074

#define BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxPktOctets.
 *
 */
typedef union BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxpktoctets[1];
	uint32_t _pkts1024tomaxpktoctets;
} BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_t;

#define BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_CLR(r) (r).pkts1024tomaxpktoctets[0] = 0
#define BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_SET(r,d) (r).pkts1024tomaxpktoctets[0] = d
#define BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_GET(r) (r).pkts1024tomaxpktoctets[0]


/*
 * These macros can be used to access Pkts1024toMaxPktOctets.
 *
 */
#define BCM53115_A0_READ_PKTS1024TOMAXPKTOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PKTS1024TOMAXPKTOCTETSr,(r._pkts1024tomaxpktoctets),4)
#define BCM53115_A0_WRITE_PKTS1024TOMAXPKTOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PKTS1024TOMAXPKTOCTETSr,&(r._pkts1024tomaxpktoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXPKTOCTETSr BCM53115_A0_PKTS1024TOMAXPKTOCTETSr
#define PKTS1024TOMAXPKTOCTETSr_SIZE BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_SIZE
typedef BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_t PKTS1024TOMAXPKTOCTETSr_t;
#define PKTS1024TOMAXPKTOCTETSr_CLR BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_CLR
#define PKTS1024TOMAXPKTOCTETSr_SET BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_SET
#define PKTS1024TOMAXPKTOCTETSr_GET BCM53115_A0_PKTS1024TOMAXPKTOCTETSr_GET
#define READ_PKTS1024TOMAXPKTOCTETSr BCM53115_A0_READ_PKTS1024TOMAXPKTOCTETSr
#define WRITE_PKTS1024TOMAXPKTOCTETSr BCM53115_A0_WRITE_PKTS1024TOMAXPKTOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PKTS1024TOMAXPKTOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  Pkts128to255Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_PKTS128TO255OCTETSr 0x00002068

#define BCM53115_A0_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets.
 *
 */
typedef union BCM53115_A0_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets[1];
	uint32_t _pkts128to255octets;
} BCM53115_A0_PKTS128TO255OCTETSr_t;

#define BCM53115_A0_PKTS128TO255OCTETSr_CLR(r) (r).pkts128to255octets[0] = 0
#define BCM53115_A0_PKTS128TO255OCTETSr_SET(r,d) (r).pkts128to255octets[0] = d
#define BCM53115_A0_PKTS128TO255OCTETSr_GET(r) (r).pkts128to255octets[0]


/*
 * These macros can be used to access Pkts128to255Octets.
 *
 */
#define BCM53115_A0_READ_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PKTS128TO255OCTETSr,(r._pkts128to255octets),4)
#define BCM53115_A0_WRITE_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PKTS128TO255OCTETSr,&(r._pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETSr BCM53115_A0_PKTS128TO255OCTETSr
#define PKTS128TO255OCTETSr_SIZE BCM53115_A0_PKTS128TO255OCTETSr_SIZE
typedef BCM53115_A0_PKTS128TO255OCTETSr_t PKTS128TO255OCTETSr_t;
#define PKTS128TO255OCTETSr_CLR BCM53115_A0_PKTS128TO255OCTETSr_CLR
#define PKTS128TO255OCTETSr_SET BCM53115_A0_PKTS128TO255OCTETSr_SET
#define PKTS128TO255OCTETSr_GET BCM53115_A0_PKTS128TO255OCTETSr_GET
#define READ_PKTS128TO255OCTETSr BCM53115_A0_READ_PKTS128TO255OCTETSr
#define WRITE_PKTS128TO255OCTETSr BCM53115_A0_WRITE_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  Pkts256to511Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_PKTS256TO511OCTETSr 0x0000206c

#define BCM53115_A0_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets.
 *
 */
typedef union BCM53115_A0_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets[1];
	uint32_t _pkts256to511octets;
} BCM53115_A0_PKTS256TO511OCTETSr_t;

#define BCM53115_A0_PKTS256TO511OCTETSr_CLR(r) (r).pkts256to511octets[0] = 0
#define BCM53115_A0_PKTS256TO511OCTETSr_SET(r,d) (r).pkts256to511octets[0] = d
#define BCM53115_A0_PKTS256TO511OCTETSr_GET(r) (r).pkts256to511octets[0]


/*
 * These macros can be used to access Pkts256to511Octets.
 *
 */
#define BCM53115_A0_READ_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PKTS256TO511OCTETSr,(r._pkts256to511octets),4)
#define BCM53115_A0_WRITE_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PKTS256TO511OCTETSr,&(r._pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETSr BCM53115_A0_PKTS256TO511OCTETSr
#define PKTS256TO511OCTETSr_SIZE BCM53115_A0_PKTS256TO511OCTETSr_SIZE
typedef BCM53115_A0_PKTS256TO511OCTETSr_t PKTS256TO511OCTETSr_t;
#define PKTS256TO511OCTETSr_CLR BCM53115_A0_PKTS256TO511OCTETSr_CLR
#define PKTS256TO511OCTETSr_SET BCM53115_A0_PKTS256TO511OCTETSr_SET
#define PKTS256TO511OCTETSr_GET BCM53115_A0_PKTS256TO511OCTETSr_GET
#define READ_PKTS256TO511OCTETSr BCM53115_A0_READ_PKTS256TO511OCTETSr
#define WRITE_PKTS256TO511OCTETSr BCM53115_A0_WRITE_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  Pkts512to1023Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_PKTS512TO1023OCTETSr 0x00002070

#define BCM53115_A0_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets.
 *
 */
typedef union BCM53115_A0_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets[1];
	uint32_t _pkts512to1023octets;
} BCM53115_A0_PKTS512TO1023OCTETSr_t;

#define BCM53115_A0_PKTS512TO1023OCTETSr_CLR(r) (r).pkts512to1023octets[0] = 0
#define BCM53115_A0_PKTS512TO1023OCTETSr_SET(r,d) (r).pkts512to1023octets[0] = d
#define BCM53115_A0_PKTS512TO1023OCTETSr_GET(r) (r).pkts512to1023octets[0]


/*
 * These macros can be used to access Pkts512to1023Octets.
 *
 */
#define BCM53115_A0_READ_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PKTS512TO1023OCTETSr,(r._pkts512to1023octets),4)
#define BCM53115_A0_WRITE_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PKTS512TO1023OCTETSr,&(r._pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETSr BCM53115_A0_PKTS512TO1023OCTETSr
#define PKTS512TO1023OCTETSr_SIZE BCM53115_A0_PKTS512TO1023OCTETSr_SIZE
typedef BCM53115_A0_PKTS512TO1023OCTETSr_t PKTS512TO1023OCTETSr_t;
#define PKTS512TO1023OCTETSr_CLR BCM53115_A0_PKTS512TO1023OCTETSr_CLR
#define PKTS512TO1023OCTETSr_SET BCM53115_A0_PKTS512TO1023OCTETSr_SET
#define PKTS512TO1023OCTETSr_GET BCM53115_A0_PKTS512TO1023OCTETSr_GET
#define READ_PKTS512TO1023OCTETSr BCM53115_A0_READ_PKTS512TO1023OCTETSr
#define WRITE_PKTS512TO1023OCTETSr BCM53115_A0_WRITE_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  Pkts64Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_PKTS64OCTETSr 0x00002060

#define BCM53115_A0_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets.
 *
 */
typedef union BCM53115_A0_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts64octets[1];
	uint32_t _pkts64octets;
} BCM53115_A0_PKTS64OCTETSr_t;

#define BCM53115_A0_PKTS64OCTETSr_CLR(r) (r).pkts64octets[0] = 0
#define BCM53115_A0_PKTS64OCTETSr_SET(r,d) (r).pkts64octets[0] = d
#define BCM53115_A0_PKTS64OCTETSr_GET(r) (r).pkts64octets[0]


/*
 * These macros can be used to access Pkts64Octets.
 *
 */
#define BCM53115_A0_READ_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PKTS64OCTETSr,(r._pkts64octets),4)
#define BCM53115_A0_WRITE_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PKTS64OCTETSr,&(r._pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETSr BCM53115_A0_PKTS64OCTETSr
#define PKTS64OCTETSr_SIZE BCM53115_A0_PKTS64OCTETSr_SIZE
typedef BCM53115_A0_PKTS64OCTETSr_t PKTS64OCTETSr_t;
#define PKTS64OCTETSr_CLR BCM53115_A0_PKTS64OCTETSr_CLR
#define PKTS64OCTETSr_SET BCM53115_A0_PKTS64OCTETSr_SET
#define PKTS64OCTETSr_GET BCM53115_A0_PKTS64OCTETSr_GET
#define READ_PKTS64OCTETSr BCM53115_A0_READ_PKTS64OCTETSr
#define WRITE_PKTS64OCTETSr BCM53115_A0_WRITE_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  Pkts65to127Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_PKTS65TO127OCTETSr 0x00002064

#define BCM53115_A0_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets.
 *
 */
typedef union BCM53115_A0_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets[1];
	uint32_t _pkts65to127octets;
} BCM53115_A0_PKTS65TO127OCTETSr_t;

#define BCM53115_A0_PKTS65TO127OCTETSr_CLR(r) (r).pkts65to127octets[0] = 0
#define BCM53115_A0_PKTS65TO127OCTETSr_SET(r,d) (r).pkts65to127octets[0] = d
#define BCM53115_A0_PKTS65TO127OCTETSr_GET(r) (r).pkts65to127octets[0]


/*
 * These macros can be used to access Pkts65to127Octets.
 *
 */
#define BCM53115_A0_READ_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_PKTS65TO127OCTETSr,(r._pkts65to127octets),4)
#define BCM53115_A0_WRITE_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_PKTS65TO127OCTETSr,&(r._pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETSr BCM53115_A0_PKTS65TO127OCTETSr
#define PKTS65TO127OCTETSr_SIZE BCM53115_A0_PKTS65TO127OCTETSr_SIZE
typedef BCM53115_A0_PKTS65TO127OCTETSr_t PKTS65TO127OCTETSr_t;
#define PKTS65TO127OCTETSr_CLR BCM53115_A0_PKTS65TO127OCTETSr_CLR
#define PKTS65TO127OCTETSr_SET BCM53115_A0_PKTS65TO127OCTETSr_SET
#define PKTS65TO127OCTETSr_GET BCM53115_A0_PKTS65TO127OCTETSr_GET
#define READ_PKTS65TO127OCTETSr BCM53115_A0_READ_PKTS65TO127OCTETSr
#define WRITE_PKTS65TO127OCTETSr BCM53115_A0_WRITE_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_1P_EN
 * BLOCKS:   SYS
 * DESC:     QoS 802.1P Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_1P_EN        Enable 802.1p priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_1P_ENr 0x00003004

#define BCM53115_A0_QOS_1P_ENr_SIZE 2

/*
 * This structure should be used to declare and program QOS_1P_EN.
 *
 */
typedef union BCM53115_A0_QOS_1P_ENr_s {
	uint32_t v[1];
	uint32_t qos_1p_en[1];
	uint32_t _qos_1p_en;
} BCM53115_A0_QOS_1P_ENr_t;

#define BCM53115_A0_QOS_1P_ENr_CLR(r) (r).qos_1p_en[0] = 0
#define BCM53115_A0_QOS_1P_ENr_SET(r,d) (r).qos_1p_en[0] = d
#define BCM53115_A0_QOS_1P_ENr_GET(r) (r).qos_1p_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_1P_ENr_QOS_1P_ENf_GET(r) (((r).qos_1p_en[0]) & 0x1ff)
#define BCM53115_A0_QOS_1P_ENr_QOS_1P_ENf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_QOS_1P_ENr_RESERVED_Rf_GET(r) ((((r).qos_1p_en[0]) >> 9) & 0x7f)
#define BCM53115_A0_QOS_1P_ENr_RESERVED_Rf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_1P_EN.
 *
 */
#define BCM53115_A0_READ_QOS_1P_ENr(u,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_1P_ENr,(r._qos_1p_en),2)
#define BCM53115_A0_WRITE_QOS_1P_ENr(u,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_1P_ENr,&(r._qos_1p_en),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_1P_ENr BCM53115_A0_QOS_1P_ENr
#define QOS_1P_ENr_SIZE BCM53115_A0_QOS_1P_ENr_SIZE
typedef BCM53115_A0_QOS_1P_ENr_t QOS_1P_ENr_t;
#define QOS_1P_ENr_CLR BCM53115_A0_QOS_1P_ENr_CLR
#define QOS_1P_ENr_SET BCM53115_A0_QOS_1P_ENr_SET
#define QOS_1P_ENr_GET BCM53115_A0_QOS_1P_ENr_GET
#define QOS_1P_ENr_QOS_1P_ENf_GET BCM53115_A0_QOS_1P_ENr_QOS_1P_ENf_GET
#define QOS_1P_ENr_QOS_1P_ENf_SET BCM53115_A0_QOS_1P_ENr_QOS_1P_ENf_SET
#define QOS_1P_ENr_RESERVED_Rf_GET BCM53115_A0_QOS_1P_ENr_RESERVED_Rf_GET
#define QOS_1P_ENr_RESERVED_Rf_SET BCM53115_A0_QOS_1P_ENr_RESERVED_Rf_SET
#define READ_QOS_1P_ENr BCM53115_A0_READ_QOS_1P_ENr
#define WRITE_QOS_1P_ENr BCM53115_A0_WRITE_QOS_1P_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_1P_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_DIFF_DSCP0
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 0 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_000000  DiffServ DSCP== 000000 to Priority ID map Register.
 *     PRI_DSCP_000001  DiffServ DSCP== 000001 to Priority ID map Register.
 *     PRI_DSCP_000010  DiffServ DSCP== 000010 to Priority ID map Register.
 *     PRI_DSCP_000011  DiffServ DSCP== 000011 to Priority ID map Register.
 *     PRI_DSCP_000100  DiffServ DSCP== 000100 to Priority ID map Register.
 *     PRI_DSCP_000101  DiffServ DSCP== 000101 to Priority ID map Register.
 *     PRI_DSCP_000110  DiffServ DSCP== 000110 to Priority ID map Register.
 *     PRI_DSCP_000111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_001000  DiffServ DSCP== 001000 to Priority ID map Register.
 *     PRI_DSCP_001001  DiffServ DSCP== 001001 to Priority ID map Register.
 *     PRI_DSCP_001010  DiffServ DSCP== 001010 to Priority ID map Register.
 *     PRI_DSCP_001011  DiffServ DSCP== 001011 to Priority ID map Register.
 *     PRI_DSCP_001100  DiffServ DSCP== 001100 to Priority ID map Register.
 *     PRI_DSCP_001101  DiffServ DSCP== 001101 to Priority ID map Register.
 *     PRI_DSCP_001110  DiffServ DSCP== 001110 to Priority ID map Register.
 *     PRI_DSCP_001111  DiffServ DSCP== 001111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_DIFF_DSCP0r 0x00003030

#define BCM53115_A0_QOS_DIFF_DSCP0r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP0.
 *
 */
typedef union BCM53115_A0_QOS_DIFF_DSCP0r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp0[2];
	uint32_t _qos_diff_dscp0;
} BCM53115_A0_QOS_DIFF_DSCP0r_t;

#define BCM53115_A0_QOS_DIFF_DSCP0r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp0), 0, sizeof(BCM53115_A0_QOS_DIFF_DSCP0r_t))
#define BCM53115_A0_QOS_DIFF_DSCP0r_SET(r,i,d) (r).qos_diff_dscp0[i] = d
#define BCM53115_A0_QOS_DIFF_DSCP0r_GET(r,i) (r).qos_diff_dscp0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET(r) (((r).qos_diff_dscp0[0]) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 3) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET(r) ((((r).qos_diff_dscp0[0]) >> 6) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET(r) ((((r).qos_diff_dscp0[0]) >> 9) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET(r) ((((r).qos_diff_dscp0[0]) >> 12) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET(r) ((((r).qos_diff_dscp0[0]) >> 15) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET(r) ((((r).qos_diff_dscp0[0]) >> 18) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET(r) ((((r).qos_diff_dscp0[0]) >> 21) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET(r) ((((r).qos_diff_dscp0[0]) >> 24) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 27) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET(r) cdk_field32_get((r).qos_diff_dscp0,30,32)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp0,30,32,f)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET(r) ((((r).qos_diff_dscp0[1]) >> 1) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET(r) ((((r).qos_diff_dscp0[1]) >> 4) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET(r) ((((r).qos_diff_dscp0[1]) >> 7) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET(r) ((((r).qos_diff_dscp0[1]) >> 10) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET(r) ((((r).qos_diff_dscp0[1]) >> 13) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP0.
 *
 */
#define BCM53115_A0_READ_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_DIFF_DSCP0r,(r._qos_diff_dscp0),6)
#define BCM53115_A0_WRITE_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_DIFF_DSCP0r,&(r._qos_diff_dscp0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP0r BCM53115_A0_QOS_DIFF_DSCP0r
#define QOS_DIFF_DSCP0r_SIZE BCM53115_A0_QOS_DIFF_DSCP0r_SIZE
typedef BCM53115_A0_QOS_DIFF_DSCP0r_t QOS_DIFF_DSCP0r_t;
#define QOS_DIFF_DSCP0r_CLR BCM53115_A0_QOS_DIFF_DSCP0r_CLR
#define QOS_DIFF_DSCP0r_SET BCM53115_A0_QOS_DIFF_DSCP0r_SET
#define QOS_DIFF_DSCP0r_GET BCM53115_A0_QOS_DIFF_DSCP0r_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET BCM53115_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET
#define READ_QOS_DIFF_DSCP0r BCM53115_A0_READ_QOS_DIFF_DSCP0r
#define WRITE_QOS_DIFF_DSCP0r BCM53115_A0_WRITE_QOS_DIFF_DSCP0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_DIFF_DSCP0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_DIFF_DSCP1
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 1 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_010000  DiffServ DSCP== 010000 to Priority ID map Register.
 *     PRI_DSCP_010001  DiffServ DSCP== 010001 to Priority ID map Register.
 *     PRI_DSCP_010010  DiffServ DSCP== 010010 to Priority ID map Register.
 *     PRI_DSCP_010011  DiffServ DSCP== 010011 to Priority ID map Register.
 *     PRI_DSCP_010100  DiffServ DSCP== 010100 to Priority ID map Register.
 *     PRI_DSCP_010101  DiffServ DSCP== 010101 to Priority ID map Register.
 *     PRI_DSCP_010110  DiffServ DSCP== 010110 to Priority ID map Register.
 *     PRI_DSCP_010111  DiffServ DSCP== 010111 to Priority ID map Register.
 *     PRI_DSCP_011000  DiffServ DSCP== 011000 to Priority ID map Register.
 *     PRI_DSCP_011001  DiffServ DSCP== 011001 to Priority ID map Register.
 *     PRI_DSCP_011010  DiffServ DSCP== 011010 to Priority ID map Register.
 *     PRI_DSCP_011011  DiffServ DSCP== 011011 to Priority ID map Register.
 *     PRI_DSCP_011100  DiffServ DSCP== 011100 to Priority ID map Register.
 *     PRI_DSCP_011101  DiffServ DSCP== 011101 to Priority ID map Register.
 *     PRI_DSCP_011110  DiffServ DSCP== 011110 to Priority ID map Register.
 *     PRI_DSCP_011111  DiffServ DSCP== 011111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_DIFF_DSCP1r 0x00003036

#define BCM53115_A0_QOS_DIFF_DSCP1r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP1.
 *
 */
typedef union BCM53115_A0_QOS_DIFF_DSCP1r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp1[2];
	uint32_t _qos_diff_dscp1;
} BCM53115_A0_QOS_DIFF_DSCP1r_t;

#define BCM53115_A0_QOS_DIFF_DSCP1r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp1), 0, sizeof(BCM53115_A0_QOS_DIFF_DSCP1r_t))
#define BCM53115_A0_QOS_DIFF_DSCP1r_SET(r,i,d) (r).qos_diff_dscp1[i] = d
#define BCM53115_A0_QOS_DIFF_DSCP1r_GET(r,i) (r).qos_diff_dscp1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET(r) (((r).qos_diff_dscp1[0]) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 3) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET(r) ((((r).qos_diff_dscp1[0]) >> 6) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET(r) ((((r).qos_diff_dscp1[0]) >> 9) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET(r) ((((r).qos_diff_dscp1[0]) >> 12) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET(r) ((((r).qos_diff_dscp1[0]) >> 15) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET(r) ((((r).qos_diff_dscp1[0]) >> 18) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET(r) ((((r).qos_diff_dscp1[0]) >> 21) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET(r) ((((r).qos_diff_dscp1[0]) >> 24) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 27) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET(r) cdk_field32_get((r).qos_diff_dscp1,30,32)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp1,30,32,f)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET(r) ((((r).qos_diff_dscp1[1]) >> 1) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET(r) ((((r).qos_diff_dscp1[1]) >> 4) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET(r) ((((r).qos_diff_dscp1[1]) >> 7) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET(r) ((((r).qos_diff_dscp1[1]) >> 10) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET(r) ((((r).qos_diff_dscp1[1]) >> 13) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP1.
 *
 */
#define BCM53115_A0_READ_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_DIFF_DSCP1r,(r._qos_diff_dscp1),6)
#define BCM53115_A0_WRITE_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_DIFF_DSCP1r,&(r._qos_diff_dscp1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP1r BCM53115_A0_QOS_DIFF_DSCP1r
#define QOS_DIFF_DSCP1r_SIZE BCM53115_A0_QOS_DIFF_DSCP1r_SIZE
typedef BCM53115_A0_QOS_DIFF_DSCP1r_t QOS_DIFF_DSCP1r_t;
#define QOS_DIFF_DSCP1r_CLR BCM53115_A0_QOS_DIFF_DSCP1r_CLR
#define QOS_DIFF_DSCP1r_SET BCM53115_A0_QOS_DIFF_DSCP1r_SET
#define QOS_DIFF_DSCP1r_GET BCM53115_A0_QOS_DIFF_DSCP1r_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET BCM53115_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET
#define READ_QOS_DIFF_DSCP1r BCM53115_A0_READ_QOS_DIFF_DSCP1r
#define WRITE_QOS_DIFF_DSCP1r BCM53115_A0_WRITE_QOS_DIFF_DSCP1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_DIFF_DSCP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_DIFF_DSCP2
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 2 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_100000  DiffServ DSCP== 100000 to Priority ID map Register.
 *     PRI_DSCP_100001  DiffServ DSCP== 100001 to Priority ID map Register.
 *     PRI_DSCP_100010  DiffServ DSCP== 100010 to Priority ID map Register.
 *     PRI_DSCP_100011  DiffServ DSCP== 100011 to Priority ID map Register.
 *     PRI_DSCP_100100  DiffServ DSCP== 100100 to Priority ID map Register.
 *     PRI_DSCP_100101  DiffServ DSCP== 100101 to Priority ID map Register.
 *     PRI_DSCP_100110  DiffServ DSCP== 100110 to Priority ID map Register.
 *     PRI_DSCP_100111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_101000  DiffServ DSCP== 101000 to Priority ID map Register.
 *     PRI_DSCP_101001  DiffServ DSCP== 101001 to Priority ID map Register.
 *     PRI_DSCP_101010  DiffServ DSCP== 101010 to Priority ID map Register.
 *     PRI_DSCP_101011  DiffServ DSCP== 101011 to Priority ID map Register.
 *     PRI_DSCP_101100  DiffServ DSCP== 101100 to Priority ID map Register.
 *     PRI_DSCP_101101  DiffServ DSCP== 001101 to Priority ID map Register.
 *     PRI_DSCP_101110  DiffServ DSCP== 001110 to Priority ID map Register.
 *     PRI_DSCP_101111  DiffServ DSCP== 001111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_DIFF_DSCP2r 0x0000303c

#define BCM53115_A0_QOS_DIFF_DSCP2r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP2.
 *
 */
typedef union BCM53115_A0_QOS_DIFF_DSCP2r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp2[2];
	uint32_t _qos_diff_dscp2;
} BCM53115_A0_QOS_DIFF_DSCP2r_t;

#define BCM53115_A0_QOS_DIFF_DSCP2r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp2), 0, sizeof(BCM53115_A0_QOS_DIFF_DSCP2r_t))
#define BCM53115_A0_QOS_DIFF_DSCP2r_SET(r,i,d) (r).qos_diff_dscp2[i] = d
#define BCM53115_A0_QOS_DIFF_DSCP2r_GET(r,i) (r).qos_diff_dscp2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET(r) (((r).qos_diff_dscp2[0]) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 3) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET(r) ((((r).qos_diff_dscp2[0]) >> 6) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET(r) ((((r).qos_diff_dscp2[0]) >> 9) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET(r) ((((r).qos_diff_dscp2[0]) >> 12) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET(r) ((((r).qos_diff_dscp2[0]) >> 15) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET(r) ((((r).qos_diff_dscp2[0]) >> 18) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET(r) ((((r).qos_diff_dscp2[0]) >> 21) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET(r) ((((r).qos_diff_dscp2[0]) >> 24) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 27) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET(r) cdk_field32_get((r).qos_diff_dscp2,30,32)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp2,30,32,f)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET(r) ((((r).qos_diff_dscp2[1]) >> 1) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET(r) ((((r).qos_diff_dscp2[1]) >> 4) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET(r) ((((r).qos_diff_dscp2[1]) >> 7) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET(r) ((((r).qos_diff_dscp2[1]) >> 10) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET(r) ((((r).qos_diff_dscp2[1]) >> 13) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP2.
 *
 */
#define BCM53115_A0_READ_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_DIFF_DSCP2r,(r._qos_diff_dscp2),6)
#define BCM53115_A0_WRITE_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_DIFF_DSCP2r,&(r._qos_diff_dscp2),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP2r BCM53115_A0_QOS_DIFF_DSCP2r
#define QOS_DIFF_DSCP2r_SIZE BCM53115_A0_QOS_DIFF_DSCP2r_SIZE
typedef BCM53115_A0_QOS_DIFF_DSCP2r_t QOS_DIFF_DSCP2r_t;
#define QOS_DIFF_DSCP2r_CLR BCM53115_A0_QOS_DIFF_DSCP2r_CLR
#define QOS_DIFF_DSCP2r_SET BCM53115_A0_QOS_DIFF_DSCP2r_SET
#define QOS_DIFF_DSCP2r_GET BCM53115_A0_QOS_DIFF_DSCP2r_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET BCM53115_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET
#define READ_QOS_DIFF_DSCP2r BCM53115_A0_READ_QOS_DIFF_DSCP2r
#define WRITE_QOS_DIFF_DSCP2r BCM53115_A0_WRITE_QOS_DIFF_DSCP2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_DIFF_DSCP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_DIFF_DSCP3
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 3 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_110000  DiffServ DSCP== 110000 to Priority ID map Register.
 *     PRI_DSCP_110001  DiffServ DSCP== 110001 to Priority ID map Register.
 *     PRI_DSCP_110010  DiffServ DSCP== 110010 to Priority ID map Register.
 *     PRI_DSCP_110011  DiffServ DSCP== 110011 to Priority ID map Register.
 *     PRI_DSCP_110100  DiffServ DSCP== 110100 to Priority ID map Register.
 *     PRI_DSCP_110101  DiffServ DSCP== 110101 to Priority ID map Register.
 *     PRI_DSCP_110110  DiffServ DSCP== 110110 to Priority ID map Register.
 *     PRI_DSCP_110111  DiffServ DSCP== 110111 to Priority ID map Register.
 *     PRI_DSCP_111000  DiffServ DSCP== 111000 to Priority ID map Register.
 *     PRI_DSCP_111001  DiffServ DSCP== 111001 to Priority ID map Register.
 *     PRI_DSCP_111010  DiffServ DSCP== 111010 to Priority ID map Register.
 *     PRI_DSCP_111011  DiffServ DSCP== 111011 to Priority ID map Register.
 *     PRI_DSCP_111100  DiffServ DSCP== 111100 to Priority ID map Register.
 *     PRI_DSCP_111101  DiffServ DSCP== 111101 to Priority ID map Register.
 *     PRI_DSCP_111110  DiffServ DSCP== 111110 to Priority ID map Register.
 *     PRI_DSCP_111111  DiffServ DSCP== 111111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_DIFF_DSCP3r 0x00003042

#define BCM53115_A0_QOS_DIFF_DSCP3r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP3.
 *
 */
typedef union BCM53115_A0_QOS_DIFF_DSCP3r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp3[2];
	uint32_t _qos_diff_dscp3;
} BCM53115_A0_QOS_DIFF_DSCP3r_t;

#define BCM53115_A0_QOS_DIFF_DSCP3r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp3), 0, sizeof(BCM53115_A0_QOS_DIFF_DSCP3r_t))
#define BCM53115_A0_QOS_DIFF_DSCP3r_SET(r,i,d) (r).qos_diff_dscp3[i] = d
#define BCM53115_A0_QOS_DIFF_DSCP3r_GET(r,i) (r).qos_diff_dscp3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET(r) (((r).qos_diff_dscp3[0]) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 3) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET(r) ((((r).qos_diff_dscp3[0]) >> 6) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET(r) ((((r).qos_diff_dscp3[0]) >> 9) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET(r) ((((r).qos_diff_dscp3[0]) >> 12) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET(r) ((((r).qos_diff_dscp3[0]) >> 15) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET(r) ((((r).qos_diff_dscp3[0]) >> 18) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET(r) ((((r).qos_diff_dscp3[0]) >> 21) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET(r) ((((r).qos_diff_dscp3[0]) >> 24) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 27) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET(r) cdk_field32_get((r).qos_diff_dscp3,30,32)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp3,30,32,f)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET(r) ((((r).qos_diff_dscp3[1]) >> 1) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET(r) ((((r).qos_diff_dscp3[1]) >> 4) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET(r) ((((r).qos_diff_dscp3[1]) >> 7) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET(r) ((((r).qos_diff_dscp3[1]) >> 10) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET(r) ((((r).qos_diff_dscp3[1]) >> 13) & 0x7)
#define BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP3.
 *
 */
#define BCM53115_A0_READ_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_DIFF_DSCP3r,(r._qos_diff_dscp3),6)
#define BCM53115_A0_WRITE_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_DIFF_DSCP3r,&(r._qos_diff_dscp3),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP3r BCM53115_A0_QOS_DIFF_DSCP3r
#define QOS_DIFF_DSCP3r_SIZE BCM53115_A0_QOS_DIFF_DSCP3r_SIZE
typedef BCM53115_A0_QOS_DIFF_DSCP3r_t QOS_DIFF_DSCP3r_t;
#define QOS_DIFF_DSCP3r_CLR BCM53115_A0_QOS_DIFF_DSCP3r_CLR
#define QOS_DIFF_DSCP3r_SET BCM53115_A0_QOS_DIFF_DSCP3r_SET
#define QOS_DIFF_DSCP3r_GET BCM53115_A0_QOS_DIFF_DSCP3r_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET BCM53115_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET
#define READ_QOS_DIFF_DSCP3r BCM53115_A0_READ_QOS_DIFF_DSCP3r
#define WRITE_QOS_DIFF_DSCP3r BCM53115_A0_WRITE_QOS_DIFF_DSCP3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_DIFF_DSCP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_EN_DIFFSERV
 * BLOCKS:   SYS
 * DESC:     QOS DiffServ Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_EN_DIFFSERV  Enable DiffServ priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_EN_DIFFSERVr 0x00003006

#define BCM53115_A0_QOS_EN_DIFFSERVr_SIZE 2

/*
 * This structure should be used to declare and program QOS_EN_DIFFSERV.
 *
 */
typedef union BCM53115_A0_QOS_EN_DIFFSERVr_s {
	uint32_t v[1];
	uint32_t qos_en_diffserv[1];
	uint32_t _qos_en_diffserv;
} BCM53115_A0_QOS_EN_DIFFSERVr_t;

#define BCM53115_A0_QOS_EN_DIFFSERVr_CLR(r) (r).qos_en_diffserv[0] = 0
#define BCM53115_A0_QOS_EN_DIFFSERVr_SET(r,d) (r).qos_en_diffserv[0] = d
#define BCM53115_A0_QOS_EN_DIFFSERVr_GET(r) (r).qos_en_diffserv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET(r) (((r).qos_en_diffserv[0]) & 0x1ff)
#define BCM53115_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_QOS_EN_DIFFSERVr_RESERVED_Rf_GET(r) ((((r).qos_en_diffserv[0]) >> 9) & 0x7f)
#define BCM53115_A0_QOS_EN_DIFFSERVr_RESERVED_Rf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_EN_DIFFSERV.
 *
 */
#define BCM53115_A0_READ_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_EN_DIFFSERVr,(r._qos_en_diffserv),2)
#define BCM53115_A0_WRITE_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_EN_DIFFSERVr,&(r._qos_en_diffserv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_EN_DIFFSERVr BCM53115_A0_QOS_EN_DIFFSERVr
#define QOS_EN_DIFFSERVr_SIZE BCM53115_A0_QOS_EN_DIFFSERVr_SIZE
typedef BCM53115_A0_QOS_EN_DIFFSERVr_t QOS_EN_DIFFSERVr_t;
#define QOS_EN_DIFFSERVr_CLR BCM53115_A0_QOS_EN_DIFFSERVr_CLR
#define QOS_EN_DIFFSERVr_SET BCM53115_A0_QOS_EN_DIFFSERVr_SET
#define QOS_EN_DIFFSERVr_GET BCM53115_A0_QOS_EN_DIFFSERVr_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET BCM53115_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET BCM53115_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET
#define QOS_EN_DIFFSERVr_RESERVED_Rf_GET BCM53115_A0_QOS_EN_DIFFSERVr_RESERVED_Rf_GET
#define QOS_EN_DIFFSERVr_RESERVED_Rf_SET BCM53115_A0_QOS_EN_DIFFSERVr_RESERVED_Rf_SET
#define READ_QOS_EN_DIFFSERVr BCM53115_A0_READ_QOS_EN_DIFFSERVr
#define WRITE_QOS_EN_DIFFSERVr BCM53115_A0_WRITE_QOS_EN_DIFFSERVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_EN_DIFFSERVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_GLOBAL_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS Global Control Register
 * SIZE:     8
 * FIELDS:
 *     MIB_QOS_MON_SEL  SelMIB QOS Monitor Selection2'b00: Queue 02'b01: Queue 12'b10: Queue 22'b11: Queue 3
 *     QOS_LAYER_SEL    QOS IP Layer/Mac Layer Selection.2'b00: Layer 2 QOS only.       Select 802.1p if enabled and the RX frame is tagged, otherwise select mac-based2'b01: IP QOS only Select Diffserv if enabled, otherwise priority=0.2'b10: If (IP) then IP QOS ELSE LAYER2 QOS For IP frame, select Diffserv (0 if Diffserv is off), for L2 frames, select 802.1p if enabled and tagged, otherwise mac-based2'b11: Max Priority of All QOS algorithm Select max priority from port-based, Diffserv if enabled, 802.1p if enabled,
 *     RESERVED_0R      Reserved
 *     PORT_QOS_EN      Port Based QOS Enable.When Set, Priority of Packet of individual Port can be assigned by Default Priority bits in Defualt 802.1Q Tag Register (Page:34h Address 10h-21h,26-27h)If Port-based QOS is enabled, it overrides all other priorities except the case of qos_layer_sel=11.Default value by Strap pin qos_en.
 *     AGGREGATION_MODE 
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_GLOBAL_CTRLr 0x00003000

#define BCM53115_A0_QOS_GLOBAL_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_GLOBAL_CTRL.
 *
 */
typedef union BCM53115_A0_QOS_GLOBAL_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_global_ctrl[1];
	uint32_t _qos_global_ctrl;
} BCM53115_A0_QOS_GLOBAL_CTRLr_t;

#define BCM53115_A0_QOS_GLOBAL_CTRLr_CLR(r) (r).qos_global_ctrl[0] = 0
#define BCM53115_A0_QOS_GLOBAL_CTRLr_SET(r,d) (r).qos_global_ctrl[0] = d
#define BCM53115_A0_QOS_GLOBAL_CTRLr_GET(r) (r).qos_global_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET(r) (((r).qos_global_ctrl[0]) & 0x3)
#define BCM53115_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET(r) ((((r).qos_global_ctrl[0]) >> 2) & 0x3)
#define BCM53115_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_QOS_GLOBAL_CTRLr_RESERVED_0Rf_GET(r) ((((r).qos_global_ctrl[0]) >> 4) & 0x3)
#define BCM53115_A0_QOS_GLOBAL_CTRLr_RESERVED_0Rf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53115_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET(r) ((((r).qos_global_ctrl[0]) >> 6) & 0x1)
#define BCM53115_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET(r) ((((r).qos_global_ctrl[0]) >> 7) & 0x1)
#define BCM53115_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access QOS_GLOBAL_CTRL.
 *
 */
#define BCM53115_A0_READ_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_GLOBAL_CTRLr,(r._qos_global_ctrl),1)
#define BCM53115_A0_WRITE_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_GLOBAL_CTRLr,&(r._qos_global_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_GLOBAL_CTRLr BCM53115_A0_QOS_GLOBAL_CTRLr
#define QOS_GLOBAL_CTRLr_SIZE BCM53115_A0_QOS_GLOBAL_CTRLr_SIZE
typedef BCM53115_A0_QOS_GLOBAL_CTRLr_t QOS_GLOBAL_CTRLr_t;
#define QOS_GLOBAL_CTRLr_CLR BCM53115_A0_QOS_GLOBAL_CTRLr_CLR
#define QOS_GLOBAL_CTRLr_SET BCM53115_A0_QOS_GLOBAL_CTRLr_SET
#define QOS_GLOBAL_CTRLr_GET BCM53115_A0_QOS_GLOBAL_CTRLr_GET
#define QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET BCM53115_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET
#define QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET BCM53115_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET
#define QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET BCM53115_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET
#define QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET BCM53115_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET
#define QOS_GLOBAL_CTRLr_RESERVED_0Rf_GET BCM53115_A0_QOS_GLOBAL_CTRLr_RESERVED_0Rf_GET
#define QOS_GLOBAL_CTRLr_RESERVED_0Rf_SET BCM53115_A0_QOS_GLOBAL_CTRLr_RESERVED_0Rf_SET
#define QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET BCM53115_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET
#define QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET BCM53115_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET
#define QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET BCM53115_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET
#define QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET BCM53115_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET
#define READ_QOS_GLOBAL_CTRLr BCM53115_A0_READ_QOS_GLOBAL_CTRLr
#define WRITE_QOS_GLOBAL_CTRLr BCM53115_A0_WRITE_QOS_GLOBAL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_GLOBAL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_TX_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS TX Control Register
 * SIZE:     8
 * FIELDS:
 *     QOS_PRIORITY_CTRL Best Effort Queues Priority ControlThis field controls the scheduling priority of the best effort queues. It does not affect the behavior of Q4 and Q5.00: all queues are weighted round robin01: Q3 is strict priority, Q2-Q0  are weighted round robin.10: Q3 and Q2 is strict priority, Q1-Q0 are weighted round robin.11: Q3, Q2, Q1 and Q0 are in strict priority.Strict priority: When it is in strict priority, the priority is Q3 > Q2 > Q1 > Q0. The G_TXPORT will always serve the higher queue first if it is not empty. In this mode, the service weight are don't care.Weighted round robin: When it is in weighted round robin mode, thequeues are scheduled in a round robin way according to the serviceweight of each queue.
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_TX_CTRLr 0x00003080

#define BCM53115_A0_QOS_TX_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_TX_CTRL.
 *
 */
typedef union BCM53115_A0_QOS_TX_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_tx_ctrl[1];
	uint32_t _qos_tx_ctrl;
} BCM53115_A0_QOS_TX_CTRLr_t;

#define BCM53115_A0_QOS_TX_CTRLr_CLR(r) (r).qos_tx_ctrl[0] = 0
#define BCM53115_A0_QOS_TX_CTRLr_SET(r,d) (r).qos_tx_ctrl[0] = d
#define BCM53115_A0_QOS_TX_CTRLr_GET(r) (r).qos_tx_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET(r) (((r).qos_tx_ctrl[0]) & 0x3)
#define BCM53115_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_QOS_TX_CTRLr_RESERVED_1Rf_GET(r) ((((r).qos_tx_ctrl[0]) >> 2) & 0x3f)
#define BCM53115_A0_QOS_TX_CTRLr_RESERVED_1Rf_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access QOS_TX_CTRL.
 *
 */
#define BCM53115_A0_READ_QOS_TX_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_TX_CTRLr,(r._qos_tx_ctrl),1)
#define BCM53115_A0_WRITE_QOS_TX_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_TX_CTRLr,&(r._qos_tx_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_TX_CTRLr BCM53115_A0_QOS_TX_CTRLr
#define QOS_TX_CTRLr_SIZE BCM53115_A0_QOS_TX_CTRLr_SIZE
typedef BCM53115_A0_QOS_TX_CTRLr_t QOS_TX_CTRLr_t;
#define QOS_TX_CTRLr_CLR BCM53115_A0_QOS_TX_CTRLr_CLR
#define QOS_TX_CTRLr_SET BCM53115_A0_QOS_TX_CTRLr_SET
#define QOS_TX_CTRLr_GET BCM53115_A0_QOS_TX_CTRLr_GET
#define QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET BCM53115_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET
#define QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET BCM53115_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET
#define QOS_TX_CTRLr_RESERVED_1Rf_GET BCM53115_A0_QOS_TX_CTRLr_RESERVED_1Rf_GET
#define QOS_TX_CTRLr_RESERVED_1Rf_SET BCM53115_A0_QOS_TX_CTRLr_RESERVED_1Rf_SET
#define READ_QOS_TX_CTRLr BCM53115_A0_READ_QOS_TX_CTRLr
#define WRITE_QOS_TX_CTRLr BCM53115_A0_WRITE_QOS_TX_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_TX_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Queue N Weight Register
 * SIZE:     8
 * FIELDS:
 *     WEIGHTS          Queue N Weight Register.Set to reserve the Service Weight of Queue N in packet count.
 *
 ******************************************************************************/
#define BCM53115_A0_QOS_WEIGHTr 0x00003081

#define BCM53115_A0_QOS_WEIGHTr_SIZE 1

/*
 * This structure should be used to declare and program QOS_WEIGHT.
 *
 */
typedef union BCM53115_A0_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t qos_weight[1];
	uint32_t _qos_weight;
} BCM53115_A0_QOS_WEIGHTr_t;

#define BCM53115_A0_QOS_WEIGHTr_CLR(r) (r).qos_weight[0] = 0
#define BCM53115_A0_QOS_WEIGHTr_SET(r,d) (r).qos_weight[0] = d
#define BCM53115_A0_QOS_WEIGHTr_GET(r) (r).qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_QOS_WEIGHTr_WEIGHTSf_GET(r) (((r).qos_weight[0]) & 0xff)
#define BCM53115_A0_QOS_WEIGHTr_WEIGHTSf_SET(r,f) (r).qos_weight[0]=(((r).qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access QOS_WEIGHT.
 *
 */
#define BCM53115_A0_READ_QOS_WEIGHTr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_QOS_WEIGHTr+(1*(i)),(r._qos_weight),1)
#define BCM53115_A0_WRITE_QOS_WEIGHTr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_QOS_WEIGHTr+(1*(i)),&(r._qos_weight),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_WEIGHTr BCM53115_A0_QOS_WEIGHTr
#define QOS_WEIGHTr_SIZE BCM53115_A0_QOS_WEIGHTr_SIZE
typedef BCM53115_A0_QOS_WEIGHTr_t QOS_WEIGHTr_t;
#define QOS_WEIGHTr_CLR BCM53115_A0_QOS_WEIGHTr_CLR
#define QOS_WEIGHTr_SET BCM53115_A0_QOS_WEIGHTr_SET
#define QOS_WEIGHTr_GET BCM53115_A0_QOS_WEIGHTr_GET
#define QOS_WEIGHTr_WEIGHTSf_GET BCM53115_A0_QOS_WEIGHTr_WEIGHTSf_GET
#define QOS_WEIGHTr_WEIGHTSf_SET BCM53115_A0_QOS_WEIGHTr_WEIGHTSf_SET
#define READ_QOS_WEIGHTr BCM53115_A0_READ_QOS_WEIGHTr
#define WRITE_QOS_WEIGHTr BCM53115_A0_WRITE_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RATE_INBAND
 * BLOCKS:   SYS
 * DESC:     CFP RATE In-Band Statistic Registers
 * SIZE:     32
 * FIELDS:
 *     INBAND_CNT       In Band CounterThis field contains the data to read from or write to the in-band counter
 *
 ******************************************************************************/
#define BCM53115_A0_RATE_INBANDr 0x0000a070

#define BCM53115_A0_RATE_INBANDr_SIZE 4

/*
 * This structure should be used to declare and program RATE_INBAND.
 *
 */
typedef union BCM53115_A0_RATE_INBANDr_s {
	uint32_t v[1];
	uint32_t rate_inband[1];
	uint32_t _rate_inband;
} BCM53115_A0_RATE_INBANDr_t;

#define BCM53115_A0_RATE_INBANDr_CLR(r) (r).rate_inband[0] = 0
#define BCM53115_A0_RATE_INBANDr_SET(r,d) (r).rate_inband[0] = d
#define BCM53115_A0_RATE_INBANDr_GET(r) (r).rate_inband[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RATE_INBANDr_INBAND_CNTf_GET(r) ((r).rate_inband[0])
#define BCM53115_A0_RATE_INBANDr_INBAND_CNTf_SET(r,f) (r).rate_inband[0]=((uint32_t)f)

/*
 * These macros can be used to access RATE_INBAND.
 *
 */
#define BCM53115_A0_READ_RATE_INBANDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RATE_INBANDr,(r._rate_inband),4)
#define BCM53115_A0_WRITE_RATE_INBANDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RATE_INBANDr,&(r._rate_inband),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_INBANDr BCM53115_A0_RATE_INBANDr
#define RATE_INBANDr_SIZE BCM53115_A0_RATE_INBANDr_SIZE
typedef BCM53115_A0_RATE_INBANDr_t RATE_INBANDr_t;
#define RATE_INBANDr_CLR BCM53115_A0_RATE_INBANDr_CLR
#define RATE_INBANDr_SET BCM53115_A0_RATE_INBANDr_SET
#define RATE_INBANDr_GET BCM53115_A0_RATE_INBANDr_GET
#define RATE_INBANDr_INBAND_CNTf_GET BCM53115_A0_RATE_INBANDr_INBAND_CNTf_GET
#define RATE_INBANDr_INBAND_CNTf_SET BCM53115_A0_RATE_INBANDr_INBAND_CNTf_SET
#define READ_RATE_INBANDr BCM53115_A0_READ_RATE_INBANDr
#define WRITE_RATE_INBANDr BCM53115_A0_WRITE_RATE_INBANDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RATE_INBANDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RATE_METER0
 * BLOCKS:   SYS
 * DESC:     CFP RATE METER DATA 0 Registers
 * SIZE:     32
 * FIELDS:
 *     CURR_QUOTA       Current Quota.This field is initialized by software as the initial credit for each flow. And hardware will update the current quota according to the per flow rate meter scheme. The unit is in byte.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_RATE_METER0r 0x0000a060

#define BCM53115_A0_RATE_METER0r_SIZE 4

/*
 * This structure should be used to declare and program RATE_METER0.
 *
 */
typedef union BCM53115_A0_RATE_METER0r_s {
	uint32_t v[1];
	uint32_t rate_meter0[1];
	uint32_t _rate_meter0;
} BCM53115_A0_RATE_METER0r_t;

#define BCM53115_A0_RATE_METER0r_CLR(r) (r).rate_meter0[0] = 0
#define BCM53115_A0_RATE_METER0r_SET(r,d) (r).rate_meter0[0] = d
#define BCM53115_A0_RATE_METER0r_GET(r) (r).rate_meter0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RATE_METER0r_CURR_QUOTAf_GET(r) (((r).rate_meter0[0]) & 0xffffff)
#define BCM53115_A0_RATE_METER0r_CURR_QUOTAf_SET(r,f) (r).rate_meter0[0]=(((r).rate_meter0[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM53115_A0_RATE_METER0r_RESERVED_Rf_GET(r) ((((r).rate_meter0[0]) >> 24) & 0xff)
#define BCM53115_A0_RATE_METER0r_RESERVED_Rf_SET(r,f) (r).rate_meter0[0]=(((r).rate_meter0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access RATE_METER0.
 *
 */
#define BCM53115_A0_READ_RATE_METER0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_RATE_METER0r,(r._rate_meter0),4)
#define BCM53115_A0_WRITE_RATE_METER0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_RATE_METER0r,&(r._rate_meter0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_METER0r BCM53115_A0_RATE_METER0r
#define RATE_METER0r_SIZE BCM53115_A0_RATE_METER0r_SIZE
typedef BCM53115_A0_RATE_METER0r_t RATE_METER0r_t;
#define RATE_METER0r_CLR BCM53115_A0_RATE_METER0r_CLR
#define RATE_METER0r_SET BCM53115_A0_RATE_METER0r_SET
#define RATE_METER0r_GET BCM53115_A0_RATE_METER0r_GET
#define RATE_METER0r_CURR_QUOTAf_GET BCM53115_A0_RATE_METER0r_CURR_QUOTAf_GET
#define RATE_METER0r_CURR_QUOTAf_SET BCM53115_A0_RATE_METER0r_CURR_QUOTAf_SET
#define RATE_METER0r_RESERVED_Rf_GET BCM53115_A0_RATE_METER0r_RESERVED_Rf_GET
#define RATE_METER0r_RESERVED_Rf_SET BCM53115_A0_RATE_METER0r_RESERVED_Rf_SET
#define READ_RATE_METER0r BCM53115_A0_READ_RATE_METER0r
#define WRITE_RATE_METER0r BCM53115_A0_WRITE_RATE_METER0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RATE_METER0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RATE_METER1
 * BLOCKS:   SYS
 * DESC:     CFP RATE METER DATA 1 Registers
 * SIZE:     32
 * FIELDS:
 *     TOKEN_NUM        Token.This token to be added on each refresh cycle, theunit is 32 byte.
 *     REF_CAP          Reference CAP.This field indicates the max bucket size per flow need to keep track off. The unit is in byte.5'b0_0000: ref_cap = 24'b1111_1111_1111_1111_1111_1111;5'b0_0001: ref_cap = 24'b0111_1111_1111_1111_1111_1111;5'b0_0010: ref_cap = 24'b0011_1111_1111_1111_1111_1111;5'b0_0011: ref_cap = 24'b0001_1111_1111_1111_1111_1111;5'b0_0100: ref_cap = 24'b0000_1111_1111_1111_1111_1111;5'b0_0101: ref_cap = 24'b0000_0111_1111_1111_1111_1111;5'b0_0110: ref_cap = 24'b0000_0011_1111_1111_1111_1111;5'b0_0111: ref_cap = 24'b0000_0001_1111_1111_1111_1111;5'b0_1000: ref_cap = 24'b0000_0000_1111_1111_1111_1111;5'b0_1001: ref_cap = 24'b0000_0000_0111_1111_1111_1111;5'b0_1010: ref_cap = 24'b0000_0000_0011_1111_1111_1111;5'b0_1011: ref_cap = 24'b0000_0000_0001_1111_1111_1111;5'b0_1100: ref_cap = 24'b0000_0000_0000_1111_1111_1111;5'b0_1101: ref_cap = 24'b0000_0000_0000_0111_1111_1111;5'b0_1110: ref_cap = 24'b0000_0000_0000_0011_1111_1111;5'b0_1111: ref_cap = 24'b0000_0000_0000_0001_1111_1111;others: reserved
 *     RESERVED_R       Reserved.
 *     RATE_REFRESH_EN  Rate Meter Refresh Enable.This field enables hardware for rate meter refresh.Software should set this bit after the rate meter RAM has been initialized, and software would like to start rate meter refresh (Global control).
 *
 ******************************************************************************/
#define BCM53115_A0_RATE_METER1r 0x0000a064

#define BCM53115_A0_RATE_METER1r_SIZE 4

/*
 * This structure should be used to declare and program RATE_METER1.
 *
 */
typedef union BCM53115_A0_RATE_METER1r_s {
	uint32_t v[1];
	uint32_t rate_meter1[1];
	uint32_t _rate_meter1;
} BCM53115_A0_RATE_METER1r_t;

#define BCM53115_A0_RATE_METER1r_CLR(r) (r).rate_meter1[0] = 0
#define BCM53115_A0_RATE_METER1r_SET(r,d) (r).rate_meter1[0] = d
#define BCM53115_A0_RATE_METER1r_GET(r) (r).rate_meter1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RATE_METER1r_TOKEN_NUMf_GET(r) (((r).rate_meter1[0]) & 0xff)
#define BCM53115_A0_RATE_METER1r_TOKEN_NUMf_SET(r,f) (r).rate_meter1[0]=(((r).rate_meter1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_RATE_METER1r_REF_CAPf_GET(r) ((((r).rate_meter1[0]) >> 8) & 0xf)
#define BCM53115_A0_RATE_METER1r_REF_CAPf_SET(r,f) (r).rate_meter1[0]=(((r).rate_meter1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_RATE_METER1r_RESERVED_Rf_GET(r) ((((r).rate_meter1[0]) >> 12) & 0x7ffff)
#define BCM53115_A0_RATE_METER1r_RESERVED_Rf_SET(r,f) (r).rate_meter1[0]=(((r).rate_meter1[0] & ~((uint32_t)0x7ffff << 12)) | ((((uint32_t)f) & 0x7ffff) << 12))
#define BCM53115_A0_RATE_METER1r_RATE_REFRESH_ENf_GET(r) ((((r).rate_meter1[0]) >> 31) & 0x1)
#define BCM53115_A0_RATE_METER1r_RATE_REFRESH_ENf_SET(r,f) (r).rate_meter1[0]=(((r).rate_meter1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access RATE_METER1.
 *
 */
#define BCM53115_A0_READ_RATE_METER1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_RATE_METER1r,(r._rate_meter1),4)
#define BCM53115_A0_WRITE_RATE_METER1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_RATE_METER1r,&(r._rate_meter1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_METER1r BCM53115_A0_RATE_METER1r
#define RATE_METER1r_SIZE BCM53115_A0_RATE_METER1r_SIZE
typedef BCM53115_A0_RATE_METER1r_t RATE_METER1r_t;
#define RATE_METER1r_CLR BCM53115_A0_RATE_METER1r_CLR
#define RATE_METER1r_SET BCM53115_A0_RATE_METER1r_SET
#define RATE_METER1r_GET BCM53115_A0_RATE_METER1r_GET
#define RATE_METER1r_TOKEN_NUMf_GET BCM53115_A0_RATE_METER1r_TOKEN_NUMf_GET
#define RATE_METER1r_TOKEN_NUMf_SET BCM53115_A0_RATE_METER1r_TOKEN_NUMf_SET
#define RATE_METER1r_REF_CAPf_GET BCM53115_A0_RATE_METER1r_REF_CAPf_GET
#define RATE_METER1r_REF_CAPf_SET BCM53115_A0_RATE_METER1r_REF_CAPf_SET
#define RATE_METER1r_RESERVED_Rf_GET BCM53115_A0_RATE_METER1r_RESERVED_Rf_GET
#define RATE_METER1r_RESERVED_Rf_SET BCM53115_A0_RATE_METER1r_RESERVED_Rf_SET
#define RATE_METER1r_RATE_REFRESH_ENf_GET BCM53115_A0_RATE_METER1r_RATE_REFRESH_ENf_GET
#define RATE_METER1r_RATE_REFRESH_ENf_SET BCM53115_A0_RATE_METER1r_RATE_REFRESH_ENf_SET
#define READ_RATE_METER1r BCM53115_A0_READ_RATE_METER1r
#define WRITE_RATE_METER1r BCM53115_A0_WRITE_RATE_METER1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RATE_METER1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RATE_OUTBAND
 * BLOCKS:   SYS
 * DESC:     CFP RATE OUT-Band Statistic Registers
 * SIZE:     32
 * FIELDS:
 *     OUTBAND_CNT      Out Band Counter.This field contains the data to read from or write to the out-band counter.
 *
 ******************************************************************************/
#define BCM53115_A0_RATE_OUTBANDr 0x0000a074

#define BCM53115_A0_RATE_OUTBANDr_SIZE 4

/*
 * This structure should be used to declare and program RATE_OUTBAND.
 *
 */
typedef union BCM53115_A0_RATE_OUTBANDr_s {
	uint32_t v[1];
	uint32_t rate_outband[1];
	uint32_t _rate_outband;
} BCM53115_A0_RATE_OUTBANDr_t;

#define BCM53115_A0_RATE_OUTBANDr_CLR(r) (r).rate_outband[0] = 0
#define BCM53115_A0_RATE_OUTBANDr_SET(r,d) (r).rate_outband[0] = d
#define BCM53115_A0_RATE_OUTBANDr_GET(r) (r).rate_outband[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RATE_OUTBANDr_OUTBAND_CNTf_GET(r) ((r).rate_outband[0])
#define BCM53115_A0_RATE_OUTBANDr_OUTBAND_CNTf_SET(r,f) (r).rate_outband[0]=((uint32_t)f)

/*
 * These macros can be used to access RATE_OUTBAND.
 *
 */
#define BCM53115_A0_READ_RATE_OUTBANDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RATE_OUTBANDr,(r._rate_outband),4)
#define BCM53115_A0_WRITE_RATE_OUTBANDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RATE_OUTBANDr,&(r._rate_outband),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RATE_OUTBANDr BCM53115_A0_RATE_OUTBANDr
#define RATE_OUTBANDr_SIZE BCM53115_A0_RATE_OUTBANDr_SIZE
typedef BCM53115_A0_RATE_OUTBANDr_t RATE_OUTBANDr_t;
#define RATE_OUTBANDr_CLR BCM53115_A0_RATE_OUTBANDr_CLR
#define RATE_OUTBANDr_SET BCM53115_A0_RATE_OUTBANDr_SET
#define RATE_OUTBANDr_GET BCM53115_A0_RATE_OUTBANDr_GET
#define RATE_OUTBANDr_OUTBAND_CNTf_GET BCM53115_A0_RATE_OUTBANDr_OUTBAND_CNTf_GET
#define RATE_OUTBANDr_OUTBAND_CNTf_SET BCM53115_A0_RATE_OUTBANDr_OUTBAND_CNTf_SET
#define READ_RATE_OUTBANDr BCM53115_A0_READ_RATE_OUTBANDr
#define WRITE_RATE_OUTBANDr BCM53115_A0_WRITE_RATE_OUTBANDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RATE_OUTBANDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_AV_EN_CTRL
 * BLOCKS:   SYS
 * DESC:     ResE AV Enable Control Register
 * SIZE:     16
 * FIELDS:
 *     AV_EN            AV enableThis field to define AV enable of each port.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_AV_EN_CTRLr 0x00009000

#define BCM53115_A0_RESE_AV_EN_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program RESE_AV_EN_CTRL.
 *
 */
typedef union BCM53115_A0_RESE_AV_EN_CTRLr_s {
	uint32_t v[1];
	uint32_t rese_av_en_ctrl[1];
	uint32_t _rese_av_en_ctrl;
} BCM53115_A0_RESE_AV_EN_CTRLr_t;

#define BCM53115_A0_RESE_AV_EN_CTRLr_CLR(r) (r).rese_av_en_ctrl[0] = 0
#define BCM53115_A0_RESE_AV_EN_CTRLr_SET(r,d) (r).rese_av_en_ctrl[0] = d
#define BCM53115_A0_RESE_AV_EN_CTRLr_GET(r) (r).rese_av_en_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_AV_EN_CTRLr_AV_ENf_GET(r) (((r).rese_av_en_ctrl[0]) & 0x3f)
#define BCM53115_A0_RESE_AV_EN_CTRLr_AV_ENf_SET(r,f) (r).rese_av_en_ctrl[0]=(((r).rese_av_en_ctrl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_RESE_AV_EN_CTRLr_RESERVED_Rf_GET(r) ((((r).rese_av_en_ctrl[0]) >> 6) & 0x3ff)
#define BCM53115_A0_RESE_AV_EN_CTRLr_RESERVED_Rf_SET(r,f) (r).rese_av_en_ctrl[0]=(((r).rese_av_en_ctrl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access RESE_AV_EN_CTRL.
 *
 */
#define BCM53115_A0_READ_RESE_AV_EN_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RESE_AV_EN_CTRLr,(r._rese_av_en_ctrl),2)
#define BCM53115_A0_WRITE_RESE_AV_EN_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RESE_AV_EN_CTRLr,&(r._rese_av_en_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_AV_EN_CTRLr BCM53115_A0_RESE_AV_EN_CTRLr
#define RESE_AV_EN_CTRLr_SIZE BCM53115_A0_RESE_AV_EN_CTRLr_SIZE
typedef BCM53115_A0_RESE_AV_EN_CTRLr_t RESE_AV_EN_CTRLr_t;
#define RESE_AV_EN_CTRLr_CLR BCM53115_A0_RESE_AV_EN_CTRLr_CLR
#define RESE_AV_EN_CTRLr_SET BCM53115_A0_RESE_AV_EN_CTRLr_SET
#define RESE_AV_EN_CTRLr_GET BCM53115_A0_RESE_AV_EN_CTRLr_GET
#define RESE_AV_EN_CTRLr_AV_ENf_GET BCM53115_A0_RESE_AV_EN_CTRLr_AV_ENf_GET
#define RESE_AV_EN_CTRLr_AV_ENf_SET BCM53115_A0_RESE_AV_EN_CTRLr_AV_ENf_SET
#define RESE_AV_EN_CTRLr_RESERVED_Rf_GET BCM53115_A0_RESE_AV_EN_CTRLr_RESERVED_Rf_GET
#define RESE_AV_EN_CTRLr_RESERVED_Rf_SET BCM53115_A0_RESE_AV_EN_CTRLr_RESERVED_Rf_SET
#define READ_RESE_AV_EN_CTRLr BCM53115_A0_READ_RESE_AV_EN_CTRLr
#define WRITE_RESE_AV_EN_CTRLr BCM53115_A0_WRITE_RESE_AV_EN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_AV_EN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_C4_BW_CNTL
 * BLOCKS:   GPIC0
 * DESC:     ResE Class 4 Bandwidth Control Register  
 * SIZE:     16
 * FIELDS:
 *     C4_BW            Class 5 Bandwidth for port NThis field defines the byte count allowed for Class 5traffic transmission within a slot time.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_C4_BW_CNTLr 0x00009060

#define BCM53115_A0_RESE_C4_BW_CNTLr_SIZE 2

/*
 * This structure should be used to declare and program RESE_C4_BW_CNTL.
 *
 */
typedef union BCM53115_A0_RESE_C4_BW_CNTLr_s {
	uint32_t v[1];
	uint32_t rese_c4_bw_cntl[1];
	uint32_t _rese_c4_bw_cntl;
} BCM53115_A0_RESE_C4_BW_CNTLr_t;

#define BCM53115_A0_RESE_C4_BW_CNTLr_CLR(r) (r).rese_c4_bw_cntl[0] = 0
#define BCM53115_A0_RESE_C4_BW_CNTLr_SET(r,d) (r).rese_c4_bw_cntl[0] = d
#define BCM53115_A0_RESE_C4_BW_CNTLr_GET(r) (r).rese_c4_bw_cntl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_C4_BW_CNTLr_C4_BWf_GET(r) (((r).rese_c4_bw_cntl[0]) & 0x3fff)
#define BCM53115_A0_RESE_C4_BW_CNTLr_C4_BWf_SET(r,f) (r).rese_c4_bw_cntl[0]=(((r).rese_c4_bw_cntl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53115_A0_RESE_C4_BW_CNTLr_RESERVED_Rf_GET(r) ((((r).rese_c4_bw_cntl[0]) >> 14) & 0x3)
#define BCM53115_A0_RESE_C4_BW_CNTLr_RESERVED_Rf_SET(r,f) (r).rese_c4_bw_cntl[0]=(((r).rese_c4_bw_cntl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access RESE_C4_BW_CNTL.
 *
 */
#define BCM53115_A0_READ_RESE_C4_BW_CNTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RESE_C4_BW_CNTLr,(r._rese_c4_bw_cntl),2)
#define BCM53115_A0_WRITE_RESE_C4_BW_CNTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RESE_C4_BW_CNTLr,&(r._rese_c4_bw_cntl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_C4_BW_CNTLr BCM53115_A0_RESE_C4_BW_CNTLr
#define RESE_C4_BW_CNTLr_SIZE BCM53115_A0_RESE_C4_BW_CNTLr_SIZE
typedef BCM53115_A0_RESE_C4_BW_CNTLr_t RESE_C4_BW_CNTLr_t;
#define RESE_C4_BW_CNTLr_CLR BCM53115_A0_RESE_C4_BW_CNTLr_CLR
#define RESE_C4_BW_CNTLr_SET BCM53115_A0_RESE_C4_BW_CNTLr_SET
#define RESE_C4_BW_CNTLr_GET BCM53115_A0_RESE_C4_BW_CNTLr_GET
#define RESE_C4_BW_CNTLr_C4_BWf_GET BCM53115_A0_RESE_C4_BW_CNTLr_C4_BWf_GET
#define RESE_C4_BW_CNTLr_C4_BWf_SET BCM53115_A0_RESE_C4_BW_CNTLr_C4_BWf_SET
#define RESE_C4_BW_CNTLr_RESERVED_Rf_GET BCM53115_A0_RESE_C4_BW_CNTLr_RESERVED_Rf_GET
#define RESE_C4_BW_CNTLr_RESERVED_Rf_SET BCM53115_A0_RESE_C4_BW_CNTLr_RESERVED_Rf_SET
#define READ_RESE_C4_BW_CNTLr BCM53115_A0_READ_RESE_C4_BW_CNTLr
#define WRITE_RESE_C4_BW_CNTLr BCM53115_A0_WRITE_RESE_C4_BW_CNTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_C4_BW_CNTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_C5_BW_CNTL
 * BLOCKS:   GPIC0
 * DESC:     ResE Class 5 Bandwidth Control Register  
 * SIZE:     16
 * FIELDS:
 *     C5_BW            Class 5 Bandwidth for port NThis field defines the byte count allowed for Class 5traffic transmission within a slot time.
 *     RESERVED_R       Reserved
 *     C5_WNDW          Class 5 traffic  Credit Carry-over control for port NThe purpose is to control the credit carry-over under different linkspeed. For 100M link, the 125us slot is too small such that ResEpacket could easily "slip slot", so the credit carry-over should beallowed. For 1G link, 125us slot is reasonably big such that the BWreservation could be done in a conservative way to prevent "slotslipping", so credit carry-over is not needed.
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_C5_BW_CNTLr 0x00009030

#define BCM53115_A0_RESE_C5_BW_CNTLr_SIZE 2

/*
 * This structure should be used to declare and program RESE_C5_BW_CNTL.
 *
 */
typedef union BCM53115_A0_RESE_C5_BW_CNTLr_s {
	uint32_t v[1];
	uint32_t rese_c5_bw_cntl[1];
	uint32_t _rese_c5_bw_cntl;
} BCM53115_A0_RESE_C5_BW_CNTLr_t;

#define BCM53115_A0_RESE_C5_BW_CNTLr_CLR(r) (r).rese_c5_bw_cntl[0] = 0
#define BCM53115_A0_RESE_C5_BW_CNTLr_SET(r,d) (r).rese_c5_bw_cntl[0] = d
#define BCM53115_A0_RESE_C5_BW_CNTLr_GET(r) (r).rese_c5_bw_cntl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_C5_BW_CNTLr_C5_BWf_GET(r) (((r).rese_c5_bw_cntl[0]) & 0x3fff)
#define BCM53115_A0_RESE_C5_BW_CNTLr_C5_BWf_SET(r,f) (r).rese_c5_bw_cntl[0]=(((r).rese_c5_bw_cntl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53115_A0_RESE_C5_BW_CNTLr_RESERVED_Rf_GET(r) ((((r).rese_c5_bw_cntl[0]) >> 14) & 0x1)
#define BCM53115_A0_RESE_C5_BW_CNTLr_RESERVED_Rf_SET(r,f) (r).rese_c5_bw_cntl[0]=(((r).rese_c5_bw_cntl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_RESE_C5_BW_CNTLr_C5_WNDWf_GET(r) ((((r).rese_c5_bw_cntl[0]) >> 15) & 0x1)
#define BCM53115_A0_RESE_C5_BW_CNTLr_C5_WNDWf_SET(r,f) (r).rese_c5_bw_cntl[0]=(((r).rese_c5_bw_cntl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access RESE_C5_BW_CNTL.
 *
 */
#define BCM53115_A0_READ_RESE_C5_BW_CNTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RESE_C5_BW_CNTLr,(r._rese_c5_bw_cntl),2)
#define BCM53115_A0_WRITE_RESE_C5_BW_CNTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RESE_C5_BW_CNTLr,&(r._rese_c5_bw_cntl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_C5_BW_CNTLr BCM53115_A0_RESE_C5_BW_CNTLr
#define RESE_C5_BW_CNTLr_SIZE BCM53115_A0_RESE_C5_BW_CNTLr_SIZE
typedef BCM53115_A0_RESE_C5_BW_CNTLr_t RESE_C5_BW_CNTLr_t;
#define RESE_C5_BW_CNTLr_CLR BCM53115_A0_RESE_C5_BW_CNTLr_CLR
#define RESE_C5_BW_CNTLr_SET BCM53115_A0_RESE_C5_BW_CNTLr_SET
#define RESE_C5_BW_CNTLr_GET BCM53115_A0_RESE_C5_BW_CNTLr_GET
#define RESE_C5_BW_CNTLr_C5_BWf_GET BCM53115_A0_RESE_C5_BW_CNTLr_C5_BWf_GET
#define RESE_C5_BW_CNTLr_C5_BWf_SET BCM53115_A0_RESE_C5_BW_CNTLr_C5_BWf_SET
#define RESE_C5_BW_CNTLr_RESERVED_Rf_GET BCM53115_A0_RESE_C5_BW_CNTLr_RESERVED_Rf_GET
#define RESE_C5_BW_CNTLr_RESERVED_Rf_SET BCM53115_A0_RESE_C5_BW_CNTLr_RESERVED_Rf_SET
#define RESE_C5_BW_CNTLr_C5_WNDWf_GET BCM53115_A0_RESE_C5_BW_CNTLr_C5_WNDWf_GET
#define RESE_C5_BW_CNTLr_C5_WNDWf_SET BCM53115_A0_RESE_C5_BW_CNTLr_C5_WNDWf_SET
#define READ_RESE_C5_BW_CNTLr BCM53115_A0_READ_RESE_C5_BW_CNTLr
#define WRITE_RESE_C5_BW_CNTLr BCM53115_A0_WRITE_RESE_C5_BW_CNTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_C5_BW_CNTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_EGRESS_TM_STAMP
 * BLOCKS:   GPIC0
 * DESC:     ResE Egress Time Stamp Register 
 * SIZE:     32
 * FIELDS:
 *     EGRESS_TS_TM_STAMP This field reports the time stamp of egress time sync. packet. It use32-bit time base as time stamping. The time between the departure offirst byte of MAC DA and the time stamping point should be constant.
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_EGRESS_TM_STAMPr 0x00009090

#define BCM53115_A0_RESE_EGRESS_TM_STAMPr_SIZE 4

/*
 * This structure should be used to declare and program RESE_EGRESS_TM_STAMP.
 *
 */
typedef union BCM53115_A0_RESE_EGRESS_TM_STAMPr_s {
	uint32_t v[1];
	uint32_t rese_egress_tm_stamp[1];
	uint32_t _rese_egress_tm_stamp;
} BCM53115_A0_RESE_EGRESS_TM_STAMPr_t;

#define BCM53115_A0_RESE_EGRESS_TM_STAMPr_CLR(r) (r).rese_egress_tm_stamp[0] = 0
#define BCM53115_A0_RESE_EGRESS_TM_STAMPr_SET(r,d) (r).rese_egress_tm_stamp[0] = d
#define BCM53115_A0_RESE_EGRESS_TM_STAMPr_GET(r) (r).rese_egress_tm_stamp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET(r) ((r).rese_egress_tm_stamp[0])
#define BCM53115_A0_RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET(r,f) (r).rese_egress_tm_stamp[0]=((uint32_t)f)

/*
 * These macros can be used to access RESE_EGRESS_TM_STAMP.
 *
 */
#define BCM53115_A0_READ_RESE_EGRESS_TM_STAMPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RESE_EGRESS_TM_STAMPr,(r._rese_egress_tm_stamp),4)
#define BCM53115_A0_WRITE_RESE_EGRESS_TM_STAMPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RESE_EGRESS_TM_STAMPr,&(r._rese_egress_tm_stamp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_EGRESS_TM_STAMPr BCM53115_A0_RESE_EGRESS_TM_STAMPr
#define RESE_EGRESS_TM_STAMPr_SIZE BCM53115_A0_RESE_EGRESS_TM_STAMPr_SIZE
typedef BCM53115_A0_RESE_EGRESS_TM_STAMPr_t RESE_EGRESS_TM_STAMPr_t;
#define RESE_EGRESS_TM_STAMPr_CLR BCM53115_A0_RESE_EGRESS_TM_STAMPr_CLR
#define RESE_EGRESS_TM_STAMPr_SET BCM53115_A0_RESE_EGRESS_TM_STAMPr_SET
#define RESE_EGRESS_TM_STAMPr_GET BCM53115_A0_RESE_EGRESS_TM_STAMPr_GET
#define RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET BCM53115_A0_RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET
#define RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET BCM53115_A0_RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET
#define READ_RESE_EGRESS_TM_STAMPr BCM53115_A0_READ_RESE_EGRESS_TM_STAMPr
#define WRITE_RESE_EGRESS_TM_STAMPr BCM53115_A0_WRITE_RESE_EGRESS_TM_STAMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_EGRESS_TM_STAMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_MAX_AV_PKT_SZ
 * BLOCKS:   SYS
 * DESC:     ResE MAX AV Packet Size Register
 * SIZE:     16
 * FIELDS:
 *     MAX_AV_PKT_SZ    This field is to define the max packet size of AV packet (Residential Ethernet).  The ingress port uses it to qualify if the packet is allowed to pass through an AV link. The egress port uses it to perform shaping gate.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_MAX_AV_PKT_SZr 0x00009004

#define BCM53115_A0_RESE_MAX_AV_PKT_SZr_SIZE 2

/*
 * This structure should be used to declare and program RESE_MAX_AV_PKT_SZ.
 *
 */
typedef union BCM53115_A0_RESE_MAX_AV_PKT_SZr_s {
	uint32_t v[1];
	uint32_t rese_max_av_pkt_sz[1];
	uint32_t _rese_max_av_pkt_sz;
} BCM53115_A0_RESE_MAX_AV_PKT_SZr_t;

#define BCM53115_A0_RESE_MAX_AV_PKT_SZr_CLR(r) (r).rese_max_av_pkt_sz[0] = 0
#define BCM53115_A0_RESE_MAX_AV_PKT_SZr_SET(r,d) (r).rese_max_av_pkt_sz[0] = d
#define BCM53115_A0_RESE_MAX_AV_PKT_SZr_GET(r) (r).rese_max_av_pkt_sz[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET(r) (((r).rese_max_av_pkt_sz[0]) & 0xfff)
#define BCM53115_A0_RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET(r,f) (r).rese_max_av_pkt_sz[0]=(((r).rese_max_av_pkt_sz[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53115_A0_RESE_MAX_AV_PKT_SZr_RESERVED_Rf_GET(r) ((((r).rese_max_av_pkt_sz[0]) >> 12) & 0xf)
#define BCM53115_A0_RESE_MAX_AV_PKT_SZr_RESERVED_Rf_SET(r,f) (r).rese_max_av_pkt_sz[0]=(((r).rese_max_av_pkt_sz[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RESE_MAX_AV_PKT_SZ.
 *
 */
#define BCM53115_A0_READ_RESE_MAX_AV_PKT_SZr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RESE_MAX_AV_PKT_SZr,(r._rese_max_av_pkt_sz),2)
#define BCM53115_A0_WRITE_RESE_MAX_AV_PKT_SZr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RESE_MAX_AV_PKT_SZr,&(r._rese_max_av_pkt_sz),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_MAX_AV_PKT_SZr BCM53115_A0_RESE_MAX_AV_PKT_SZr
#define RESE_MAX_AV_PKT_SZr_SIZE BCM53115_A0_RESE_MAX_AV_PKT_SZr_SIZE
typedef BCM53115_A0_RESE_MAX_AV_PKT_SZr_t RESE_MAX_AV_PKT_SZr_t;
#define RESE_MAX_AV_PKT_SZr_CLR BCM53115_A0_RESE_MAX_AV_PKT_SZr_CLR
#define RESE_MAX_AV_PKT_SZr_SET BCM53115_A0_RESE_MAX_AV_PKT_SZr_SET
#define RESE_MAX_AV_PKT_SZr_GET BCM53115_A0_RESE_MAX_AV_PKT_SZr_GET
#define RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET BCM53115_A0_RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET
#define RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET BCM53115_A0_RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET
#define RESE_MAX_AV_PKT_SZr_RESERVED_Rf_GET BCM53115_A0_RESE_MAX_AV_PKT_SZr_RESERVED_Rf_GET
#define RESE_MAX_AV_PKT_SZr_RESERVED_Rf_SET BCM53115_A0_RESE_MAX_AV_PKT_SZr_RESERVED_Rf_SET
#define READ_RESE_MAX_AV_PKT_SZr BCM53115_A0_READ_RESE_MAX_AV_PKT_SZr
#define WRITE_RESE_MAX_AV_PKT_SZr BCM53115_A0_WRITE_RESE_MAX_AV_PKT_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_MAX_AV_PKT_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_SLOT_ADJ
 * BLOCKS:   SYS
 * DESC:     ResE Slot Adjustment Register
 * SIZE:     32
 * FIELDS:
 *     SLOT_ADJ         This field defines when the Slot Number Counter increment by 1.  Default is 40.00: Slot Number increment by 1 when tick counter rolls over 312501:312610:312411: Reserved
 *     RESERVED_2R      Reserved
 *     SLOT_ADJ_PRD     This field defines the number of Slots to apply the altered SlotAdjustment.
 *     RESERVED_1R      Reserved
 *     MCRO_SLOT_PRD    This field defines the slot time of a Macro slot for Class 4 traffic.00: 1 ms01: 2 ms10: 4 ms11: reservedClass 5 traffic slot time is always 125 us period.
 *     RESERVED_0R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_SLOT_ADJr 0x0000901c

#define BCM53115_A0_RESE_SLOT_ADJr_SIZE 4

/*
 * This structure should be used to declare and program RESE_SLOT_ADJ.
 *
 */
typedef union BCM53115_A0_RESE_SLOT_ADJr_s {
	uint32_t v[1];
	uint32_t rese_slot_adj[1];
	uint32_t _rese_slot_adj;
} BCM53115_A0_RESE_SLOT_ADJr_t;

#define BCM53115_A0_RESE_SLOT_ADJr_CLR(r) (r).rese_slot_adj[0] = 0
#define BCM53115_A0_RESE_SLOT_ADJr_SET(r,d) (r).rese_slot_adj[0] = d
#define BCM53115_A0_RESE_SLOT_ADJr_GET(r) (r).rese_slot_adj[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_SLOT_ADJr_SLOT_ADJf_GET(r) (((r).rese_slot_adj[0]) & 0x3)
#define BCM53115_A0_RESE_SLOT_ADJr_SLOT_ADJf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_RESE_SLOT_ADJr_RESERVED_2Rf_GET(r) ((((r).rese_slot_adj[0]) >> 2) & 0x3f)
#define BCM53115_A0_RESE_SLOT_ADJr_RESERVED_2Rf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM53115_A0_RESE_SLOT_ADJr_SLOT_ADJ_PRDf_GET(r) ((((r).rese_slot_adj[0]) >> 8) & 0xf)
#define BCM53115_A0_RESE_SLOT_ADJr_SLOT_ADJ_PRDf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_RESE_SLOT_ADJr_RESERVED_1Rf_GET(r) ((((r).rese_slot_adj[0]) >> 12) & 0xf)
#define BCM53115_A0_RESE_SLOT_ADJr_RESERVED_1Rf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53115_A0_RESE_SLOT_ADJr_MCRO_SLOT_PRDf_GET(r) ((((r).rese_slot_adj[0]) >> 16) & 0x3)
#define BCM53115_A0_RESE_SLOT_ADJr_MCRO_SLOT_PRDf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53115_A0_RESE_SLOT_ADJr_RESERVED_0Rf_GET(r) ((((r).rese_slot_adj[0]) >> 18) & 0x3fff)
#define BCM53115_A0_RESE_SLOT_ADJr_RESERVED_0Rf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access RESE_SLOT_ADJ.
 *
 */
#define BCM53115_A0_READ_RESE_SLOT_ADJr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RESE_SLOT_ADJr,(r._rese_slot_adj),4)
#define BCM53115_A0_WRITE_RESE_SLOT_ADJr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RESE_SLOT_ADJr,&(r._rese_slot_adj),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_SLOT_ADJr BCM53115_A0_RESE_SLOT_ADJr
#define RESE_SLOT_ADJr_SIZE BCM53115_A0_RESE_SLOT_ADJr_SIZE
typedef BCM53115_A0_RESE_SLOT_ADJr_t RESE_SLOT_ADJr_t;
#define RESE_SLOT_ADJr_CLR BCM53115_A0_RESE_SLOT_ADJr_CLR
#define RESE_SLOT_ADJr_SET BCM53115_A0_RESE_SLOT_ADJr_SET
#define RESE_SLOT_ADJr_GET BCM53115_A0_RESE_SLOT_ADJr_GET
#define RESE_SLOT_ADJr_SLOT_ADJf_GET BCM53115_A0_RESE_SLOT_ADJr_SLOT_ADJf_GET
#define RESE_SLOT_ADJr_SLOT_ADJf_SET BCM53115_A0_RESE_SLOT_ADJr_SLOT_ADJf_SET
#define RESE_SLOT_ADJr_RESERVED_2Rf_GET BCM53115_A0_RESE_SLOT_ADJr_RESERVED_2Rf_GET
#define RESE_SLOT_ADJr_RESERVED_2Rf_SET BCM53115_A0_RESE_SLOT_ADJr_RESERVED_2Rf_SET
#define RESE_SLOT_ADJr_SLOT_ADJ_PRDf_GET BCM53115_A0_RESE_SLOT_ADJr_SLOT_ADJ_PRDf_GET
#define RESE_SLOT_ADJr_SLOT_ADJ_PRDf_SET BCM53115_A0_RESE_SLOT_ADJr_SLOT_ADJ_PRDf_SET
#define RESE_SLOT_ADJr_RESERVED_1Rf_GET BCM53115_A0_RESE_SLOT_ADJr_RESERVED_1Rf_GET
#define RESE_SLOT_ADJr_RESERVED_1Rf_SET BCM53115_A0_RESE_SLOT_ADJr_RESERVED_1Rf_SET
#define RESE_SLOT_ADJr_MCRO_SLOT_PRDf_GET BCM53115_A0_RESE_SLOT_ADJr_MCRO_SLOT_PRDf_GET
#define RESE_SLOT_ADJr_MCRO_SLOT_PRDf_SET BCM53115_A0_RESE_SLOT_ADJr_MCRO_SLOT_PRDf_SET
#define RESE_SLOT_ADJr_RESERVED_0Rf_GET BCM53115_A0_RESE_SLOT_ADJr_RESERVED_0Rf_GET
#define RESE_SLOT_ADJr_RESERVED_0Rf_SET BCM53115_A0_RESE_SLOT_ADJr_RESERVED_0Rf_SET
#define READ_RESE_SLOT_ADJr BCM53115_A0_READ_RESE_SLOT_ADJr
#define WRITE_RESE_SLOT_ADJr BCM53115_A0_WRITE_RESE_SLOT_ADJr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_SLOT_ADJr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_SLOT_TICK_CNTR
 * BLOCKS:   SYS
 * DESC:     ResE Slot Number and Tick Counter Register
 * SIZE:     32
 * FIELDS:
 *     SLOT_NUM         This field specifies the Slot Number for ResE.
 *     RESERVED_1R      Reserved
 *     TICK_CNTR        This is the tick counter which defines when will Slot Number increment. It runs from 1 to 3125 (or 3124, or 3126, depends on Slot Adjustment register setting) under 25MHz.
 *     RESERVED_0R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr 0x00009018

#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_SIZE 4

/*
 * This structure should be used to declare and program RESE_SLOT_TICK_CNTR.
 *
 */
typedef union BCM53115_A0_RESE_SLOT_TICK_CNTRr_s {
	uint32_t v[1];
	uint32_t rese_slot_tick_cntr[1];
	uint32_t _rese_slot_tick_cntr;
} BCM53115_A0_RESE_SLOT_TICK_CNTRr_t;

#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_CLR(r) (r).rese_slot_tick_cntr[0] = 0
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_SET(r,d) (r).rese_slot_tick_cntr[0] = d
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_GET(r) (r).rese_slot_tick_cntr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_SLOT_NUMf_GET(r) (((r).rese_slot_tick_cntr[0]) & 0x1f)
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_SLOT_NUMf_SET(r,f) (r).rese_slot_tick_cntr[0]=(((r).rese_slot_tick_cntr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_RESERVED_1Rf_GET(r) ((((r).rese_slot_tick_cntr[0]) >> 5) & 0x7ff)
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_RESERVED_1Rf_SET(r,f) (r).rese_slot_tick_cntr[0]=(((r).rese_slot_tick_cntr[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_TICK_CNTRf_GET(r) ((((r).rese_slot_tick_cntr[0]) >> 16) & 0xfff)
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_TICK_CNTRf_SET(r,f) (r).rese_slot_tick_cntr[0]=(((r).rese_slot_tick_cntr[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_RESERVED_0Rf_GET(r) ((((r).rese_slot_tick_cntr[0]) >> 28) & 0xf)
#define BCM53115_A0_RESE_SLOT_TICK_CNTRr_RESERVED_0Rf_SET(r,f) (r).rese_slot_tick_cntr[0]=(((r).rese_slot_tick_cntr[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access RESE_SLOT_TICK_CNTR.
 *
 */
#define BCM53115_A0_READ_RESE_SLOT_TICK_CNTRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RESE_SLOT_TICK_CNTRr,(r._rese_slot_tick_cntr),4)
#define BCM53115_A0_WRITE_RESE_SLOT_TICK_CNTRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RESE_SLOT_TICK_CNTRr,&(r._rese_slot_tick_cntr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_SLOT_TICK_CNTRr BCM53115_A0_RESE_SLOT_TICK_CNTRr
#define RESE_SLOT_TICK_CNTRr_SIZE BCM53115_A0_RESE_SLOT_TICK_CNTRr_SIZE
typedef BCM53115_A0_RESE_SLOT_TICK_CNTRr_t RESE_SLOT_TICK_CNTRr_t;
#define RESE_SLOT_TICK_CNTRr_CLR BCM53115_A0_RESE_SLOT_TICK_CNTRr_CLR
#define RESE_SLOT_TICK_CNTRr_SET BCM53115_A0_RESE_SLOT_TICK_CNTRr_SET
#define RESE_SLOT_TICK_CNTRr_GET BCM53115_A0_RESE_SLOT_TICK_CNTRr_GET
#define RESE_SLOT_TICK_CNTRr_SLOT_NUMf_GET BCM53115_A0_RESE_SLOT_TICK_CNTRr_SLOT_NUMf_GET
#define RESE_SLOT_TICK_CNTRr_SLOT_NUMf_SET BCM53115_A0_RESE_SLOT_TICK_CNTRr_SLOT_NUMf_SET
#define RESE_SLOT_TICK_CNTRr_RESERVED_1Rf_GET BCM53115_A0_RESE_SLOT_TICK_CNTRr_RESERVED_1Rf_GET
#define RESE_SLOT_TICK_CNTRr_RESERVED_1Rf_SET BCM53115_A0_RESE_SLOT_TICK_CNTRr_RESERVED_1Rf_SET
#define RESE_SLOT_TICK_CNTRr_TICK_CNTRf_GET BCM53115_A0_RESE_SLOT_TICK_CNTRr_TICK_CNTRf_GET
#define RESE_SLOT_TICK_CNTRr_TICK_CNTRf_SET BCM53115_A0_RESE_SLOT_TICK_CNTRr_TICK_CNTRf_SET
#define RESE_SLOT_TICK_CNTRr_RESERVED_0Rf_GET BCM53115_A0_RESE_SLOT_TICK_CNTRr_RESERVED_0Rf_GET
#define RESE_SLOT_TICK_CNTRr_RESERVED_0Rf_SET BCM53115_A0_RESE_SLOT_TICK_CNTRr_RESERVED_0Rf_SET
#define READ_RESE_SLOT_TICK_CNTRr BCM53115_A0_READ_RESE_SLOT_TICK_CNTRr
#define WRITE_RESE_SLOT_TICK_CNTRr BCM53115_A0_WRITE_RESE_SLOT_TICK_CNTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_SLOT_TICK_CNTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_TM_ADJ
 * BLOCKS:   SYS
 * DESC:     ResE Time Base Adjustment Register
 * SIZE:     32
 * FIELDS:
 *     TM_INC           This field is to define the max packet size of AV packet (Residential Ethernet).  The ingress port uses it to qualify if the packet is allowed to pass through an AV link. The egress port uses it to perform shaping gate.
 *     RESERVED_1R      Reserved
 *     TM_ADJ_PRD       This field defines the tick numbers to apply the adjusted Time Increment (when Time Increment does not equal to 40). For example, increment the Time Base 41 for 10 ticks. In this case, Time Adjust Period is 10, and Time Increment is 41.
 *     RESERVED_0R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_TM_ADJr 0x00009014

#define BCM53115_A0_RESE_TM_ADJr_SIZE 4

/*
 * This structure should be used to declare and program RESE_TM_ADJ.
 *
 */
typedef union BCM53115_A0_RESE_TM_ADJr_s {
	uint32_t v[1];
	uint32_t rese_tm_adj[1];
	uint32_t _rese_tm_adj;
} BCM53115_A0_RESE_TM_ADJr_t;

#define BCM53115_A0_RESE_TM_ADJr_CLR(r) (r).rese_tm_adj[0] = 0
#define BCM53115_A0_RESE_TM_ADJr_SET(r,d) (r).rese_tm_adj[0] = d
#define BCM53115_A0_RESE_TM_ADJr_GET(r) (r).rese_tm_adj[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_TM_ADJr_TM_INCf_GET(r) (((r).rese_tm_adj[0]) & 0x3f)
#define BCM53115_A0_RESE_TM_ADJr_TM_INCf_SET(r,f) (r).rese_tm_adj[0]=(((r).rese_tm_adj[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_RESE_TM_ADJr_RESERVED_1Rf_GET(r) ((((r).rese_tm_adj[0]) >> 6) & 0x3)
#define BCM53115_A0_RESE_TM_ADJr_RESERVED_1Rf_SET(r,f) (r).rese_tm_adj[0]=(((r).rese_tm_adj[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53115_A0_RESE_TM_ADJr_TM_ADJ_PRDf_GET(r) ((((r).rese_tm_adj[0]) >> 8) & 0xf)
#define BCM53115_A0_RESE_TM_ADJr_TM_ADJ_PRDf_SET(r,f) (r).rese_tm_adj[0]=(((r).rese_tm_adj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53115_A0_RESE_TM_ADJr_RESERVED_0Rf_GET(r) ((((r).rese_tm_adj[0]) >> 12) & 0xfffff)
#define BCM53115_A0_RESE_TM_ADJr_RESERVED_0Rf_SET(r,f) (r).rese_tm_adj[0]=(((r).rese_tm_adj[0] & ~((uint32_t)0xfffff << 12)) | ((((uint32_t)f) & 0xfffff) << 12))

/*
 * These macros can be used to access RESE_TM_ADJ.
 *
 */
#define BCM53115_A0_READ_RESE_TM_ADJr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RESE_TM_ADJr,(r._rese_tm_adj),4)
#define BCM53115_A0_WRITE_RESE_TM_ADJr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RESE_TM_ADJr,&(r._rese_tm_adj),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_TM_ADJr BCM53115_A0_RESE_TM_ADJr
#define RESE_TM_ADJr_SIZE BCM53115_A0_RESE_TM_ADJr_SIZE
typedef BCM53115_A0_RESE_TM_ADJr_t RESE_TM_ADJr_t;
#define RESE_TM_ADJr_CLR BCM53115_A0_RESE_TM_ADJr_CLR
#define RESE_TM_ADJr_SET BCM53115_A0_RESE_TM_ADJr_SET
#define RESE_TM_ADJr_GET BCM53115_A0_RESE_TM_ADJr_GET
#define RESE_TM_ADJr_TM_INCf_GET BCM53115_A0_RESE_TM_ADJr_TM_INCf_GET
#define RESE_TM_ADJr_TM_INCf_SET BCM53115_A0_RESE_TM_ADJr_TM_INCf_SET
#define RESE_TM_ADJr_RESERVED_1Rf_GET BCM53115_A0_RESE_TM_ADJr_RESERVED_1Rf_GET
#define RESE_TM_ADJr_RESERVED_1Rf_SET BCM53115_A0_RESE_TM_ADJr_RESERVED_1Rf_SET
#define RESE_TM_ADJr_TM_ADJ_PRDf_GET BCM53115_A0_RESE_TM_ADJr_TM_ADJ_PRDf_GET
#define RESE_TM_ADJr_TM_ADJ_PRDf_SET BCM53115_A0_RESE_TM_ADJr_TM_ADJ_PRDf_SET
#define RESE_TM_ADJr_RESERVED_0Rf_GET BCM53115_A0_RESE_TM_ADJr_RESERVED_0Rf_GET
#define RESE_TM_ADJr_RESERVED_0Rf_SET BCM53115_A0_RESE_TM_ADJr_RESERVED_0Rf_SET
#define READ_RESE_TM_ADJr BCM53115_A0_READ_RESE_TM_ADJr
#define WRITE_RESE_TM_ADJr BCM53115_A0_WRITE_RESE_TM_ADJr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_TM_ADJr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RESE_TM_BASE
 * BLOCKS:   SYS
 * DESC:     ResE Time Base Register
 * SIZE:     32
 * FIELDS:
 *     TM_BASE          This is 32-bit free running clock (running in 25MHz) for ResE time base. Ingress port and Egress port use it for Time Synchronization Packet Time Stamp.
 *
 ******************************************************************************/
#define BCM53115_A0_RESE_TM_BASEr 0x00009010

#define BCM53115_A0_RESE_TM_BASEr_SIZE 4

/*
 * This structure should be used to declare and program RESE_TM_BASE.
 *
 */
typedef union BCM53115_A0_RESE_TM_BASEr_s {
	uint32_t v[1];
	uint32_t rese_tm_base[1];
	uint32_t _rese_tm_base;
} BCM53115_A0_RESE_TM_BASEr_t;

#define BCM53115_A0_RESE_TM_BASEr_CLR(r) (r).rese_tm_base[0] = 0
#define BCM53115_A0_RESE_TM_BASEr_SET(r,d) (r).rese_tm_base[0] = d
#define BCM53115_A0_RESE_TM_BASEr_GET(r) (r).rese_tm_base[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RESE_TM_BASEr_TM_BASEf_GET(r) ((r).rese_tm_base[0])
#define BCM53115_A0_RESE_TM_BASEr_TM_BASEf_SET(r,f) (r).rese_tm_base[0]=((uint32_t)f)

/*
 * These macros can be used to access RESE_TM_BASE.
 *
 */
#define BCM53115_A0_READ_RESE_TM_BASEr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RESE_TM_BASEr,(r._rese_tm_base),4)
#define BCM53115_A0_WRITE_RESE_TM_BASEr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RESE_TM_BASEr,&(r._rese_tm_base),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_TM_BASEr BCM53115_A0_RESE_TM_BASEr
#define RESE_TM_BASEr_SIZE BCM53115_A0_RESE_TM_BASEr_SIZE
typedef BCM53115_A0_RESE_TM_BASEr_t RESE_TM_BASEr_t;
#define RESE_TM_BASEr_CLR BCM53115_A0_RESE_TM_BASEr_CLR
#define RESE_TM_BASEr_SET BCM53115_A0_RESE_TM_BASEr_SET
#define RESE_TM_BASEr_GET BCM53115_A0_RESE_TM_BASEr_GET
#define RESE_TM_BASEr_TM_BASEf_GET BCM53115_A0_RESE_TM_BASEr_TM_BASEf_GET
#define RESE_TM_BASEr_TM_BASEf_SET BCM53115_A0_RESE_TM_BASEr_TM_BASEf_SET
#define READ_RESE_TM_BASEr BCM53115_A0_READ_RESE_TM_BASEr
#define WRITE_RESE_TM_BASEr BCM53115_A0_WRITE_RESE_TM_BASEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RESE_TM_BASEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RMONSTEER
 * BLOCKS:   SYS
 * DESC:     RMON MIB Steering Register
 * SIZE:     16
 * FIELDS:
 *     OR_RMON_RCV      Override RMON Receive.Forces the RMON packet size bucket counters from the normal default of snooping on the receive side of the MAC, to the transmit side. This allows the RMON bucket counters to snoop either transmit or receive, allowing full duplex MAC support.0-7: Port0-7
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_RMONSTEERr 0x00000204

#define BCM53115_A0_RMONSTEERr_SIZE 2

/*
 * This structure should be used to declare and program RMONSTEER.
 *
 */
typedef union BCM53115_A0_RMONSTEERr_s {
	uint32_t v[1];
	uint32_t rmonsteer[1];
	uint32_t _rmonsteer;
} BCM53115_A0_RMONSTEERr_t;

#define BCM53115_A0_RMONSTEERr_CLR(r) (r).rmonsteer[0] = 0
#define BCM53115_A0_RMONSTEERr_SET(r,d) (r).rmonsteer[0] = d
#define BCM53115_A0_RMONSTEERr_GET(r) (r).rmonsteer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RMONSTEERr_OR_RMON_RCVf_GET(r) (((r).rmonsteer[0]) & 0x1ff)
#define BCM53115_A0_RMONSTEERr_OR_RMON_RCVf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_RMONSTEERr_RESERVED_Rf_GET(r) ((((r).rmonsteer[0]) >> 9) & 0x7f)
#define BCM53115_A0_RMONSTEERr_RESERVED_Rf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access RMONSTEER.
 *
 */
#define BCM53115_A0_READ_RMONSTEERr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RMONSTEERr,(r._rmonsteer),2)
#define BCM53115_A0_WRITE_RMONSTEERr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RMONSTEERr,&(r._rmonsteer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RMONSTEERr BCM53115_A0_RMONSTEERr
#define RMONSTEERr_SIZE BCM53115_A0_RMONSTEERr_SIZE
typedef BCM53115_A0_RMONSTEERr_t RMONSTEERr_t;
#define RMONSTEERr_CLR BCM53115_A0_RMONSTEERr_CLR
#define RMONSTEERr_SET BCM53115_A0_RMONSTEERr_SET
#define RMONSTEERr_GET BCM53115_A0_RMONSTEERr_GET
#define RMONSTEERr_OR_RMON_RCVf_GET BCM53115_A0_RMONSTEERr_OR_RMON_RCVf_GET
#define RMONSTEERr_OR_RMON_RCVf_SET BCM53115_A0_RMONSTEERr_OR_RMON_RCVf_SET
#define RMONSTEERr_RESERVED_Rf_GET BCM53115_A0_RMONSTEERr_RESERVED_Rf_GET
#define RMONSTEERr_RESERVED_Rf_SET BCM53115_A0_RMONSTEERr_RESERVED_Rf_SET
#define READ_RMONSTEERr BCM53115_A0_READ_RMONSTEERr
#define WRITE_RMONSTEERr BCM53115_A0_WRITE_RMONSTEERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RMONSTEERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RSV_MCAST_CTRL
 * BLOCKS:   SYS
 * DESC:     Reserved Multicast Register
 * SIZE:     8
 * FIELDS:
 *     EN_MUL_0         bit[0] :01-80-C2-00-00-00.0: Forward (default).1: Drop.
 *     EN_MUL_1         bit[1] :01-80-C2-00-00-02 ~ 01-80-C2-00-00-0F.0: Forward1: Drop (default)
 *     EN_MUL_2         bit[2] :01-80-C2-00-00-10.0: Forward (default).1: Drop.
 *     EN_MUL_3         bit[2] :01-80-C2-00-00-11 ~ 01-80-C2-00-00-1F.0: Forward (default).1: Drop.
 *     EN_MUL_4         bit[3] :01-80-C2-00-00-20 ~ 01-80-C2-00-00-2F.0: Forward (default).1: Drop.
 *     RESERVED_R       Reserved
 *     EN_RES_MUL_LEARN bit[7] :en_reserved_McastDA_learn.0: Don't learn (default )1: Learn
 *
 ******************************************************************************/
#define BCM53115_A0_RSV_MCAST_CTRLr 0x0000002f

#define BCM53115_A0_RSV_MCAST_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program RSV_MCAST_CTRL.
 *
 */
typedef union BCM53115_A0_RSV_MCAST_CTRLr_s {
	uint32_t v[1];
	uint32_t rsv_mcast_ctrl[1];
	uint32_t _rsv_mcast_ctrl;
} BCM53115_A0_RSV_MCAST_CTRLr_t;

#define BCM53115_A0_RSV_MCAST_CTRLr_CLR(r) (r).rsv_mcast_ctrl[0] = 0
#define BCM53115_A0_RSV_MCAST_CTRLr_SET(r,d) (r).rsv_mcast_ctrl[0] = d
#define BCM53115_A0_RSV_MCAST_CTRLr_GET(r) (r).rsv_mcast_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET(r) (((r).rsv_mcast_ctrl[0]) & 0x1)
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 3) & 0x1)
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 4) & 0x1)
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_RSV_MCAST_CTRLr_RESERVED_Rf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 5) & 0x3)
#define BCM53115_A0_RSV_MCAST_CTRLr_RESERVED_Rf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 7) & 0x1)
#define BCM53115_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RSV_MCAST_CTRL.
 *
 */
#define BCM53115_A0_READ_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RSV_MCAST_CTRLr,(r._rsv_mcast_ctrl),1)
#define BCM53115_A0_WRITE_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RSV_MCAST_CTRLr,&(r._rsv_mcast_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RSV_MCAST_CTRLr BCM53115_A0_RSV_MCAST_CTRLr
#define RSV_MCAST_CTRLr_SIZE BCM53115_A0_RSV_MCAST_CTRLr_SIZE
typedef BCM53115_A0_RSV_MCAST_CTRLr_t RSV_MCAST_CTRLr_t;
#define RSV_MCAST_CTRLr_CLR BCM53115_A0_RSV_MCAST_CTRLr_CLR
#define RSV_MCAST_CTRLr_SET BCM53115_A0_RSV_MCAST_CTRLr_SET
#define RSV_MCAST_CTRLr_GET BCM53115_A0_RSV_MCAST_CTRLr_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_GET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_SET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET
#define RSV_MCAST_CTRLr_EN_MUL_1f_GET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET
#define RSV_MCAST_CTRLr_EN_MUL_1f_SET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET
#define RSV_MCAST_CTRLr_EN_MUL_2f_GET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET
#define RSV_MCAST_CTRLr_EN_MUL_2f_SET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET
#define RSV_MCAST_CTRLr_EN_MUL_3f_GET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET
#define RSV_MCAST_CTRLr_EN_MUL_3f_SET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET
#define RSV_MCAST_CTRLr_EN_MUL_4f_GET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET
#define RSV_MCAST_CTRLr_EN_MUL_4f_SET BCM53115_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET
#define RSV_MCAST_CTRLr_RESERVED_Rf_GET BCM53115_A0_RSV_MCAST_CTRLr_RESERVED_Rf_GET
#define RSV_MCAST_CTRLr_RESERVED_Rf_SET BCM53115_A0_RSV_MCAST_CTRLr_RESERVED_Rf_SET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET BCM53115_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET BCM53115_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET
#define READ_RSV_MCAST_CTRLr BCM53115_A0_READ_RSV_MCAST_CTRLr
#define WRITE_RSV_MCAST_CTRLr BCM53115_A0_WRITE_RSV_MCAST_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RSV_MCAST_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RXDISCARD
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Discard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXDISCARDr 0x000020c0

#define BCM53115_A0_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD.
 *
 */
typedef union BCM53115_A0_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t rxdiscard[1];
	uint32_t _rxdiscard;
} BCM53115_A0_RXDISCARDr_t;

#define BCM53115_A0_RXDISCARDr_CLR(r) (r).rxdiscard[0] = 0
#define BCM53115_A0_RXDISCARDr_SET(r,d) (r).rxdiscard[0] = d
#define BCM53115_A0_RXDISCARDr_GET(r) (r).rxdiscard[0]


/*
 * These macros can be used to access RXDISCARD.
 *
 */
#define BCM53115_A0_READ_RXDISCARDr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXDISCARDr,(r._rxdiscard),4)
#define BCM53115_A0_WRITE_RXDISCARDr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXDISCARDr,&(r._rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARDr BCM53115_A0_RXDISCARDr
#define RXDISCARDr_SIZE BCM53115_A0_RXDISCARDr_SIZE
typedef BCM53115_A0_RXDISCARDr_t RXDISCARDr_t;
#define RXDISCARDr_CLR BCM53115_A0_RXDISCARDr_CLR
#define RXDISCARDr_SET BCM53115_A0_RXDISCARDr_SET
#define RXDISCARDr_GET BCM53115_A0_RXDISCARDr_GET
#define READ_RXDISCARDr BCM53115_A0_READ_RXDISCARDr
#define WRITE_RXDISCARDr BCM53115_A0_WRITE_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RXSymblErr
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXSYMBLERRr 0x000020ac

#define BCM53115_A0_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr.
 *
 */
typedef union BCM53115_A0_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t rxsymblerr[1];
	uint32_t _rxsymblerr;
} BCM53115_A0_RXSYMBLERRr_t;

#define BCM53115_A0_RXSYMBLERRr_CLR(r) (r).rxsymblerr[0] = 0
#define BCM53115_A0_RXSYMBLERRr_SET(r,d) (r).rxsymblerr[0] = d
#define BCM53115_A0_RXSYMBLERRr_GET(r) (r).rxsymblerr[0]


/*
 * These macros can be used to access RXSymblErr.
 *
 */
#define BCM53115_A0_READ_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXSYMBLERRr,(r._rxsymblerr),4)
#define BCM53115_A0_WRITE_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXSYMBLERRr,&(r._rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERRr BCM53115_A0_RXSYMBLERRr
#define RXSYMBLERRr_SIZE BCM53115_A0_RXSYMBLERRr_SIZE
typedef BCM53115_A0_RXSYMBLERRr_t RXSYMBLERRr_t;
#define RXSYMBLERRr_CLR BCM53115_A0_RXSYMBLERRr_CLR
#define RXSYMBLERRr_SET BCM53115_A0_RXSYMBLERRr_SET
#define RXSYMBLERRr_GET BCM53115_A0_RXSYMBLERRr_GET
#define READ_RXSYMBLERRr BCM53115_A0_READ_RXSYMBLERRr
#define WRITE_RXSYMBLERRr BCM53115_A0_WRITE_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RX_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     RX Global Control register
 * SIZE:     8
 * FIELDS:
 *     FMOK_LATENCY_CNT fmok latency counter.
 *     DIS_CRC_CHK      Disable crc check.
 *     DIS_ECC_CHK      Disable ecc check.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_RX_GLOBAL_CTLr 0x0000000a

#define BCM53115_A0_RX_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program RX_GLOBAL_CTL.
 *
 */
typedef union BCM53115_A0_RX_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_global_ctl[1];
	uint32_t _rx_global_ctl;
} BCM53115_A0_RX_GLOBAL_CTLr_t;

#define BCM53115_A0_RX_GLOBAL_CTLr_CLR(r) (r).rx_global_ctl[0] = 0
#define BCM53115_A0_RX_GLOBAL_CTLr_SET(r,d) (r).rx_global_ctl[0] = d
#define BCM53115_A0_RX_GLOBAL_CTLr_GET(r) (r).rx_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET(r) (((r).rx_global_ctl[0]) & 0xf)
#define BCM53115_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53115_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 4) & 0x1)
#define BCM53115_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 5) & 0x1)
#define BCM53115_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_RX_GLOBAL_CTLr_RESERVED_Rf_GET(r) ((((r).rx_global_ctl[0]) >> 6) & 0x3)
#define BCM53115_A0_RX_GLOBAL_CTLr_RESERVED_Rf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access RX_GLOBAL_CTL.
 *
 */
#define BCM53115_A0_READ_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RX_GLOBAL_CTLr,(r._rx_global_ctl),1)
#define BCM53115_A0_WRITE_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RX_GLOBAL_CTLr,&(r._rx_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_GLOBAL_CTLr BCM53115_A0_RX_GLOBAL_CTLr
#define RX_GLOBAL_CTLr_SIZE BCM53115_A0_RX_GLOBAL_CTLr_SIZE
typedef BCM53115_A0_RX_GLOBAL_CTLr_t RX_GLOBAL_CTLr_t;
#define RX_GLOBAL_CTLr_CLR BCM53115_A0_RX_GLOBAL_CTLr_CLR
#define RX_GLOBAL_CTLr_SET BCM53115_A0_RX_GLOBAL_CTLr_SET
#define RX_GLOBAL_CTLr_GET BCM53115_A0_RX_GLOBAL_CTLr_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET BCM53115_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET BCM53115_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET BCM53115_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET BCM53115_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET BCM53115_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET BCM53115_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET
#define RX_GLOBAL_CTLr_RESERVED_Rf_GET BCM53115_A0_RX_GLOBAL_CTLr_RESERVED_Rf_GET
#define RX_GLOBAL_CTLr_RESERVED_Rf_SET BCM53115_A0_RX_GLOBAL_CTLr_RESERVED_Rf_SET
#define READ_RX_GLOBAL_CTLr BCM53115_A0_READ_RX_GLOBAL_CTLr
#define WRITE_RX_GLOBAL_CTLr BCM53115_A0_WRITE_RX_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RX_GLOBAL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for RX Registrer
 * SIZE:     16
 * FIELDS:
 *     RX_PAUSE_PASS    RX pause pass through map.1 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_RX_PAUSE_PASSr 0x00000038

#define BCM53115_A0_RX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program RX_PAUSE_PASS.
 *
 */
typedef union BCM53115_A0_RX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t rx_pause_pass[1];
	uint32_t _rx_pause_pass;
} BCM53115_A0_RX_PAUSE_PASSr_t;

#define BCM53115_A0_RX_PAUSE_PASSr_CLR(r) (r).rx_pause_pass[0] = 0
#define BCM53115_A0_RX_PAUSE_PASSr_SET(r,d) (r).rx_pause_pass[0] = d
#define BCM53115_A0_RX_PAUSE_PASSr_GET(r) (r).rx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET(r) (((r).rx_pause_pass[0]) & 0xff)
#define BCM53115_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_RX_PAUSE_PASSr_RESERVED_Rf_GET(r) ((((r).rx_pause_pass[0]) >> 8) & 0xff)
#define BCM53115_A0_RX_PAUSE_PASSr_RESERVED_Rf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_PAUSE_PASS.
 *
 */
#define BCM53115_A0_READ_RX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_RX_PAUSE_PASSr,(r._rx_pause_pass),2)
#define BCM53115_A0_WRITE_RX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_RX_PAUSE_PASSr,&(r._rx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PAUSE_PASSr BCM53115_A0_RX_PAUSE_PASSr
#define RX_PAUSE_PASSr_SIZE BCM53115_A0_RX_PAUSE_PASSr_SIZE
typedef BCM53115_A0_RX_PAUSE_PASSr_t RX_PAUSE_PASSr_t;
#define RX_PAUSE_PASSr_CLR BCM53115_A0_RX_PAUSE_PASSr_CLR
#define RX_PAUSE_PASSr_SET BCM53115_A0_RX_PAUSE_PASSr_SET
#define RX_PAUSE_PASSr_GET BCM53115_A0_RX_PAUSE_PASSr_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET BCM53115_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET BCM53115_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET
#define RX_PAUSE_PASSr_RESERVED_Rf_GET BCM53115_A0_RX_PAUSE_PASSr_RESERVED_Rf_GET
#define RX_PAUSE_PASSr_RESERVED_Rf_SET BCM53115_A0_RX_PAUSE_PASSr_RESERVED_Rf_SET
#define READ_RX_PAUSE_PASSr BCM53115_A0_READ_RX_PAUSE_PASSr
#define WRITE_RX_PAUSE_PASSr BCM53115_A0_WRITE_RX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxAlignmentErrors
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXALIGNMENTERRORSr 0x00002080

#define BCM53115_A0_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors.
 *
 */
typedef union BCM53115_A0_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors[1];
	uint32_t _rxalignmenterrors;
} BCM53115_A0_RXALIGNMENTERRORSr_t;

#define BCM53115_A0_RXALIGNMENTERRORSr_CLR(r) (r).rxalignmenterrors[0] = 0
#define BCM53115_A0_RXALIGNMENTERRORSr_SET(r,d) (r).rxalignmenterrors[0] = d
#define BCM53115_A0_RXALIGNMENTERRORSr_GET(r) (r).rxalignmenterrors[0]


/*
 * These macros can be used to access RxAlignmentErrors.
 *
 */
#define BCM53115_A0_READ_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXALIGNMENTERRORSr,(r._rxalignmenterrors),4)
#define BCM53115_A0_WRITE_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXALIGNMENTERRORSr,&(r._rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORSr BCM53115_A0_RXALIGNMENTERRORSr
#define RXALIGNMENTERRORSr_SIZE BCM53115_A0_RXALIGNMENTERRORSr_SIZE
typedef BCM53115_A0_RXALIGNMENTERRORSr_t RXALIGNMENTERRORSr_t;
#define RXALIGNMENTERRORSr_CLR BCM53115_A0_RXALIGNMENTERRORSr_CLR
#define RXALIGNMENTERRORSr_SET BCM53115_A0_RXALIGNMENTERRORSr_SET
#define RXALIGNMENTERRORSr_GET BCM53115_A0_RXALIGNMENTERRORSr_GET
#define READ_RXALIGNMENTERRORSr BCM53115_A0_READ_RXALIGNMENTERRORSr
#define WRITE_RXALIGNMENTERRORSr BCM53115_A0_WRITE_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxBroadcastPkt
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXBROADCASTPKTr 0x0000209c

#define BCM53115_A0_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkt.
 *
 */
typedef union BCM53115_A0_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkt[1];
	uint32_t _rxbroadcastpkt;
} BCM53115_A0_RXBROADCASTPKTr_t;

#define BCM53115_A0_RXBROADCASTPKTr_CLR(r) (r).rxbroadcastpkt[0] = 0
#define BCM53115_A0_RXBROADCASTPKTr_SET(r,d) (r).rxbroadcastpkt[0] = d
#define BCM53115_A0_RXBROADCASTPKTr_GET(r) (r).rxbroadcastpkt[0]


/*
 * These macros can be used to access RxBroadcastPkt.
 *
 */
#define BCM53115_A0_READ_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXBROADCASTPKTr,(r._rxbroadcastpkt),4)
#define BCM53115_A0_WRITE_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXBROADCASTPKTr,&(r._rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTr BCM53115_A0_RXBROADCASTPKTr
#define RXBROADCASTPKTr_SIZE BCM53115_A0_RXBROADCASTPKTr_SIZE
typedef BCM53115_A0_RXBROADCASTPKTr_t RXBROADCASTPKTr_t;
#define RXBROADCASTPKTr_CLR BCM53115_A0_RXBROADCASTPKTr_CLR
#define RXBROADCASTPKTr_SET BCM53115_A0_RXBROADCASTPKTr_SET
#define RXBROADCASTPKTr_GET BCM53115_A0_RXBROADCASTPKTr_GET
#define READ_RXBROADCASTPKTr BCM53115_A0_READ_RXBROADCASTPKTr
#define WRITE_RXBROADCASTPKTr BCM53115_A0_WRITE_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXBROADCASTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxDropPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXDROPPKTSr 0x00002090

#define BCM53115_A0_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts.
 *
 */
typedef union BCM53115_A0_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t rxdroppkts[1];
	uint32_t _rxdroppkts;
} BCM53115_A0_RXDROPPKTSr_t;

#define BCM53115_A0_RXDROPPKTSr_CLR(r) (r).rxdroppkts[0] = 0
#define BCM53115_A0_RXDROPPKTSr_SET(r,d) (r).rxdroppkts[0] = d
#define BCM53115_A0_RXDROPPKTSr_GET(r) (r).rxdroppkts[0]


/*
 * These macros can be used to access RxDropPkts.
 *
 */
#define BCM53115_A0_READ_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXDROPPKTSr,(r._rxdroppkts),4)
#define BCM53115_A0_WRITE_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXDROPPKTSr,&(r._rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTSr BCM53115_A0_RXDROPPKTSr
#define RXDROPPKTSr_SIZE BCM53115_A0_RXDROPPKTSr_SIZE
typedef BCM53115_A0_RXDROPPKTSr_t RXDROPPKTSr_t;
#define RXDROPPKTSr_CLR BCM53115_A0_RXDROPPKTSr_CLR
#define RXDROPPKTSr_SET BCM53115_A0_RXDROPPKTSr_SET
#define RXDROPPKTSr_GET BCM53115_A0_RXDROPPKTSr_GET
#define READ_RXDROPPKTSr BCM53115_A0_READ_RXDROPPKTSr
#define WRITE_RXDROPPKTSr BCM53115_A0_WRITE_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxFCSErrors
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXFCSERRORSr 0x00002084

#define BCM53115_A0_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors.
 *
 */
typedef union BCM53115_A0_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t rxfcserrors[1];
	uint32_t _rxfcserrors;
} BCM53115_A0_RXFCSERRORSr_t;

#define BCM53115_A0_RXFCSERRORSr_CLR(r) (r).rxfcserrors[0] = 0
#define BCM53115_A0_RXFCSERRORSr_SET(r,d) (r).rxfcserrors[0] = d
#define BCM53115_A0_RXFCSERRORSr_GET(r) (r).rxfcserrors[0]


/*
 * These macros can be used to access RxFCSErrors.
 *
 */
#define BCM53115_A0_READ_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXFCSERRORSr,(r._rxfcserrors),4)
#define BCM53115_A0_WRITE_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXFCSERRORSr,&(r._rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORSr BCM53115_A0_RXFCSERRORSr
#define RXFCSERRORSr_SIZE BCM53115_A0_RXFCSERRORSr_SIZE
typedef BCM53115_A0_RXFCSERRORSr_t RXFCSERRORSr_t;
#define RXFCSERRORSr_CLR BCM53115_A0_RXFCSERRORSr_CLR
#define RXFCSERRORSr_SET BCM53115_A0_RXFCSERRORSr_SET
#define RXFCSERRORSr_GET BCM53115_A0_RXFCSERRORSr_GET
#define READ_RXFCSERRORSr BCM53115_A0_READ_RXFCSERRORSr
#define WRITE_RXFCSERRORSr BCM53115_A0_WRITE_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxFragments
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXFRAGMENTSr 0x000020a4

#define BCM53115_A0_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments.
 *
 */
typedef union BCM53115_A0_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t rxfragments[1];
	uint32_t _rxfragments;
} BCM53115_A0_RXFRAGMENTSr_t;

#define BCM53115_A0_RXFRAGMENTSr_CLR(r) (r).rxfragments[0] = 0
#define BCM53115_A0_RXFRAGMENTSr_SET(r,d) (r).rxfragments[0] = d
#define BCM53115_A0_RXFRAGMENTSr_GET(r) (r).rxfragments[0]


/*
 * These macros can be used to access RxFragments.
 *
 */
#define BCM53115_A0_READ_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXFRAGMENTSr,(r._rxfragments),4)
#define BCM53115_A0_WRITE_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXFRAGMENTSr,&(r._rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTSr BCM53115_A0_RXFRAGMENTSr
#define RXFRAGMENTSr_SIZE BCM53115_A0_RXFRAGMENTSr_SIZE
typedef BCM53115_A0_RXFRAGMENTSr_t RXFRAGMENTSr_t;
#define RXFRAGMENTSr_CLR BCM53115_A0_RXFRAGMENTSr_CLR
#define RXFRAGMENTSr_SET BCM53115_A0_RXFRAGMENTSr_SET
#define RXFRAGMENTSr_GET BCM53115_A0_RXFRAGMENTSr_GET
#define READ_RXFRAGMENTSr BCM53115_A0_READ_RXFRAGMENTSr
#define WRITE_RXFRAGMENTSr BCM53115_A0_WRITE_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxGoodOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53115_A0_RXGOODOCTETSr 0x00002088

#define BCM53115_A0_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets.
 *
 */
typedef union BCM53115_A0_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets[2];
	uint32_t _rxgoodoctets;
} BCM53115_A0_RXGOODOCTETSr_t;

#define BCM53115_A0_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets), 0, sizeof(BCM53115_A0_RXGOODOCTETSr_t))
#define BCM53115_A0_RXGOODOCTETSr_SET(r,i,d) (r).rxgoodoctets[i] = d
#define BCM53115_A0_RXGOODOCTETSr_GET(r,i) (r).rxgoodoctets[i]


/*
 * These macros can be used to access RxGoodOctets.
 *
 */
#define BCM53115_A0_READ_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXGOODOCTETSr,(r._rxgoodoctets),8)
#define BCM53115_A0_WRITE_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXGOODOCTETSr,&(r._rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETSr BCM53115_A0_RXGOODOCTETSr
#define RXGOODOCTETSr_SIZE BCM53115_A0_RXGOODOCTETSr_SIZE
typedef BCM53115_A0_RXGOODOCTETSr_t RXGOODOCTETSr_t;
#define RXGOODOCTETSr_CLR BCM53115_A0_RXGOODOCTETSr_CLR
#define RXGOODOCTETSr_SET BCM53115_A0_RXGOODOCTETSr_SET
#define RXGOODOCTETSr_GET BCM53115_A0_RXGOODOCTETSr_GET
#define READ_RXGOODOCTETSr BCM53115_A0_READ_RXGOODOCTETSr
#define WRITE_RXGOODOCTETSr BCM53115_A0_WRITE_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxJabbers
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXJABBERSr 0x0000207c

#define BCM53115_A0_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers.
 *
 */
typedef union BCM53115_A0_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t rxjabbers[1];
	uint32_t _rxjabbers;
} BCM53115_A0_RXJABBERSr_t;

#define BCM53115_A0_RXJABBERSr_CLR(r) (r).rxjabbers[0] = 0
#define BCM53115_A0_RXJABBERSr_SET(r,d) (r).rxjabbers[0] = d
#define BCM53115_A0_RXJABBERSr_GET(r) (r).rxjabbers[0]


/*
 * These macros can be used to access RxJabbers.
 *
 */
#define BCM53115_A0_READ_RXJABBERSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXJABBERSr,(r._rxjabbers),4)
#define BCM53115_A0_WRITE_RXJABBERSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXJABBERSr,&(r._rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERSr BCM53115_A0_RXJABBERSr
#define RXJABBERSr_SIZE BCM53115_A0_RXJABBERSr_SIZE
typedef BCM53115_A0_RXJABBERSr_t RXJABBERSr_t;
#define RXJABBERSr_CLR BCM53115_A0_RXJABBERSr_CLR
#define RXJABBERSr_SET BCM53115_A0_RXJABBERSr_SET
#define RXJABBERSr_GET BCM53115_A0_RXJABBERSr_GET
#define READ_RXJABBERSr BCM53115_A0_READ_RXJABBERSr
#define WRITE_RXJABBERSr BCM53115_A0_WRITE_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxMulticastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXMULTICASTPKTSr 0x00002098

#define BCM53115_A0_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts.
 *
 */
typedef union BCM53115_A0_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts[1];
	uint32_t _rxmulticastpkts;
} BCM53115_A0_RXMULTICASTPKTSr_t;

#define BCM53115_A0_RXMULTICASTPKTSr_CLR(r) (r).rxmulticastpkts[0] = 0
#define BCM53115_A0_RXMULTICASTPKTSr_SET(r,d) (r).rxmulticastpkts[0] = d
#define BCM53115_A0_RXMULTICASTPKTSr_GET(r) (r).rxmulticastpkts[0]


/*
 * These macros can be used to access RxMulticastPkts.
 *
 */
#define BCM53115_A0_READ_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXMULTICASTPKTSr,(r._rxmulticastpkts),4)
#define BCM53115_A0_WRITE_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXMULTICASTPKTSr,&(r._rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTSr BCM53115_A0_RXMULTICASTPKTSr
#define RXMULTICASTPKTSr_SIZE BCM53115_A0_RXMULTICASTPKTSr_SIZE
typedef BCM53115_A0_RXMULTICASTPKTSr_t RXMULTICASTPKTSr_t;
#define RXMULTICASTPKTSr_CLR BCM53115_A0_RXMULTICASTPKTSr_CLR
#define RXMULTICASTPKTSr_SET BCM53115_A0_RXMULTICASTPKTSr_SET
#define RXMULTICASTPKTSr_GET BCM53115_A0_RXMULTICASTPKTSr_GET
#define READ_RXMULTICASTPKTSr BCM53115_A0_READ_RXMULTICASTPKTSr
#define WRITE_RXMULTICASTPKTSr BCM53115_A0_WRITE_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53115_A0_RXOCTETSr 0x00002050

#define BCM53115_A0_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets.
 *
 */
typedef union BCM53115_A0_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t rxoctets[2];
	uint32_t _rxoctets;
} BCM53115_A0_RXOCTETSr_t;

#define BCM53115_A0_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxoctets), 0, sizeof(BCM53115_A0_RXOCTETSr_t))
#define BCM53115_A0_RXOCTETSr_SET(r,i,d) (r).rxoctets[i] = d
#define BCM53115_A0_RXOCTETSr_GET(r,i) (r).rxoctets[i]


/*
 * These macros can be used to access RxOctets.
 *
 */
#define BCM53115_A0_READ_RXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXOCTETSr,(r._rxoctets),8)
#define BCM53115_A0_WRITE_RXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXOCTETSr,&(r._rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETSr BCM53115_A0_RXOCTETSr
#define RXOCTETSr_SIZE BCM53115_A0_RXOCTETSr_SIZE
typedef BCM53115_A0_RXOCTETSr_t RXOCTETSr_t;
#define RXOCTETSr_CLR BCM53115_A0_RXOCTETSr_CLR
#define RXOCTETSr_SET BCM53115_A0_RXOCTETSr_SET
#define RXOCTETSr_GET BCM53115_A0_RXOCTETSr_GET
#define READ_RXOCTETSr BCM53115_A0_READ_RXOCTETSr
#define WRITE_RXOCTETSr BCM53115_A0_WRITE_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxOversizePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXOVERSIZEPKTSr 0x00002078

#define BCM53115_A0_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts.
 *
 */
typedef union BCM53115_A0_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts[1];
	uint32_t _rxoversizepkts;
} BCM53115_A0_RXOVERSIZEPKTSr_t;

#define BCM53115_A0_RXOVERSIZEPKTSr_CLR(r) (r).rxoversizepkts[0] = 0
#define BCM53115_A0_RXOVERSIZEPKTSr_SET(r,d) (r).rxoversizepkts[0] = d
#define BCM53115_A0_RXOVERSIZEPKTSr_GET(r) (r).rxoversizepkts[0]


/*
 * These macros can be used to access RxOversizePkts.
 *
 */
#define BCM53115_A0_READ_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXOVERSIZEPKTSr,(r._rxoversizepkts),4)
#define BCM53115_A0_WRITE_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXOVERSIZEPKTSr,&(r._rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTSr BCM53115_A0_RXOVERSIZEPKTSr
#define RXOVERSIZEPKTSr_SIZE BCM53115_A0_RXOVERSIZEPKTSr_SIZE
typedef BCM53115_A0_RXOVERSIZEPKTSr_t RXOVERSIZEPKTSr_t;
#define RXOVERSIZEPKTSr_CLR BCM53115_A0_RXOVERSIZEPKTSr_CLR
#define RXOVERSIZEPKTSr_SET BCM53115_A0_RXOVERSIZEPKTSr_SET
#define RXOVERSIZEPKTSr_GET BCM53115_A0_RXOVERSIZEPKTSr_GET
#define READ_RXOVERSIZEPKTSr BCM53115_A0_READ_RXOVERSIZEPKTSr
#define WRITE_RXOVERSIZEPKTSr BCM53115_A0_WRITE_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxPausePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXPAUSEPKTSr 0x0000205c

#define BCM53115_A0_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts.
 *
 */
typedef union BCM53115_A0_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t rxpausepkts[1];
	uint32_t _rxpausepkts;
} BCM53115_A0_RXPAUSEPKTSr_t;

#define BCM53115_A0_RXPAUSEPKTSr_CLR(r) (r).rxpausepkts[0] = 0
#define BCM53115_A0_RXPAUSEPKTSr_SET(r,d) (r).rxpausepkts[0] = d
#define BCM53115_A0_RXPAUSEPKTSr_GET(r) (r).rxpausepkts[0]


/*
 * These macros can be used to access RxPausePkts.
 *
 */
#define BCM53115_A0_READ_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXPAUSEPKTSr,(r._rxpausepkts),4)
#define BCM53115_A0_WRITE_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXPAUSEPKTSr,&(r._rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTSr BCM53115_A0_RXPAUSEPKTSr
#define RXPAUSEPKTSr_SIZE BCM53115_A0_RXPAUSEPKTSr_SIZE
typedef BCM53115_A0_RXPAUSEPKTSr_t RXPAUSEPKTSr_t;
#define RXPAUSEPKTSr_CLR BCM53115_A0_RXPAUSEPKTSr_CLR
#define RXPAUSEPKTSr_SET BCM53115_A0_RXPAUSEPKTSr_SET
#define RXPAUSEPKTSr_GET BCM53115_A0_RXPAUSEPKTSr_GET
#define READ_RXPAUSEPKTSr BCM53115_A0_READ_RXPAUSEPKTSr
#define WRITE_RXPAUSEPKTSr BCM53115_A0_WRITE_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxSAChanges
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXSACHANGESr 0x000020a0

#define BCM53115_A0_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges.
 *
 */
typedef union BCM53115_A0_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t rxsachanges[1];
	uint32_t _rxsachanges;
} BCM53115_A0_RXSACHANGESr_t;

#define BCM53115_A0_RXSACHANGESr_CLR(r) (r).rxsachanges[0] = 0
#define BCM53115_A0_RXSACHANGESr_SET(r,d) (r).rxsachanges[0] = d
#define BCM53115_A0_RXSACHANGESr_GET(r) (r).rxsachanges[0]


/*
 * These macros can be used to access RxSAChanges.
 *
 */
#define BCM53115_A0_READ_RXSACHANGESr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXSACHANGESr,(r._rxsachanges),4)
#define BCM53115_A0_WRITE_RXSACHANGESr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXSACHANGESr,&(r._rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGESr BCM53115_A0_RXSACHANGESr
#define RXSACHANGESr_SIZE BCM53115_A0_RXSACHANGESr_SIZE
typedef BCM53115_A0_RXSACHANGESr_t RXSACHANGESr_t;
#define RXSACHANGESr_CLR BCM53115_A0_RXSACHANGESr_CLR
#define RXSACHANGESr_SET BCM53115_A0_RXSACHANGESr_SET
#define RXSACHANGESr_GET BCM53115_A0_RXSACHANGESr_GET
#define READ_RXSACHANGESr BCM53115_A0_READ_RXSACHANGESr
#define WRITE_RXSACHANGESr BCM53115_A0_WRITE_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxUndersizePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXUNDERSIZEPKTSr 0x00002058

#define BCM53115_A0_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts.
 *
 */
typedef union BCM53115_A0_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts[1];
	uint32_t _rxundersizepkts;
} BCM53115_A0_RXUNDERSIZEPKTSr_t;

#define BCM53115_A0_RXUNDERSIZEPKTSr_CLR(r) (r).rxundersizepkts[0] = 0
#define BCM53115_A0_RXUNDERSIZEPKTSr_SET(r,d) (r).rxundersizepkts[0] = d
#define BCM53115_A0_RXUNDERSIZEPKTSr_GET(r) (r).rxundersizepkts[0]


/*
 * These macros can be used to access RxUndersizePkts.
 *
 */
#define BCM53115_A0_READ_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXUNDERSIZEPKTSr,(r._rxundersizepkts),4)
#define BCM53115_A0_WRITE_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXUNDERSIZEPKTSr,&(r._rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTSr BCM53115_A0_RXUNDERSIZEPKTSr
#define RXUNDERSIZEPKTSr_SIZE BCM53115_A0_RXUNDERSIZEPKTSr_SIZE
typedef BCM53115_A0_RXUNDERSIZEPKTSr_t RXUNDERSIZEPKTSr_t;
#define RXUNDERSIZEPKTSr_CLR BCM53115_A0_RXUNDERSIZEPKTSr_CLR
#define RXUNDERSIZEPKTSr_SET BCM53115_A0_RXUNDERSIZEPKTSr_SET
#define RXUNDERSIZEPKTSr_GET BCM53115_A0_RXUNDERSIZEPKTSr_GET
#define READ_RXUNDERSIZEPKTSr BCM53115_A0_READ_RXUNDERSIZEPKTSr
#define WRITE_RXUNDERSIZEPKTSr BCM53115_A0_WRITE_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  RxUnicastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_RXUNICASTPKTSr 0x00002094

#define BCM53115_A0_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts.
 *
 */
typedef union BCM53115_A0_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts[1];
	uint32_t _rxunicastpkts;
} BCM53115_A0_RXUNICASTPKTSr_t;

#define BCM53115_A0_RXUNICASTPKTSr_CLR(r) (r).rxunicastpkts[0] = 0
#define BCM53115_A0_RXUNICASTPKTSr_SET(r,d) (r).rxunicastpkts[0] = d
#define BCM53115_A0_RXUNICASTPKTSr_GET(r) (r).rxunicastpkts[0]


/*
 * These macros can be used to access RxUnicastPkts.
 *
 */
#define BCM53115_A0_READ_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_RXUNICASTPKTSr,(r._rxunicastpkts),4)
#define BCM53115_A0_WRITE_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_RXUNICASTPKTSr,&(r._rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTSr BCM53115_A0_RXUNICASTPKTSr
#define RXUNICASTPKTSr_SIZE BCM53115_A0_RXUNICASTPKTSr_SIZE
typedef BCM53115_A0_RXUNICASTPKTSr_t RXUNICASTPKTSr_t;
#define RXUNICASTPKTSr_CLR BCM53115_A0_RXUNICASTPKTSr_CLR
#define RXUNICASTPKTSr_SET BCM53115_A0_RXUNICASTPKTSr_SET
#define RXUNICASTPKTSr_GET BCM53115_A0_RXUNICASTPKTSr_GET
#define READ_RXUNICASTPKTSr BCM53115_A0_READ_RXUNICASTPKTSr
#define WRITE_RXUNICASTPKTSr BCM53115_A0_WRITE_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SFT_LRN_CTL
 * BLOCKS:   SYS
 * DESC:     Software Learning Control
 * SIZE:     16
 * FIELDS:
 *     SW_LEARN_CNTL    
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_SFT_LRN_CTLr 0x0000003e

#define BCM53115_A0_SFT_LRN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program SFT_LRN_CTL.
 *
 */
typedef union BCM53115_A0_SFT_LRN_CTLr_s {
	uint32_t v[1];
	uint32_t sft_lrn_ctl[1];
	uint32_t _sft_lrn_ctl;
} BCM53115_A0_SFT_LRN_CTLr_t;

#define BCM53115_A0_SFT_LRN_CTLr_CLR(r) (r).sft_lrn_ctl[0] = 0
#define BCM53115_A0_SFT_LRN_CTLr_SET(r,d) (r).sft_lrn_ctl[0] = d
#define BCM53115_A0_SFT_LRN_CTLr_GET(r) (r).sft_lrn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_GET(r) (((r).sft_lrn_ctl[0]) & 0x1ff)
#define BCM53115_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_SET(r,f) (r).sft_lrn_ctl[0]=(((r).sft_lrn_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_SFT_LRN_CTLr_RESERVED_Rf_GET(r) ((((r).sft_lrn_ctl[0]) >> 9) & 0x7f)
#define BCM53115_A0_SFT_LRN_CTLr_RESERVED_Rf_SET(r,f) (r).sft_lrn_ctl[0]=(((r).sft_lrn_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SFT_LRN_CTL.
 *
 */
#define BCM53115_A0_READ_SFT_LRN_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_SFT_LRN_CTLr,(r._sft_lrn_ctl),2)
#define BCM53115_A0_WRITE_SFT_LRN_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_SFT_LRN_CTLr,&(r._sft_lrn_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFT_LRN_CTLr BCM53115_A0_SFT_LRN_CTLr
#define SFT_LRN_CTLr_SIZE BCM53115_A0_SFT_LRN_CTLr_SIZE
typedef BCM53115_A0_SFT_LRN_CTLr_t SFT_LRN_CTLr_t;
#define SFT_LRN_CTLr_CLR BCM53115_A0_SFT_LRN_CTLr_CLR
#define SFT_LRN_CTLr_SET BCM53115_A0_SFT_LRN_CTLr_SET
#define SFT_LRN_CTLr_GET BCM53115_A0_SFT_LRN_CTLr_GET
#define SFT_LRN_CTLr_SW_LEARN_CNTLf_GET BCM53115_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_GET
#define SFT_LRN_CTLr_SW_LEARN_CNTLf_SET BCM53115_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_SET
#define SFT_LRN_CTLr_RESERVED_Rf_GET BCM53115_A0_SFT_LRN_CTLr_RESERVED_Rf_GET
#define SFT_LRN_CTLr_RESERVED_Rf_SET BCM53115_A0_SFT_LRN_CTLr_RESERVED_Rf_SET
#define READ_SFT_LRN_CTLr BCM53115_A0_READ_SFT_LRN_CTLr
#define WRITE_SFT_LRN_CTLr BCM53115_A0_WRITE_SFT_LRN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SFT_LRN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     5
 * FIELDS:
 *     CPIC             Software Block Flag for CPIC
 *     EXP              Software Block Flag for EXP
 *     GPIC             Software Block Flag for GPIC
 *     SPI              Software Block Flag for SPI
 *     SYS              Software Block Flag for SYS
 *
 ******************************************************************************/
#define BCM53115_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM53115_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM53115_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM53115_A0_SOFTWARE_BLOCKMAP_t;

#define BCM53115_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM53115_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM53115_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SOFTWARE_BLOCKMAP_CPICf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM53115_A0_SOFTWARE_BLOCKMAP_CPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_SOFTWARE_BLOCKMAP_EXPf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM53115_A0_SOFTWARE_BLOCKMAP_EXPf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_SOFTWARE_BLOCKMAP_GPICf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM53115_A0_SOFTWARE_BLOCKMAP_GPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_SOFTWARE_BLOCKMAP_SPIf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM53115_A0_SOFTWARE_BLOCKMAP_SPIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_SOFTWARE_BLOCKMAP_SYSf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM53115_A0_SOFTWARE_BLOCKMAP_SYSf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM53115_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM53115_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM53115_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM53115_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM53115_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM53115_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_CPICf_GET BCM53115_A0_SOFTWARE_BLOCKMAP_CPICf_GET
#define SOFTWARE_BLOCKMAP_CPICf_SET BCM53115_A0_SOFTWARE_BLOCKMAP_CPICf_SET
#define SOFTWARE_BLOCKMAP_EXPf_GET BCM53115_A0_SOFTWARE_BLOCKMAP_EXPf_GET
#define SOFTWARE_BLOCKMAP_EXPf_SET BCM53115_A0_SOFTWARE_BLOCKMAP_EXPf_SET
#define SOFTWARE_BLOCKMAP_GPICf_GET BCM53115_A0_SOFTWARE_BLOCKMAP_GPICf_GET
#define SOFTWARE_BLOCKMAP_GPICf_SET BCM53115_A0_SOFTWARE_BLOCKMAP_GPICf_SET
#define SOFTWARE_BLOCKMAP_SPIf_GET BCM53115_A0_SOFTWARE_BLOCKMAP_SPIf_GET
#define SOFTWARE_BLOCKMAP_SPIf_SET BCM53115_A0_SOFTWARE_BLOCKMAP_SPIf_SET
#define SOFTWARE_BLOCKMAP_SYSf_GET BCM53115_A0_SOFTWARE_BLOCKMAP_SYSf_GET
#define SOFTWARE_BLOCKMAP_SYSf_SET BCM53115_A0_SOFTWARE_BLOCKMAP_SYSf_SET
#define READ_SOFTWARE_BLOCKMAP BCM53115_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM53115_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPDSTS
 * BLOCKS:   SYS
 * DESC:     Port Speed Summary Register
 * SIZE:     32
 * FIELDS:
 *     PORT_SPD         Port Speed.18 bit field indicating the operating speed for each 10/100/1000BASE-T port.Bit 15:0 = Port 7 - Port 0(Bit [1:0] for Port 0, Bit [15:14] for Port 7 and Bit [17:16] for IMP port).00 = 10 Mb/s01 = 100 Mb/s10 = 1000 Mb/s
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_SPDSTSr 0x00000104

#define BCM53115_A0_SPDSTSr_SIZE 4

/*
 * This structure should be used to declare and program SPDSTS.
 *
 */
typedef union BCM53115_A0_SPDSTSr_s {
	uint32_t v[1];
	uint32_t spdsts[1];
	uint32_t _spdsts;
} BCM53115_A0_SPDSTSr_t;

#define BCM53115_A0_SPDSTSr_CLR(r) (r).spdsts[0] = 0
#define BCM53115_A0_SPDSTSr_SET(r,d) (r).spdsts[0] = d
#define BCM53115_A0_SPDSTSr_GET(r) (r).spdsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPDSTSr_PORT_SPDf_GET(r) (((r).spdsts[0]) & 0x3ffff)
#define BCM53115_A0_SPDSTSr_PORT_SPDf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53115_A0_SPDSTSr_RESERVED_Rf_GET(r) ((((r).spdsts[0]) >> 18) & 0x3fff)
#define BCM53115_A0_SPDSTSr_RESERVED_Rf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access SPDSTS.
 *
 */
#define BCM53115_A0_READ_SPDSTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPDSTSr,(r._spdsts),4)
#define BCM53115_A0_WRITE_SPDSTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPDSTSr,&(r._spdsts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPDSTSr BCM53115_A0_SPDSTSr
#define SPDSTSr_SIZE BCM53115_A0_SPDSTSr_SIZE
typedef BCM53115_A0_SPDSTSr_t SPDSTSr_t;
#define SPDSTSr_CLR BCM53115_A0_SPDSTSr_CLR
#define SPDSTSr_SET BCM53115_A0_SPDSTSr_SET
#define SPDSTSr_GET BCM53115_A0_SPDSTSr_GET
#define SPDSTSr_PORT_SPDf_GET BCM53115_A0_SPDSTSr_PORT_SPDf_GET
#define SPDSTSr_PORT_SPDf_SET BCM53115_A0_SPDSTSr_PORT_SPDf_SET
#define SPDSTSr_RESERVED_Rf_GET BCM53115_A0_SPDSTSr_RESERVED_Rf_GET
#define SPDSTSr_RESERVED_Rf_SET BCM53115_A0_SPDSTSr_RESERVED_Rf_SET
#define READ_SPDSTSr BCM53115_A0_READ_SPDSTSr
#define WRITE_SPDSTSr BCM53115_A0_WRITE_SPDSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPDSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPIDIO0
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 0
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Data I/O 0
 *
 ******************************************************************************/
#define BCM53115_A0_SPIDIO0r 0x0000fff0

#define BCM53115_A0_SPIDIO0r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO0.
 *
 */
typedef union BCM53115_A0_SPIDIO0r_s {
	uint32_t v[1];
	uint32_t spidio0[1];
	uint32_t _spidio0;
} BCM53115_A0_SPIDIO0r_t;

#define BCM53115_A0_SPIDIO0r_CLR(r) (r).spidio0[0] = 0
#define BCM53115_A0_SPIDIO0r_SET(r,d) (r).spidio0[0] = d
#define BCM53115_A0_SPIDIO0r_GET(r) (r).spidio0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPIDIO0r_RESERVED_Rf_GET(r) (((r).spidio0[0]) & 0xff)
#define BCM53115_A0_SPIDIO0r_RESERVED_Rf_SET(r,f) (r).spidio0[0]=(((r).spidio0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO0.
 *
 */
#define BCM53115_A0_READ_SPIDIO0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPIDIO0r,(r._spidio0),1)
#define BCM53115_A0_WRITE_SPIDIO0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPIDIO0r,&(r._spidio0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO0r BCM53115_A0_SPIDIO0r
#define SPIDIO0r_SIZE BCM53115_A0_SPIDIO0r_SIZE
typedef BCM53115_A0_SPIDIO0r_t SPIDIO0r_t;
#define SPIDIO0r_CLR BCM53115_A0_SPIDIO0r_CLR
#define SPIDIO0r_SET BCM53115_A0_SPIDIO0r_SET
#define SPIDIO0r_GET BCM53115_A0_SPIDIO0r_GET
#define SPIDIO0r_RESERVED_Rf_GET BCM53115_A0_SPIDIO0r_RESERVED_Rf_GET
#define SPIDIO0r_RESERVED_Rf_SET BCM53115_A0_SPIDIO0r_RESERVED_Rf_SET
#define READ_SPIDIO0r BCM53115_A0_READ_SPIDIO0r
#define WRITE_SPIDIO0r BCM53115_A0_WRITE_SPIDIO0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPIDIO0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPIDIO1
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 1
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Data I/O 1
 *
 ******************************************************************************/
#define BCM53115_A0_SPIDIO1r 0x0000fff1

#define BCM53115_A0_SPIDIO1r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO1.
 *
 */
typedef union BCM53115_A0_SPIDIO1r_s {
	uint32_t v[1];
	uint32_t spidio1[1];
	uint32_t _spidio1;
} BCM53115_A0_SPIDIO1r_t;

#define BCM53115_A0_SPIDIO1r_CLR(r) (r).spidio1[0] = 0
#define BCM53115_A0_SPIDIO1r_SET(r,d) (r).spidio1[0] = d
#define BCM53115_A0_SPIDIO1r_GET(r) (r).spidio1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPIDIO1r_RESERVED_Rf_GET(r) (((r).spidio1[0]) & 0xff)
#define BCM53115_A0_SPIDIO1r_RESERVED_Rf_SET(r,f) (r).spidio1[0]=(((r).spidio1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO1.
 *
 */
#define BCM53115_A0_READ_SPIDIO1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPIDIO1r,(r._spidio1),1)
#define BCM53115_A0_WRITE_SPIDIO1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPIDIO1r,&(r._spidio1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO1r BCM53115_A0_SPIDIO1r
#define SPIDIO1r_SIZE BCM53115_A0_SPIDIO1r_SIZE
typedef BCM53115_A0_SPIDIO1r_t SPIDIO1r_t;
#define SPIDIO1r_CLR BCM53115_A0_SPIDIO1r_CLR
#define SPIDIO1r_SET BCM53115_A0_SPIDIO1r_SET
#define SPIDIO1r_GET BCM53115_A0_SPIDIO1r_GET
#define SPIDIO1r_RESERVED_Rf_GET BCM53115_A0_SPIDIO1r_RESERVED_Rf_GET
#define SPIDIO1r_RESERVED_Rf_SET BCM53115_A0_SPIDIO1r_RESERVED_Rf_SET
#define READ_SPIDIO1r BCM53115_A0_READ_SPIDIO1r
#define WRITE_SPIDIO1r BCM53115_A0_WRITE_SPIDIO1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPIDIO1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPIDIO2
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 2
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Data I/O 2
 *
 ******************************************************************************/
#define BCM53115_A0_SPIDIO2r 0x0000fff2

#define BCM53115_A0_SPIDIO2r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO2.
 *
 */
typedef union BCM53115_A0_SPIDIO2r_s {
	uint32_t v[1];
	uint32_t spidio2[1];
	uint32_t _spidio2;
} BCM53115_A0_SPIDIO2r_t;

#define BCM53115_A0_SPIDIO2r_CLR(r) (r).spidio2[0] = 0
#define BCM53115_A0_SPIDIO2r_SET(r,d) (r).spidio2[0] = d
#define BCM53115_A0_SPIDIO2r_GET(r) (r).spidio2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPIDIO2r_RESERVED_Rf_GET(r) (((r).spidio2[0]) & 0xff)
#define BCM53115_A0_SPIDIO2r_RESERVED_Rf_SET(r,f) (r).spidio2[0]=(((r).spidio2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO2.
 *
 */
#define BCM53115_A0_READ_SPIDIO2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPIDIO2r,(r._spidio2),1)
#define BCM53115_A0_WRITE_SPIDIO2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPIDIO2r,&(r._spidio2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO2r BCM53115_A0_SPIDIO2r
#define SPIDIO2r_SIZE BCM53115_A0_SPIDIO2r_SIZE
typedef BCM53115_A0_SPIDIO2r_t SPIDIO2r_t;
#define SPIDIO2r_CLR BCM53115_A0_SPIDIO2r_CLR
#define SPIDIO2r_SET BCM53115_A0_SPIDIO2r_SET
#define SPIDIO2r_GET BCM53115_A0_SPIDIO2r_GET
#define SPIDIO2r_RESERVED_Rf_GET BCM53115_A0_SPIDIO2r_RESERVED_Rf_GET
#define SPIDIO2r_RESERVED_Rf_SET BCM53115_A0_SPIDIO2r_RESERVED_Rf_SET
#define READ_SPIDIO2r BCM53115_A0_READ_SPIDIO2r
#define WRITE_SPIDIO2r BCM53115_A0_WRITE_SPIDIO2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPIDIO2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPIDIO3
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 3
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Data I/O 3
 *
 ******************************************************************************/
#define BCM53115_A0_SPIDIO3r 0x0000fff3

#define BCM53115_A0_SPIDIO3r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO3.
 *
 */
typedef union BCM53115_A0_SPIDIO3r_s {
	uint32_t v[1];
	uint32_t spidio3[1];
	uint32_t _spidio3;
} BCM53115_A0_SPIDIO3r_t;

#define BCM53115_A0_SPIDIO3r_CLR(r) (r).spidio3[0] = 0
#define BCM53115_A0_SPIDIO3r_SET(r,d) (r).spidio3[0] = d
#define BCM53115_A0_SPIDIO3r_GET(r) (r).spidio3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPIDIO3r_RESERVED_Rf_GET(r) (((r).spidio3[0]) & 0xff)
#define BCM53115_A0_SPIDIO3r_RESERVED_Rf_SET(r,f) (r).spidio3[0]=(((r).spidio3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO3.
 *
 */
#define BCM53115_A0_READ_SPIDIO3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPIDIO3r,(r._spidio3),1)
#define BCM53115_A0_WRITE_SPIDIO3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPIDIO3r,&(r._spidio3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO3r BCM53115_A0_SPIDIO3r
#define SPIDIO3r_SIZE BCM53115_A0_SPIDIO3r_SIZE
typedef BCM53115_A0_SPIDIO3r_t SPIDIO3r_t;
#define SPIDIO3r_CLR BCM53115_A0_SPIDIO3r_CLR
#define SPIDIO3r_SET BCM53115_A0_SPIDIO3r_SET
#define SPIDIO3r_GET BCM53115_A0_SPIDIO3r_GET
#define SPIDIO3r_RESERVED_Rf_GET BCM53115_A0_SPIDIO3r_RESERVED_Rf_GET
#define SPIDIO3r_RESERVED_Rf_SET BCM53115_A0_SPIDIO3r_RESERVED_Rf_SET
#define READ_SPIDIO3r BCM53115_A0_READ_SPIDIO3r
#define WRITE_SPIDIO3r BCM53115_A0_WRITE_SPIDIO3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPIDIO3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPIDIO4
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 4
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Data I/O 4
 *
 ******************************************************************************/
#define BCM53115_A0_SPIDIO4r 0x0000fff4

#define BCM53115_A0_SPIDIO4r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO4.
 *
 */
typedef union BCM53115_A0_SPIDIO4r_s {
	uint32_t v[1];
	uint32_t spidio4[1];
	uint32_t _spidio4;
} BCM53115_A0_SPIDIO4r_t;

#define BCM53115_A0_SPIDIO4r_CLR(r) (r).spidio4[0] = 0
#define BCM53115_A0_SPIDIO4r_SET(r,d) (r).spidio4[0] = d
#define BCM53115_A0_SPIDIO4r_GET(r) (r).spidio4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPIDIO4r_RESERVED_Rf_GET(r) (((r).spidio4[0]) & 0xff)
#define BCM53115_A0_SPIDIO4r_RESERVED_Rf_SET(r,f) (r).spidio4[0]=(((r).spidio4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO4.
 *
 */
#define BCM53115_A0_READ_SPIDIO4r(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPIDIO4r,(r._spidio4),1)
#define BCM53115_A0_WRITE_SPIDIO4r(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPIDIO4r,&(r._spidio4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO4r BCM53115_A0_SPIDIO4r
#define SPIDIO4r_SIZE BCM53115_A0_SPIDIO4r_SIZE
typedef BCM53115_A0_SPIDIO4r_t SPIDIO4r_t;
#define SPIDIO4r_CLR BCM53115_A0_SPIDIO4r_CLR
#define SPIDIO4r_SET BCM53115_A0_SPIDIO4r_SET
#define SPIDIO4r_GET BCM53115_A0_SPIDIO4r_GET
#define SPIDIO4r_RESERVED_Rf_GET BCM53115_A0_SPIDIO4r_RESERVED_Rf_GET
#define SPIDIO4r_RESERVED_Rf_SET BCM53115_A0_SPIDIO4r_RESERVED_Rf_SET
#define READ_SPIDIO4r BCM53115_A0_READ_SPIDIO4r
#define WRITE_SPIDIO4r BCM53115_A0_WRITE_SPIDIO4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPIDIO4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPIDIO5
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 5
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Data I/O 5
 *
 ******************************************************************************/
#define BCM53115_A0_SPIDIO5r 0x0000fff5

#define BCM53115_A0_SPIDIO5r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO5.
 *
 */
typedef union BCM53115_A0_SPIDIO5r_s {
	uint32_t v[1];
	uint32_t spidio5[1];
	uint32_t _spidio5;
} BCM53115_A0_SPIDIO5r_t;

#define BCM53115_A0_SPIDIO5r_CLR(r) (r).spidio5[0] = 0
#define BCM53115_A0_SPIDIO5r_SET(r,d) (r).spidio5[0] = d
#define BCM53115_A0_SPIDIO5r_GET(r) (r).spidio5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPIDIO5r_RESERVED_Rf_GET(r) (((r).spidio5[0]) & 0xff)
#define BCM53115_A0_SPIDIO5r_RESERVED_Rf_SET(r,f) (r).spidio5[0]=(((r).spidio5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO5.
 *
 */
#define BCM53115_A0_READ_SPIDIO5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPIDIO5r,(r._spidio5),1)
#define BCM53115_A0_WRITE_SPIDIO5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPIDIO5r,&(r._spidio5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO5r BCM53115_A0_SPIDIO5r
#define SPIDIO5r_SIZE BCM53115_A0_SPIDIO5r_SIZE
typedef BCM53115_A0_SPIDIO5r_t SPIDIO5r_t;
#define SPIDIO5r_CLR BCM53115_A0_SPIDIO5r_CLR
#define SPIDIO5r_SET BCM53115_A0_SPIDIO5r_SET
#define SPIDIO5r_GET BCM53115_A0_SPIDIO5r_GET
#define SPIDIO5r_RESERVED_Rf_GET BCM53115_A0_SPIDIO5r_RESERVED_Rf_GET
#define SPIDIO5r_RESERVED_Rf_SET BCM53115_A0_SPIDIO5r_RESERVED_Rf_SET
#define READ_SPIDIO5r BCM53115_A0_READ_SPIDIO5r
#define WRITE_SPIDIO5r BCM53115_A0_WRITE_SPIDIO5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPIDIO5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPIDIO6
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 6
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Data I/O 6
 *
 ******************************************************************************/
#define BCM53115_A0_SPIDIO6r 0x0000fff6

#define BCM53115_A0_SPIDIO6r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO6.
 *
 */
typedef union BCM53115_A0_SPIDIO6r_s {
	uint32_t v[1];
	uint32_t spidio6[1];
	uint32_t _spidio6;
} BCM53115_A0_SPIDIO6r_t;

#define BCM53115_A0_SPIDIO6r_CLR(r) (r).spidio6[0] = 0
#define BCM53115_A0_SPIDIO6r_SET(r,d) (r).spidio6[0] = d
#define BCM53115_A0_SPIDIO6r_GET(r) (r).spidio6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPIDIO6r_RESERVED_Rf_GET(r) (((r).spidio6[0]) & 0xff)
#define BCM53115_A0_SPIDIO6r_RESERVED_Rf_SET(r,f) (r).spidio6[0]=(((r).spidio6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO6.
 *
 */
#define BCM53115_A0_READ_SPIDIO6r(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPIDIO6r,(r._spidio6),1)
#define BCM53115_A0_WRITE_SPIDIO6r(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPIDIO6r,&(r._spidio6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO6r BCM53115_A0_SPIDIO6r
#define SPIDIO6r_SIZE BCM53115_A0_SPIDIO6r_SIZE
typedef BCM53115_A0_SPIDIO6r_t SPIDIO6r_t;
#define SPIDIO6r_CLR BCM53115_A0_SPIDIO6r_CLR
#define SPIDIO6r_SET BCM53115_A0_SPIDIO6r_SET
#define SPIDIO6r_GET BCM53115_A0_SPIDIO6r_GET
#define SPIDIO6r_RESERVED_Rf_GET BCM53115_A0_SPIDIO6r_RESERVED_Rf_GET
#define SPIDIO6r_RESERVED_Rf_SET BCM53115_A0_SPIDIO6r_RESERVED_Rf_SET
#define READ_SPIDIO6r BCM53115_A0_READ_SPIDIO6r
#define WRITE_SPIDIO6r BCM53115_A0_WRITE_SPIDIO6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPIDIO6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPIDIO7
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 7
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Data I/O 7
 *
 ******************************************************************************/
#define BCM53115_A0_SPIDIO7r 0x0000fff7

#define BCM53115_A0_SPIDIO7r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO7.
 *
 */
typedef union BCM53115_A0_SPIDIO7r_s {
	uint32_t v[1];
	uint32_t spidio7[1];
	uint32_t _spidio7;
} BCM53115_A0_SPIDIO7r_t;

#define BCM53115_A0_SPIDIO7r_CLR(r) (r).spidio7[0] = 0
#define BCM53115_A0_SPIDIO7r_SET(r,d) (r).spidio7[0] = d
#define BCM53115_A0_SPIDIO7r_GET(r) (r).spidio7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPIDIO7r_RESERVED_Rf_GET(r) (((r).spidio7[0]) & 0xff)
#define BCM53115_A0_SPIDIO7r_RESERVED_Rf_SET(r,f) (r).spidio7[0]=(((r).spidio7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO7.
 *
 */
#define BCM53115_A0_READ_SPIDIO7r(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPIDIO7r,(r._spidio7),1)
#define BCM53115_A0_WRITE_SPIDIO7r(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPIDIO7r,&(r._spidio7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO7r BCM53115_A0_SPIDIO7r
#define SPIDIO7r_SIZE BCM53115_A0_SPIDIO7r_SIZE
typedef BCM53115_A0_SPIDIO7r_t SPIDIO7r_t;
#define SPIDIO7r_CLR BCM53115_A0_SPIDIO7r_CLR
#define SPIDIO7r_SET BCM53115_A0_SPIDIO7r_SET
#define SPIDIO7r_GET BCM53115_A0_SPIDIO7r_GET
#define SPIDIO7r_RESERVED_Rf_GET BCM53115_A0_SPIDIO7r_RESERVED_Rf_GET
#define SPIDIO7r_RESERVED_Rf_SET BCM53115_A0_SPIDIO7r_RESERVED_Rf_SET
#define READ_SPIDIO7r BCM53115_A0_READ_SPIDIO7r
#define WRITE_SPIDIO7r BCM53115_A0_WRITE_SPIDIO7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPIDIO7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPISTS
 * BLOCKS:   SYS
 * DESC:     SPI Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_R       SPI Status Register
 *
 ******************************************************************************/
#define BCM53115_A0_SPISTSr 0x0000fffe

#define BCM53115_A0_SPISTSr_SIZE 1

/*
 * This structure should be used to declare and program SPISTS.
 *
 */
typedef union BCM53115_A0_SPISTSr_s {
	uint32_t v[1];
	uint32_t spists[1];
	uint32_t _spists;
} BCM53115_A0_SPISTSr_t;

#define BCM53115_A0_SPISTSr_CLR(r) (r).spists[0] = 0
#define BCM53115_A0_SPISTSr_SET(r,d) (r).spists[0] = d
#define BCM53115_A0_SPISTSr_GET(r) (r).spists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPISTSr_RESERVED_Rf_GET(r) (((r).spists[0]) & 0xff)
#define BCM53115_A0_SPISTSr_RESERVED_Rf_SET(r,f) (r).spists[0]=(((r).spists[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPISTS.
 *
 */
#define BCM53115_A0_READ_SPISTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPISTSr,(r._spists),1)
#define BCM53115_A0_WRITE_SPISTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPISTSr,&(r._spists),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPISTSr BCM53115_A0_SPISTSr
#define SPISTSr_SIZE BCM53115_A0_SPISTSr_SIZE
typedef BCM53115_A0_SPISTSr_t SPISTSr_t;
#define SPISTSr_CLR BCM53115_A0_SPISTSr_CLR
#define SPISTSr_SET BCM53115_A0_SPISTSr_SET
#define SPISTSr_GET BCM53115_A0_SPISTSr_GET
#define SPISTSr_RESERVED_Rf_GET BCM53115_A0_SPISTSr_RESERVED_Rf_GET
#define SPISTSr_RESERVED_Rf_SET BCM53115_A0_SPISTSr_RESERVED_Rf_SET
#define READ_SPISTSr BCM53115_A0_READ_SPISTSr
#define WRITE_SPISTSr BCM53115_A0_WRITE_SPISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPTAGT
 * BLOCKS:   SYS
 * DESC:     Aging Time Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_TIME         Specifies the aging time in seconds for dynamicallylearned address. Maximum age time is 1,048,575 s. Note that while 802.1D specifies a range of values of 10 - 1,000,000 s, this register does not enforce this range. Setting the AGE_TIME to zero disables the aging process.
 *     AGE_CHANGE_EN    Set 1 to Change Aging Timer by AGE_TIME[19:0].
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_SPTAGTr 0x00000206

#define BCM53115_A0_SPTAGTr_SIZE 4

/*
 * This structure should be used to declare and program SPTAGT.
 *
 */
typedef union BCM53115_A0_SPTAGTr_s {
	uint32_t v[1];
	uint32_t sptagt[1];
	uint32_t _sptagt;
} BCM53115_A0_SPTAGTr_t;

#define BCM53115_A0_SPTAGTr_CLR(r) (r).sptagt[0] = 0
#define BCM53115_A0_SPTAGTr_SET(r,d) (r).sptagt[0] = d
#define BCM53115_A0_SPTAGTr_GET(r) (r).sptagt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPTAGTr_AGE_TIMEf_GET(r) (((r).sptagt[0]) & 0xfffff)
#define BCM53115_A0_SPTAGTr_AGE_TIMEf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM53115_A0_SPTAGTr_AGE_CHANGE_ENf_GET(r) ((((r).sptagt[0]) >> 20) & 0x1)
#define BCM53115_A0_SPTAGTr_AGE_CHANGE_ENf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53115_A0_SPTAGTr_RESERVED_Rf_GET(r) ((((r).sptagt[0]) >> 21) & 0x7ff)
#define BCM53115_A0_SPTAGTr_RESERVED_Rf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access SPTAGT.
 *
 */
#define BCM53115_A0_READ_SPTAGTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPTAGTr,(r._sptagt),4)
#define BCM53115_A0_WRITE_SPTAGTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPTAGTr,&(r._sptagt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPTAGTr BCM53115_A0_SPTAGTr
#define SPTAGTr_SIZE BCM53115_A0_SPTAGTr_SIZE
typedef BCM53115_A0_SPTAGTr_t SPTAGTr_t;
#define SPTAGTr_CLR BCM53115_A0_SPTAGTr_CLR
#define SPTAGTr_SET BCM53115_A0_SPTAGTr_SET
#define SPTAGTr_GET BCM53115_A0_SPTAGTr_GET
#define SPTAGTr_AGE_TIMEf_GET BCM53115_A0_SPTAGTr_AGE_TIMEf_GET
#define SPTAGTr_AGE_TIMEf_SET BCM53115_A0_SPTAGTr_AGE_TIMEf_SET
#define SPTAGTr_AGE_CHANGE_ENf_GET BCM53115_A0_SPTAGTr_AGE_CHANGE_ENf_GET
#define SPTAGTr_AGE_CHANGE_ENf_SET BCM53115_A0_SPTAGTr_AGE_CHANGE_ENf_SET
#define SPTAGTr_RESERVED_Rf_GET BCM53115_A0_SPTAGTr_RESERVED_Rf_GET
#define SPTAGTr_RESERVED_Rf_SET BCM53115_A0_SPTAGTr_RESERVED_Rf_SET
#define READ_SPTAGTr BCM53115_A0_READ_SPTAGTr
#define WRITE_SPTAGTr BCM53115_A0_WRITE_SPTAGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPTAGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SPT_MULTI_ADDR_BPS_CTRL
 * BLOCKS:   SYS
 * DESC:     STP Multiport Address Bypass Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MPORT0_BYPASS_SPT 1'b0: The MPORT_ADD0 will not be checked by SPT Status1'b1: The MPORT_ADD0 will  be checked by SPT Status
 *     EN_MPORT1_BYPASS_SPT 1'b0: The MPORT_ADD1 will not be checked by SPT Status1'b1: The MPORT_ADD1 will  be checked by SPT Status
 *     EN_MPORT2_BYPASS_SPT 1'b0: The MPORT_ADD2 will not be checked by SPT Status1'b1: The MPORT_ADD2 will  be checked by SPT Status
 *     EN_MPORT3_BYPASS_SPT 1'b0: The MPORT_ADD3 will not be checked by SPT Status1'b1: The MPORT_ADD3 will  be checked by SPT Status
 *     EN_MPORT4_BYPASS_SPT 1'b0: The MPORT_ADD4 will not be checked by SPT Status1'b1: The MPORT_ADD4 will  be checked by SPT Status
 *     EN_MPORT5_BYPASS_SPT 1'b0: The MPORT_ADD5 will not be checked by SPT Status1'b1: The MPORT_ADD5 will  be checked by SPT Status
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr 0x00004350

#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program SPT_MULTI_ADDR_BPS_CTRL.
 *
 */
typedef union BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_s {
	uint32_t v[1];
	uint32_t spt_multi_addr_bps_ctrl[1];
	uint32_t _spt_multi_addr_bps_ctrl;
} BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_t;

#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_CLR(r) (r).spt_multi_addr_bps_ctrl[0] = 0
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_SET(r,d) (r).spt_multi_addr_bps_ctrl[0] = d
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_GET(r) (r).spt_multi_addr_bps_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET(r) (((r).spt_multi_addr_bps_ctrl[0]) & 0x1)
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 3) & 0x1)
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 4) & 0x1)
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 5) & 0x1)
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVED_Rf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 6) & 0x3ff)
#define BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVED_Rf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access SPT_MULTI_ADDR_BPS_CTRL.
 *
 */
#define BCM53115_A0_READ_SPT_MULTI_ADDR_BPS_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr,(r._spt_multi_addr_bps_ctrl),2)
#define BCM53115_A0_WRITE_SPT_MULTI_ADDR_BPS_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr,&(r._spt_multi_addr_bps_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPT_MULTI_ADDR_BPS_CTRLr BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr
#define SPT_MULTI_ADDR_BPS_CTRLr_SIZE BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_SIZE
typedef BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_t SPT_MULTI_ADDR_BPS_CTRLr_t;
#define SPT_MULTI_ADDR_BPS_CTRLr_CLR BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_CLR
#define SPT_MULTI_ADDR_BPS_CTRLr_SET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_GET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_RESERVED_Rf_GET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVED_Rf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_RESERVED_Rf_SET BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVED_Rf_SET
#define READ_SPT_MULTI_ADDR_BPS_CTRLr BCM53115_A0_READ_SPT_MULTI_ADDR_BPS_CTRLr
#define WRITE_SPT_MULTI_ADDR_BPS_CTRLr BCM53115_A0_WRITE_SPT_MULTI_ADDR_BPS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SPT_MULTI_ADDR_BPS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SRCADRCHG
 * BLOCKS:   SYS
 * DESC:     Source Address Change Register
 * SIZE:     16
 * FIELDS:
 *     SRC_ADDR_CHANGE  Source Address Change.9 bit field indicating that the value loaded into the Last Source Address register was not the same 48-bit value as the previous value. A 1 value indicates a dedicated link degment, a value greater than 1 generally indicates a mixing (repeatered) segment. Upon change of SA, a bit remains set until cleared by a read operation.0 = Source Address Constant1 = Source Address Changed
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_SRCADRCHGr 0x0000010e

#define BCM53115_A0_SRCADRCHGr_SIZE 2

/*
 * This structure should be used to declare and program SRCADRCHG.
 *
 */
typedef union BCM53115_A0_SRCADRCHGr_s {
	uint32_t v[1];
	uint32_t srcadrchg[1];
	uint32_t _srcadrchg;
} BCM53115_A0_SRCADRCHGr_t;

#define BCM53115_A0_SRCADRCHGr_CLR(r) (r).srcadrchg[0] = 0
#define BCM53115_A0_SRCADRCHGr_SET(r,d) (r).srcadrchg[0] = d
#define BCM53115_A0_SRCADRCHGr_GET(r) (r).srcadrchg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET(r) (((r).srcadrchg[0]) & 0x1ff)
#define BCM53115_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_SRCADRCHGr_RESERVED_Rf_GET(r) ((((r).srcadrchg[0]) >> 9) & 0x7f)
#define BCM53115_A0_SRCADRCHGr_RESERVED_Rf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SRCADRCHG.
 *
 */
#define BCM53115_A0_READ_SRCADRCHGr(u,r) cdk_robo_reg_read(u,BCM53115_A0_SRCADRCHGr,(r._srcadrchg),2)
#define BCM53115_A0_WRITE_SRCADRCHGr(u,r) cdk_robo_reg_write(u,BCM53115_A0_SRCADRCHGr,&(r._srcadrchg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRCADRCHGr BCM53115_A0_SRCADRCHGr
#define SRCADRCHGr_SIZE BCM53115_A0_SRCADRCHGr_SIZE
typedef BCM53115_A0_SRCADRCHGr_t SRCADRCHGr_t;
#define SRCADRCHGr_CLR BCM53115_A0_SRCADRCHGr_CLR
#define SRCADRCHGr_SET BCM53115_A0_SRCADRCHGr_SET
#define SRCADRCHGr_GET BCM53115_A0_SRCADRCHGr_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_GET BCM53115_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_SET BCM53115_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET
#define SRCADRCHGr_RESERVED_Rf_GET BCM53115_A0_SRCADRCHGr_RESERVED_Rf_GET
#define SRCADRCHGr_RESERVED_Rf_SET BCM53115_A0_SRCADRCHGr_RESERVED_Rf_SET
#define READ_SRCADRCHGr BCM53115_A0_READ_SRCADRCHGr
#define WRITE_SRCADRCHGr BCM53115_A0_WRITE_SRCADRCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SRCADRCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  STRAP_VALUE
 * BLOCKS:   SYS
 * DESC:     Strap Value Register
 * SIZE:     48
 * FIELDS:
 *     BC_SUPP_EN       bc_supp_en_strap,
 *     BIST_CLRMEM      bist_clrmem_sel,
 *     SYSFREQ          clock freq[1:0],
 *     CPU_EPROM        cpu_eprom_sel,
 *     EN_CLK25_OUT     enable clk25 outout.
 *     EN_CLK50_OUT     enable clk50 outout.
 *     DIS_IMP          
 *     ENEXTCLK         enextclk.
 *     EN_LPDET         
 *     ENFDXFLOW        enfdxflow,
 *     ENHDXFLOW        enhdxflow,
 *     EEPROM_TYPE      eprom_type[1:0],
 *     IMP_TXC_DELAY    
 *     IMP_RXC_DELAY    
 *     HW_FWDG_EN       hw_fwdg_en,
 *     IMP_MODE         IMP mode,
 *     LEDMODE          ledmode[2:0],
 *     LP_IMP_SEL       
 *     MII_DUMP_FWDG    
 *     SKIP_SRAMBIST    skip_srambist,
 *     WD_CLR_EN        wd_clr_en,
 *     GMII_MODE        
 *     GMII_CTRL        
 *     GMII_TXC_DELAY   
 *     GMII_RXC_DELAY   
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_STRAP_VALUEr 0x00000170

#define BCM53115_A0_STRAP_VALUEr_SIZE 6

/*
 * This structure should be used to declare and program STRAP_VALUE.
 *
 */
typedef union BCM53115_A0_STRAP_VALUEr_s {
	uint32_t v[2];
	uint32_t strap_value[2];
	uint32_t _strap_value;
} BCM53115_A0_STRAP_VALUEr_t;

#define BCM53115_A0_STRAP_VALUEr_CLR(r) CDK_MEMSET(&((r)._strap_value), 0, sizeof(BCM53115_A0_STRAP_VALUEr_t))
#define BCM53115_A0_STRAP_VALUEr_SET(r,i,d) (r).strap_value[i] = d
#define BCM53115_A0_STRAP_VALUEr_GET(r,i) (r).strap_value[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_STRAP_VALUEr_BC_SUPP_ENf_GET(r) (((r).strap_value[0]) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_BC_SUPP_ENf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_STRAP_VALUEr_BIST_CLRMEMf_GET(r) ((((r).strap_value[0]) >> 1) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_BIST_CLRMEMf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_STRAP_VALUEr_SYSFREQf_GET(r) ((((r).strap_value[0]) >> 2) & 0x3)
#define BCM53115_A0_STRAP_VALUEr_SYSFREQf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_STRAP_VALUEr_CPU_EPROMf_GET(r) ((((r).strap_value[0]) >> 4) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_CPU_EPROMf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_STRAP_VALUEr_EN_CLK25_OUTf_GET(r) ((((r).strap_value[0]) >> 5) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_EN_CLK25_OUTf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_STRAP_VALUEr_EN_CLK50_OUTf_GET(r) ((((r).strap_value[0]) >> 6) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_EN_CLK50_OUTf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_STRAP_VALUEr_DIS_IMPf_GET(r) ((((r).strap_value[0]) >> 7) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_DIS_IMPf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_STRAP_VALUEr_ENEXTCLKf_GET(r) ((((r).strap_value[0]) >> 8) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_ENEXTCLKf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_STRAP_VALUEr_EN_LPDETf_GET(r) ((((r).strap_value[0]) >> 9) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_EN_LPDETf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_STRAP_VALUEr_ENFDXFLOWf_GET(r) ((((r).strap_value[0]) >> 10) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_ENFDXFLOWf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_STRAP_VALUEr_ENHDXFLOWf_GET(r) ((((r).strap_value[0]) >> 11) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_ENHDXFLOWf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_STRAP_VALUEr_EEPROM_TYPEf_GET(r) ((((r).strap_value[0]) >> 12) & 0x3)
#define BCM53115_A0_STRAP_VALUEr_EEPROM_TYPEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53115_A0_STRAP_VALUEr_IMP_TXC_DELAYf_GET(r) ((((r).strap_value[0]) >> 14) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_IMP_TXC_DELAYf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53115_A0_STRAP_VALUEr_IMP_RXC_DELAYf_GET(r) ((((r).strap_value[0]) >> 15) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_IMP_RXC_DELAYf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_STRAP_VALUEr_HW_FWDG_ENf_GET(r) ((((r).strap_value[0]) >> 16) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_HW_FWDG_ENf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_STRAP_VALUEr_IMP_MODEf_GET(r) ((((r).strap_value[0]) >> 17) & 0x3)
#define BCM53115_A0_STRAP_VALUEr_IMP_MODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM53115_A0_STRAP_VALUEr_LEDMODEf_GET(r) ((((r).strap_value[0]) >> 19) & 0x3)
#define BCM53115_A0_STRAP_VALUEr_LEDMODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53115_A0_STRAP_VALUEr_LP_IMP_SELf_GET(r) ((((r).strap_value[0]) >> 21) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_LP_IMP_SELf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53115_A0_STRAP_VALUEr_MII_DUMP_FWDGf_GET(r) ((((r).strap_value[0]) >> 22) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_MII_DUMP_FWDGf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53115_A0_STRAP_VALUEr_SKIP_SRAMBISTf_GET(r) ((((r).strap_value[0]) >> 23) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_SKIP_SRAMBISTf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53115_A0_STRAP_VALUEr_WD_CLR_ENf_GET(r) ((((r).strap_value[0]) >> 24) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_WD_CLR_ENf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53115_A0_STRAP_VALUEr_GMII_MODEf_GET(r) ((((r).strap_value[0]) >> 25) & 0x3)
#define BCM53115_A0_STRAP_VALUEr_GMII_MODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM53115_A0_STRAP_VALUEr_GMII_CTRLf_GET(r) ((((r).strap_value[0]) >> 27) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_GMII_CTRLf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53115_A0_STRAP_VALUEr_GMII_TXC_DELAYf_GET(r) ((((r).strap_value[0]) >> 28) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_GMII_TXC_DELAYf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53115_A0_STRAP_VALUEr_GMII_RXC_DELAYf_GET(r) ((((r).strap_value[0]) >> 29) & 0x1)
#define BCM53115_A0_STRAP_VALUEr_GMII_RXC_DELAYf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53115_A0_STRAP_VALUEr_RESERVED_Rf_GET(r) cdk_field32_get((r).strap_value,30,47)
#define BCM53115_A0_STRAP_VALUEr_RESERVED_Rf_SET(r,f) cdk_field32_set((r).strap_value,30,47,f)

/*
 * These macros can be used to access STRAP_VALUE.
 *
 */
#define BCM53115_A0_READ_STRAP_VALUEr(u,r) cdk_robo_reg_read(u,BCM53115_A0_STRAP_VALUEr,(r._strap_value),6)
#define BCM53115_A0_WRITE_STRAP_VALUEr(u,r) cdk_robo_reg_write(u,BCM53115_A0_STRAP_VALUEr,&(r._strap_value),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STRAP_VALUEr BCM53115_A0_STRAP_VALUEr
#define STRAP_VALUEr_SIZE BCM53115_A0_STRAP_VALUEr_SIZE
typedef BCM53115_A0_STRAP_VALUEr_t STRAP_VALUEr_t;
#define STRAP_VALUEr_CLR BCM53115_A0_STRAP_VALUEr_CLR
#define STRAP_VALUEr_SET BCM53115_A0_STRAP_VALUEr_SET
#define STRAP_VALUEr_GET BCM53115_A0_STRAP_VALUEr_GET
#define STRAP_VALUEr_BC_SUPP_ENf_GET BCM53115_A0_STRAP_VALUEr_BC_SUPP_ENf_GET
#define STRAP_VALUEr_BC_SUPP_ENf_SET BCM53115_A0_STRAP_VALUEr_BC_SUPP_ENf_SET
#define STRAP_VALUEr_BIST_CLRMEMf_GET BCM53115_A0_STRAP_VALUEr_BIST_CLRMEMf_GET
#define STRAP_VALUEr_BIST_CLRMEMf_SET BCM53115_A0_STRAP_VALUEr_BIST_CLRMEMf_SET
#define STRAP_VALUEr_SYSFREQf_GET BCM53115_A0_STRAP_VALUEr_SYSFREQf_GET
#define STRAP_VALUEr_SYSFREQf_SET BCM53115_A0_STRAP_VALUEr_SYSFREQf_SET
#define STRAP_VALUEr_CPU_EPROMf_GET BCM53115_A0_STRAP_VALUEr_CPU_EPROMf_GET
#define STRAP_VALUEr_CPU_EPROMf_SET BCM53115_A0_STRAP_VALUEr_CPU_EPROMf_SET
#define STRAP_VALUEr_EN_CLK25_OUTf_GET BCM53115_A0_STRAP_VALUEr_EN_CLK25_OUTf_GET
#define STRAP_VALUEr_EN_CLK25_OUTf_SET BCM53115_A0_STRAP_VALUEr_EN_CLK25_OUTf_SET
#define STRAP_VALUEr_EN_CLK50_OUTf_GET BCM53115_A0_STRAP_VALUEr_EN_CLK50_OUTf_GET
#define STRAP_VALUEr_EN_CLK50_OUTf_SET BCM53115_A0_STRAP_VALUEr_EN_CLK50_OUTf_SET
#define STRAP_VALUEr_DIS_IMPf_GET BCM53115_A0_STRAP_VALUEr_DIS_IMPf_GET
#define STRAP_VALUEr_DIS_IMPf_SET BCM53115_A0_STRAP_VALUEr_DIS_IMPf_SET
#define STRAP_VALUEr_ENEXTCLKf_GET BCM53115_A0_STRAP_VALUEr_ENEXTCLKf_GET
#define STRAP_VALUEr_ENEXTCLKf_SET BCM53115_A0_STRAP_VALUEr_ENEXTCLKf_SET
#define STRAP_VALUEr_EN_LPDETf_GET BCM53115_A0_STRAP_VALUEr_EN_LPDETf_GET
#define STRAP_VALUEr_EN_LPDETf_SET BCM53115_A0_STRAP_VALUEr_EN_LPDETf_SET
#define STRAP_VALUEr_ENFDXFLOWf_GET BCM53115_A0_STRAP_VALUEr_ENFDXFLOWf_GET
#define STRAP_VALUEr_ENFDXFLOWf_SET BCM53115_A0_STRAP_VALUEr_ENFDXFLOWf_SET
#define STRAP_VALUEr_ENHDXFLOWf_GET BCM53115_A0_STRAP_VALUEr_ENHDXFLOWf_GET
#define STRAP_VALUEr_ENHDXFLOWf_SET BCM53115_A0_STRAP_VALUEr_ENHDXFLOWf_SET
#define STRAP_VALUEr_EEPROM_TYPEf_GET BCM53115_A0_STRAP_VALUEr_EEPROM_TYPEf_GET
#define STRAP_VALUEr_EEPROM_TYPEf_SET BCM53115_A0_STRAP_VALUEr_EEPROM_TYPEf_SET
#define STRAP_VALUEr_IMP_TXC_DELAYf_GET BCM53115_A0_STRAP_VALUEr_IMP_TXC_DELAYf_GET
#define STRAP_VALUEr_IMP_TXC_DELAYf_SET BCM53115_A0_STRAP_VALUEr_IMP_TXC_DELAYf_SET
#define STRAP_VALUEr_IMP_RXC_DELAYf_GET BCM53115_A0_STRAP_VALUEr_IMP_RXC_DELAYf_GET
#define STRAP_VALUEr_IMP_RXC_DELAYf_SET BCM53115_A0_STRAP_VALUEr_IMP_RXC_DELAYf_SET
#define STRAP_VALUEr_HW_FWDG_ENf_GET BCM53115_A0_STRAP_VALUEr_HW_FWDG_ENf_GET
#define STRAP_VALUEr_HW_FWDG_ENf_SET BCM53115_A0_STRAP_VALUEr_HW_FWDG_ENf_SET
#define STRAP_VALUEr_IMP_MODEf_GET BCM53115_A0_STRAP_VALUEr_IMP_MODEf_GET
#define STRAP_VALUEr_IMP_MODEf_SET BCM53115_A0_STRAP_VALUEr_IMP_MODEf_SET
#define STRAP_VALUEr_LEDMODEf_GET BCM53115_A0_STRAP_VALUEr_LEDMODEf_GET
#define STRAP_VALUEr_LEDMODEf_SET BCM53115_A0_STRAP_VALUEr_LEDMODEf_SET
#define STRAP_VALUEr_LP_IMP_SELf_GET BCM53115_A0_STRAP_VALUEr_LP_IMP_SELf_GET
#define STRAP_VALUEr_LP_IMP_SELf_SET BCM53115_A0_STRAP_VALUEr_LP_IMP_SELf_SET
#define STRAP_VALUEr_MII_DUMP_FWDGf_GET BCM53115_A0_STRAP_VALUEr_MII_DUMP_FWDGf_GET
#define STRAP_VALUEr_MII_DUMP_FWDGf_SET BCM53115_A0_STRAP_VALUEr_MII_DUMP_FWDGf_SET
#define STRAP_VALUEr_SKIP_SRAMBISTf_GET BCM53115_A0_STRAP_VALUEr_SKIP_SRAMBISTf_GET
#define STRAP_VALUEr_SKIP_SRAMBISTf_SET BCM53115_A0_STRAP_VALUEr_SKIP_SRAMBISTf_SET
#define STRAP_VALUEr_WD_CLR_ENf_GET BCM53115_A0_STRAP_VALUEr_WD_CLR_ENf_GET
#define STRAP_VALUEr_WD_CLR_ENf_SET BCM53115_A0_STRAP_VALUEr_WD_CLR_ENf_SET
#define STRAP_VALUEr_GMII_MODEf_GET BCM53115_A0_STRAP_VALUEr_GMII_MODEf_GET
#define STRAP_VALUEr_GMII_MODEf_SET BCM53115_A0_STRAP_VALUEr_GMII_MODEf_SET
#define STRAP_VALUEr_GMII_CTRLf_GET BCM53115_A0_STRAP_VALUEr_GMII_CTRLf_GET
#define STRAP_VALUEr_GMII_CTRLf_SET BCM53115_A0_STRAP_VALUEr_GMII_CTRLf_SET
#define STRAP_VALUEr_GMII_TXC_DELAYf_GET BCM53115_A0_STRAP_VALUEr_GMII_TXC_DELAYf_GET
#define STRAP_VALUEr_GMII_TXC_DELAYf_SET BCM53115_A0_STRAP_VALUEr_GMII_TXC_DELAYf_SET
#define STRAP_VALUEr_GMII_RXC_DELAYf_GET BCM53115_A0_STRAP_VALUEr_GMII_RXC_DELAYf_GET
#define STRAP_VALUEr_GMII_RXC_DELAYf_SET BCM53115_A0_STRAP_VALUEr_GMII_RXC_DELAYf_SET
#define STRAP_VALUEr_RESERVED_Rf_GET BCM53115_A0_STRAP_VALUEr_RESERVED_Rf_GET
#define STRAP_VALUEr_RESERVED_Rf_SET BCM53115_A0_STRAP_VALUEr_RESERVED_Rf_SET
#define READ_STRAP_VALUEr BCM53115_A0_READ_STRAP_VALUEr
#define WRITE_STRAP_VALUEr BCM53115_A0_WRITE_STRAP_VALUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_STRAP_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  STS_OVERRIDE_GMIIP
 * BLOCKS:   GPIC0
 * DESC:     Port N GMII Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED_R          Software Port Speed setting2'b10 : 1000M2'b01: 100M2'b00 : 10M
 *     RXFLOW_CNTL      Software Rx Flow Control Enable
 *     TXFLOW_CNTL      Software Tx Flow Control Enable
 *     SW_OVERRIDE_R    CPU set software Override bit to 1 to make bit [5:0] affected.PHY scan register will be override.
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_STS_OVERRIDE_GMIIPr 0x00000058

#define BCM53115_A0_STS_OVERRIDE_GMIIPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_GMIIP.
 *
 */
typedef union BCM53115_A0_STS_OVERRIDE_GMIIPr_s {
	uint32_t v[1];
	uint32_t sts_override_gmiip[1];
	uint32_t _sts_override_gmiip;
} BCM53115_A0_STS_OVERRIDE_GMIIPr_t;

#define BCM53115_A0_STS_OVERRIDE_GMIIPr_CLR(r) (r).sts_override_gmiip[0] = 0
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_SET(r,d) (r).sts_override_gmiip[0] = d
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_GET(r) (r).sts_override_gmiip[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_GET(r) (((r).sts_override_gmiip[0]) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET(r) ((((r).sts_override_gmiip[0]) >> 1) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_SPEED_Rf_GET(r) ((((r).sts_override_gmiip[0]) >> 2) & 0x3)
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_SPEED_Rf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_gmiip[0]) >> 4) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_gmiip[0]) >> 5) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDE_Rf_GET(r) ((((r).sts_override_gmiip[0]) >> 6) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDE_Rf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_RESERVED_1Rf_GET(r) ((((r).sts_override_gmiip[0]) >> 7) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_GMIIPr_RESERVED_1Rf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_GMIIP.
 *
 */
#define BCM53115_A0_READ_STS_OVERRIDE_GMIIPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_STS_OVERRIDE_GMIIPr,(r._sts_override_gmiip),1)
#define BCM53115_A0_WRITE_STS_OVERRIDE_GMIIPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_STS_OVERRIDE_GMIIPr,&(r._sts_override_gmiip),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_GMIIPr BCM53115_A0_STS_OVERRIDE_GMIIPr
#define STS_OVERRIDE_GMIIPr_SIZE BCM53115_A0_STS_OVERRIDE_GMIIPr_SIZE
typedef BCM53115_A0_STS_OVERRIDE_GMIIPr_t STS_OVERRIDE_GMIIPr_t;
#define STS_OVERRIDE_GMIIPr_CLR BCM53115_A0_STS_OVERRIDE_GMIIPr_CLR
#define STS_OVERRIDE_GMIIPr_SET BCM53115_A0_STS_OVERRIDE_GMIIPr_SET
#define STS_OVERRIDE_GMIIPr_GET BCM53115_A0_STS_OVERRIDE_GMIIPr_GET
#define STS_OVERRIDE_GMIIPr_LINK_STSf_GET BCM53115_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_GET
#define STS_OVERRIDE_GMIIPr_LINK_STSf_SET BCM53115_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_SET
#define STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET BCM53115_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET BCM53115_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_GMIIPr_SPEED_Rf_GET BCM53115_A0_STS_OVERRIDE_GMIIPr_SPEED_Rf_GET
#define STS_OVERRIDE_GMIIPr_SPEED_Rf_SET BCM53115_A0_STS_OVERRIDE_GMIIPr_SPEED_Rf_SET
#define STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET BCM53115_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET BCM53115_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET BCM53115_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET BCM53115_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_GMIIPr_SW_OVERRIDE_Rf_GET BCM53115_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDE_Rf_GET
#define STS_OVERRIDE_GMIIPr_SW_OVERRIDE_Rf_SET BCM53115_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDE_Rf_SET
#define STS_OVERRIDE_GMIIPr_RESERVED_1Rf_GET BCM53115_A0_STS_OVERRIDE_GMIIPr_RESERVED_1Rf_GET
#define STS_OVERRIDE_GMIIPr_RESERVED_1Rf_SET BCM53115_A0_STS_OVERRIDE_GMIIPr_RESERVED_1Rf_SET
#define READ_STS_OVERRIDE_GMIIPr BCM53115_A0_READ_STS_OVERRIDE_GMIIPr
#define WRITE_STS_OVERRIDE_GMIIPr BCM53115_A0_WRITE_STS_OVERRIDE_GMIIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_STS_OVERRIDE_GMIIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  STS_OVERRIDE_IMP
 * BLOCKS:   CPIC
 * DESC:     IMP Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         Link Status0: Link fail1: Link pass
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED_R          Speed00: 10 Mbps01: 100 Mbps10: 1000Mbps
 *     RXFLOW_CNTL      Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     TX_FLOW_CNTL     Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     RESERVED_1R      Reserved
 *     MII_SW_OR        MII Software Override0: Use MII hardware pin status1: Use contents of this register
 *
 ******************************************************************************/
#define BCM53115_A0_STS_OVERRIDE_IMPr 0x0000000e

#define BCM53115_A0_STS_OVERRIDE_IMPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_IMP.
 *
 */
typedef union BCM53115_A0_STS_OVERRIDE_IMPr_s {
	uint32_t v[1];
	uint32_t sts_override_imp[1];
	uint32_t _sts_override_imp;
} BCM53115_A0_STS_OVERRIDE_IMPr_t;

#define BCM53115_A0_STS_OVERRIDE_IMPr_CLR(r) (r).sts_override_imp[0] = 0
#define BCM53115_A0_STS_OVERRIDE_IMPr_SET(r,d) (r).sts_override_imp[0] = d
#define BCM53115_A0_STS_OVERRIDE_IMPr_GET(r) (r).sts_override_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET(r) (((r).sts_override_imp[0]) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET(r) ((((r).sts_override_imp[0]) >> 1) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_STS_OVERRIDE_IMPr_SPEED_Rf_GET(r) ((((r).sts_override_imp[0]) >> 2) & 0x3)
#define BCM53115_A0_STS_OVERRIDE_IMPr_SPEED_Rf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 4) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 5) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_STS_OVERRIDE_IMPr_RESERVED_1Rf_GET(r) ((((r).sts_override_imp[0]) >> 6) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_IMPr_RESERVED_1Rf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET(r) ((((r).sts_override_imp[0]) >> 7) & 0x1)
#define BCM53115_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_IMP.
 *
 */
#define BCM53115_A0_READ_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_STS_OVERRIDE_IMPr,(r._sts_override_imp),1)
#define BCM53115_A0_WRITE_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_STS_OVERRIDE_IMPr,&(r._sts_override_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_IMPr BCM53115_A0_STS_OVERRIDE_IMPr
#define STS_OVERRIDE_IMPr_SIZE BCM53115_A0_STS_OVERRIDE_IMPr_SIZE
typedef BCM53115_A0_STS_OVERRIDE_IMPr_t STS_OVERRIDE_IMPr_t;
#define STS_OVERRIDE_IMPr_CLR BCM53115_A0_STS_OVERRIDE_IMPr_CLR
#define STS_OVERRIDE_IMPr_SET BCM53115_A0_STS_OVERRIDE_IMPr_SET
#define STS_OVERRIDE_IMPr_GET BCM53115_A0_STS_OVERRIDE_IMPr_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_GET BCM53115_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_SET BCM53115_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_GET BCM53115_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_SET BCM53115_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_IMPr_SPEED_Rf_GET BCM53115_A0_STS_OVERRIDE_IMPr_SPEED_Rf_GET
#define STS_OVERRIDE_IMPr_SPEED_Rf_SET BCM53115_A0_STS_OVERRIDE_IMPr_SPEED_Rf_SET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET BCM53115_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET BCM53115_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_GET BCM53115_A0_STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_SET BCM53115_A0_STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_RESERVED_1Rf_GET BCM53115_A0_STS_OVERRIDE_IMPr_RESERVED_1Rf_GET
#define STS_OVERRIDE_IMPr_RESERVED_1Rf_SET BCM53115_A0_STS_OVERRIDE_IMPr_RESERVED_1Rf_SET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_GET BCM53115_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_SET BCM53115_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET
#define READ_STS_OVERRIDE_IMPr BCM53115_A0_READ_STS_OVERRIDE_IMPr
#define WRITE_STS_OVERRIDE_IMPr BCM53115_A0_WRITE_STS_OVERRIDE_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_STS_OVERRIDE_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  SWMODE
 * BLOCKS:   SYS
 * DESC:     Switch Mode Register
 * SIZE:     8
 * FIELDS:
 *     SW_FWDG_MODE     Software Forwarding Mode.Strapped from the inverse of the HW_FWDG_EN pin at power-on. Can be overwritten subsequently.0 = Unmanaged Mode.1 = Managed ModeThe ARL treats Reserved Multicast addresses differently dependent on this selection. See Table 3 for a precise definition.
 *     SW_FWDG_EN       Software Forwarding EnableSW_FWDG_EN=1: Frame forwarding is enabled.SW_FWDG_EN=0: Frame forwarding is disabled.Read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently. For managed switch implementations (5388 mode), the switch should be configured to disable forwarding on power-on, to allow the processor to configure the internal address table and other parameters, before frame forwarding is enabled.
 *     PTRY_LMT_DIS     Retry Limit DisableWhen set, disables the Retry limit on all MAC ports (10/100BASE-T and MII ports). Causes a MAC port in half duplex operation, to continue to retry the same packet regardless of the number of collision attempts.
 *     FAST_TXDESC_RERURN Controls which algorithm is used to release packets when a link goes down.
 *     NOBLKCD          Always not to blockcarrier detected signal.1b'b1: Not to block. txport will always defer to crs.1b'b0: Block CD
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_SWMODEr 0x0000000b

#define BCM53115_A0_SWMODEr_SIZE 1

/*
 * This structure should be used to declare and program SWMODE.
 *
 */
typedef union BCM53115_A0_SWMODEr_s {
	uint32_t v[1];
	uint32_t swmode[1];
	uint32_t _swmode;
} BCM53115_A0_SWMODEr_t;

#define BCM53115_A0_SWMODEr_CLR(r) (r).swmode[0] = 0
#define BCM53115_A0_SWMODEr_SET(r,d) (r).swmode[0] = d
#define BCM53115_A0_SWMODEr_GET(r) (r).swmode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_SWMODEr_SW_FWDG_MODEf_GET(r) (((r).swmode[0]) & 0x1)
#define BCM53115_A0_SWMODEr_SW_FWDG_MODEf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_SWMODEr_SW_FWDG_ENf_GET(r) ((((r).swmode[0]) >> 1) & 0x1)
#define BCM53115_A0_SWMODEr_SW_FWDG_ENf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_SWMODEr_PTRY_LMT_DISf_GET(r) ((((r).swmode[0]) >> 2) & 0x1)
#define BCM53115_A0_SWMODEr_PTRY_LMT_DISf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_SWMODEr_FAST_TXDESC_RERURNf_GET(r) ((((r).swmode[0]) >> 3) & 0x1)
#define BCM53115_A0_SWMODEr_FAST_TXDESC_RERURNf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_SWMODEr_NOBLKCDf_GET(r) ((((r).swmode[0]) >> 4) & 0x1)
#define BCM53115_A0_SWMODEr_NOBLKCDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_SWMODEr_RESERVED_Rf_GET(r) ((((r).swmode[0]) >> 5) & 0x7)
#define BCM53115_A0_SWMODEr_RESERVED_Rf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access SWMODE.
 *
 */
#define BCM53115_A0_READ_SWMODEr(u,r) cdk_robo_reg_read(u,BCM53115_A0_SWMODEr,(r._swmode),1)
#define BCM53115_A0_WRITE_SWMODEr(u,r) cdk_robo_reg_write(u,BCM53115_A0_SWMODEr,&(r._swmode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWMODEr BCM53115_A0_SWMODEr
#define SWMODEr_SIZE BCM53115_A0_SWMODEr_SIZE
typedef BCM53115_A0_SWMODEr_t SWMODEr_t;
#define SWMODEr_CLR BCM53115_A0_SWMODEr_CLR
#define SWMODEr_SET BCM53115_A0_SWMODEr_SET
#define SWMODEr_GET BCM53115_A0_SWMODEr_GET
#define SWMODEr_SW_FWDG_MODEf_GET BCM53115_A0_SWMODEr_SW_FWDG_MODEf_GET
#define SWMODEr_SW_FWDG_MODEf_SET BCM53115_A0_SWMODEr_SW_FWDG_MODEf_SET
#define SWMODEr_SW_FWDG_ENf_GET BCM53115_A0_SWMODEr_SW_FWDG_ENf_GET
#define SWMODEr_SW_FWDG_ENf_SET BCM53115_A0_SWMODEr_SW_FWDG_ENf_SET
#define SWMODEr_PTRY_LMT_DISf_GET BCM53115_A0_SWMODEr_PTRY_LMT_DISf_GET
#define SWMODEr_PTRY_LMT_DISf_SET BCM53115_A0_SWMODEr_PTRY_LMT_DISf_SET
#define SWMODEr_FAST_TXDESC_RERURNf_GET BCM53115_A0_SWMODEr_FAST_TXDESC_RERURNf_GET
#define SWMODEr_FAST_TXDESC_RERURNf_SET BCM53115_A0_SWMODEr_FAST_TXDESC_RERURNf_SET
#define SWMODEr_NOBLKCDf_GET BCM53115_A0_SWMODEr_NOBLKCDf_GET
#define SWMODEr_NOBLKCDf_SET BCM53115_A0_SWMODEr_NOBLKCDf_SET
#define SWMODEr_RESERVED_Rf_GET BCM53115_A0_SWMODEr_RESERVED_Rf_GET
#define SWMODEr_RESERVED_Rf_SET BCM53115_A0_SWMODEr_RESERVED_Rf_SET
#define READ_SWMODEr BCM53115_A0_READ_SWMODEr
#define WRITE_SWMODEr BCM53115_A0_WRITE_SWMODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_SWMODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_InRangeErrCount
 * BLOCKS:   SYS
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_INRANGEERRCOUNTr 0x000071b0

#define BCM53115_A0_S_INRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program S_InRangeErrCount.
 *
 */
typedef union BCM53115_A0_S_INRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t s_inrangeerrcount[1];
	uint32_t _s_inrangeerrcount;
} BCM53115_A0_S_INRANGEERRCOUNTr_t;

#define BCM53115_A0_S_INRANGEERRCOUNTr_CLR(r) (r).s_inrangeerrcount[0] = 0
#define BCM53115_A0_S_INRANGEERRCOUNTr_SET(r,d) (r).s_inrangeerrcount[0] = d
#define BCM53115_A0_S_INRANGEERRCOUNTr_GET(r) (r).s_inrangeerrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_INRANGEERRCOUNTr_COUNTSf_GET(r) ((r).s_inrangeerrcount[0])
#define BCM53115_A0_S_INRANGEERRCOUNTr_COUNTSf_SET(r,f) (r).s_inrangeerrcount[0]=((uint32_t)f)

/*
 * These macros can be used to access S_InRangeErrCount.
 *
 */
#define BCM53115_A0_READ_S_INRANGEERRCOUNTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_INRANGEERRCOUNTr,(r._s_inrangeerrcount),4)
#define BCM53115_A0_WRITE_S_INRANGEERRCOUNTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_INRANGEERRCOUNTr,&(r._s_inrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_INRANGEERRCOUNTr BCM53115_A0_S_INRANGEERRCOUNTr
#define S_INRANGEERRCOUNTr_SIZE BCM53115_A0_S_INRANGEERRCOUNTr_SIZE
typedef BCM53115_A0_S_INRANGEERRCOUNTr_t S_INRANGEERRCOUNTr_t;
#define S_INRANGEERRCOUNTr_CLR BCM53115_A0_S_INRANGEERRCOUNTr_CLR
#define S_INRANGEERRCOUNTr_SET BCM53115_A0_S_INRANGEERRCOUNTr_SET
#define S_INRANGEERRCOUNTr_GET BCM53115_A0_S_INRANGEERRCOUNTr_GET
#define S_INRANGEERRCOUNTr_COUNTSf_GET BCM53115_A0_S_INRANGEERRCOUNTr_COUNTSf_GET
#define S_INRANGEERRCOUNTr_COUNTSf_SET BCM53115_A0_S_INRANGEERRCOUNTr_COUNTSf_SET
#define READ_S_INRANGEERRCOUNTr BCM53115_A0_READ_S_INRANGEERRCOUNTr
#define WRITE_S_INRANGEERRCOUNTr BCM53115_A0_WRITE_S_INRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_INRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_JumboPkt
 * BLOCKS:   SYS
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_JUMBOPKTr 0x000071a8

#define BCM53115_A0_S_JUMBOPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_JumboPkt.
 *
 */
typedef union BCM53115_A0_S_JUMBOPKTr_s {
	uint32_t v[1];
	uint32_t s_jumbopkt[1];
	uint32_t _s_jumbopkt;
} BCM53115_A0_S_JUMBOPKTr_t;

#define BCM53115_A0_S_JUMBOPKTr_CLR(r) (r).s_jumbopkt[0] = 0
#define BCM53115_A0_S_JUMBOPKTr_SET(r,d) (r).s_jumbopkt[0] = d
#define BCM53115_A0_S_JUMBOPKTr_GET(r) (r).s_jumbopkt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_JUMBOPKTr_COUNTSf_GET(r) ((r).s_jumbopkt[0])
#define BCM53115_A0_S_JUMBOPKTr_COUNTSf_SET(r,f) (r).s_jumbopkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_JumboPkt.
 *
 */
#define BCM53115_A0_READ_S_JUMBOPKTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_JUMBOPKTr,(r._s_jumbopkt),4)
#define BCM53115_A0_WRITE_S_JUMBOPKTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_JUMBOPKTr,&(r._s_jumbopkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_JUMBOPKTr BCM53115_A0_S_JUMBOPKTr
#define S_JUMBOPKTr_SIZE BCM53115_A0_S_JUMBOPKTr_SIZE
typedef BCM53115_A0_S_JUMBOPKTr_t S_JUMBOPKTr_t;
#define S_JUMBOPKTr_CLR BCM53115_A0_S_JUMBOPKTr_CLR
#define S_JUMBOPKTr_SET BCM53115_A0_S_JUMBOPKTr_SET
#define S_JUMBOPKTr_GET BCM53115_A0_S_JUMBOPKTr_GET
#define S_JUMBOPKTr_COUNTSf_GET BCM53115_A0_S_JUMBOPKTr_COUNTSf_GET
#define S_JUMBOPKTr_COUNTSf_SET BCM53115_A0_S_JUMBOPKTr_COUNTSf_SET
#define READ_S_JUMBOPKTr BCM53115_A0_READ_S_JUMBOPKTr
#define WRITE_S_JUMBOPKTr BCM53115_A0_WRITE_S_JUMBOPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_JUMBOPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_OutRangeErrCount
 * BLOCKS:   SYS
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_OUTRANGEERRCOUNTr 0x000071b4

#define BCM53115_A0_S_OUTRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program S_OutRangeErrCount.
 *
 */
typedef union BCM53115_A0_S_OUTRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t s_outrangeerrcount[1];
	uint32_t _s_outrangeerrcount;
} BCM53115_A0_S_OUTRANGEERRCOUNTr_t;

#define BCM53115_A0_S_OUTRANGEERRCOUNTr_CLR(r) (r).s_outrangeerrcount[0] = 0
#define BCM53115_A0_S_OUTRANGEERRCOUNTr_SET(r,d) (r).s_outrangeerrcount[0] = d
#define BCM53115_A0_S_OUTRANGEERRCOUNTr_GET(r) (r).s_outrangeerrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_OUTRANGEERRCOUNTr_COUNTSf_GET(r) ((r).s_outrangeerrcount[0])
#define BCM53115_A0_S_OUTRANGEERRCOUNTr_COUNTSf_SET(r,f) (r).s_outrangeerrcount[0]=((uint32_t)f)

/*
 * These macros can be used to access S_OutRangeErrCount.
 *
 */
#define BCM53115_A0_READ_S_OUTRANGEERRCOUNTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_OUTRANGEERRCOUNTr,(r._s_outrangeerrcount),4)
#define BCM53115_A0_WRITE_S_OUTRANGEERRCOUNTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_OUTRANGEERRCOUNTr,&(r._s_outrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_OUTRANGEERRCOUNTr BCM53115_A0_S_OUTRANGEERRCOUNTr
#define S_OUTRANGEERRCOUNTr_SIZE BCM53115_A0_S_OUTRANGEERRCOUNTr_SIZE
typedef BCM53115_A0_S_OUTRANGEERRCOUNTr_t S_OUTRANGEERRCOUNTr_t;
#define S_OUTRANGEERRCOUNTr_CLR BCM53115_A0_S_OUTRANGEERRCOUNTr_CLR
#define S_OUTRANGEERRCOUNTr_SET BCM53115_A0_S_OUTRANGEERRCOUNTr_SET
#define S_OUTRANGEERRCOUNTr_GET BCM53115_A0_S_OUTRANGEERRCOUNTr_GET
#define S_OUTRANGEERRCOUNTr_COUNTSf_GET BCM53115_A0_S_OUTRANGEERRCOUNTr_COUNTSf_GET
#define S_OUTRANGEERRCOUNTr_COUNTSf_SET BCM53115_A0_S_OUTRANGEERRCOUNTr_COUNTSf_SET
#define READ_S_OUTRANGEERRCOUNTr BCM53115_A0_READ_S_OUTRANGEERRCOUNTr
#define WRITE_S_OUTRANGEERRCOUNTr BCM53115_A0_WRITE_S_OUTRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_OUTRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_Pkts1024toMaxPktOctets
 * BLOCKS:   SYS
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr 0x00007174

#define BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts1024toMaxPktOctets.
 *
 */
typedef union BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts1024tomaxpktoctets[1];
	uint32_t _s_pkts1024tomaxpktoctets;
} BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_t;

#define BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_CLR(r) (r).s_pkts1024tomaxpktoctets[0] = 0
#define BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_SET(r,d) (r).s_pkts1024tomaxpktoctets[0] = d
#define BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_GET(r) (r).s_pkts1024tomaxpktoctets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTSf_GET(r) ((r).s_pkts1024tomaxpktoctets[0])
#define BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTSf_SET(r,f) (r).s_pkts1024tomaxpktoctets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts1024toMaxPktOctets.
 *
 */
#define BCM53115_A0_READ_S_PKTS1024TOMAXPKTOCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr,(r._s_pkts1024tomaxpktoctets),4)
#define BCM53115_A0_WRITE_S_PKTS1024TOMAXPKTOCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr,&(r._s_pkts1024tomaxpktoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS1024TOMAXPKTOCTETSr BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr
#define S_PKTS1024TOMAXPKTOCTETSr_SIZE BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_SIZE
typedef BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_t S_PKTS1024TOMAXPKTOCTETSr_t;
#define S_PKTS1024TOMAXPKTOCTETSr_CLR BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_CLR
#define S_PKTS1024TOMAXPKTOCTETSr_SET BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_SET
#define S_PKTS1024TOMAXPKTOCTETSr_GET BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_GET
#define S_PKTS1024TOMAXPKTOCTETSr_COUNTSf_GET BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTSf_GET
#define S_PKTS1024TOMAXPKTOCTETSr_COUNTSf_SET BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTSf_SET
#define READ_S_PKTS1024TOMAXPKTOCTETSr BCM53115_A0_READ_S_PKTS1024TOMAXPKTOCTETSr
#define WRITE_S_PKTS1024TOMAXPKTOCTETSr BCM53115_A0_WRITE_S_PKTS1024TOMAXPKTOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_PKTS1024TOMAXPKTOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_Pkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_PKTS128TO255OCTETSr 0x00007168

#define BCM53115_A0_S_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts128to255Octets.
 *
 */
typedef union BCM53115_A0_S_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts128to255octets[1];
	uint32_t _s_pkts128to255octets;
} BCM53115_A0_S_PKTS128TO255OCTETSr_t;

#define BCM53115_A0_S_PKTS128TO255OCTETSr_CLR(r) (r).s_pkts128to255octets[0] = 0
#define BCM53115_A0_S_PKTS128TO255OCTETSr_SET(r,d) (r).s_pkts128to255octets[0] = d
#define BCM53115_A0_S_PKTS128TO255OCTETSr_GET(r) (r).s_pkts128to255octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_PKTS128TO255OCTETSr_COUNTSf_GET(r) ((r).s_pkts128to255octets[0])
#define BCM53115_A0_S_PKTS128TO255OCTETSr_COUNTSf_SET(r,f) (r).s_pkts128to255octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts128to255Octets.
 *
 */
#define BCM53115_A0_READ_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_PKTS128TO255OCTETSr,(r._s_pkts128to255octets),4)
#define BCM53115_A0_WRITE_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_PKTS128TO255OCTETSr,&(r._s_pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS128TO255OCTETSr BCM53115_A0_S_PKTS128TO255OCTETSr
#define S_PKTS128TO255OCTETSr_SIZE BCM53115_A0_S_PKTS128TO255OCTETSr_SIZE
typedef BCM53115_A0_S_PKTS128TO255OCTETSr_t S_PKTS128TO255OCTETSr_t;
#define S_PKTS128TO255OCTETSr_CLR BCM53115_A0_S_PKTS128TO255OCTETSr_CLR
#define S_PKTS128TO255OCTETSr_SET BCM53115_A0_S_PKTS128TO255OCTETSr_SET
#define S_PKTS128TO255OCTETSr_GET BCM53115_A0_S_PKTS128TO255OCTETSr_GET
#define S_PKTS128TO255OCTETSr_COUNTSf_GET BCM53115_A0_S_PKTS128TO255OCTETSr_COUNTSf_GET
#define S_PKTS128TO255OCTETSr_COUNTSf_SET BCM53115_A0_S_PKTS128TO255OCTETSr_COUNTSf_SET
#define READ_S_PKTS128TO255OCTETSr BCM53115_A0_READ_S_PKTS128TO255OCTETSr
#define WRITE_S_PKTS128TO255OCTETSr BCM53115_A0_WRITE_S_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_Pkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_PKTS256TO511OCTETSr 0x0000716c

#define BCM53115_A0_S_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts256to511Octets.
 *
 */
typedef union BCM53115_A0_S_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts256to511octets[1];
	uint32_t _s_pkts256to511octets;
} BCM53115_A0_S_PKTS256TO511OCTETSr_t;

#define BCM53115_A0_S_PKTS256TO511OCTETSr_CLR(r) (r).s_pkts256to511octets[0] = 0
#define BCM53115_A0_S_PKTS256TO511OCTETSr_SET(r,d) (r).s_pkts256to511octets[0] = d
#define BCM53115_A0_S_PKTS256TO511OCTETSr_GET(r) (r).s_pkts256to511octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_PKTS256TO511OCTETSr_COUNTSf_GET(r) ((r).s_pkts256to511octets[0])
#define BCM53115_A0_S_PKTS256TO511OCTETSr_COUNTSf_SET(r,f) (r).s_pkts256to511octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts256to511Octets.
 *
 */
#define BCM53115_A0_READ_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_PKTS256TO511OCTETSr,(r._s_pkts256to511octets),4)
#define BCM53115_A0_WRITE_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_PKTS256TO511OCTETSr,&(r._s_pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS256TO511OCTETSr BCM53115_A0_S_PKTS256TO511OCTETSr
#define S_PKTS256TO511OCTETSr_SIZE BCM53115_A0_S_PKTS256TO511OCTETSr_SIZE
typedef BCM53115_A0_S_PKTS256TO511OCTETSr_t S_PKTS256TO511OCTETSr_t;
#define S_PKTS256TO511OCTETSr_CLR BCM53115_A0_S_PKTS256TO511OCTETSr_CLR
#define S_PKTS256TO511OCTETSr_SET BCM53115_A0_S_PKTS256TO511OCTETSr_SET
#define S_PKTS256TO511OCTETSr_GET BCM53115_A0_S_PKTS256TO511OCTETSr_GET
#define S_PKTS256TO511OCTETSr_COUNTSf_GET BCM53115_A0_S_PKTS256TO511OCTETSr_COUNTSf_GET
#define S_PKTS256TO511OCTETSr_COUNTSf_SET BCM53115_A0_S_PKTS256TO511OCTETSr_COUNTSf_SET
#define READ_S_PKTS256TO511OCTETSr BCM53115_A0_READ_S_PKTS256TO511OCTETSr
#define WRITE_S_PKTS256TO511OCTETSr BCM53115_A0_WRITE_S_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_Pkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_PKTS512TO1023OCTETSr 0x00007170

#define BCM53115_A0_S_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts512to1023Octets.
 *
 */
typedef union BCM53115_A0_S_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts512to1023octets[1];
	uint32_t _s_pkts512to1023octets;
} BCM53115_A0_S_PKTS512TO1023OCTETSr_t;

#define BCM53115_A0_S_PKTS512TO1023OCTETSr_CLR(r) (r).s_pkts512to1023octets[0] = 0
#define BCM53115_A0_S_PKTS512TO1023OCTETSr_SET(r,d) (r).s_pkts512to1023octets[0] = d
#define BCM53115_A0_S_PKTS512TO1023OCTETSr_GET(r) (r).s_pkts512to1023octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_PKTS512TO1023OCTETSr_COUNTSf_GET(r) ((r).s_pkts512to1023octets[0])
#define BCM53115_A0_S_PKTS512TO1023OCTETSr_COUNTSf_SET(r,f) (r).s_pkts512to1023octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts512to1023Octets.
 *
 */
#define BCM53115_A0_READ_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_PKTS512TO1023OCTETSr,(r._s_pkts512to1023octets),4)
#define BCM53115_A0_WRITE_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_PKTS512TO1023OCTETSr,&(r._s_pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS512TO1023OCTETSr BCM53115_A0_S_PKTS512TO1023OCTETSr
#define S_PKTS512TO1023OCTETSr_SIZE BCM53115_A0_S_PKTS512TO1023OCTETSr_SIZE
typedef BCM53115_A0_S_PKTS512TO1023OCTETSr_t S_PKTS512TO1023OCTETSr_t;
#define S_PKTS512TO1023OCTETSr_CLR BCM53115_A0_S_PKTS512TO1023OCTETSr_CLR
#define S_PKTS512TO1023OCTETSr_SET BCM53115_A0_S_PKTS512TO1023OCTETSr_SET
#define S_PKTS512TO1023OCTETSr_GET BCM53115_A0_S_PKTS512TO1023OCTETSr_GET
#define S_PKTS512TO1023OCTETSr_COUNTSf_GET BCM53115_A0_S_PKTS512TO1023OCTETSr_COUNTSf_GET
#define S_PKTS512TO1023OCTETSr_COUNTSf_SET BCM53115_A0_S_PKTS512TO1023OCTETSr_COUNTSf_SET
#define READ_S_PKTS512TO1023OCTETSr BCM53115_A0_READ_S_PKTS512TO1023OCTETSr
#define WRITE_S_PKTS512TO1023OCTETSr BCM53115_A0_WRITE_S_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_Pkts64Octets
 * BLOCKS:   SYS
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_PKTS64OCTETSr 0x00007160

#define BCM53115_A0_S_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts64Octets.
 *
 */
typedef union BCM53115_A0_S_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts64octets[1];
	uint32_t _s_pkts64octets;
} BCM53115_A0_S_PKTS64OCTETSr_t;

#define BCM53115_A0_S_PKTS64OCTETSr_CLR(r) (r).s_pkts64octets[0] = 0
#define BCM53115_A0_S_PKTS64OCTETSr_SET(r,d) (r).s_pkts64octets[0] = d
#define BCM53115_A0_S_PKTS64OCTETSr_GET(r) (r).s_pkts64octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_PKTS64OCTETSr_COUNTSf_GET(r) ((r).s_pkts64octets[0])
#define BCM53115_A0_S_PKTS64OCTETSr_COUNTSf_SET(r,f) (r).s_pkts64octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts64Octets.
 *
 */
#define BCM53115_A0_READ_S_PKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_PKTS64OCTETSr,(r._s_pkts64octets),4)
#define BCM53115_A0_WRITE_S_PKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_PKTS64OCTETSr,&(r._s_pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS64OCTETSr BCM53115_A0_S_PKTS64OCTETSr
#define S_PKTS64OCTETSr_SIZE BCM53115_A0_S_PKTS64OCTETSr_SIZE
typedef BCM53115_A0_S_PKTS64OCTETSr_t S_PKTS64OCTETSr_t;
#define S_PKTS64OCTETSr_CLR BCM53115_A0_S_PKTS64OCTETSr_CLR
#define S_PKTS64OCTETSr_SET BCM53115_A0_S_PKTS64OCTETSr_SET
#define S_PKTS64OCTETSr_GET BCM53115_A0_S_PKTS64OCTETSr_GET
#define S_PKTS64OCTETSr_COUNTSf_GET BCM53115_A0_S_PKTS64OCTETSr_COUNTSf_GET
#define S_PKTS64OCTETSr_COUNTSf_SET BCM53115_A0_S_PKTS64OCTETSr_COUNTSf_SET
#define READ_S_PKTS64OCTETSr BCM53115_A0_READ_S_PKTS64OCTETSr
#define WRITE_S_PKTS64OCTETSr BCM53115_A0_WRITE_S_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_Pkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_PKTS65TO127OCTETSr 0x00007164

#define BCM53115_A0_S_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts65to127Octets.
 *
 */
typedef union BCM53115_A0_S_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts65to127octets[1];
	uint32_t _s_pkts65to127octets;
} BCM53115_A0_S_PKTS65TO127OCTETSr_t;

#define BCM53115_A0_S_PKTS65TO127OCTETSr_CLR(r) (r).s_pkts65to127octets[0] = 0
#define BCM53115_A0_S_PKTS65TO127OCTETSr_SET(r,d) (r).s_pkts65to127octets[0] = d
#define BCM53115_A0_S_PKTS65TO127OCTETSr_GET(r) (r).s_pkts65to127octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_PKTS65TO127OCTETSr_COUNTSf_GET(r) ((r).s_pkts65to127octets[0])
#define BCM53115_A0_S_PKTS65TO127OCTETSr_COUNTSf_SET(r,f) (r).s_pkts65to127octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts65to127Octets.
 *
 */
#define BCM53115_A0_READ_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_PKTS65TO127OCTETSr,(r._s_pkts65to127octets),4)
#define BCM53115_A0_WRITE_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_PKTS65TO127OCTETSr,&(r._s_pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS65TO127OCTETSr BCM53115_A0_S_PKTS65TO127OCTETSr
#define S_PKTS65TO127OCTETSr_SIZE BCM53115_A0_S_PKTS65TO127OCTETSr_SIZE
typedef BCM53115_A0_S_PKTS65TO127OCTETSr_t S_PKTS65TO127OCTETSr_t;
#define S_PKTS65TO127OCTETSr_CLR BCM53115_A0_S_PKTS65TO127OCTETSr_CLR
#define S_PKTS65TO127OCTETSr_SET BCM53115_A0_S_PKTS65TO127OCTETSr_SET
#define S_PKTS65TO127OCTETSr_GET BCM53115_A0_S_PKTS65TO127OCTETSr_GET
#define S_PKTS65TO127OCTETSr_COUNTSf_GET BCM53115_A0_S_PKTS65TO127OCTETSr_COUNTSf_GET
#define S_PKTS65TO127OCTETSr_COUNTSf_SET BCM53115_A0_S_PKTS65TO127OCTETSr_COUNTSf_SET
#define READ_S_PKTS65TO127OCTETSr BCM53115_A0_READ_S_PKTS65TO127OCTETSr
#define WRITE_S_PKTS65TO127OCTETSr BCM53115_A0_WRITE_S_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RXDISCARD
 * BLOCKS:   SYS
 * DESC:     Rx Discard Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXDISCARDr 0x000071c0

#define BCM53115_A0_S_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program S_RXDISCARD.
 *
 */
typedef union BCM53115_A0_S_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t s_rxdiscard[1];
	uint32_t _s_rxdiscard;
} BCM53115_A0_S_RXDISCARDr_t;

#define BCM53115_A0_S_RXDISCARDr_CLR(r) (r).s_rxdiscard[0] = 0
#define BCM53115_A0_S_RXDISCARDr_SET(r,d) (r).s_rxdiscard[0] = d
#define BCM53115_A0_S_RXDISCARDr_GET(r) (r).s_rxdiscard[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXDISCARDr_COUNTSf_GET(r) ((r).s_rxdiscard[0])
#define BCM53115_A0_S_RXDISCARDr_COUNTSf_SET(r,f) (r).s_rxdiscard[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXDISCARD.
 *
 */
#define BCM53115_A0_READ_S_RXDISCARDr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXDISCARDr,(r._s_rxdiscard),4)
#define BCM53115_A0_WRITE_S_RXDISCARDr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXDISCARDr,&(r._s_rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDISCARDr BCM53115_A0_S_RXDISCARDr
#define S_RXDISCARDr_SIZE BCM53115_A0_S_RXDISCARDr_SIZE
typedef BCM53115_A0_S_RXDISCARDr_t S_RXDISCARDr_t;
#define S_RXDISCARDr_CLR BCM53115_A0_S_RXDISCARDr_CLR
#define S_RXDISCARDr_SET BCM53115_A0_S_RXDISCARDr_SET
#define S_RXDISCARDr_GET BCM53115_A0_S_RXDISCARDr_GET
#define S_RXDISCARDr_COUNTSf_GET BCM53115_A0_S_RXDISCARDr_COUNTSf_GET
#define S_RXDISCARDr_COUNTSf_SET BCM53115_A0_S_RXDISCARDr_COUNTSf_SET
#define READ_S_RXDISCARDr BCM53115_A0_READ_S_RXDISCARDr
#define WRITE_S_RXDISCARDr BCM53115_A0_WRITE_S_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RXSymblErr
 * BLOCKS:   SYS
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXSYMBLERRr 0x000071ac

#define BCM53115_A0_S_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program S_RXSymblErr.
 *
 */
typedef union BCM53115_A0_S_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t s_rxsymblerr[1];
	uint32_t _s_rxsymblerr;
} BCM53115_A0_S_RXSYMBLERRr_t;

#define BCM53115_A0_S_RXSYMBLERRr_CLR(r) (r).s_rxsymblerr[0] = 0
#define BCM53115_A0_S_RXSYMBLERRr_SET(r,d) (r).s_rxsymblerr[0] = d
#define BCM53115_A0_S_RXSYMBLERRr_GET(r) (r).s_rxsymblerr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXSYMBLERRr_COUNTSf_GET(r) ((r).s_rxsymblerr[0])
#define BCM53115_A0_S_RXSYMBLERRr_COUNTSf_SET(r,f) (r).s_rxsymblerr[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXSymblErr.
 *
 */
#define BCM53115_A0_READ_S_RXSYMBLERRr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXSYMBLERRr,(r._s_rxsymblerr),4)
#define BCM53115_A0_WRITE_S_RXSYMBLERRr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXSYMBLERRr,&(r._s_rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSYMBLERRr BCM53115_A0_S_RXSYMBLERRr
#define S_RXSYMBLERRr_SIZE BCM53115_A0_S_RXSYMBLERRr_SIZE
typedef BCM53115_A0_S_RXSYMBLERRr_t S_RXSYMBLERRr_t;
#define S_RXSYMBLERRr_CLR BCM53115_A0_S_RXSYMBLERRr_CLR
#define S_RXSYMBLERRr_SET BCM53115_A0_S_RXSYMBLERRr_SET
#define S_RXSYMBLERRr_GET BCM53115_A0_S_RXSYMBLERRr_GET
#define S_RXSYMBLERRr_COUNTSf_GET BCM53115_A0_S_RXSYMBLERRr_COUNTSf_GET
#define S_RXSYMBLERRr_COUNTSf_SET BCM53115_A0_S_RXSYMBLERRr_COUNTSf_SET
#define READ_S_RXSYMBLERRr BCM53115_A0_READ_S_RXSYMBLERRr
#define WRITE_S_RXSYMBLERRr BCM53115_A0_WRITE_S_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxAlignmentErrors
 * BLOCKS:   SYS
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXALIGNMENTERRORSr 0x00007180

#define BCM53115_A0_S_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxAlignmentErrors.
 *
 */
typedef union BCM53115_A0_S_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxalignmenterrors[1];
	uint32_t _s_rxalignmenterrors;
} BCM53115_A0_S_RXALIGNMENTERRORSr_t;

#define BCM53115_A0_S_RXALIGNMENTERRORSr_CLR(r) (r).s_rxalignmenterrors[0] = 0
#define BCM53115_A0_S_RXALIGNMENTERRORSr_SET(r,d) (r).s_rxalignmenterrors[0] = d
#define BCM53115_A0_S_RXALIGNMENTERRORSr_GET(r) (r).s_rxalignmenterrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXALIGNMENTERRORSr_COUNTSf_GET(r) ((r).s_rxalignmenterrors[0])
#define BCM53115_A0_S_RXALIGNMENTERRORSr_COUNTSf_SET(r,f) (r).s_rxalignmenterrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxAlignmentErrors.
 *
 */
#define BCM53115_A0_READ_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXALIGNMENTERRORSr,(r._s_rxalignmenterrors),4)
#define BCM53115_A0_WRITE_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXALIGNMENTERRORSr,&(r._s_rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXALIGNMENTERRORSr BCM53115_A0_S_RXALIGNMENTERRORSr
#define S_RXALIGNMENTERRORSr_SIZE BCM53115_A0_S_RXALIGNMENTERRORSr_SIZE
typedef BCM53115_A0_S_RXALIGNMENTERRORSr_t S_RXALIGNMENTERRORSr_t;
#define S_RXALIGNMENTERRORSr_CLR BCM53115_A0_S_RXALIGNMENTERRORSr_CLR
#define S_RXALIGNMENTERRORSr_SET BCM53115_A0_S_RXALIGNMENTERRORSr_SET
#define S_RXALIGNMENTERRORSr_GET BCM53115_A0_S_RXALIGNMENTERRORSr_GET
#define S_RXALIGNMENTERRORSr_COUNTSf_GET BCM53115_A0_S_RXALIGNMENTERRORSr_COUNTSf_GET
#define S_RXALIGNMENTERRORSr_COUNTSf_SET BCM53115_A0_S_RXALIGNMENTERRORSr_COUNTSf_SET
#define READ_S_RXALIGNMENTERRORSr BCM53115_A0_READ_S_RXALIGNMENTERRORSr
#define WRITE_S_RXALIGNMENTERRORSr BCM53115_A0_WRITE_S_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxBroadcastPkt
 * BLOCKS:   SYS
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXBROADCASTPKTr 0x0000719c

#define BCM53115_A0_S_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_RxBroadcastPkt.
 *
 */
typedef union BCM53115_A0_S_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t s_rxbroadcastpkt[1];
	uint32_t _s_rxbroadcastpkt;
} BCM53115_A0_S_RXBROADCASTPKTr_t;

#define BCM53115_A0_S_RXBROADCASTPKTr_CLR(r) (r).s_rxbroadcastpkt[0] = 0
#define BCM53115_A0_S_RXBROADCASTPKTr_SET(r,d) (r).s_rxbroadcastpkt[0] = d
#define BCM53115_A0_S_RXBROADCASTPKTr_GET(r) (r).s_rxbroadcastpkt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXBROADCASTPKTr_COUNTSf_GET(r) ((r).s_rxbroadcastpkt[0])
#define BCM53115_A0_S_RXBROADCASTPKTr_COUNTSf_SET(r,f) (r).s_rxbroadcastpkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxBroadcastPkt.
 *
 */
#define BCM53115_A0_READ_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXBROADCASTPKTr,(r._s_rxbroadcastpkt),4)
#define BCM53115_A0_WRITE_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXBROADCASTPKTr,&(r._s_rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXBROADCASTPKTr BCM53115_A0_S_RXBROADCASTPKTr
#define S_RXBROADCASTPKTr_SIZE BCM53115_A0_S_RXBROADCASTPKTr_SIZE
typedef BCM53115_A0_S_RXBROADCASTPKTr_t S_RXBROADCASTPKTr_t;
#define S_RXBROADCASTPKTr_CLR BCM53115_A0_S_RXBROADCASTPKTr_CLR
#define S_RXBROADCASTPKTr_SET BCM53115_A0_S_RXBROADCASTPKTr_SET
#define S_RXBROADCASTPKTr_GET BCM53115_A0_S_RXBROADCASTPKTr_GET
#define S_RXBROADCASTPKTr_COUNTSf_GET BCM53115_A0_S_RXBROADCASTPKTr_COUNTSf_GET
#define S_RXBROADCASTPKTr_COUNTSf_SET BCM53115_A0_S_RXBROADCASTPKTr_COUNTSf_SET
#define READ_S_RXBROADCASTPKTr BCM53115_A0_READ_S_RXBROADCASTPKTr
#define WRITE_S_RXBROADCASTPKTr BCM53115_A0_WRITE_S_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXBROADCASTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxDropPkts
 * BLOCKS:   SYS
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXDROPPKTSr 0x00007190

#define BCM53115_A0_S_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxDropPkts.
 *
 */
typedef union BCM53115_A0_S_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxdroppkts[1];
	uint32_t _s_rxdroppkts;
} BCM53115_A0_S_RXDROPPKTSr_t;

#define BCM53115_A0_S_RXDROPPKTSr_CLR(r) (r).s_rxdroppkts[0] = 0
#define BCM53115_A0_S_RXDROPPKTSr_SET(r,d) (r).s_rxdroppkts[0] = d
#define BCM53115_A0_S_RXDROPPKTSr_GET(r) (r).s_rxdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXDROPPKTSr_COUNTSf_GET(r) ((r).s_rxdroppkts[0])
#define BCM53115_A0_S_RXDROPPKTSr_COUNTSf_SET(r,f) (r).s_rxdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxDropPkts.
 *
 */
#define BCM53115_A0_READ_S_RXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXDROPPKTSr,(r._s_rxdroppkts),4)
#define BCM53115_A0_WRITE_S_RXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXDROPPKTSr,&(r._s_rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDROPPKTSr BCM53115_A0_S_RXDROPPKTSr
#define S_RXDROPPKTSr_SIZE BCM53115_A0_S_RXDROPPKTSr_SIZE
typedef BCM53115_A0_S_RXDROPPKTSr_t S_RXDROPPKTSr_t;
#define S_RXDROPPKTSr_CLR BCM53115_A0_S_RXDROPPKTSr_CLR
#define S_RXDROPPKTSr_SET BCM53115_A0_S_RXDROPPKTSr_SET
#define S_RXDROPPKTSr_GET BCM53115_A0_S_RXDROPPKTSr_GET
#define S_RXDROPPKTSr_COUNTSf_GET BCM53115_A0_S_RXDROPPKTSr_COUNTSf_GET
#define S_RXDROPPKTSr_COUNTSf_SET BCM53115_A0_S_RXDROPPKTSr_COUNTSf_SET
#define READ_S_RXDROPPKTSr BCM53115_A0_READ_S_RXDROPPKTSr
#define WRITE_S_RXDROPPKTSr BCM53115_A0_WRITE_S_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxFCSErrors
 * BLOCKS:   SYS
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXFCSERRORSr 0x00007184

#define BCM53115_A0_S_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFCSErrors.
 *
 */
typedef union BCM53115_A0_S_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxfcserrors[1];
	uint32_t _s_rxfcserrors;
} BCM53115_A0_S_RXFCSERRORSr_t;

#define BCM53115_A0_S_RXFCSERRORSr_CLR(r) (r).s_rxfcserrors[0] = 0
#define BCM53115_A0_S_RXFCSERRORSr_SET(r,d) (r).s_rxfcserrors[0] = d
#define BCM53115_A0_S_RXFCSERRORSr_GET(r) (r).s_rxfcserrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXFCSERRORSr_COUNTSf_GET(r) ((r).s_rxfcserrors[0])
#define BCM53115_A0_S_RXFCSERRORSr_COUNTSf_SET(r,f) (r).s_rxfcserrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFCSErrors.
 *
 */
#define BCM53115_A0_READ_S_RXFCSERRORSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXFCSERRORSr,(r._s_rxfcserrors),4)
#define BCM53115_A0_WRITE_S_RXFCSERRORSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXFCSERRORSr,&(r._s_rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFCSERRORSr BCM53115_A0_S_RXFCSERRORSr
#define S_RXFCSERRORSr_SIZE BCM53115_A0_S_RXFCSERRORSr_SIZE
typedef BCM53115_A0_S_RXFCSERRORSr_t S_RXFCSERRORSr_t;
#define S_RXFCSERRORSr_CLR BCM53115_A0_S_RXFCSERRORSr_CLR
#define S_RXFCSERRORSr_SET BCM53115_A0_S_RXFCSERRORSr_SET
#define S_RXFCSERRORSr_GET BCM53115_A0_S_RXFCSERRORSr_GET
#define S_RXFCSERRORSr_COUNTSf_GET BCM53115_A0_S_RXFCSERRORSr_COUNTSf_GET
#define S_RXFCSERRORSr_COUNTSf_SET BCM53115_A0_S_RXFCSERRORSr_COUNTSf_SET
#define READ_S_RXFCSERRORSr BCM53115_A0_READ_S_RXFCSERRORSr
#define WRITE_S_RXFCSERRORSr BCM53115_A0_WRITE_S_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxFragments
 * BLOCKS:   SYS
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXFRAGMENTSr 0x000071a4

#define BCM53115_A0_S_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFragments.
 *
 */
typedef union BCM53115_A0_S_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t s_rxfragments[1];
	uint32_t _s_rxfragments;
} BCM53115_A0_S_RXFRAGMENTSr_t;

#define BCM53115_A0_S_RXFRAGMENTSr_CLR(r) (r).s_rxfragments[0] = 0
#define BCM53115_A0_S_RXFRAGMENTSr_SET(r,d) (r).s_rxfragments[0] = d
#define BCM53115_A0_S_RXFRAGMENTSr_GET(r) (r).s_rxfragments[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXFRAGMENTSr_COUNTSf_GET(r) ((r).s_rxfragments[0])
#define BCM53115_A0_S_RXFRAGMENTSr_COUNTSf_SET(r,f) (r).s_rxfragments[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFragments.
 *
 */
#define BCM53115_A0_READ_S_RXFRAGMENTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXFRAGMENTSr,(r._s_rxfragments),4)
#define BCM53115_A0_WRITE_S_RXFRAGMENTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXFRAGMENTSr,&(r._s_rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFRAGMENTSr BCM53115_A0_S_RXFRAGMENTSr
#define S_RXFRAGMENTSr_SIZE BCM53115_A0_S_RXFRAGMENTSr_SIZE
typedef BCM53115_A0_S_RXFRAGMENTSr_t S_RXFRAGMENTSr_t;
#define S_RXFRAGMENTSr_CLR BCM53115_A0_S_RXFRAGMENTSr_CLR
#define S_RXFRAGMENTSr_SET BCM53115_A0_S_RXFRAGMENTSr_SET
#define S_RXFRAGMENTSr_GET BCM53115_A0_S_RXFRAGMENTSr_GET
#define S_RXFRAGMENTSr_COUNTSf_GET BCM53115_A0_S_RXFRAGMENTSr_COUNTSf_GET
#define S_RXFRAGMENTSr_COUNTSf_SET BCM53115_A0_S_RXFRAGMENTSr_COUNTSf_SET
#define READ_S_RXFRAGMENTSr BCM53115_A0_READ_S_RXFRAGMENTSr
#define WRITE_S_RXFRAGMENTSr BCM53115_A0_WRITE_S_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxGoodOctets
 * BLOCKS:   SYS
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXGOODOCTETSr 0x00007188

#define BCM53115_A0_S_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxGoodOctets.
 *
 */
typedef union BCM53115_A0_S_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxgoodoctets[2];
	uint32_t _s_rxgoodoctets;
} BCM53115_A0_S_RXGOODOCTETSr_t;

#define BCM53115_A0_S_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxgoodoctets), 0, sizeof(BCM53115_A0_S_RXGOODOCTETSr_t))
#define BCM53115_A0_S_RXGOODOCTETSr_SET(r,i,d) (r).s_rxgoodoctets[i] = d
#define BCM53115_A0_S_RXGOODOCTETSr_GET(r,i) (r).s_rxgoodoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXGOODOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_rxgoodoctets,0,63,a)
#define BCM53115_A0_S_RXGOODOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_rxgoodoctets,0,63,a)

/*
 * These macros can be used to access S_RxGoodOctets.
 *
 */
#define BCM53115_A0_READ_S_RXGOODOCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXGOODOCTETSr,(r._s_rxgoodoctets),8)
#define BCM53115_A0_WRITE_S_RXGOODOCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXGOODOCTETSr,&(r._s_rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXGOODOCTETSr BCM53115_A0_S_RXGOODOCTETSr
#define S_RXGOODOCTETSr_SIZE BCM53115_A0_S_RXGOODOCTETSr_SIZE
typedef BCM53115_A0_S_RXGOODOCTETSr_t S_RXGOODOCTETSr_t;
#define S_RXGOODOCTETSr_CLR BCM53115_A0_S_RXGOODOCTETSr_CLR
#define S_RXGOODOCTETSr_SET BCM53115_A0_S_RXGOODOCTETSr_SET
#define S_RXGOODOCTETSr_GET BCM53115_A0_S_RXGOODOCTETSr_GET
#define S_RXGOODOCTETSr_COUNTSf_GET BCM53115_A0_S_RXGOODOCTETSr_COUNTSf_GET
#define S_RXGOODOCTETSr_COUNTSf_SET BCM53115_A0_S_RXGOODOCTETSr_COUNTSf_SET
#define READ_S_RXGOODOCTETSr BCM53115_A0_READ_S_RXGOODOCTETSr
#define WRITE_S_RXGOODOCTETSr BCM53115_A0_WRITE_S_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxJabbers
 * BLOCKS:   SYS
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXJABBERSr 0x0000717c

#define BCM53115_A0_S_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxJabbers.
 *
 */
typedef union BCM53115_A0_S_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t s_rxjabbers[1];
	uint32_t _s_rxjabbers;
} BCM53115_A0_S_RXJABBERSr_t;

#define BCM53115_A0_S_RXJABBERSr_CLR(r) (r).s_rxjabbers[0] = 0
#define BCM53115_A0_S_RXJABBERSr_SET(r,d) (r).s_rxjabbers[0] = d
#define BCM53115_A0_S_RXJABBERSr_GET(r) (r).s_rxjabbers[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXJABBERSr_COUNTSf_GET(r) ((r).s_rxjabbers[0])
#define BCM53115_A0_S_RXJABBERSr_COUNTSf_SET(r,f) (r).s_rxjabbers[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxJabbers.
 *
 */
#define BCM53115_A0_READ_S_RXJABBERSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXJABBERSr,(r._s_rxjabbers),4)
#define BCM53115_A0_WRITE_S_RXJABBERSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXJABBERSr,&(r._s_rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXJABBERSr BCM53115_A0_S_RXJABBERSr
#define S_RXJABBERSr_SIZE BCM53115_A0_S_RXJABBERSr_SIZE
typedef BCM53115_A0_S_RXJABBERSr_t S_RXJABBERSr_t;
#define S_RXJABBERSr_CLR BCM53115_A0_S_RXJABBERSr_CLR
#define S_RXJABBERSr_SET BCM53115_A0_S_RXJABBERSr_SET
#define S_RXJABBERSr_GET BCM53115_A0_S_RXJABBERSr_GET
#define S_RXJABBERSr_COUNTSf_GET BCM53115_A0_S_RXJABBERSr_COUNTSf_GET
#define S_RXJABBERSr_COUNTSf_SET BCM53115_A0_S_RXJABBERSr_COUNTSf_SET
#define READ_S_RXJABBERSr BCM53115_A0_READ_S_RXJABBERSr
#define WRITE_S_RXJABBERSr BCM53115_A0_WRITE_S_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXMULTICASTPKTSr 0x00007198

#define BCM53115_A0_S_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxMulticastPkts.
 *
 */
typedef union BCM53115_A0_S_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxmulticastpkts[1];
	uint32_t _s_rxmulticastpkts;
} BCM53115_A0_S_RXMULTICASTPKTSr_t;

#define BCM53115_A0_S_RXMULTICASTPKTSr_CLR(r) (r).s_rxmulticastpkts[0] = 0
#define BCM53115_A0_S_RXMULTICASTPKTSr_SET(r,d) (r).s_rxmulticastpkts[0] = d
#define BCM53115_A0_S_RXMULTICASTPKTSr_GET(r) (r).s_rxmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXMULTICASTPKTSr_COUNTSf_GET(r) ((r).s_rxmulticastpkts[0])
#define BCM53115_A0_S_RXMULTICASTPKTSr_COUNTSf_SET(r,f) (r).s_rxmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxMulticastPkts.
 *
 */
#define BCM53115_A0_READ_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXMULTICASTPKTSr,(r._s_rxmulticastpkts),4)
#define BCM53115_A0_WRITE_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXMULTICASTPKTSr,&(r._s_rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXMULTICASTPKTSr BCM53115_A0_S_RXMULTICASTPKTSr
#define S_RXMULTICASTPKTSr_SIZE BCM53115_A0_S_RXMULTICASTPKTSr_SIZE
typedef BCM53115_A0_S_RXMULTICASTPKTSr_t S_RXMULTICASTPKTSr_t;
#define S_RXMULTICASTPKTSr_CLR BCM53115_A0_S_RXMULTICASTPKTSr_CLR
#define S_RXMULTICASTPKTSr_SET BCM53115_A0_S_RXMULTICASTPKTSr_SET
#define S_RXMULTICASTPKTSr_GET BCM53115_A0_S_RXMULTICASTPKTSr_GET
#define S_RXMULTICASTPKTSr_COUNTSf_GET BCM53115_A0_S_RXMULTICASTPKTSr_COUNTSf_GET
#define S_RXMULTICASTPKTSr_COUNTSf_SET BCM53115_A0_S_RXMULTICASTPKTSr_COUNTSf_SET
#define READ_S_RXMULTICASTPKTSr BCM53115_A0_READ_S_RXMULTICASTPKTSr
#define WRITE_S_RXMULTICASTPKTSr BCM53115_A0_WRITE_S_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxOctets
 * BLOCKS:   SYS
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXOCTETSr 0x00007150

#define BCM53115_A0_S_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxOctets.
 *
 */
typedef union BCM53115_A0_S_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxoctets[2];
	uint32_t _s_rxoctets;
} BCM53115_A0_S_RXOCTETSr_t;

#define BCM53115_A0_S_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxoctets), 0, sizeof(BCM53115_A0_S_RXOCTETSr_t))
#define BCM53115_A0_S_RXOCTETSr_SET(r,i,d) (r).s_rxoctets[i] = d
#define BCM53115_A0_S_RXOCTETSr_GET(r,i) (r).s_rxoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_rxoctets,0,63,a)
#define BCM53115_A0_S_RXOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_rxoctets,0,63,a)

/*
 * These macros can be used to access S_RxOctets.
 *
 */
#define BCM53115_A0_READ_S_RXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXOCTETSr,(r._s_rxoctets),8)
#define BCM53115_A0_WRITE_S_RXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXOCTETSr,&(r._s_rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOCTETSr BCM53115_A0_S_RXOCTETSr
#define S_RXOCTETSr_SIZE BCM53115_A0_S_RXOCTETSr_SIZE
typedef BCM53115_A0_S_RXOCTETSr_t S_RXOCTETSr_t;
#define S_RXOCTETSr_CLR BCM53115_A0_S_RXOCTETSr_CLR
#define S_RXOCTETSr_SET BCM53115_A0_S_RXOCTETSr_SET
#define S_RXOCTETSr_GET BCM53115_A0_S_RXOCTETSr_GET
#define S_RXOCTETSr_COUNTSf_GET BCM53115_A0_S_RXOCTETSr_COUNTSf_GET
#define S_RXOCTETSr_COUNTSf_SET BCM53115_A0_S_RXOCTETSr_COUNTSf_SET
#define READ_S_RXOCTETSr BCM53115_A0_READ_S_RXOCTETSr
#define WRITE_S_RXOCTETSr BCM53115_A0_WRITE_S_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxOversizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXOVERSIZEPKTSr 0x00007178

#define BCM53115_A0_S_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxOversizePkts.
 *
 */
typedef union BCM53115_A0_S_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxoversizepkts[1];
	uint32_t _s_rxoversizepkts;
} BCM53115_A0_S_RXOVERSIZEPKTSr_t;

#define BCM53115_A0_S_RXOVERSIZEPKTSr_CLR(r) (r).s_rxoversizepkts[0] = 0
#define BCM53115_A0_S_RXOVERSIZEPKTSr_SET(r,d) (r).s_rxoversizepkts[0] = d
#define BCM53115_A0_S_RXOVERSIZEPKTSr_GET(r) (r).s_rxoversizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXOVERSIZEPKTSr_COUNTSf_GET(r) ((r).s_rxoversizepkts[0])
#define BCM53115_A0_S_RXOVERSIZEPKTSr_COUNTSf_SET(r,f) (r).s_rxoversizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxOversizePkts.
 *
 */
#define BCM53115_A0_READ_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXOVERSIZEPKTSr,(r._s_rxoversizepkts),4)
#define BCM53115_A0_WRITE_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXOVERSIZEPKTSr,&(r._s_rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOVERSIZEPKTSr BCM53115_A0_S_RXOVERSIZEPKTSr
#define S_RXOVERSIZEPKTSr_SIZE BCM53115_A0_S_RXOVERSIZEPKTSr_SIZE
typedef BCM53115_A0_S_RXOVERSIZEPKTSr_t S_RXOVERSIZEPKTSr_t;
#define S_RXOVERSIZEPKTSr_CLR BCM53115_A0_S_RXOVERSIZEPKTSr_CLR
#define S_RXOVERSIZEPKTSr_SET BCM53115_A0_S_RXOVERSIZEPKTSr_SET
#define S_RXOVERSIZEPKTSr_GET BCM53115_A0_S_RXOVERSIZEPKTSr_GET
#define S_RXOVERSIZEPKTSr_COUNTSf_GET BCM53115_A0_S_RXOVERSIZEPKTSr_COUNTSf_GET
#define S_RXOVERSIZEPKTSr_COUNTSf_SET BCM53115_A0_S_RXOVERSIZEPKTSr_COUNTSf_SET
#define READ_S_RXOVERSIZEPKTSr BCM53115_A0_READ_S_RXOVERSIZEPKTSr
#define WRITE_S_RXOVERSIZEPKTSr BCM53115_A0_WRITE_S_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxPausePkts
 * BLOCKS:   SYS
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXPAUSEPKTSr 0x0000715c

#define BCM53115_A0_S_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPausePkts.
 *
 */
typedef union BCM53115_A0_S_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxpausepkts[1];
	uint32_t _s_rxpausepkts;
} BCM53115_A0_S_RXPAUSEPKTSr_t;

#define BCM53115_A0_S_RXPAUSEPKTSr_CLR(r) (r).s_rxpausepkts[0] = 0
#define BCM53115_A0_S_RXPAUSEPKTSr_SET(r,d) (r).s_rxpausepkts[0] = d
#define BCM53115_A0_S_RXPAUSEPKTSr_GET(r) (r).s_rxpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXPAUSEPKTSr_COUNTSf_GET(r) ((r).s_rxpausepkts[0])
#define BCM53115_A0_S_RXPAUSEPKTSr_COUNTSf_SET(r,f) (r).s_rxpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxPausePkts.
 *
 */
#define BCM53115_A0_READ_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXPAUSEPKTSr,(r._s_rxpausepkts),4)
#define BCM53115_A0_WRITE_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXPAUSEPKTSr,&(r._s_rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPAUSEPKTSr BCM53115_A0_S_RXPAUSEPKTSr
#define S_RXPAUSEPKTSr_SIZE BCM53115_A0_S_RXPAUSEPKTSr_SIZE
typedef BCM53115_A0_S_RXPAUSEPKTSr_t S_RXPAUSEPKTSr_t;
#define S_RXPAUSEPKTSr_CLR BCM53115_A0_S_RXPAUSEPKTSr_CLR
#define S_RXPAUSEPKTSr_SET BCM53115_A0_S_RXPAUSEPKTSr_SET
#define S_RXPAUSEPKTSr_GET BCM53115_A0_S_RXPAUSEPKTSr_GET
#define S_RXPAUSEPKTSr_COUNTSf_GET BCM53115_A0_S_RXPAUSEPKTSr_COUNTSf_GET
#define S_RXPAUSEPKTSr_COUNTSf_SET BCM53115_A0_S_RXPAUSEPKTSr_COUNTSf_SET
#define READ_S_RXPAUSEPKTSr BCM53115_A0_READ_S_RXPAUSEPKTSr
#define WRITE_S_RXPAUSEPKTSr BCM53115_A0_WRITE_S_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxSAChanges
 * BLOCKS:   SYS
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXSACHANGESr 0x000071a0

#define BCM53115_A0_S_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program S_RxSAChanges.
 *
 */
typedef union BCM53115_A0_S_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t s_rxsachanges[1];
	uint32_t _s_rxsachanges;
} BCM53115_A0_S_RXSACHANGESr_t;

#define BCM53115_A0_S_RXSACHANGESr_CLR(r) (r).s_rxsachanges[0] = 0
#define BCM53115_A0_S_RXSACHANGESr_SET(r,d) (r).s_rxsachanges[0] = d
#define BCM53115_A0_S_RXSACHANGESr_GET(r) (r).s_rxsachanges[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXSACHANGESr_COUNTSf_GET(r) ((r).s_rxsachanges[0])
#define BCM53115_A0_S_RXSACHANGESr_COUNTSf_SET(r,f) (r).s_rxsachanges[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxSAChanges.
 *
 */
#define BCM53115_A0_READ_S_RXSACHANGESr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXSACHANGESr,(r._s_rxsachanges),4)
#define BCM53115_A0_WRITE_S_RXSACHANGESr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXSACHANGESr,&(r._s_rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSACHANGESr BCM53115_A0_S_RXSACHANGESr
#define S_RXSACHANGESr_SIZE BCM53115_A0_S_RXSACHANGESr_SIZE
typedef BCM53115_A0_S_RXSACHANGESr_t S_RXSACHANGESr_t;
#define S_RXSACHANGESr_CLR BCM53115_A0_S_RXSACHANGESr_CLR
#define S_RXSACHANGESr_SET BCM53115_A0_S_RXSACHANGESr_SET
#define S_RXSACHANGESr_GET BCM53115_A0_S_RXSACHANGESr_GET
#define S_RXSACHANGESr_COUNTSf_GET BCM53115_A0_S_RXSACHANGESr_COUNTSf_GET
#define S_RXSACHANGESr_COUNTSf_SET BCM53115_A0_S_RXSACHANGESr_COUNTSf_SET
#define READ_S_RXSACHANGESr BCM53115_A0_READ_S_RXSACHANGESr
#define WRITE_S_RXSACHANGESr BCM53115_A0_WRITE_S_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxUndersizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXUNDERSIZEPKTSr 0x00007158

#define BCM53115_A0_S_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUndersizePkts.
 *
 */
typedef union BCM53115_A0_S_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxundersizepkts[1];
	uint32_t _s_rxundersizepkts;
} BCM53115_A0_S_RXUNDERSIZEPKTSr_t;

#define BCM53115_A0_S_RXUNDERSIZEPKTSr_CLR(r) (r).s_rxundersizepkts[0] = 0
#define BCM53115_A0_S_RXUNDERSIZEPKTSr_SET(r,d) (r).s_rxundersizepkts[0] = d
#define BCM53115_A0_S_RXUNDERSIZEPKTSr_GET(r) (r).s_rxundersizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXUNDERSIZEPKTSr_COUNTSf_GET(r) ((r).s_rxundersizepkts[0])
#define BCM53115_A0_S_RXUNDERSIZEPKTSr_COUNTSf_SET(r,f) (r).s_rxundersizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUndersizePkts.
 *
 */
#define BCM53115_A0_READ_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXUNDERSIZEPKTSr,(r._s_rxundersizepkts),4)
#define BCM53115_A0_WRITE_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXUNDERSIZEPKTSr,&(r._s_rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNDERSIZEPKTSr BCM53115_A0_S_RXUNDERSIZEPKTSr
#define S_RXUNDERSIZEPKTSr_SIZE BCM53115_A0_S_RXUNDERSIZEPKTSr_SIZE
typedef BCM53115_A0_S_RXUNDERSIZEPKTSr_t S_RXUNDERSIZEPKTSr_t;
#define S_RXUNDERSIZEPKTSr_CLR BCM53115_A0_S_RXUNDERSIZEPKTSr_CLR
#define S_RXUNDERSIZEPKTSr_SET BCM53115_A0_S_RXUNDERSIZEPKTSr_SET
#define S_RXUNDERSIZEPKTSr_GET BCM53115_A0_S_RXUNDERSIZEPKTSr_GET
#define S_RXUNDERSIZEPKTSr_COUNTSf_GET BCM53115_A0_S_RXUNDERSIZEPKTSr_COUNTSf_GET
#define S_RXUNDERSIZEPKTSr_COUNTSf_SET BCM53115_A0_S_RXUNDERSIZEPKTSr_COUNTSf_SET
#define READ_S_RXUNDERSIZEPKTSr BCM53115_A0_READ_S_RXUNDERSIZEPKTSr
#define WRITE_S_RXUNDERSIZEPKTSr BCM53115_A0_WRITE_S_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_RxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_RXUNICASTPKTSr 0x00007194

#define BCM53115_A0_S_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUnicastPkts.
 *
 */
typedef union BCM53115_A0_S_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxunicastpkts[1];
	uint32_t _s_rxunicastpkts;
} BCM53115_A0_S_RXUNICASTPKTSr_t;

#define BCM53115_A0_S_RXUNICASTPKTSr_CLR(r) (r).s_rxunicastpkts[0] = 0
#define BCM53115_A0_S_RXUNICASTPKTSr_SET(r,d) (r).s_rxunicastpkts[0] = d
#define BCM53115_A0_S_RXUNICASTPKTSr_GET(r) (r).s_rxunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_RXUNICASTPKTSr_COUNTSf_GET(r) ((r).s_rxunicastpkts[0])
#define BCM53115_A0_S_RXUNICASTPKTSr_COUNTSf_SET(r,f) (r).s_rxunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUnicastPkts.
 *
 */
#define BCM53115_A0_READ_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_RXUNICASTPKTSr,(r._s_rxunicastpkts),4)
#define BCM53115_A0_WRITE_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_RXUNICASTPKTSr,&(r._s_rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNICASTPKTSr BCM53115_A0_S_RXUNICASTPKTSr
#define S_RXUNICASTPKTSr_SIZE BCM53115_A0_S_RXUNICASTPKTSr_SIZE
typedef BCM53115_A0_S_RXUNICASTPKTSr_t S_RXUNICASTPKTSr_t;
#define S_RXUNICASTPKTSr_CLR BCM53115_A0_S_RXUNICASTPKTSr_CLR
#define S_RXUNICASTPKTSr_SET BCM53115_A0_S_RXUNICASTPKTSr_SET
#define S_RXUNICASTPKTSr_GET BCM53115_A0_S_RXUNICASTPKTSr_GET
#define S_RXUNICASTPKTSr_COUNTSf_GET BCM53115_A0_S_RXUNICASTPKTSr_COUNTSf_GET
#define S_RXUNICASTPKTSr_COUNTSf_SET BCM53115_A0_S_RXUNICASTPKTSr_COUNTSf_SET
#define READ_S_RXUNICASTPKTSr BCM53115_A0_READ_S_RXUNICASTPKTSr
#define WRITE_S_RXUNICASTPKTSr BCM53115_A0_WRITE_S_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXBROADCASTPKTSr 0x00007110

#define BCM53115_A0_S_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxBroadcastPkts.
 *
 */
typedef union BCM53115_A0_S_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txbroadcastpkts[1];
	uint32_t _s_txbroadcastpkts;
} BCM53115_A0_S_TXBROADCASTPKTSr_t;

#define BCM53115_A0_S_TXBROADCASTPKTSr_CLR(r) (r).s_txbroadcastpkts[0] = 0
#define BCM53115_A0_S_TXBROADCASTPKTSr_SET(r,d) (r).s_txbroadcastpkts[0] = d
#define BCM53115_A0_S_TXBROADCASTPKTSr_GET(r) (r).s_txbroadcastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXBROADCASTPKTSr_COUNTSf_GET(r) ((r).s_txbroadcastpkts[0])
#define BCM53115_A0_S_TXBROADCASTPKTSr_COUNTSf_SET(r,f) (r).s_txbroadcastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxBroadcastPkts.
 *
 */
#define BCM53115_A0_READ_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXBROADCASTPKTSr,(r._s_txbroadcastpkts),4)
#define BCM53115_A0_WRITE_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXBROADCASTPKTSr,&(r._s_txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXBROADCASTPKTSr BCM53115_A0_S_TXBROADCASTPKTSr
#define S_TXBROADCASTPKTSr_SIZE BCM53115_A0_S_TXBROADCASTPKTSr_SIZE
typedef BCM53115_A0_S_TXBROADCASTPKTSr_t S_TXBROADCASTPKTSr_t;
#define S_TXBROADCASTPKTSr_CLR BCM53115_A0_S_TXBROADCASTPKTSr_CLR
#define S_TXBROADCASTPKTSr_SET BCM53115_A0_S_TXBROADCASTPKTSr_SET
#define S_TXBROADCASTPKTSr_GET BCM53115_A0_S_TXBROADCASTPKTSr_GET
#define S_TXBROADCASTPKTSr_COUNTSf_GET BCM53115_A0_S_TXBROADCASTPKTSr_COUNTSf_GET
#define S_TXBROADCASTPKTSr_COUNTSf_SET BCM53115_A0_S_TXBROADCASTPKTSr_COUNTSf_SET
#define READ_S_TXBROADCASTPKTSr BCM53115_A0_READ_S_TXBROADCASTPKTSr
#define WRITE_S_TXBROADCASTPKTSr BCM53115_A0_WRITE_S_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxCollisions
 * BLOCKS:   SYS
 * DESC:     Tx Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXCOLLISIONSr 0x0000711c

#define BCM53115_A0_S_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxCollisions.
 *
 */
typedef union BCM53115_A0_S_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txcollisions[1];
	uint32_t _s_txcollisions;
} BCM53115_A0_S_TXCOLLISIONSr_t;

#define BCM53115_A0_S_TXCOLLISIONSr_CLR(r) (r).s_txcollisions[0] = 0
#define BCM53115_A0_S_TXCOLLISIONSr_SET(r,d) (r).s_txcollisions[0] = d
#define BCM53115_A0_S_TXCOLLISIONSr_GET(r) (r).s_txcollisions[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXCOLLISIONSr_COUNTSf_GET(r) ((r).s_txcollisions[0])
#define BCM53115_A0_S_TXCOLLISIONSr_COUNTSf_SET(r,f) (r).s_txcollisions[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxCollisions.
 *
 */
#define BCM53115_A0_READ_S_TXCOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXCOLLISIONSr,(r._s_txcollisions),4)
#define BCM53115_A0_WRITE_S_TXCOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXCOLLISIONSr,&(r._s_txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXCOLLISIONSr BCM53115_A0_S_TXCOLLISIONSr
#define S_TXCOLLISIONSr_SIZE BCM53115_A0_S_TXCOLLISIONSr_SIZE
typedef BCM53115_A0_S_TXCOLLISIONSr_t S_TXCOLLISIONSr_t;
#define S_TXCOLLISIONSr_CLR BCM53115_A0_S_TXCOLLISIONSr_CLR
#define S_TXCOLLISIONSr_SET BCM53115_A0_S_TXCOLLISIONSr_SET
#define S_TXCOLLISIONSr_GET BCM53115_A0_S_TXCOLLISIONSr_GET
#define S_TXCOLLISIONSr_COUNTSf_GET BCM53115_A0_S_TXCOLLISIONSr_COUNTSf_GET
#define S_TXCOLLISIONSr_COUNTSf_SET BCM53115_A0_S_TXCOLLISIONSr_COUNTSf_SET
#define READ_S_TXCOLLISIONSr BCM53115_A0_READ_S_TXCOLLISIONSr
#define WRITE_S_TXCOLLISIONSr BCM53115_A0_WRITE_S_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxDeferredTransmit
 * BLOCKS:   SYS
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXDEFERREDTRANSMITr 0x00007128

#define BCM53115_A0_S_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDeferredTransmit.
 *
 */
typedef union BCM53115_A0_S_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t s_txdeferredtransmit[1];
	uint32_t _s_txdeferredtransmit;
} BCM53115_A0_S_TXDEFERREDTRANSMITr_t;

#define BCM53115_A0_S_TXDEFERREDTRANSMITr_CLR(r) (r).s_txdeferredtransmit[0] = 0
#define BCM53115_A0_S_TXDEFERREDTRANSMITr_SET(r,d) (r).s_txdeferredtransmit[0] = d
#define BCM53115_A0_S_TXDEFERREDTRANSMITr_GET(r) (r).s_txdeferredtransmit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXDEFERREDTRANSMITr_COUNTSf_GET(r) ((r).s_txdeferredtransmit[0])
#define BCM53115_A0_S_TXDEFERREDTRANSMITr_COUNTSf_SET(r,f) (r).s_txdeferredtransmit[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDeferredTransmit.
 *
 */
#define BCM53115_A0_READ_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXDEFERREDTRANSMITr,(r._s_txdeferredtransmit),4)
#define BCM53115_A0_WRITE_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXDEFERREDTRANSMITr,&(r._s_txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDEFERREDTRANSMITr BCM53115_A0_S_TXDEFERREDTRANSMITr
#define S_TXDEFERREDTRANSMITr_SIZE BCM53115_A0_S_TXDEFERREDTRANSMITr_SIZE
typedef BCM53115_A0_S_TXDEFERREDTRANSMITr_t S_TXDEFERREDTRANSMITr_t;
#define S_TXDEFERREDTRANSMITr_CLR BCM53115_A0_S_TXDEFERREDTRANSMITr_CLR
#define S_TXDEFERREDTRANSMITr_SET BCM53115_A0_S_TXDEFERREDTRANSMITr_SET
#define S_TXDEFERREDTRANSMITr_GET BCM53115_A0_S_TXDEFERREDTRANSMITr_GET
#define S_TXDEFERREDTRANSMITr_COUNTSf_GET BCM53115_A0_S_TXDEFERREDTRANSMITr_COUNTSf_GET
#define S_TXDEFERREDTRANSMITr_COUNTSf_SET BCM53115_A0_S_TXDEFERREDTRANSMITr_COUNTSf_SET
#define READ_S_TXDEFERREDTRANSMITr BCM53115_A0_READ_S_TXDEFERREDTRANSMITr
#define WRITE_S_TXDEFERREDTRANSMITr BCM53115_A0_WRITE_S_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxDropPkts
 * BLOCKS:   SYS
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXDROPPKTSr 0x00007108

#define BCM53115_A0_S_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDropPkts.
 *
 */
typedef union BCM53115_A0_S_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_txdroppkts[1];
	uint32_t _s_txdroppkts;
} BCM53115_A0_S_TXDROPPKTSr_t;

#define BCM53115_A0_S_TXDROPPKTSr_CLR(r) (r).s_txdroppkts[0] = 0
#define BCM53115_A0_S_TXDROPPKTSr_SET(r,d) (r).s_txdroppkts[0] = d
#define BCM53115_A0_S_TXDROPPKTSr_GET(r) (r).s_txdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXDROPPKTSr_COUNTSf_GET(r) ((r).s_txdroppkts[0])
#define BCM53115_A0_S_TXDROPPKTSr_COUNTSf_SET(r,f) (r).s_txdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDropPkts.
 *
 */
#define BCM53115_A0_READ_S_TXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXDROPPKTSr,(r._s_txdroppkts),4)
#define BCM53115_A0_WRITE_S_TXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXDROPPKTSr,&(r._s_txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDROPPKTSr BCM53115_A0_S_TXDROPPKTSr
#define S_TXDROPPKTSr_SIZE BCM53115_A0_S_TXDROPPKTSr_SIZE
typedef BCM53115_A0_S_TXDROPPKTSr_t S_TXDROPPKTSr_t;
#define S_TXDROPPKTSr_CLR BCM53115_A0_S_TXDROPPKTSr_CLR
#define S_TXDROPPKTSr_SET BCM53115_A0_S_TXDROPPKTSr_SET
#define S_TXDROPPKTSr_GET BCM53115_A0_S_TXDROPPKTSr_GET
#define S_TXDROPPKTSr_COUNTSf_GET BCM53115_A0_S_TXDROPPKTSr_COUNTSf_GET
#define S_TXDROPPKTSr_COUNTSf_SET BCM53115_A0_S_TXDROPPKTSr_COUNTSf_SET
#define READ_S_TXDROPPKTSr BCM53115_A0_READ_S_TXDROPPKTSr
#define WRITE_S_TXDROPPKTSr BCM53115_A0_WRITE_S_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxExcessiveCollision
 * BLOCKS:   SYS
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXEXCESSIVECOLLISIONr 0x00007130

#define BCM53115_A0_S_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxExcessiveCollision.
 *
 */
typedef union BCM53115_A0_S_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txexcessivecollision[1];
	uint32_t _s_txexcessivecollision;
} BCM53115_A0_S_TXEXCESSIVECOLLISIONr_t;

#define BCM53115_A0_S_TXEXCESSIVECOLLISIONr_CLR(r) (r).s_txexcessivecollision[0] = 0
#define BCM53115_A0_S_TXEXCESSIVECOLLISIONr_SET(r,d) (r).s_txexcessivecollision[0] = d
#define BCM53115_A0_S_TXEXCESSIVECOLLISIONr_GET(r) (r).s_txexcessivecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_GET(r) ((r).s_txexcessivecollision[0])
#define BCM53115_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_SET(r,f) (r).s_txexcessivecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxExcessiveCollision.
 *
 */
#define BCM53115_A0_READ_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXEXCESSIVECOLLISIONr,(r._s_txexcessivecollision),4)
#define BCM53115_A0_WRITE_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXEXCESSIVECOLLISIONr,&(r._s_txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXEXCESSIVECOLLISIONr BCM53115_A0_S_TXEXCESSIVECOLLISIONr
#define S_TXEXCESSIVECOLLISIONr_SIZE BCM53115_A0_S_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53115_A0_S_TXEXCESSIVECOLLISIONr_t S_TXEXCESSIVECOLLISIONr_t;
#define S_TXEXCESSIVECOLLISIONr_CLR BCM53115_A0_S_TXEXCESSIVECOLLISIONr_CLR
#define S_TXEXCESSIVECOLLISIONr_SET BCM53115_A0_S_TXEXCESSIVECOLLISIONr_SET
#define S_TXEXCESSIVECOLLISIONr_GET BCM53115_A0_S_TXEXCESSIVECOLLISIONr_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTSf_GET BCM53115_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTSf_SET BCM53115_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_SET
#define READ_S_TXEXCESSIVECOLLISIONr BCM53115_A0_READ_S_TXEXCESSIVECOLLISIONr
#define WRITE_S_TXEXCESSIVECOLLISIONr BCM53115_A0_WRITE_S_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxFrameInDisc
 * BLOCKS:   SYS
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXFRAMEINDISCr 0x00007134

#define BCM53115_A0_S_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program S_TxFrameInDisc.
 *
 */
typedef union BCM53115_A0_S_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t s_txframeindisc[1];
	uint32_t _s_txframeindisc;
} BCM53115_A0_S_TXFRAMEINDISCr_t;

#define BCM53115_A0_S_TXFRAMEINDISCr_CLR(r) (r).s_txframeindisc[0] = 0
#define BCM53115_A0_S_TXFRAMEINDISCr_SET(r,d) (r).s_txframeindisc[0] = d
#define BCM53115_A0_S_TXFRAMEINDISCr_GET(r) (r).s_txframeindisc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXFRAMEINDISCr_COUNTSf_GET(r) ((r).s_txframeindisc[0])
#define BCM53115_A0_S_TXFRAMEINDISCr_COUNTSf_SET(r,f) (r).s_txframeindisc[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxFrameInDisc.
 *
 */
#define BCM53115_A0_READ_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXFRAMEINDISCr,(r._s_txframeindisc),4)
#define BCM53115_A0_WRITE_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXFRAMEINDISCr,&(r._s_txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXFRAMEINDISCr BCM53115_A0_S_TXFRAMEINDISCr
#define S_TXFRAMEINDISCr_SIZE BCM53115_A0_S_TXFRAMEINDISCr_SIZE
typedef BCM53115_A0_S_TXFRAMEINDISCr_t S_TXFRAMEINDISCr_t;
#define S_TXFRAMEINDISCr_CLR BCM53115_A0_S_TXFRAMEINDISCr_CLR
#define S_TXFRAMEINDISCr_SET BCM53115_A0_S_TXFRAMEINDISCr_SET
#define S_TXFRAMEINDISCr_GET BCM53115_A0_S_TXFRAMEINDISCr_GET
#define S_TXFRAMEINDISCr_COUNTSf_GET BCM53115_A0_S_TXFRAMEINDISCr_COUNTSf_GET
#define S_TXFRAMEINDISCr_COUNTSf_SET BCM53115_A0_S_TXFRAMEINDISCr_COUNTSf_SET
#define READ_S_TXFRAMEINDISCr BCM53115_A0_READ_S_TXFRAMEINDISCr
#define WRITE_S_TXFRAMEINDISCr BCM53115_A0_WRITE_S_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxLateCollision
 * BLOCKS:   SYS
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXLATECOLLISIONr 0x0000712c

#define BCM53115_A0_S_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxLateCollision.
 *
 */
typedef union BCM53115_A0_S_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txlatecollision[1];
	uint32_t _s_txlatecollision;
} BCM53115_A0_S_TXLATECOLLISIONr_t;

#define BCM53115_A0_S_TXLATECOLLISIONr_CLR(r) (r).s_txlatecollision[0] = 0
#define BCM53115_A0_S_TXLATECOLLISIONr_SET(r,d) (r).s_txlatecollision[0] = d
#define BCM53115_A0_S_TXLATECOLLISIONr_GET(r) (r).s_txlatecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXLATECOLLISIONr_COUNTSf_GET(r) ((r).s_txlatecollision[0])
#define BCM53115_A0_S_TXLATECOLLISIONr_COUNTSf_SET(r,f) (r).s_txlatecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxLateCollision.
 *
 */
#define BCM53115_A0_READ_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXLATECOLLISIONr,(r._s_txlatecollision),4)
#define BCM53115_A0_WRITE_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXLATECOLLISIONr,&(r._s_txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXLATECOLLISIONr BCM53115_A0_S_TXLATECOLLISIONr
#define S_TXLATECOLLISIONr_SIZE BCM53115_A0_S_TXLATECOLLISIONr_SIZE
typedef BCM53115_A0_S_TXLATECOLLISIONr_t S_TXLATECOLLISIONr_t;
#define S_TXLATECOLLISIONr_CLR BCM53115_A0_S_TXLATECOLLISIONr_CLR
#define S_TXLATECOLLISIONr_SET BCM53115_A0_S_TXLATECOLLISIONr_SET
#define S_TXLATECOLLISIONr_GET BCM53115_A0_S_TXLATECOLLISIONr_GET
#define S_TXLATECOLLISIONr_COUNTSf_GET BCM53115_A0_S_TXLATECOLLISIONr_COUNTSf_GET
#define S_TXLATECOLLISIONr_COUNTSf_SET BCM53115_A0_S_TXLATECOLLISIONr_COUNTSf_SET
#define READ_S_TXLATECOLLISIONr BCM53115_A0_READ_S_TXLATECOLLISIONr
#define WRITE_S_TXLATECOLLISIONr BCM53115_A0_WRITE_S_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXMULTICASTPKTSr 0x00007114

#define BCM53115_A0_S_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMulticastPkts.
 *
 */
typedef union BCM53115_A0_S_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txmulticastpkts[1];
	uint32_t _s_txmulticastpkts;
} BCM53115_A0_S_TXMULTICASTPKTSr_t;

#define BCM53115_A0_S_TXMULTICASTPKTSr_CLR(r) (r).s_txmulticastpkts[0] = 0
#define BCM53115_A0_S_TXMULTICASTPKTSr_SET(r,d) (r).s_txmulticastpkts[0] = d
#define BCM53115_A0_S_TXMULTICASTPKTSr_GET(r) (r).s_txmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXMULTICASTPKTSr_COUNTSf_GET(r) ((r).s_txmulticastpkts[0])
#define BCM53115_A0_S_TXMULTICASTPKTSr_COUNTSf_SET(r,f) (r).s_txmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMulticastPkts.
 *
 */
#define BCM53115_A0_READ_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXMULTICASTPKTSr,(r._s_txmulticastpkts),4)
#define BCM53115_A0_WRITE_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXMULTICASTPKTSr,&(r._s_txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTICASTPKTSr BCM53115_A0_S_TXMULTICASTPKTSr
#define S_TXMULTICASTPKTSr_SIZE BCM53115_A0_S_TXMULTICASTPKTSr_SIZE
typedef BCM53115_A0_S_TXMULTICASTPKTSr_t S_TXMULTICASTPKTSr_t;
#define S_TXMULTICASTPKTSr_CLR BCM53115_A0_S_TXMULTICASTPKTSr_CLR
#define S_TXMULTICASTPKTSr_SET BCM53115_A0_S_TXMULTICASTPKTSr_SET
#define S_TXMULTICASTPKTSr_GET BCM53115_A0_S_TXMULTICASTPKTSr_GET
#define S_TXMULTICASTPKTSr_COUNTSf_GET BCM53115_A0_S_TXMULTICASTPKTSr_COUNTSf_GET
#define S_TXMULTICASTPKTSr_COUNTSf_SET BCM53115_A0_S_TXMULTICASTPKTSr_COUNTSf_SET
#define READ_S_TXMULTICASTPKTSr BCM53115_A0_READ_S_TXMULTICASTPKTSr
#define WRITE_S_TXMULTICASTPKTSr BCM53115_A0_WRITE_S_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxMultipleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXMULTIPLECOLLISIONr 0x00007124

#define BCM53115_A0_S_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMultipleCollision.
 *
 */
typedef union BCM53115_A0_S_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txmultiplecollision[1];
	uint32_t _s_txmultiplecollision;
} BCM53115_A0_S_TXMULTIPLECOLLISIONr_t;

#define BCM53115_A0_S_TXMULTIPLECOLLISIONr_CLR(r) (r).s_txmultiplecollision[0] = 0
#define BCM53115_A0_S_TXMULTIPLECOLLISIONr_SET(r,d) (r).s_txmultiplecollision[0] = d
#define BCM53115_A0_S_TXMULTIPLECOLLISIONr_GET(r) (r).s_txmultiplecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_GET(r) ((r).s_txmultiplecollision[0])
#define BCM53115_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_SET(r,f) (r).s_txmultiplecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMultipleCollision.
 *
 */
#define BCM53115_A0_READ_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXMULTIPLECOLLISIONr,(r._s_txmultiplecollision),4)
#define BCM53115_A0_WRITE_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXMULTIPLECOLLISIONr,&(r._s_txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTIPLECOLLISIONr BCM53115_A0_S_TXMULTIPLECOLLISIONr
#define S_TXMULTIPLECOLLISIONr_SIZE BCM53115_A0_S_TXMULTIPLECOLLISIONr_SIZE
typedef BCM53115_A0_S_TXMULTIPLECOLLISIONr_t S_TXMULTIPLECOLLISIONr_t;
#define S_TXMULTIPLECOLLISIONr_CLR BCM53115_A0_S_TXMULTIPLECOLLISIONr_CLR
#define S_TXMULTIPLECOLLISIONr_SET BCM53115_A0_S_TXMULTIPLECOLLISIONr_SET
#define S_TXMULTIPLECOLLISIONr_GET BCM53115_A0_S_TXMULTIPLECOLLISIONr_GET
#define S_TXMULTIPLECOLLISIONr_COUNTSf_GET BCM53115_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_GET
#define S_TXMULTIPLECOLLISIONr_COUNTSf_SET BCM53115_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_SET
#define READ_S_TXMULTIPLECOLLISIONr BCM53115_A0_READ_S_TXMULTIPLECOLLISIONr
#define WRITE_S_TXMULTIPLECOLLISIONr BCM53115_A0_WRITE_S_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxOctets
 * BLOCKS:   SYS
 * DESC:     Tx Octets
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXOCTETSr 0x00007100

#define BCM53115_A0_S_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxOctets.
 *
 */
typedef union BCM53115_A0_S_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_txoctets[2];
	uint32_t _s_txoctets;
} BCM53115_A0_S_TXOCTETSr_t;

#define BCM53115_A0_S_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txoctets), 0, sizeof(BCM53115_A0_S_TXOCTETSr_t))
#define BCM53115_A0_S_TXOCTETSr_SET(r,i,d) (r).s_txoctets[i] = d
#define BCM53115_A0_S_TXOCTETSr_GET(r,i) (r).s_txoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_txoctets,0,63,a)
#define BCM53115_A0_S_TXOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_txoctets,0,63,a)

/*
 * These macros can be used to access S_TxOctets.
 *
 */
#define BCM53115_A0_READ_S_TXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXOCTETSr,(r._s_txoctets),8)
#define BCM53115_A0_WRITE_S_TXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXOCTETSr,&(r._s_txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXOCTETSr BCM53115_A0_S_TXOCTETSr
#define S_TXOCTETSr_SIZE BCM53115_A0_S_TXOCTETSr_SIZE
typedef BCM53115_A0_S_TXOCTETSr_t S_TXOCTETSr_t;
#define S_TXOCTETSr_CLR BCM53115_A0_S_TXOCTETSr_CLR
#define S_TXOCTETSr_SET BCM53115_A0_S_TXOCTETSr_SET
#define S_TXOCTETSr_GET BCM53115_A0_S_TXOCTETSr_GET
#define S_TXOCTETSr_COUNTSf_GET BCM53115_A0_S_TXOCTETSr_COUNTSf_GET
#define S_TXOCTETSr_COUNTSf_SET BCM53115_A0_S_TXOCTETSr_COUNTSf_SET
#define READ_S_TXOCTETSr BCM53115_A0_READ_S_TXOCTETSr
#define WRITE_S_TXOCTETSr BCM53115_A0_WRITE_S_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxPausePkts
 * BLOCKS:   SYS
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXPAUSEPKTSr 0x00007138

#define BCM53115_A0_S_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPausePkts.
 *
 */
typedef union BCM53115_A0_S_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_txpausepkts[1];
	uint32_t _s_txpausepkts;
} BCM53115_A0_S_TXPAUSEPKTSr_t;

#define BCM53115_A0_S_TXPAUSEPKTSr_CLR(r) (r).s_txpausepkts[0] = 0
#define BCM53115_A0_S_TXPAUSEPKTSr_SET(r,d) (r).s_txpausepkts[0] = d
#define BCM53115_A0_S_TXPAUSEPKTSr_GET(r) (r).s_txpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXPAUSEPKTSr_COUNTSf_GET(r) ((r).s_txpausepkts[0])
#define BCM53115_A0_S_TXPAUSEPKTSr_COUNTSf_SET(r,f) (r).s_txpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxPausePkts.
 *
 */
#define BCM53115_A0_READ_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXPAUSEPKTSr,(r._s_txpausepkts),4)
#define BCM53115_A0_WRITE_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXPAUSEPKTSr,&(r._s_txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPAUSEPKTSr BCM53115_A0_S_TXPAUSEPKTSr
#define S_TXPAUSEPKTSr_SIZE BCM53115_A0_S_TXPAUSEPKTSr_SIZE
typedef BCM53115_A0_S_TXPAUSEPKTSr_t S_TXPAUSEPKTSr_t;
#define S_TXPAUSEPKTSr_CLR BCM53115_A0_S_TXPAUSEPKTSr_CLR
#define S_TXPAUSEPKTSr_SET BCM53115_A0_S_TXPAUSEPKTSr_SET
#define S_TXPAUSEPKTSr_GET BCM53115_A0_S_TXPAUSEPKTSr_GET
#define S_TXPAUSEPKTSr_COUNTSf_GET BCM53115_A0_S_TXPAUSEPKTSr_COUNTSf_GET
#define S_TXPAUSEPKTSr_COUNTSf_SET BCM53115_A0_S_TXPAUSEPKTSr_COUNTSf_SET
#define READ_S_TXPAUSEPKTSr BCM53115_A0_READ_S_TXPAUSEPKTSr
#define WRITE_S_TXPAUSEPKTSr BCM53115_A0_WRITE_S_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxQPKTQ0
 * BLOCKS:   SYS
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXQPKTQ0r 0x0000710c

#define BCM53115_A0_S_TXQPKTQ0r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ0.
 *
 */
typedef union BCM53115_A0_S_TXQPKTQ0r_s {
	uint32_t v[1];
	uint32_t s_txqpktq0[1];
	uint32_t _s_txqpktq0;
} BCM53115_A0_S_TXQPKTQ0r_t;

#define BCM53115_A0_S_TXQPKTQ0r_CLR(r) (r).s_txqpktq0[0] = 0
#define BCM53115_A0_S_TXQPKTQ0r_SET(r,d) (r).s_txqpktq0[0] = d
#define BCM53115_A0_S_TXQPKTQ0r_GET(r) (r).s_txqpktq0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXQPKTQ0r_COUNTSf_GET(r) ((r).s_txqpktq0[0])
#define BCM53115_A0_S_TXQPKTQ0r_COUNTSf_SET(r,f) (r).s_txqpktq0[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ0.
 *
 */
#define BCM53115_A0_READ_S_TXQPKTQ0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXQPKTQ0r,(r._s_txqpktq0),4)
#define BCM53115_A0_WRITE_S_TXQPKTQ0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXQPKTQ0r,&(r._s_txqpktq0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ0r BCM53115_A0_S_TXQPKTQ0r
#define S_TXQPKTQ0r_SIZE BCM53115_A0_S_TXQPKTQ0r_SIZE
typedef BCM53115_A0_S_TXQPKTQ0r_t S_TXQPKTQ0r_t;
#define S_TXQPKTQ0r_CLR BCM53115_A0_S_TXQPKTQ0r_CLR
#define S_TXQPKTQ0r_SET BCM53115_A0_S_TXQPKTQ0r_SET
#define S_TXQPKTQ0r_GET BCM53115_A0_S_TXQPKTQ0r_GET
#define S_TXQPKTQ0r_COUNTSf_GET BCM53115_A0_S_TXQPKTQ0r_COUNTSf_GET
#define S_TXQPKTQ0r_COUNTSf_SET BCM53115_A0_S_TXQPKTQ0r_COUNTSf_SET
#define READ_S_TXQPKTQ0r BCM53115_A0_READ_S_TXQPKTQ0r
#define WRITE_S_TXQPKTQ0r BCM53115_A0_WRITE_S_TXQPKTQ0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXQPKTQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxQPKTQ1
 * BLOCKS:   SYS
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXQPKTQ1r 0x0000713c

#define BCM53115_A0_S_TXQPKTQ1r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ1.
 *
 */
typedef union BCM53115_A0_S_TXQPKTQ1r_s {
	uint32_t v[1];
	uint32_t s_txqpktq1[1];
	uint32_t _s_txqpktq1;
} BCM53115_A0_S_TXQPKTQ1r_t;

#define BCM53115_A0_S_TXQPKTQ1r_CLR(r) (r).s_txqpktq1[0] = 0
#define BCM53115_A0_S_TXQPKTQ1r_SET(r,d) (r).s_txqpktq1[0] = d
#define BCM53115_A0_S_TXQPKTQ1r_GET(r) (r).s_txqpktq1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXQPKTQ1r_COUNTSf_GET(r) ((r).s_txqpktq1[0])
#define BCM53115_A0_S_TXQPKTQ1r_COUNTSf_SET(r,f) (r).s_txqpktq1[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ1.
 *
 */
#define BCM53115_A0_READ_S_TXQPKTQ1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXQPKTQ1r,(r._s_txqpktq1),4)
#define BCM53115_A0_WRITE_S_TXQPKTQ1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXQPKTQ1r,&(r._s_txqpktq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ1r BCM53115_A0_S_TXQPKTQ1r
#define S_TXQPKTQ1r_SIZE BCM53115_A0_S_TXQPKTQ1r_SIZE
typedef BCM53115_A0_S_TXQPKTQ1r_t S_TXQPKTQ1r_t;
#define S_TXQPKTQ1r_CLR BCM53115_A0_S_TXQPKTQ1r_CLR
#define S_TXQPKTQ1r_SET BCM53115_A0_S_TXQPKTQ1r_SET
#define S_TXQPKTQ1r_GET BCM53115_A0_S_TXQPKTQ1r_GET
#define S_TXQPKTQ1r_COUNTSf_GET BCM53115_A0_S_TXQPKTQ1r_COUNTSf_GET
#define S_TXQPKTQ1r_COUNTSf_SET BCM53115_A0_S_TXQPKTQ1r_COUNTSf_SET
#define READ_S_TXQPKTQ1r BCM53115_A0_READ_S_TXQPKTQ1r
#define WRITE_S_TXQPKTQ1r BCM53115_A0_WRITE_S_TXQPKTQ1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXQPKTQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxQPKTQ2
 * BLOCKS:   SYS
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXQPKTQ2r 0x00007140

#define BCM53115_A0_S_TXQPKTQ2r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ2.
 *
 */
typedef union BCM53115_A0_S_TXQPKTQ2r_s {
	uint32_t v[1];
	uint32_t s_txqpktq2[1];
	uint32_t _s_txqpktq2;
} BCM53115_A0_S_TXQPKTQ2r_t;

#define BCM53115_A0_S_TXQPKTQ2r_CLR(r) (r).s_txqpktq2[0] = 0
#define BCM53115_A0_S_TXQPKTQ2r_SET(r,d) (r).s_txqpktq2[0] = d
#define BCM53115_A0_S_TXQPKTQ2r_GET(r) (r).s_txqpktq2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXQPKTQ2r_COUNTSf_GET(r) ((r).s_txqpktq2[0])
#define BCM53115_A0_S_TXQPKTQ2r_COUNTSf_SET(r,f) (r).s_txqpktq2[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ2.
 *
 */
#define BCM53115_A0_READ_S_TXQPKTQ2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXQPKTQ2r,(r._s_txqpktq2),4)
#define BCM53115_A0_WRITE_S_TXQPKTQ2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXQPKTQ2r,&(r._s_txqpktq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ2r BCM53115_A0_S_TXQPKTQ2r
#define S_TXQPKTQ2r_SIZE BCM53115_A0_S_TXQPKTQ2r_SIZE
typedef BCM53115_A0_S_TXQPKTQ2r_t S_TXQPKTQ2r_t;
#define S_TXQPKTQ2r_CLR BCM53115_A0_S_TXQPKTQ2r_CLR
#define S_TXQPKTQ2r_SET BCM53115_A0_S_TXQPKTQ2r_SET
#define S_TXQPKTQ2r_GET BCM53115_A0_S_TXQPKTQ2r_GET
#define S_TXQPKTQ2r_COUNTSf_GET BCM53115_A0_S_TXQPKTQ2r_COUNTSf_GET
#define S_TXQPKTQ2r_COUNTSf_SET BCM53115_A0_S_TXQPKTQ2r_COUNTSf_SET
#define READ_S_TXQPKTQ2r BCM53115_A0_READ_S_TXQPKTQ2r
#define WRITE_S_TXQPKTQ2r BCM53115_A0_WRITE_S_TXQPKTQ2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXQPKTQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxQPKTQ3
 * BLOCKS:   SYS
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXQPKTQ3r 0x00007144

#define BCM53115_A0_S_TXQPKTQ3r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ3.
 *
 */
typedef union BCM53115_A0_S_TXQPKTQ3r_s {
	uint32_t v[1];
	uint32_t s_txqpktq3[1];
	uint32_t _s_txqpktq3;
} BCM53115_A0_S_TXQPKTQ3r_t;

#define BCM53115_A0_S_TXQPKTQ3r_CLR(r) (r).s_txqpktq3[0] = 0
#define BCM53115_A0_S_TXQPKTQ3r_SET(r,d) (r).s_txqpktq3[0] = d
#define BCM53115_A0_S_TXQPKTQ3r_GET(r) (r).s_txqpktq3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXQPKTQ3r_COUNTSf_GET(r) ((r).s_txqpktq3[0])
#define BCM53115_A0_S_TXQPKTQ3r_COUNTSf_SET(r,f) (r).s_txqpktq3[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ3.
 *
 */
#define BCM53115_A0_READ_S_TXQPKTQ3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXQPKTQ3r,(r._s_txqpktq3),4)
#define BCM53115_A0_WRITE_S_TXQPKTQ3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXQPKTQ3r,&(r._s_txqpktq3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ3r BCM53115_A0_S_TXQPKTQ3r
#define S_TXQPKTQ3r_SIZE BCM53115_A0_S_TXQPKTQ3r_SIZE
typedef BCM53115_A0_S_TXQPKTQ3r_t S_TXQPKTQ3r_t;
#define S_TXQPKTQ3r_CLR BCM53115_A0_S_TXQPKTQ3r_CLR
#define S_TXQPKTQ3r_SET BCM53115_A0_S_TXQPKTQ3r_SET
#define S_TXQPKTQ3r_GET BCM53115_A0_S_TXQPKTQ3r_GET
#define S_TXQPKTQ3r_COUNTSf_GET BCM53115_A0_S_TXQPKTQ3r_COUNTSf_GET
#define S_TXQPKTQ3r_COUNTSf_SET BCM53115_A0_S_TXQPKTQ3r_COUNTSf_SET
#define READ_S_TXQPKTQ3r BCM53115_A0_READ_S_TXQPKTQ3r
#define WRITE_S_TXQPKTQ3r BCM53115_A0_WRITE_S_TXQPKTQ3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXQPKTQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxQPKTQ4
 * BLOCKS:   SYS
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXQPKTQ4r 0x00007148

#define BCM53115_A0_S_TXQPKTQ4r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ4.
 *
 */
typedef union BCM53115_A0_S_TXQPKTQ4r_s {
	uint32_t v[1];
	uint32_t s_txqpktq4[1];
	uint32_t _s_txqpktq4;
} BCM53115_A0_S_TXQPKTQ4r_t;

#define BCM53115_A0_S_TXQPKTQ4r_CLR(r) (r).s_txqpktq4[0] = 0
#define BCM53115_A0_S_TXQPKTQ4r_SET(r,d) (r).s_txqpktq4[0] = d
#define BCM53115_A0_S_TXQPKTQ4r_GET(r) (r).s_txqpktq4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXQPKTQ4r_COUNTSf_GET(r) ((r).s_txqpktq4[0])
#define BCM53115_A0_S_TXQPKTQ4r_COUNTSf_SET(r,f) (r).s_txqpktq4[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ4.
 *
 */
#define BCM53115_A0_READ_S_TXQPKTQ4r(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXQPKTQ4r,(r._s_txqpktq4),4)
#define BCM53115_A0_WRITE_S_TXQPKTQ4r(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXQPKTQ4r,&(r._s_txqpktq4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ4r BCM53115_A0_S_TXQPKTQ4r
#define S_TXQPKTQ4r_SIZE BCM53115_A0_S_TXQPKTQ4r_SIZE
typedef BCM53115_A0_S_TXQPKTQ4r_t S_TXQPKTQ4r_t;
#define S_TXQPKTQ4r_CLR BCM53115_A0_S_TXQPKTQ4r_CLR
#define S_TXQPKTQ4r_SET BCM53115_A0_S_TXQPKTQ4r_SET
#define S_TXQPKTQ4r_GET BCM53115_A0_S_TXQPKTQ4r_GET
#define S_TXQPKTQ4r_COUNTSf_GET BCM53115_A0_S_TXQPKTQ4r_COUNTSf_GET
#define S_TXQPKTQ4r_COUNTSf_SET BCM53115_A0_S_TXQPKTQ4r_COUNTSf_SET
#define READ_S_TXQPKTQ4r BCM53115_A0_READ_S_TXQPKTQ4r
#define WRITE_S_TXQPKTQ4r BCM53115_A0_WRITE_S_TXQPKTQ4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXQPKTQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxQPKTQ5
 * BLOCKS:   SYS
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXQPKTQ5r 0x0000714c

#define BCM53115_A0_S_TXQPKTQ5r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ5.
 *
 */
typedef union BCM53115_A0_S_TXQPKTQ5r_s {
	uint32_t v[1];
	uint32_t s_txqpktq5[1];
	uint32_t _s_txqpktq5;
} BCM53115_A0_S_TXQPKTQ5r_t;

#define BCM53115_A0_S_TXQPKTQ5r_CLR(r) (r).s_txqpktq5[0] = 0
#define BCM53115_A0_S_TXQPKTQ5r_SET(r,d) (r).s_txqpktq5[0] = d
#define BCM53115_A0_S_TXQPKTQ5r_GET(r) (r).s_txqpktq5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXQPKTQ5r_COUNTSf_GET(r) ((r).s_txqpktq5[0])
#define BCM53115_A0_S_TXQPKTQ5r_COUNTSf_SET(r,f) (r).s_txqpktq5[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ5.
 *
 */
#define BCM53115_A0_READ_S_TXQPKTQ5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXQPKTQ5r,(r._s_txqpktq5),4)
#define BCM53115_A0_WRITE_S_TXQPKTQ5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXQPKTQ5r,&(r._s_txqpktq5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ5r BCM53115_A0_S_TXQPKTQ5r
#define S_TXQPKTQ5r_SIZE BCM53115_A0_S_TXQPKTQ5r_SIZE
typedef BCM53115_A0_S_TXQPKTQ5r_t S_TXQPKTQ5r_t;
#define S_TXQPKTQ5r_CLR BCM53115_A0_S_TXQPKTQ5r_CLR
#define S_TXQPKTQ5r_SET BCM53115_A0_S_TXQPKTQ5r_SET
#define S_TXQPKTQ5r_GET BCM53115_A0_S_TXQPKTQ5r_GET
#define S_TXQPKTQ5r_COUNTSf_GET BCM53115_A0_S_TXQPKTQ5r_COUNTSf_GET
#define S_TXQPKTQ5r_COUNTSf_SET BCM53115_A0_S_TXQPKTQ5r_COUNTSf_SET
#define READ_S_TXQPKTQ5r BCM53115_A0_READ_S_TXQPKTQ5r
#define WRITE_S_TXQPKTQ5r BCM53115_A0_WRITE_S_TXQPKTQ5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXQPKTQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxSingleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXSINGLECOLLISIONr 0x00007120

#define BCM53115_A0_S_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxSingleCollision.
 *
 */
typedef union BCM53115_A0_S_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txsinglecollision[1];
	uint32_t _s_txsinglecollision;
} BCM53115_A0_S_TXSINGLECOLLISIONr_t;

#define BCM53115_A0_S_TXSINGLECOLLISIONr_CLR(r) (r).s_txsinglecollision[0] = 0
#define BCM53115_A0_S_TXSINGLECOLLISIONr_SET(r,d) (r).s_txsinglecollision[0] = d
#define BCM53115_A0_S_TXSINGLECOLLISIONr_GET(r) (r).s_txsinglecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXSINGLECOLLISIONr_COUNTSf_GET(r) ((r).s_txsinglecollision[0])
#define BCM53115_A0_S_TXSINGLECOLLISIONr_COUNTSf_SET(r,f) (r).s_txsinglecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxSingleCollision.
 *
 */
#define BCM53115_A0_READ_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXSINGLECOLLISIONr,(r._s_txsinglecollision),4)
#define BCM53115_A0_WRITE_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXSINGLECOLLISIONr,&(r._s_txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXSINGLECOLLISIONr BCM53115_A0_S_TXSINGLECOLLISIONr
#define S_TXSINGLECOLLISIONr_SIZE BCM53115_A0_S_TXSINGLECOLLISIONr_SIZE
typedef BCM53115_A0_S_TXSINGLECOLLISIONr_t S_TXSINGLECOLLISIONr_t;
#define S_TXSINGLECOLLISIONr_CLR BCM53115_A0_S_TXSINGLECOLLISIONr_CLR
#define S_TXSINGLECOLLISIONr_SET BCM53115_A0_S_TXSINGLECOLLISIONr_SET
#define S_TXSINGLECOLLISIONr_GET BCM53115_A0_S_TXSINGLECOLLISIONr_GET
#define S_TXSINGLECOLLISIONr_COUNTSf_GET BCM53115_A0_S_TXSINGLECOLLISIONr_COUNTSf_GET
#define S_TXSINGLECOLLISIONr_COUNTSf_SET BCM53115_A0_S_TXSINGLECOLLISIONr_COUNTSf_SET
#define READ_S_TXSINGLECOLLISIONr BCM53115_A0_READ_S_TXSINGLECOLLISIONr
#define WRITE_S_TXSINGLECOLLISIONr BCM53115_A0_WRITE_S_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  S_TxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM53115_A0_S_TXUNICASTPKTSr 0x00007118

#define BCM53115_A0_S_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxUnicastPkts.
 *
 */
typedef union BCM53115_A0_S_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txunicastpkts[1];
	uint32_t _s_txunicastpkts;
} BCM53115_A0_S_TXUNICASTPKTSr_t;

#define BCM53115_A0_S_TXUNICASTPKTSr_CLR(r) (r).s_txunicastpkts[0] = 0
#define BCM53115_A0_S_TXUNICASTPKTSr_SET(r,d) (r).s_txunicastpkts[0] = d
#define BCM53115_A0_S_TXUNICASTPKTSr_GET(r) (r).s_txunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_S_TXUNICASTPKTSr_COUNTSf_GET(r) ((r).s_txunicastpkts[0])
#define BCM53115_A0_S_TXUNICASTPKTSr_COUNTSf_SET(r,f) (r).s_txunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxUnicastPkts.
 *
 */
#define BCM53115_A0_READ_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_S_TXUNICASTPKTSr,(r._s_txunicastpkts),4)
#define BCM53115_A0_WRITE_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_S_TXUNICASTPKTSr,&(r._s_txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXUNICASTPKTSr BCM53115_A0_S_TXUNICASTPKTSr
#define S_TXUNICASTPKTSr_SIZE BCM53115_A0_S_TXUNICASTPKTSr_SIZE
typedef BCM53115_A0_S_TXUNICASTPKTSr_t S_TXUNICASTPKTSr_t;
#define S_TXUNICASTPKTSr_CLR BCM53115_A0_S_TXUNICASTPKTSr_CLR
#define S_TXUNICASTPKTSr_SET BCM53115_A0_S_TXUNICASTPKTSr_SET
#define S_TXUNICASTPKTSr_GET BCM53115_A0_S_TXUNICASTPKTSr_GET
#define S_TXUNICASTPKTSr_COUNTSf_GET BCM53115_A0_S_TXUNICASTPKTSr_COUNTSf_GET
#define S_TXUNICASTPKTSr_COUNTSf_SET BCM53115_A0_S_TXUNICASTPKTSr_COUNTSf_SET
#define READ_S_TXUNICASTPKTSr BCM53115_A0_READ_S_TXUNICASTPKTSr
#define WRITE_S_TXUNICASTPKTSr BCM53115_A0_WRITE_S_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_S_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TC2COS_MAP
 * BLOCKS:   SYS
 * DESC:     TC to COS Mapping Register
 * SIZE:     16
 * FIELDS:
 *     PRT000_TO_QID    Priority ID 000 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT001_TO_QID    Priority ID 001 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT010_TO_QID    Priority ID 010 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT011_TO_QID    Priority ID 011 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT100_TO_QID    Priority ID 100 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT101_TO_QID    Priority ID 101 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT110_TO_QID    Priority ID 110 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT111_TO_QID    Priority ID 111 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *
 ******************************************************************************/
#define BCM53115_A0_TC2COS_MAPr 0x00003062

#define BCM53115_A0_TC2COS_MAPr_SIZE 2

/*
 * This structure should be used to declare and program TC2COS_MAP.
 *
 */
typedef union BCM53115_A0_TC2COS_MAPr_s {
	uint32_t v[1];
	uint32_t tc2cos_map[1];
	uint32_t _tc2cos_map;
} BCM53115_A0_TC2COS_MAPr_t;

#define BCM53115_A0_TC2COS_MAPr_CLR(r) (r).tc2cos_map[0] = 0
#define BCM53115_A0_TC2COS_MAPr_SET(r,d) (r).tc2cos_map[0] = d
#define BCM53115_A0_TC2COS_MAPr_GET(r) (r).tc2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TC2COS_MAPr_PRT000_TO_QIDf_GET(r) (((r).tc2cos_map[0]) & 0x3)
#define BCM53115_A0_TC2COS_MAPr_PRT000_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_TC2COS_MAPr_PRT001_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 2) & 0x3)
#define BCM53115_A0_TC2COS_MAPr_PRT001_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_TC2COS_MAPr_PRT010_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 4) & 0x3)
#define BCM53115_A0_TC2COS_MAPr_PRT010_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53115_A0_TC2COS_MAPr_PRT011_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 6) & 0x3)
#define BCM53115_A0_TC2COS_MAPr_PRT011_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53115_A0_TC2COS_MAPr_PRT100_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 8) & 0x3)
#define BCM53115_A0_TC2COS_MAPr_PRT100_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53115_A0_TC2COS_MAPr_PRT101_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 10) & 0x3)
#define BCM53115_A0_TC2COS_MAPr_PRT101_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53115_A0_TC2COS_MAPr_PRT110_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 12) & 0x3)
#define BCM53115_A0_TC2COS_MAPr_PRT110_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53115_A0_TC2COS_MAPr_PRT111_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 14) & 0x3)
#define BCM53115_A0_TC2COS_MAPr_PRT111_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access TC2COS_MAP.
 *
 */
#define BCM53115_A0_READ_TC2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TC2COS_MAPr,(r._tc2cos_map),2)
#define BCM53115_A0_WRITE_TC2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TC2COS_MAPr,&(r._tc2cos_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TC2COS_MAPr BCM53115_A0_TC2COS_MAPr
#define TC2COS_MAPr_SIZE BCM53115_A0_TC2COS_MAPr_SIZE
typedef BCM53115_A0_TC2COS_MAPr_t TC2COS_MAPr_t;
#define TC2COS_MAPr_CLR BCM53115_A0_TC2COS_MAPr_CLR
#define TC2COS_MAPr_SET BCM53115_A0_TC2COS_MAPr_SET
#define TC2COS_MAPr_GET BCM53115_A0_TC2COS_MAPr_GET
#define TC2COS_MAPr_PRT000_TO_QIDf_GET BCM53115_A0_TC2COS_MAPr_PRT000_TO_QIDf_GET
#define TC2COS_MAPr_PRT000_TO_QIDf_SET BCM53115_A0_TC2COS_MAPr_PRT000_TO_QIDf_SET
#define TC2COS_MAPr_PRT001_TO_QIDf_GET BCM53115_A0_TC2COS_MAPr_PRT001_TO_QIDf_GET
#define TC2COS_MAPr_PRT001_TO_QIDf_SET BCM53115_A0_TC2COS_MAPr_PRT001_TO_QIDf_SET
#define TC2COS_MAPr_PRT010_TO_QIDf_GET BCM53115_A0_TC2COS_MAPr_PRT010_TO_QIDf_GET
#define TC2COS_MAPr_PRT010_TO_QIDf_SET BCM53115_A0_TC2COS_MAPr_PRT010_TO_QIDf_SET
#define TC2COS_MAPr_PRT011_TO_QIDf_GET BCM53115_A0_TC2COS_MAPr_PRT011_TO_QIDf_GET
#define TC2COS_MAPr_PRT011_TO_QIDf_SET BCM53115_A0_TC2COS_MAPr_PRT011_TO_QIDf_SET
#define TC2COS_MAPr_PRT100_TO_QIDf_GET BCM53115_A0_TC2COS_MAPr_PRT100_TO_QIDf_GET
#define TC2COS_MAPr_PRT100_TO_QIDf_SET BCM53115_A0_TC2COS_MAPr_PRT100_TO_QIDf_SET
#define TC2COS_MAPr_PRT101_TO_QIDf_GET BCM53115_A0_TC2COS_MAPr_PRT101_TO_QIDf_GET
#define TC2COS_MAPr_PRT101_TO_QIDf_SET BCM53115_A0_TC2COS_MAPr_PRT101_TO_QIDf_SET
#define TC2COS_MAPr_PRT110_TO_QIDf_GET BCM53115_A0_TC2COS_MAPr_PRT110_TO_QIDf_GET
#define TC2COS_MAPr_PRT110_TO_QIDf_SET BCM53115_A0_TC2COS_MAPr_PRT110_TO_QIDf_SET
#define TC2COS_MAPr_PRT111_TO_QIDf_GET BCM53115_A0_TC2COS_MAPr_PRT111_TO_QIDf_GET
#define TC2COS_MAPr_PRT111_TO_QIDf_SET BCM53115_A0_TC2COS_MAPr_PRT111_TO_QIDf_SET
#define READ_TC2COS_MAPr BCM53115_A0_READ_TC2COS_MAPr
#define WRITE_TC2COS_MAPr BCM53115_A0_WRITE_TC2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TC2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TCAM_BIST_CONTROL
 * BLOCKS:   SYS
 * DESC:     TCAM BIST Control Registers
 * SIZE:     32
 * FIELDS:
 *     TCAM_BIST_EN     
 *     TCAM_SEL_R       
 *     RESERVED_R       
 *     TCAM_BIST_STATUS_SEL 
 *     TCAM_BIST_SKIP_ERR_CNT 
 *     TCAM_TEST_COMPARE 
 *     RESERVED_1R      
 *     TCAM_BIST_DONE   
 *
 ******************************************************************************/
#define BCM53115_A0_TCAM_BIST_CONTROLr 0x0000a0a0

#define BCM53115_A0_TCAM_BIST_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program TCAM_BIST_CONTROL.
 *
 */
typedef union BCM53115_A0_TCAM_BIST_CONTROLr_s {
	uint32_t v[1];
	uint32_t tcam_bist_control[1];
	uint32_t _tcam_bist_control;
} BCM53115_A0_TCAM_BIST_CONTROLr_t;

#define BCM53115_A0_TCAM_BIST_CONTROLr_CLR(r) (r).tcam_bist_control[0] = 0
#define BCM53115_A0_TCAM_BIST_CONTROLr_SET(r,d) (r).tcam_bist_control[0] = d
#define BCM53115_A0_TCAM_BIST_CONTROLr_GET(r) (r).tcam_bist_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_ENf_GET(r) (((r).tcam_bist_control[0]) & 0x1)
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_ENf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_SEL_Rf_GET(r) ((((r).tcam_bist_control[0]) >> 1) & 0x1)
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_SEL_Rf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_TCAM_BIST_CONTROLr_RESERVED_Rf_GET(r) ((((r).tcam_bist_control[0]) >> 2) & 0x3)
#define BCM53115_A0_TCAM_BIST_CONTROLr_RESERVED_Rf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_GET(r) ((((r).tcam_bist_control[0]) >> 4) & 0xf)
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_GET(r) ((((r).tcam_bist_control[0]) >> 8) & 0xff)
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_GET(r) ((((r).tcam_bist_control[0]) >> 16) & 0x1)
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53115_A0_TCAM_BIST_CONTROLr_RESERVED_1Rf_GET(r) ((((r).tcam_bist_control[0]) >> 17) & 0x3fff)
#define BCM53115_A0_TCAM_BIST_CONTROLr_RESERVED_1Rf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x3fff << 17)) | ((((uint32_t)f) & 0x3fff) << 17))
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_GET(r) ((((r).tcam_bist_control[0]) >> 31) & 0x1)
#define BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_SET(r,f) (r).tcam_bist_control[0]=(((r).tcam_bist_control[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access TCAM_BIST_CONTROL.
 *
 */
#define BCM53115_A0_READ_TCAM_BIST_CONTROLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TCAM_BIST_CONTROLr,(r._tcam_bist_control),4)
#define BCM53115_A0_WRITE_TCAM_BIST_CONTROLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TCAM_BIST_CONTROLr,&(r._tcam_bist_control),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_BIST_CONTROLr BCM53115_A0_TCAM_BIST_CONTROLr
#define TCAM_BIST_CONTROLr_SIZE BCM53115_A0_TCAM_BIST_CONTROLr_SIZE
typedef BCM53115_A0_TCAM_BIST_CONTROLr_t TCAM_BIST_CONTROLr_t;
#define TCAM_BIST_CONTROLr_CLR BCM53115_A0_TCAM_BIST_CONTROLr_CLR
#define TCAM_BIST_CONTROLr_SET BCM53115_A0_TCAM_BIST_CONTROLr_SET
#define TCAM_BIST_CONTROLr_GET BCM53115_A0_TCAM_BIST_CONTROLr_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_ENf_GET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_ENf_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_ENf_SET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_ENf_SET
#define TCAM_BIST_CONTROLr_TCAM_SEL_Rf_GET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_SEL_Rf_GET
#define TCAM_BIST_CONTROLr_TCAM_SEL_Rf_SET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_SEL_Rf_SET
#define TCAM_BIST_CONTROLr_RESERVED_Rf_GET BCM53115_A0_TCAM_BIST_CONTROLr_RESERVED_Rf_GET
#define TCAM_BIST_CONTROLr_RESERVED_Rf_SET BCM53115_A0_TCAM_BIST_CONTROLr_RESERVED_Rf_SET
#define TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_GET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_SET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_STATUS_SELf_SET
#define TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_GET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_SET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_SKIP_ERR_CNTf_SET
#define TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_GET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_GET
#define TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_SET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_TEST_COMPAREf_SET
#define TCAM_BIST_CONTROLr_RESERVED_1Rf_GET BCM53115_A0_TCAM_BIST_CONTROLr_RESERVED_1Rf_GET
#define TCAM_BIST_CONTROLr_RESERVED_1Rf_SET BCM53115_A0_TCAM_BIST_CONTROLr_RESERVED_1Rf_SET
#define TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_GET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_GET
#define TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_SET BCM53115_A0_TCAM_BIST_CONTROLr_TCAM_BIST_DONEf_SET
#define READ_TCAM_BIST_CONTROLr BCM53115_A0_READ_TCAM_BIST_CONTROLr
#define WRITE_TCAM_BIST_CONTROLr BCM53115_A0_WRITE_TCAM_BIST_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TCAM_BIST_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TCAM_BIST_STATUS
 * BLOCKS:   SYS
 * DESC:     TCAM BIST Status Registers
 * SIZE:     32
 * FIELDS:
 *     TCAM_BIST_STATUS 
 *
 ******************************************************************************/
#define BCM53115_A0_TCAM_BIST_STATUSr 0x0000a0a4

#define BCM53115_A0_TCAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TCAM_BIST_STATUS.
 *
 */
typedef union BCM53115_A0_TCAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t tcam_bist_status[1];
	uint32_t _tcam_bist_status;
} BCM53115_A0_TCAM_BIST_STATUSr_t;

#define BCM53115_A0_TCAM_BIST_STATUSr_CLR(r) (r).tcam_bist_status[0] = 0
#define BCM53115_A0_TCAM_BIST_STATUSr_SET(r,d) (r).tcam_bist_status[0] = d
#define BCM53115_A0_TCAM_BIST_STATUSr_GET(r) (r).tcam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_GET(r) ((r).tcam_bist_status[0])
#define BCM53115_A0_TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_SET(r,f) (r).tcam_bist_status[0]=((uint32_t)f)

/*
 * These macros can be used to access TCAM_BIST_STATUS.
 *
 */
#define BCM53115_A0_READ_TCAM_BIST_STATUSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TCAM_BIST_STATUSr,(r._tcam_bist_status),4)
#define BCM53115_A0_WRITE_TCAM_BIST_STATUSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TCAM_BIST_STATUSr,&(r._tcam_bist_status),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_BIST_STATUSr BCM53115_A0_TCAM_BIST_STATUSr
#define TCAM_BIST_STATUSr_SIZE BCM53115_A0_TCAM_BIST_STATUSr_SIZE
typedef BCM53115_A0_TCAM_BIST_STATUSr_t TCAM_BIST_STATUSr_t;
#define TCAM_BIST_STATUSr_CLR BCM53115_A0_TCAM_BIST_STATUSr_CLR
#define TCAM_BIST_STATUSr_SET BCM53115_A0_TCAM_BIST_STATUSr_SET
#define TCAM_BIST_STATUSr_GET BCM53115_A0_TCAM_BIST_STATUSr_GET
#define TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_GET BCM53115_A0_TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_GET
#define TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_SET BCM53115_A0_TCAM_BIST_STATUSr_TCAM_BIST_STATUSf_SET
#define READ_TCAM_BIST_STATUSr BCM53115_A0_READ_TCAM_BIST_STATUSr
#define WRITE_TCAM_BIST_STATUSr BCM53115_A0_WRITE_TCAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TCAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TCAM_TEST_COMPARE_STATUS
 * BLOCKS:   SYS
 * DESC:     TCAM Test Compare Status Registers
 * SIZE:     32
 * FIELDS:
 *     TCAM_HIT_ADDR    
 *     RESERVED_R       
 *     TCAM_HIT         
 *     RESERVED_1R      
 *
 ******************************************************************************/
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr 0x0000a0a8

#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program TCAM_TEST_COMPARE_STATUS.
 *
 */
typedef union BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_s {
	uint32_t v[1];
	uint32_t tcam_test_compare_status[1];
	uint32_t _tcam_test_compare_status;
} BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_t;

#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_CLR(r) (r).tcam_test_compare_status[0] = 0
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_SET(r,d) (r).tcam_test_compare_status[0] = d
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_GET(r) (r).tcam_test_compare_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_GET(r) (((r).tcam_test_compare_status[0]) & 0xff)
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_SET(r,f) (r).tcam_test_compare_status[0]=(((r).tcam_test_compare_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_Rf_GET(r) ((((r).tcam_test_compare_status[0]) >> 8) & 0x7f)
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_Rf_SET(r,f) (r).tcam_test_compare_status[0]=(((r).tcam_test_compare_status[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_GET(r) ((((r).tcam_test_compare_status[0]) >> 15) & 0x1)
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_SET(r,f) (r).tcam_test_compare_status[0]=(((r).tcam_test_compare_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_1Rf_GET(r) ((((r).tcam_test_compare_status[0]) >> 16) & 0xffff)
#define BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_1Rf_SET(r,f) (r).tcam_test_compare_status[0]=(((r).tcam_test_compare_status[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access TCAM_TEST_COMPARE_STATUS.
 *
 */
#define BCM53115_A0_READ_TCAM_TEST_COMPARE_STATUSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TCAM_TEST_COMPARE_STATUSr,(r._tcam_test_compare_status),4)
#define BCM53115_A0_WRITE_TCAM_TEST_COMPARE_STATUSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TCAM_TEST_COMPARE_STATUSr,&(r._tcam_test_compare_status),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TCAM_TEST_COMPARE_STATUSr BCM53115_A0_TCAM_TEST_COMPARE_STATUSr
#define TCAM_TEST_COMPARE_STATUSr_SIZE BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_SIZE
typedef BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_t TCAM_TEST_COMPARE_STATUSr_t;
#define TCAM_TEST_COMPARE_STATUSr_CLR BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_CLR
#define TCAM_TEST_COMPARE_STATUSr_SET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_SET
#define TCAM_TEST_COMPARE_STATUSr_GET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_GET
#define TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_GET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_GET
#define TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_SET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HIT_ADDRf_SET
#define TCAM_TEST_COMPARE_STATUSr_RESERVED_Rf_GET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_Rf_GET
#define TCAM_TEST_COMPARE_STATUSr_RESERVED_Rf_SET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_Rf_SET
#define TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_GET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_GET
#define TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_SET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_TCAM_HITf_SET
#define TCAM_TEST_COMPARE_STATUSr_RESERVED_1Rf_GET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_1Rf_GET
#define TCAM_TEST_COMPARE_STATUSr_RESERVED_1Rf_SET BCM53115_A0_TCAM_TEST_COMPARE_STATUSr_RESERVED_1Rf_SET
#define READ_TCAM_TEST_COMPARE_STATUSr BCM53115_A0_READ_TCAM_TEST_COMPARE_STATUSr
#define WRITE_TCAM_TEST_COMPARE_STATUSr BCM53115_A0_WRITE_TCAM_TEST_COMPARE_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TCAM_TEST_COMPARE_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TM_STAMP_RPT_CTRL
 * BLOCKS:   SYS
 * DESC:     ResE Time Stamp Report Control Register
 * SIZE:     8
 * FIELDS:
 *     TSRPT_PKT_EN     This field is to allow "Time Stamp Reporting Packet" to IMP when the time sync. packet transmitted on egress port .
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_TM_STAMP_RPT_CTRLr 0x00009002

#define BCM53115_A0_TM_STAMP_RPT_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program TM_STAMP_RPT_CTRL.
 *
 */
typedef union BCM53115_A0_TM_STAMP_RPT_CTRLr_s {
	uint32_t v[1];
	uint32_t tm_stamp_rpt_ctrl[1];
	uint32_t _tm_stamp_rpt_ctrl;
} BCM53115_A0_TM_STAMP_RPT_CTRLr_t;

#define BCM53115_A0_TM_STAMP_RPT_CTRLr_CLR(r) (r).tm_stamp_rpt_ctrl[0] = 0
#define BCM53115_A0_TM_STAMP_RPT_CTRLr_SET(r,d) (r).tm_stamp_rpt_ctrl[0] = d
#define BCM53115_A0_TM_STAMP_RPT_CTRLr_GET(r) (r).tm_stamp_rpt_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET(r) (((r).tm_stamp_rpt_ctrl[0]) & 0x1)
#define BCM53115_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET(r,f) (r).tm_stamp_rpt_ctrl[0]=(((r).tm_stamp_rpt_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_TM_STAMP_RPT_CTRLr_RESERVED_Rf_GET(r) ((((r).tm_stamp_rpt_ctrl[0]) >> 1) & 0x7f)
#define BCM53115_A0_TM_STAMP_RPT_CTRLr_RESERVED_Rf_SET(r,f) (r).tm_stamp_rpt_ctrl[0]=(((r).tm_stamp_rpt_ctrl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TM_STAMP_RPT_CTRL.
 *
 */
#define BCM53115_A0_READ_TM_STAMP_RPT_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TM_STAMP_RPT_CTRLr,(r._tm_stamp_rpt_ctrl),1)
#define BCM53115_A0_WRITE_TM_STAMP_RPT_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TM_STAMP_RPT_CTRLr,&(r._tm_stamp_rpt_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TM_STAMP_RPT_CTRLr BCM53115_A0_TM_STAMP_RPT_CTRLr
#define TM_STAMP_RPT_CTRLr_SIZE BCM53115_A0_TM_STAMP_RPT_CTRLr_SIZE
typedef BCM53115_A0_TM_STAMP_RPT_CTRLr_t TM_STAMP_RPT_CTRLr_t;
#define TM_STAMP_RPT_CTRLr_CLR BCM53115_A0_TM_STAMP_RPT_CTRLr_CLR
#define TM_STAMP_RPT_CTRLr_SET BCM53115_A0_TM_STAMP_RPT_CTRLr_SET
#define TM_STAMP_RPT_CTRLr_GET BCM53115_A0_TM_STAMP_RPT_CTRLr_GET
#define TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET BCM53115_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET
#define TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET BCM53115_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET
#define TM_STAMP_RPT_CTRLr_RESERVED_Rf_GET BCM53115_A0_TM_STAMP_RPT_CTRLr_RESERVED_Rf_GET
#define TM_STAMP_RPT_CTRLr_RESERVED_Rf_SET BCM53115_A0_TM_STAMP_RPT_CTRLr_RESERVED_Rf_SET
#define READ_TM_STAMP_RPT_CTRLr BCM53115_A0_READ_TM_STAMP_RPT_CTRLr
#define WRITE_TM_STAMP_RPT_CTRLr BCM53115_A0_WRITE_TM_STAMP_RPT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TM_STAMP_RPT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TM_STAMP_STATUS
 * BLOCKS:   SYS
 * DESC:     ResE Egress Time Stamp Status Register
 * SIZE:     8
 * FIELDS:
 *     VALID_STATUS     5 bit field indicating  the Valid Status for each Time Stamp Register.  Once ResE Egress Time Stamp Register  read out by SPI, the Valid Status will be cleared respectively.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_TM_STAMP_STATUSr 0x000090af

#define BCM53115_A0_TM_STAMP_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program TM_STAMP_STATUS.
 *
 */
typedef union BCM53115_A0_TM_STAMP_STATUSr_s {
	uint32_t v[1];
	uint32_t tm_stamp_status[1];
	uint32_t _tm_stamp_status;
} BCM53115_A0_TM_STAMP_STATUSr_t;

#define BCM53115_A0_TM_STAMP_STATUSr_CLR(r) (r).tm_stamp_status[0] = 0
#define BCM53115_A0_TM_STAMP_STATUSr_SET(r,d) (r).tm_stamp_status[0] = d
#define BCM53115_A0_TM_STAMP_STATUSr_GET(r) (r).tm_stamp_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TM_STAMP_STATUSr_VALID_STATUSf_GET(r) (((r).tm_stamp_status[0]) & 0x3f)
#define BCM53115_A0_TM_STAMP_STATUSr_VALID_STATUSf_SET(r,f) (r).tm_stamp_status[0]=(((r).tm_stamp_status[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_TM_STAMP_STATUSr_RESERVED_Rf_GET(r) ((((r).tm_stamp_status[0]) >> 6) & 0x3)
#define BCM53115_A0_TM_STAMP_STATUSr_RESERVED_Rf_SET(r,f) (r).tm_stamp_status[0]=(((r).tm_stamp_status[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access TM_STAMP_STATUS.
 *
 */
#define BCM53115_A0_READ_TM_STAMP_STATUSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TM_STAMP_STATUSr,(r._tm_stamp_status),1)
#define BCM53115_A0_WRITE_TM_STAMP_STATUSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TM_STAMP_STATUSr,&(r._tm_stamp_status),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TM_STAMP_STATUSr BCM53115_A0_TM_STAMP_STATUSr
#define TM_STAMP_STATUSr_SIZE BCM53115_A0_TM_STAMP_STATUSr_SIZE
typedef BCM53115_A0_TM_STAMP_STATUSr_t TM_STAMP_STATUSr_t;
#define TM_STAMP_STATUSr_CLR BCM53115_A0_TM_STAMP_STATUSr_CLR
#define TM_STAMP_STATUSr_SET BCM53115_A0_TM_STAMP_STATUSr_SET
#define TM_STAMP_STATUSr_GET BCM53115_A0_TM_STAMP_STATUSr_GET
#define TM_STAMP_STATUSr_VALID_STATUSf_GET BCM53115_A0_TM_STAMP_STATUSr_VALID_STATUSf_GET
#define TM_STAMP_STATUSr_VALID_STATUSf_SET BCM53115_A0_TM_STAMP_STATUSr_VALID_STATUSf_SET
#define TM_STAMP_STATUSr_RESERVED_Rf_GET BCM53115_A0_TM_STAMP_STATUSr_RESERVED_Rf_GET
#define TM_STAMP_STATUSr_RESERVED_Rf_SET BCM53115_A0_TM_STAMP_STATUSr_RESERVED_Rf_SET
#define READ_TM_STAMP_STATUSr BCM53115_A0_READ_TM_STAMP_STATUSr
#define WRITE_TM_STAMP_STATUSr BCM53115_A0_WRITE_TM_STAMP_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TM_STAMP_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TRREG_CTRL
 * BLOCKS:   SYS
 * DESC:     Traffic Remarking Control Register
 * SIZE:     32
 * FIELDS:
 *     CFI_RMK_EN       CFI Remarking Enable
 *     PCP_RMK_EN       PCP Remarking Enable
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_TRREG_CTRLr 0x00009100

#define BCM53115_A0_TRREG_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program TRREG_CTRL.
 *
 */
typedef union BCM53115_A0_TRREG_CTRLr_s {
	uint32_t v[1];
	uint32_t trreg_ctrl[1];
	uint32_t _trreg_ctrl;
} BCM53115_A0_TRREG_CTRLr_t;

#define BCM53115_A0_TRREG_CTRLr_CLR(r) (r).trreg_ctrl[0] = 0
#define BCM53115_A0_TRREG_CTRLr_SET(r,d) (r).trreg_ctrl[0] = d
#define BCM53115_A0_TRREG_CTRLr_GET(r) (r).trreg_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TRREG_CTRLr_CFI_RMK_ENf_GET(r) (((r).trreg_ctrl[0]) & 0x1ff)
#define BCM53115_A0_TRREG_CTRLr_CFI_RMK_ENf_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_TRREG_CTRLr_PCP_RMK_ENf_GET(r) ((((r).trreg_ctrl[0]) >> 16) & 0x1ff)
#define BCM53115_A0_TRREG_CTRLr_PCP_RMK_ENf_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x1ff << 16)) | ((((uint32_t)f) & 0x1ff) << 16))
#define BCM53115_A0_TRREG_CTRLr_RESERVED_1Rf_GET(r) ((((r).trreg_ctrl[0]) >> 25) & 0x7f)
#define BCM53115_A0_TRREG_CTRLr_RESERVED_1Rf_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access TRREG_CTRL.
 *
 */
#define BCM53115_A0_READ_TRREG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TRREG_CTRLr,(r._trreg_ctrl),4)
#define BCM53115_A0_WRITE_TRREG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TRREG_CTRLr,&(r._trreg_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRREG_CTRLr BCM53115_A0_TRREG_CTRLr
#define TRREG_CTRLr_SIZE BCM53115_A0_TRREG_CTRLr_SIZE
typedef BCM53115_A0_TRREG_CTRLr_t TRREG_CTRLr_t;
#define TRREG_CTRLr_CLR BCM53115_A0_TRREG_CTRLr_CLR
#define TRREG_CTRLr_SET BCM53115_A0_TRREG_CTRLr_SET
#define TRREG_CTRLr_GET BCM53115_A0_TRREG_CTRLr_GET
#define TRREG_CTRLr_CFI_RMK_ENf_GET BCM53115_A0_TRREG_CTRLr_CFI_RMK_ENf_GET
#define TRREG_CTRLr_CFI_RMK_ENf_SET BCM53115_A0_TRREG_CTRLr_CFI_RMK_ENf_SET
#define TRREG_CTRLr_PCP_RMK_ENf_GET BCM53115_A0_TRREG_CTRLr_PCP_RMK_ENf_GET
#define TRREG_CTRLr_PCP_RMK_ENf_SET BCM53115_A0_TRREG_CTRLr_PCP_RMK_ENf_SET
#define TRREG_CTRLr_RESERVED_1Rf_GET BCM53115_A0_TRREG_CTRLr_RESERVED_1Rf_GET
#define TRREG_CTRLr_RESERVED_1Rf_SET BCM53115_A0_TRREG_CTRLr_RESERVED_1Rf_SET
#define READ_TRREG_CTRLr BCM53115_A0_READ_TRREG_CTRLr
#define WRITE_TRREG_CTRLr BCM53115_A0_WRITE_TRREG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TRREG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TRUNK_GRP_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TRUNK_GRP     Trunk Group Enable1 = Enable trunk group.0 = Disable trunk_groupBit 8: IMP port.For BCM5395 bits[5:0] correspond to ports [5:0], respectively.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_TRUNK_GRP_CTLr 0x00003210

#define BCM53115_A0_TRUNK_GRP_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TRUNK_GRP_CTL.
 *
 */
typedef union BCM53115_A0_TRUNK_GRP_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_ctl[1];
	uint32_t _trunk_grp_ctl;
} BCM53115_A0_TRUNK_GRP_CTLr_t;

#define BCM53115_A0_TRUNK_GRP_CTLr_CLR(r) (r).trunk_grp_ctl[0] = 0
#define BCM53115_A0_TRUNK_GRP_CTLr_SET(r,d) (r).trunk_grp_ctl[0] = d
#define BCM53115_A0_TRUNK_GRP_CTLr_GET(r) (r).trunk_grp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET(r) (((r).trunk_grp_ctl[0]) & 0x1ff)
#define BCM53115_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_TRUNK_GRP_CTLr_RESERVED_Rf_GET(r) ((((r).trunk_grp_ctl[0]) >> 9) & 0x7f)
#define BCM53115_A0_TRUNK_GRP_CTLr_RESERVED_Rf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TRUNK_GRP_CTL.
 *
 */
#define BCM53115_A0_READ_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_TRUNK_GRP_CTLr+(2*(i)),(r._trunk_grp_ctl),2)
#define BCM53115_A0_WRITE_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_TRUNK_GRP_CTLr+(2*(i)),&(r._trunk_grp_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_CTLr BCM53115_A0_TRUNK_GRP_CTLr
#define TRUNK_GRP_CTLr_SIZE BCM53115_A0_TRUNK_GRP_CTLr_SIZE
typedef BCM53115_A0_TRUNK_GRP_CTLr_t TRUNK_GRP_CTLr_t;
#define TRUNK_GRP_CTLr_CLR BCM53115_A0_TRUNK_GRP_CTLr_CLR
#define TRUNK_GRP_CTLr_SET BCM53115_A0_TRUNK_GRP_CTLr_SET
#define TRUNK_GRP_CTLr_GET BCM53115_A0_TRUNK_GRP_CTLr_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET BCM53115_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET BCM53115_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET
#define TRUNK_GRP_CTLr_RESERVED_Rf_GET BCM53115_A0_TRUNK_GRP_CTLr_RESERVED_Rf_GET
#define TRUNK_GRP_CTLr_RESERVED_Rf_SET BCM53115_A0_TRUNK_GRP_CTLr_RESERVED_Rf_SET
#define READ_TRUNK_GRP_CTLr BCM53115_A0_READ_TRUNK_GRP_CTLr
#define WRITE_TRUNK_GRP_CTLr BCM53115_A0_WRITE_TRUNK_GRP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TRUNK_GRP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TXQ_FLUSH_MODE
 * BLOCKS:   SYS
 * DESC:     TxQ Flush Mode Control Registrer
 * SIZE:     8
 * FIELDS:
 *     BYPASS_FASTTXDSC_PATH Bypass Fast Txdsc Path.
 *     DIS_NEW_TXDIS    Disable new txdisable.
 *     EN_LCOL_FLUSH    Enable Locl Flush.
 *     EN_RELOAD_ERR_PATH Enable Reload Error Path.
 *     EN_LCOL_TXFM_MASK enable_lcol_txfm_mask (default = 0)Description:- When enabled, 5388 drops the TX frame upon a latecollision.  (collisions detected beyond 64th byte including the preamble)- When disabled, 5388 transmits TX frames regardless of late-collision occurrence.
 *     EN_ECOL_TXFM_MASK enable_ecol_txfm_mask (default = 1)This bit affect the behavior of the register Retry_Lmt_Dis (Switch Mode reg 00:0Bh bit2) as follows:- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 1,TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and stay at 15 until the next normal frame transmission.- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 0,TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and loops back to 0and repeats this until the next normal frame transmission.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 1,TX frame is retried up to 15 times, and the frame gets dropped upon the 16th consecutive early collision.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 0,This mode is only engineering purpose, and prohibited for customers (ENGINEERING NOTE: This mode sets 5388 to the old mode, where we observed the tx ports hang. Don't show this in the customer datasheet).
 *     EN_LATECOL65_DROP enable_latecol65_drop.Enable old frame drop when a late collision occurs at 65th byte from start of preamble. When enabled, 5388 goes back to old mode by turning off the fix for Cisco TX Hang.Default is 0NOTE: Engineering only. Do not release this reg to customers.
 *     EN_NEW_BOFF_SEED 1'b1:backoff seed refer to port mumber.1'b0:backoff seed used default fix mumber.
 *
 ******************************************************************************/
#define BCM53115_A0_TXQ_FLUSH_MODEr 0x00000031

#define BCM53115_A0_TXQ_FLUSH_MODEr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_FLUSH_MODE.
 *
 */
typedef union BCM53115_A0_TXQ_FLUSH_MODEr_s {
	uint32_t v[1];
	uint32_t txq_flush_mode[1];
	uint32_t _txq_flush_mode;
} BCM53115_A0_TXQ_FLUSH_MODEr_t;

#define BCM53115_A0_TXQ_FLUSH_MODEr_CLR(r) (r).txq_flush_mode[0] = 0
#define BCM53115_A0_TXQ_FLUSH_MODEr_SET(r,d) (r).txq_flush_mode[0] = d
#define BCM53115_A0_TXQ_FLUSH_MODEr_GET(r) (r).txq_flush_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET(r) (((r).txq_flush_mode[0]) & 0x1)
#define BCM53115_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET(r) ((((r).txq_flush_mode[0]) >> 1) & 0x1)
#define BCM53115_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET(r) ((((r).txq_flush_mode[0]) >> 2) & 0x1)
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET(r) ((((r).txq_flush_mode[0]) >> 3) & 0x1)
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 4) & 0x1)
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 5) & 0x1)
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET(r) ((((r).txq_flush_mode[0]) >> 6) & 0x1)
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET(r) ((((r).txq_flush_mode[0]) >> 7) & 0x1)
#define BCM53115_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_FLUSH_MODE.
 *
 */
#define BCM53115_A0_READ_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TXQ_FLUSH_MODEr,(r._txq_flush_mode),1)
#define BCM53115_A0_WRITE_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TXQ_FLUSH_MODEr,&(r._txq_flush_mode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_FLUSH_MODEr BCM53115_A0_TXQ_FLUSH_MODEr
#define TXQ_FLUSH_MODEr_SIZE BCM53115_A0_TXQ_FLUSH_MODEr_SIZE
typedef BCM53115_A0_TXQ_FLUSH_MODEr_t TXQ_FLUSH_MODEr_t;
#define TXQ_FLUSH_MODEr_CLR BCM53115_A0_TXQ_FLUSH_MODEr_CLR
#define TXQ_FLUSH_MODEr_SET BCM53115_A0_TXQ_FLUSH_MODEr_SET
#define TXQ_FLUSH_MODEr_GET BCM53115_A0_TXQ_FLUSH_MODEr_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET BCM53115_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET BCM53115_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET BCM53115_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET BCM53115_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET BCM53115_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET BCM53115_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET BCM53115_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET BCM53115_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET BCM53115_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET BCM53115_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET BCM53115_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET BCM53115_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET BCM53115_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET BCM53115_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET BCM53115_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET BCM53115_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET
#define READ_TXQ_FLUSH_MODEr BCM53115_A0_READ_TXQ_FLUSH_MODEr
#define WRITE_TXQ_FLUSH_MODEr BCM53115_A0_WRITE_TXQ_FLUSH_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXQ_FLUSH_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for TX Registrer
 * SIZE:     16
 * FIELDS:
 *     TX_PAUSE_PASS    TX pause pass through map.1 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_TX_PAUSE_PASSr 0x0000003a

#define BCM53115_A0_TX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program TX_PAUSE_PASS.
 *
 */
typedef union BCM53115_A0_TX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t tx_pause_pass[1];
	uint32_t _tx_pause_pass;
} BCM53115_A0_TX_PAUSE_PASSr_t;

#define BCM53115_A0_TX_PAUSE_PASSr_CLR(r) (r).tx_pause_pass[0] = 0
#define BCM53115_A0_TX_PAUSE_PASSr_SET(r,d) (r).tx_pause_pass[0] = d
#define BCM53115_A0_TX_PAUSE_PASSr_GET(r) (r).tx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET(r) (((r).tx_pause_pass[0]) & 0x1ff)
#define BCM53115_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_TX_PAUSE_PASSr_RESERVED_Rf_GET(r) ((((r).tx_pause_pass[0]) >> 9) & 0x7f)
#define BCM53115_A0_TX_PAUSE_PASSr_RESERVED_Rf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TX_PAUSE_PASS.
 *
 */
#define BCM53115_A0_READ_TX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM53115_A0_TX_PAUSE_PASSr,(r._tx_pause_pass),2)
#define BCM53115_A0_WRITE_TX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM53115_A0_TX_PAUSE_PASSr,&(r._tx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PAUSE_PASSr BCM53115_A0_TX_PAUSE_PASSr
#define TX_PAUSE_PASSr_SIZE BCM53115_A0_TX_PAUSE_PASSr_SIZE
typedef BCM53115_A0_TX_PAUSE_PASSr_t TX_PAUSE_PASSr_t;
#define TX_PAUSE_PASSr_CLR BCM53115_A0_TX_PAUSE_PASSr_CLR
#define TX_PAUSE_PASSr_SET BCM53115_A0_TX_PAUSE_PASSr_SET
#define TX_PAUSE_PASSr_GET BCM53115_A0_TX_PAUSE_PASSr_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET BCM53115_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET BCM53115_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET
#define TX_PAUSE_PASSr_RESERVED_Rf_GET BCM53115_A0_TX_PAUSE_PASSr_RESERVED_Rf_GET
#define TX_PAUSE_PASSr_RESERVED_Rf_SET BCM53115_A0_TX_PAUSE_PASSr_RESERVED_Rf_SET
#define READ_TX_PAUSE_PASSr BCM53115_A0_READ_TX_PAUSE_PASSr
#define WRITE_TX_PAUSE_PASSr BCM53115_A0_WRITE_TX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxBroadcastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXBROADCASTPKTSr 0x00002010

#define BCM53115_A0_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts.
 *
 */
typedef union BCM53115_A0_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts[1];
	uint32_t _txbroadcastpkts;
} BCM53115_A0_TXBROADCASTPKTSr_t;

#define BCM53115_A0_TXBROADCASTPKTSr_CLR(r) (r).txbroadcastpkts[0] = 0
#define BCM53115_A0_TXBROADCASTPKTSr_SET(r,d) (r).txbroadcastpkts[0] = d
#define BCM53115_A0_TXBROADCASTPKTSr_GET(r) (r).txbroadcastpkts[0]


/*
 * These macros can be used to access TxBroadcastPkts.
 *
 */
#define BCM53115_A0_READ_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXBROADCASTPKTSr,(r._txbroadcastpkts),4)
#define BCM53115_A0_WRITE_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXBROADCASTPKTSr,&(r._txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTSr BCM53115_A0_TXBROADCASTPKTSr
#define TXBROADCASTPKTSr_SIZE BCM53115_A0_TXBROADCASTPKTSr_SIZE
typedef BCM53115_A0_TXBROADCASTPKTSr_t TXBROADCASTPKTSr_t;
#define TXBROADCASTPKTSr_CLR BCM53115_A0_TXBROADCASTPKTSr_CLR
#define TXBROADCASTPKTSr_SET BCM53115_A0_TXBROADCASTPKTSr_SET
#define TXBROADCASTPKTSr_GET BCM53115_A0_TXBROADCASTPKTSr_GET
#define READ_TXBROADCASTPKTSr BCM53115_A0_READ_TXBROADCASTPKTSr
#define WRITE_TXBROADCASTPKTSr BCM53115_A0_WRITE_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxCollisions
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXCOLLISIONSr 0x0000201c

#define BCM53115_A0_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions.
 *
 */
typedef union BCM53115_A0_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txcollisions[1];
	uint32_t _txcollisions;
} BCM53115_A0_TXCOLLISIONSr_t;

#define BCM53115_A0_TXCOLLISIONSr_CLR(r) (r).txcollisions[0] = 0
#define BCM53115_A0_TXCOLLISIONSr_SET(r,d) (r).txcollisions[0] = d
#define BCM53115_A0_TXCOLLISIONSr_GET(r) (r).txcollisions[0]


/*
 * These macros can be used to access TxCollisions.
 *
 */
#define BCM53115_A0_READ_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXCOLLISIONSr,(r._txcollisions),4)
#define BCM53115_A0_WRITE_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXCOLLISIONSr,&(r._txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONSr BCM53115_A0_TXCOLLISIONSr
#define TXCOLLISIONSr_SIZE BCM53115_A0_TXCOLLISIONSr_SIZE
typedef BCM53115_A0_TXCOLLISIONSr_t TXCOLLISIONSr_t;
#define TXCOLLISIONSr_CLR BCM53115_A0_TXCOLLISIONSr_CLR
#define TXCOLLISIONSr_SET BCM53115_A0_TXCOLLISIONSr_SET
#define TXCOLLISIONSr_GET BCM53115_A0_TXCOLLISIONSr_GET
#define READ_TXCOLLISIONSr BCM53115_A0_READ_TXCOLLISIONSr
#define WRITE_TXCOLLISIONSr BCM53115_A0_WRITE_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxDeferredTransmit
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXDEFERREDTRANSMITr 0x00002028

#define BCM53115_A0_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit.
 *
 */
typedef union BCM53115_A0_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit[1];
	uint32_t _txdeferredtransmit;
} BCM53115_A0_TXDEFERREDTRANSMITr_t;

#define BCM53115_A0_TXDEFERREDTRANSMITr_CLR(r) (r).txdeferredtransmit[0] = 0
#define BCM53115_A0_TXDEFERREDTRANSMITr_SET(r,d) (r).txdeferredtransmit[0] = d
#define BCM53115_A0_TXDEFERREDTRANSMITr_GET(r) (r).txdeferredtransmit[0]


/*
 * These macros can be used to access TxDeferredTransmit.
 *
 */
#define BCM53115_A0_READ_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXDEFERREDTRANSMITr,(r._txdeferredtransmit),4)
#define BCM53115_A0_WRITE_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXDEFERREDTRANSMITr,&(r._txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMITr BCM53115_A0_TXDEFERREDTRANSMITr
#define TXDEFERREDTRANSMITr_SIZE BCM53115_A0_TXDEFERREDTRANSMITr_SIZE
typedef BCM53115_A0_TXDEFERREDTRANSMITr_t TXDEFERREDTRANSMITr_t;
#define TXDEFERREDTRANSMITr_CLR BCM53115_A0_TXDEFERREDTRANSMITr_CLR
#define TXDEFERREDTRANSMITr_SET BCM53115_A0_TXDEFERREDTRANSMITr_SET
#define TXDEFERREDTRANSMITr_GET BCM53115_A0_TXDEFERREDTRANSMITr_GET
#define READ_TXDEFERREDTRANSMITr BCM53115_A0_READ_TXDEFERREDTRANSMITr
#define WRITE_TXDEFERREDTRANSMITr BCM53115_A0_WRITE_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxDropPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXDROPPKTSr 0x00002008

#define BCM53115_A0_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts.
 *
 */
typedef union BCM53115_A0_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t txdroppkts[1];
	uint32_t _txdroppkts;
} BCM53115_A0_TXDROPPKTSr_t;

#define BCM53115_A0_TXDROPPKTSr_CLR(r) (r).txdroppkts[0] = 0
#define BCM53115_A0_TXDROPPKTSr_SET(r,d) (r).txdroppkts[0] = d
#define BCM53115_A0_TXDROPPKTSr_GET(r) (r).txdroppkts[0]


/*
 * These macros can be used to access TxDropPkts.
 *
 */
#define BCM53115_A0_READ_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXDROPPKTSr,(r._txdroppkts),4)
#define BCM53115_A0_WRITE_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXDROPPKTSr,&(r._txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTSr BCM53115_A0_TXDROPPKTSr
#define TXDROPPKTSr_SIZE BCM53115_A0_TXDROPPKTSr_SIZE
typedef BCM53115_A0_TXDROPPKTSr_t TXDROPPKTSr_t;
#define TXDROPPKTSr_CLR BCM53115_A0_TXDROPPKTSr_CLR
#define TXDROPPKTSr_SET BCM53115_A0_TXDROPPKTSr_SET
#define TXDROPPKTSr_GET BCM53115_A0_TXDROPPKTSr_GET
#define READ_TXDROPPKTSr BCM53115_A0_READ_TXDROPPKTSr
#define WRITE_TXDROPPKTSr BCM53115_A0_WRITE_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxExcessiveCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXEXCESSIVECOLLISIONr 0x00002030

#define BCM53115_A0_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision.
 *
 */
typedef union BCM53115_A0_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision[1];
	uint32_t _txexcessivecollision;
} BCM53115_A0_TXEXCESSIVECOLLISIONr_t;

#define BCM53115_A0_TXEXCESSIVECOLLISIONr_CLR(r) (r).txexcessivecollision[0] = 0
#define BCM53115_A0_TXEXCESSIVECOLLISIONr_SET(r,d) (r).txexcessivecollision[0] = d
#define BCM53115_A0_TXEXCESSIVECOLLISIONr_GET(r) (r).txexcessivecollision[0]


/*
 * These macros can be used to access TxExcessiveCollision.
 *
 */
#define BCM53115_A0_READ_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXEXCESSIVECOLLISIONr,(r._txexcessivecollision),4)
#define BCM53115_A0_WRITE_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXEXCESSIVECOLLISIONr,&(r._txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISIONr BCM53115_A0_TXEXCESSIVECOLLISIONr
#define TXEXCESSIVECOLLISIONr_SIZE BCM53115_A0_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53115_A0_TXEXCESSIVECOLLISIONr_t TXEXCESSIVECOLLISIONr_t;
#define TXEXCESSIVECOLLISIONr_CLR BCM53115_A0_TXEXCESSIVECOLLISIONr_CLR
#define TXEXCESSIVECOLLISIONr_SET BCM53115_A0_TXEXCESSIVECOLLISIONr_SET
#define TXEXCESSIVECOLLISIONr_GET BCM53115_A0_TXEXCESSIVECOLLISIONr_GET
#define READ_TXEXCESSIVECOLLISIONr BCM53115_A0_READ_TXEXCESSIVECOLLISIONr
#define WRITE_TXEXCESSIVECOLLISIONr BCM53115_A0_WRITE_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxFrameInDisc
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXFRAMEINDISCr 0x00002034

#define BCM53115_A0_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc.
 *
 */
typedef union BCM53115_A0_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t txframeindisc[1];
	uint32_t _txframeindisc;
} BCM53115_A0_TXFRAMEINDISCr_t;

#define BCM53115_A0_TXFRAMEINDISCr_CLR(r) (r).txframeindisc[0] = 0
#define BCM53115_A0_TXFRAMEINDISCr_SET(r,d) (r).txframeindisc[0] = d
#define BCM53115_A0_TXFRAMEINDISCr_GET(r) (r).txframeindisc[0]


/*
 * These macros can be used to access TxFrameInDisc.
 *
 */
#define BCM53115_A0_READ_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXFRAMEINDISCr,(r._txframeindisc),4)
#define BCM53115_A0_WRITE_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXFRAMEINDISCr,&(r._txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISCr BCM53115_A0_TXFRAMEINDISCr
#define TXFRAMEINDISCr_SIZE BCM53115_A0_TXFRAMEINDISCr_SIZE
typedef BCM53115_A0_TXFRAMEINDISCr_t TXFRAMEINDISCr_t;
#define TXFRAMEINDISCr_CLR BCM53115_A0_TXFRAMEINDISCr_CLR
#define TXFRAMEINDISCr_SET BCM53115_A0_TXFRAMEINDISCr_SET
#define TXFRAMEINDISCr_GET BCM53115_A0_TXFRAMEINDISCr_GET
#define READ_TXFRAMEINDISCr BCM53115_A0_READ_TXFRAMEINDISCr
#define WRITE_TXFRAMEINDISCr BCM53115_A0_WRITE_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxLateCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXLATECOLLISIONr 0x0000202c

#define BCM53115_A0_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision.
 *
 */
typedef union BCM53115_A0_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txlatecollision[1];
	uint32_t _txlatecollision;
} BCM53115_A0_TXLATECOLLISIONr_t;

#define BCM53115_A0_TXLATECOLLISIONr_CLR(r) (r).txlatecollision[0] = 0
#define BCM53115_A0_TXLATECOLLISIONr_SET(r,d) (r).txlatecollision[0] = d
#define BCM53115_A0_TXLATECOLLISIONr_GET(r) (r).txlatecollision[0]


/*
 * These macros can be used to access TxLateCollision.
 *
 */
#define BCM53115_A0_READ_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXLATECOLLISIONr,(r._txlatecollision),4)
#define BCM53115_A0_WRITE_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXLATECOLLISIONr,&(r._txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISIONr BCM53115_A0_TXLATECOLLISIONr
#define TXLATECOLLISIONr_SIZE BCM53115_A0_TXLATECOLLISIONr_SIZE
typedef BCM53115_A0_TXLATECOLLISIONr_t TXLATECOLLISIONr_t;
#define TXLATECOLLISIONr_CLR BCM53115_A0_TXLATECOLLISIONr_CLR
#define TXLATECOLLISIONr_SET BCM53115_A0_TXLATECOLLISIONr_SET
#define TXLATECOLLISIONr_GET BCM53115_A0_TXLATECOLLISIONr_GET
#define READ_TXLATECOLLISIONr BCM53115_A0_READ_TXLATECOLLISIONr
#define WRITE_TXLATECOLLISIONr BCM53115_A0_WRITE_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxMulticastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXMULTICASTPKTSr 0x00002014

#define BCM53115_A0_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts.
 *
 */
typedef union BCM53115_A0_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts[1];
	uint32_t _txmulticastpkts;
} BCM53115_A0_TXMULTICASTPKTSr_t;

#define BCM53115_A0_TXMULTICASTPKTSr_CLR(r) (r).txmulticastpkts[0] = 0
#define BCM53115_A0_TXMULTICASTPKTSr_SET(r,d) (r).txmulticastpkts[0] = d
#define BCM53115_A0_TXMULTICASTPKTSr_GET(r) (r).txmulticastpkts[0]


/*
 * These macros can be used to access TxMulticastPkts.
 *
 */
#define BCM53115_A0_READ_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXMULTICASTPKTSr,(r._txmulticastpkts),4)
#define BCM53115_A0_WRITE_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXMULTICASTPKTSr,&(r._txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTSr BCM53115_A0_TXMULTICASTPKTSr
#define TXMULTICASTPKTSr_SIZE BCM53115_A0_TXMULTICASTPKTSr_SIZE
typedef BCM53115_A0_TXMULTICASTPKTSr_t TXMULTICASTPKTSr_t;
#define TXMULTICASTPKTSr_CLR BCM53115_A0_TXMULTICASTPKTSr_CLR
#define TXMULTICASTPKTSr_SET BCM53115_A0_TXMULTICASTPKTSr_SET
#define TXMULTICASTPKTSr_GET BCM53115_A0_TXMULTICASTPKTSr_GET
#define READ_TXMULTICASTPKTSr BCM53115_A0_READ_TXMULTICASTPKTSr
#define WRITE_TXMULTICASTPKTSr BCM53115_A0_WRITE_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxMultipleCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXMULTIPLECOLLISIONr 0x00002024

#define BCM53115_A0_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision.
 *
 */
typedef union BCM53115_A0_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision[1];
	uint32_t _txmultiplecollision;
} BCM53115_A0_TXMULTIPLECOLLISIONr_t;

#define BCM53115_A0_TXMULTIPLECOLLISIONr_CLR(r) (r).txmultiplecollision[0] = 0
#define BCM53115_A0_TXMULTIPLECOLLISIONr_SET(r,d) (r).txmultiplecollision[0] = d
#define BCM53115_A0_TXMULTIPLECOLLISIONr_GET(r) (r).txmultiplecollision[0]


/*
 * These macros can be used to access TxMultipleCollision.
 *
 */
#define BCM53115_A0_READ_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXMULTIPLECOLLISIONr,(r._txmultiplecollision),4)
#define BCM53115_A0_WRITE_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXMULTIPLECOLLISIONr,&(r._txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISIONr BCM53115_A0_TXMULTIPLECOLLISIONr
#define TXMULTIPLECOLLISIONr_SIZE BCM53115_A0_TXMULTIPLECOLLISIONr_SIZE
typedef BCM53115_A0_TXMULTIPLECOLLISIONr_t TXMULTIPLECOLLISIONr_t;
#define TXMULTIPLECOLLISIONr_CLR BCM53115_A0_TXMULTIPLECOLLISIONr_CLR
#define TXMULTIPLECOLLISIONr_SET BCM53115_A0_TXMULTIPLECOLLISIONr_SET
#define TXMULTIPLECOLLISIONr_GET BCM53115_A0_TXMULTIPLECOLLISIONr_GET
#define READ_TXMULTIPLECOLLISIONr BCM53115_A0_READ_TXMULTIPLECOLLISIONr
#define WRITE_TXMULTIPLECOLLISIONr BCM53115_A0_WRITE_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53115_A0_TXOCTETSr 0x00002000

#define BCM53115_A0_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets.
 *
 */
typedef union BCM53115_A0_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t txoctets[2];
	uint32_t _txoctets;
} BCM53115_A0_TXOCTETSr_t;

#define BCM53115_A0_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._txoctets), 0, sizeof(BCM53115_A0_TXOCTETSr_t))
#define BCM53115_A0_TXOCTETSr_SET(r,i,d) (r).txoctets[i] = d
#define BCM53115_A0_TXOCTETSr_GET(r,i) (r).txoctets[i]


/*
 * These macros can be used to access TxOctets.
 *
 */
#define BCM53115_A0_READ_TXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXOCTETSr,(r._txoctets),8)
#define BCM53115_A0_WRITE_TXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXOCTETSr,&(r._txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETSr BCM53115_A0_TXOCTETSr
#define TXOCTETSr_SIZE BCM53115_A0_TXOCTETSr_SIZE
typedef BCM53115_A0_TXOCTETSr_t TXOCTETSr_t;
#define TXOCTETSr_CLR BCM53115_A0_TXOCTETSr_CLR
#define TXOCTETSr_SET BCM53115_A0_TXOCTETSr_SET
#define TXOCTETSr_GET BCM53115_A0_TXOCTETSr_GET
#define READ_TXOCTETSr BCM53115_A0_READ_TXOCTETSr
#define WRITE_TXOCTETSr BCM53115_A0_WRITE_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxPausePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXPAUSEPKTSr 0x00002038

#define BCM53115_A0_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts.
 *
 */
typedef union BCM53115_A0_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t txpausepkts[1];
	uint32_t _txpausepkts;
} BCM53115_A0_TXPAUSEPKTSr_t;

#define BCM53115_A0_TXPAUSEPKTSr_CLR(r) (r).txpausepkts[0] = 0
#define BCM53115_A0_TXPAUSEPKTSr_SET(r,d) (r).txpausepkts[0] = d
#define BCM53115_A0_TXPAUSEPKTSr_GET(r) (r).txpausepkts[0]


/*
 * These macros can be used to access TxPausePkts.
 *
 */
#define BCM53115_A0_READ_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXPAUSEPKTSr,(r._txpausepkts),4)
#define BCM53115_A0_WRITE_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXPAUSEPKTSr,&(r._txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTSr BCM53115_A0_TXPAUSEPKTSr
#define TXPAUSEPKTSr_SIZE BCM53115_A0_TXPAUSEPKTSr_SIZE
typedef BCM53115_A0_TXPAUSEPKTSr_t TXPAUSEPKTSr_t;
#define TXPAUSEPKTSr_CLR BCM53115_A0_TXPAUSEPKTSr_CLR
#define TXPAUSEPKTSr_SET BCM53115_A0_TXPAUSEPKTSr_SET
#define TXPAUSEPKTSr_GET BCM53115_A0_TXPAUSEPKTSr_GET
#define READ_TXPAUSEPKTSr BCM53115_A0_READ_TXPAUSEPKTSr
#define WRITE_TXPAUSEPKTSr BCM53115_A0_WRITE_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxQPKTQ0
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXQPKTQ0r 0x0000200c

#define BCM53115_A0_TXQPKTQ0r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ0.
 *
 */
typedef union BCM53115_A0_TXQPKTQ0r_s {
	uint32_t v[1];
	uint32_t txqpktq0[1];
	uint32_t _txqpktq0;
} BCM53115_A0_TXQPKTQ0r_t;

#define BCM53115_A0_TXQPKTQ0r_CLR(r) (r).txqpktq0[0] = 0
#define BCM53115_A0_TXQPKTQ0r_SET(r,d) (r).txqpktq0[0] = d
#define BCM53115_A0_TXQPKTQ0r_GET(r) (r).txqpktq0[0]


/*
 * These macros can be used to access TxQPKTQ0.
 *
 */
#define BCM53115_A0_READ_TXQPKTQ0r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXQPKTQ0r,(r._txqpktq0),4)
#define BCM53115_A0_WRITE_TXQPKTQ0r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXQPKTQ0r,&(r._txqpktq0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ0r BCM53115_A0_TXQPKTQ0r
#define TXQPKTQ0r_SIZE BCM53115_A0_TXQPKTQ0r_SIZE
typedef BCM53115_A0_TXQPKTQ0r_t TXQPKTQ0r_t;
#define TXQPKTQ0r_CLR BCM53115_A0_TXQPKTQ0r_CLR
#define TXQPKTQ0r_SET BCM53115_A0_TXQPKTQ0r_SET
#define TXQPKTQ0r_GET BCM53115_A0_TXQPKTQ0r_GET
#define READ_TXQPKTQ0r BCM53115_A0_READ_TXQPKTQ0r
#define WRITE_TXQPKTQ0r BCM53115_A0_WRITE_TXQPKTQ0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXQPKTQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxQPKTQ1
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXQPKTQ1r 0x0000203c

#define BCM53115_A0_TXQPKTQ1r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ1.
 *
 */
typedef union BCM53115_A0_TXQPKTQ1r_s {
	uint32_t v[1];
	uint32_t txqpktq1[1];
	uint32_t _txqpktq1;
} BCM53115_A0_TXQPKTQ1r_t;

#define BCM53115_A0_TXQPKTQ1r_CLR(r) (r).txqpktq1[0] = 0
#define BCM53115_A0_TXQPKTQ1r_SET(r,d) (r).txqpktq1[0] = d
#define BCM53115_A0_TXQPKTQ1r_GET(r) (r).txqpktq1[0]


/*
 * These macros can be used to access TxQPKTQ1.
 *
 */
#define BCM53115_A0_READ_TXQPKTQ1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXQPKTQ1r,(r._txqpktq1),4)
#define BCM53115_A0_WRITE_TXQPKTQ1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXQPKTQ1r,&(r._txqpktq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ1r BCM53115_A0_TXQPKTQ1r
#define TXQPKTQ1r_SIZE BCM53115_A0_TXQPKTQ1r_SIZE
typedef BCM53115_A0_TXQPKTQ1r_t TXQPKTQ1r_t;
#define TXQPKTQ1r_CLR BCM53115_A0_TXQPKTQ1r_CLR
#define TXQPKTQ1r_SET BCM53115_A0_TXQPKTQ1r_SET
#define TXQPKTQ1r_GET BCM53115_A0_TXQPKTQ1r_GET
#define READ_TXQPKTQ1r BCM53115_A0_READ_TXQPKTQ1r
#define WRITE_TXQPKTQ1r BCM53115_A0_WRITE_TXQPKTQ1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXQPKTQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxQPKTQ2
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXQPKTQ2r 0x00002040

#define BCM53115_A0_TXQPKTQ2r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ2.
 *
 */
typedef union BCM53115_A0_TXQPKTQ2r_s {
	uint32_t v[1];
	uint32_t txqpktq2[1];
	uint32_t _txqpktq2;
} BCM53115_A0_TXQPKTQ2r_t;

#define BCM53115_A0_TXQPKTQ2r_CLR(r) (r).txqpktq2[0] = 0
#define BCM53115_A0_TXQPKTQ2r_SET(r,d) (r).txqpktq2[0] = d
#define BCM53115_A0_TXQPKTQ2r_GET(r) (r).txqpktq2[0]


/*
 * These macros can be used to access TxQPKTQ2.
 *
 */
#define BCM53115_A0_READ_TXQPKTQ2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXQPKTQ2r,(r._txqpktq2),4)
#define BCM53115_A0_WRITE_TXQPKTQ2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXQPKTQ2r,&(r._txqpktq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ2r BCM53115_A0_TXQPKTQ2r
#define TXQPKTQ2r_SIZE BCM53115_A0_TXQPKTQ2r_SIZE
typedef BCM53115_A0_TXQPKTQ2r_t TXQPKTQ2r_t;
#define TXQPKTQ2r_CLR BCM53115_A0_TXQPKTQ2r_CLR
#define TXQPKTQ2r_SET BCM53115_A0_TXQPKTQ2r_SET
#define TXQPKTQ2r_GET BCM53115_A0_TXQPKTQ2r_GET
#define READ_TXQPKTQ2r BCM53115_A0_READ_TXQPKTQ2r
#define WRITE_TXQPKTQ2r BCM53115_A0_WRITE_TXQPKTQ2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXQPKTQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxQPKTQ3
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXQPKTQ3r 0x00002044

#define BCM53115_A0_TXQPKTQ3r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ3.
 *
 */
typedef union BCM53115_A0_TXQPKTQ3r_s {
	uint32_t v[1];
	uint32_t txqpktq3[1];
	uint32_t _txqpktq3;
} BCM53115_A0_TXQPKTQ3r_t;

#define BCM53115_A0_TXQPKTQ3r_CLR(r) (r).txqpktq3[0] = 0
#define BCM53115_A0_TXQPKTQ3r_SET(r,d) (r).txqpktq3[0] = d
#define BCM53115_A0_TXQPKTQ3r_GET(r) (r).txqpktq3[0]


/*
 * These macros can be used to access TxQPKTQ3.
 *
 */
#define BCM53115_A0_READ_TXQPKTQ3r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXQPKTQ3r,(r._txqpktq3),4)
#define BCM53115_A0_WRITE_TXQPKTQ3r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXQPKTQ3r,&(r._txqpktq3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ3r BCM53115_A0_TXQPKTQ3r
#define TXQPKTQ3r_SIZE BCM53115_A0_TXQPKTQ3r_SIZE
typedef BCM53115_A0_TXQPKTQ3r_t TXQPKTQ3r_t;
#define TXQPKTQ3r_CLR BCM53115_A0_TXQPKTQ3r_CLR
#define TXQPKTQ3r_SET BCM53115_A0_TXQPKTQ3r_SET
#define TXQPKTQ3r_GET BCM53115_A0_TXQPKTQ3r_GET
#define READ_TXQPKTQ3r BCM53115_A0_READ_TXQPKTQ3r
#define WRITE_TXQPKTQ3r BCM53115_A0_WRITE_TXQPKTQ3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXQPKTQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxQPKTQ4
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXQPKTQ4r 0x00002048

#define BCM53115_A0_TXQPKTQ4r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ4.
 *
 */
typedef union BCM53115_A0_TXQPKTQ4r_s {
	uint32_t v[1];
	uint32_t txqpktq4[1];
	uint32_t _txqpktq4;
} BCM53115_A0_TXQPKTQ4r_t;

#define BCM53115_A0_TXQPKTQ4r_CLR(r) (r).txqpktq4[0] = 0
#define BCM53115_A0_TXQPKTQ4r_SET(r,d) (r).txqpktq4[0] = d
#define BCM53115_A0_TXQPKTQ4r_GET(r) (r).txqpktq4[0]


/*
 * These macros can be used to access TxQPKTQ4.
 *
 */
#define BCM53115_A0_READ_TXQPKTQ4r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXQPKTQ4r,(r._txqpktq4),4)
#define BCM53115_A0_WRITE_TXQPKTQ4r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXQPKTQ4r,&(r._txqpktq4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ4r BCM53115_A0_TXQPKTQ4r
#define TXQPKTQ4r_SIZE BCM53115_A0_TXQPKTQ4r_SIZE
typedef BCM53115_A0_TXQPKTQ4r_t TXQPKTQ4r_t;
#define TXQPKTQ4r_CLR BCM53115_A0_TXQPKTQ4r_CLR
#define TXQPKTQ4r_SET BCM53115_A0_TXQPKTQ4r_SET
#define TXQPKTQ4r_GET BCM53115_A0_TXQPKTQ4r_GET
#define READ_TXQPKTQ4r BCM53115_A0_READ_TXQPKTQ4r
#define WRITE_TXQPKTQ4r BCM53115_A0_WRITE_TXQPKTQ4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXQPKTQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxQPKTQ5
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXQPKTQ5r 0x0000204c

#define BCM53115_A0_TXQPKTQ5r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ5.
 *
 */
typedef union BCM53115_A0_TXQPKTQ5r_s {
	uint32_t v[1];
	uint32_t txqpktq5[1];
	uint32_t _txqpktq5;
} BCM53115_A0_TXQPKTQ5r_t;

#define BCM53115_A0_TXQPKTQ5r_CLR(r) (r).txqpktq5[0] = 0
#define BCM53115_A0_TXQPKTQ5r_SET(r,d) (r).txqpktq5[0] = d
#define BCM53115_A0_TXQPKTQ5r_GET(r) (r).txqpktq5[0]


/*
 * These macros can be used to access TxQPKTQ5.
 *
 */
#define BCM53115_A0_READ_TXQPKTQ5r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXQPKTQ5r,(r._txqpktq5),4)
#define BCM53115_A0_WRITE_TXQPKTQ5r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXQPKTQ5r,&(r._txqpktq5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ5r BCM53115_A0_TXQPKTQ5r
#define TXQPKTQ5r_SIZE BCM53115_A0_TXQPKTQ5r_SIZE
typedef BCM53115_A0_TXQPKTQ5r_t TXQPKTQ5r_t;
#define TXQPKTQ5r_CLR BCM53115_A0_TXQPKTQ5r_CLR
#define TXQPKTQ5r_SET BCM53115_A0_TXQPKTQ5r_SET
#define TXQPKTQ5r_GET BCM53115_A0_TXQPKTQ5r_GET
#define READ_TXQPKTQ5r BCM53115_A0_READ_TXQPKTQ5r
#define WRITE_TXQPKTQ5r BCM53115_A0_WRITE_TXQPKTQ5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXQPKTQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxSingleCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXSINGLECOLLISIONr 0x00002020

#define BCM53115_A0_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision.
 *
 */
typedef union BCM53115_A0_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txsinglecollision[1];
	uint32_t _txsinglecollision;
} BCM53115_A0_TXSINGLECOLLISIONr_t;

#define BCM53115_A0_TXSINGLECOLLISIONr_CLR(r) (r).txsinglecollision[0] = 0
#define BCM53115_A0_TXSINGLECOLLISIONr_SET(r,d) (r).txsinglecollision[0] = d
#define BCM53115_A0_TXSINGLECOLLISIONr_GET(r) (r).txsinglecollision[0]


/*
 * These macros can be used to access TxSingleCollision.
 *
 */
#define BCM53115_A0_READ_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXSINGLECOLLISIONr,(r._txsinglecollision),4)
#define BCM53115_A0_WRITE_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXSINGLECOLLISIONr,&(r._txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISIONr BCM53115_A0_TXSINGLECOLLISIONr
#define TXSINGLECOLLISIONr_SIZE BCM53115_A0_TXSINGLECOLLISIONr_SIZE
typedef BCM53115_A0_TXSINGLECOLLISIONr_t TXSINGLECOLLISIONr_t;
#define TXSINGLECOLLISIONr_CLR BCM53115_A0_TXSINGLECOLLISIONr_CLR
#define TXSINGLECOLLISIONr_SET BCM53115_A0_TXSINGLECOLLISIONr_SET
#define TXSINGLECOLLISIONr_GET BCM53115_A0_TXSINGLECOLLISIONr_GET
#define READ_TXSINGLECOLLISIONr BCM53115_A0_READ_TXSINGLECOLLISIONr
#define WRITE_TXSINGLECOLLISIONr BCM53115_A0_WRITE_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  TxUnicastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53115_A0_TXUNICASTPKTSr 0x00002018

#define BCM53115_A0_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts.
 *
 */
typedef union BCM53115_A0_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txunicastpkts[1];
	uint32_t _txunicastpkts;
} BCM53115_A0_TXUNICASTPKTSr_t;

#define BCM53115_A0_TXUNICASTPKTSr_CLR(r) (r).txunicastpkts[0] = 0
#define BCM53115_A0_TXUNICASTPKTSr_SET(r,d) (r).txunicastpkts[0] = d
#define BCM53115_A0_TXUNICASTPKTSr_GET(r) (r).txunicastpkts[0]


/*
 * These macros can be used to access TxUnicastPkts.
 *
 */
#define BCM53115_A0_READ_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53115_A0_TXUNICASTPKTSr,(r._txunicastpkts),4)
#define BCM53115_A0_WRITE_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53115_A0_TXUNICASTPKTSr,&(r._txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTSr BCM53115_A0_TXUNICASTPKTSr
#define TXUNICASTPKTSr_SIZE BCM53115_A0_TXUNICASTPKTSr_SIZE
typedef BCM53115_A0_TXUNICASTPKTSr_t TXUNICASTPKTSr_t;
#define TXUNICASTPKTSr_CLR BCM53115_A0_TXUNICASTPKTSr_CLR
#define TXUNICASTPKTSr_SET BCM53115_A0_TXUNICASTPKTSr_SET
#define TXUNICASTPKTSr_GET BCM53115_A0_TXUNICASTPKTSr_GET
#define READ_TXUNICASTPKTSr BCM53115_A0_READ_TXUNICASTPKTSr
#define WRITE_TXUNICASTPKTSr BCM53115_A0_WRITE_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_0_A
 * BLOCKS:   SYS
 * DESC:     UDF_0_A_N(0~8) for IPv4 Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_0_A_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_0_Ar 0x0000a110

#define BCM53115_A0_UDF_0_Ar_SIZE 1

/*
 * This structure should be used to declare and program UDF_0_A.
 *
 */
typedef union BCM53115_A0_UDF_0_Ar_s {
	uint32_t v[1];
	uint32_t udf_0_a[1];
	uint32_t _udf_0_a;
} BCM53115_A0_UDF_0_Ar_t;

#define BCM53115_A0_UDF_0_Ar_CLR(r) (r).udf_0_a[0] = 0
#define BCM53115_A0_UDF_0_Ar_SET(r,d) (r).udf_0_a[0] = d
#define BCM53115_A0_UDF_0_Ar_GET(r) (r).udf_0_a[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_0_Ar_CFG_UDF_0_A_0_8f_GET(r) (((r).udf_0_a[0]) & 0xff)
#define BCM53115_A0_UDF_0_Ar_CFG_UDF_0_A_0_8f_SET(r,f) (r).udf_0_a[0]=(((r).udf_0_a[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_0_A.
 *
 */
#define BCM53115_A0_READ_UDF_0_Ar(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_0_Ar+(1*(i)),(r._udf_0_a),1)
#define BCM53115_A0_WRITE_UDF_0_Ar(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_0_Ar+(1*(i)),&(r._udf_0_a),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_0_Ar BCM53115_A0_UDF_0_Ar
#define UDF_0_Ar_SIZE BCM53115_A0_UDF_0_Ar_SIZE
typedef BCM53115_A0_UDF_0_Ar_t UDF_0_Ar_t;
#define UDF_0_Ar_CLR BCM53115_A0_UDF_0_Ar_CLR
#define UDF_0_Ar_SET BCM53115_A0_UDF_0_Ar_SET
#define UDF_0_Ar_GET BCM53115_A0_UDF_0_Ar_GET
#define UDF_0_Ar_CFG_UDF_0_A_0_8f_GET BCM53115_A0_UDF_0_Ar_CFG_UDF_0_A_0_8f_GET
#define UDF_0_Ar_CFG_UDF_0_A_0_8f_SET BCM53115_A0_UDF_0_Ar_CFG_UDF_0_A_0_8f_SET
#define READ_UDF_0_Ar BCM53115_A0_READ_UDF_0_Ar
#define WRITE_UDF_0_Ar BCM53115_A0_WRITE_UDF_0_Ar

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_0_Ar'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_0_B
 * BLOCKS:   SYS
 * DESC:     UDF_0_B_N(0~8) for IPv6 Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_0_B_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_0_Br 0x0000a140

#define BCM53115_A0_UDF_0_Br_SIZE 1

/*
 * This structure should be used to declare and program UDF_0_B.
 *
 */
typedef union BCM53115_A0_UDF_0_Br_s {
	uint32_t v[1];
	uint32_t udf_0_b[1];
	uint32_t _udf_0_b;
} BCM53115_A0_UDF_0_Br_t;

#define BCM53115_A0_UDF_0_Br_CLR(r) (r).udf_0_b[0] = 0
#define BCM53115_A0_UDF_0_Br_SET(r,d) (r).udf_0_b[0] = d
#define BCM53115_A0_UDF_0_Br_GET(r) (r).udf_0_b[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_0_Br_CFG_UDF_0_B_0_8f_GET(r) (((r).udf_0_b[0]) & 0xff)
#define BCM53115_A0_UDF_0_Br_CFG_UDF_0_B_0_8f_SET(r,f) (r).udf_0_b[0]=(((r).udf_0_b[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_0_B.
 *
 */
#define BCM53115_A0_READ_UDF_0_Br(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_0_Br+(1*(i)),(r._udf_0_b),1)
#define BCM53115_A0_WRITE_UDF_0_Br(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_0_Br+(1*(i)),&(r._udf_0_b),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_0_Br BCM53115_A0_UDF_0_Br
#define UDF_0_Br_SIZE BCM53115_A0_UDF_0_Br_SIZE
typedef BCM53115_A0_UDF_0_Br_t UDF_0_Br_t;
#define UDF_0_Br_CLR BCM53115_A0_UDF_0_Br_CLR
#define UDF_0_Br_SET BCM53115_A0_UDF_0_Br_SET
#define UDF_0_Br_GET BCM53115_A0_UDF_0_Br_GET
#define UDF_0_Br_CFG_UDF_0_B_0_8f_GET BCM53115_A0_UDF_0_Br_CFG_UDF_0_B_0_8f_GET
#define UDF_0_Br_CFG_UDF_0_B_0_8f_SET BCM53115_A0_UDF_0_Br_CFG_UDF_0_B_0_8f_SET
#define READ_UDF_0_Br BCM53115_A0_READ_UDF_0_Br
#define WRITE_UDF_0_Br BCM53115_A0_WRITE_UDF_0_Br

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_0_Br'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_0_C
 * BLOCKS:   SYS
 * DESC:     UDF_0_C_N(0~8) for none-IP Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_0_C_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_0_Cr 0x0000a170

#define BCM53115_A0_UDF_0_Cr_SIZE 1

/*
 * This structure should be used to declare and program UDF_0_C.
 *
 */
typedef union BCM53115_A0_UDF_0_Cr_s {
	uint32_t v[1];
	uint32_t udf_0_c[1];
	uint32_t _udf_0_c;
} BCM53115_A0_UDF_0_Cr_t;

#define BCM53115_A0_UDF_0_Cr_CLR(r) (r).udf_0_c[0] = 0
#define BCM53115_A0_UDF_0_Cr_SET(r,d) (r).udf_0_c[0] = d
#define BCM53115_A0_UDF_0_Cr_GET(r) (r).udf_0_c[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_0_Cr_CFG_UDF_0_C_0_8f_GET(r) (((r).udf_0_c[0]) & 0xff)
#define BCM53115_A0_UDF_0_Cr_CFG_UDF_0_C_0_8f_SET(r,f) (r).udf_0_c[0]=(((r).udf_0_c[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_0_C.
 *
 */
#define BCM53115_A0_READ_UDF_0_Cr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_0_Cr+(1*(i)),(r._udf_0_c),1)
#define BCM53115_A0_WRITE_UDF_0_Cr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_0_Cr+(1*(i)),&(r._udf_0_c),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_0_Cr BCM53115_A0_UDF_0_Cr
#define UDF_0_Cr_SIZE BCM53115_A0_UDF_0_Cr_SIZE
typedef BCM53115_A0_UDF_0_Cr_t UDF_0_Cr_t;
#define UDF_0_Cr_CLR BCM53115_A0_UDF_0_Cr_CLR
#define UDF_0_Cr_SET BCM53115_A0_UDF_0_Cr_SET
#define UDF_0_Cr_GET BCM53115_A0_UDF_0_Cr_GET
#define UDF_0_Cr_CFG_UDF_0_C_0_8f_GET BCM53115_A0_UDF_0_Cr_CFG_UDF_0_C_0_8f_GET
#define UDF_0_Cr_CFG_UDF_0_C_0_8f_SET BCM53115_A0_UDF_0_Cr_CFG_UDF_0_C_0_8f_SET
#define READ_UDF_0_Cr BCM53115_A0_READ_UDF_0_Cr
#define WRITE_UDF_0_Cr BCM53115_A0_WRITE_UDF_0_Cr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_0_Cr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_0_D
 * BLOCKS:   SYS
 * DESC:     UDF_0_D_N(0~11) for IPv6 Chain Rule Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_0_D_0_11 
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_0_Dr 0x0000a1a0

#define BCM53115_A0_UDF_0_Dr_SIZE 1

/*
 * This structure should be used to declare and program UDF_0_D.
 *
 */
typedef union BCM53115_A0_UDF_0_Dr_s {
	uint32_t v[1];
	uint32_t udf_0_d[1];
	uint32_t _udf_0_d;
} BCM53115_A0_UDF_0_Dr_t;

#define BCM53115_A0_UDF_0_Dr_CLR(r) (r).udf_0_d[0] = 0
#define BCM53115_A0_UDF_0_Dr_SET(r,d) (r).udf_0_d[0] = d
#define BCM53115_A0_UDF_0_Dr_GET(r) (r).udf_0_d[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_0_Dr_CFG_UDF_0_D_0_11f_GET(r) (((r).udf_0_d[0]) & 0xff)
#define BCM53115_A0_UDF_0_Dr_CFG_UDF_0_D_0_11f_SET(r,f) (r).udf_0_d[0]=(((r).udf_0_d[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_0_D.
 *
 */
#define BCM53115_A0_READ_UDF_0_Dr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_0_Dr+(1*(i)),(r._udf_0_d),1)
#define BCM53115_A0_WRITE_UDF_0_Dr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_0_Dr+(1*(i)),&(r._udf_0_d),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_0_Dr BCM53115_A0_UDF_0_Dr
#define UDF_0_Dr_SIZE BCM53115_A0_UDF_0_Dr_SIZE
typedef BCM53115_A0_UDF_0_Dr_t UDF_0_Dr_t;
#define UDF_0_Dr_CLR BCM53115_A0_UDF_0_Dr_CLR
#define UDF_0_Dr_SET BCM53115_A0_UDF_0_Dr_SET
#define UDF_0_Dr_GET BCM53115_A0_UDF_0_Dr_GET
#define UDF_0_Dr_CFG_UDF_0_D_0_11f_GET BCM53115_A0_UDF_0_Dr_CFG_UDF_0_D_0_11f_GET
#define UDF_0_Dr_CFG_UDF_0_D_0_11f_SET BCM53115_A0_UDF_0_Dr_CFG_UDF_0_D_0_11f_SET
#define READ_UDF_0_Dr BCM53115_A0_READ_UDF_0_Dr
#define WRITE_UDF_0_Dr BCM53115_A0_WRITE_UDF_0_Dr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_0_Dr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_1_A
 * BLOCKS:   SYS
 * DESC:     UDF_1_A_N(0~8) for IPv4 Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_1_A_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_1_Ar 0x0000a120

#define BCM53115_A0_UDF_1_Ar_SIZE 1

/*
 * This structure should be used to declare and program UDF_1_A.
 *
 */
typedef union BCM53115_A0_UDF_1_Ar_s {
	uint32_t v[1];
	uint32_t udf_1_a[1];
	uint32_t _udf_1_a;
} BCM53115_A0_UDF_1_Ar_t;

#define BCM53115_A0_UDF_1_Ar_CLR(r) (r).udf_1_a[0] = 0
#define BCM53115_A0_UDF_1_Ar_SET(r,d) (r).udf_1_a[0] = d
#define BCM53115_A0_UDF_1_Ar_GET(r) (r).udf_1_a[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_1_Ar_CFG_UDF_1_A_0_8f_GET(r) (((r).udf_1_a[0]) & 0xff)
#define BCM53115_A0_UDF_1_Ar_CFG_UDF_1_A_0_8f_SET(r,f) (r).udf_1_a[0]=(((r).udf_1_a[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_1_A.
 *
 */
#define BCM53115_A0_READ_UDF_1_Ar(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_1_Ar+(1*(i)),(r._udf_1_a),1)
#define BCM53115_A0_WRITE_UDF_1_Ar(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_1_Ar+(1*(i)),&(r._udf_1_a),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_1_Ar BCM53115_A0_UDF_1_Ar
#define UDF_1_Ar_SIZE BCM53115_A0_UDF_1_Ar_SIZE
typedef BCM53115_A0_UDF_1_Ar_t UDF_1_Ar_t;
#define UDF_1_Ar_CLR BCM53115_A0_UDF_1_Ar_CLR
#define UDF_1_Ar_SET BCM53115_A0_UDF_1_Ar_SET
#define UDF_1_Ar_GET BCM53115_A0_UDF_1_Ar_GET
#define UDF_1_Ar_CFG_UDF_1_A_0_8f_GET BCM53115_A0_UDF_1_Ar_CFG_UDF_1_A_0_8f_GET
#define UDF_1_Ar_CFG_UDF_1_A_0_8f_SET BCM53115_A0_UDF_1_Ar_CFG_UDF_1_A_0_8f_SET
#define READ_UDF_1_Ar BCM53115_A0_READ_UDF_1_Ar
#define WRITE_UDF_1_Ar BCM53115_A0_WRITE_UDF_1_Ar

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_1_Ar'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_1_B
 * BLOCKS:   SYS
 * DESC:     UDF_1_B_N(0~8) for IPv6 Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_1_B_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_1_Br 0x0000a150

#define BCM53115_A0_UDF_1_Br_SIZE 1

/*
 * This structure should be used to declare and program UDF_1_B.
 *
 */
typedef union BCM53115_A0_UDF_1_Br_s {
	uint32_t v[1];
	uint32_t udf_1_b[1];
	uint32_t _udf_1_b;
} BCM53115_A0_UDF_1_Br_t;

#define BCM53115_A0_UDF_1_Br_CLR(r) (r).udf_1_b[0] = 0
#define BCM53115_A0_UDF_1_Br_SET(r,d) (r).udf_1_b[0] = d
#define BCM53115_A0_UDF_1_Br_GET(r) (r).udf_1_b[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_1_Br_CFG_UDF_1_B_0_8f_GET(r) (((r).udf_1_b[0]) & 0xff)
#define BCM53115_A0_UDF_1_Br_CFG_UDF_1_B_0_8f_SET(r,f) (r).udf_1_b[0]=(((r).udf_1_b[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_1_B.
 *
 */
#define BCM53115_A0_READ_UDF_1_Br(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_1_Br+(1*(i)),(r._udf_1_b),1)
#define BCM53115_A0_WRITE_UDF_1_Br(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_1_Br+(1*(i)),&(r._udf_1_b),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_1_Br BCM53115_A0_UDF_1_Br
#define UDF_1_Br_SIZE BCM53115_A0_UDF_1_Br_SIZE
typedef BCM53115_A0_UDF_1_Br_t UDF_1_Br_t;
#define UDF_1_Br_CLR BCM53115_A0_UDF_1_Br_CLR
#define UDF_1_Br_SET BCM53115_A0_UDF_1_Br_SET
#define UDF_1_Br_GET BCM53115_A0_UDF_1_Br_GET
#define UDF_1_Br_CFG_UDF_1_B_0_8f_GET BCM53115_A0_UDF_1_Br_CFG_UDF_1_B_0_8f_GET
#define UDF_1_Br_CFG_UDF_1_B_0_8f_SET BCM53115_A0_UDF_1_Br_CFG_UDF_1_B_0_8f_SET
#define READ_UDF_1_Br BCM53115_A0_READ_UDF_1_Br
#define WRITE_UDF_1_Br BCM53115_A0_WRITE_UDF_1_Br

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_1_Br'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_1_C
 * BLOCKS:   SYS
 * DESC:     UDF_1_C_N(0~8) for none-IP Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_1_C_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_1_Cr 0x0000a180

#define BCM53115_A0_UDF_1_Cr_SIZE 1

/*
 * This structure should be used to declare and program UDF_1_C.
 *
 */
typedef union BCM53115_A0_UDF_1_Cr_s {
	uint32_t v[1];
	uint32_t udf_1_c[1];
	uint32_t _udf_1_c;
} BCM53115_A0_UDF_1_Cr_t;

#define BCM53115_A0_UDF_1_Cr_CLR(r) (r).udf_1_c[0] = 0
#define BCM53115_A0_UDF_1_Cr_SET(r,d) (r).udf_1_c[0] = d
#define BCM53115_A0_UDF_1_Cr_GET(r) (r).udf_1_c[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_1_Cr_CFG_UDF_1_C_0_8f_GET(r) (((r).udf_1_c[0]) & 0xff)
#define BCM53115_A0_UDF_1_Cr_CFG_UDF_1_C_0_8f_SET(r,f) (r).udf_1_c[0]=(((r).udf_1_c[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_1_C.
 *
 */
#define BCM53115_A0_READ_UDF_1_Cr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_1_Cr+(1*(i)),(r._udf_1_c),1)
#define BCM53115_A0_WRITE_UDF_1_Cr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_1_Cr+(1*(i)),&(r._udf_1_c),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_1_Cr BCM53115_A0_UDF_1_Cr
#define UDF_1_Cr_SIZE BCM53115_A0_UDF_1_Cr_SIZE
typedef BCM53115_A0_UDF_1_Cr_t UDF_1_Cr_t;
#define UDF_1_Cr_CLR BCM53115_A0_UDF_1_Cr_CLR
#define UDF_1_Cr_SET BCM53115_A0_UDF_1_Cr_SET
#define UDF_1_Cr_GET BCM53115_A0_UDF_1_Cr_GET
#define UDF_1_Cr_CFG_UDF_1_C_0_8f_GET BCM53115_A0_UDF_1_Cr_CFG_UDF_1_C_0_8f_GET
#define UDF_1_Cr_CFG_UDF_1_C_0_8f_SET BCM53115_A0_UDF_1_Cr_CFG_UDF_1_C_0_8f_SET
#define READ_UDF_1_Cr BCM53115_A0_READ_UDF_1_Cr
#define WRITE_UDF_1_Cr BCM53115_A0_WRITE_UDF_1_Cr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_1_Cr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_2_A
 * BLOCKS:   SYS
 * DESC:     UDF_2_A_N(0~8) for IPv4 Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_2_A_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_2_Ar 0x0000a130

#define BCM53115_A0_UDF_2_Ar_SIZE 1

/*
 * This structure should be used to declare and program UDF_2_A.
 *
 */
typedef union BCM53115_A0_UDF_2_Ar_s {
	uint32_t v[1];
	uint32_t udf_2_a[1];
	uint32_t _udf_2_a;
} BCM53115_A0_UDF_2_Ar_t;

#define BCM53115_A0_UDF_2_Ar_CLR(r) (r).udf_2_a[0] = 0
#define BCM53115_A0_UDF_2_Ar_SET(r,d) (r).udf_2_a[0] = d
#define BCM53115_A0_UDF_2_Ar_GET(r) (r).udf_2_a[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_2_Ar_CFG_UDF_2_A_0_8f_GET(r) (((r).udf_2_a[0]) & 0xff)
#define BCM53115_A0_UDF_2_Ar_CFG_UDF_2_A_0_8f_SET(r,f) (r).udf_2_a[0]=(((r).udf_2_a[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_2_A.
 *
 */
#define BCM53115_A0_READ_UDF_2_Ar(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_2_Ar+(1*(i)),(r._udf_2_a),1)
#define BCM53115_A0_WRITE_UDF_2_Ar(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_2_Ar+(1*(i)),&(r._udf_2_a),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_2_Ar BCM53115_A0_UDF_2_Ar
#define UDF_2_Ar_SIZE BCM53115_A0_UDF_2_Ar_SIZE
typedef BCM53115_A0_UDF_2_Ar_t UDF_2_Ar_t;
#define UDF_2_Ar_CLR BCM53115_A0_UDF_2_Ar_CLR
#define UDF_2_Ar_SET BCM53115_A0_UDF_2_Ar_SET
#define UDF_2_Ar_GET BCM53115_A0_UDF_2_Ar_GET
#define UDF_2_Ar_CFG_UDF_2_A_0_8f_GET BCM53115_A0_UDF_2_Ar_CFG_UDF_2_A_0_8f_GET
#define UDF_2_Ar_CFG_UDF_2_A_0_8f_SET BCM53115_A0_UDF_2_Ar_CFG_UDF_2_A_0_8f_SET
#define READ_UDF_2_Ar BCM53115_A0_READ_UDF_2_Ar
#define WRITE_UDF_2_Ar BCM53115_A0_WRITE_UDF_2_Ar

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_2_Ar'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_2_B
 * BLOCKS:   SYS
 * DESC:     UDF_2_B_N(0~8) for IPv6 Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_2_B_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_2_Br 0x0000a160

#define BCM53115_A0_UDF_2_Br_SIZE 1

/*
 * This structure should be used to declare and program UDF_2_B.
 *
 */
typedef union BCM53115_A0_UDF_2_Br_s {
	uint32_t v[1];
	uint32_t udf_2_b[1];
	uint32_t _udf_2_b;
} BCM53115_A0_UDF_2_Br_t;

#define BCM53115_A0_UDF_2_Br_CLR(r) (r).udf_2_b[0] = 0
#define BCM53115_A0_UDF_2_Br_SET(r,d) (r).udf_2_b[0] = d
#define BCM53115_A0_UDF_2_Br_GET(r) (r).udf_2_b[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_2_Br_CFG_UDF_2_B_0_8f_GET(r) (((r).udf_2_b[0]) & 0xff)
#define BCM53115_A0_UDF_2_Br_CFG_UDF_2_B_0_8f_SET(r,f) (r).udf_2_b[0]=(((r).udf_2_b[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_2_B.
 *
 */
#define BCM53115_A0_READ_UDF_2_Br(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_2_Br+(1*(i)),(r._udf_2_b),1)
#define BCM53115_A0_WRITE_UDF_2_Br(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_2_Br+(1*(i)),&(r._udf_2_b),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_2_Br BCM53115_A0_UDF_2_Br
#define UDF_2_Br_SIZE BCM53115_A0_UDF_2_Br_SIZE
typedef BCM53115_A0_UDF_2_Br_t UDF_2_Br_t;
#define UDF_2_Br_CLR BCM53115_A0_UDF_2_Br_CLR
#define UDF_2_Br_SET BCM53115_A0_UDF_2_Br_SET
#define UDF_2_Br_GET BCM53115_A0_UDF_2_Br_GET
#define UDF_2_Br_CFG_UDF_2_B_0_8f_GET BCM53115_A0_UDF_2_Br_CFG_UDF_2_B_0_8f_GET
#define UDF_2_Br_CFG_UDF_2_B_0_8f_SET BCM53115_A0_UDF_2_Br_CFG_UDF_2_B_0_8f_SET
#define READ_UDF_2_Br BCM53115_A0_READ_UDF_2_Br
#define WRITE_UDF_2_Br BCM53115_A0_WRITE_UDF_2_Br

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_2_Br'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  UDF_2_C
 * BLOCKS:   SYS
 * DESC:     UDF_2_C_N(0~8) for none-IP Registers
 * SIZE:     8
 * FIELDS:
 *     CFG_UDF_1_C_0_8  
 *
 ******************************************************************************/
#define BCM53115_A0_UDF_2_Cr 0x0000a190

#define BCM53115_A0_UDF_2_Cr_SIZE 1

/*
 * This structure should be used to declare and program UDF_2_C.
 *
 */
typedef union BCM53115_A0_UDF_2_Cr_s {
	uint32_t v[1];
	uint32_t udf_2_c[1];
	uint32_t _udf_2_c;
} BCM53115_A0_UDF_2_Cr_t;

#define BCM53115_A0_UDF_2_Cr_CLR(r) (r).udf_2_c[0] = 0
#define BCM53115_A0_UDF_2_Cr_SET(r,d) (r).udf_2_c[0] = d
#define BCM53115_A0_UDF_2_Cr_GET(r) (r).udf_2_c[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_UDF_2_Cr_CFG_UDF_1_C_0_8f_GET(r) (((r).udf_2_c[0]) & 0xff)
#define BCM53115_A0_UDF_2_Cr_CFG_UDF_1_C_0_8f_SET(r,f) (r).udf_2_c[0]=(((r).udf_2_c[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access UDF_2_C.
 *
 */
#define BCM53115_A0_READ_UDF_2_Cr(u,i,r) cdk_robo_reg_read(u,BCM53115_A0_UDF_2_Cr+(1*(i)),(r._udf_2_c),1)
#define BCM53115_A0_WRITE_UDF_2_Cr(u,i,r) cdk_robo_reg_write(u,BCM53115_A0_UDF_2_Cr+(1*(i)),&(r._udf_2_c),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_2_Cr BCM53115_A0_UDF_2_Cr
#define UDF_2_Cr_SIZE BCM53115_A0_UDF_2_Cr_SIZE
typedef BCM53115_A0_UDF_2_Cr_t UDF_2_Cr_t;
#define UDF_2_Cr_CLR BCM53115_A0_UDF_2_Cr_CLR
#define UDF_2_Cr_SET BCM53115_A0_UDF_2_Cr_SET
#define UDF_2_Cr_GET BCM53115_A0_UDF_2_Cr_GET
#define UDF_2_Cr_CFG_UDF_1_C_0_8f_GET BCM53115_A0_UDF_2_Cr_CFG_UDF_1_C_0_8f_GET
#define UDF_2_Cr_CFG_UDF_1_C_0_8f_SET BCM53115_A0_UDF_2_Cr_CFG_UDF_1_C_0_8f_SET
#define READ_UDF_2_Cr BCM53115_A0_READ_UDF_2_Cr
#define WRITE_UDF_2_Cr BCM53115_A0_WRITE_UDF_2_Cr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_UDF_2_Cr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  ULF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Unicast Lookup Failed Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     UNI_LOOPUP_FAIL_FWD_MAP Unicast Lookup Failed Forward Map.When unicast lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_ULF_DROP_MAPr 0x00000032

#define BCM53115_A0_ULF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program ULF_DROP_MAP.
 *
 */
typedef union BCM53115_A0_ULF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t ulf_drop_map[1];
	uint32_t _ulf_drop_map;
} BCM53115_A0_ULF_DROP_MAPr_t;

#define BCM53115_A0_ULF_DROP_MAPr_CLR(r) (r).ulf_drop_map[0] = 0
#define BCM53115_A0_ULF_DROP_MAPr_SET(r,d) (r).ulf_drop_map[0] = d
#define BCM53115_A0_ULF_DROP_MAPr_GET(r) (r).ulf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET(r) (((r).ulf_drop_map[0]) & 0x1ff)
#define BCM53115_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_ULF_DROP_MAPr_RESERVED_Rf_GET(r) ((((r).ulf_drop_map[0]) >> 9) & 0x7f)
#define BCM53115_A0_ULF_DROP_MAPr_RESERVED_Rf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ULF_DROP_MAP.
 *
 */
#define BCM53115_A0_READ_ULF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM53115_A0_ULF_DROP_MAPr,(r._ulf_drop_map),2)
#define BCM53115_A0_WRITE_ULF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM53115_A0_ULF_DROP_MAPr,&(r._ulf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ULF_DROP_MAPr BCM53115_A0_ULF_DROP_MAPr
#define ULF_DROP_MAPr_SIZE BCM53115_A0_ULF_DROP_MAPr_SIZE
typedef BCM53115_A0_ULF_DROP_MAPr_t ULF_DROP_MAPr_t;
#define ULF_DROP_MAPr_CLR BCM53115_A0_ULF_DROP_MAPr_CLR
#define ULF_DROP_MAPr_SET BCM53115_A0_ULF_DROP_MAPr_SET
#define ULF_DROP_MAPr_GET BCM53115_A0_ULF_DROP_MAPr_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET BCM53115_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET BCM53115_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET
#define ULF_DROP_MAPr_RESERVED_Rf_GET BCM53115_A0_ULF_DROP_MAPr_RESERVED_Rf_GET
#define ULF_DROP_MAPr_RESERVED_Rf_SET BCM53115_A0_ULF_DROP_MAPr_RESERVED_Rf_SET
#define READ_ULF_DROP_MAPr BCM53115_A0_READ_ULF_DROP_MAPr
#define WRITE_ULF_DROP_MAPr BCM53115_A0_WRITE_ULF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_ULF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * MEMORY:  VLAN_1Q
 * BLOCKS:   SYS
 * DESC:     VLAN Table
 * SIZE:     32
 * FIELDS:
 *     FORWARD_MAP      Forward PORT MAP.The VLAN-tagged Frame is allowed to be forwarded to the destination ports corresponding bits set in the Map.Bits4-0: Port 4-0.Bit5: Management Port 2(IMP1 port).Bit6: Management Port (IMP/IMP_0 port).
 *     UNTAG_MAP        Untag Port Map.The VLAN-tagged Frame forward to the destination ports corresponding bits set in the Map will be untagged.Bits4-0: Port 4-0.Bit5: Management Port 2(IMP1 port).Bit6: Management Port (IMP/IMP_0 port).
 *     MSPT_ID          Index for 8 spanning tree.
 *     FWD_MODE         It indicate wheter the packet forwarding should be based on VLANmembership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used forcertain ISP tagged packets received from ISP port when Falcon isoperating in Double Tag mode.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_1Qm 0x20000580

#define BCM53115_A0_VLAN_1Qm_MIN 0
#define BCM53115_A0_VLAN_1Qm_MAX 4095
#define BCM53115_A0_VLAN_1Qm_CMAX(u) 4095
#define BCM53115_A0_VLAN_1Qm_SIZE 4

/*
 * This structure should be used to declare and program VLAN_1Q.
 *
 */
typedef union BCM53115_A0_VLAN_1Qm_s {
	uint32_t v[1];
	uint32_t vlan_1q[1];
	uint32_t _vlan_1q;
} BCM53115_A0_VLAN_1Qm_t;

#define BCM53115_A0_VLAN_1Qm_CLR(r) (r).vlan_1q[0] = 0
#define BCM53115_A0_VLAN_1Qm_SET(r,d) (r).vlan_1q[0] = d
#define BCM53115_A0_VLAN_1Qm_GET(r) (r).vlan_1q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_1Qm_FORWARD_MAPf_GET(r) (((r).vlan_1q[0]) & 0x1ff)
#define BCM53115_A0_VLAN_1Qm_FORWARD_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_VLAN_1Qm_UNTAG_MAPf_GET(r) ((((r).vlan_1q[0]) >> 9) & 0x1ff)
#define BCM53115_A0_VLAN_1Qm_UNTAG_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53115_A0_VLAN_1Qm_MSPT_IDf_GET(r) ((((r).vlan_1q[0]) >> 18) & 0x7)
#define BCM53115_A0_VLAN_1Qm_MSPT_IDf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53115_A0_VLAN_1Qm_FWD_MODEf_GET(r) ((((r).vlan_1q[0]) >> 21) & 0x1)
#define BCM53115_A0_VLAN_1Qm_FWD_MODEf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53115_A0_VLAN_1Qm_RESERVED_Rf_GET(r) ((((r).vlan_1q[0]) >> 22) & 0x3ff)
#define BCM53115_A0_VLAN_1Qm_RESERVED_Rf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access VLAN_1Q.
 *
 */
#define BCM53115_A0_READ_VLAN_1Qm(u,i,m) cdk_robo_mem_read(u,BCM53115_A0_VLAN_1Qm,i,(m),4)
#define BCM53115_A0_WRITE_VLAN_1Qm(u,i,m) cdk_robo_mem_write(u,BCM53115_A0_VLAN_1Qm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_1Qm BCM53115_A0_VLAN_1Qm
#define VLAN_1Qm_MIN BCM53115_A0_VLAN_1Qm_MIN
#define VLAN_1Qm_MAX BCM53115_A0_VLAN_1Qm_MAX
#define VLAN_1Qm_CMAX(u) BCM53115_A0_VLAN_1Qm_CMAX(u)
#define VLAN_1Qm_SIZE BCM53115_A0_VLAN_1Qm_SIZE
typedef BCM53115_A0_VLAN_1Qm_t VLAN_1Qm_t;
#define VLAN_1Qm_CLR BCM53115_A0_VLAN_1Qm_CLR
#define VLAN_1Qm_SET BCM53115_A0_VLAN_1Qm_SET
#define VLAN_1Qm_GET BCM53115_A0_VLAN_1Qm_GET
#define VLAN_1Qm_FORWARD_MAPf_GET BCM53115_A0_VLAN_1Qm_FORWARD_MAPf_GET
#define VLAN_1Qm_FORWARD_MAPf_SET BCM53115_A0_VLAN_1Qm_FORWARD_MAPf_SET
#define VLAN_1Qm_UNTAG_MAPf_GET BCM53115_A0_VLAN_1Qm_UNTAG_MAPf_GET
#define VLAN_1Qm_UNTAG_MAPf_SET BCM53115_A0_VLAN_1Qm_UNTAG_MAPf_SET
#define VLAN_1Qm_MSPT_IDf_GET BCM53115_A0_VLAN_1Qm_MSPT_IDf_GET
#define VLAN_1Qm_MSPT_IDf_SET BCM53115_A0_VLAN_1Qm_MSPT_IDf_SET
#define VLAN_1Qm_FWD_MODEf_GET BCM53115_A0_VLAN_1Qm_FWD_MODEf_GET
#define VLAN_1Qm_FWD_MODEf_SET BCM53115_A0_VLAN_1Qm_FWD_MODEf_SET
#define VLAN_1Qm_RESERVED_Rf_GET BCM53115_A0_VLAN_1Qm_RESERVED_Rf_GET
#define VLAN_1Qm_RESERVED_Rf_SET BCM53115_A0_VLAN_1Qm_RESERVED_Rf_SET
#define READ_VLAN_1Qm BCM53115_A0_READ_VLAN_1Qm
#define WRITE_VLAN_1Qm BCM53115_A0_WRITE_VLAN_1Qm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_1Qm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  VLAN_CTRL0
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 0 Registers
 * SIZE:     8
 * FIELDS:
 *     CHANGE_1P_VID_INNER 
 *     CHANGE_1P_VID_OUTER 
 *     RESERVED_0R      Reserved.
 *     CHANGE_1Q_VID    
 *     RESERVED_1R      Reserved.
 *     VLAN_LEARN_MODE  00: SVL( Shared VLAN Learning Mode)(MAC used to hash ARL table).11:IVL(Individual VLAN Learning Mode) (MAC and VID used to hash ARL table).10= illegal Setting.01= illegal Setting.
 *     VLAN_EN          When set to 1, the 802.1Q VLAN function will be enabled.
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_CTRL0r 0x00003400

#define BCM53115_A0_VLAN_CTRL0r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL0.
 *
 */
typedef union BCM53115_A0_VLAN_CTRL0r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl0[1];
	uint32_t _vlan_ctrl0;
} BCM53115_A0_VLAN_CTRL0r_t;

#define BCM53115_A0_VLAN_CTRL0r_CLR(r) (r).vlan_ctrl0[0] = 0
#define BCM53115_A0_VLAN_CTRL0r_SET(r,d) (r).vlan_ctrl0[0] = d
#define BCM53115_A0_VLAN_CTRL0r_GET(r) (r).vlan_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET(r) (((r).vlan_ctrl0[0]) & 0x1)
#define BCM53115_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET(r) ((((r).vlan_ctrl0[0]) >> 1) & 0x1)
#define BCM53115_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_VLAN_CTRL0r_RESERVED_0Rf_GET(r) ((((r).vlan_ctrl0[0]) >> 2) & 0x1)
#define BCM53115_A0_VLAN_CTRL0r_RESERVED_0Rf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_GET(r) ((((r).vlan_ctrl0[0]) >> 3) & 0x1)
#define BCM53115_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_VLAN_CTRL0r_RESERVED_1Rf_GET(r) ((((r).vlan_ctrl0[0]) >> 4) & 0x1)
#define BCM53115_A0_VLAN_CTRL0r_RESERVED_1Rf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET(r) ((((r).vlan_ctrl0[0]) >> 5) & 0x3)
#define BCM53115_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53115_A0_VLAN_CTRL0r_VLAN_ENf_GET(r) ((((r).vlan_ctrl0[0]) >> 7) & 0x1)
#define BCM53115_A0_VLAN_CTRL0r_VLAN_ENf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL0.
 *
 */
#define BCM53115_A0_READ_VLAN_CTRL0r(u,r) cdk_robo_reg_read(u,BCM53115_A0_VLAN_CTRL0r,(r._vlan_ctrl0),1)
#define BCM53115_A0_WRITE_VLAN_CTRL0r(u,r) cdk_robo_reg_write(u,BCM53115_A0_VLAN_CTRL0r,&(r._vlan_ctrl0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL0r BCM53115_A0_VLAN_CTRL0r
#define VLAN_CTRL0r_SIZE BCM53115_A0_VLAN_CTRL0r_SIZE
typedef BCM53115_A0_VLAN_CTRL0r_t VLAN_CTRL0r_t;
#define VLAN_CTRL0r_CLR BCM53115_A0_VLAN_CTRL0r_CLR
#define VLAN_CTRL0r_SET BCM53115_A0_VLAN_CTRL0r_SET
#define VLAN_CTRL0r_GET BCM53115_A0_VLAN_CTRL0r_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET BCM53115_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET BCM53115_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET
#define VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET BCM53115_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET BCM53115_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET
#define VLAN_CTRL0r_RESERVED_0Rf_GET BCM53115_A0_VLAN_CTRL0r_RESERVED_0Rf_GET
#define VLAN_CTRL0r_RESERVED_0Rf_SET BCM53115_A0_VLAN_CTRL0r_RESERVED_0Rf_SET
#define VLAN_CTRL0r_CHANGE_1Q_VIDf_GET BCM53115_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_GET
#define VLAN_CTRL0r_CHANGE_1Q_VIDf_SET BCM53115_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_SET
#define VLAN_CTRL0r_RESERVED_1Rf_GET BCM53115_A0_VLAN_CTRL0r_RESERVED_1Rf_GET
#define VLAN_CTRL0r_RESERVED_1Rf_SET BCM53115_A0_VLAN_CTRL0r_RESERVED_1Rf_SET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_GET BCM53115_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_SET BCM53115_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET
#define VLAN_CTRL0r_VLAN_ENf_GET BCM53115_A0_VLAN_CTRL0r_VLAN_ENf_GET
#define VLAN_CTRL0r_VLAN_ENf_SET BCM53115_A0_VLAN_CTRL0r_VLAN_ENf_SET
#define READ_VLAN_CTRL0r BCM53115_A0_READ_VLAN_CTRL0r
#define WRITE_VLAN_CTRL0r BCM53115_A0_WRITE_VLAN_CTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  VLAN_CTRL1
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 1 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     RESERVED_1R      Reserved.It's illegal to set 0.
 *     EN_RSV_MCAST_FWDMAP When asserted, reserved multicast frames (except GMRP and GVRP) will be checked by v_fwdmap.
 *     EN_RSV_MCAST_UNTAG RW When asserted, reserved multicast frames (except GMRP andmGVRP) will be checked by v_untagmap
 *     RESERVED_2R      Reserved.It's illegal to set 1.
 *     EN_IPMC_BYPASS_FWDMAP When asserted will not check IPMC frame with V_fwdmap.
 *     EN_IPMC_BYPASS_UNTAG 
 *     RESERVED_3R      Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_CTRL1r 0x00003401

#define BCM53115_A0_VLAN_CTRL1r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL1.
 *
 */
typedef union BCM53115_A0_VLAN_CTRL1r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl1[1];
	uint32_t _vlan_ctrl1;
} BCM53115_A0_VLAN_CTRL1r_t;

#define BCM53115_A0_VLAN_CTRL1r_CLR(r) (r).vlan_ctrl1[0] = 0
#define BCM53115_A0_VLAN_CTRL1r_SET(r,d) (r).vlan_ctrl1[0] = d
#define BCM53115_A0_VLAN_CTRL1r_GET(r) (r).vlan_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_CTRL1r_RESERVED_0Rf_GET(r) (((r).vlan_ctrl1[0]) & 0x1)
#define BCM53115_A0_VLAN_CTRL1r_RESERVED_0Rf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_VLAN_CTRL1r_RESERVED_1Rf_GET(r) ((((r).vlan_ctrl1[0]) >> 1) & 0x1)
#define BCM53115_A0_VLAN_CTRL1r_RESERVED_1Rf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 2) & 0x1)
#define BCM53115_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 3) & 0x1)
#define BCM53115_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_VLAN_CTRL1r_RESERVED_2Rf_GET(r) ((((r).vlan_ctrl1[0]) >> 4) & 0x1)
#define BCM53115_A0_VLAN_CTRL1r_RESERVED_2Rf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 5) & 0x1)
#define BCM53115_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 6) & 0x1)
#define BCM53115_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_VLAN_CTRL1r_RESERVED_3Rf_GET(r) ((((r).vlan_ctrl1[0]) >> 7) & 0x1)
#define BCM53115_A0_VLAN_CTRL1r_RESERVED_3Rf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL1.
 *
 */
#define BCM53115_A0_READ_VLAN_CTRL1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_VLAN_CTRL1r,(r._vlan_ctrl1),1)
#define BCM53115_A0_WRITE_VLAN_CTRL1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_VLAN_CTRL1r,&(r._vlan_ctrl1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL1r BCM53115_A0_VLAN_CTRL1r
#define VLAN_CTRL1r_SIZE BCM53115_A0_VLAN_CTRL1r_SIZE
typedef BCM53115_A0_VLAN_CTRL1r_t VLAN_CTRL1r_t;
#define VLAN_CTRL1r_CLR BCM53115_A0_VLAN_CTRL1r_CLR
#define VLAN_CTRL1r_SET BCM53115_A0_VLAN_CTRL1r_SET
#define VLAN_CTRL1r_GET BCM53115_A0_VLAN_CTRL1r_GET
#define VLAN_CTRL1r_RESERVED_0Rf_GET BCM53115_A0_VLAN_CTRL1r_RESERVED_0Rf_GET
#define VLAN_CTRL1r_RESERVED_0Rf_SET BCM53115_A0_VLAN_CTRL1r_RESERVED_0Rf_SET
#define VLAN_CTRL1r_RESERVED_1Rf_GET BCM53115_A0_VLAN_CTRL1r_RESERVED_1Rf_GET
#define VLAN_CTRL1r_RESERVED_1Rf_SET BCM53115_A0_VLAN_CTRL1r_RESERVED_1Rf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET BCM53115_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET BCM53115_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET BCM53115_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET BCM53115_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_2Rf_GET BCM53115_A0_VLAN_CTRL1r_RESERVED_2Rf_GET
#define VLAN_CTRL1r_RESERVED_2Rf_SET BCM53115_A0_VLAN_CTRL1r_RESERVED_2Rf_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET BCM53115_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET BCM53115_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET BCM53115_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET BCM53115_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_3Rf_GET BCM53115_A0_VLAN_CTRL1r_RESERVED_3Rf_GET
#define VLAN_CTRL1r_RESERVED_3Rf_SET BCM53115_A0_VLAN_CTRL1r_RESERVED_3Rf_SET
#define READ_VLAN_CTRL1r BCM53115_A0_READ_VLAN_CTRL1r
#define WRITE_VLAN_CTRL1r BCM53115_A0_WRITE_VLAN_CTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  VLAN_CTRL2
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 2 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved.
 *     EN_MIIM_BYPASS_V_FWDMAP When set to 1, frames reveived by MII_manage port will bypass V_fwdmap checking.** Untagged frame received by MII_manage port will never be tagged.
 *     RESERVED_2R      Reserved.
 *     EN_GMRP_GVRP_V_FWDMAP When set to 1, GMRP,GVRP will be checked by v_fwdmap.** this rule do not apply to MII_manage EXP and SPI ports.
 *     EN_GMRP_GVRP_UNTAG_MAP When set to 1, GMRP,GVRP will be checked by v_untagmap** this rule do not apply to MII_manage exp and SPI ports.
 *     RESERVED_R       
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_CTRL2r 0x00003402

#define BCM53115_A0_VLAN_CTRL2r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL2.
 *
 */
typedef union BCM53115_A0_VLAN_CTRL2r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl2[1];
	uint32_t _vlan_ctrl2;
} BCM53115_A0_VLAN_CTRL2r_t;

#define BCM53115_A0_VLAN_CTRL2r_CLR(r) (r).vlan_ctrl2[0] = 0
#define BCM53115_A0_VLAN_CTRL2r_SET(r,d) (r).vlan_ctrl2[0] = d
#define BCM53115_A0_VLAN_CTRL2r_GET(r) (r).vlan_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_CTRL2r_RESERVED_0Rf_GET(r) (((r).vlan_ctrl2[0]) & 0x3)
#define BCM53115_A0_VLAN_CTRL2r_RESERVED_0Rf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53115_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 2) & 0x1)
#define BCM53115_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_VLAN_CTRL2r_RESERVED_2Rf_GET(r) ((((r).vlan_ctrl2[0]) >> 3) & 0x3)
#define BCM53115_A0_VLAN_CTRL2r_RESERVED_2Rf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53115_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 5) & 0x1)
#define BCM53115_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 6) & 0x1)
#define BCM53115_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_VLAN_CTRL2r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl2[0]) >> 7) & 0x1)
#define BCM53115_A0_VLAN_CTRL2r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL2.
 *
 */
#define BCM53115_A0_READ_VLAN_CTRL2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_VLAN_CTRL2r,(r._vlan_ctrl2),1)
#define BCM53115_A0_WRITE_VLAN_CTRL2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_VLAN_CTRL2r,&(r._vlan_ctrl2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL2r BCM53115_A0_VLAN_CTRL2r
#define VLAN_CTRL2r_SIZE BCM53115_A0_VLAN_CTRL2r_SIZE
typedef BCM53115_A0_VLAN_CTRL2r_t VLAN_CTRL2r_t;
#define VLAN_CTRL2r_CLR BCM53115_A0_VLAN_CTRL2r_CLR
#define VLAN_CTRL2r_SET BCM53115_A0_VLAN_CTRL2r_SET
#define VLAN_CTRL2r_GET BCM53115_A0_VLAN_CTRL2r_GET
#define VLAN_CTRL2r_RESERVED_0Rf_GET BCM53115_A0_VLAN_CTRL2r_RESERVED_0Rf_GET
#define VLAN_CTRL2r_RESERVED_0Rf_SET BCM53115_A0_VLAN_CTRL2r_RESERVED_0Rf_SET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET BCM53115_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET BCM53115_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET
#define VLAN_CTRL2r_RESERVED_2Rf_GET BCM53115_A0_VLAN_CTRL2r_RESERVED_2Rf_GET
#define VLAN_CTRL2r_RESERVED_2Rf_SET BCM53115_A0_VLAN_CTRL2r_RESERVED_2Rf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET BCM53115_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET BCM53115_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET BCM53115_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET BCM53115_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET
#define VLAN_CTRL2r_RESERVED_Rf_GET BCM53115_A0_VLAN_CTRL2r_RESERVED_Rf_GET
#define VLAN_CTRL2r_RESERVED_Rf_SET BCM53115_A0_VLAN_CTRL2r_RESERVED_Rf_SET
#define READ_VLAN_CTRL2r BCM53115_A0_READ_VLAN_CTRL2r
#define WRITE_VLAN_CTRL2r BCM53115_A0_WRITE_VLAN_CTRL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  VLAN_CTRL3
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 3 Registers
 * SIZE:     16
 * FIELDS:
 *     EN_DROP_NON1Q    When enabled , any non_1Q frame will be dropped by this port. Ports 7-0 respectively.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_CTRL3r 0x00003403

#define BCM53115_A0_VLAN_CTRL3r_SIZE 2

/*
 * This structure should be used to declare and program VLAN_CTRL3.
 *
 */
typedef union BCM53115_A0_VLAN_CTRL3r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl3[1];
	uint32_t _vlan_ctrl3;
} BCM53115_A0_VLAN_CTRL3r_t;

#define BCM53115_A0_VLAN_CTRL3r_CLR(r) (r).vlan_ctrl3[0] = 0
#define BCM53115_A0_VLAN_CTRL3r_SET(r,d) (r).vlan_ctrl3[0] = d
#define BCM53115_A0_VLAN_CTRL3r_GET(r) (r).vlan_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET(r) (((r).vlan_ctrl3[0]) & 0x1ff)
#define BCM53115_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_VLAN_CTRL3r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl3[0]) >> 9) & 0x7f)
#define BCM53115_A0_VLAN_CTRL3r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access VLAN_CTRL3.
 *
 */
#define BCM53115_A0_READ_VLAN_CTRL3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_VLAN_CTRL3r,(r._vlan_ctrl3),2)
#define BCM53115_A0_WRITE_VLAN_CTRL3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_VLAN_CTRL3r,&(r._vlan_ctrl3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL3r BCM53115_A0_VLAN_CTRL3r
#define VLAN_CTRL3r_SIZE BCM53115_A0_VLAN_CTRL3r_SIZE
typedef BCM53115_A0_VLAN_CTRL3r_t VLAN_CTRL3r_t;
#define VLAN_CTRL3r_CLR BCM53115_A0_VLAN_CTRL3r_CLR
#define VLAN_CTRL3r_SET BCM53115_A0_VLAN_CTRL3r_SET
#define VLAN_CTRL3r_GET BCM53115_A0_VLAN_CTRL3r_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_GET BCM53115_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_SET BCM53115_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET
#define VLAN_CTRL3r_RESERVED_Rf_GET BCM53115_A0_VLAN_CTRL3r_RESERVED_Rf_GET
#define VLAN_CTRL3r_RESERVED_Rf_SET BCM53115_A0_VLAN_CTRL3r_RESERVED_Rf_SET
#define READ_VLAN_CTRL3r BCM53115_A0_READ_VLAN_CTRL3r
#define WRITE_VLAN_CTRL3r BCM53115_A0_WRITE_VLAN_CTRL3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  VLAN_CTRL4
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 4 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_1R      Reserved.
 *     RESV_MCAST_FLOOD When chip is at double tag mode and also in management mode.1 : the received mcast frame will be flood per the VLAN rule.0 : the received mcast frame will be trap to CPU.01-80-c2-00-(00,01-2f)
 *     EN_DOUBLE_TAG    
 *     EN_MGE_REV_GMRP  When set to 1, management port ( the port with CPU) will be the destination port of GMRP frame. In multiple chip system, a GMRP frmae received by a chip without CPU will pass it to expansion port, and eventually it will be forward to CPU.
 *     EN_MGE_REV_GVRP  When set to 1. management port ( the port with CPU) will be the destination port of GVRP frame.
 *     INGR_VID_CHK     00: forward ingress VID violation frame( VID is not in v_fwdmap). But do not learn in ARL table.01: Drop frame if frame has VID violation, not Learned.10: Do not check ingress VID violation.(Forward and Learn as no violation case)11:Forward ingress VIO violation frame to IMP, but not learn(default)** This rule do not apply IMP
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_CTRL4r 0x00003405

#define BCM53115_A0_VLAN_CTRL4r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL4.
 *
 */
typedef union BCM53115_A0_VLAN_CTRL4r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl4[1];
	uint32_t _vlan_ctrl4;
} BCM53115_A0_VLAN_CTRL4r_t;

#define BCM53115_A0_VLAN_CTRL4r_CLR(r) (r).vlan_ctrl4[0] = 0
#define BCM53115_A0_VLAN_CTRL4r_SET(r,d) (r).vlan_ctrl4[0] = d
#define BCM53115_A0_VLAN_CTRL4r_GET(r) (r).vlan_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_CTRL4r_RESERVED_1Rf_GET(r) (((r).vlan_ctrl4[0]) & 0x1)
#define BCM53115_A0_VLAN_CTRL4r_RESERVED_1Rf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET(r) ((((r).vlan_ctrl4[0]) >> 1) & 0x1)
#define BCM53115_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_GET(r) ((((r).vlan_ctrl4[0]) >> 2) & 0x3)
#define BCM53115_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53115_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 4) & 0x1)
#define BCM53115_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 5) & 0x1)
#define BCM53115_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET(r) ((((r).vlan_ctrl4[0]) >> 6) & 0x3)
#define BCM53115_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access VLAN_CTRL4.
 *
 */
#define BCM53115_A0_READ_VLAN_CTRL4r(u,r) cdk_robo_reg_read(u,BCM53115_A0_VLAN_CTRL4r,(r._vlan_ctrl4),1)
#define BCM53115_A0_WRITE_VLAN_CTRL4r(u,r) cdk_robo_reg_write(u,BCM53115_A0_VLAN_CTRL4r,&(r._vlan_ctrl4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL4r BCM53115_A0_VLAN_CTRL4r
#define VLAN_CTRL4r_SIZE BCM53115_A0_VLAN_CTRL4r_SIZE
typedef BCM53115_A0_VLAN_CTRL4r_t VLAN_CTRL4r_t;
#define VLAN_CTRL4r_CLR BCM53115_A0_VLAN_CTRL4r_CLR
#define VLAN_CTRL4r_SET BCM53115_A0_VLAN_CTRL4r_SET
#define VLAN_CTRL4r_GET BCM53115_A0_VLAN_CTRL4r_GET
#define VLAN_CTRL4r_RESERVED_1Rf_GET BCM53115_A0_VLAN_CTRL4r_RESERVED_1Rf_GET
#define VLAN_CTRL4r_RESERVED_1Rf_SET BCM53115_A0_VLAN_CTRL4r_RESERVED_1Rf_SET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_GET BCM53115_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_SET BCM53115_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET
#define VLAN_CTRL4r_EN_DOUBLE_TAGf_GET BCM53115_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_GET
#define VLAN_CTRL4r_EN_DOUBLE_TAGf_SET BCM53115_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET BCM53115_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET BCM53115_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET BCM53115_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET BCM53115_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET
#define VLAN_CTRL4r_INGR_VID_CHKf_GET BCM53115_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET
#define VLAN_CTRL4r_INGR_VID_CHKf_SET BCM53115_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET
#define READ_VLAN_CTRL4r BCM53115_A0_READ_VLAN_CTRL4r
#define WRITE_VLAN_CTRL4r BCM53115_A0_WRITE_VLAN_CTRL4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  VLAN_CTRL5
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 5 Registers
 * SIZE:     8
 * FIELDS:
 *     EN_CPU_RX_BYP_INNER_CRCCHK When set to 1, the management port with CPU on it will ignore inner CRC (BRCM tag frame)
 *     RESERVED_R       Reserved
 *     EN_VID_FFF_FWD   0 : comply with standard, drop frame.1: forwaed frame.
 *     DROP_VTABLE_MISS When set to 1, a frame with V_table miss will be dropped.When set to 0, a frame with V_table miss will be fowarded to IMP.
 *     EGRESS_DIR_FRM_BYPASS_TRUNK_EN Egress Directed Frame Bypass Trunking Re-direction EnableSet to1 : Egress Directed Frame From Management Port will bypass Re-Trunking Re-directed RuleSet to 0: Egress Directed Frame will From Management Port will follow Trunking Re-directed Rule.
 *     EN_PRESV_1P_TAG  To enable this, en_preserv_non_1q_frame must be also enabled.When enabled, it preserves priority (802.1p) tagged frames as priority tagged frames at TX even if untag map in VLAN table is 1.
 *     PRESV_NON1Q      - en_preserv_non_1q_frame: (default 0)When enabled, it preserves untagged frame as untagged frame at TX regardless of untag map in VLAN table, and preserves priority (802.1p) tagged frames as priority tagged frames at TX if untag map in VLAN Table is 0, but otherwise ntag priority tag.
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_CTRL5r 0x00003406

#define BCM53115_A0_VLAN_CTRL5r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL5.
 *
 */
typedef union BCM53115_A0_VLAN_CTRL5r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl5[1];
	uint32_t _vlan_ctrl5;
} BCM53115_A0_VLAN_CTRL5r_t;

#define BCM53115_A0_VLAN_CTRL5r_CLR(r) (r).vlan_ctrl5[0] = 0
#define BCM53115_A0_VLAN_CTRL5r_SET(r,d) (r).vlan_ctrl5[0] = d
#define BCM53115_A0_VLAN_CTRL5r_GET(r) (r).vlan_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET(r) (((r).vlan_ctrl5[0]) & 0x1)
#define BCM53115_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_VLAN_CTRL5r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl5[0]) >> 1) & 0x1)
#define BCM53115_A0_VLAN_CTRL5r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET(r) ((((r).vlan_ctrl5[0]) >> 2) & 0x1)
#define BCM53115_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET(r) ((((r).vlan_ctrl5[0]) >> 3) & 0x1)
#define BCM53115_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET(r) ((((r).vlan_ctrl5[0]) >> 4) & 0x1)
#define BCM53115_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_VLAN_CTRL5r_EN_PRESV_1P_TAGf_GET(r) ((((r).vlan_ctrl5[0]) >> 5) & 0x1)
#define BCM53115_A0_VLAN_CTRL5r_EN_PRESV_1P_TAGf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET(r) ((((r).vlan_ctrl5[0]) >> 6) & 0x1)
#define BCM53115_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access VLAN_CTRL5.
 *
 */
#define BCM53115_A0_READ_VLAN_CTRL5r(u,r) cdk_robo_reg_read(u,BCM53115_A0_VLAN_CTRL5r,(r._vlan_ctrl5),1)
#define BCM53115_A0_WRITE_VLAN_CTRL5r(u,r) cdk_robo_reg_write(u,BCM53115_A0_VLAN_CTRL5r,&(r._vlan_ctrl5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL5r BCM53115_A0_VLAN_CTRL5r
#define VLAN_CTRL5r_SIZE BCM53115_A0_VLAN_CTRL5r_SIZE
typedef BCM53115_A0_VLAN_CTRL5r_t VLAN_CTRL5r_t;
#define VLAN_CTRL5r_CLR BCM53115_A0_VLAN_CTRL5r_CLR
#define VLAN_CTRL5r_SET BCM53115_A0_VLAN_CTRL5r_SET
#define VLAN_CTRL5r_GET BCM53115_A0_VLAN_CTRL5r_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET BCM53115_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET BCM53115_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET
#define VLAN_CTRL5r_RESERVED_Rf_GET BCM53115_A0_VLAN_CTRL5r_RESERVED_Rf_GET
#define VLAN_CTRL5r_RESERVED_Rf_SET BCM53115_A0_VLAN_CTRL5r_RESERVED_Rf_SET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_GET BCM53115_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_SET BCM53115_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_GET BCM53115_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_SET BCM53115_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET BCM53115_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET BCM53115_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET
#define VLAN_CTRL5r_EN_PRESV_1P_TAGf_GET BCM53115_A0_VLAN_CTRL5r_EN_PRESV_1P_TAGf_GET
#define VLAN_CTRL5r_EN_PRESV_1P_TAGf_SET BCM53115_A0_VLAN_CTRL5r_EN_PRESV_1P_TAGf_SET
#define VLAN_CTRL5r_PRESV_NON1Qf_GET BCM53115_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET
#define VLAN_CTRL5r_PRESV_NON1Qf_SET BCM53115_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET
#define READ_VLAN_CTRL5r BCM53115_A0_READ_VLAN_CTRL5r
#define WRITE_VLAN_CTRL5r BCM53115_A0_WRITE_VLAN_CTRL5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_CTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  VLAN_CTRL6
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 6 Registers
 * SIZE:     8
 * FIELDS:
 *     STRICT_SFD_DETECT When enabled, 5388 drops frames with no preamble and start with SFD regardless of the phase rx clk at which nibble data of SFD is received.When disabled (dfault), 5388 drops such frames only at certain phase of the nibble data of SFD.NOTE: This register turns on a bug fix, so should be hidden in the customer datasheet. We decided to turn it off by default for safety purpose.0
 *     RESERVED_R       Reserved.
 *     DIS_ARL_BUST_LMT Disable ARL arbiter burst limit of 2 cycles.When set to 1, it disables the fix for ARL arbiter problem of not granting the high-priority request immediately. Default is 0.NOTE: Engineering only. Do not release this reg to customers
 *     ARL_LATE_SEL     Num of extra states to accommodate ARL latency.When 3'b000, lengthen rxfsm by 2 cycles (Default).When 3'b001, lengthen rxfsm by 3 cycles.When 3'b010, lengthen rxfsm by 4 cycles.When 3'b111, lengthen rxfsm by 1 cycles.When 3'b110, lengthen rxfsm by 0 cycles.When 3'b100, lengthen rxfsm by 2 cycles and turn off pulling in fmstopped effectively by 1 cycle.When other values, behaves the same as the 3'b000 case Default is 3'b000.NOTE: Engineering only. Do not release this reg to customers.
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_CTRL6r 0x00003407

#define BCM53115_A0_VLAN_CTRL6r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL6.
 *
 */
typedef union BCM53115_A0_VLAN_CTRL6r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl6[1];
	uint32_t _vlan_ctrl6;
} BCM53115_A0_VLAN_CTRL6r_t;

#define BCM53115_A0_VLAN_CTRL6r_CLR(r) (r).vlan_ctrl6[0] = 0
#define BCM53115_A0_VLAN_CTRL6r_SET(r,d) (r).vlan_ctrl6[0] = d
#define BCM53115_A0_VLAN_CTRL6r_GET(r) (r).vlan_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET(r) (((r).vlan_ctrl6[0]) & 0x1)
#define BCM53115_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_VLAN_CTRL6r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl6[0]) >> 1) & 0x7)
#define BCM53115_A0_VLAN_CTRL6r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53115_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET(r) ((((r).vlan_ctrl6[0]) >> 4) & 0x1)
#define BCM53115_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_VLAN_CTRL6r_ARL_LATE_SELf_GET(r) ((((r).vlan_ctrl6[0]) >> 5) & 0x7)
#define BCM53115_A0_VLAN_CTRL6r_ARL_LATE_SELf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access VLAN_CTRL6.
 *
 */
#define BCM53115_A0_READ_VLAN_CTRL6r(u,r) cdk_robo_reg_read(u,BCM53115_A0_VLAN_CTRL6r,(r._vlan_ctrl6),1)
#define BCM53115_A0_WRITE_VLAN_CTRL6r(u,r) cdk_robo_reg_write(u,BCM53115_A0_VLAN_CTRL6r,&(r._vlan_ctrl6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL6r BCM53115_A0_VLAN_CTRL6r
#define VLAN_CTRL6r_SIZE BCM53115_A0_VLAN_CTRL6r_SIZE
typedef BCM53115_A0_VLAN_CTRL6r_t VLAN_CTRL6r_t;
#define VLAN_CTRL6r_CLR BCM53115_A0_VLAN_CTRL6r_CLR
#define VLAN_CTRL6r_SET BCM53115_A0_VLAN_CTRL6r_SET
#define VLAN_CTRL6r_GET BCM53115_A0_VLAN_CTRL6r_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_GET BCM53115_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_SET BCM53115_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET
#define VLAN_CTRL6r_RESERVED_Rf_GET BCM53115_A0_VLAN_CTRL6r_RESERVED_Rf_GET
#define VLAN_CTRL6r_RESERVED_Rf_SET BCM53115_A0_VLAN_CTRL6r_RESERVED_Rf_SET
#define VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET BCM53115_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET
#define VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET BCM53115_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET
#define VLAN_CTRL6r_ARL_LATE_SELf_GET BCM53115_A0_VLAN_CTRL6r_ARL_LATE_SELf_GET
#define VLAN_CTRL6r_ARL_LATE_SELf_SET BCM53115_A0_VLAN_CTRL6r_ARL_LATE_SELf_SET
#define READ_VLAN_CTRL6r BCM53115_A0_READ_VLAN_CTRL6r
#define WRITE_VLAN_CTRL6r BCM53115_A0_WRITE_VLAN_CTRL6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_CTRL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  VLAN_MULTI_PORT_ADDR_CTL
 * BLOCKS:   SYS
 * DESC:     VLAN Multiport Address Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MPORT0_V_FWD_MAP When set to 1, MPORT_ADD0 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT0_UTG_MAP When set to 1, MPORT_ADD0 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT1_V_FWD_MAP When set to 1, MPORT_ADD1 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT1_UTG_MAP When set to 1, MPORT_ADD1 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT2_V_FWD_MAP When set to 1, MPORT_ADD2 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT2_UTG_MAP When set to 1, MPORT_ADD2 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT3_V_FWD_MAP When set to 1, MPORT_ADD3 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT3_UTG_MAP When set to 1, MPORT_ADD3 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT4_V_FWD_MAP When set to 1, MPORT_ADD4 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT4_UTG_MAP When set to 1, MPORT_ADD4 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT5_V_FWD_MAP When set to 1, MPORT_ADD5 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT5_UTG_MAP When set to 1, MPORT_ADD5 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr 0x0000340a

#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_SIZE 2

/*
 * This structure should be used to declare and program VLAN_MULTI_PORT_ADDR_CTL.
 *
 */
typedef union BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_s {
	uint32_t v[1];
	uint32_t vlan_multi_port_addr_ctl[1];
	uint32_t _vlan_multi_port_addr_ctl;
} BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_t;

#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_CLR(r) (r).vlan_multi_port_addr_ctl[0] = 0
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_SET(r,d) (r).vlan_multi_port_addr_ctl[0] = d
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_GET(r) (r).vlan_multi_port_addr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET(r) (((r).vlan_multi_port_addr_ctl[0]) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 1) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 2) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 3) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 4) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 5) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 6) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 7) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 8) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 9) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 10) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 11) & 0x1)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVED_Rf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 12) & 0xf)
#define BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVED_Rf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access VLAN_MULTI_PORT_ADDR_CTL.
 *
 */
#define BCM53115_A0_READ_VLAN_MULTI_PORT_ADDR_CTLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr,(r._vlan_multi_port_addr_ctl),2)
#define BCM53115_A0_WRITE_VLAN_MULTI_PORT_ADDR_CTLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr,&(r._vlan_multi_port_addr_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MULTI_PORT_ADDR_CTLr BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr
#define VLAN_MULTI_PORT_ADDR_CTLr_SIZE BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_SIZE
typedef BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_t VLAN_MULTI_PORT_ADDR_CTLr_t;
#define VLAN_MULTI_PORT_ADDR_CTLr_CLR BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_CLR
#define VLAN_MULTI_PORT_ADDR_CTLr_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_RESERVED_Rf_GET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVED_Rf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_RESERVED_Rf_SET BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVED_Rf_SET
#define READ_VLAN_MULTI_PORT_ADDR_CTLr BCM53115_A0_READ_VLAN_MULTI_PORT_ADDR_CTLr
#define WRITE_VLAN_MULTI_PORT_ADDR_CTLr BCM53115_A0_WRITE_VLAN_MULTI_PORT_ADDR_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_VLAN_MULTI_PORT_ADDR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  WAN_PORT_SEL
 * BLOCKS:   SYS
 * DESC:     WAN Port select Register
 * SIZE:     16
 * FIELDS:
 *     WAN_SELECT       
 *     RESERVED_R       Reserved
 *     EN_MAN2WAN       
 *     WAN_PORT_RESERVED Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_WAN_PORT_SELr 0x00000026

#define BCM53115_A0_WAN_PORT_SELr_SIZE 2

/*
 * This structure should be used to declare and program WAN_PORT_SEL.
 *
 */
typedef union BCM53115_A0_WAN_PORT_SELr_s {
	uint32_t v[1];
	uint32_t wan_port_sel[1];
	uint32_t _wan_port_sel;
} BCM53115_A0_WAN_PORT_SELr_t;

#define BCM53115_A0_WAN_PORT_SELr_CLR(r) (r).wan_port_sel[0] = 0
#define BCM53115_A0_WAN_PORT_SELr_SET(r,d) (r).wan_port_sel[0] = d
#define BCM53115_A0_WAN_PORT_SELr_GET(r) (r).wan_port_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_WAN_PORT_SELr_WAN_SELECTf_GET(r) (((r).wan_port_sel[0]) & 0x3f)
#define BCM53115_A0_WAN_PORT_SELr_WAN_SELECTf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53115_A0_WAN_PORT_SELr_RESERVED_Rf_GET(r) ((((r).wan_port_sel[0]) >> 6) & 0x7)
#define BCM53115_A0_WAN_PORT_SELr_RESERVED_Rf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53115_A0_WAN_PORT_SELr_EN_MAN2WANf_GET(r) ((((r).wan_port_sel[0]) >> 9) & 0x1)
#define BCM53115_A0_WAN_PORT_SELr_EN_MAN2WANf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53115_A0_WAN_PORT_SELr_WAN_PORT_RESERVEDf_GET(r) ((((r).wan_port_sel[0]) >> 10) & 0x3f)
#define BCM53115_A0_WAN_PORT_SELr_WAN_PORT_RESERVEDf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access WAN_PORT_SEL.
 *
 */
#define BCM53115_A0_READ_WAN_PORT_SELr(u,r) cdk_robo_reg_read(u,BCM53115_A0_WAN_PORT_SELr,(r._wan_port_sel),2)
#define BCM53115_A0_WRITE_WAN_PORT_SELr(u,r) cdk_robo_reg_write(u,BCM53115_A0_WAN_PORT_SELr,&(r._wan_port_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WAN_PORT_SELr BCM53115_A0_WAN_PORT_SELr
#define WAN_PORT_SELr_SIZE BCM53115_A0_WAN_PORT_SELr_SIZE
typedef BCM53115_A0_WAN_PORT_SELr_t WAN_PORT_SELr_t;
#define WAN_PORT_SELr_CLR BCM53115_A0_WAN_PORT_SELr_CLR
#define WAN_PORT_SELr_SET BCM53115_A0_WAN_PORT_SELr_SET
#define WAN_PORT_SELr_GET BCM53115_A0_WAN_PORT_SELr_GET
#define WAN_PORT_SELr_WAN_SELECTf_GET BCM53115_A0_WAN_PORT_SELr_WAN_SELECTf_GET
#define WAN_PORT_SELr_WAN_SELECTf_SET BCM53115_A0_WAN_PORT_SELr_WAN_SELECTf_SET
#define WAN_PORT_SELr_RESERVED_Rf_GET BCM53115_A0_WAN_PORT_SELr_RESERVED_Rf_GET
#define WAN_PORT_SELr_RESERVED_Rf_SET BCM53115_A0_WAN_PORT_SELr_RESERVED_Rf_SET
#define WAN_PORT_SELr_EN_MAN2WANf_GET BCM53115_A0_WAN_PORT_SELr_EN_MAN2WANf_GET
#define WAN_PORT_SELr_EN_MAN2WANf_SET BCM53115_A0_WAN_PORT_SELr_EN_MAN2WANf_SET
#define WAN_PORT_SELr_WAN_PORT_RESERVEDf_GET BCM53115_A0_WAN_PORT_SELr_WAN_PORT_RESERVEDf_GET
#define WAN_PORT_SELr_WAN_PORT_RESERVEDf_SET BCM53115_A0_WAN_PORT_SELr_WAN_PORT_RESERVEDf_SET
#define READ_WAN_PORT_SELr BCM53115_A0_READ_WAN_PORT_SELr
#define WRITE_WAN_PORT_SELr BCM53115_A0_WRITE_WAN_PORT_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_WAN_PORT_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  WATCH_DOG_CTRL
 * BLOCKS:   SYS
 * DESC:     Watch Dog Control Registrer
 * SIZE:     8
 * FIELDS:
 *     EN_RST_SWCODE    Enable Reset Switch Code.Default value by strap pin auto_reset_en.
 *     EN_RST_REGFILE   Enable Reset Register.Default value by strap pin auto_reset_en.
 *     EN_RELOAD_EEPROM Enable Reload EEPROM after software Reset.Default value by strap pin auto_reset_en.
 *     EN_AUTO_RESET    Enable watch dog Auto-Reset (in dumb system).Default value by strap pin auto_reset_en.
 *     EN_SW_RESET      Enable software  Reset.
 *     RESERVED_R       Reserved
 *     SOFTWARE_RESET   Enable Software Reset. (EN_SW_RST must be enabled as well1: Reset activeShoudl write software_reset bit 1, then write 0 to clear the reset state.
 *
 ******************************************************************************/
#define BCM53115_A0_WATCH_DOG_CTRLr 0x00000079

#define BCM53115_A0_WATCH_DOG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program WATCH_DOG_CTRL.
 *
 */
typedef union BCM53115_A0_WATCH_DOG_CTRLr_s {
	uint32_t v[1];
	uint32_t watch_dog_ctrl[1];
	uint32_t _watch_dog_ctrl;
} BCM53115_A0_WATCH_DOG_CTRLr_t;

#define BCM53115_A0_WATCH_DOG_CTRLr_CLR(r) (r).watch_dog_ctrl[0] = 0
#define BCM53115_A0_WATCH_DOG_CTRLr_SET(r,d) (r).watch_dog_ctrl[0] = d
#define BCM53115_A0_WATCH_DOG_CTRLr_GET(r) (r).watch_dog_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_RST_SWCODEf_GET(r) (((r).watch_dog_ctrl[0]) & 0x1)
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_RST_SWCODEf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET(r) ((((r).watch_dog_ctrl[0]) >> 1) & 0x1)
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET(r) ((((r).watch_dog_ctrl[0]) >> 2) & 0x1)
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_AUTO_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 3) & 0x1)
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_AUTO_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 4) & 0x1)
#define BCM53115_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53115_A0_WATCH_DOG_CTRLr_RESERVED_Rf_GET(r) ((((r).watch_dog_ctrl[0]) >> 5) & 0x3)
#define BCM53115_A0_WATCH_DOG_CTRLr_RESERVED_Rf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53115_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 7) & 0x1)
#define BCM53115_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access WATCH_DOG_CTRL.
 *
 */
#define BCM53115_A0_READ_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53115_A0_WATCH_DOG_CTRLr,(r._watch_dog_ctrl),1)
#define BCM53115_A0_WRITE_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53115_A0_WATCH_DOG_CTRLr,&(r._watch_dog_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_CTRLr BCM53115_A0_WATCH_DOG_CTRLr
#define WATCH_DOG_CTRLr_SIZE BCM53115_A0_WATCH_DOG_CTRLr_SIZE
typedef BCM53115_A0_WATCH_DOG_CTRLr_t WATCH_DOG_CTRLr_t;
#define WATCH_DOG_CTRLr_CLR BCM53115_A0_WATCH_DOG_CTRLr_CLR
#define WATCH_DOG_CTRLr_SET BCM53115_A0_WATCH_DOG_CTRLr_SET
#define WATCH_DOG_CTRLr_GET BCM53115_A0_WATCH_DOG_CTRLr_GET
#define WATCH_DOG_CTRLr_EN_RST_SWCODEf_GET BCM53115_A0_WATCH_DOG_CTRLr_EN_RST_SWCODEf_GET
#define WATCH_DOG_CTRLr_EN_RST_SWCODEf_SET BCM53115_A0_WATCH_DOG_CTRLr_EN_RST_SWCODEf_SET
#define WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET BCM53115_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET
#define WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET BCM53115_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET
#define WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET BCM53115_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET
#define WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET BCM53115_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET
#define WATCH_DOG_CTRLr_EN_AUTO_RESETf_GET BCM53115_A0_WATCH_DOG_CTRLr_EN_AUTO_RESETf_GET
#define WATCH_DOG_CTRLr_EN_AUTO_RESETf_SET BCM53115_A0_WATCH_DOG_CTRLr_EN_AUTO_RESETf_SET
#define WATCH_DOG_CTRLr_EN_SW_RESETf_GET BCM53115_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_GET
#define WATCH_DOG_CTRLr_EN_SW_RESETf_SET BCM53115_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_SET
#define WATCH_DOG_CTRLr_RESERVED_Rf_GET BCM53115_A0_WATCH_DOG_CTRLr_RESERVED_Rf_GET
#define WATCH_DOG_CTRLr_RESERVED_Rf_SET BCM53115_A0_WATCH_DOG_CTRLr_RESERVED_Rf_SET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET BCM53115_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET BCM53115_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET
#define READ_WATCH_DOG_CTRLr BCM53115_A0_READ_WATCH_DOG_CTRLr
#define WRITE_WATCH_DOG_CTRLr BCM53115_A0_WRITE_WATCH_DOG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_WATCH_DOG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  WATCH_DOG_RPT1
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 1 Registrer
 * SIZE:     16
 * FIELDS:
 *     TX_PORT_HUNG_INDICATOR Tx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_WATCH_DOG_RPT1r 0x0000007a

#define BCM53115_A0_WATCH_DOG_RPT1r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT1.
 *
 */
typedef union BCM53115_A0_WATCH_DOG_RPT1r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt1[1];
	uint32_t _watch_dog_rpt1;
} BCM53115_A0_WATCH_DOG_RPT1r_t;

#define BCM53115_A0_WATCH_DOG_RPT1r_CLR(r) (r).watch_dog_rpt1[0] = 0
#define BCM53115_A0_WATCH_DOG_RPT1r_SET(r,d) (r).watch_dog_rpt1[0] = d
#define BCM53115_A0_WATCH_DOG_RPT1r_GET(r) (r).watch_dog_rpt1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt1[0]) & 0x1ff)
#define BCM53115_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_WATCH_DOG_RPT1r_RESERVED_Rf_GET(r) ((((r).watch_dog_rpt1[0]) >> 9) & 0x7f)
#define BCM53115_A0_WATCH_DOG_RPT1r_RESERVED_Rf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT1.
 *
 */
#define BCM53115_A0_READ_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_read(u,BCM53115_A0_WATCH_DOG_RPT1r,(r._watch_dog_rpt1),2)
#define BCM53115_A0_WRITE_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_write(u,BCM53115_A0_WATCH_DOG_RPT1r,&(r._watch_dog_rpt1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT1r BCM53115_A0_WATCH_DOG_RPT1r
#define WATCH_DOG_RPT1r_SIZE BCM53115_A0_WATCH_DOG_RPT1r_SIZE
typedef BCM53115_A0_WATCH_DOG_RPT1r_t WATCH_DOG_RPT1r_t;
#define WATCH_DOG_RPT1r_CLR BCM53115_A0_WATCH_DOG_RPT1r_CLR
#define WATCH_DOG_RPT1r_SET BCM53115_A0_WATCH_DOG_RPT1r_SET
#define WATCH_DOG_RPT1r_GET BCM53115_A0_WATCH_DOG_RPT1r_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET BCM53115_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET BCM53115_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT1r_RESERVED_Rf_GET BCM53115_A0_WATCH_DOG_RPT1r_RESERVED_Rf_GET
#define WATCH_DOG_RPT1r_RESERVED_Rf_SET BCM53115_A0_WATCH_DOG_RPT1r_RESERVED_Rf_SET
#define READ_WATCH_DOG_RPT1r BCM53115_A0_READ_WATCH_DOG_RPT1r
#define WRITE_WATCH_DOG_RPT1r BCM53115_A0_WRITE_WATCH_DOG_RPT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_WATCH_DOG_RPT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  WATCH_DOG_RPT2
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 2 Registrer
 * SIZE:     16
 * FIELDS:
 *     RX_PORT_HUNG_INDICATOR Rx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_WATCH_DOG_RPT2r 0x0000007c

#define BCM53115_A0_WATCH_DOG_RPT2r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT2.
 *
 */
typedef union BCM53115_A0_WATCH_DOG_RPT2r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt2[1];
	uint32_t _watch_dog_rpt2;
} BCM53115_A0_WATCH_DOG_RPT2r_t;

#define BCM53115_A0_WATCH_DOG_RPT2r_CLR(r) (r).watch_dog_rpt2[0] = 0
#define BCM53115_A0_WATCH_DOG_RPT2r_SET(r,d) (r).watch_dog_rpt2[0] = d
#define BCM53115_A0_WATCH_DOG_RPT2r_GET(r) (r).watch_dog_rpt2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt2[0]) & 0x1ff)
#define BCM53115_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_WATCH_DOG_RPT2r_RESERVED_Rf_GET(r) ((((r).watch_dog_rpt2[0]) >> 9) & 0x7f)
#define BCM53115_A0_WATCH_DOG_RPT2r_RESERVED_Rf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT2.
 *
 */
#define BCM53115_A0_READ_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_read(u,BCM53115_A0_WATCH_DOG_RPT2r,(r._watch_dog_rpt2),2)
#define BCM53115_A0_WRITE_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_write(u,BCM53115_A0_WATCH_DOG_RPT2r,&(r._watch_dog_rpt2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT2r BCM53115_A0_WATCH_DOG_RPT2r
#define WATCH_DOG_RPT2r_SIZE BCM53115_A0_WATCH_DOG_RPT2r_SIZE
typedef BCM53115_A0_WATCH_DOG_RPT2r_t WATCH_DOG_RPT2r_t;
#define WATCH_DOG_RPT2r_CLR BCM53115_A0_WATCH_DOG_RPT2r_CLR
#define WATCH_DOG_RPT2r_SET BCM53115_A0_WATCH_DOG_RPT2r_SET
#define WATCH_DOG_RPT2r_GET BCM53115_A0_WATCH_DOG_RPT2r_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET BCM53115_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET BCM53115_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT2r_RESERVED_Rf_GET BCM53115_A0_WATCH_DOG_RPT2r_RESERVED_Rf_GET
#define WATCH_DOG_RPT2r_RESERVED_Rf_SET BCM53115_A0_WATCH_DOG_RPT2r_RESERVED_Rf_SET
#define READ_WATCH_DOG_RPT2r BCM53115_A0_READ_WATCH_DOG_RPT2r
#define WRITE_WATCH_DOG_RPT2r BCM53115_A0_WRITE_WATCH_DOG_RPT2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_WATCH_DOG_RPT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53115_A0
 * REGISTER:  WATCH_DOG_RPT3
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 3 Registrer
 * SIZE:     16
 * FIELDS:
 *     ARL_HUNG_INDICATOR ARL Indicator.Bit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM53115_A0_WATCH_DOG_RPT3r 0x0000007e

#define BCM53115_A0_WATCH_DOG_RPT3r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT3.
 *
 */
typedef union BCM53115_A0_WATCH_DOG_RPT3r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt3[1];
	uint32_t _watch_dog_rpt3;
} BCM53115_A0_WATCH_DOG_RPT3r_t;

#define BCM53115_A0_WATCH_DOG_RPT3r_CLR(r) (r).watch_dog_rpt3[0] = 0
#define BCM53115_A0_WATCH_DOG_RPT3r_SET(r,d) (r).watch_dog_rpt3[0] = d
#define BCM53115_A0_WATCH_DOG_RPT3r_GET(r) (r).watch_dog_rpt3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53115_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt3[0]) & 0x1ff)
#define BCM53115_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53115_A0_WATCH_DOG_RPT3r_RESERVED_Rf_GET(r) ((((r).watch_dog_rpt3[0]) >> 9) & 0x7f)
#define BCM53115_A0_WATCH_DOG_RPT3r_RESERVED_Rf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT3.
 *
 */
#define BCM53115_A0_READ_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_read(u,BCM53115_A0_WATCH_DOG_RPT3r,(r._watch_dog_rpt3),2)
#define BCM53115_A0_WRITE_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_write(u,BCM53115_A0_WATCH_DOG_RPT3r,&(r._watch_dog_rpt3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT3r BCM53115_A0_WATCH_DOG_RPT3r
#define WATCH_DOG_RPT3r_SIZE BCM53115_A0_WATCH_DOG_RPT3r_SIZE
typedef BCM53115_A0_WATCH_DOG_RPT3r_t WATCH_DOG_RPT3r_t;
#define WATCH_DOG_RPT3r_CLR BCM53115_A0_WATCH_DOG_RPT3r_CLR
#define WATCH_DOG_RPT3r_SET BCM53115_A0_WATCH_DOG_RPT3r_SET
#define WATCH_DOG_RPT3r_GET BCM53115_A0_WATCH_DOG_RPT3r_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET BCM53115_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET BCM53115_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT3r_RESERVED_Rf_GET BCM53115_A0_WATCH_DOG_RPT3r_RESERVED_Rf_GET
#define WATCH_DOG_RPT3r_RESERVED_Rf_SET BCM53115_A0_WATCH_DOG_RPT3r_RESERVED_Rf_SET
#define READ_WATCH_DOG_RPT3r BCM53115_A0_READ_WATCH_DOG_RPT3r
#define WRITE_WATCH_DOG_RPT3r BCM53115_A0_WRITE_WATCH_DOG_RPT3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53115_A0_WATCH_DOG_RPT3r'
 ******************************************************************************/

#define NUM_EGRESS_QUEUES       4


#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM53115_A0_DEFS_H__ */
