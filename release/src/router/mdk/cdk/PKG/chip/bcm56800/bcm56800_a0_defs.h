#ifndef __BCM56800_A0_DEFS_H__
#define __BCM56800_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM56800_A0.
 * This file provides all basic definitions required to program the BCM56800_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/xgs_reg.h>
#include <cdk/arch/xgs_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CMIC physical block/port */
#define BCM56800_A0_CMIC_BLOCK          15
#define BCM56800_A0_CMIC_PORT           20

/* Additional block types */
#define BCM56800_A0_BLKTYPE_BSAFE       0
#define BCM56800_A0_BLKTYPE_CMIC        1
#define BCM56800_A0_BLKTYPE_EPIPE       2
#define BCM56800_A0_BLKTYPE_GXPORT      3
#define BCM56800_A0_BLKTYPE_IPIPE       4
#define BCM56800_A0_BLKTYPE_MMU         5

/* Chip-specific flags */
#define BCM56800_A0_CHIP_FLAG_56580     0x80000000
#define BCM56800_A0_CHIP_FLAG_NOETH_X   0x40000000
#define BCM56800_A0_CHIP_FLAG_NOETH_Y   0x20000000
#define BCM56800_A0_CHIP_FLAG_TDM8_X    0x10000000
#define BCM56800_A0_CHIP_FLAG_TDM8_Y    0x08000000

#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_BLOCK                      BCM56800_A0_CMIC_BLOCK
#define CMIC_PORT                       BCM56800_A0_CMIC_PORT

#define BLKTYPE_BSAFE                   BCM56800_A0_BLKTYPE_BSAFE
#define BLKTYPE_CMIC                    BCM56800_A0_BLKTYPE_CMIC
#define BLKTYPE_EPIPE                   BCM56800_A0_BLKTYPE_EPIPE
#define BLKTYPE_GXPORT                  BCM56800_A0_BLKTYPE_GXPORT
#define BLKTYPE_IPIPE                   BCM56800_A0_BLKTYPE_IPIPE
#define BLKTYPE_MMU                     BCM56800_A0_BLKTYPE_MMU

#define CHIP_FLAG_56580                 BCM56800_A0_CHIP_FLAG_56580
#define CHIP_FLAG_NOETH_X               BCM56800_A0_CHIP_FLAG_NOETH_X
#define CHIP_FLAG_NOETH_Y               BCM56800_A0_CHIP_FLAG_NOETH_Y
#define CHIP_FLAG_TDM8_X                BCM56800_A0_CHIP_FLAG_TDM8_X
#define CHIP_FLAG_TDM8_Y                BCM56800_A0_CHIP_FLAG_TDM8_Y

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  ALTERNATE_EMIRROR_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Source Modid based blocking mask table, FeatureSpecific-Ethernet
 * SIZE:     21
 * FIELDS:
 *     BITMAP           HiGig port bitmap for Egress Mirror pkts.
 *
 ******************************************************************************/
#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm 0x0e16b000

#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_MIN 0
#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_MAX 127
#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_CMAX(u) 127
#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_SIZE 3

/*
 * This structure should be used to declare and program ALTERNATE_EMIRROR_BITMAP.
 *
 */
typedef union BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_s {
	uint32_t v[1];
	uint32_t alternate_emirror_bitmap[1];
	uint32_t _alternate_emirror_bitmap;
} BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_t;

#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_CLR(r) (r).alternate_emirror_bitmap[0] = 0
#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_SET(r,d) (r).alternate_emirror_bitmap[0] = d
#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_GET(r) (r).alternate_emirror_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_BITMAPf_GET(r) (((r).alternate_emirror_bitmap[0]) & 0x1fffff)
#define BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_BITMAPf_SET(r,f) (r).alternate_emirror_bitmap[0]=(((r).alternate_emirror_bitmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access ALTERNATE_EMIRROR_BITMAP.
 *
 */
#define BCM56800_A0_READ_ALTERNATE_EMIRROR_BITMAPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm,i,(m._alternate_emirror_bitmap),1)
#define BCM56800_A0_WRITE_ALTERNATE_EMIRROR_BITMAPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm,i,&(m._alternate_emirror_bitmap),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ALTERNATE_EMIRROR_BITMAPm BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm
#define ALTERNATE_EMIRROR_BITMAPm_MIN BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_MIN
#define ALTERNATE_EMIRROR_BITMAPm_MAX BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_MAX
#define ALTERNATE_EMIRROR_BITMAPm_CMAX(u) BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_CMAX(u)
#define ALTERNATE_EMIRROR_BITMAPm_SIZE BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_SIZE
typedef BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_t ALTERNATE_EMIRROR_BITMAPm_t;
#define ALTERNATE_EMIRROR_BITMAPm_CLR BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_CLR
#define ALTERNATE_EMIRROR_BITMAPm_SET BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_SET
#define ALTERNATE_EMIRROR_BITMAPm_GET BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_GET
#define ALTERNATE_EMIRROR_BITMAPm_BITMAPf_GET BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_BITMAPf_GET
#define ALTERNATE_EMIRROR_BITMAPm_BITMAPf_SET BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm_BITMAPf_SET
#define READ_ALTERNATE_EMIRROR_BITMAPm BCM56800_A0_READ_ALTERNATE_EMIRROR_BITMAPm
#define WRITE_ALTERNATE_EMIRROR_BITMAPm BCM56800_A0_WRITE_ALTERNATE_EMIRROR_BITMAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ALTERNATE_EMIRROR_BITMAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ASF_PORT_SPEED
 * BLOCKS:   MMU
 * DESC:     ASF_PORT_SPEED
 * SIZE:     32
 * FIELDS:
 *     ASF_PORT_SPEED   port_speed: port speed (for ASF check) for port X0= (do not participate in ASF)2=10Mbps-half-duplex, 3=10Mbps-full-duplex, 4=100Mbps-half-duplex, 5=100Mbps-full-duplex,6=1Gbps-half-duplex, 7=1Gbps-full-duplex, 8=2.5Gbps-half-duplex, 9=2.5Gbps-full-duplex,21=10Gbps (full duplex), 25=12Gbps (full duplex)[any values are valid as long as they go from slowest to fastest and are relative to the other ports]CPU port should be set to '0' to not participate.Note: with this encoding, port_speed[0] indicates full-duplex.
 *
 ******************************************************************************/
#define BCM56800_A0_ASF_PORT_SPEEDr 0x03d00004

#define BCM56800_A0_ASF_PORT_SPEEDr_SIZE 4

/*
 * This structure should be used to declare and program ASF_PORT_SPEED.
 *
 */
typedef union BCM56800_A0_ASF_PORT_SPEEDr_s {
	uint32_t v[1];
	uint32_t asf_port_speed[1];
	uint32_t _asf_port_speed;
} BCM56800_A0_ASF_PORT_SPEEDr_t;

#define BCM56800_A0_ASF_PORT_SPEEDr_CLR(r) (r).asf_port_speed[0] = 0
#define BCM56800_A0_ASF_PORT_SPEEDr_SET(r,d) (r).asf_port_speed[0] = d
#define BCM56800_A0_ASF_PORT_SPEEDr_GET(r) (r).asf_port_speed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ASF_PORT_SPEEDr_ASF_PORT_SPEEDf_GET(r) (((r).asf_port_speed[0]) & 0x1f)
#define BCM56800_A0_ASF_PORT_SPEEDr_ASF_PORT_SPEEDf_SET(r,f) (r).asf_port_speed[0]=(((r).asf_port_speed[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access ASF_PORT_SPEED.
 *
 */
#define BCM56800_A0_READ_ASF_PORT_SPEEDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ASF_PORT_SPEEDr,(r._asf_port_speed))
#define BCM56800_A0_WRITE_ASF_PORT_SPEEDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ASF_PORT_SPEEDr,&(r._asf_port_speed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ASF_PORT_SPEEDr BCM56800_A0_ASF_PORT_SPEEDr
#define ASF_PORT_SPEEDr_SIZE BCM56800_A0_ASF_PORT_SPEEDr_SIZE
typedef BCM56800_A0_ASF_PORT_SPEEDr_t ASF_PORT_SPEEDr_t;
#define ASF_PORT_SPEEDr_CLR BCM56800_A0_ASF_PORT_SPEEDr_CLR
#define ASF_PORT_SPEEDr_SET BCM56800_A0_ASF_PORT_SPEEDr_SET
#define ASF_PORT_SPEEDr_GET BCM56800_A0_ASF_PORT_SPEEDr_GET
#define ASF_PORT_SPEEDr_ASF_PORT_SPEEDf_GET BCM56800_A0_ASF_PORT_SPEEDr_ASF_PORT_SPEEDf_GET
#define ASF_PORT_SPEEDr_ASF_PORT_SPEEDf_SET BCM56800_A0_ASF_PORT_SPEEDr_ASF_PORT_SPEEDf_SET
#define READ_ASF_PORT_SPEEDr BCM56800_A0_READ_ASF_PORT_SPEEDr
#define WRITE_ASF_PORT_SPEEDr BCM56800_A0_WRITE_ASF_PORT_SPEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ASF_PORT_SPEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  AUX_ARB_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register for L2 table
 * SIZE:     32
 * FIELDS:
 *     L2_MOD_FIFO_LOCK Set to 1 to lock the L2_MOD_FIFO, clearing empties the L2_MOD_FIFO
 *     L2_MOD_FIFO_ENABLE Enables tracking the L2_MOD_FIFO, this cause learns/ages to get blocked when full
 *
 ******************************************************************************/
#define BCM56800_A0_AUX_ARB_CONTROLr 0x00180200

#define BCM56800_A0_AUX_ARB_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL.
 *
 */
typedef union BCM56800_A0_AUX_ARB_CONTROLr_s {
	uint32_t v[1];
	uint32_t aux_arb_control[1];
	uint32_t _aux_arb_control;
} BCM56800_A0_AUX_ARB_CONTROLr_t;

#define BCM56800_A0_AUX_ARB_CONTROLr_CLR(r) (r).aux_arb_control[0] = 0
#define BCM56800_A0_AUX_ARB_CONTROLr_SET(r,d) (r).aux_arb_control[0] = d
#define BCM56800_A0_AUX_ARB_CONTROLr_GET(r) (r).aux_arb_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET(r) (((r).aux_arb_control[0]) & 0x1)
#define BCM56800_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET(r) ((((r).aux_arb_control[0]) >> 1) & 0x1)
#define BCM56800_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET(r,f) (r).aux_arb_control[0]=(((r).aux_arb_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access AUX_ARB_CONTROL.
 *
 */
#define BCM56800_A0_READ_AUX_ARB_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_AUX_ARB_CONTROLr,(r._aux_arb_control))
#define BCM56800_A0_WRITE_AUX_ARB_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_AUX_ARB_CONTROLr,&(r._aux_arb_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_ARB_CONTROLr BCM56800_A0_AUX_ARB_CONTROLr
#define AUX_ARB_CONTROLr_SIZE BCM56800_A0_AUX_ARB_CONTROLr_SIZE
typedef BCM56800_A0_AUX_ARB_CONTROLr_t AUX_ARB_CONTROLr_t;
#define AUX_ARB_CONTROLr_CLR BCM56800_A0_AUX_ARB_CONTROLr_CLR
#define AUX_ARB_CONTROLr_SET BCM56800_A0_AUX_ARB_CONTROLr_SET
#define AUX_ARB_CONTROLr_GET BCM56800_A0_AUX_ARB_CONTROLr_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET BCM56800_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET BCM56800_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_LOCKf_SET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET BCM56800_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_GET
#define AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET BCM56800_A0_AUX_ARB_CONTROLr_L2_MOD_FIFO_ENABLEf_SET
#define READ_AUX_ARB_CONTROLr BCM56800_A0_READ_AUX_ARB_CONTROLr
#define WRITE_AUX_ARB_CONTROLr BCM56800_A0_WRITE_AUX_ARB_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_AUX_ARB_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  AUX_ARB_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     IP auxilary arbiter control register for FP functions. FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_REFRESH_ENABLE Enables sending FP refreshes down this pipeline
 *     CLK_GRAN         clock granularity for ages (speed up for simulation use only)
 *
 ******************************************************************************/
#define BCM56800_A0_AUX_ARB_CONTROL_2r 0x00180c01

#define BCM56800_A0_AUX_ARB_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program AUX_ARB_CONTROL_2.
 *
 */
typedef union BCM56800_A0_AUX_ARB_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t aux_arb_control_2[1];
	uint32_t _aux_arb_control_2;
} BCM56800_A0_AUX_ARB_CONTROL_2r_t;

#define BCM56800_A0_AUX_ARB_CONTROL_2r_CLR(r) (r).aux_arb_control_2[0] = 0
#define BCM56800_A0_AUX_ARB_CONTROL_2r_SET(r,d) (r).aux_arb_control_2[0] = d
#define BCM56800_A0_AUX_ARB_CONTROL_2r_GET(r) (r).aux_arb_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_GET(r) (((r).aux_arb_control_2[0]) & 0x1)
#define BCM56800_A0_AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_AUX_ARB_CONTROL_2r_CLK_GRANf_GET(r) ((((r).aux_arb_control_2[0]) >> 1) & 0x3)
#define BCM56800_A0_AUX_ARB_CONTROL_2r_CLK_GRANf_SET(r,f) (r).aux_arb_control_2[0]=(((r).aux_arb_control_2[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))

/*
 * These macros can be used to access AUX_ARB_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_AUX_ARB_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_AUX_ARB_CONTROL_2r,(r._aux_arb_control_2))
#define BCM56800_A0_WRITE_AUX_ARB_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_AUX_ARB_CONTROL_2r,&(r._aux_arb_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_ARB_CONTROL_2r BCM56800_A0_AUX_ARB_CONTROL_2r
#define AUX_ARB_CONTROL_2r_SIZE BCM56800_A0_AUX_ARB_CONTROL_2r_SIZE
typedef BCM56800_A0_AUX_ARB_CONTROL_2r_t AUX_ARB_CONTROL_2r_t;
#define AUX_ARB_CONTROL_2r_CLR BCM56800_A0_AUX_ARB_CONTROL_2r_CLR
#define AUX_ARB_CONTROL_2r_SET BCM56800_A0_AUX_ARB_CONTROL_2r_SET
#define AUX_ARB_CONTROL_2r_GET BCM56800_A0_AUX_ARB_CONTROL_2r_GET
#define AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_GET BCM56800_A0_AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_GET
#define AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_SET BCM56800_A0_AUX_ARB_CONTROL_2r_FP_REFRESH_ENABLEf_SET
#define AUX_ARB_CONTROL_2r_CLK_GRANf_GET BCM56800_A0_AUX_ARB_CONTROL_2r_CLK_GRANf_GET
#define AUX_ARB_CONTROL_2r_CLK_GRANf_SET BCM56800_A0_AUX_ARB_CONTROL_2r_CLK_GRANf_SET
#define READ_AUX_ARB_CONTROL_2r BCM56800_A0_READ_AUX_ARB_CONTROL_2r
#define WRITE_AUX_ARB_CONTROL_2r BCM56800_A0_WRITE_AUX_ARB_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_AUX_ARB_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Broadcast Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56800_A0_BCAST_BLOCK_MASKr 0x0e100042

#define BCM56800_A0_BCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_BLOCK_MASK.
 *
 */
typedef union BCM56800_A0_BCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t bcast_block_mask[1];
	uint32_t _bcast_block_mask;
} BCM56800_A0_BCAST_BLOCK_MASKr_t;

#define BCM56800_A0_BCAST_BLOCK_MASKr_CLR(r) (r).bcast_block_mask[0] = 0
#define BCM56800_A0_BCAST_BLOCK_MASKr_SET(r,d) (r).bcast_block_mask[0] = d
#define BCM56800_A0_BCAST_BLOCK_MASKr_GET(r) (r).bcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).bcast_block_mask[0]) & 0x1fffff)
#define BCM56800_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).bcast_block_mask[0]=(((r).bcast_block_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access BCAST_BLOCK_MASK.
 *
 */
#define BCM56800_A0_READ_BCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_BCAST_BLOCK_MASKr,(r._bcast_block_mask))
#define BCM56800_A0_WRITE_BCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_BCAST_BLOCK_MASKr,&(r._bcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_BLOCK_MASKr BCM56800_A0_BCAST_BLOCK_MASKr
#define BCAST_BLOCK_MASKr_SIZE BCM56800_A0_BCAST_BLOCK_MASKr_SIZE
typedef BCM56800_A0_BCAST_BLOCK_MASKr_t BCAST_BLOCK_MASKr_t;
#define BCAST_BLOCK_MASKr_CLR BCM56800_A0_BCAST_BLOCK_MASKr_CLR
#define BCAST_BLOCK_MASKr_SET BCM56800_A0_BCAST_BLOCK_MASKr_SET
#define BCAST_BLOCK_MASKr_GET BCM56800_A0_BCAST_BLOCK_MASKr_GET
#define BCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56800_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define BCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56800_A0_BCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_BCAST_BLOCK_MASKr BCM56800_A0_READ_BCAST_BLOCK_MASKr
#define WRITE_BCAST_BLOCK_MASKr BCM56800_A0_WRITE_BCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BCAST_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Broadcast Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           Broadcast rate control enable
 *
 ******************************************************************************/
#define BCM56800_A0_BCAST_STORM_CONTROLr 0x0b100001

#define BCM56800_A0_BCAST_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program BCAST_STORM_CONTROL.
 *
 */
typedef union BCM56800_A0_BCAST_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t bcast_storm_control[1];
	uint32_t _bcast_storm_control;
} BCM56800_A0_BCAST_STORM_CONTROLr_t;

#define BCM56800_A0_BCAST_STORM_CONTROLr_CLR(r) (r).bcast_storm_control[0] = 0
#define BCM56800_A0_BCAST_STORM_CONTROLr_SET(r,d) (r).bcast_storm_control[0] = d
#define BCM56800_A0_BCAST_STORM_CONTROLr_GET(r) (r).bcast_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BCAST_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).bcast_storm_control[0]) & 0x1ffffff)
#define BCM56800_A0_BCAST_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).bcast_storm_control[0]=(((r).bcast_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56800_A0_BCAST_STORM_CONTROLr_ENABLEf_GET(r) ((((r).bcast_storm_control[0]) >> 25) & 0x1)
#define BCM56800_A0_BCAST_STORM_CONTROLr_ENABLEf_SET(r,f) (r).bcast_storm_control[0]=(((r).bcast_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access BCAST_STORM_CONTROL.
 *
 */
#define BCM56800_A0_READ_BCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_BCAST_STORM_CONTROLr,(r._bcast_storm_control))
#define BCM56800_A0_WRITE_BCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_BCAST_STORM_CONTROLr,&(r._bcast_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BCAST_STORM_CONTROLr BCM56800_A0_BCAST_STORM_CONTROLr
#define BCAST_STORM_CONTROLr_SIZE BCM56800_A0_BCAST_STORM_CONTROLr_SIZE
typedef BCM56800_A0_BCAST_STORM_CONTROLr_t BCAST_STORM_CONTROLr_t;
#define BCAST_STORM_CONTROLr_CLR BCM56800_A0_BCAST_STORM_CONTROLr_CLR
#define BCAST_STORM_CONTROLr_SET BCM56800_A0_BCAST_STORM_CONTROLr_SET
#define BCAST_STORM_CONTROLr_GET BCM56800_A0_BCAST_STORM_CONTROLr_GET
#define BCAST_STORM_CONTROLr_THRESHOLDf_GET BCM56800_A0_BCAST_STORM_CONTROLr_THRESHOLDf_GET
#define BCAST_STORM_CONTROLr_THRESHOLDf_SET BCM56800_A0_BCAST_STORM_CONTROLr_THRESHOLDf_SET
#define BCAST_STORM_CONTROLr_ENABLEf_GET BCM56800_A0_BCAST_STORM_CONTROLr_ENABLEf_GET
#define BCAST_STORM_CONTROLr_ENABLEf_SET BCM56800_A0_BCAST_STORM_CONTROLr_ENABLEf_SET
#define READ_BCAST_STORM_CONTROLr BCM56800_A0_READ_BCAST_STORM_CONTROLr
#define WRITE_BCAST_STORM_CONTROLr BCM56800_A0_WRITE_BCAST_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BCAST_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BKPMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     Back-pressure Metering Bucket
 * SIZE:     32
 * FIELDS:
 *     BUCKET_COUNT     Pause Metering\'s Bucket Count for each ingress port
 *     OUT_PROFILE_FLAG OUT_PROFILE_FLAG inidcates the current state of Back Pressure Metering bucket1: out of profile0: In profile
 *
 ******************************************************************************/
#define BCM56800_A0_BKPMETERINGBUCKETr 0x09d00001

#define BCM56800_A0_BKPMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGBUCKET.
 *
 */
typedef union BCM56800_A0_BKPMETERINGBUCKETr_s {
	uint32_t v[1];
	uint32_t bkpmeteringbucket[1];
	uint32_t _bkpmeteringbucket;
} BCM56800_A0_BKPMETERINGBUCKETr_t;

#define BCM56800_A0_BKPMETERINGBUCKETr_CLR(r) (r).bkpmeteringbucket[0] = 0
#define BCM56800_A0_BKPMETERINGBUCKETr_SET(r,d) (r).bkpmeteringbucket[0] = d
#define BCM56800_A0_BKPMETERINGBUCKETr_GET(r) (r).bkpmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_GET(r) (((r).bkpmeteringbucket[0]) & 0x1fffffff)
#define BCM56800_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_SET(r,f) (r).bkpmeteringbucket[0]=(((r).bkpmeteringbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56800_A0_BKPMETERINGBUCKETr_OUT_PROFILE_FLAGf_GET(r) ((((r).bkpmeteringbucket[0]) >> 29) & 0x1)
#define BCM56800_A0_BKPMETERINGBUCKETr_OUT_PROFILE_FLAGf_SET(r,f) (r).bkpmeteringbucket[0]=(((r).bkpmeteringbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access BKPMETERINGBUCKET.
 *
 */
#define BCM56800_A0_READ_BKPMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_BKPMETERINGBUCKETr,(r._bkpmeteringbucket))
#define BCM56800_A0_WRITE_BKPMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_BKPMETERINGBUCKETr,&(r._bkpmeteringbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGBUCKETr BCM56800_A0_BKPMETERINGBUCKETr
#define BKPMETERINGBUCKETr_SIZE BCM56800_A0_BKPMETERINGBUCKETr_SIZE
typedef BCM56800_A0_BKPMETERINGBUCKETr_t BKPMETERINGBUCKETr_t;
#define BKPMETERINGBUCKETr_CLR BCM56800_A0_BKPMETERINGBUCKETr_CLR
#define BKPMETERINGBUCKETr_SET BCM56800_A0_BKPMETERINGBUCKETr_SET
#define BKPMETERINGBUCKETr_GET BCM56800_A0_BKPMETERINGBUCKETr_GET
#define BKPMETERINGBUCKETr_BUCKET_COUNTf_GET BCM56800_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_GET
#define BKPMETERINGBUCKETr_BUCKET_COUNTf_SET BCM56800_A0_BKPMETERINGBUCKETr_BUCKET_COUNTf_SET
#define BKPMETERINGBUCKETr_OUT_PROFILE_FLAGf_GET BCM56800_A0_BKPMETERINGBUCKETr_OUT_PROFILE_FLAGf_GET
#define BKPMETERINGBUCKETr_OUT_PROFILE_FLAGf_SET BCM56800_A0_BKPMETERINGBUCKETr_OUT_PROFILE_FLAGf_SET
#define READ_BKPMETERINGBUCKETr BCM56800_A0_READ_BKPMETERINGBUCKETr
#define WRITE_BKPMETERINGBUCKETr BCM56800_A0_WRITE_BKPMETERINGBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BKPMETERINGBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BKPMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     Back-pressure Metering Config
 * SIZE:     32
 * FIELDS:
 *     PAUSE_THD        Pause Threshold for start pause on pause metering of an ingress port:When Bucket Count fells below Pause Threshold, it sends out Back PressureWarning Status Message. This threshold must not over the size of Bucket Count. (256 Mbits)0x0: Disable, BKP Metering function is disabled.0x1:  32k bits, (32*1024),0x2:  64k bits, (64*1024),0x3: 128k bits, (128*1024),0x4: 256k bits, (256*1024),0x5: 512k bits, (512*1024),0x6:   1M bits, (1024*1024),0x7:   2M bits, (2*1024*1024),0x8:   4M bits, (4*1024*1024),0x9:   8M bits, (8*1024*1024),0xa:  16M bits, (16*1024*1024),0xb:  32M bits, (32*1024*1024),0xc:  64M bits, (64*1024*1024),0xd: 128M bits, (128*1024*1024),0xe: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,0xf: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,
 *     RESUME_THD       Resume Threshold for resume reception on pause metering of an ingress port:When Bucket Count reqain above Resume Threshold, it sends out Back PressureWarning Status Clearing Message. 0x0:  75% of PAUSE_THD.0x1:  50% of PAUSE_THD.0x2:  25% of PAUSE_THD.0x3:  12.5% of PAUSE_THD.
 *     DISCARD_THD      Discard Threshold for discarding packet on Back Pressure Metering bucket of an ingress port:When Bucket Count reqain above Resume Threshold, it sends out Back PressureWarning Status Clearing Message. This threshold select if the number over PAUSE_THD. (256 Mbits)0x0:  75% of PAUSE_THD above PAUSE_THD.0x1:  50% of PAUSE_THD above PAUSE_THD.0x2:  25% of PAUSE_THD above PAUSE_THD.0x3:  12.5% of PAUSE_THD above PAUSE_THD.
 *     REFRESHCOUNT     Refresh count for Back Pressure Metering bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set REFRESH = 15624.
 *     BKPDISCARD_EN    Back Pressure Metering Discard Message Enable:Enable Back Pressure Warning Message to discard packet formthis ingress port when Back Pressure Metering bucket count is above Discard Threshold.   
 *
 ******************************************************************************/
#define BCM56800_A0_BKPMETERINGCONFIGr 0x09d00000

#define BCM56800_A0_BKPMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGCONFIG.
 *
 */
typedef union BCM56800_A0_BKPMETERINGCONFIGr_s {
	uint32_t v[1];
	uint32_t bkpmeteringconfig[1];
	uint32_t _bkpmeteringconfig;
} BCM56800_A0_BKPMETERINGCONFIGr_t;

#define BCM56800_A0_BKPMETERINGCONFIGr_CLR(r) (r).bkpmeteringconfig[0] = 0
#define BCM56800_A0_BKPMETERINGCONFIGr_SET(r,d) (r).bkpmeteringconfig[0] = d
#define BCM56800_A0_BKPMETERINGCONFIGr_GET(r) (r).bkpmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BKPMETERINGCONFIGr_PAUSE_THDf_GET(r) (((r).bkpmeteringconfig[0]) & 0xf)
#define BCM56800_A0_BKPMETERINGCONFIGr_PAUSE_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_BKPMETERINGCONFIGr_RESUME_THDf_GET(r) ((((r).bkpmeteringconfig[0]) >> 4) & 0x3)
#define BCM56800_A0_BKPMETERINGCONFIGr_RESUME_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_BKPMETERINGCONFIGr_DISCARD_THDf_GET(r) ((((r).bkpmeteringconfig[0]) >> 6) & 0x3)
#define BCM56800_A0_BKPMETERINGCONFIGr_DISCARD_THDf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_GET(r) ((((r).bkpmeteringconfig[0]) >> 8) & 0x3ffff)
#define BCM56800_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x3ffff << 8)) | ((((uint32_t)f) & 0x3ffff) << 8))
#define BCM56800_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET(r) ((((r).bkpmeteringconfig[0]) >> 26) & 0x1)
#define BCM56800_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET(r,f) (r).bkpmeteringconfig[0]=(((r).bkpmeteringconfig[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access BKPMETERINGCONFIG.
 *
 */
#define BCM56800_A0_READ_BKPMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_BKPMETERINGCONFIGr,(r._bkpmeteringconfig))
#define BCM56800_A0_WRITE_BKPMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_BKPMETERINGCONFIGr,&(r._bkpmeteringconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGCONFIGr BCM56800_A0_BKPMETERINGCONFIGr
#define BKPMETERINGCONFIGr_SIZE BCM56800_A0_BKPMETERINGCONFIGr_SIZE
typedef BCM56800_A0_BKPMETERINGCONFIGr_t BKPMETERINGCONFIGr_t;
#define BKPMETERINGCONFIGr_CLR BCM56800_A0_BKPMETERINGCONFIGr_CLR
#define BKPMETERINGCONFIGr_SET BCM56800_A0_BKPMETERINGCONFIGr_SET
#define BKPMETERINGCONFIGr_GET BCM56800_A0_BKPMETERINGCONFIGr_GET
#define BKPMETERINGCONFIGr_PAUSE_THDf_GET BCM56800_A0_BKPMETERINGCONFIGr_PAUSE_THDf_GET
#define BKPMETERINGCONFIGr_PAUSE_THDf_SET BCM56800_A0_BKPMETERINGCONFIGr_PAUSE_THDf_SET
#define BKPMETERINGCONFIGr_RESUME_THDf_GET BCM56800_A0_BKPMETERINGCONFIGr_RESUME_THDf_GET
#define BKPMETERINGCONFIGr_RESUME_THDf_SET BCM56800_A0_BKPMETERINGCONFIGr_RESUME_THDf_SET
#define BKPMETERINGCONFIGr_DISCARD_THDf_GET BCM56800_A0_BKPMETERINGCONFIGr_DISCARD_THDf_GET
#define BKPMETERINGCONFIGr_DISCARD_THDf_SET BCM56800_A0_BKPMETERINGCONFIGr_DISCARD_THDf_SET
#define BKPMETERINGCONFIGr_REFRESHCOUNTf_GET BCM56800_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_GET
#define BKPMETERINGCONFIGr_REFRESHCOUNTf_SET BCM56800_A0_BKPMETERINGCONFIGr_REFRESHCOUNTf_SET
#define BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET BCM56800_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_GET
#define BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET BCM56800_A0_BKPMETERINGCONFIGr_BKPDISCARD_ENf_SET
#define READ_BKPMETERINGCONFIGr BCM56800_A0_READ_BKPMETERINGCONFIGr
#define WRITE_BKPMETERINGCONFIGr BCM56800_A0_WRITE_BKPMETERINGCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BKPMETERINGCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BKPMETERINGDISCSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering discard status
 *
 ******************************************************************************/
#define BCM56800_A0_BKPMETERINGDISCSTATUSr 0x09d80011

#define BCM56800_A0_BKPMETERINGDISCSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGDISCSTATUS.
 *
 */
typedef union BCM56800_A0_BKPMETERINGDISCSTATUSr_s {
	uint32_t v[1];
	uint32_t bkpmeteringdiscstatus[1];
	uint32_t _bkpmeteringdiscstatus;
} BCM56800_A0_BKPMETERINGDISCSTATUSr_t;

#define BCM56800_A0_BKPMETERINGDISCSTATUSr_CLR(r) (r).bkpmeteringdiscstatus[0] = 0
#define BCM56800_A0_BKPMETERINGDISCSTATUSr_SET(r,d) (r).bkpmeteringdiscstatus[0] = d
#define BCM56800_A0_BKPMETERINGDISCSTATUSr_GET(r) (r).bkpmeteringdiscstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET(r) (((r).bkpmeteringdiscstatus[0]) & 0x1fffff)
#define BCM56800_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringdiscstatus[0]=(((r).bkpmeteringdiscstatus[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access BKPMETERINGDISCSTATUS.
 *
 */
#define BCM56800_A0_READ_BKPMETERINGDISCSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BKPMETERINGDISCSTATUSr,(r._bkpmeteringdiscstatus))
#define BCM56800_A0_WRITE_BKPMETERINGDISCSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BKPMETERINGDISCSTATUSr,&(r._bkpmeteringdiscstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGDISCSTATUSr BCM56800_A0_BKPMETERINGDISCSTATUSr
#define BKPMETERINGDISCSTATUSr_SIZE BCM56800_A0_BKPMETERINGDISCSTATUSr_SIZE
typedef BCM56800_A0_BKPMETERINGDISCSTATUSr_t BKPMETERINGDISCSTATUSr_t;
#define BKPMETERINGDISCSTATUSr_CLR BCM56800_A0_BKPMETERINGDISCSTATUSr_CLR
#define BKPMETERINGDISCSTATUSr_SET BCM56800_A0_BKPMETERINGDISCSTATUSr_SET
#define BKPMETERINGDISCSTATUSr_GET BCM56800_A0_BKPMETERINGDISCSTATUSr_GET
#define BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET BCM56800_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_GET
#define BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET BCM56800_A0_BKPMETERINGDISCSTATUSr_PORT_BITMAPf_SET
#define READ_BKPMETERINGDISCSTATUSr BCM56800_A0_READ_BKPMETERINGDISCSTATUSr
#define WRITE_BKPMETERINGDISCSTATUSr BCM56800_A0_WRITE_BKPMETERINGDISCSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BKPMETERINGDISCSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BKPMETERINGWARNSTATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Current Back Pressure Metering warning status
 *
 ******************************************************************************/
#define BCM56800_A0_BKPMETERINGWARNSTATUSr 0x09d80010

#define BCM56800_A0_BKPMETERINGWARNSTATUSr_SIZE 4

/*
 * This structure should be used to declare and program BKPMETERINGWARNSTATUS.
 *
 */
typedef union BCM56800_A0_BKPMETERINGWARNSTATUSr_s {
	uint32_t v[1];
	uint32_t bkpmeteringwarnstatus[1];
	uint32_t _bkpmeteringwarnstatus;
} BCM56800_A0_BKPMETERINGWARNSTATUSr_t;

#define BCM56800_A0_BKPMETERINGWARNSTATUSr_CLR(r) (r).bkpmeteringwarnstatus[0] = 0
#define BCM56800_A0_BKPMETERINGWARNSTATUSr_SET(r,d) (r).bkpmeteringwarnstatus[0] = d
#define BCM56800_A0_BKPMETERINGWARNSTATUSr_GET(r) (r).bkpmeteringwarnstatus[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BKPMETERINGWARNSTATUSr_PORT_BITMAPf_GET(r) (((r).bkpmeteringwarnstatus[0]) & 0x1fffff)
#define BCM56800_A0_BKPMETERINGWARNSTATUSr_PORT_BITMAPf_SET(r,f) (r).bkpmeteringwarnstatus[0]=(((r).bkpmeteringwarnstatus[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access BKPMETERINGWARNSTATUS.
 *
 */
#define BCM56800_A0_READ_BKPMETERINGWARNSTATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BKPMETERINGWARNSTATUSr,(r._bkpmeteringwarnstatus))
#define BCM56800_A0_WRITE_BKPMETERINGWARNSTATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BKPMETERINGWARNSTATUSr,&(r._bkpmeteringwarnstatus))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKPMETERINGWARNSTATUSr BCM56800_A0_BKPMETERINGWARNSTATUSr
#define BKPMETERINGWARNSTATUSr_SIZE BCM56800_A0_BKPMETERINGWARNSTATUSr_SIZE
typedef BCM56800_A0_BKPMETERINGWARNSTATUSr_t BKPMETERINGWARNSTATUSr_t;
#define BKPMETERINGWARNSTATUSr_CLR BCM56800_A0_BKPMETERINGWARNSTATUSr_CLR
#define BKPMETERINGWARNSTATUSr_SET BCM56800_A0_BKPMETERINGWARNSTATUSr_SET
#define BKPMETERINGWARNSTATUSr_GET BCM56800_A0_BKPMETERINGWARNSTATUSr_GET
#define BKPMETERINGWARNSTATUSr_PORT_BITMAPf_GET BCM56800_A0_BKPMETERINGWARNSTATUSr_PORT_BITMAPf_GET
#define BKPMETERINGWARNSTATUSr_PORT_BITMAPf_SET BCM56800_A0_BKPMETERINGWARNSTATUSr_PORT_BITMAPf_SET
#define READ_BKPMETERINGWARNSTATUSr BCM56800_A0_READ_BKPMETERINGWARNSTATUSr
#define WRITE_BKPMETERINGWARNSTATUSr BCM56800_A0_WRITE_BKPMETERINGWARNSTATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BKPMETERINGWARNSTATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BKP_DISC_PRIORITY
 * BLOCKS:   IPIPE
 * DESC:     Back Pressure Discard Register
 * SIZE:     32
 * FIELDS:
 *     PRI_BITMAP       Back Pressure Discard Bitmap per Priority from MMU
 *
 ******************************************************************************/
#define BCM56800_A0_BKP_DISC_PRIORITYr 0x0e100063

#define BCM56800_A0_BKP_DISC_PRIORITYr_SIZE 4

/*
 * This structure should be used to declare and program BKP_DISC_PRIORITY.
 *
 */
typedef union BCM56800_A0_BKP_DISC_PRIORITYr_s {
	uint32_t v[1];
	uint32_t bkp_disc_priority[1];
	uint32_t _bkp_disc_priority;
} BCM56800_A0_BKP_DISC_PRIORITYr_t;

#define BCM56800_A0_BKP_DISC_PRIORITYr_CLR(r) (r).bkp_disc_priority[0] = 0
#define BCM56800_A0_BKP_DISC_PRIORITYr_SET(r,d) (r).bkp_disc_priority[0] = d
#define BCM56800_A0_BKP_DISC_PRIORITYr_GET(r) (r).bkp_disc_priority[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BKP_DISC_PRIORITYr_PRI_BITMAPf_GET(r) (((r).bkp_disc_priority[0]) & 0x3fff)
#define BCM56800_A0_BKP_DISC_PRIORITYr_PRI_BITMAPf_SET(r,f) (r).bkp_disc_priority[0]=(((r).bkp_disc_priority[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access BKP_DISC_PRIORITY.
 *
 */
#define BCM56800_A0_READ_BKP_DISC_PRIORITYr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_BKP_DISC_PRIORITYr,(r._bkp_disc_priority))
#define BCM56800_A0_WRITE_BKP_DISC_PRIORITYr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_BKP_DISC_PRIORITYr,&(r._bkp_disc_priority))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BKP_DISC_PRIORITYr BCM56800_A0_BKP_DISC_PRIORITYr
#define BKP_DISC_PRIORITYr_SIZE BCM56800_A0_BKP_DISC_PRIORITYr_SIZE
typedef BCM56800_A0_BKP_DISC_PRIORITYr_t BKP_DISC_PRIORITYr_t;
#define BKP_DISC_PRIORITYr_CLR BCM56800_A0_BKP_DISC_PRIORITYr_CLR
#define BKP_DISC_PRIORITYr_SET BCM56800_A0_BKP_DISC_PRIORITYr_SET
#define BKP_DISC_PRIORITYr_GET BCM56800_A0_BKP_DISC_PRIORITYr_GET
#define BKP_DISC_PRIORITYr_PRI_BITMAPf_GET BCM56800_A0_BKP_DISC_PRIORITYr_PRI_BITMAPf_GET
#define BKP_DISC_PRIORITYr_PRI_BITMAPf_SET BCM56800_A0_BKP_DISC_PRIORITYr_PRI_BITMAPf_SET
#define READ_BKP_DISC_PRIORITYr BCM56800_A0_READ_BKP_DISC_PRIORITYr
#define WRITE_BKP_DISC_PRIORITYr BCM56800_A0_WRITE_BKP_DISC_PRIORITYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BKP_DISC_PRIORITYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  BSAFE_CMD_DATA_IN
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register
 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Input data for command processing to the uHSM.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_CMD_DATA_INm 0x00e10000

#define BCM56800_A0_BSAFE_CMD_DATA_INm_MIN 0
#define BCM56800_A0_BSAFE_CMD_DATA_INm_MAX 255
#define BCM56800_A0_BSAFE_CMD_DATA_INm_CMAX(u) 255
#define BCM56800_A0_BSAFE_CMD_DATA_INm_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_CMD_DATA_IN.
 *
 */
typedef union BCM56800_A0_BSAFE_CMD_DATA_INm_s {
	uint32_t v[1];
	uint32_t bsafe_cmd_data_in[1];
	uint32_t _bsafe_cmd_data_in;
} BCM56800_A0_BSAFE_CMD_DATA_INm_t;

#define BCM56800_A0_BSAFE_CMD_DATA_INm_CLR(r) (r).bsafe_cmd_data_in[0] = 0
#define BCM56800_A0_BSAFE_CMD_DATA_INm_SET(r,d) (r).bsafe_cmd_data_in[0] = d
#define BCM56800_A0_BSAFE_CMD_DATA_INm_GET(r) (r).bsafe_cmd_data_in[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_CMD_DATA_INm_CMD_DINf_GET(r) ((r).bsafe_cmd_data_in[0])
#define BCM56800_A0_BSAFE_CMD_DATA_INm_CMD_DINf_SET(r,f) (r).bsafe_cmd_data_in[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_CMD_DATA_IN.
 *
 */
#define BCM56800_A0_READ_BSAFE_CMD_DATA_INm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_BSAFE_CMD_DATA_INm,i,(m._bsafe_cmd_data_in),1)
#define BCM56800_A0_WRITE_BSAFE_CMD_DATA_INm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_BSAFE_CMD_DATA_INm,i,&(m._bsafe_cmd_data_in),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_CMD_DATA_INm BCM56800_A0_BSAFE_CMD_DATA_INm
#define BSAFE_CMD_DATA_INm_MIN BCM56800_A0_BSAFE_CMD_DATA_INm_MIN
#define BSAFE_CMD_DATA_INm_MAX BCM56800_A0_BSAFE_CMD_DATA_INm_MAX
#define BSAFE_CMD_DATA_INm_CMAX(u) BCM56800_A0_BSAFE_CMD_DATA_INm_CMAX(u)
#define BSAFE_CMD_DATA_INm_SIZE BCM56800_A0_BSAFE_CMD_DATA_INm_SIZE
typedef BCM56800_A0_BSAFE_CMD_DATA_INm_t BSAFE_CMD_DATA_INm_t;
#define BSAFE_CMD_DATA_INm_CLR BCM56800_A0_BSAFE_CMD_DATA_INm_CLR
#define BSAFE_CMD_DATA_INm_SET BCM56800_A0_BSAFE_CMD_DATA_INm_SET
#define BSAFE_CMD_DATA_INm_GET BCM56800_A0_BSAFE_CMD_DATA_INm_GET
#define BSAFE_CMD_DATA_INm_CMD_DINf_GET BCM56800_A0_BSAFE_CMD_DATA_INm_CMD_DINf_GET
#define BSAFE_CMD_DATA_INm_CMD_DINf_SET BCM56800_A0_BSAFE_CMD_DATA_INm_CMD_DINf_SET
#define READ_BSAFE_CMD_DATA_INm BCM56800_A0_READ_BSAFE_CMD_DATA_INm
#define WRITE_BSAFE_CMD_DATA_INm BCM56800_A0_WRITE_BSAFE_CMD_DATA_INm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_CMD_DATA_INm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  BSAFE_CMD_DATA_OUT
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register
 * SIZE:     32
 * FIELDS:
 *     CMD_DOUT         Output data for command processing from the uHSM.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_CMD_DATA_OUTm 0x00e20000

#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_MIN 0
#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_MAX 255
#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_CMAX(u) 255
#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_CMD_DATA_OUT.
 *
 */
typedef union BCM56800_A0_BSAFE_CMD_DATA_OUTm_s {
	uint32_t v[1];
	uint32_t bsafe_cmd_data_out[1];
	uint32_t _bsafe_cmd_data_out;
} BCM56800_A0_BSAFE_CMD_DATA_OUTm_t;

#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_CLR(r) (r).bsafe_cmd_data_out[0] = 0
#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_SET(r,d) (r).bsafe_cmd_data_out[0] = d
#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_GET(r) (r).bsafe_cmd_data_out[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET(r) ((r).bsafe_cmd_data_out[0])
#define BCM56800_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET(r,f) (r).bsafe_cmd_data_out[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_CMD_DATA_OUT.
 *
 */
#define BCM56800_A0_READ_BSAFE_CMD_DATA_OUTm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_BSAFE_CMD_DATA_OUTm,i,(m._bsafe_cmd_data_out),1)
#define BCM56800_A0_WRITE_BSAFE_CMD_DATA_OUTm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_BSAFE_CMD_DATA_OUTm,i,&(m._bsafe_cmd_data_out),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_CMD_DATA_OUTm BCM56800_A0_BSAFE_CMD_DATA_OUTm
#define BSAFE_CMD_DATA_OUTm_MIN BCM56800_A0_BSAFE_CMD_DATA_OUTm_MIN
#define BSAFE_CMD_DATA_OUTm_MAX BCM56800_A0_BSAFE_CMD_DATA_OUTm_MAX
#define BSAFE_CMD_DATA_OUTm_CMAX(u) BCM56800_A0_BSAFE_CMD_DATA_OUTm_CMAX(u)
#define BSAFE_CMD_DATA_OUTm_SIZE BCM56800_A0_BSAFE_CMD_DATA_OUTm_SIZE
typedef BCM56800_A0_BSAFE_CMD_DATA_OUTm_t BSAFE_CMD_DATA_OUTm_t;
#define BSAFE_CMD_DATA_OUTm_CLR BCM56800_A0_BSAFE_CMD_DATA_OUTm_CLR
#define BSAFE_CMD_DATA_OUTm_SET BCM56800_A0_BSAFE_CMD_DATA_OUTm_SET
#define BSAFE_CMD_DATA_OUTm_GET BCM56800_A0_BSAFE_CMD_DATA_OUTm_GET
#define BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET BCM56800_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_GET
#define BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET BCM56800_A0_BSAFE_CMD_DATA_OUTm_CMD_DOUTf_SET
#define READ_BSAFE_CMD_DATA_OUTm BCM56800_A0_READ_BSAFE_CMD_DATA_OUTm
#define WRITE_BSAFE_CMD_DATA_OUTm BCM56800_A0_WRITE_BSAFE_CMD_DATA_OUTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_CMD_DATA_OUTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_CMD_CTRL
 * BLOCKS:   BSAFE
 * DESC:     This register is used to control the command interface for the uHSM. The 
values in this register are used to control the GLB_CMD_DATA_IN and 
GLB_CMD_DATA_OUT data input registers.

 * SIZE:     32
 * FIELDS:
 *     CMD_IRDY         COMMAND INPUT READY: Indicates that the GLB_CMD_DATA_IN register is ready to accept data from the local interface.
 *     CMD_ISYNC        COMMAND INPUT SYNC: This bit is set high to indicate the start of a command packet to the uHSM. It is lowered to zero on the last word of the command packet.
 *     CMD_ORDY         COMMAND OUTPUT READY: Indicates that the GLB_CMD_DATA_OUT register contains valid data.
 *     CMD_OSYNC        COMMAND OUTPUT SYNC: This bit is set high by to indicate the start of a command packet response from the uHSM. It is lowered on the last word of the command packet to indicate the end of the response.
 *     RESERVED_4       Reserved.
 *     SOFT_RST         Initiates a soft reset of the uHSM block. The state of the entire block is cleared to the power on reset values.  The soft reset can be initiated by the local host via the external interface OR the master controller.
 *     GPI              General Purpose Input: The input value of the GPIO[2:0] pins.
 *     RESERVED_3       Reserved.
 *     GPO              General Purpose Output: The output value that the GPIO[2:0] are set to by the master controller.
 *     RESERVED_2       Reserved.
 *     GPEN             General Purpose Enable: Controls the enable signal on the bi-directional GPIO[2:0] pins.
 *     RESERVED_1       Reserved.
 *     REVID            The uHSM revision identification based on the RTL netlist/ROM version. This revision identifier can potentially be the same for multiple chips as it identifies the version of the uHSM only.  The uHSM master controller sets these bits from a value stored in ROM.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr 0x00e80214

#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_CTRL.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_CMD_CTRLr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_ctrl[1];
	uint32_t _bsafe_glb_cmd_ctrl;
} BCM56800_A0_BSAFE_GLB_CMD_CTRLr_t;

#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CLR(r) (r).bsafe_glb_cmd_ctrl[0] = 0
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_SET(r,d) (r).bsafe_glb_cmd_ctrl[0] = d
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GET(r) (r).bsafe_glb_cmd_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET(r) (((r).bsafe_glb_cmd_ctrl[0]) & 0x1)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 3) & 0x1)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 4) & 0x7)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 7) & 0x1)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPIf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 8) & 0x7)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPIf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 11) & 0x1)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPOf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 12) & 0x7)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPOf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 15) & 0x1)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPENf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 16) & 0x7)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPENf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 19) & 0x1f)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0x1f << 19)) | ((((uint32_t)f) & 0x1f) << 19))
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_GET(r) ((((r).bsafe_glb_cmd_ctrl[0]) >> 24) & 0xff)
#define BCM56800_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_SET(r,f) (r).bsafe_glb_cmd_ctrl[0]=(((r).bsafe_glb_cmd_ctrl[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access BSAFE_GLB_CMD_CTRL.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_CMD_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_CMD_CTRLr,(r._bsafe_glb_cmd_ctrl))
#define BCM56800_A0_WRITE_BSAFE_GLB_CMD_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_CMD_CTRLr,&(r._bsafe_glb_cmd_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_CTRLr BCM56800_A0_BSAFE_GLB_CMD_CTRLr
#define BSAFE_GLB_CMD_CTRLr_SIZE BCM56800_A0_BSAFE_GLB_CMD_CTRLr_SIZE
typedef BCM56800_A0_BSAFE_GLB_CMD_CTRLr_t BSAFE_GLB_CMD_CTRLr_t;
#define BSAFE_GLB_CMD_CTRLr_CLR BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CLR
#define BSAFE_GLB_CMD_CTRLr_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_SET
#define BSAFE_GLB_CMD_CTRLr_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_IRDYf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_ISYNCf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_ORDYf_SET
#define BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_GET
#define BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_CMD_OSYNCf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_4f_SET
#define BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_GET
#define BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_SOFT_RSTf_SET
#define BSAFE_GLB_CMD_CTRLr_GPIf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPIf_GET
#define BSAFE_GLB_CMD_CTRLr_GPIf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPIf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_3f_SET
#define BSAFE_GLB_CMD_CTRLr_GPOf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPOf_GET
#define BSAFE_GLB_CMD_CTRLr_GPOf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPOf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_2f_SET
#define BSAFE_GLB_CMD_CTRLr_GPENf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPENf_GET
#define BSAFE_GLB_CMD_CTRLr_GPENf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_GPENf_SET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_GET
#define BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_RESERVED_1f_SET
#define BSAFE_GLB_CMD_CTRLr_REVIDf_GET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_GET
#define BSAFE_GLB_CMD_CTRLr_REVIDf_SET BCM56800_A0_BSAFE_GLB_CMD_CTRLr_REVIDf_SET
#define READ_BSAFE_GLB_CMD_CTRLr BCM56800_A0_READ_BSAFE_GLB_CMD_CTRLr
#define WRITE_BSAFE_GLB_CMD_CTRLr BCM56800_A0_WRITE_BSAFE_GLB_CMD_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_CMD_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_CMD_DATA_IN
 * BLOCKS:   BSAFE
 * DESC:     Command Data In Register.

 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Input data for command processing to the uHSM.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_INr 0x00e80218

#define BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_DATA_IN.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_data_in[1];
	uint32_t _bsafe_glb_cmd_data_in;
} BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_t;

#define BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_CLR(r) (r).bsafe_glb_cmd_data_in[0] = 0
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_SET(r,d) (r).bsafe_glb_cmd_data_in[0] = d
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_GET(r) (r).bsafe_glb_cmd_data_in[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET(r) ((r).bsafe_glb_cmd_data_in[0])
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET(r,f) (r).bsafe_glb_cmd_data_in[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_CMD_DATA_IN.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_CMD_DATA_INr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_CMD_DATA_INr,(r._bsafe_glb_cmd_data_in))
#define BCM56800_A0_WRITE_BSAFE_GLB_CMD_DATA_INr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_CMD_DATA_INr,&(r._bsafe_glb_cmd_data_in))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_DATA_INr BCM56800_A0_BSAFE_GLB_CMD_DATA_INr
#define BSAFE_GLB_CMD_DATA_INr_SIZE BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_SIZE
typedef BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_t BSAFE_GLB_CMD_DATA_INr_t;
#define BSAFE_GLB_CMD_DATA_INr_CLR BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_CLR
#define BSAFE_GLB_CMD_DATA_INr_SET BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_SET
#define BSAFE_GLB_CMD_DATA_INr_GET BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_GET
#define BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_GET
#define BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET BCM56800_A0_BSAFE_GLB_CMD_DATA_INr_CMD_DINf_SET
#define READ_BSAFE_GLB_CMD_DATA_INr BCM56800_A0_READ_BSAFE_GLB_CMD_DATA_INr
#define WRITE_BSAFE_GLB_CMD_DATA_INr BCM56800_A0_WRITE_BSAFE_GLB_CMD_DATA_INr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_CMD_DATA_INr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_CMD_DATA_OUT
 * BLOCKS:   BSAFE
 * DESC:     Command Data Out Register.

 * SIZE:     32
 * FIELDS:
 *     CMD_DIN          Output data for command processing from the uHSM.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr 0x00e8021c

#define BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_CMD_DATA_OUT.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_cmd_data_out[1];
	uint32_t _bsafe_glb_cmd_data_out;
} BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_t;

#define BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_CLR(r) (r).bsafe_glb_cmd_data_out[0] = 0
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_SET(r,d) (r).bsafe_glb_cmd_data_out[0] = d
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_GET(r) (r).bsafe_glb_cmd_data_out[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET(r) ((r).bsafe_glb_cmd_data_out[0])
#define BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET(r,f) (r).bsafe_glb_cmd_data_out[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_CMD_DATA_OUT.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_CMD_DATA_OUTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr,(r._bsafe_glb_cmd_data_out))
#define BCM56800_A0_WRITE_BSAFE_GLB_CMD_DATA_OUTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr,&(r._bsafe_glb_cmd_data_out))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_CMD_DATA_OUTr BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr
#define BSAFE_GLB_CMD_DATA_OUTr_SIZE BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_SIZE
typedef BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_t BSAFE_GLB_CMD_DATA_OUTr_t;
#define BSAFE_GLB_CMD_DATA_OUTr_CLR BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_CLR
#define BSAFE_GLB_CMD_DATA_OUTr_SET BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_SET
#define BSAFE_GLB_CMD_DATA_OUTr_GET BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_GET
#define BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_GET
#define BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr_CMD_DINf_SET
#define READ_BSAFE_GLB_CMD_DATA_OUTr BCM56800_A0_READ_BSAFE_GLB_CMD_DATA_OUTr
#define WRITE_BSAFE_GLB_CMD_DATA_OUTr BCM56800_A0_WRITE_BSAFE_GLB_CMD_DATA_OUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_CMD_DATA_OUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_DEV_STATUS
 * BLOCKS:   BSAFE
 * DESC:     The status register is accessible by the local host at any time to indicate 
the current status of the uHSM. The local host must use the GLB_STATUS.BUSY 
bits to determine when it can access the data buffer via external interface.

 * SIZE:     32
 * FIELDS:
 *     BUSY             These bits lock out access to the command registers.  It indicates that the uHSM block is busy processing a command.  On reset, these bits will indicate busy until the master controller is ready to accept commands (INIT_DONE=1).
 *     INIT_DONE        Indicates that initialization has competed.
 *     KS_ACTIVE        Key session setup have been completed and the session is active.
 *     RESERVED_2       Reserved.
 *     PROD_CFG_VLD     This flag is set when the prod_config register is initializedwith the value stored in NVM. Setting this flag informsthe external world that the content of theprod_config register is good to be sampled.
 *     RESERVED_1       Reserved.
 *     POST_STAT        This field holds the POST result vector as defined in uHSM_SELF_TEST. A none-zero value indicate a failure has occured in the system.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr 0x00e80210

#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_DEV_STATUS.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_DEV_STATUSr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_dev_status[1];
	uint32_t _bsafe_glb_dev_status;
} BCM56800_A0_BSAFE_GLB_DEV_STATUSr_t;

#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_CLR(r) (r).bsafe_glb_dev_status[0] = 0
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_SET(r,d) (r).bsafe_glb_dev_status[0] = d
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_GET(r) (r).bsafe_glb_dev_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_GET(r) (((r).bsafe_glb_dev_status[0]) & 0x3)
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 4) & 0x1)
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 5) & 0x1)
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 6) & 0x1)
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 7) & 0x1)
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 8) & 0xff)
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_POST_STATf_GET(r) ((((r).bsafe_glb_dev_status[0]) >> 16) & 0xffff)
#define BCM56800_A0_BSAFE_GLB_DEV_STATUSr_POST_STATf_SET(r,f) (r).bsafe_glb_dev_status[0]=(((r).bsafe_glb_dev_status[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access BSAFE_GLB_DEV_STATUS.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_DEV_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_DEV_STATUSr,(r._bsafe_glb_dev_status))
#define BCM56800_A0_WRITE_BSAFE_GLB_DEV_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_DEV_STATUSr,&(r._bsafe_glb_dev_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_DEV_STATUSr BCM56800_A0_BSAFE_GLB_DEV_STATUSr
#define BSAFE_GLB_DEV_STATUSr_SIZE BCM56800_A0_BSAFE_GLB_DEV_STATUSr_SIZE
typedef BCM56800_A0_BSAFE_GLB_DEV_STATUSr_t BSAFE_GLB_DEV_STATUSr_t;
#define BSAFE_GLB_DEV_STATUSr_CLR BCM56800_A0_BSAFE_GLB_DEV_STATUSr_CLR
#define BSAFE_GLB_DEV_STATUSr_SET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_SET
#define BSAFE_GLB_DEV_STATUSr_GET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_GET
#define BSAFE_GLB_DEV_STATUSr_BUSYf_GET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_GET
#define BSAFE_GLB_DEV_STATUSr_BUSYf_SET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_BUSYf_SET
#define BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_GET
#define BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_INIT_DONEf_SET
#define BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_GET
#define BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_KS_ACTIVEf_SET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_GET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_2f_SET
#define BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_GET
#define BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_PROD_CFG_VLDf_SET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_GET
#define BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_RESERVED_1f_SET
#define BSAFE_GLB_DEV_STATUSr_POST_STATf_GET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_POST_STATf_GET
#define BSAFE_GLB_DEV_STATUSr_POST_STATf_SET BCM56800_A0_BSAFE_GLB_DEV_STATUSr_POST_STATf_SET
#define READ_BSAFE_GLB_DEV_STATUSr BCM56800_A0_READ_BSAFE_GLB_DEV_STATUSr
#define WRITE_BSAFE_GLB_DEV_STATUSr BCM56800_A0_WRITE_BSAFE_GLB_DEV_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_DEV_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_INT_CTRL
 * BLOCKS:   BSAFE
 * DESC:     Interrupt Control Register.

 * SIZE:     32
 * FIELDS:
 *     SRC_CDONE        COMMAND DONE: Indicates that the uHSM has completed a command.
 *     SRC_CERR         COMMAND ERROR: Indicates that the uHSM has completed a command that returns a non-zero returnCode.
 *     SRC_RDY          READY: Indicates that the uHSM is ready to accept a command.
 *     SRC_DEV_FAILURE  Device failure: when set, it indicates a device failure has been detected byPOST or uHSM_SELF_TEST.
 *     SRC_SAL          SECURITY ASSURANCE LOGIC: Indicates that the SAL has triggered an interrupt. The SAL status register should be read for more information.
 *     RESERVED_2       Reserved.
 *     INT_SRC_EN       INTERRUPT SOURCE ENABLE: The interrupt mask register. Each bit corresponds to an individual interrupt source defined in SRC_xxxx[3:0]
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr 0x00e80220

#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_INT_CTRL.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_INT_CTRLr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_int_ctrl[1];
	uint32_t _bsafe_glb_int_ctrl;
} BCM56800_A0_BSAFE_GLB_INT_CTRLr_t;

#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_CLR(r) (r).bsafe_glb_int_ctrl[0] = 0
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SET(r,d) (r).bsafe_glb_int_ctrl[0] = d
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_GET(r) (r).bsafe_glb_int_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET(r) (((r).bsafe_glb_int_ctrl[0]) & 0x1)
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_DEV_FAILUREf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 3) & 0x1)
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_DEV_FAILUREf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 4) & 0x1)
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 5) & 0x7)
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 8) & 0x1f)
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET(r) ((((r).bsafe_glb_int_ctrl[0]) >> 13) & 0x7ffff)
#define BCM56800_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET(r,f) (r).bsafe_glb_int_ctrl[0]=(((r).bsafe_glb_int_ctrl[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access BSAFE_GLB_INT_CTRL.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_INT_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_INT_CTRLr,(r._bsafe_glb_int_ctrl))
#define BCM56800_A0_WRITE_BSAFE_GLB_INT_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_INT_CTRLr,&(r._bsafe_glb_int_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_INT_CTRLr BCM56800_A0_BSAFE_GLB_INT_CTRLr
#define BSAFE_GLB_INT_CTRLr_SIZE BCM56800_A0_BSAFE_GLB_INT_CTRLr_SIZE
typedef BCM56800_A0_BSAFE_GLB_INT_CTRLr_t BSAFE_GLB_INT_CTRLr_t;
#define BSAFE_GLB_INT_CTRLr_CLR BCM56800_A0_BSAFE_GLB_INT_CTRLr_CLR
#define BSAFE_GLB_INT_CTRLr_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SET
#define BSAFE_GLB_INT_CTRLr_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_CDONEf_SET
#define BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_CERRf_SET
#define BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_RDYf_SET
#define BSAFE_GLB_INT_CTRLr_SRC_DEV_FAILUREf_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_DEV_FAILUREf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_DEV_FAILUREf_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_DEV_FAILUREf_SET
#define BSAFE_GLB_INT_CTRLr_SRC_SALf_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_GET
#define BSAFE_GLB_INT_CTRLr_SRC_SALf_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_SRC_SALf_SET
#define BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_GET
#define BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_RESERVED_2f_SET
#define BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_GET
#define BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_INT_SRC_ENf_SET
#define BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET BCM56800_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_GET
#define BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET BCM56800_A0_BSAFE_GLB_INT_CTRLr_RESERVED_1f_SET
#define READ_BSAFE_GLB_INT_CTRLr BCM56800_A0_READ_BSAFE_GLB_INT_CTRLr
#define WRITE_BSAFE_GLB_INT_CTRLr BCM56800_A0_WRITE_BSAFE_GLB_INT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_INT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_MEM_PARAM
 * BLOCKS:   BSAFE
 * DESC:     MEM Parameter Register.

 * SIZE:     32
 * FIELDS:
 *     RAM_TM           SRAM tm (test mode)This is a direct input to the scratch SRAM block. It is used to put the instance intovarious test modes that can be used for a number of different purposes includingextended screening, yield improvement and debug. The default mode of the instance istm[3:0] = 4'b0000. It is highly recomended that the user has control over all thetm[3:0] inputs. All tm[3:0] inputs are asynchronous. See the Test Modes section of theon line G90SP Web Specification for further details.This field can be reset by hard rest and SAL reset. Soft reset has not effect on thisfield.
 *     ROM_TEST         ROM test mode. This is a direct input to all ROM blocks. It controls the senseamp timing. If this field is set, ROM output is available after the following edgeof the clock. Otherwise, the ROM output delay is self timed. This bit helps determinewhether there is a mismatch between the reference sense amp and the regular senseamp, or the memory cell is weak. This field can be reset by hard reset and SAL reset.Soft reset has no effect to this field.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr 0x00e80224

#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_MEM_PARAM.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_MEM_PARAMr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_mem_param[1];
	uint32_t _bsafe_glb_mem_param;
} BCM56800_A0_BSAFE_GLB_MEM_PARAMr_t;

#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_CLR(r) (r).bsafe_glb_mem_param[0] = 0
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_SET(r,d) (r).bsafe_glb_mem_param[0] = d
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_GET(r) (r).bsafe_glb_mem_param[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_RAM_TMf_GET(r) ((((r).bsafe_glb_mem_param[0]) >> 4) & 0xf)
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_RAM_TMf_SET(r,f) (r).bsafe_glb_mem_param[0]=(((r).bsafe_glb_mem_param[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_ROM_TESTf_GET(r) ((((r).bsafe_glb_mem_param[0]) >> 8) & 0x1)
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_ROM_TESTf_SET(r,f) (r).bsafe_glb_mem_param[0]=(((r).bsafe_glb_mem_param[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_RESERVEDf_GET(r) ((((r).bsafe_glb_mem_param[0]) >> 9) & 0x7fffff)
#define BCM56800_A0_BSAFE_GLB_MEM_PARAMr_RESERVEDf_SET(r,f) (r).bsafe_glb_mem_param[0]=(((r).bsafe_glb_mem_param[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access BSAFE_GLB_MEM_PARAM.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_MEM_PARAMr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_MEM_PARAMr,(r._bsafe_glb_mem_param))
#define BCM56800_A0_WRITE_BSAFE_GLB_MEM_PARAMr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_MEM_PARAMr,&(r._bsafe_glb_mem_param))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_MEM_PARAMr BCM56800_A0_BSAFE_GLB_MEM_PARAMr
#define BSAFE_GLB_MEM_PARAMr_SIZE BCM56800_A0_BSAFE_GLB_MEM_PARAMr_SIZE
typedef BCM56800_A0_BSAFE_GLB_MEM_PARAMr_t BSAFE_GLB_MEM_PARAMr_t;
#define BSAFE_GLB_MEM_PARAMr_CLR BCM56800_A0_BSAFE_GLB_MEM_PARAMr_CLR
#define BSAFE_GLB_MEM_PARAMr_SET BCM56800_A0_BSAFE_GLB_MEM_PARAMr_SET
#define BSAFE_GLB_MEM_PARAMr_GET BCM56800_A0_BSAFE_GLB_MEM_PARAMr_GET
#define BSAFE_GLB_MEM_PARAMr_RAM_TMf_GET BCM56800_A0_BSAFE_GLB_MEM_PARAMr_RAM_TMf_GET
#define BSAFE_GLB_MEM_PARAMr_RAM_TMf_SET BCM56800_A0_BSAFE_GLB_MEM_PARAMr_RAM_TMf_SET
#define BSAFE_GLB_MEM_PARAMr_ROM_TESTf_GET BCM56800_A0_BSAFE_GLB_MEM_PARAMr_ROM_TESTf_GET
#define BSAFE_GLB_MEM_PARAMr_ROM_TESTf_SET BCM56800_A0_BSAFE_GLB_MEM_PARAMr_ROM_TESTf_SET
#define BSAFE_GLB_MEM_PARAMr_RESERVEDf_GET BCM56800_A0_BSAFE_GLB_MEM_PARAMr_RESERVEDf_GET
#define BSAFE_GLB_MEM_PARAMr_RESERVEDf_SET BCM56800_A0_BSAFE_GLB_MEM_PARAMr_RESERVEDf_SET
#define READ_BSAFE_GLB_MEM_PARAMr BCM56800_A0_READ_BSAFE_GLB_MEM_PARAMr
#define WRITE_BSAFE_GLB_MEM_PARAMr BCM56800_A0_WRITE_BSAFE_GLB_MEM_PARAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_MEM_PARAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_MEM_TST_CTL
 * BLOCKS:   BSAFE
 * DESC:     MEM Test Control Register.

 * SIZE:     32
 * FIELDS:
 *     OCST_EN          NVM over-current stress test enable.Setting this bit put NVM into over-current stress test mode. The time duration forOCST is in the range of a few hundred milliseconds to a couple of seconds.This field is OR'ed with the OCST iput pin.l The OCST mode can be disabled after NVMprogramming.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr 0x00e80228

#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_MEM_TST_CTL.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_mem_tst_ctl[1];
	uint32_t _bsafe_glb_mem_tst_ctl;
} BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_t;

#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_CLR(r) (r).bsafe_glb_mem_tst_ctl[0] = 0
#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_SET(r,d) (r).bsafe_glb_mem_tst_ctl[0] = d
#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_GET(r) (r).bsafe_glb_mem_tst_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_OCST_ENf_GET(r) (((r).bsafe_glb_mem_tst_ctl[0]) & 0x1)
#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_OCST_ENf_SET(r,f) (r).bsafe_glb_mem_tst_ctl[0]=(((r).bsafe_glb_mem_tst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_RESERVEDf_GET(r) ((((r).bsafe_glb_mem_tst_ctl[0]) >> 1) & 0x7fffffff)
#define BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_RESERVEDf_SET(r,f) (r).bsafe_glb_mem_tst_ctl[0]=(((r).bsafe_glb_mem_tst_ctl[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access BSAFE_GLB_MEM_TST_CTL.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_MEM_TST_CTLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr,(r._bsafe_glb_mem_tst_ctl))
#define BCM56800_A0_WRITE_BSAFE_GLB_MEM_TST_CTLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr,&(r._bsafe_glb_mem_tst_ctl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_MEM_TST_CTLr BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr
#define BSAFE_GLB_MEM_TST_CTLr_SIZE BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_SIZE
typedef BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_t BSAFE_GLB_MEM_TST_CTLr_t;
#define BSAFE_GLB_MEM_TST_CTLr_CLR BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_CLR
#define BSAFE_GLB_MEM_TST_CTLr_SET BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_SET
#define BSAFE_GLB_MEM_TST_CTLr_GET BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_GET
#define BSAFE_GLB_MEM_TST_CTLr_OCST_ENf_GET BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_OCST_ENf_GET
#define BSAFE_GLB_MEM_TST_CTLr_OCST_ENf_SET BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_OCST_ENf_SET
#define BSAFE_GLB_MEM_TST_CTLr_RESERVEDf_GET BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_RESERVEDf_GET
#define BSAFE_GLB_MEM_TST_CTLr_RESERVEDf_SET BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr_RESERVEDf_SET
#define READ_BSAFE_GLB_MEM_TST_CTLr BCM56800_A0_READ_BSAFE_GLB_MEM_TST_CTLr
#define WRITE_BSAFE_GLB_MEM_TST_CTLr BCM56800_A0_WRITE_BSAFE_GLB_MEM_TST_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_MEM_TST_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_PRESCALE
 * BLOCKS:   BSAFE
 * DESC:     The reference clock (refclk) input is pre-scaled to provide a nominal 1 second 
clock tick used to increment the GLB_TIMER register. The reference clock is 
divided by four in the reference clock domain, then synchronized to the core 
clock domain.  The core clock input must be equal to or greater than the 
reference clock input for all frequencies. The divide by four ensures that 
the reference clock is sampled properly. Therefore, the time tick is calculated
as follows: period = (refclk period * PRESCALE * 4)
When the refclk is 6.25MHz, the prescalar should have the value 0x17D784. When 
the refclk is 62.5MHz, the prescalar should have the value 0xEE6B28.
This register is write-once protected. It can only be written one time
by an sbus write access. Further write attempts are ignored by uHSM.

 * SIZE:     32
 * FIELDS:
 *     PRESCALE         Pre-scalar value for the system time tick. The defaultvalue assumes a 6.25MHz reference system clock input.The value of this register can only be initialized onceafter each hardware reset. Subsequent write operations tothis register through the register access interface will nothave any effect.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_PRESCALEr 0x00e80204

#define BCM56800_A0_BSAFE_GLB_PRESCALEr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_PRESCALE.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_PRESCALEr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_prescale[1];
	uint32_t _bsafe_glb_prescale;
} BCM56800_A0_BSAFE_GLB_PRESCALEr_t;

#define BCM56800_A0_BSAFE_GLB_PRESCALEr_CLR(r) (r).bsafe_glb_prescale[0] = 0
#define BCM56800_A0_BSAFE_GLB_PRESCALEr_SET(r,d) (r).bsafe_glb_prescale[0] = d
#define BCM56800_A0_BSAFE_GLB_PRESCALEr_GET(r) (r).bsafe_glb_prescale[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_GET(r) (((r).bsafe_glb_prescale[0]) & 0xffffff)
#define BCM56800_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_SET(r,f) (r).bsafe_glb_prescale[0]=(((r).bsafe_glb_prescale[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56800_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_GET(r) ((((r).bsafe_glb_prescale[0]) >> 24) & 0xff)
#define BCM56800_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_SET(r,f) (r).bsafe_glb_prescale[0]=(((r).bsafe_glb_prescale[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access BSAFE_GLB_PRESCALE.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_PRESCALEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_PRESCALEr,(r._bsafe_glb_prescale))
#define BCM56800_A0_WRITE_BSAFE_GLB_PRESCALEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_PRESCALEr,&(r._bsafe_glb_prescale))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_PRESCALEr BCM56800_A0_BSAFE_GLB_PRESCALEr
#define BSAFE_GLB_PRESCALEr_SIZE BCM56800_A0_BSAFE_GLB_PRESCALEr_SIZE
typedef BCM56800_A0_BSAFE_GLB_PRESCALEr_t BSAFE_GLB_PRESCALEr_t;
#define BSAFE_GLB_PRESCALEr_CLR BCM56800_A0_BSAFE_GLB_PRESCALEr_CLR
#define BSAFE_GLB_PRESCALEr_SET BCM56800_A0_BSAFE_GLB_PRESCALEr_SET
#define BSAFE_GLB_PRESCALEr_GET BCM56800_A0_BSAFE_GLB_PRESCALEr_GET
#define BSAFE_GLB_PRESCALEr_PRESCALEf_GET BCM56800_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_GET
#define BSAFE_GLB_PRESCALEr_PRESCALEf_SET BCM56800_A0_BSAFE_GLB_PRESCALEr_PRESCALEf_SET
#define BSAFE_GLB_PRESCALEr_RESERVED_1f_GET BCM56800_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_GET
#define BSAFE_GLB_PRESCALEr_RESERVED_1f_SET BCM56800_A0_BSAFE_GLB_PRESCALEr_RESERVED_1f_SET
#define READ_BSAFE_GLB_PRESCALEr BCM56800_A0_READ_BSAFE_GLB_PRESCALEr
#define WRITE_BSAFE_GLB_PRESCALEr BCM56800_A0_WRITE_BSAFE_GLB_PRESCALEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_PRESCALEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_PROD_CFG
 * BLOCKS:   BSAFE
 * DESC:     The device configuration register allows the system to be configured securely 
by the HSM. For example, a higher performance capability can be shipped 
disabled, then upgraded via a secure communication message in the field to 
increase perforamnce.  These bits would be used to disable the feature or 
performance capability in the system (or on chip).  Upon each power on reset 
or hardware reset of the uHSM, the embedded microcontroller will read the 
default initial value of this register from the NVM and set the register 
content. The register content can be subsequently updated via uHSM_LD_CFG 
command. The functionality of the uHSM is determined by the current value of 
the register.  The content of this register is brought out to the uHSM 
interface so that external system hardware can be configured.

 * SIZE:     32
 * FIELDS:
 *     PROD_CFG         The secure product configuration values. The usage is system dependent for eachbit.  The initial values of these bits are set via the "uHSM_INIT_DEVICEKEY (uhsm_config, prod_config, authorization)" command in the "configuration" input field. The values of these bits can be changed in-field by a manufacturer's authorized signature.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_PROD_CFGr 0x00e8020c

#define BCM56800_A0_BSAFE_GLB_PROD_CFGr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_PROD_CFG.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_PROD_CFGr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_prod_cfg[1];
	uint32_t _bsafe_glb_prod_cfg;
} BCM56800_A0_BSAFE_GLB_PROD_CFGr_t;

#define BCM56800_A0_BSAFE_GLB_PROD_CFGr_CLR(r) (r).bsafe_glb_prod_cfg[0] = 0
#define BCM56800_A0_BSAFE_GLB_PROD_CFGr_SET(r,d) (r).bsafe_glb_prod_cfg[0] = d
#define BCM56800_A0_BSAFE_GLB_PROD_CFGr_GET(r) (r).bsafe_glb_prod_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET(r) ((r).bsafe_glb_prod_cfg[0])
#define BCM56800_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET(r,f) (r).bsafe_glb_prod_cfg[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_PROD_CFG.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_PROD_CFGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_PROD_CFGr,(r._bsafe_glb_prod_cfg))
#define BCM56800_A0_WRITE_BSAFE_GLB_PROD_CFGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_PROD_CFGr,&(r._bsafe_glb_prod_cfg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_PROD_CFGr BCM56800_A0_BSAFE_GLB_PROD_CFGr
#define BSAFE_GLB_PROD_CFGr_SIZE BCM56800_A0_BSAFE_GLB_PROD_CFGr_SIZE
typedef BCM56800_A0_BSAFE_GLB_PROD_CFGr_t BSAFE_GLB_PROD_CFGr_t;
#define BSAFE_GLB_PROD_CFGr_CLR BCM56800_A0_BSAFE_GLB_PROD_CFGr_CLR
#define BSAFE_GLB_PROD_CFGr_SET BCM56800_A0_BSAFE_GLB_PROD_CFGr_SET
#define BSAFE_GLB_PROD_CFGr_GET BCM56800_A0_BSAFE_GLB_PROD_CFGr_GET
#define BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET BCM56800_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_GET
#define BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET BCM56800_A0_BSAFE_GLB_PROD_CFGr_PROD_CFGf_SET
#define READ_BSAFE_GLB_PROD_CFGr BCM56800_A0_READ_BSAFE_GLB_PROD_CFGr
#define WRITE_BSAFE_GLB_PROD_CFGr BCM56800_A0_WRITE_BSAFE_GLB_PROD_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_PROD_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_TIMER
 * BLOCKS:   BSAFE
 * DESC:     System Time Register.
The timer register is used to determine when time based keys are expired
by the uHSM. The time tick is stored in this register and is set to zero 
at reset. The time tick increments in one second increments continuously 
from reset.
The value of this register can only be initialized once
after each hardware reset. Subsequent write operations to
this register through the register access interface will not
have any effect.

 * SIZE:     32
 * FIELDS:
 *     TIME_TICK        The relative time tick register. This register is disabled at reset. It remains at zero, until it is being programmed to a non-zero value.The value of this registers can only be initialized once after each hardware reset. Subsequent write operations to this register through the register access interface will not have any effect.This field is write-once protected. It can only be written one timeby an sbus write access. Further write attempts are ignored by uHSM.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_TIMERr 0x00e80200

#define BCM56800_A0_BSAFE_GLB_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_TIMER.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_TIMERr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_timer[1];
	uint32_t _bsafe_glb_timer;
} BCM56800_A0_BSAFE_GLB_TIMERr_t;

#define BCM56800_A0_BSAFE_GLB_TIMERr_CLR(r) (r).bsafe_glb_timer[0] = 0
#define BCM56800_A0_BSAFE_GLB_TIMERr_SET(r,d) (r).bsafe_glb_timer[0] = d
#define BCM56800_A0_BSAFE_GLB_TIMERr_GET(r) (r).bsafe_glb_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_TIMERr_TIME_TICKf_GET(r) ((r).bsafe_glb_timer[0])
#define BCM56800_A0_BSAFE_GLB_TIMERr_TIME_TICKf_SET(r,f) (r).bsafe_glb_timer[0]=((uint32_t)f)

/*
 * These macros can be used to access BSAFE_GLB_TIMER.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_TIMERr,(r._bsafe_glb_timer))
#define BCM56800_A0_WRITE_BSAFE_GLB_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_TIMERr,&(r._bsafe_glb_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_TIMERr BCM56800_A0_BSAFE_GLB_TIMERr
#define BSAFE_GLB_TIMERr_SIZE BCM56800_A0_BSAFE_GLB_TIMERr_SIZE
typedef BCM56800_A0_BSAFE_GLB_TIMERr_t BSAFE_GLB_TIMERr_t;
#define BSAFE_GLB_TIMERr_CLR BCM56800_A0_BSAFE_GLB_TIMERr_CLR
#define BSAFE_GLB_TIMERr_SET BCM56800_A0_BSAFE_GLB_TIMERr_SET
#define BSAFE_GLB_TIMERr_GET BCM56800_A0_BSAFE_GLB_TIMERr_GET
#define BSAFE_GLB_TIMERr_TIME_TICKf_GET BCM56800_A0_BSAFE_GLB_TIMERr_TIME_TICKf_GET
#define BSAFE_GLB_TIMERr_TIME_TICKf_SET BCM56800_A0_BSAFE_GLB_TIMERr_TIME_TICKf_SET
#define READ_BSAFE_GLB_TIMERr BCM56800_A0_READ_BSAFE_GLB_TIMERr
#define WRITE_BSAFE_GLB_TIMERr BCM56800_A0_WRITE_BSAFE_GLB_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  BSAFE_GLB_UHSM_CFG
 * BLOCKS:   BSAFE
 * DESC:     The uHSM configuration register allows the uHSM to be configured securely by 
the HSM. The most common use for this function is the in field upgrade 
capability for export controls.  Upon each power on reset or hardware reset 
of the uHSM, the embedded microcontroller will read the default initial value 
of this register from the NVM and set the register content. The register 
content can be subsequently updated via uHSM_LD_CFG command. The 
functionality of the uHSM is determined by the current value of the register.

 * SIZE:     32
 * FIELDS:
 *     UHSM_CFG         The secure uHSM configuration values. The pre-defined flags are specified in the uHSM_INIT_DEVICEKEY command.  The initial values of these bits are set via the "uHSM_INIT_DEVICEKEY (uhsm_config, prod_config, authorization)" command in the "configuration" input field. The values of these bits can be changed in-field by a manufacturer's authorized signature.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr 0x00e80208

#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr_SIZE 4

/*
 * This structure should be used to declare and program BSAFE_GLB_UHSM_CFG.
 *
 */
typedef union BCM56800_A0_BSAFE_GLB_UHSM_CFGr_s {
	uint32_t v[1];
	uint32_t bsafe_glb_uhsm_cfg[1];
	uint32_t _bsafe_glb_uhsm_cfg;
} BCM56800_A0_BSAFE_GLB_UHSM_CFGr_t;

#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr_CLR(r) (r).bsafe_glb_uhsm_cfg[0] = 0
#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr_SET(r,d) (r).bsafe_glb_uhsm_cfg[0] = d
#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr_GET(r) (r).bsafe_glb_uhsm_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET(r) (((r).bsafe_glb_uhsm_cfg[0]) & 0xfffff)
#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET(r,f) (r).bsafe_glb_uhsm_cfg[0]=(((r).bsafe_glb_uhsm_cfg[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr_RESERVED_1f_GET(r) ((((r).bsafe_glb_uhsm_cfg[0]) >> 20) & 0xfff)
#define BCM56800_A0_BSAFE_GLB_UHSM_CFGr_RESERVED_1f_SET(r,f) (r).bsafe_glb_uhsm_cfg[0]=(((r).bsafe_glb_uhsm_cfg[0] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access BSAFE_GLB_UHSM_CFG.
 *
 */
#define BCM56800_A0_READ_BSAFE_GLB_UHSM_CFGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_BSAFE_GLB_UHSM_CFGr,(r._bsafe_glb_uhsm_cfg))
#define BCM56800_A0_WRITE_BSAFE_GLB_UHSM_CFGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_BSAFE_GLB_UHSM_CFGr,&(r._bsafe_glb_uhsm_cfg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BSAFE_GLB_UHSM_CFGr BCM56800_A0_BSAFE_GLB_UHSM_CFGr
#define BSAFE_GLB_UHSM_CFGr_SIZE BCM56800_A0_BSAFE_GLB_UHSM_CFGr_SIZE
typedef BCM56800_A0_BSAFE_GLB_UHSM_CFGr_t BSAFE_GLB_UHSM_CFGr_t;
#define BSAFE_GLB_UHSM_CFGr_CLR BCM56800_A0_BSAFE_GLB_UHSM_CFGr_CLR
#define BSAFE_GLB_UHSM_CFGr_SET BCM56800_A0_BSAFE_GLB_UHSM_CFGr_SET
#define BSAFE_GLB_UHSM_CFGr_GET BCM56800_A0_BSAFE_GLB_UHSM_CFGr_GET
#define BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET BCM56800_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_GET
#define BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET BCM56800_A0_BSAFE_GLB_UHSM_CFGr_UHSM_CFGf_SET
#define BSAFE_GLB_UHSM_CFGr_RESERVED_1f_GET BCM56800_A0_BSAFE_GLB_UHSM_CFGr_RESERVED_1f_GET
#define BSAFE_GLB_UHSM_CFGr_RESERVED_1f_SET BCM56800_A0_BSAFE_GLB_UHSM_CFGr_RESERVED_1f_SET
#define READ_BSAFE_GLB_UHSM_CFGr BCM56800_A0_READ_BSAFE_GLB_UHSM_CFGr
#define WRITE_BSAFE_GLB_UHSM_CFGr BCM56800_A0_WRITE_BSAFE_GLB_UHSM_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_BSAFE_GLB_UHSM_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CBPCELLHDRMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm registers.
 *
 ******************************************************************************/
#define BCM56800_A0_CBPCELLHDRMEMDEBUGr 0x10d80000

#define BCM56800_A0_CBPCELLHDRMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPCELLHDRMEMDEBUG.
 *
 */
typedef union BCM56800_A0_CBPCELLHDRMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbpcellhdrmemdebug[1];
	uint32_t _cbpcellhdrmemdebug;
} BCM56800_A0_CBPCELLHDRMEMDEBUGr_t;

#define BCM56800_A0_CBPCELLHDRMEMDEBUGr_CLR(r) (r).cbpcellhdrmemdebug[0] = 0
#define BCM56800_A0_CBPCELLHDRMEMDEBUGr_SET(r,d) (r).cbpcellhdrmemdebug[0] = d
#define BCM56800_A0_CBPCELLHDRMEMDEBUGr_GET(r) (r).cbpcellhdrmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CBPCELLHDRMEMDEBUGr_TMf_GET(r) (((r).cbpcellhdrmemdebug[0]) & 0xff)
#define BCM56800_A0_CBPCELLHDRMEMDEBUGr_TMf_SET(r,f) (r).cbpcellhdrmemdebug[0]=(((r).cbpcellhdrmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CBPCELLHDRMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CBPCELLHDRMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CBPCELLHDRMEMDEBUGr,(r._cbpcellhdrmemdebug))
#define BCM56800_A0_WRITE_CBPCELLHDRMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CBPCELLHDRMEMDEBUGr,&(r._cbpcellhdrmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPCELLHDRMEMDEBUGr BCM56800_A0_CBPCELLHDRMEMDEBUGr
#define CBPCELLHDRMEMDEBUGr_SIZE BCM56800_A0_CBPCELLHDRMEMDEBUGr_SIZE
typedef BCM56800_A0_CBPCELLHDRMEMDEBUGr_t CBPCELLHDRMEMDEBUGr_t;
#define CBPCELLHDRMEMDEBUGr_CLR BCM56800_A0_CBPCELLHDRMEMDEBUGr_CLR
#define CBPCELLHDRMEMDEBUGr_SET BCM56800_A0_CBPCELLHDRMEMDEBUGr_SET
#define CBPCELLHDRMEMDEBUGr_GET BCM56800_A0_CBPCELLHDRMEMDEBUGr_GET
#define CBPCELLHDRMEMDEBUGr_TMf_GET BCM56800_A0_CBPCELLHDRMEMDEBUGr_TMf_GET
#define CBPCELLHDRMEMDEBUGr_TMf_SET BCM56800_A0_CBPCELLHDRMEMDEBUGr_TMf_SET
#define READ_CBPCELLHDRMEMDEBUGr BCM56800_A0_READ_CBPCELLHDRMEMDEBUGr
#define WRITE_CBPCELLHDRMEMDEBUGr BCM56800_A0_WRITE_CBPCELLHDRMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CBPCELLHDRMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CBPDATAMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm for mem1 mem0
 *     TM0              tm for mem0
 *     TM1              tm for mem1
 *
 ******************************************************************************/
#define BCM56800_A0_CBPDATAMEMDEBUGr 0x0fd80000

#define BCM56800_A0_CBPDATAMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPDATAMEMDEBUG.
 *
 */
typedef union BCM56800_A0_CBPDATAMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbpdatamemdebug[1];
	uint32_t _cbpdatamemdebug;
} BCM56800_A0_CBPDATAMEMDEBUGr_t;

#define BCM56800_A0_CBPDATAMEMDEBUGr_CLR(r) (r).cbpdatamemdebug[0] = 0
#define BCM56800_A0_CBPDATAMEMDEBUGr_SET(r,d) (r).cbpdatamemdebug[0] = d
#define BCM56800_A0_CBPDATAMEMDEBUGr_GET(r) (r).cbpdatamemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CBPDATAMEMDEBUGr_TMf_GET(r) (((r).cbpdatamemdebug[0]) & 0xffff)
#define BCM56800_A0_CBPDATAMEMDEBUGr_TMf_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CBPDATAMEMDEBUGr_TM0f_GET(r) (((r).cbpdatamemdebug[0]) & 0xff)
#define BCM56800_A0_CBPDATAMEMDEBUGr_TM0f_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CBPDATAMEMDEBUGr_TM1f_GET(r) ((((r).cbpdatamemdebug[0]) >> 8) & 0xff)
#define BCM56800_A0_CBPDATAMEMDEBUGr_TM1f_SET(r,f) (r).cbpdatamemdebug[0]=(((r).cbpdatamemdebug[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access CBPDATAMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CBPDATAMEMDEBUGr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_CBPDATAMEMDEBUGr+(i),(r._cbpdatamemdebug))
#define BCM56800_A0_WRITE_CBPDATAMEMDEBUGr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_CBPDATAMEMDEBUGr+(i),&(r._cbpdatamemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPDATAMEMDEBUGr BCM56800_A0_CBPDATAMEMDEBUGr
#define CBPDATAMEMDEBUGr_SIZE BCM56800_A0_CBPDATAMEMDEBUGr_SIZE
typedef BCM56800_A0_CBPDATAMEMDEBUGr_t CBPDATAMEMDEBUGr_t;
#define CBPDATAMEMDEBUGr_CLR BCM56800_A0_CBPDATAMEMDEBUGr_CLR
#define CBPDATAMEMDEBUGr_SET BCM56800_A0_CBPDATAMEMDEBUGr_SET
#define CBPDATAMEMDEBUGr_GET BCM56800_A0_CBPDATAMEMDEBUGr_GET
#define CBPDATAMEMDEBUGr_TMf_GET BCM56800_A0_CBPDATAMEMDEBUGr_TMf_GET
#define CBPDATAMEMDEBUGr_TMf_SET BCM56800_A0_CBPDATAMEMDEBUGr_TMf_SET
#define CBPDATAMEMDEBUGr_TM0f_GET BCM56800_A0_CBPDATAMEMDEBUGr_TM0f_GET
#define CBPDATAMEMDEBUGr_TM0f_SET BCM56800_A0_CBPDATAMEMDEBUGr_TM0f_SET
#define CBPDATAMEMDEBUGr_TM1f_GET BCM56800_A0_CBPDATAMEMDEBUGr_TM1f_GET
#define CBPDATAMEMDEBUGr_TM1f_SET BCM56800_A0_CBPDATAMEMDEBUGr_TM1f_SET
#define READ_CBPDATAMEMDEBUGr BCM56800_A0_READ_CBPDATAMEMDEBUGr
#define WRITE_CBPDATAMEMDEBUGr BCM56800_A0_WRITE_CBPDATAMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CBPDATAMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CBPPKTHDR0MEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm for mem1 mem0
 *     TM0              tm for mem0
 *     TM1              tm for mem1
 *
 ******************************************************************************/
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr 0x0fd80010

#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDR0MEMDEBUG.
 *
 */
typedef union BCM56800_A0_CBPPKTHDR0MEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdr0memdebug[1];
	uint32_t _cbppkthdr0memdebug;
} BCM56800_A0_CBPPKTHDR0MEMDEBUGr_t;

#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_CLR(r) (r).cbppkthdr0memdebug[0] = 0
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_SET(r,d) (r).cbppkthdr0memdebug[0] = d
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_GET(r) (r).cbppkthdr0memdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TMf_GET(r) (((r).cbppkthdr0memdebug[0]) & 0xffff)
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TMf_SET(r,f) (r).cbppkthdr0memdebug[0]=(((r).cbppkthdr0memdebug[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TM0f_GET(r) (((r).cbppkthdr0memdebug[0]) & 0xff)
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TM0f_SET(r,f) (r).cbppkthdr0memdebug[0]=(((r).cbppkthdr0memdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TM1f_GET(r) ((((r).cbppkthdr0memdebug[0]) >> 8) & 0xff)
#define BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TM1f_SET(r,f) (r).cbppkthdr0memdebug[0]=(((r).cbppkthdr0memdebug[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access CBPPKTHDR0MEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CBPPKTHDR0MEMDEBUGr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_CBPPKTHDR0MEMDEBUGr+(i),(r._cbppkthdr0memdebug))
#define BCM56800_A0_WRITE_CBPPKTHDR0MEMDEBUGr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_CBPPKTHDR0MEMDEBUGr+(i),&(r._cbppkthdr0memdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDR0MEMDEBUGr BCM56800_A0_CBPPKTHDR0MEMDEBUGr
#define CBPPKTHDR0MEMDEBUGr_SIZE BCM56800_A0_CBPPKTHDR0MEMDEBUGr_SIZE
typedef BCM56800_A0_CBPPKTHDR0MEMDEBUGr_t CBPPKTHDR0MEMDEBUGr_t;
#define CBPPKTHDR0MEMDEBUGr_CLR BCM56800_A0_CBPPKTHDR0MEMDEBUGr_CLR
#define CBPPKTHDR0MEMDEBUGr_SET BCM56800_A0_CBPPKTHDR0MEMDEBUGr_SET
#define CBPPKTHDR0MEMDEBUGr_GET BCM56800_A0_CBPPKTHDR0MEMDEBUGr_GET
#define CBPPKTHDR0MEMDEBUGr_TMf_GET BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TMf_GET
#define CBPPKTHDR0MEMDEBUGr_TMf_SET BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TMf_SET
#define CBPPKTHDR0MEMDEBUGr_TM0f_GET BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TM0f_GET
#define CBPPKTHDR0MEMDEBUGr_TM0f_SET BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TM0f_SET
#define CBPPKTHDR0MEMDEBUGr_TM1f_GET BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TM1f_GET
#define CBPPKTHDR0MEMDEBUGr_TM1f_SET BCM56800_A0_CBPPKTHDR0MEMDEBUGr_TM1f_SET
#define READ_CBPPKTHDR0MEMDEBUGr BCM56800_A0_READ_CBPPKTHDR0MEMDEBUGr
#define WRITE_CBPPKTHDR0MEMDEBUGr BCM56800_A0_WRITE_CBPPKTHDR0MEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CBPPKTHDR0MEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CBPPKTHDR1MEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm for mem1 mem0
 *     TM0              tm for mem0
 *     TM1              tm for mem1
 *
 ******************************************************************************/
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr 0x10d80001

#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDR1MEMDEBUG.
 *
 */
typedef union BCM56800_A0_CBPPKTHDR1MEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdr1memdebug[1];
	uint32_t _cbppkthdr1memdebug;
} BCM56800_A0_CBPPKTHDR1MEMDEBUGr_t;

#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_CLR(r) (r).cbppkthdr1memdebug[0] = 0
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_SET(r,d) (r).cbppkthdr1memdebug[0] = d
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_GET(r) (r).cbppkthdr1memdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TMf_GET(r) (((r).cbppkthdr1memdebug[0]) & 0xffff)
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TMf_SET(r,f) (r).cbppkthdr1memdebug[0]=(((r).cbppkthdr1memdebug[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TM0f_GET(r) (((r).cbppkthdr1memdebug[0]) & 0xff)
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TM0f_SET(r,f) (r).cbppkthdr1memdebug[0]=(((r).cbppkthdr1memdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TM1f_GET(r) ((((r).cbppkthdr1memdebug[0]) >> 8) & 0xff)
#define BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TM1f_SET(r,f) (r).cbppkthdr1memdebug[0]=(((r).cbppkthdr1memdebug[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access CBPPKTHDR1MEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CBPPKTHDR1MEMDEBUGr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_CBPPKTHDR1MEMDEBUGr+(i),(r._cbppkthdr1memdebug))
#define BCM56800_A0_WRITE_CBPPKTHDR1MEMDEBUGr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_CBPPKTHDR1MEMDEBUGr+(i),&(r._cbppkthdr1memdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDR1MEMDEBUGr BCM56800_A0_CBPPKTHDR1MEMDEBUGr
#define CBPPKTHDR1MEMDEBUGr_SIZE BCM56800_A0_CBPPKTHDR1MEMDEBUGr_SIZE
typedef BCM56800_A0_CBPPKTHDR1MEMDEBUGr_t CBPPKTHDR1MEMDEBUGr_t;
#define CBPPKTHDR1MEMDEBUGr_CLR BCM56800_A0_CBPPKTHDR1MEMDEBUGr_CLR
#define CBPPKTHDR1MEMDEBUGr_SET BCM56800_A0_CBPPKTHDR1MEMDEBUGr_SET
#define CBPPKTHDR1MEMDEBUGr_GET BCM56800_A0_CBPPKTHDR1MEMDEBUGr_GET
#define CBPPKTHDR1MEMDEBUGr_TMf_GET BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TMf_GET
#define CBPPKTHDR1MEMDEBUGr_TMf_SET BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TMf_SET
#define CBPPKTHDR1MEMDEBUGr_TM0f_GET BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TM0f_GET
#define CBPPKTHDR1MEMDEBUGr_TM0f_SET BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TM0f_SET
#define CBPPKTHDR1MEMDEBUGr_TM1f_GET BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TM1f_GET
#define CBPPKTHDR1MEMDEBUGr_TM1f_SET BCM56800_A0_CBPPKTHDR1MEMDEBUGr_TM1f_SET
#define READ_CBPPKTHDR1MEMDEBUGr BCM56800_A0_READ_CBPPKTHDR1MEMDEBUGr
#define WRITE_CBPPKTHDR1MEMDEBUGr BCM56800_A0_WRITE_CBPPKTHDR1MEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CBPPKTHDR1MEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CBPPKTHDRCPUMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm for mem1 mem0
 *     TM0              tm for mem0
 *     TM1              tm for mem1
 *
 ******************************************************************************/
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr 0x0fd80013

#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CBPPKTHDRCPUMEMDEBUG.
 *
 */
typedef union BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cbppkthdrcpumemdebug[1];
	uint32_t _cbppkthdrcpumemdebug;
} BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_t;

#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_CLR(r) (r).cbppkthdrcpumemdebug[0] = 0
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_SET(r,d) (r).cbppkthdrcpumemdebug[0] = d
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_GET(r) (r).cbppkthdrcpumemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TMf_GET(r) (((r).cbppkthdrcpumemdebug[0]) & 0xffff)
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TMf_SET(r,f) (r).cbppkthdrcpumemdebug[0]=(((r).cbppkthdrcpumemdebug[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TM0f_GET(r) (((r).cbppkthdrcpumemdebug[0]) & 0xff)
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TM0f_SET(r,f) (r).cbppkthdrcpumemdebug[0]=(((r).cbppkthdrcpumemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TM1f_GET(r) ((((r).cbppkthdrcpumemdebug[0]) >> 8) & 0xff)
#define BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TM1f_SET(r,f) (r).cbppkthdrcpumemdebug[0]=(((r).cbppkthdrcpumemdebug[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access CBPPKTHDRCPUMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CBPPKTHDRCPUMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr,(r._cbppkthdrcpumemdebug))
#define BCM56800_A0_WRITE_CBPPKTHDRCPUMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr,&(r._cbppkthdrcpumemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CBPPKTHDRCPUMEMDEBUGr BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr
#define CBPPKTHDRCPUMEMDEBUGr_SIZE BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_SIZE
typedef BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_t CBPPKTHDRCPUMEMDEBUGr_t;
#define CBPPKTHDRCPUMEMDEBUGr_CLR BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_CLR
#define CBPPKTHDRCPUMEMDEBUGr_SET BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_SET
#define CBPPKTHDRCPUMEMDEBUGr_GET BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_GET
#define CBPPKTHDRCPUMEMDEBUGr_TMf_GET BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TMf_GET
#define CBPPKTHDRCPUMEMDEBUGr_TMf_SET BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TMf_SET
#define CBPPKTHDRCPUMEMDEBUGr_TM0f_GET BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TM0f_GET
#define CBPPKTHDRCPUMEMDEBUGr_TM0f_SET BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TM0f_SET
#define CBPPKTHDRCPUMEMDEBUGr_TM1f_GET BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TM1f_GET
#define CBPPKTHDRCPUMEMDEBUGr_TM1f_SET BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr_TM1f_SET
#define READ_CBPPKTHDRCPUMEMDEBUGr BCM56800_A0_READ_CBPPKTHDRCPUMEMDEBUGr
#define WRITE_CBPPKTHDRCPUMEMDEBUGr BCM56800_A0_WRITE_CBPPKTHDRCPUMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CBPPKTHDRCPUMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CCPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     CCP Memory debug register
 * SIZE:     32
 * FIELDS:
 *     TM               tm registers.
 *
 ******************************************************************************/
#define BCM56800_A0_CCPMEMDEBUGr 0x08d80012

#define BCM56800_A0_CCPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CCPMEMDEBUG.
 *
 */
typedef union BCM56800_A0_CCPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t ccpmemdebug[1];
	uint32_t _ccpmemdebug;
} BCM56800_A0_CCPMEMDEBUGr_t;

#define BCM56800_A0_CCPMEMDEBUGr_CLR(r) (r).ccpmemdebug[0] = 0
#define BCM56800_A0_CCPMEMDEBUGr_SET(r,d) (r).ccpmemdebug[0] = d
#define BCM56800_A0_CCPMEMDEBUGr_GET(r) (r).ccpmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CCPMEMDEBUGr_TMf_GET(r) (((r).ccpmemdebug[0]) & 0xff)
#define BCM56800_A0_CCPMEMDEBUGr_TMf_SET(r,f) (r).ccpmemdebug[0]=(((r).ccpmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CCPMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CCPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CCPMEMDEBUGr,(r._ccpmemdebug))
#define BCM56800_A0_WRITE_CCPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CCPMEMDEBUGr,&(r._ccpmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CCPMEMDEBUGr BCM56800_A0_CCPMEMDEBUGr
#define CCPMEMDEBUGr_SIZE BCM56800_A0_CCPMEMDEBUGr_SIZE
typedef BCM56800_A0_CCPMEMDEBUGr_t CCPMEMDEBUGr_t;
#define CCPMEMDEBUGr_CLR BCM56800_A0_CCPMEMDEBUGr_CLR
#define CCPMEMDEBUGr_SET BCM56800_A0_CCPMEMDEBUGr_SET
#define CCPMEMDEBUGr_GET BCM56800_A0_CCPMEMDEBUGr_GET
#define CCPMEMDEBUGr_TMf_GET BCM56800_A0_CCPMEMDEBUGr_TMf_GET
#define CCPMEMDEBUGr_TMf_SET BCM56800_A0_CCPMEMDEBUGr_TMf_SET
#define READ_CCPMEMDEBUGr BCM56800_A0_READ_CCPMEMDEBUGr
#define WRITE_CCPMEMDEBUGr BCM56800_A0_WRITE_CCPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CCPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CCPPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     CCP Parity Error Pointer
 * SIZE:     32
 * FIELDS:
 *     CCPPARITYERRORPTR The memory address at which the most recent CCP parity error occurred.
 *
 ******************************************************************************/
#define BCM56800_A0_CCPPARITYERRORPTRr 0x08d80011

#define BCM56800_A0_CCPPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program CCPPARITYERRORPTR.
 *
 */
typedef union BCM56800_A0_CCPPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t ccpparityerrorptr[1];
	uint32_t _ccpparityerrorptr;
} BCM56800_A0_CCPPARITYERRORPTRr_t;

#define BCM56800_A0_CCPPARITYERRORPTRr_CLR(r) (r).ccpparityerrorptr[0] = 0
#define BCM56800_A0_CCPPARITYERRORPTRr_SET(r,d) (r).ccpparityerrorptr[0] = d
#define BCM56800_A0_CCPPARITYERRORPTRr_GET(r) (r).ccpparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET(r) (((r).ccpparityerrorptr[0]) & 0x3fff)
#define BCM56800_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET(r,f) (r).ccpparityerrorptr[0]=(((r).ccpparityerrorptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CCPPARITYERRORPTR.
 *
 */
#define BCM56800_A0_READ_CCPPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CCPPARITYERRORPTRr,(r._ccpparityerrorptr))
#define BCM56800_A0_WRITE_CCPPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CCPPARITYERRORPTRr,&(r._ccpparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CCPPARITYERRORPTRr BCM56800_A0_CCPPARITYERRORPTRr
#define CCPPARITYERRORPTRr_SIZE BCM56800_A0_CCPPARITYERRORPTRr_SIZE
typedef BCM56800_A0_CCPPARITYERRORPTRr_t CCPPARITYERRORPTRr_t;
#define CCPPARITYERRORPTRr_CLR BCM56800_A0_CCPPARITYERRORPTRr_CLR
#define CCPPARITYERRORPTRr_SET BCM56800_A0_CCPPARITYERRORPTRr_SET
#define CCPPARITYERRORPTRr_GET BCM56800_A0_CCPPARITYERRORPTRr_GET
#define CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET BCM56800_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_GET
#define CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET BCM56800_A0_CCPPARITYERRORPTRr_CCPPARITYERRORPTRf_SET
#define READ_CCPPARITYERRORPTRr BCM56800_A0_READ_CCPPARITYERRORPTRr
#define WRITE_CCPPARITYERRORPTRr BCM56800_A0_WRITE_CCPPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CCPPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CELLCHKMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm registers.
 *
 ******************************************************************************/
#define BCM56800_A0_CELLCHKMEMDEBUGr 0x0fd80014

#define BCM56800_A0_CELLCHKMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CELLCHKMEMDEBUG.
 *
 */
typedef union BCM56800_A0_CELLCHKMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cellchkmemdebug[1];
	uint32_t _cellchkmemdebug;
} BCM56800_A0_CELLCHKMEMDEBUGr_t;

#define BCM56800_A0_CELLCHKMEMDEBUGr_CLR(r) (r).cellchkmemdebug[0] = 0
#define BCM56800_A0_CELLCHKMEMDEBUGr_SET(r,d) (r).cellchkmemdebug[0] = d
#define BCM56800_A0_CELLCHKMEMDEBUGr_GET(r) (r).cellchkmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CELLCHKMEMDEBUGr_TMf_GET(r) (((r).cellchkmemdebug[0]) & 0xff)
#define BCM56800_A0_CELLCHKMEMDEBUGr_TMf_SET(r,f) (r).cellchkmemdebug[0]=(((r).cellchkmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CELLCHKMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CELLCHKMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CELLCHKMEMDEBUGr,(r._cellchkmemdebug))
#define BCM56800_A0_WRITE_CELLCHKMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CELLCHKMEMDEBUGr,&(r._cellchkmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CELLCHKMEMDEBUGr BCM56800_A0_CELLCHKMEMDEBUGr
#define CELLCHKMEMDEBUGr_SIZE BCM56800_A0_CELLCHKMEMDEBUGr_SIZE
typedef BCM56800_A0_CELLCHKMEMDEBUGr_t CELLCHKMEMDEBUGr_t;
#define CELLCHKMEMDEBUGr_CLR BCM56800_A0_CELLCHKMEMDEBUGr_CLR
#define CELLCHKMEMDEBUGr_SET BCM56800_A0_CELLCHKMEMDEBUGr_SET
#define CELLCHKMEMDEBUGr_GET BCM56800_A0_CELLCHKMEMDEBUGr_GET
#define CELLCHKMEMDEBUGr_TMf_GET BCM56800_A0_CELLCHKMEMDEBUGr_TMf_GET
#define CELLCHKMEMDEBUGr_TMf_SET BCM56800_A0_CELLCHKMEMDEBUGr_TMf_SET
#define READ_CELLCHKMEMDEBUGr BCM56800_A0_READ_CELLCHKMEMDEBUGr
#define WRITE_CELLCHKMEMDEBUGr BCM56800_A0_WRITE_CELLCHKMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CELLCHKMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CELLLINKMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm registers.
 *
 ******************************************************************************/
#define BCM56800_A0_CELLLINKMEMDEBUGr 0x10d80003

#define BCM56800_A0_CELLLINKMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CELLLINKMEMDEBUG.
 *
 */
typedef union BCM56800_A0_CELLLINKMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t celllinkmemdebug[1];
	uint32_t _celllinkmemdebug;
} BCM56800_A0_CELLLINKMEMDEBUGr_t;

#define BCM56800_A0_CELLLINKMEMDEBUGr_CLR(r) (r).celllinkmemdebug[0] = 0
#define BCM56800_A0_CELLLINKMEMDEBUGr_SET(r,d) (r).celllinkmemdebug[0] = d
#define BCM56800_A0_CELLLINKMEMDEBUGr_GET(r) (r).celllinkmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CELLLINKMEMDEBUGr_TMf_GET(r) (((r).celllinkmemdebug[0]) & 0xff)
#define BCM56800_A0_CELLLINKMEMDEBUGr_TMf_SET(r,f) (r).celllinkmemdebug[0]=(((r).celllinkmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CELLLINKMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CELLLINKMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CELLLINKMEMDEBUGr,(r._celllinkmemdebug))
#define BCM56800_A0_WRITE_CELLLINKMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CELLLINKMEMDEBUGr,&(r._celllinkmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CELLLINKMEMDEBUGr BCM56800_A0_CELLLINKMEMDEBUGr
#define CELLLINKMEMDEBUGr_SIZE BCM56800_A0_CELLLINKMEMDEBUGr_SIZE
typedef BCM56800_A0_CELLLINKMEMDEBUGr_t CELLLINKMEMDEBUGr_t;
#define CELLLINKMEMDEBUGr_CLR BCM56800_A0_CELLLINKMEMDEBUGr_CLR
#define CELLLINKMEMDEBUGr_SET BCM56800_A0_CELLLINKMEMDEBUGr_SET
#define CELLLINKMEMDEBUGr_GET BCM56800_A0_CELLLINKMEMDEBUGr_GET
#define CELLLINKMEMDEBUGr_TMf_GET BCM56800_A0_CELLLINKMEMDEBUGr_TMf_GET
#define CELLLINKMEMDEBUGr_TMf_SET BCM56800_A0_CELLLINKMEMDEBUGr_TMf_SET
#define READ_CELLLINKMEMDEBUGr BCM56800_A0_READ_CELLLINKMEMDEBUGr
#define WRITE_CELLLINKMEMDEBUGr BCM56800_A0_WRITE_CELLLINKMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CELLLINKMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CFAPCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls CFAP Init and PoolSize
 * SIZE:     32
 * FIELDS:
 *     CFAPPOOLSIZE     Maximum number of cell pointers of CBP memory.Do NOT set this above the RESET VALUE, as it will cause unexpected behavior of MMU. Can set to a lower value to exclude higher locations of memory(for diagnostics or if higher locations are faulty/unavailable)
 *     START_CFAP_INIT  Re-Initialize CFAP Memory.Software should set this bit to '1' after it has re-arranged the CFAPmemory. MMU will then re-start the CFAP pointer pre-fetch process.
 *
 ******************************************************************************/
#define BCM56800_A0_CFAPCONFIGr 0x07d80000

#define BCM56800_A0_CFAPCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPCONFIG.
 *
 */
typedef union BCM56800_A0_CFAPCONFIGr_s {
	uint32_t v[1];
	uint32_t cfapconfig[1];
	uint32_t _cfapconfig;
} BCM56800_A0_CFAPCONFIGr_t;

#define BCM56800_A0_CFAPCONFIGr_CLR(r) (r).cfapconfig[0] = 0
#define BCM56800_A0_CFAPCONFIGr_SET(r,d) (r).cfapconfig[0] = d
#define BCM56800_A0_CFAPCONFIGr_GET(r) (r).cfapconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CFAPCONFIGr_CFAPPOOLSIZEf_GET(r) (((r).cfapconfig[0]) & 0x3fff)
#define BCM56800_A0_CFAPCONFIGr_CFAPPOOLSIZEf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_CFAPCONFIGr_START_CFAP_INITf_GET(r) ((((r).cfapconfig[0]) >> 14) & 0x1)
#define BCM56800_A0_CFAPCONFIGr_START_CFAP_INITf_SET(r,f) (r).cfapconfig[0]=(((r).cfapconfig[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access CFAPCONFIG.
 *
 */
#define BCM56800_A0_READ_CFAPCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CFAPCONFIGr,(r._cfapconfig))
#define BCM56800_A0_WRITE_CFAPCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CFAPCONFIGr,&(r._cfapconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPCONFIGr BCM56800_A0_CFAPCONFIGr
#define CFAPCONFIGr_SIZE BCM56800_A0_CFAPCONFIGr_SIZE
typedef BCM56800_A0_CFAPCONFIGr_t CFAPCONFIGr_t;
#define CFAPCONFIGr_CLR BCM56800_A0_CFAPCONFIGr_CLR
#define CFAPCONFIGr_SET BCM56800_A0_CFAPCONFIGr_SET
#define CFAPCONFIGr_GET BCM56800_A0_CFAPCONFIGr_GET
#define CFAPCONFIGr_CFAPPOOLSIZEf_GET BCM56800_A0_CFAPCONFIGr_CFAPPOOLSIZEf_GET
#define CFAPCONFIGr_CFAPPOOLSIZEf_SET BCM56800_A0_CFAPCONFIGr_CFAPPOOLSIZEf_SET
#define CFAPCONFIGr_START_CFAP_INITf_GET BCM56800_A0_CFAPCONFIGr_START_CFAP_INITf_GET
#define CFAPCONFIGr_START_CFAP_INITf_SET BCM56800_A0_CFAPCONFIGr_START_CFAP_INITf_SET
#define READ_CFAPCONFIGr BCM56800_A0_READ_CFAPCONFIGr
#define WRITE_CFAPCONFIGr BCM56800_A0_WRITE_CFAPCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CFAPCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CFAPDEBUGSCR0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PTR              Scratch pad 0 pointer.
 *     VLD              Scratch pad 0 valid.
 *
 ******************************************************************************/
#define BCM56800_A0_CFAPDEBUGSCR0r 0x07d80020

#define BCM56800_A0_CFAPDEBUGSCR0r_SIZE 4

/*
 * This structure should be used to declare and program CFAPDEBUGSCR0.
 *
 */
typedef union BCM56800_A0_CFAPDEBUGSCR0r_s {
	uint32_t v[1];
	uint32_t cfapdebugscr0[1];
	uint32_t _cfapdebugscr0;
} BCM56800_A0_CFAPDEBUGSCR0r_t;

#define BCM56800_A0_CFAPDEBUGSCR0r_CLR(r) (r).cfapdebugscr0[0] = 0
#define BCM56800_A0_CFAPDEBUGSCR0r_SET(r,d) (r).cfapdebugscr0[0] = d
#define BCM56800_A0_CFAPDEBUGSCR0r_GET(r) (r).cfapdebugscr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CFAPDEBUGSCR0r_PTRf_GET(r) (((r).cfapdebugscr0[0]) & 0x3fff)
#define BCM56800_A0_CFAPDEBUGSCR0r_PTRf_SET(r,f) (r).cfapdebugscr0[0]=(((r).cfapdebugscr0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_CFAPDEBUGSCR0r_VLDf_GET(r) ((((r).cfapdebugscr0[0]) >> 16) & 0x1)
#define BCM56800_A0_CFAPDEBUGSCR0r_VLDf_SET(r,f) (r).cfapdebugscr0[0]=(((r).cfapdebugscr0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access CFAPDEBUGSCR0.
 *
 */
#define BCM56800_A0_READ_CFAPDEBUGSCR0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CFAPDEBUGSCR0r,(r._cfapdebugscr0))
#define BCM56800_A0_WRITE_CFAPDEBUGSCR0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CFAPDEBUGSCR0r,&(r._cfapdebugscr0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPDEBUGSCR0r BCM56800_A0_CFAPDEBUGSCR0r
#define CFAPDEBUGSCR0r_SIZE BCM56800_A0_CFAPDEBUGSCR0r_SIZE
typedef BCM56800_A0_CFAPDEBUGSCR0r_t CFAPDEBUGSCR0r_t;
#define CFAPDEBUGSCR0r_CLR BCM56800_A0_CFAPDEBUGSCR0r_CLR
#define CFAPDEBUGSCR0r_SET BCM56800_A0_CFAPDEBUGSCR0r_SET
#define CFAPDEBUGSCR0r_GET BCM56800_A0_CFAPDEBUGSCR0r_GET
#define CFAPDEBUGSCR0r_PTRf_GET BCM56800_A0_CFAPDEBUGSCR0r_PTRf_GET
#define CFAPDEBUGSCR0r_PTRf_SET BCM56800_A0_CFAPDEBUGSCR0r_PTRf_SET
#define CFAPDEBUGSCR0r_VLDf_GET BCM56800_A0_CFAPDEBUGSCR0r_VLDf_GET
#define CFAPDEBUGSCR0r_VLDf_SET BCM56800_A0_CFAPDEBUGSCR0r_VLDf_SET
#define READ_CFAPDEBUGSCR0r BCM56800_A0_READ_CFAPDEBUGSCR0r
#define WRITE_CFAPDEBUGSCR0r BCM56800_A0_WRITE_CFAPDEBUGSCR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CFAPDEBUGSCR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CFAPDEBUGSCR1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PTR              Scratch pad 1 pointer.
 *     VLD              Scratch pad 1 valid.
 *
 ******************************************************************************/
#define BCM56800_A0_CFAPDEBUGSCR1r 0x07d80021

#define BCM56800_A0_CFAPDEBUGSCR1r_SIZE 4

/*
 * This structure should be used to declare and program CFAPDEBUGSCR1.
 *
 */
typedef union BCM56800_A0_CFAPDEBUGSCR1r_s {
	uint32_t v[1];
	uint32_t cfapdebugscr1[1];
	uint32_t _cfapdebugscr1;
} BCM56800_A0_CFAPDEBUGSCR1r_t;

#define BCM56800_A0_CFAPDEBUGSCR1r_CLR(r) (r).cfapdebugscr1[0] = 0
#define BCM56800_A0_CFAPDEBUGSCR1r_SET(r,d) (r).cfapdebugscr1[0] = d
#define BCM56800_A0_CFAPDEBUGSCR1r_GET(r) (r).cfapdebugscr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CFAPDEBUGSCR1r_PTRf_GET(r) (((r).cfapdebugscr1[0]) & 0x3fff)
#define BCM56800_A0_CFAPDEBUGSCR1r_PTRf_SET(r,f) (r).cfapdebugscr1[0]=(((r).cfapdebugscr1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_CFAPDEBUGSCR1r_VLDf_GET(r) ((((r).cfapdebugscr1[0]) >> 16) & 0x1)
#define BCM56800_A0_CFAPDEBUGSCR1r_VLDf_SET(r,f) (r).cfapdebugscr1[0]=(((r).cfapdebugscr1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access CFAPDEBUGSCR1.
 *
 */
#define BCM56800_A0_READ_CFAPDEBUGSCR1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CFAPDEBUGSCR1r,(r._cfapdebugscr1))
#define BCM56800_A0_WRITE_CFAPDEBUGSCR1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CFAPDEBUGSCR1r,&(r._cfapdebugscr1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPDEBUGSCR1r BCM56800_A0_CFAPDEBUGSCR1r
#define CFAPDEBUGSCR1r_SIZE BCM56800_A0_CFAPDEBUGSCR1r_SIZE
typedef BCM56800_A0_CFAPDEBUGSCR1r_t CFAPDEBUGSCR1r_t;
#define CFAPDEBUGSCR1r_CLR BCM56800_A0_CFAPDEBUGSCR1r_CLR
#define CFAPDEBUGSCR1r_SET BCM56800_A0_CFAPDEBUGSCR1r_SET
#define CFAPDEBUGSCR1r_GET BCM56800_A0_CFAPDEBUGSCR1r_GET
#define CFAPDEBUGSCR1r_PTRf_GET BCM56800_A0_CFAPDEBUGSCR1r_PTRf_GET
#define CFAPDEBUGSCR1r_PTRf_SET BCM56800_A0_CFAPDEBUGSCR1r_PTRf_SET
#define CFAPDEBUGSCR1r_VLDf_GET BCM56800_A0_CFAPDEBUGSCR1r_VLDf_GET
#define CFAPDEBUGSCR1r_VLDf_SET BCM56800_A0_CFAPDEBUGSCR1r_VLDf_SET
#define READ_CFAPDEBUGSCR1r BCM56800_A0_READ_CFAPDEBUGSCR1r
#define WRITE_CFAPDEBUGSCR1r BCM56800_A0_WRITE_CFAPDEBUGSCR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CFAPDEBUGSCR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CFAPDEBUGSCR2
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     PTR              Scratch pad 2 pointer.
 *     VLD              Scratch pad 2 valid.
 *
 ******************************************************************************/
#define BCM56800_A0_CFAPDEBUGSCR2r 0x07d80022

#define BCM56800_A0_CFAPDEBUGSCR2r_SIZE 4

/*
 * This structure should be used to declare and program CFAPDEBUGSCR2.
 *
 */
typedef union BCM56800_A0_CFAPDEBUGSCR2r_s {
	uint32_t v[1];
	uint32_t cfapdebugscr2[1];
	uint32_t _cfapdebugscr2;
} BCM56800_A0_CFAPDEBUGSCR2r_t;

#define BCM56800_A0_CFAPDEBUGSCR2r_CLR(r) (r).cfapdebugscr2[0] = 0
#define BCM56800_A0_CFAPDEBUGSCR2r_SET(r,d) (r).cfapdebugscr2[0] = d
#define BCM56800_A0_CFAPDEBUGSCR2r_GET(r) (r).cfapdebugscr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CFAPDEBUGSCR2r_PTRf_GET(r) (((r).cfapdebugscr2[0]) & 0x3fff)
#define BCM56800_A0_CFAPDEBUGSCR2r_PTRf_SET(r,f) (r).cfapdebugscr2[0]=(((r).cfapdebugscr2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_CFAPDEBUGSCR2r_VLDf_GET(r) ((((r).cfapdebugscr2[0]) >> 16) & 0x1)
#define BCM56800_A0_CFAPDEBUGSCR2r_VLDf_SET(r,f) (r).cfapdebugscr2[0]=(((r).cfapdebugscr2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access CFAPDEBUGSCR2.
 *
 */
#define BCM56800_A0_READ_CFAPDEBUGSCR2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CFAPDEBUGSCR2r,(r._cfapdebugscr2))
#define BCM56800_A0_WRITE_CFAPDEBUGSCR2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CFAPDEBUGSCR2r,&(r._cfapdebugscr2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPDEBUGSCR2r BCM56800_A0_CFAPDEBUGSCR2r
#define CFAPDEBUGSCR2r_SIZE BCM56800_A0_CFAPDEBUGSCR2r_SIZE
typedef BCM56800_A0_CFAPDEBUGSCR2r_t CFAPDEBUGSCR2r_t;
#define CFAPDEBUGSCR2r_CLR BCM56800_A0_CFAPDEBUGSCR2r_CLR
#define CFAPDEBUGSCR2r_SET BCM56800_A0_CFAPDEBUGSCR2r_SET
#define CFAPDEBUGSCR2r_GET BCM56800_A0_CFAPDEBUGSCR2r_GET
#define CFAPDEBUGSCR2r_PTRf_GET BCM56800_A0_CFAPDEBUGSCR2r_PTRf_GET
#define CFAPDEBUGSCR2r_PTRf_SET BCM56800_A0_CFAPDEBUGSCR2r_PTRf_SET
#define CFAPDEBUGSCR2r_VLDf_GET BCM56800_A0_CFAPDEBUGSCR2r_VLDf_GET
#define CFAPDEBUGSCR2r_VLDf_SET BCM56800_A0_CFAPDEBUGSCR2r_VLDf_SET
#define READ_CFAPDEBUGSCR2r BCM56800_A0_READ_CFAPDEBUGSCR2r
#define WRITE_CFAPDEBUGSCR2r BCM56800_A0_WRITE_CFAPDEBUGSCR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CFAPDEBUGSCR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CFAPFULLTHRESHOLD
 * BLOCKS:   MMU
 * DESC:     Specifies the CFAP Full thresholds
 * SIZE:     32
 * FIELDS:
 *     CFAPFULLSETPOINT Defines the threshold of entering CFAP FULL condition. CFAP is full when CFAP Read Pointer is above this limit.
 *     CFAPFULLRESETPOINT Defines the threshold of exiting CFAP FULL condition. CFAP is not full when CFAP Read Pointer is below this limit.
 *
 ******************************************************************************/
#define BCM56800_A0_CFAPFULLTHRESHOLDr 0x07d80001

#define BCM56800_A0_CFAPFULLTHRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program CFAPFULLTHRESHOLD.
 *
 */
typedef union BCM56800_A0_CFAPFULLTHRESHOLDr_s {
	uint32_t v[1];
	uint32_t cfapfullthreshold[1];
	uint32_t _cfapfullthreshold;
} BCM56800_A0_CFAPFULLTHRESHOLDr_t;

#define BCM56800_A0_CFAPFULLTHRESHOLDr_CLR(r) (r).cfapfullthreshold[0] = 0
#define BCM56800_A0_CFAPFULLTHRESHOLDr_SET(r,d) (r).cfapfullthreshold[0] = d
#define BCM56800_A0_CFAPFULLTHRESHOLDr_GET(r) (r).cfapfullthreshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET(r) (((r).cfapfullthreshold[0]) & 0x3fff)
#define BCM56800_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET(r) ((((r).cfapfullthreshold[0]) >> 14) & 0x3fff)
#define BCM56800_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET(r,f) (r).cfapfullthreshold[0]=(((r).cfapfullthreshold[0] & ~((uint32_t)0x3fff << 14)) | ((((uint32_t)f) & 0x3fff) << 14))

/*
 * These macros can be used to access CFAPFULLTHRESHOLD.
 *
 */
#define BCM56800_A0_READ_CFAPFULLTHRESHOLDr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CFAPFULLTHRESHOLDr,(r._cfapfullthreshold))
#define BCM56800_A0_WRITE_CFAPFULLTHRESHOLDr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CFAPFULLTHRESHOLDr,&(r._cfapfullthreshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPFULLTHRESHOLDr BCM56800_A0_CFAPFULLTHRESHOLDr
#define CFAPFULLTHRESHOLDr_SIZE BCM56800_A0_CFAPFULLTHRESHOLDr_SIZE
typedef BCM56800_A0_CFAPFULLTHRESHOLDr_t CFAPFULLTHRESHOLDr_t;
#define CFAPFULLTHRESHOLDr_CLR BCM56800_A0_CFAPFULLTHRESHOLDr_CLR
#define CFAPFULLTHRESHOLDr_SET BCM56800_A0_CFAPFULLTHRESHOLDr_SET
#define CFAPFULLTHRESHOLDr_GET BCM56800_A0_CFAPFULLTHRESHOLDr_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET BCM56800_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET BCM56800_A0_CFAPFULLTHRESHOLDr_CFAPFULLSETPOINTf_SET
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET BCM56800_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_GET
#define CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET BCM56800_A0_CFAPFULLTHRESHOLDr_CFAPFULLRESETPOINTf_SET
#define READ_CFAPFULLTHRESHOLDr BCM56800_A0_READ_CFAPFULLTHRESHOLDr
#define WRITE_CFAPFULLTHRESHOLDr BCM56800_A0_WRITE_CFAPFULLTHRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CFAPFULLTHRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CFAPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm registers.
 *
 ******************************************************************************/
#define BCM56800_A0_CFAPMEMDEBUGr 0x07d80012

#define BCM56800_A0_CFAPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program CFAPMEMDEBUG.
 *
 */
typedef union BCM56800_A0_CFAPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t cfapmemdebug[1];
	uint32_t _cfapmemdebug;
} BCM56800_A0_CFAPMEMDEBUGr_t;

#define BCM56800_A0_CFAPMEMDEBUGr_CLR(r) (r).cfapmemdebug[0] = 0
#define BCM56800_A0_CFAPMEMDEBUGr_SET(r,d) (r).cfapmemdebug[0] = d
#define BCM56800_A0_CFAPMEMDEBUGr_GET(r) (r).cfapmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CFAPMEMDEBUGr_TMf_GET(r) (((r).cfapmemdebug[0]) & 0xf)
#define BCM56800_A0_CFAPMEMDEBUGr_TMf_SET(r,f) (r).cfapmemdebug[0]=(((r).cfapmemdebug[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access CFAPMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_CFAPMEMDEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CFAPMEMDEBUGr,(r._cfapmemdebug))
#define BCM56800_A0_WRITE_CFAPMEMDEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CFAPMEMDEBUGr,&(r._cfapmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPMEMDEBUGr BCM56800_A0_CFAPMEMDEBUGr
#define CFAPMEMDEBUGr_SIZE BCM56800_A0_CFAPMEMDEBUGr_SIZE
typedef BCM56800_A0_CFAPMEMDEBUGr_t CFAPMEMDEBUGr_t;
#define CFAPMEMDEBUGr_CLR BCM56800_A0_CFAPMEMDEBUGr_CLR
#define CFAPMEMDEBUGr_SET BCM56800_A0_CFAPMEMDEBUGr_SET
#define CFAPMEMDEBUGr_GET BCM56800_A0_CFAPMEMDEBUGr_GET
#define CFAPMEMDEBUGr_TMf_GET BCM56800_A0_CFAPMEMDEBUGr_TMf_GET
#define CFAPMEMDEBUGr_TMf_SET BCM56800_A0_CFAPMEMDEBUGr_TMf_SET
#define READ_CFAPMEMDEBUGr BCM56800_A0_READ_CFAPMEMDEBUGr
#define WRITE_CFAPMEMDEBUGr BCM56800_A0_WRITE_CFAPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CFAPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CFAPPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     CFAP Parity Error Pointer
 * SIZE:     32
 * FIELDS:
 *     CFAPPARITYERRORPTR The memory address at which the most recent CFAP parity error occurred.
 *
 ******************************************************************************/
#define BCM56800_A0_CFAPPARITYERRORPTRr 0x07d80011

#define BCM56800_A0_CFAPPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program CFAPPARITYERRORPTR.
 *
 */
typedef union BCM56800_A0_CFAPPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t cfapparityerrorptr[1];
	uint32_t _cfapparityerrorptr;
} BCM56800_A0_CFAPPARITYERRORPTRr_t;

#define BCM56800_A0_CFAPPARITYERRORPTRr_CLR(r) (r).cfapparityerrorptr[0] = 0
#define BCM56800_A0_CFAPPARITYERRORPTRr_SET(r,d) (r).cfapparityerrorptr[0] = d
#define BCM56800_A0_CFAPPARITYERRORPTRr_GET(r) (r).cfapparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET(r) (((r).cfapparityerrorptr[0]) & 0x3fff)
#define BCM56800_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET(r,f) (r).cfapparityerrorptr[0]=(((r).cfapparityerrorptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access CFAPPARITYERRORPTR.
 *
 */
#define BCM56800_A0_READ_CFAPPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CFAPPARITYERRORPTRr,(r._cfapparityerrorptr))
#define BCM56800_A0_WRITE_CFAPPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CFAPPARITYERRORPTRr,&(r._cfapparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPPARITYERRORPTRr BCM56800_A0_CFAPPARITYERRORPTRr
#define CFAPPARITYERRORPTRr_SIZE BCM56800_A0_CFAPPARITYERRORPTRr_SIZE
typedef BCM56800_A0_CFAPPARITYERRORPTRr_t CFAPPARITYERRORPTRr_t;
#define CFAPPARITYERRORPTRr_CLR BCM56800_A0_CFAPPARITYERRORPTRr_CLR
#define CFAPPARITYERRORPTRr_SET BCM56800_A0_CFAPPARITYERRORPTRr_SET
#define CFAPPARITYERRORPTRr_GET BCM56800_A0_CFAPPARITYERRORPTRr_GET
#define CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET BCM56800_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_GET
#define CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET BCM56800_A0_CFAPPARITYERRORPTRr_CFAPPARITYERRORPTRf_SET
#define READ_CFAPPARITYERRORPTRr BCM56800_A0_READ_CFAPPARITYERRORPTRr
#define WRITE_CFAPPARITYERRORPTRr BCM56800_A0_WRITE_CFAPPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CFAPPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CFAPREADPOINTER
 * BLOCKS:   MMU
 * DESC:     Specifies the CFAP status
 * SIZE:     32
 * FIELDS:
 *     CFAPREADPOINTER  The current number of cells that are outstanding in the CBP memory.
 *     CBPFULLSTATUS    Current CBP FULL Status
 *
 ******************************************************************************/
#define BCM56800_A0_CFAPREADPOINTERr 0x07d80010

#define BCM56800_A0_CFAPREADPOINTERr_SIZE 4

/*
 * This structure should be used to declare and program CFAPREADPOINTER.
 *
 */
typedef union BCM56800_A0_CFAPREADPOINTERr_s {
	uint32_t v[1];
	uint32_t cfapreadpointer[1];
	uint32_t _cfapreadpointer;
} BCM56800_A0_CFAPREADPOINTERr_t;

#define BCM56800_A0_CFAPREADPOINTERr_CLR(r) (r).cfapreadpointer[0] = 0
#define BCM56800_A0_CFAPREADPOINTERr_SET(r,d) (r).cfapreadpointer[0] = d
#define BCM56800_A0_CFAPREADPOINTERr_GET(r) (r).cfapreadpointer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_GET(r) (((r).cfapreadpointer[0]) & 0x3fff)
#define BCM56800_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_SET(r,f) (r).cfapreadpointer[0]=(((r).cfapreadpointer[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_GET(r) ((((r).cfapreadpointer[0]) >> 14) & 0x1)
#define BCM56800_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_SET(r,f) (r).cfapreadpointer[0]=(((r).cfapreadpointer[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access CFAPREADPOINTER.
 *
 */
#define BCM56800_A0_READ_CFAPREADPOINTERr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CFAPREADPOINTERr,(r._cfapreadpointer))
#define BCM56800_A0_WRITE_CFAPREADPOINTERr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CFAPREADPOINTERr,&(r._cfapreadpointer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CFAPREADPOINTERr BCM56800_A0_CFAPREADPOINTERr
#define CFAPREADPOINTERr_SIZE BCM56800_A0_CFAPREADPOINTERr_SIZE
typedef BCM56800_A0_CFAPREADPOINTERr_t CFAPREADPOINTERr_t;
#define CFAPREADPOINTERr_CLR BCM56800_A0_CFAPREADPOINTERr_CLR
#define CFAPREADPOINTERr_SET BCM56800_A0_CFAPREADPOINTERr_SET
#define CFAPREADPOINTERr_GET BCM56800_A0_CFAPREADPOINTERr_GET
#define CFAPREADPOINTERr_CFAPREADPOINTERf_GET BCM56800_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_GET
#define CFAPREADPOINTERr_CFAPREADPOINTERf_SET BCM56800_A0_CFAPREADPOINTERr_CFAPREADPOINTERf_SET
#define CFAPREADPOINTERr_CBPFULLSTATUSf_GET BCM56800_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_GET
#define CFAPREADPOINTERr_CBPFULLSTATUSf_SET BCM56800_A0_CFAPREADPOINTERr_CBPFULLSTATUSf_SET
#define READ_CFAPREADPOINTERr BCM56800_A0_READ_CFAPREADPOINTERr
#define WRITE_CFAPREADPOINTERr BCM56800_A0_WRITE_CFAPREADPOINTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CFAPREADPOINTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_CONFIG
 * BLOCKS:   CMIC
 * DESC:     Configuration Register
 * SIZE:     32
 * FIELDS:
 *     RD_BRST_EN       When set (1), CMIC supports PIO Read Bursts
 *     WR_BRST_EN       When set (1), CMIC supports PIO Write Bursts
 *     BE_CHECK_EN      When set (1), CMIC Does BE Check (32-bit) on PCI writes
 *     MSTR_Q_MAX_EN    When set (1), CMIC can queue up to 4 PCI master requests
 *     RESERVED_1       Reserved
 *     RESET_CPS        When set CMIC drives CPS-Channel reset
 *     ACT_LOW_INT      When set CMIC drives INTR pin as Active LOW (0) - Default is Active low
 *     SCHAN_ABORT      When set CMIC aborts any pending SCH operation
 *     UNTAG_ALL_RCV_EN When set CMIC removes the TAG field from all received Packets
 *     UNTAG_EN         When set CMIC can remove the TAG field
 *     LE_DMA_EN        When set CMIC the DMA data transfer will be done in Little Endian format
 *     I2C_EN           When set CMIC PCI access to I2C interface is Enabled
 *     RESERVED_2       Reserved
 *     IGNORE_ADR_ALIGN_EN When set, allow DMA (PCI->SOC) to be aligned to any address boundary.
 *     RESERVED_3       Reserved
 *     DMA_GARBAGE_COLLECT_EN When set CMIC collects packets with Purge bit set
 *     RESET_PCI_EN     If set, CPS reset will also  reset the internal CMIC PCI interface.
 *     TIME_STAMP_UPD_DIS Disable packet time stamp update operation.  DEBUG ONLY.
 *     SG_ENABLE        Enable scatter/gather operation.
 *     SG_RELOAD_ENABLE Enable scatter/gather reload operation.
 *     RLD_STS_UPD_DIS  When set, do not update status fields on reload operation.
 *     STOP_LS_ON_CHANGE When set, on link change detection, stop link scanning
 *     ABORT_STAT_DMA   Abort the current stat DMA operation.  Not for normal operation.
 *     RESERVED_4       Reserved
 *     COS_RX_EN        When set, packet DMA is based on received COS.  Multiple write channels can be active. 
 *     RESERVED_5       Reserved
 *     OVER_RIDE_EXT_MDIO_MSTR_CNTRL When set, external MDIO master access is disabled,and CMIC becomes the MDIO master, allowing hardware link scan. MUST BE 1 FOR NORMAL OPERATION. Set to 0x0 by default to allow ATE tests to access XAUI/SERDES cores.
 *     MIIM_ADDR_MAP_ENABLE When set, use the MDIO Address Map Table to get the Phy IDfrom the port number for both Wr/Rd and link scan.Else, use the Phy ID as-is.
 *     RESERVED_6       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_CONFIGr 0x0000010c

#define BCM56800_A0_CMIC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_CONFIG.
 *
 */
typedef union BCM56800_A0_CMIC_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_config[1];
	uint32_t _cmic_config;
} BCM56800_A0_CMIC_CONFIGr_t;

#define BCM56800_A0_CMIC_CONFIGr_CLR(r) (r).cmic_config[0] = 0
#define BCM56800_A0_CMIC_CONFIGr_SET(r,d) (r).cmic_config[0] = d
#define BCM56800_A0_CMIC_CONFIGr_GET(r) (r).cmic_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_CONFIGr_RD_BRST_ENf_GET(r) (((r).cmic_config[0]) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RD_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_CONFIGr_WR_BRST_ENf_GET(r) ((((r).cmic_config[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_WR_BRST_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_CONFIGr_BE_CHECK_ENf_GET(r) ((((r).cmic_config[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_BE_CHECK_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET(r) ((((r).cmic_config[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_1f_GET(r) ((((r).cmic_config[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_1f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_CONFIGr_RESET_CPSf_GET(r) ((((r).cmic_config[0]) >> 5) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RESET_CPSf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CMIC_CONFIGr_ACT_LOW_INTf_GET(r) ((((r).cmic_config[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_ACT_LOW_INTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_CONFIGr_SCHAN_ABORTf_GET(r) ((((r).cmic_config[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_SCHAN_ABORTf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET(r) ((((r).cmic_config[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_CONFIGr_UNTAG_ENf_GET(r) ((((r).cmic_config[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_UNTAG_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_CONFIGr_LE_DMA_ENf_GET(r) ((((r).cmic_config[0]) >> 10) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_LE_DMA_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_CMIC_CONFIGr_I2C_ENf_GET(r) ((((r).cmic_config[0]) >> 11) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_I2C_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_2f_GET(r) ((((r).cmic_config[0]) >> 12) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_2f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET(r) ((((r).cmic_config[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_3f_GET(r) ((((r).cmic_config[0]) >> 14) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_3f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET(r) ((((r).cmic_config[0]) >> 15) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CMIC_CONFIGr_RESET_PCI_ENf_GET(r) ((((r).cmic_config[0]) >> 16) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RESET_PCI_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_CONFIGr_SG_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_SG_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 19) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_GET(r) ((((r).cmic_config[0]) >> 20) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET(r) ((((r).cmic_config[0]) >> 21) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_GET(r) ((((r).cmic_config[0]) >> 22) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_4f_GET(r) ((((r).cmic_config[0]) >> 23) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_4f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_CMIC_CONFIGr_COS_RX_ENf_GET(r) ((((r).cmic_config[0]) >> 24) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_COS_RX_ENf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_5f_GET(r) ((((r).cmic_config[0]) >> 25) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_5f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET(r) ((((r).cmic_config[0]) >> 26) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET(r) ((((r).cmic_config[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_6f_GET(r) ((((r).cmic_config[0]) >> 28) & 0xf)
#define BCM56800_A0_CMIC_CONFIGr_RESERVED_6f_SET(r,f) (r).cmic_config[0]=(((r).cmic_config[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_CONFIG.
 *
 */
#define BCM56800_A0_READ_CMIC_CONFIGr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_CONFIGr,r._cmic_config)
#define BCM56800_A0_WRITE_CMIC_CONFIGr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_CONFIGr,r._cmic_config)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_CONFIGr BCM56800_A0_CMIC_CONFIGr
#define CMIC_CONFIGr_SIZE BCM56800_A0_CMIC_CONFIGr_SIZE
typedef BCM56800_A0_CMIC_CONFIGr_t CMIC_CONFIGr_t;
#define CMIC_CONFIGr_CLR BCM56800_A0_CMIC_CONFIGr_CLR
#define CMIC_CONFIGr_SET BCM56800_A0_CMIC_CONFIGr_SET
#define CMIC_CONFIGr_GET BCM56800_A0_CMIC_CONFIGr_GET
#define CMIC_CONFIGr_RD_BRST_ENf_GET BCM56800_A0_CMIC_CONFIGr_RD_BRST_ENf_GET
#define CMIC_CONFIGr_RD_BRST_ENf_SET BCM56800_A0_CMIC_CONFIGr_RD_BRST_ENf_SET
#define CMIC_CONFIGr_WR_BRST_ENf_GET BCM56800_A0_CMIC_CONFIGr_WR_BRST_ENf_GET
#define CMIC_CONFIGr_WR_BRST_ENf_SET BCM56800_A0_CMIC_CONFIGr_WR_BRST_ENf_SET
#define CMIC_CONFIGr_BE_CHECK_ENf_GET BCM56800_A0_CMIC_CONFIGr_BE_CHECK_ENf_GET
#define CMIC_CONFIGr_BE_CHECK_ENf_SET BCM56800_A0_CMIC_CONFIGr_BE_CHECK_ENf_SET
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET BCM56800_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_GET
#define CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET BCM56800_A0_CMIC_CONFIGr_MSTR_Q_MAX_ENf_SET
#define CMIC_CONFIGr_RESERVED_1f_GET BCM56800_A0_CMIC_CONFIGr_RESERVED_1f_GET
#define CMIC_CONFIGr_RESERVED_1f_SET BCM56800_A0_CMIC_CONFIGr_RESERVED_1f_SET
#define CMIC_CONFIGr_RESET_CPSf_GET BCM56800_A0_CMIC_CONFIGr_RESET_CPSf_GET
#define CMIC_CONFIGr_RESET_CPSf_SET BCM56800_A0_CMIC_CONFIGr_RESET_CPSf_SET
#define CMIC_CONFIGr_ACT_LOW_INTf_GET BCM56800_A0_CMIC_CONFIGr_ACT_LOW_INTf_GET
#define CMIC_CONFIGr_ACT_LOW_INTf_SET BCM56800_A0_CMIC_CONFIGr_ACT_LOW_INTf_SET
#define CMIC_CONFIGr_SCHAN_ABORTf_GET BCM56800_A0_CMIC_CONFIGr_SCHAN_ABORTf_GET
#define CMIC_CONFIGr_SCHAN_ABORTf_SET BCM56800_A0_CMIC_CONFIGr_SCHAN_ABORTf_SET
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET BCM56800_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_GET
#define CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET BCM56800_A0_CMIC_CONFIGr_UNTAG_ALL_RCV_ENf_SET
#define CMIC_CONFIGr_UNTAG_ENf_GET BCM56800_A0_CMIC_CONFIGr_UNTAG_ENf_GET
#define CMIC_CONFIGr_UNTAG_ENf_SET BCM56800_A0_CMIC_CONFIGr_UNTAG_ENf_SET
#define CMIC_CONFIGr_LE_DMA_ENf_GET BCM56800_A0_CMIC_CONFIGr_LE_DMA_ENf_GET
#define CMIC_CONFIGr_LE_DMA_ENf_SET BCM56800_A0_CMIC_CONFIGr_LE_DMA_ENf_SET
#define CMIC_CONFIGr_I2C_ENf_GET BCM56800_A0_CMIC_CONFIGr_I2C_ENf_GET
#define CMIC_CONFIGr_I2C_ENf_SET BCM56800_A0_CMIC_CONFIGr_I2C_ENf_SET
#define CMIC_CONFIGr_RESERVED_2f_GET BCM56800_A0_CMIC_CONFIGr_RESERVED_2f_GET
#define CMIC_CONFIGr_RESERVED_2f_SET BCM56800_A0_CMIC_CONFIGr_RESERVED_2f_SET
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET BCM56800_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_GET
#define CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET BCM56800_A0_CMIC_CONFIGr_IGNORE_ADR_ALIGN_ENf_SET
#define CMIC_CONFIGr_RESERVED_3f_GET BCM56800_A0_CMIC_CONFIGr_RESERVED_3f_GET
#define CMIC_CONFIGr_RESERVED_3f_SET BCM56800_A0_CMIC_CONFIGr_RESERVED_3f_SET
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET BCM56800_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_GET
#define CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET BCM56800_A0_CMIC_CONFIGr_DMA_GARBAGE_COLLECT_ENf_SET
#define CMIC_CONFIGr_RESET_PCI_ENf_GET BCM56800_A0_CMIC_CONFIGr_RESET_PCI_ENf_GET
#define CMIC_CONFIGr_RESET_PCI_ENf_SET BCM56800_A0_CMIC_CONFIGr_RESET_PCI_ENf_SET
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET BCM56800_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_GET
#define CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET BCM56800_A0_CMIC_CONFIGr_TIME_STAMP_UPD_DISf_SET
#define CMIC_CONFIGr_SG_ENABLEf_GET BCM56800_A0_CMIC_CONFIGr_SG_ENABLEf_GET
#define CMIC_CONFIGr_SG_ENABLEf_SET BCM56800_A0_CMIC_CONFIGr_SG_ENABLEf_SET
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET BCM56800_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_GET
#define CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET BCM56800_A0_CMIC_CONFIGr_SG_RELOAD_ENABLEf_SET
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_GET BCM56800_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_GET
#define CMIC_CONFIGr_RLD_STS_UPD_DISf_SET BCM56800_A0_CMIC_CONFIGr_RLD_STS_UPD_DISf_SET
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET BCM56800_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_GET
#define CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET BCM56800_A0_CMIC_CONFIGr_STOP_LS_ON_CHANGEf_SET
#define CMIC_CONFIGr_ABORT_STAT_DMAf_GET BCM56800_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_GET
#define CMIC_CONFIGr_ABORT_STAT_DMAf_SET BCM56800_A0_CMIC_CONFIGr_ABORT_STAT_DMAf_SET
#define CMIC_CONFIGr_RESERVED_4f_GET BCM56800_A0_CMIC_CONFIGr_RESERVED_4f_GET
#define CMIC_CONFIGr_RESERVED_4f_SET BCM56800_A0_CMIC_CONFIGr_RESERVED_4f_SET
#define CMIC_CONFIGr_COS_RX_ENf_GET BCM56800_A0_CMIC_CONFIGr_COS_RX_ENf_GET
#define CMIC_CONFIGr_COS_RX_ENf_SET BCM56800_A0_CMIC_CONFIGr_COS_RX_ENf_SET
#define CMIC_CONFIGr_RESERVED_5f_GET BCM56800_A0_CMIC_CONFIGr_RESERVED_5f_GET
#define CMIC_CONFIGr_RESERVED_5f_SET BCM56800_A0_CMIC_CONFIGr_RESERVED_5f_SET
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET BCM56800_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_GET
#define CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET BCM56800_A0_CMIC_CONFIGr_OVER_RIDE_EXT_MDIO_MSTR_CNTRLf_SET
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET BCM56800_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_GET
#define CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET BCM56800_A0_CMIC_CONFIGr_MIIM_ADDR_MAP_ENABLEf_SET
#define CMIC_CONFIGr_RESERVED_6f_GET BCM56800_A0_CMIC_CONFIGr_RESERVED_6f_GET
#define CMIC_CONFIGr_RESERVED_6f_SET BCM56800_A0_CMIC_CONFIGr_RESERVED_6f_SET
#define READ_CMIC_CONFIGr BCM56800_A0_READ_CMIC_CONFIGr
#define WRITE_CMIC_CONFIGr BCM56800_A0_WRITE_CMIC_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_COS_CTRL_RX
 * BLOCKS:   CMIC
 * DESC:     When COS_RX_EN of CMIC_CONFIG is set, this register
indicates which cos are admitted by channel 

 * SIZE:     32
 * FIELDS:
 *     CH0_COS_BMP      Channel 0 COS bitmap
 *     CH1_COS_BMP      Channel 1 COS bitmap
 *     CH2_COS_BMP      Channel 2 COS bitmap
 *     CH3_COS_BMP      Channel 3 COS bitmap
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_COS_CTRL_RXr 0x00000180

#define BCM56800_A0_CMIC_COS_CTRL_RXr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COS_CTRL_RX.
 *
 */
typedef union BCM56800_A0_CMIC_COS_CTRL_RXr_s {
	uint32_t v[1];
	uint32_t cmic_cos_ctrl_rx[1];
	uint32_t _cmic_cos_ctrl_rx;
} BCM56800_A0_CMIC_COS_CTRL_RXr_t;

#define BCM56800_A0_CMIC_COS_CTRL_RXr_CLR(r) (r).cmic_cos_ctrl_rx[0] = 0
#define BCM56800_A0_CMIC_COS_CTRL_RXr_SET(r,d) (r).cmic_cos_ctrl_rx[0] = d
#define BCM56800_A0_CMIC_COS_CTRL_RXr_GET(r) (r).cmic_cos_ctrl_rx[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET(r) (((r).cmic_cos_ctrl_rx[0]) & 0xff)
#define BCM56800_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 8) & 0xff)
#define BCM56800_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 16) & 0xff)
#define BCM56800_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET(r) ((((r).cmic_cos_ctrl_rx[0]) >> 24) & 0xff)
#define BCM56800_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET(r,f) (r).cmic_cos_ctrl_rx[0]=(((r).cmic_cos_ctrl_rx[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_COS_CTRL_RX.
 *
 */
#define BCM56800_A0_READ_CMIC_COS_CTRL_RXr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_COS_CTRL_RXr,r._cmic_cos_ctrl_rx)
#define BCM56800_A0_WRITE_CMIC_COS_CTRL_RXr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_COS_CTRL_RXr,r._cmic_cos_ctrl_rx)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_COS_CTRL_RXr BCM56800_A0_CMIC_COS_CTRL_RXr
#define CMIC_COS_CTRL_RXr_SIZE BCM56800_A0_CMIC_COS_CTRL_RXr_SIZE
typedef BCM56800_A0_CMIC_COS_CTRL_RXr_t CMIC_COS_CTRL_RXr_t;
#define CMIC_COS_CTRL_RXr_CLR BCM56800_A0_CMIC_COS_CTRL_RXr_CLR
#define CMIC_COS_CTRL_RXr_SET BCM56800_A0_CMIC_COS_CTRL_RXr_SET
#define CMIC_COS_CTRL_RXr_GET BCM56800_A0_CMIC_COS_CTRL_RXr_GET
#define CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET BCM56800_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET BCM56800_A0_CMIC_COS_CTRL_RXr_CH0_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET BCM56800_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET BCM56800_A0_CMIC_COS_CTRL_RXr_CH1_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET BCM56800_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET BCM56800_A0_CMIC_COS_CTRL_RXr_CH2_COS_BMPf_SET
#define CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET BCM56800_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_GET
#define CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET BCM56800_A0_CMIC_COS_CTRL_RXr_CH3_COS_BMPf_SET
#define READ_CMIC_COS_CTRL_RXr BCM56800_A0_READ_CMIC_COS_CTRL_RXr
#define WRITE_CMIC_COS_CTRL_RXr BCM56800_A0_WRITE_CMIC_COS_CTRL_RXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_COS_CTRL_RXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_COS_CTRL_RX_HI
 * BLOCKS:   CMIC
 * DESC:     This register provides the upper two bits (bits 9,8) of the CoS value
indicating which CoS are admitted by the channel. The lower 8 bits are
provided by the register CMIC_COS_CTRL_RX. CMIC_COS_CTRL_RX_HI is new
for Humv/Bradley.

 * SIZE:     32
 * FIELDS:
 *     CH0_COS_BMP_HI   Upper two bits of the 10-bit Channel 0 COS bitmap
 *     RESERVED_0       Reserved
 *     CH1_COS_BMP_HI   Upper two bits of the 10-bit Channel 1 COS bitmap
 *     RESERVED_1       Reserved
 *     CH2_COS_BMP_HI   Upper two bits of the 10-bit Channel 2 COS bitmap
 *     RESERVED_2       Reserved
 *     CH3_COS_BMP_HI   Upper two bits of the 10-bit Channel 3 COS bitmap
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr 0x00000184

#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_COS_CTRL_RX_HI.
 *
 */
typedef union BCM56800_A0_CMIC_COS_CTRL_RX_HIr_s {
	uint32_t v[1];
	uint32_t cmic_cos_ctrl_rx_hi[1];
	uint32_t _cmic_cos_ctrl_rx_hi;
} BCM56800_A0_CMIC_COS_CTRL_RX_HIr_t;

#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CLR(r) (r).cmic_cos_ctrl_rx_hi[0] = 0
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_SET(r,d) (r).cmic_cos_ctrl_rx_hi[0] = d
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_GET(r) (r).cmic_cos_ctrl_rx_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMP_HIf_GET(r) (((r).cmic_cos_ctrl_rx_hi[0]) & 0x3)
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMP_HIf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_0f_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 2) & 0x3f)
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_0f_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMP_HIf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 8) & 0x3)
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMP_HIf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_1f_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 10) & 0x3f)
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_1f_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMP_HIf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 16) & 0x3)
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMP_HIf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_2f_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 18) & 0x3f)
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_2f_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0x3f << 18)) | ((((uint32_t)f) & 0x3f) << 18))
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMP_HIf_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 24) & 0x3)
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMP_HIf_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_3f_GET(r) ((((r).cmic_cos_ctrl_rx_hi[0]) >> 26) & 0x3f)
#define BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_3f_SET(r,f) (r).cmic_cos_ctrl_rx_hi[0]=(((r).cmic_cos_ctrl_rx_hi[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_COS_CTRL_RX_HI.
 *
 */
#define BCM56800_A0_READ_CMIC_COS_CTRL_RX_HIr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_COS_CTRL_RX_HIr,r._cmic_cos_ctrl_rx_hi)
#define BCM56800_A0_WRITE_CMIC_COS_CTRL_RX_HIr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_COS_CTRL_RX_HIr,r._cmic_cos_ctrl_rx_hi)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_COS_CTRL_RX_HIr BCM56800_A0_CMIC_COS_CTRL_RX_HIr
#define CMIC_COS_CTRL_RX_HIr_SIZE BCM56800_A0_CMIC_COS_CTRL_RX_HIr_SIZE
typedef BCM56800_A0_CMIC_COS_CTRL_RX_HIr_t CMIC_COS_CTRL_RX_HIr_t;
#define CMIC_COS_CTRL_RX_HIr_CLR BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CLR
#define CMIC_COS_CTRL_RX_HIr_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_SET
#define CMIC_COS_CTRL_RX_HIr_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_GET
#define CMIC_COS_CTRL_RX_HIr_CH0_COS_BMP_HIf_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMP_HIf_GET
#define CMIC_COS_CTRL_RX_HIr_CH0_COS_BMP_HIf_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH0_COS_BMP_HIf_SET
#define CMIC_COS_CTRL_RX_HIr_RESERVED_0f_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_0f_GET
#define CMIC_COS_CTRL_RX_HIr_RESERVED_0f_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_0f_SET
#define CMIC_COS_CTRL_RX_HIr_CH1_COS_BMP_HIf_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMP_HIf_GET
#define CMIC_COS_CTRL_RX_HIr_CH1_COS_BMP_HIf_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH1_COS_BMP_HIf_SET
#define CMIC_COS_CTRL_RX_HIr_RESERVED_1f_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_1f_GET
#define CMIC_COS_CTRL_RX_HIr_RESERVED_1f_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_1f_SET
#define CMIC_COS_CTRL_RX_HIr_CH2_COS_BMP_HIf_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMP_HIf_GET
#define CMIC_COS_CTRL_RX_HIr_CH2_COS_BMP_HIf_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH2_COS_BMP_HIf_SET
#define CMIC_COS_CTRL_RX_HIr_RESERVED_2f_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_2f_GET
#define CMIC_COS_CTRL_RX_HIr_RESERVED_2f_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_2f_SET
#define CMIC_COS_CTRL_RX_HIr_CH3_COS_BMP_HIf_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMP_HIf_GET
#define CMIC_COS_CTRL_RX_HIr_CH3_COS_BMP_HIf_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_CH3_COS_BMP_HIf_SET
#define CMIC_COS_CTRL_RX_HIr_RESERVED_3f_GET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_3f_GET
#define CMIC_COS_CTRL_RX_HIr_RESERVED_3f_SET BCM56800_A0_CMIC_COS_CTRL_RX_HIr_RESERVED_3f_SET
#define READ_CMIC_COS_CTRL_RX_HIr BCM56800_A0_READ_CMIC_COS_CTRL_RX_HIr
#define WRITE_CMIC_COS_CTRL_RX_HIr BCM56800_A0_WRITE_CMIC_COS_CTRL_RX_HIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_COS_CTRL_RX_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_DEV_REV_ID
 * BLOCKS:   CMIC
 * DESC:     Device/revision ID
 * SIZE:     32
 * FIELDS:
 *     DEV_ID           Device ID
 *     REV_ID           Revision ID
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_DEV_REV_IDr 0x00000178

#define BCM56800_A0_CMIC_DEV_REV_IDr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DEV_REV_ID.
 *
 */
typedef union BCM56800_A0_CMIC_DEV_REV_IDr_s {
	uint32_t v[1];
	uint32_t cmic_dev_rev_id[1];
	uint32_t _cmic_dev_rev_id;
} BCM56800_A0_CMIC_DEV_REV_IDr_t;

#define BCM56800_A0_CMIC_DEV_REV_IDr_CLR(r) (r).cmic_dev_rev_id[0] = 0
#define BCM56800_A0_CMIC_DEV_REV_IDr_SET(r,d) (r).cmic_dev_rev_id[0] = d
#define BCM56800_A0_CMIC_DEV_REV_IDr_GET(r) (r).cmic_dev_rev_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_DEV_REV_IDr_DEV_IDf_GET(r) (((r).cmic_dev_rev_id[0]) & 0xffff)
#define BCM56800_A0_CMIC_DEV_REV_IDr_DEV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CMIC_DEV_REV_IDr_REV_IDf_GET(r) ((((r).cmic_dev_rev_id[0]) >> 16) & 0xff)
#define BCM56800_A0_CMIC_DEV_REV_IDr_REV_IDf_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_CMIC_DEV_REV_IDr_RESERVED_1f_GET(r) ((((r).cmic_dev_rev_id[0]) >> 24) & 0xff)
#define BCM56800_A0_CMIC_DEV_REV_IDr_RESERVED_1f_SET(r,f) (r).cmic_dev_rev_id[0]=(((r).cmic_dev_rev_id[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_DEV_REV_ID.
 *
 */
#define BCM56800_A0_READ_CMIC_DEV_REV_IDr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_DEV_REV_IDr,r._cmic_dev_rev_id)
#define BCM56800_A0_WRITE_CMIC_DEV_REV_IDr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_DEV_REV_IDr,r._cmic_dev_rev_id)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DEV_REV_IDr BCM56800_A0_CMIC_DEV_REV_IDr
#define CMIC_DEV_REV_IDr_SIZE BCM56800_A0_CMIC_DEV_REV_IDr_SIZE
typedef BCM56800_A0_CMIC_DEV_REV_IDr_t CMIC_DEV_REV_IDr_t;
#define CMIC_DEV_REV_IDr_CLR BCM56800_A0_CMIC_DEV_REV_IDr_CLR
#define CMIC_DEV_REV_IDr_SET BCM56800_A0_CMIC_DEV_REV_IDr_SET
#define CMIC_DEV_REV_IDr_GET BCM56800_A0_CMIC_DEV_REV_IDr_GET
#define CMIC_DEV_REV_IDr_DEV_IDf_GET BCM56800_A0_CMIC_DEV_REV_IDr_DEV_IDf_GET
#define CMIC_DEV_REV_IDr_DEV_IDf_SET BCM56800_A0_CMIC_DEV_REV_IDr_DEV_IDf_SET
#define CMIC_DEV_REV_IDr_REV_IDf_GET BCM56800_A0_CMIC_DEV_REV_IDr_REV_IDf_GET
#define CMIC_DEV_REV_IDr_REV_IDf_SET BCM56800_A0_CMIC_DEV_REV_IDr_REV_IDf_SET
#define CMIC_DEV_REV_IDr_RESERVED_1f_GET BCM56800_A0_CMIC_DEV_REV_IDr_RESERVED_1f_GET
#define CMIC_DEV_REV_IDr_RESERVED_1f_SET BCM56800_A0_CMIC_DEV_REV_IDr_RESERVED_1f_SET
#define READ_CMIC_DEV_REV_IDr BCM56800_A0_READ_CMIC_DEV_REV_IDr
#define WRITE_CMIC_DEV_REV_IDr BCM56800_A0_WRITE_CMIC_DEV_REV_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_DEV_REV_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_DMA_CTRL
 * BLOCKS:   CMIC
 * DESC:     DMA Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_DIRECTION    DMA channel 0 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH0   Reserved
 *     CH0_ABORT_DMA    DMA channel 0 abort
 *     CH0_SEL_INTR_ON_DESC_OR_PKT DMA channel 0 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH0   Reserved
 *     RESERVED_3_CH0   Reserved
 *     CH0_DROP_RX_PKT_ON_CHAIN_END DMA channel 0 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH1_DIRECTION    DMA channel 1 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH1   Reserved
 *     CH1_ABORT_DMA    DMA channel 1 abort
 *     CH1_SEL_INTR_ON_DESC_OR_PKT DMA channel 1 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH1   Reserved
 *     RESERVED_3_CH1   Reserved
 *     CH1_DROP_RX_PKT_ON_CHAIN_END DMA channel 1 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH2_DIRECTION    DMA channel 2 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH2   Reserved
 *     CH2_ABORT_DMA    DMA channel 2 abort
 *     CH2_SEL_INTR_ON_DESC_OR_PKT DMA channel 2 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH2   Reserved
 *     RESERVED_3_CH2   Reserved
 *     CH2_DROP_RX_PKT_ON_CHAIN_END DMA channel 2 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *     CH3_DIRECTION    DMA channel 3 direction:1=Mem->SOC, 0=SOC->Mem
 *     RESERVED_1_CH3   Reserved
 *     CH3_ABORT_DMA    DMA channel 3 abort
 *     CH3_SEL_INTR_ON_DESC_OR_PKT DMA channel 3 interrupt select:1=after descriptor, 0=after packet
 *     RESERVED_2_CH3   Reserved
 *     RESERVED_3_CH3   Reserved
 *     CH3_DROP_RX_PKT_ON_CHAIN_END DMA channel 3 setting for handling packet received after hittingend of chain (and hence no descriptors are available)1=drop the packet, 0=block, waiting for descriptor to be available
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_DMA_CTRLr 0x00000100

#define BCM56800_A0_CMIC_DMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_CTRL.
 *
 */
typedef union BCM56800_A0_CMIC_DMA_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_dma_ctrl[1];
	uint32_t _cmic_dma_ctrl;
} BCM56800_A0_CMIC_DMA_CTRLr_t;

#define BCM56800_A0_CMIC_DMA_CTRLr_CLR(r) (r).cmic_dma_ctrl[0] = 0
#define BCM56800_A0_CMIC_DMA_CTRLr_SET(r,d) (r).cmic_dma_ctrl[0] = d
#define BCM56800_A0_CMIC_DMA_CTRLr_GET(r) (r).cmic_dma_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET(r) (((r).cmic_dma_ctrl[0]) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 5) & 0x3)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 10) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 11) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 12) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 13) & 0x3)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 15) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 16) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 19) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 20) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 21) & 0x3)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 21)) | ((((uint32_t)f) & 0x3) << 21))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 23) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 24) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 25) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 26) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 28) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET(r) ((((r).cmic_dma_ctrl[0]) >> 29) & 0x3)
#define BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x3 << 29)) | ((((uint32_t)f) & 0x3) << 29))
#define BCM56800_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET(r) ((((r).cmic_dma_ctrl[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET(r,f) (r).cmic_dma_ctrl[0]=(((r).cmic_dma_ctrl[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_DMA_CTRL.
 *
 */
#define BCM56800_A0_READ_CMIC_DMA_CTRLr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_DMA_CTRLr,r._cmic_dma_ctrl)
#define BCM56800_A0_WRITE_CMIC_DMA_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_DMA_CTRLr,r._cmic_dma_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_CTRLr BCM56800_A0_CMIC_DMA_CTRLr
#define CMIC_DMA_CTRLr_SIZE BCM56800_A0_CMIC_DMA_CTRLr_SIZE
typedef BCM56800_A0_CMIC_DMA_CTRLr_t CMIC_DMA_CTRLr_t;
#define CMIC_DMA_CTRLr_CLR BCM56800_A0_CMIC_DMA_CTRLr_CLR
#define CMIC_DMA_CTRLr_SET BCM56800_A0_CMIC_DMA_CTRLr_SET
#define CMIC_DMA_CTRLr_GET BCM56800_A0_CMIC_DMA_CTRLr_GET
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH0_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH0f_SET
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH0_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH0_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH0f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH0f_SET
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH0_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH1_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH1f_SET
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH1_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH1_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH1f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH1f_SET
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH1_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH2_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH2f_SET
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH2_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH2_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH2f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH2f_SET
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH2_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_GET
#define CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH3_DIRECTIONf_SET
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_1_CH3f_SET
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_GET
#define CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH3_ABORT_DMAf_SET
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_GET
#define CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH3_SEL_INTR_ON_DESC_OR_PKTf_SET
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_2_CH3f_SET
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_GET
#define CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET BCM56800_A0_CMIC_DMA_CTRLr_RESERVED_3_CH3f_SET
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET BCM56800_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_GET
#define CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET BCM56800_A0_CMIC_DMA_CTRLr_CH3_DROP_RX_PKT_ON_CHAIN_ENDf_SET
#define READ_CMIC_DMA_CTRLr BCM56800_A0_READ_CMIC_DMA_CTRLr
#define WRITE_CMIC_DMA_CTRLr BCM56800_A0_WRITE_CMIC_DMA_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_DMA_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_DMA_DESC0
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 0 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH0 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_DMA_DESC0r 0x00000110

#define BCM56800_A0_CMIC_DMA_DESC0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC0.
 *
 */
typedef union BCM56800_A0_CMIC_DMA_DESC0r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc0[1];
	uint32_t _cmic_dma_desc0;
} BCM56800_A0_CMIC_DMA_DESC0r_t;

#define BCM56800_A0_CMIC_DMA_DESC0r_CLR(r) (r).cmic_dma_desc0[0] = 0
#define BCM56800_A0_CMIC_DMA_DESC0r_SET(r,d) (r).cmic_dma_desc0[0] = d
#define BCM56800_A0_CMIC_DMA_DESC0r_GET(r) (r).cmic_dma_desc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_DMA_DESC0r_ADDRf_GET(r) ((r).cmic_dma_desc0[0])
#define BCM56800_A0_CMIC_DMA_DESC0r_ADDRf_SET(r,f) (r).cmic_dma_desc0[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC0.
 *
 */
#define BCM56800_A0_READ_CMIC_DMA_DESC0r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_DMA_DESC0r,r._cmic_dma_desc0)
#define BCM56800_A0_WRITE_CMIC_DMA_DESC0r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_DMA_DESC0r,r._cmic_dma_desc0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC0r BCM56800_A0_CMIC_DMA_DESC0r
#define CMIC_DMA_DESC0r_SIZE BCM56800_A0_CMIC_DMA_DESC0r_SIZE
typedef BCM56800_A0_CMIC_DMA_DESC0r_t CMIC_DMA_DESC0r_t;
#define CMIC_DMA_DESC0r_CLR BCM56800_A0_CMIC_DMA_DESC0r_CLR
#define CMIC_DMA_DESC0r_SET BCM56800_A0_CMIC_DMA_DESC0r_SET
#define CMIC_DMA_DESC0r_GET BCM56800_A0_CMIC_DMA_DESC0r_GET
#define CMIC_DMA_DESC0r_ADDRf_GET BCM56800_A0_CMIC_DMA_DESC0r_ADDRf_GET
#define CMIC_DMA_DESC0r_ADDRf_SET BCM56800_A0_CMIC_DMA_DESC0r_ADDRf_SET
#define READ_CMIC_DMA_DESC0r BCM56800_A0_READ_CMIC_DMA_DESC0r
#define WRITE_CMIC_DMA_DESC0r BCM56800_A0_WRITE_CMIC_DMA_DESC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_DMA_DESC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_DMA_DESC1
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 1 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH1 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_DMA_DESC1r 0x00000114

#define BCM56800_A0_CMIC_DMA_DESC1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC1.
 *
 */
typedef union BCM56800_A0_CMIC_DMA_DESC1r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc1[1];
	uint32_t _cmic_dma_desc1;
} BCM56800_A0_CMIC_DMA_DESC1r_t;

#define BCM56800_A0_CMIC_DMA_DESC1r_CLR(r) (r).cmic_dma_desc1[0] = 0
#define BCM56800_A0_CMIC_DMA_DESC1r_SET(r,d) (r).cmic_dma_desc1[0] = d
#define BCM56800_A0_CMIC_DMA_DESC1r_GET(r) (r).cmic_dma_desc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_DMA_DESC1r_ADDRf_GET(r) ((r).cmic_dma_desc1[0])
#define BCM56800_A0_CMIC_DMA_DESC1r_ADDRf_SET(r,f) (r).cmic_dma_desc1[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC1.
 *
 */
#define BCM56800_A0_READ_CMIC_DMA_DESC1r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_DMA_DESC1r,r._cmic_dma_desc1)
#define BCM56800_A0_WRITE_CMIC_DMA_DESC1r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_DMA_DESC1r,r._cmic_dma_desc1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC1r BCM56800_A0_CMIC_DMA_DESC1r
#define CMIC_DMA_DESC1r_SIZE BCM56800_A0_CMIC_DMA_DESC1r_SIZE
typedef BCM56800_A0_CMIC_DMA_DESC1r_t CMIC_DMA_DESC1r_t;
#define CMIC_DMA_DESC1r_CLR BCM56800_A0_CMIC_DMA_DESC1r_CLR
#define CMIC_DMA_DESC1r_SET BCM56800_A0_CMIC_DMA_DESC1r_SET
#define CMIC_DMA_DESC1r_GET BCM56800_A0_CMIC_DMA_DESC1r_GET
#define CMIC_DMA_DESC1r_ADDRf_GET BCM56800_A0_CMIC_DMA_DESC1r_ADDRf_GET
#define CMIC_DMA_DESC1r_ADDRf_SET BCM56800_A0_CMIC_DMA_DESC1r_ADDRf_SET
#define READ_CMIC_DMA_DESC1r BCM56800_A0_READ_CMIC_DMA_DESC1r
#define WRITE_CMIC_DMA_DESC1r BCM56800_A0_WRITE_CMIC_DMA_DESC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_DMA_DESC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_DMA_DESC2
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 2 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH2 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_DMA_DESC2r 0x00000118

#define BCM56800_A0_CMIC_DMA_DESC2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC2.
 *
 */
typedef union BCM56800_A0_CMIC_DMA_DESC2r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc2[1];
	uint32_t _cmic_dma_desc2;
} BCM56800_A0_CMIC_DMA_DESC2r_t;

#define BCM56800_A0_CMIC_DMA_DESC2r_CLR(r) (r).cmic_dma_desc2[0] = 0
#define BCM56800_A0_CMIC_DMA_DESC2r_SET(r,d) (r).cmic_dma_desc2[0] = d
#define BCM56800_A0_CMIC_DMA_DESC2r_GET(r) (r).cmic_dma_desc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_DMA_DESC2r_ADDRf_GET(r) ((r).cmic_dma_desc2[0])
#define BCM56800_A0_CMIC_DMA_DESC2r_ADDRf_SET(r,f) (r).cmic_dma_desc2[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC2.
 *
 */
#define BCM56800_A0_READ_CMIC_DMA_DESC2r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_DMA_DESC2r,r._cmic_dma_desc2)
#define BCM56800_A0_WRITE_CMIC_DMA_DESC2r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_DMA_DESC2r,r._cmic_dma_desc2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC2r BCM56800_A0_CMIC_DMA_DESC2r
#define CMIC_DMA_DESC2r_SIZE BCM56800_A0_CMIC_DMA_DESC2r_SIZE
typedef BCM56800_A0_CMIC_DMA_DESC2r_t CMIC_DMA_DESC2r_t;
#define CMIC_DMA_DESC2r_CLR BCM56800_A0_CMIC_DMA_DESC2r_CLR
#define CMIC_DMA_DESC2r_SET BCM56800_A0_CMIC_DMA_DESC2r_SET
#define CMIC_DMA_DESC2r_GET BCM56800_A0_CMIC_DMA_DESC2r_GET
#define CMIC_DMA_DESC2r_ADDRf_GET BCM56800_A0_CMIC_DMA_DESC2r_ADDRf_GET
#define CMIC_DMA_DESC2r_ADDRf_SET BCM56800_A0_CMIC_DMA_DESC2r_ADDRf_SET
#define READ_CMIC_DMA_DESC2r BCM56800_A0_READ_CMIC_DMA_DESC2r
#define WRITE_CMIC_DMA_DESC2r BCM56800_A0_WRITE_CMIC_DMA_DESC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_DMA_DESC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_DMA_DESC3
 * BLOCKS:   CMIC
 * DESC:     DMA Channel 3 Descriptor Address
 * SIZE:     32
 * FIELDS:
 *     ADDR             DMA CH3 DESCRIPTOR ADDRESS REGISTER
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_DMA_DESC3r 0x0000011c

#define BCM56800_A0_CMIC_DMA_DESC3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_DESC3.
 *
 */
typedef union BCM56800_A0_CMIC_DMA_DESC3r_s {
	uint32_t v[1];
	uint32_t cmic_dma_desc3[1];
	uint32_t _cmic_dma_desc3;
} BCM56800_A0_CMIC_DMA_DESC3r_t;

#define BCM56800_A0_CMIC_DMA_DESC3r_CLR(r) (r).cmic_dma_desc3[0] = 0
#define BCM56800_A0_CMIC_DMA_DESC3r_SET(r,d) (r).cmic_dma_desc3[0] = d
#define BCM56800_A0_CMIC_DMA_DESC3r_GET(r) (r).cmic_dma_desc3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_DMA_DESC3r_ADDRf_GET(r) ((r).cmic_dma_desc3[0])
#define BCM56800_A0_CMIC_DMA_DESC3r_ADDRf_SET(r,f) (r).cmic_dma_desc3[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_DMA_DESC3.
 *
 */
#define BCM56800_A0_READ_CMIC_DMA_DESC3r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_DMA_DESC3r,r._cmic_dma_desc3)
#define BCM56800_A0_WRITE_CMIC_DMA_DESC3r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_DMA_DESC3r,r._cmic_dma_desc3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_DESC3r BCM56800_A0_CMIC_DMA_DESC3r
#define CMIC_DMA_DESC3r_SIZE BCM56800_A0_CMIC_DMA_DESC3r_SIZE
typedef BCM56800_A0_CMIC_DMA_DESC3r_t CMIC_DMA_DESC3r_t;
#define CMIC_DMA_DESC3r_CLR BCM56800_A0_CMIC_DMA_DESC3r_CLR
#define CMIC_DMA_DESC3r_SET BCM56800_A0_CMIC_DMA_DESC3r_SET
#define CMIC_DMA_DESC3r_GET BCM56800_A0_CMIC_DMA_DESC3r_GET
#define CMIC_DMA_DESC3r_ADDRf_GET BCM56800_A0_CMIC_DMA_DESC3r_ADDRf_GET
#define CMIC_DMA_DESC3r_ADDRf_SET BCM56800_A0_CMIC_DMA_DESC3r_ADDRf_SET
#define READ_CMIC_DMA_DESC3r BCM56800_A0_READ_CMIC_DMA_DESC3r
#define WRITE_CMIC_DMA_DESC3r BCM56800_A0_WRITE_CMIC_DMA_DESC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_DMA_DESC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_DMA_STAT
 * BLOCKS:   CMIC
 * DESC:     DMA Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     CH0_DMA_EN       Set by CPU to start a DMA on CH0 
 *     CH1_DMA_EN       Set by CPU to start a DMA on CH1 
 *     CH2_DMA_EN       Set by CPU to start a DMA on CH2 
 *     CH3_DMA_EN       Set by CPU to start a DMA on CH3 
 *     CH0_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH1_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH2_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH3_CHAIN_DONE   Set by CMIC indicating DMA Completion 
 *     CH0_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH1_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH2_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     CH3_DESC_DONE    Set by CMIC indicating Current DMA DES Completion 
 *     DMA_RESET        Set by CPU to reset DMA Controller
 *     STATS_DMA_OPN_COMPLETE Set by CPU to indicate Stats DMA operation complete
 *     STATS_DMA_ITER_DONE Set by CPU to indicate Stats DMA iteration done
 *     TX_DMA_ABORT_NEEDS_CLEANUP Set by CPU to indicate that the previous TX DMA was aborted inthe middle of a packet (i.e., not at packet boundary). The CPU needs to clean up by forcing an eop packet with purge bit set.
 *     STATS_DMA_ERROR  Set by CPU to indicate Stats DMA resulted in an error
 *     STATS_DMA_ACTIVE Set by CPU to indicate Stats DMA currently active
 *     CH0_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH1_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH2_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     CH3_DMA_ACTIVE   Set by CMIC to indicate DMA channel is Active
 *     PCI_PARITY_ERR   Set by CMIC to indicate DMA Resulting in PCI Parity Error
 *     PCI_FATAL_ERR    Set by CMIC to indicate DMA Resulting in PCI Fatal Error
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_DMA_STATr 0x00000104

#define BCM56800_A0_CMIC_DMA_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_DMA_STAT.
 *
 */
typedef union BCM56800_A0_CMIC_DMA_STATr_s {
	uint32_t v[1];
	uint32_t cmic_dma_stat[1];
	uint32_t _cmic_dma_stat;
} BCM56800_A0_CMIC_DMA_STATr_t;

#define BCM56800_A0_CMIC_DMA_STATr_CLR(r) (r).cmic_dma_stat[0] = 0
#define BCM56800_A0_CMIC_DMA_STATr_SET(r,d) (r).cmic_dma_stat[0] = d
#define BCM56800_A0_CMIC_DMA_STATr_GET(r) (r).cmic_dma_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_DMA_STATr_CH0_DMA_ENf_GET(r) (((r).cmic_dma_stat[0]) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH0_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_DMA_STATr_CH1_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH1_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_DMA_STATr_CH2_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH2_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_DMA_STATr_CH3_DMA_ENf_GET(r) ((((r).cmic_dma_stat[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH3_DMA_ENf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 5) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 10) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 11) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_CMIC_DMA_STATr_DMA_RESETf_GET(r) ((((r).cmic_dma_stat[0]) >> 12) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_DMA_RESETf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET(r) ((((r).cmic_dma_stat[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET(r) ((((r).cmic_dma_stat[0]) >> 14) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET(r) ((((r).cmic_dma_stat[0]) >> 15) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_GET(r) ((((r).cmic_dma_stat[0]) >> 16) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 19) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 20) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET(r) ((((r).cmic_dma_stat[0]) >> 21) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 22) & 0x1f)
#define BCM56800_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 22)) | ((((uint32_t)f) & 0x1f) << 22))
#define BCM56800_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_dma_stat[0]) >> 27) & 0x1f)
#define BCM56800_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))
#define BCM56800_A0_CMIC_DMA_STATr_BIT_POSf_GET(r) (((r).cmic_dma_stat[0]) & 0x1f)
#define BCM56800_A0_CMIC_DMA_STATr_BIT_POSf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_DMA_STATr_BIT_VALf_GET(r) ((((r).cmic_dma_stat[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_DMA_STATr_BIT_VALf_SET(r,f) (r).cmic_dma_stat[0]=(((r).cmic_dma_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CMIC_DMA_STAT.
 *
 */
#define BCM56800_A0_READ_CMIC_DMA_STATr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_DMA_STATr,r._cmic_dma_stat)
#define BCM56800_A0_WRITE_CMIC_DMA_STATr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_DMA_STATr,r._cmic_dma_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_DMA_STATr BCM56800_A0_CMIC_DMA_STATr
#define CMIC_DMA_STATr_SIZE BCM56800_A0_CMIC_DMA_STATr_SIZE
typedef BCM56800_A0_CMIC_DMA_STATr_t CMIC_DMA_STATr_t;
#define CMIC_DMA_STATr_CLR BCM56800_A0_CMIC_DMA_STATr_CLR
#define CMIC_DMA_STATr_SET BCM56800_A0_CMIC_DMA_STATr_SET
#define CMIC_DMA_STATr_GET BCM56800_A0_CMIC_DMA_STATr_GET
#define CMIC_DMA_STATr_CH0_DMA_ENf_GET BCM56800_A0_CMIC_DMA_STATr_CH0_DMA_ENf_GET
#define CMIC_DMA_STATr_CH0_DMA_ENf_SET BCM56800_A0_CMIC_DMA_STATr_CH0_DMA_ENf_SET
#define CMIC_DMA_STATr_CH1_DMA_ENf_GET BCM56800_A0_CMIC_DMA_STATr_CH1_DMA_ENf_GET
#define CMIC_DMA_STATr_CH1_DMA_ENf_SET BCM56800_A0_CMIC_DMA_STATr_CH1_DMA_ENf_SET
#define CMIC_DMA_STATr_CH2_DMA_ENf_GET BCM56800_A0_CMIC_DMA_STATr_CH2_DMA_ENf_GET
#define CMIC_DMA_STATr_CH2_DMA_ENf_SET BCM56800_A0_CMIC_DMA_STATr_CH2_DMA_ENf_SET
#define CMIC_DMA_STATr_CH3_DMA_ENf_GET BCM56800_A0_CMIC_DMA_STATr_CH3_DMA_ENf_GET
#define CMIC_DMA_STATr_CH3_DMA_ENf_SET BCM56800_A0_CMIC_DMA_STATr_CH3_DMA_ENf_SET
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_CH0_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_CH1_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_CH2_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_GET
#define CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_CH3_CHAIN_DONEf_SET
#define CMIC_DMA_STATr_CH0_DESC_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH0_DESC_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_CH0_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH1_DESC_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH1_DESC_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_CH1_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH2_DESC_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH2_DESC_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_CH2_DESC_DONEf_SET
#define CMIC_DMA_STATr_CH3_DESC_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_GET
#define CMIC_DMA_STATr_CH3_DESC_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_CH3_DESC_DONEf_SET
#define CMIC_DMA_STATr_DMA_RESETf_GET BCM56800_A0_CMIC_DMA_STATr_DMA_RESETf_GET
#define CMIC_DMA_STATr_DMA_RESETf_SET BCM56800_A0_CMIC_DMA_STATr_DMA_RESETf_SET
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_GET
#define CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_OPN_COMPLETEf_SET
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_GET
#define CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ITER_DONEf_SET
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET BCM56800_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_GET
#define CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET BCM56800_A0_CMIC_DMA_STATr_TX_DMA_ABORT_NEEDS_CLEANUPf_SET
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_GET BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_GET
#define CMIC_DMA_STATr_STATS_DMA_ERRORf_SET BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ERRORf_SET
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET BCM56800_A0_CMIC_DMA_STATr_STATS_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET BCM56800_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET BCM56800_A0_CMIC_DMA_STATr_CH0_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET BCM56800_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET BCM56800_A0_CMIC_DMA_STATr_CH1_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET BCM56800_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET BCM56800_A0_CMIC_DMA_STATr_CH2_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET BCM56800_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_GET
#define CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET BCM56800_A0_CMIC_DMA_STATr_CH3_DMA_ACTIVEf_SET
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_GET BCM56800_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_GET
#define CMIC_DMA_STATr_PCI_PARITY_ERRf_SET BCM56800_A0_CMIC_DMA_STATr_PCI_PARITY_ERRf_SET
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_GET BCM56800_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_GET
#define CMIC_DMA_STATr_PCI_FATAL_ERRf_SET BCM56800_A0_CMIC_DMA_STATr_PCI_FATAL_ERRf_SET
#define CMIC_DMA_STATr_BIT_POSf_GET BCM56800_A0_CMIC_DMA_STATr_BIT_POSf_GET
#define CMIC_DMA_STATr_BIT_POSf_SET BCM56800_A0_CMIC_DMA_STATr_BIT_POSf_SET
#define CMIC_DMA_STATr_BIT_VALf_GET BCM56800_A0_CMIC_DMA_STATr_BIT_VALf_GET
#define CMIC_DMA_STATr_BIT_VALf_SET BCM56800_A0_CMIC_DMA_STATr_BIT_VALf_SET
#define READ_CMIC_DMA_STATr BCM56800_A0_READ_CMIC_DMA_STATr
#define WRITE_CMIC_DMA_STATr BCM56800_A0_WRITE_CMIC_DMA_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_DMA_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_ENDIANESS_SEL
 * BLOCKS:   CMIC
 * DESC:     Endianness selection register (for various CMIC operations)

 * SIZE:     32
 * FIELDS:
 *     BYTELANE0        Each byte lane must carry the same data value,especially the MSB byte and the LSB byte.The various bits in the byte are interpretedas explained below:
 *     BYTELANE1        Byte Lane 1 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE2        Byte Lane 2 (see BYTELANE0)Each byte lane must carry the same data value.
 *     BYTELANE3        Byte Lane 3 (see BYTELANE0)Each byte lane must carry the same data value.
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_ENDIANESS_SELr 0x00000174

#define BCM56800_A0_CMIC_ENDIANESS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_ENDIANESS_SEL.
 *
 */
typedef union BCM56800_A0_CMIC_ENDIANESS_SELr_s {
	uint32_t v[1];
	uint32_t cmic_endianess_sel[1];
	uint32_t _cmic_endianess_sel;
} BCM56800_A0_CMIC_ENDIANESS_SELr_t;

#define BCM56800_A0_CMIC_ENDIANESS_SELr_CLR(r) (r).cmic_endianess_sel[0] = 0
#define BCM56800_A0_CMIC_ENDIANESS_SELr_SET(r,d) (r).cmic_endianess_sel[0] = d
#define BCM56800_A0_CMIC_ENDIANESS_SELr_GET(r) (r).cmic_endianess_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_GET(r) (((r).cmic_endianess_sel[0]) & 0xff)
#define BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_GET(r) ((((r).cmic_endianess_sel[0]) >> 8) & 0xff)
#define BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_GET(r) ((((r).cmic_endianess_sel[0]) >> 16) & 0xff)
#define BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_GET(r) ((((r).cmic_endianess_sel[0]) >> 24) & 0xff)
#define BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_SET(r,f) (r).cmic_endianess_sel[0]=(((r).cmic_endianess_sel[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_ENDIANESS_SEL.
 *
 */
#define BCM56800_A0_READ_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)
#define BCM56800_A0_WRITE_CMIC_ENDIANESS_SELr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_ENDIANESS_SELr,r._cmic_endianess_sel)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_ENDIANESS_SELr BCM56800_A0_CMIC_ENDIANESS_SELr
#define CMIC_ENDIANESS_SELr_SIZE BCM56800_A0_CMIC_ENDIANESS_SELr_SIZE
typedef BCM56800_A0_CMIC_ENDIANESS_SELr_t CMIC_ENDIANESS_SELr_t;
#define CMIC_ENDIANESS_SELr_CLR BCM56800_A0_CMIC_ENDIANESS_SELr_CLR
#define CMIC_ENDIANESS_SELr_SET BCM56800_A0_CMIC_ENDIANESS_SELr_SET
#define CMIC_ENDIANESS_SELr_GET BCM56800_A0_CMIC_ENDIANESS_SELr_GET
#define CMIC_ENDIANESS_SELr_BYTELANE0f_GET BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE0f_SET BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE0f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE1f_GET BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE1f_SET BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE1f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE2f_GET BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE2f_SET BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE2f_SET
#define CMIC_ENDIANESS_SELr_BYTELANE3f_GET BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_GET
#define CMIC_ENDIANESS_SELr_BYTELANE3f_SET BCM56800_A0_CMIC_ENDIANESS_SELr_BYTELANE3f_SET
#define READ_CMIC_ENDIANESS_SELr BCM56800_A0_READ_CMIC_ENDIANESS_SELr
#define WRITE_CMIC_ENDIANESS_SELr BCM56800_A0_WRITE_CMIC_ENDIANESS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_ENDIANESS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_I2C_CTRL
 * BLOCKS:   CMIC
 * DESC:     I2C Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     AAAK             When set (1), asserts an ACKNOWLEDGE clock pulse (SDA LOW) on the I2C bus 
 *     INT_FLAG         When set, indicates an interrupt has occurred due to one of the status conditions 
 *     MM_STP           When set, controls entering the Master mode and send a STOP condition on the bus, when it is free. This bit is automatically cleared after the STOP condition has been sent. 
 *     MM_STRT          When set, controls entering the Master mode and send a START condition on the bus, when it is free. This bit is automatically cleared after the START condition has been sent. 
 *     BUS_EN           When set, Enable I2C bus and respond to calls to the slave address and the General Call Address ability. 
 *     INT_EN           When set, enables generation of interrupts.
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_I2C_CTRLr 0x00000128

#define BCM56800_A0_CMIC_I2C_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_CTRL.
 *
 */
typedef union BCM56800_A0_CMIC_I2C_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_ctrl[1];
	uint32_t _cmic_i2c_ctrl;
} BCM56800_A0_CMIC_I2C_CTRLr_t;

#define BCM56800_A0_CMIC_I2C_CTRLr_CLR(r) (r).cmic_i2c_ctrl[0] = 0
#define BCM56800_A0_CMIC_I2C_CTRLr_SET(r,d) (r).cmic_i2c_ctrl[0] = d
#define BCM56800_A0_CMIC_I2C_CTRLr_GET(r) (r).cmic_i2c_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_I2C_CTRLr_RESERVED_1f_GET(r) (((r).cmic_i2c_ctrl[0]) & 0x3)
#define BCM56800_A0_CMIC_I2C_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_CMIC_I2C_CTRLr_AAAKf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_I2C_CTRLr_AAAKf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_I2C_CTRLr_INT_FLAGf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_I2C_CTRLr_INT_FLAGf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_I2C_CTRLr_MM_STPf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_I2C_CTRLr_MM_STPf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_I2C_CTRLr_MM_STRTf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 5) & 0x1)
#define BCM56800_A0_CMIC_I2C_CTRLr_MM_STRTf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CMIC_I2C_CTRLr_BUS_ENf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_I2C_CTRLr_BUS_ENf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_I2C_CTRLr_INT_ENf_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_I2C_CTRLr_INT_ENf_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_I2C_CTRLr_RESERVED_2f_GET(r) ((((r).cmic_i2c_ctrl[0]) >> 8) & 0xffffff)
#define BCM56800_A0_CMIC_I2C_CTRLr_RESERVED_2f_SET(r,f) (r).cmic_i2c_ctrl[0]=(((r).cmic_i2c_ctrl[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_CTRL.
 *
 */
#define BCM56800_A0_READ_CMIC_I2C_CTRLr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_I2C_CTRLr,r._cmic_i2c_ctrl)
#define BCM56800_A0_WRITE_CMIC_I2C_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_I2C_CTRLr,r._cmic_i2c_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_CTRLr BCM56800_A0_CMIC_I2C_CTRLr
#define CMIC_I2C_CTRLr_SIZE BCM56800_A0_CMIC_I2C_CTRLr_SIZE
typedef BCM56800_A0_CMIC_I2C_CTRLr_t CMIC_I2C_CTRLr_t;
#define CMIC_I2C_CTRLr_CLR BCM56800_A0_CMIC_I2C_CTRLr_CLR
#define CMIC_I2C_CTRLr_SET BCM56800_A0_CMIC_I2C_CTRLr_SET
#define CMIC_I2C_CTRLr_GET BCM56800_A0_CMIC_I2C_CTRLr_GET
#define CMIC_I2C_CTRLr_RESERVED_1f_GET BCM56800_A0_CMIC_I2C_CTRLr_RESERVED_1f_GET
#define CMIC_I2C_CTRLr_RESERVED_1f_SET BCM56800_A0_CMIC_I2C_CTRLr_RESERVED_1f_SET
#define CMIC_I2C_CTRLr_AAAKf_GET BCM56800_A0_CMIC_I2C_CTRLr_AAAKf_GET
#define CMIC_I2C_CTRLr_AAAKf_SET BCM56800_A0_CMIC_I2C_CTRLr_AAAKf_SET
#define CMIC_I2C_CTRLr_INT_FLAGf_GET BCM56800_A0_CMIC_I2C_CTRLr_INT_FLAGf_GET
#define CMIC_I2C_CTRLr_INT_FLAGf_SET BCM56800_A0_CMIC_I2C_CTRLr_INT_FLAGf_SET
#define CMIC_I2C_CTRLr_MM_STPf_GET BCM56800_A0_CMIC_I2C_CTRLr_MM_STPf_GET
#define CMIC_I2C_CTRLr_MM_STPf_SET BCM56800_A0_CMIC_I2C_CTRLr_MM_STPf_SET
#define CMIC_I2C_CTRLr_MM_STRTf_GET BCM56800_A0_CMIC_I2C_CTRLr_MM_STRTf_GET
#define CMIC_I2C_CTRLr_MM_STRTf_SET BCM56800_A0_CMIC_I2C_CTRLr_MM_STRTf_SET
#define CMIC_I2C_CTRLr_BUS_ENf_GET BCM56800_A0_CMIC_I2C_CTRLr_BUS_ENf_GET
#define CMIC_I2C_CTRLr_BUS_ENf_SET BCM56800_A0_CMIC_I2C_CTRLr_BUS_ENf_SET
#define CMIC_I2C_CTRLr_INT_ENf_GET BCM56800_A0_CMIC_I2C_CTRLr_INT_ENf_GET
#define CMIC_I2C_CTRLr_INT_ENf_SET BCM56800_A0_CMIC_I2C_CTRLr_INT_ENf_SET
#define CMIC_I2C_CTRLr_RESERVED_2f_GET BCM56800_A0_CMIC_I2C_CTRLr_RESERVED_2f_GET
#define CMIC_I2C_CTRLr_RESERVED_2f_SET BCM56800_A0_CMIC_I2C_CTRLr_RESERVED_2f_SET
#define READ_CMIC_I2C_CTRLr BCM56800_A0_READ_CMIC_I2C_CTRLr
#define WRITE_CMIC_I2C_CTRLr BCM56800_A0_WRITE_CMIC_I2C_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_I2C_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_I2C_DATA
 * BLOCKS:   CMIC
 * DESC:     I2C Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             Data that is read from or written to the I2C interface.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_I2C_DATAr 0x00000124

#define BCM56800_A0_CMIC_I2C_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_DATA.
 *
 */
typedef union BCM56800_A0_CMIC_I2C_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_data[1];
	uint32_t _cmic_i2c_data;
} BCM56800_A0_CMIC_I2C_DATAr_t;

#define BCM56800_A0_CMIC_I2C_DATAr_CLR(r) (r).cmic_i2c_data[0] = 0
#define BCM56800_A0_CMIC_I2C_DATAr_SET(r,d) (r).cmic_i2c_data[0] = d
#define BCM56800_A0_CMIC_I2C_DATAr_GET(r) (r).cmic_i2c_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_I2C_DATAr_DATAf_GET(r) (((r).cmic_i2c_data[0]) & 0xff)
#define BCM56800_A0_CMIC_I2C_DATAr_DATAf_SET(r,f) (r).cmic_i2c_data[0]=(((r).cmic_i2c_data[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_I2C_DATAr_RESERVED_1f_GET(r) ((((r).cmic_i2c_data[0]) >> 8) & 0xffffff)
#define BCM56800_A0_CMIC_I2C_DATAr_RESERVED_1f_SET(r,f) (r).cmic_i2c_data[0]=(((r).cmic_i2c_data[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_DATA.
 *
 */
#define BCM56800_A0_READ_CMIC_I2C_DATAr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_I2C_DATAr,r._cmic_i2c_data)
#define BCM56800_A0_WRITE_CMIC_I2C_DATAr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_I2C_DATAr,r._cmic_i2c_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_DATAr BCM56800_A0_CMIC_I2C_DATAr
#define CMIC_I2C_DATAr_SIZE BCM56800_A0_CMIC_I2C_DATAr_SIZE
typedef BCM56800_A0_CMIC_I2C_DATAr_t CMIC_I2C_DATAr_t;
#define CMIC_I2C_DATAr_CLR BCM56800_A0_CMIC_I2C_DATAr_CLR
#define CMIC_I2C_DATAr_SET BCM56800_A0_CMIC_I2C_DATAr_SET
#define CMIC_I2C_DATAr_GET BCM56800_A0_CMIC_I2C_DATAr_GET
#define CMIC_I2C_DATAr_DATAf_GET BCM56800_A0_CMIC_I2C_DATAr_DATAf_GET
#define CMIC_I2C_DATAr_DATAf_SET BCM56800_A0_CMIC_I2C_DATAr_DATAf_SET
#define CMIC_I2C_DATAr_RESERVED_1f_GET BCM56800_A0_CMIC_I2C_DATAr_RESERVED_1f_GET
#define CMIC_I2C_DATAr_RESERVED_1f_SET BCM56800_A0_CMIC_I2C_DATAr_RESERVED_1f_SET
#define READ_CMIC_I2C_DATAr BCM56800_A0_READ_CMIC_I2C_DATAr
#define WRITE_CMIC_I2C_DATAr BCM56800_A0_WRITE_CMIC_I2C_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_I2C_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_I2C_RESET
 * BLOCKS:   CMIC
 * DESC:     I2C Soft Reset Register
 * SIZE:     32
 * FIELDS:
 *     RESET            A write operation to this register with any data will perform a soft reset to the I2C interface.  The bus is set to idle state and the MM_STOP, MM_STRT and INT_FLAG in the I2C Status and Control Register are set to 0. 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_I2C_RESETr 0x0000013c

#define BCM56800_A0_CMIC_I2C_RESETr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_RESET.
 *
 */
typedef union BCM56800_A0_CMIC_I2C_RESETr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_reset[1];
	uint32_t _cmic_i2c_reset;
} BCM56800_A0_CMIC_I2C_RESETr_t;

#define BCM56800_A0_CMIC_I2C_RESETr_CLR(r) (r).cmic_i2c_reset[0] = 0
#define BCM56800_A0_CMIC_I2C_RESETr_SET(r,d) (r).cmic_i2c_reset[0] = d
#define BCM56800_A0_CMIC_I2C_RESETr_GET(r) (r).cmic_i2c_reset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_I2C_RESETr_RESETf_GET(r) (((r).cmic_i2c_reset[0]) & 0xff)
#define BCM56800_A0_CMIC_I2C_RESETr_RESETf_SET(r,f) (r).cmic_i2c_reset[0]=(((r).cmic_i2c_reset[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_I2C_RESETr_RESERVED_1f_GET(r) ((((r).cmic_i2c_reset[0]) >> 8) & 0xffffff)
#define BCM56800_A0_CMIC_I2C_RESETr_RESERVED_1f_SET(r,f) (r).cmic_i2c_reset[0]=(((r).cmic_i2c_reset[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_RESET.
 *
 */
#define BCM56800_A0_READ_CMIC_I2C_RESETr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_I2C_RESETr,r._cmic_i2c_reset)
#define BCM56800_A0_WRITE_CMIC_I2C_RESETr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_I2C_RESETr,r._cmic_i2c_reset)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_RESETr BCM56800_A0_CMIC_I2C_RESETr
#define CMIC_I2C_RESETr_SIZE BCM56800_A0_CMIC_I2C_RESETr_SIZE
typedef BCM56800_A0_CMIC_I2C_RESETr_t CMIC_I2C_RESETr_t;
#define CMIC_I2C_RESETr_CLR BCM56800_A0_CMIC_I2C_RESETr_CLR
#define CMIC_I2C_RESETr_SET BCM56800_A0_CMIC_I2C_RESETr_SET
#define CMIC_I2C_RESETr_GET BCM56800_A0_CMIC_I2C_RESETr_GET
#define CMIC_I2C_RESETr_RESETf_GET BCM56800_A0_CMIC_I2C_RESETr_RESETf_GET
#define CMIC_I2C_RESETr_RESETf_SET BCM56800_A0_CMIC_I2C_RESETr_RESETf_SET
#define CMIC_I2C_RESETr_RESERVED_1f_GET BCM56800_A0_CMIC_I2C_RESETr_RESERVED_1f_GET
#define CMIC_I2C_RESETr_RESERVED_1f_SET BCM56800_A0_CMIC_I2C_RESETr_RESERVED_1f_SET
#define READ_CMIC_I2C_RESETr BCM56800_A0_READ_CMIC_I2C_RESETr
#define WRITE_CMIC_I2C_RESETr BCM56800_A0_WRITE_CMIC_I2C_RESETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_I2C_RESETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_I2C_SLAVE_ADDR
 * BLOCKS:   CMIC
 * DESC:     I2C Slave Address Register
 * SIZE:     32
 * FIELDS:
 *     GEN_CALL_EN      Controls recognition of the General Call Address of 00H.0 = Disable General Call Address recognition1 = Enable General Call Address recognition
 *     ADDR             I2C SLAVE Address 6:0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr 0x00000120

#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_SLAVE_ADDR.
 *
 */
typedef union BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_slave_addr[1];
	uint32_t _cmic_i2c_slave_addr;
} BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_t;

#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_CLR(r) (r).cmic_i2c_slave_addr[0] = 0
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_SET(r,d) (r).cmic_i2c_slave_addr[0] = d
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_GET(r) (r).cmic_i2c_slave_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET(r) (((r).cmic_i2c_slave_addr[0]) & 0x1)
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_GET(r) ((((r).cmic_i2c_slave_addr[0]) >> 1) & 0x7f)
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET(r) ((((r).cmic_i2c_slave_addr[0]) >> 8) & 0xffffff)
#define BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET(r,f) (r).cmic_i2c_slave_addr[0]=(((r).cmic_i2c_slave_addr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_SLAVE_ADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_I2C_SLAVE_ADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_I2C_SLAVE_ADDRr,r._cmic_i2c_slave_addr)
#define BCM56800_A0_WRITE_CMIC_I2C_SLAVE_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_I2C_SLAVE_ADDRr,r._cmic_i2c_slave_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_SLAVE_ADDRr BCM56800_A0_CMIC_I2C_SLAVE_ADDRr
#define CMIC_I2C_SLAVE_ADDRr_SIZE BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_SIZE
typedef BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_t CMIC_I2C_SLAVE_ADDRr_t;
#define CMIC_I2C_SLAVE_ADDRr_CLR BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_CLR
#define CMIC_I2C_SLAVE_ADDRr_SET BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_SET
#define CMIC_I2C_SLAVE_ADDRr_GET BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_GET
#define CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_GET
#define CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_GEN_CALL_ENf_SET
#define CMIC_I2C_SLAVE_ADDRr_ADDRf_GET BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_GET
#define CMIC_I2C_SLAVE_ADDRr_ADDRf_SET BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_ADDRf_SET
#define CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_GET
#define CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET BCM56800_A0_CMIC_I2C_SLAVE_ADDRr_RESERVED_1f_SET
#define READ_CMIC_I2C_SLAVE_ADDRr BCM56800_A0_READ_CMIC_I2C_SLAVE_ADDRr
#define WRITE_CMIC_I2C_SLAVE_ADDRr BCM56800_A0_WRITE_CMIC_I2C_SLAVE_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_I2C_SLAVE_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_I2C_SLAVE_XADDR
 * BLOCKS:   CMIC
 * DESC:     I2C Slave Extended Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Slave address 7-0 for the extended slave addressing mode.  When the address received starts with F7-F0H, the two LSBs are recognized as slave address 9-8 and the content of this register are used as address 7-0 to form the 10-bit address used in extended addressing mode. 
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr 0x00000130

#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_SLAVE_XADDR.
 *
 */
typedef union BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_slave_xaddr[1];
	uint32_t _cmic_i2c_slave_xaddr;
} BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_t;

#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_CLR(r) (r).cmic_i2c_slave_xaddr[0] = 0
#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_SET(r,d) (r).cmic_i2c_slave_xaddr[0] = d
#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_GET(r) (r).cmic_i2c_slave_xaddr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_GET(r) (((r).cmic_i2c_slave_xaddr[0]) & 0xff)
#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_SET(r,f) (r).cmic_i2c_slave_xaddr[0]=(((r).cmic_i2c_slave_xaddr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET(r) ((((r).cmic_i2c_slave_xaddr[0]) >> 8) & 0xffffff)
#define BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET(r,f) (r).cmic_i2c_slave_xaddr[0]=(((r).cmic_i2c_slave_xaddr[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_SLAVE_XADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_I2C_SLAVE_XADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_I2C_SLAVE_XADDRr,r._cmic_i2c_slave_xaddr)
#define BCM56800_A0_WRITE_CMIC_I2C_SLAVE_XADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_I2C_SLAVE_XADDRr,r._cmic_i2c_slave_xaddr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_SLAVE_XADDRr BCM56800_A0_CMIC_I2C_SLAVE_XADDRr
#define CMIC_I2C_SLAVE_XADDRr_SIZE BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_SIZE
typedef BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_t CMIC_I2C_SLAVE_XADDRr_t;
#define CMIC_I2C_SLAVE_XADDRr_CLR BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_CLR
#define CMIC_I2C_SLAVE_XADDRr_SET BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_SET
#define CMIC_I2C_SLAVE_XADDRr_GET BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_GET
#define CMIC_I2C_SLAVE_XADDRr_ADDRf_GET BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_GET
#define CMIC_I2C_SLAVE_XADDRr_ADDRf_SET BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_ADDRf_SET
#define CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_GET
#define CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET BCM56800_A0_CMIC_I2C_SLAVE_XADDRr_RESERVED_1f_SET
#define READ_CMIC_I2C_SLAVE_XADDRr BCM56800_A0_READ_CMIC_I2C_SLAVE_XADDRr
#define WRITE_CMIC_I2C_SLAVE_XADDRr BCM56800_A0_WRITE_CMIC_I2C_SLAVE_XADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_I2C_SLAVE_XADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_I2C_STAT
 * BLOCKS:   CMIC
 * DESC:     I2C Condition Status Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     COND             Five bit condition codes defined as follows: I2C Status Register
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_I2C_STATr 0x0000012c

#define BCM56800_A0_CMIC_I2C_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_I2C_STAT.
 *
 */
typedef union BCM56800_A0_CMIC_I2C_STATr_s {
	uint32_t v[1];
	uint32_t cmic_i2c_stat[1];
	uint32_t _cmic_i2c_stat;
} BCM56800_A0_CMIC_I2C_STATr_t;

#define BCM56800_A0_CMIC_I2C_STATr_CLR(r) (r).cmic_i2c_stat[0] = 0
#define BCM56800_A0_CMIC_I2C_STATr_SET(r,d) (r).cmic_i2c_stat[0] = d
#define BCM56800_A0_CMIC_I2C_STATr_GET(r) (r).cmic_i2c_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_I2C_STATr_RESERVED_1f_GET(r) (((r).cmic_i2c_stat[0]) & 0x7)
#define BCM56800_A0_CMIC_I2C_STATr_RESERVED_1f_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_CMIC_I2C_STATr_CONDf_GET(r) ((((r).cmic_i2c_stat[0]) >> 3) & 0x1f)
#define BCM56800_A0_CMIC_I2C_STATr_CONDf_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56800_A0_CMIC_I2C_STATr_RESERVED_2f_GET(r) ((((r).cmic_i2c_stat[0]) >> 8) & 0xffffff)
#define BCM56800_A0_CMIC_I2C_STATr_RESERVED_2f_SET(r,f) (r).cmic_i2c_stat[0]=(((r).cmic_i2c_stat[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access CMIC_I2C_STAT.
 *
 */
#define BCM56800_A0_READ_CMIC_I2C_STATr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_I2C_STATr,r._cmic_i2c_stat)
#define BCM56800_A0_WRITE_CMIC_I2C_STATr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_I2C_STATr,r._cmic_i2c_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_I2C_STATr BCM56800_A0_CMIC_I2C_STATr
#define CMIC_I2C_STATr_SIZE BCM56800_A0_CMIC_I2C_STATr_SIZE
typedef BCM56800_A0_CMIC_I2C_STATr_t CMIC_I2C_STATr_t;
#define CMIC_I2C_STATr_CLR BCM56800_A0_CMIC_I2C_STATr_CLR
#define CMIC_I2C_STATr_SET BCM56800_A0_CMIC_I2C_STATr_SET
#define CMIC_I2C_STATr_GET BCM56800_A0_CMIC_I2C_STATr_GET
#define CMIC_I2C_STATr_RESERVED_1f_GET BCM56800_A0_CMIC_I2C_STATr_RESERVED_1f_GET
#define CMIC_I2C_STATr_RESERVED_1f_SET BCM56800_A0_CMIC_I2C_STATr_RESERVED_1f_SET
#define CMIC_I2C_STATr_CONDf_GET BCM56800_A0_CMIC_I2C_STATr_CONDf_GET
#define CMIC_I2C_STATr_CONDf_SET BCM56800_A0_CMIC_I2C_STATr_CONDf_SET
#define CMIC_I2C_STATr_RESERVED_2f_GET BCM56800_A0_CMIC_I2C_STATr_RESERVED_2f_GET
#define CMIC_I2C_STATr_RESERVED_2f_SET BCM56800_A0_CMIC_I2C_STATr_RESERVED_2f_SET
#define READ_CMIC_I2C_STATr BCM56800_A0_READ_CMIC_I2C_STATr
#define WRITE_CMIC_I2C_STATr BCM56800_A0_WRITE_CMIC_I2C_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_I2C_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_IRQ_MASK
 * BLOCKS:   CMIC
 * DESC:     Interrupt Mask Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Mask
 *     RESERVED_1       Reserved
 *     LINK_STAT_MOD    Link Status Change Mask
 *     IP_INTR          L2 MOD Fifo is full
 *     EP_INTR          Reserved
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Mask
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Mask
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Mask
 *     CH1_CHAIN_DONE   DMA CH1 ENd Of Chain Mask
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Mask
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Mask
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Mask
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Mask
 *     PCI_PARITY_ERR   PCI Bus Parity Error Mask
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Mask
 *     SCHAN_ERR        SCH Bus Error Mask
 *     I2C_INTR         I2C Mask
 *     MIIM_OP_DONE     MIIM Operation Complete Mask
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Mask
 *     RESERVED_3       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed
 *     TABLE_DMA_COMPLETE Table DMA operation complete Mask
 *     SLAM_DMA_COMPLETE Slam DMA operation complete Mask
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_IRQ_MASKr 0x00000148

#define BCM56800_A0_CMIC_IRQ_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_MASK.
 *
 */
typedef union BCM56800_A0_CMIC_IRQ_MASKr_s {
	uint32_t v[1];
	uint32_t cmic_irq_mask[1];
	uint32_t _cmic_irq_mask;
} BCM56800_A0_CMIC_IRQ_MASKr_t;

#define BCM56800_A0_CMIC_IRQ_MASKr_CLR(r) (r).cmic_irq_mask[0] = 0
#define BCM56800_A0_CMIC_IRQ_MASKr_SET(r,d) (r).cmic_irq_mask[0] = d
#define BCM56800_A0_CMIC_IRQ_MASKr_GET(r) (r).cmic_irq_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_mask[0]) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_IRQ_MASKr_RESERVED_1f_GET(r) ((((r).cmic_irq_mask[0]) >> 1) & 0x7)
#define BCM56800_A0_CMIC_IRQ_MASKr_RESERVED_1f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56800_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_mask[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_IRQ_MASKr_IP_INTRf_GET(r) ((((r).cmic_irq_mask[0]) >> 5) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_IP_INTRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CMIC_IRQ_MASKr_EP_INTRf_GET(r) ((((r).cmic_irq_mask[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_EP_INTRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 10) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 11) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 12) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 14) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 15) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 16) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_mask[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_IRQ_MASKr_I2C_INTRf_GET(r) ((((r).cmic_irq_mask[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_I2C_INTRf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 19) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 20) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CMIC_IRQ_MASKr_RESERVED_3f_GET(r) ((((r).cmic_irq_mask[0]) >> 21) & 0xf)
#define BCM56800_A0_CMIC_IRQ_MASKr_RESERVED_3f_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56800_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 25) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 26) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_IRQ_MASKr_MEM_FAILf_GET(r) ((((r).cmic_irq_mask[0]) >> 28) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_MEM_FAILf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 29) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_mask[0]) >> 30) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_mask[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_mask[0]=(((r).cmic_irq_mask[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_MASK.
 *
 */
#define BCM56800_A0_READ_CMIC_IRQ_MASKr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_IRQ_MASKr,r._cmic_irq_mask)
#define BCM56800_A0_WRITE_CMIC_IRQ_MASKr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_IRQ_MASKr,r._cmic_irq_mask)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_IRQ_MASKr BCM56800_A0_CMIC_IRQ_MASKr
#define CMIC_IRQ_MASKr_SIZE BCM56800_A0_CMIC_IRQ_MASKr_SIZE
typedef BCM56800_A0_CMIC_IRQ_MASKr_t CMIC_IRQ_MASKr_t;
#define CMIC_IRQ_MASKr_CLR BCM56800_A0_CMIC_IRQ_MASKr_CLR
#define CMIC_IRQ_MASKr_SET BCM56800_A0_CMIC_IRQ_MASKr_SET
#define CMIC_IRQ_MASKr_GET BCM56800_A0_CMIC_IRQ_MASKr_GET
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_GET
#define CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_SCH_MSG_DONEf_SET
#define CMIC_IRQ_MASKr_RESERVED_1f_GET BCM56800_A0_CMIC_IRQ_MASKr_RESERVED_1f_GET
#define CMIC_IRQ_MASKr_RESERVED_1f_SET BCM56800_A0_CMIC_IRQ_MASKr_RESERVED_1f_SET
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_GET BCM56800_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_GET
#define CMIC_IRQ_MASKr_LINK_STAT_MODf_SET BCM56800_A0_CMIC_IRQ_MASKr_LINK_STAT_MODf_SET
#define CMIC_IRQ_MASKr_IP_INTRf_GET BCM56800_A0_CMIC_IRQ_MASKr_IP_INTRf_GET
#define CMIC_IRQ_MASKr_IP_INTRf_SET BCM56800_A0_CMIC_IRQ_MASKr_IP_INTRf_SET
#define CMIC_IRQ_MASKr_EP_INTRf_GET BCM56800_A0_CMIC_IRQ_MASKr_EP_INTRf_GET
#define CMIC_IRQ_MASKr_EP_INTRf_SET BCM56800_A0_CMIC_IRQ_MASKr_EP_INTRf_SET
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CH0_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CH0_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CH1_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CH1_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CH2_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CH2_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_GET
#define CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CH3_DESC_DONEf_SET
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_GET
#define CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CH3_CHAIN_DONEf_SET
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET BCM56800_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_GET
#define CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET BCM56800_A0_CMIC_IRQ_MASKr_PCI_PARITY_ERRf_SET
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET BCM56800_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_GET
#define CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET BCM56800_A0_CMIC_IRQ_MASKr_PCI_FATAL_ERRf_SET
#define CMIC_IRQ_MASKr_SCHAN_ERRf_GET BCM56800_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_GET
#define CMIC_IRQ_MASKr_SCHAN_ERRf_SET BCM56800_A0_CMIC_IRQ_MASKr_SCHAN_ERRf_SET
#define CMIC_IRQ_MASKr_I2C_INTRf_GET BCM56800_A0_CMIC_IRQ_MASKr_I2C_INTRf_GET
#define CMIC_IRQ_MASKr_I2C_INTRf_SET BCM56800_A0_CMIC_IRQ_MASKr_I2C_INTRf_SET
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_GET
#define CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_MIIM_OP_DONEf_SET
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_GET
#define CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_STAT_DMA_DONEf_SET
#define CMIC_IRQ_MASKr_RESERVED_3f_GET BCM56800_A0_CMIC_IRQ_MASKr_RESERVED_3f_GET
#define CMIC_IRQ_MASKr_RESERVED_3f_SET BCM56800_A0_CMIC_IRQ_MASKr_RESERVED_3f_SET
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_BSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_CSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_HSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_MASKr_MEM_FAILf_GET BCM56800_A0_CMIC_IRQ_MASKr_MEM_FAILf_GET
#define CMIC_IRQ_MASKr_MEM_FAILf_SET BCM56800_A0_CMIC_IRQ_MASKr_MEM_FAILf_SET
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET BCM56800_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_GET
#define CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET BCM56800_A0_CMIC_IRQ_MASKr_TABLE_DMA_COMPLETEf_SET
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET BCM56800_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_GET
#define CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET BCM56800_A0_CMIC_IRQ_MASKr_SLAM_DMA_COMPLETEf_SET
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET BCM56800_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_GET
#define CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET BCM56800_A0_CMIC_IRQ_MASKr_BSAFE_OP_DONEf_SET
#define READ_CMIC_IRQ_MASKr BCM56800_A0_READ_CMIC_IRQ_MASKr
#define WRITE_CMIC_IRQ_MASKr BCM56800_A0_WRITE_CMIC_IRQ_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_IRQ_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_IRQ_STAT
 * BLOCKS:   CMIC
 * DESC:     Interrupt Status Register
 * SIZE:     32
 * FIELDS:
 *     SCH_MSG_DONE     SCH Message Operation Complete Interrupt
 *     RESERVED_1       Reserved
 *     LINK_STAT_MOD    Link Status Change Interrupt
 *     IP_INTR          Interrupt from Ingress Pipe
 *     EP_INTR          Interrupt from Egress Pipe
 *     CH0_DESC_DONE    DMA CH0 Next Descriptor Execution Complete Interrupt
 *     CH0_CHAIN_DONE   DMA CH0 End Of Chain Interrupt
 *     CH1_DESC_DONE    DMA CH1 Next Descriptor Execution Complete Interrupt
 *     CH1_CHAIN_DONE   DMA CH1 End Of Chain Interrupt
 *     CH2_DESC_DONE    DMA CH2 Next Descriptor Execution Complete Interrupt
 *     CH2_CHAIN_DONE   DMA CH2 End Of Chain Interrupt
 *     CH3_DESC_DONE    DMA CH3 Next Descriptor Execution Complete Interrupt
 *     CH3_CHAIN_DONE   DMA CH3 End Of Chain Interrupt
 *     PCI_PARITY_ERR   PCI Bus Parity Error Interrupt
 *     PCI_FATAL_ERR    PCI Bus Fatal Error Interrupt
 *     SCHAN_ERR        SCH Bus Error Interrupt
 *     I2C_INTR         I2C Interrupt
 *     MIIM_OP_DONE     MIIM Operation Complete Interrupt
 *     STAT_DMA_DONE    Stats DMA Iteration Complete Interrupt
 *     RESERVED_2       Reserved
 *     BSE_CMDMEM_DONE  BSE CMDMEM DONE
 *     CSE_CMDMEM_DONE  CSE CMDMEM DONE
 *     HSE_CMDMEM_DONE  HSE CMDMEM DONE
 *     MEM_FAIL         MMU Memory Failed
 *     TABLE_DMA_COMPLETE Table DMA operation complete
 *     SLAM_DMA_COMPLETE Slam DMA operation complete
 *     BSAFE_OP_DONE    Broadsafe operation complete
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_IRQ_STATr 0x00000144

#define BCM56800_A0_CMIC_IRQ_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_IRQ_STAT.
 *
 */
typedef union BCM56800_A0_CMIC_IRQ_STATr_s {
	uint32_t v[1];
	uint32_t cmic_irq_stat[1];
	uint32_t _cmic_irq_stat;
} BCM56800_A0_CMIC_IRQ_STATr_t;

#define BCM56800_A0_CMIC_IRQ_STATr_CLR(r) (r).cmic_irq_stat[0] = 0
#define BCM56800_A0_CMIC_IRQ_STATr_SET(r,d) (r).cmic_irq_stat[0] = d
#define BCM56800_A0_CMIC_IRQ_STATr_GET(r) (r).cmic_irq_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_GET(r) (((r).cmic_irq_stat[0]) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_IRQ_STATr_RESERVED_1f_GET(r) ((((r).cmic_irq_stat[0]) >> 1) & 0x7)
#define BCM56800_A0_CMIC_IRQ_STATr_RESERVED_1f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56800_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_GET(r) ((((r).cmic_irq_stat[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_IRQ_STATr_IP_INTRf_GET(r) ((((r).cmic_irq_stat[0]) >> 5) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_IP_INTRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CMIC_IRQ_STATr_EP_INTRf_GET(r) ((((r).cmic_irq_stat[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_EP_INTRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 10) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 11) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 12) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 14) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 15) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 16) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CMIC_IRQ_STATr_SCHAN_ERRf_GET(r) ((((r).cmic_irq_stat[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_SCHAN_ERRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_IRQ_STATr_I2C_INTRf_GET(r) ((((r).cmic_irq_stat[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_I2C_INTRf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 19) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 20) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CMIC_IRQ_STATr_RESERVED_2f_GET(r) ((((r).cmic_irq_stat[0]) >> 21) & 0xf)
#define BCM56800_A0_CMIC_IRQ_STATr_RESERVED_2f_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56800_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 25) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 26) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_IRQ_STATr_MEM_FAILf_GET(r) ((((r).cmic_irq_stat[0]) >> 28) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_MEM_FAILf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 29) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET(r) ((((r).cmic_irq_stat[0]) >> 30) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET(r) ((((r).cmic_irq_stat[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET(r,f) (r).cmic_irq_stat[0]=(((r).cmic_irq_stat[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_IRQ_STAT.
 *
 */
#define BCM56800_A0_READ_CMIC_IRQ_STATr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_IRQ_STATr,r._cmic_irq_stat)
#define BCM56800_A0_WRITE_CMIC_IRQ_STATr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_IRQ_STATr,r._cmic_irq_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_IRQ_STATr BCM56800_A0_CMIC_IRQ_STATr
#define CMIC_IRQ_STATr_SIZE BCM56800_A0_CMIC_IRQ_STATr_SIZE
typedef BCM56800_A0_CMIC_IRQ_STATr_t CMIC_IRQ_STATr_t;
#define CMIC_IRQ_STATr_CLR BCM56800_A0_CMIC_IRQ_STATr_CLR
#define CMIC_IRQ_STATr_SET BCM56800_A0_CMIC_IRQ_STATr_SET
#define CMIC_IRQ_STATr_GET BCM56800_A0_CMIC_IRQ_STATr_GET
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_GET
#define CMIC_IRQ_STATr_SCH_MSG_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_SCH_MSG_DONEf_SET
#define CMIC_IRQ_STATr_RESERVED_1f_GET BCM56800_A0_CMIC_IRQ_STATr_RESERVED_1f_GET
#define CMIC_IRQ_STATr_RESERVED_1f_SET BCM56800_A0_CMIC_IRQ_STATr_RESERVED_1f_SET
#define CMIC_IRQ_STATr_LINK_STAT_MODf_GET BCM56800_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_GET
#define CMIC_IRQ_STATr_LINK_STAT_MODf_SET BCM56800_A0_CMIC_IRQ_STATr_LINK_STAT_MODf_SET
#define CMIC_IRQ_STATr_IP_INTRf_GET BCM56800_A0_CMIC_IRQ_STATr_IP_INTRf_GET
#define CMIC_IRQ_STATr_IP_INTRf_SET BCM56800_A0_CMIC_IRQ_STATr_IP_INTRf_SET
#define CMIC_IRQ_STATr_EP_INTRf_GET BCM56800_A0_CMIC_IRQ_STATr_EP_INTRf_GET
#define CMIC_IRQ_STATr_EP_INTRf_SET BCM56800_A0_CMIC_IRQ_STATr_EP_INTRf_SET
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH0_DESC_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CH0_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CH0_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH1_DESC_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CH1_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CH1_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH2_DESC_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CH2_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CH2_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_GET
#define CMIC_IRQ_STATr_CH3_DESC_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CH3_DESC_DONEf_SET
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_GET
#define CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CH3_CHAIN_DONEf_SET
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET BCM56800_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_GET
#define CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET BCM56800_A0_CMIC_IRQ_STATr_PCI_PARITY_ERRf_SET
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET BCM56800_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_GET
#define CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET BCM56800_A0_CMIC_IRQ_STATr_PCI_FATAL_ERRf_SET
#define CMIC_IRQ_STATr_SCHAN_ERRf_GET BCM56800_A0_CMIC_IRQ_STATr_SCHAN_ERRf_GET
#define CMIC_IRQ_STATr_SCHAN_ERRf_SET BCM56800_A0_CMIC_IRQ_STATr_SCHAN_ERRf_SET
#define CMIC_IRQ_STATr_I2C_INTRf_GET BCM56800_A0_CMIC_IRQ_STATr_I2C_INTRf_GET
#define CMIC_IRQ_STATr_I2C_INTRf_SET BCM56800_A0_CMIC_IRQ_STATr_I2C_INTRf_SET
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_GET
#define CMIC_IRQ_STATr_MIIM_OP_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_MIIM_OP_DONEf_SET
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_GET
#define CMIC_IRQ_STATr_STAT_DMA_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_STAT_DMA_DONEf_SET
#define CMIC_IRQ_STATr_RESERVED_2f_GET BCM56800_A0_CMIC_IRQ_STATr_RESERVED_2f_GET
#define CMIC_IRQ_STATr_RESERVED_2f_SET BCM56800_A0_CMIC_IRQ_STATr_RESERVED_2f_SET
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_BSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_CSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_GET
#define CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_HSE_CMDMEM_DONEf_SET
#define CMIC_IRQ_STATr_MEM_FAILf_GET BCM56800_A0_CMIC_IRQ_STATr_MEM_FAILf_GET
#define CMIC_IRQ_STATr_MEM_FAILf_SET BCM56800_A0_CMIC_IRQ_STATr_MEM_FAILf_SET
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET BCM56800_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_GET
#define CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET BCM56800_A0_CMIC_IRQ_STATr_TABLE_DMA_COMPLETEf_SET
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET BCM56800_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_GET
#define CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET BCM56800_A0_CMIC_IRQ_STATr_SLAM_DMA_COMPLETEf_SET
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET BCM56800_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_GET
#define CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET BCM56800_A0_CMIC_IRQ_STATr_BSAFE_OP_DONEf_SET
#define READ_CMIC_IRQ_STATr BCM56800_A0_READ_CMIC_IRQ_STATr
#define WRITE_CMIC_IRQ_STATr BCM56800_A0_WRITE_CMIC_IRQ_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_IRQ_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_LEDUP_CTRL
 * BLOCKS:   CMIC
 * DESC:     LEDUP Control
 * SIZE:     32
 * FIELDS:
 *     LEDUP_EN         LEDUP Enable
 *     LEDUP_SKIP_SCAN_OUT If set, skip Data Scan-out step
 *     LEDUP_SKIP_PROCESSOR If set, skip LED Processor run
 *     LEDUP_SKIP_SCAN_IN If set, skip MAC Data Scan-in step
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_LEDUP_CTRLr 0x00001000

#define BCM56800_A0_CMIC_LEDUP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_CTRL.
 *
 */
typedef union BCM56800_A0_CMIC_LEDUP_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_ctrl[1];
	uint32_t _cmic_ledup_ctrl;
} BCM56800_A0_CMIC_LEDUP_CTRLr_t;

#define BCM56800_A0_CMIC_LEDUP_CTRLr_CLR(r) (r).cmic_ledup_ctrl[0] = 0
#define BCM56800_A0_CMIC_LEDUP_CTRLr_SET(r,d) (r).cmic_ledup_ctrl[0] = d
#define BCM56800_A0_CMIC_LEDUP_CTRLr_GET(r) (r).cmic_ledup_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_GET(r) (((r).cmic_ledup_ctrl[0]) & 0x1)
#define BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET(r) ((((r).cmic_ledup_ctrl[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET(r,f) (r).cmic_ledup_ctrl[0]=(((r).cmic_ledup_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access CMIC_LEDUP_CTRL.
 *
 */
#define BCM56800_A0_READ_CMIC_LEDUP_CTRLr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_LEDUP_CTRLr,r._cmic_ledup_ctrl)
#define BCM56800_A0_WRITE_CMIC_LEDUP_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_LEDUP_CTRLr,r._cmic_ledup_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_CTRLr BCM56800_A0_CMIC_LEDUP_CTRLr
#define CMIC_LEDUP_CTRLr_SIZE BCM56800_A0_CMIC_LEDUP_CTRLr_SIZE
typedef BCM56800_A0_CMIC_LEDUP_CTRLr_t CMIC_LEDUP_CTRLr_t;
#define CMIC_LEDUP_CTRLr_CLR BCM56800_A0_CMIC_LEDUP_CTRLr_CLR
#define CMIC_LEDUP_CTRLr_SET BCM56800_A0_CMIC_LEDUP_CTRLr_SET
#define CMIC_LEDUP_CTRLr_GET BCM56800_A0_CMIC_LEDUP_CTRLr_GET
#define CMIC_LEDUP_CTRLr_LEDUP_ENf_GET BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_ENf_SET BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_ENf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_OUTf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_PROCESSORf_SET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_GET
#define CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET BCM56800_A0_CMIC_LEDUP_CTRLr_LEDUP_SKIP_SCAN_INf_SET
#define READ_CMIC_LEDUP_CTRLr BCM56800_A0_READ_CMIC_LEDUP_CTRLr
#define WRITE_CMIC_LEDUP_CTRLr BCM56800_A0_WRITE_CMIC_LEDUP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_LEDUP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_LEDUP_DATA_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP Data RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP DATA RAM data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_LEDUP_DATA_RAMr 0x00001c00

#define BCM56800_A0_CMIC_LEDUP_DATA_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_DATA_RAM.
 *
 */
typedef union BCM56800_A0_CMIC_LEDUP_DATA_RAMr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_data_ram[1];
	uint32_t _cmic_ledup_data_ram;
} BCM56800_A0_CMIC_LEDUP_DATA_RAMr_t;

#define BCM56800_A0_CMIC_LEDUP_DATA_RAMr_CLR(r) (r).cmic_ledup_data_ram[0] = 0
#define BCM56800_A0_CMIC_LEDUP_DATA_RAMr_SET(r,d) (r).cmic_ledup_data_ram[0] = d
#define BCM56800_A0_CMIC_LEDUP_DATA_RAMr_GET(r) (r).cmic_ledup_data_ram[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_LEDUP_DATA_RAMr_DATAf_GET(r) (((r).cmic_ledup_data_ram[0]) & 0xff)
#define BCM56800_A0_CMIC_LEDUP_DATA_RAMr_DATAf_SET(r,f) (r).cmic_ledup_data_ram[0]=(((r).cmic_ledup_data_ram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP_DATA_RAM.
 *
 */
#define BCM56800_A0_READ_CMIC_LEDUP_DATA_RAMr(u,i,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_LEDUP_DATA_RAMr+(4*(i)),r._cmic_ledup_data_ram)
#define BCM56800_A0_WRITE_CMIC_LEDUP_DATA_RAMr(u,i,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_LEDUP_DATA_RAMr+(4*(i)),r._cmic_ledup_data_ram)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_DATA_RAMr BCM56800_A0_CMIC_LEDUP_DATA_RAMr
#define CMIC_LEDUP_DATA_RAMr_SIZE BCM56800_A0_CMIC_LEDUP_DATA_RAMr_SIZE
typedef BCM56800_A0_CMIC_LEDUP_DATA_RAMr_t CMIC_LEDUP_DATA_RAMr_t;
#define CMIC_LEDUP_DATA_RAMr_CLR BCM56800_A0_CMIC_LEDUP_DATA_RAMr_CLR
#define CMIC_LEDUP_DATA_RAMr_SET BCM56800_A0_CMIC_LEDUP_DATA_RAMr_SET
#define CMIC_LEDUP_DATA_RAMr_GET BCM56800_A0_CMIC_LEDUP_DATA_RAMr_GET
#define CMIC_LEDUP_DATA_RAMr_DATAf_GET BCM56800_A0_CMIC_LEDUP_DATA_RAMr_DATAf_GET
#define CMIC_LEDUP_DATA_RAMr_DATAf_SET BCM56800_A0_CMIC_LEDUP_DATA_RAMr_DATAf_SET
#define READ_CMIC_LEDUP_DATA_RAMr BCM56800_A0_READ_CMIC_LEDUP_DATA_RAMr
#define WRITE_CMIC_LEDUP_DATA_RAMr BCM56800_A0_WRITE_CMIC_LEDUP_DATA_RAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_LEDUP_DATA_RAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_LEDUP_PROGRAM_RAM
 * BLOCKS:   CMIC
 * DESC:     LEDUP Program RAM
 * SIZE:     32
 * FIELDS:
 *     DATA             LEDUP PROGRAM RAM data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr 0x00001800

#define BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_PROGRAM_RAM.
 *
 */
typedef union BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_program_ram[1];
	uint32_t _cmic_ledup_program_ram;
} BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_t;

#define BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_CLR(r) (r).cmic_ledup_program_ram[0] = 0
#define BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_SET(r,d) (r).cmic_ledup_program_ram[0] = d
#define BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_GET(r) (r).cmic_ledup_program_ram[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET(r) (((r).cmic_ledup_program_ram[0]) & 0xff)
#define BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET(r,f) (r).cmic_ledup_program_ram[0]=(((r).cmic_ledup_program_ram[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CMIC_LEDUP_PROGRAM_RAM.
 *
 */
#define BCM56800_A0_READ_CMIC_LEDUP_PROGRAM_RAMr(u,i,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr+(4*(i)),r._cmic_ledup_program_ram)
#define BCM56800_A0_WRITE_CMIC_LEDUP_PROGRAM_RAMr(u,i,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr+(4*(i)),r._cmic_ledup_program_ram)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_PROGRAM_RAMr BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr
#define CMIC_LEDUP_PROGRAM_RAMr_SIZE BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_SIZE
typedef BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_t CMIC_LEDUP_PROGRAM_RAMr_t;
#define CMIC_LEDUP_PROGRAM_RAMr_CLR BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_CLR
#define CMIC_LEDUP_PROGRAM_RAMr_SET BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_SET
#define CMIC_LEDUP_PROGRAM_RAMr_GET BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_GET
#define CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_GET
#define CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr_DATAf_SET
#define READ_CMIC_LEDUP_PROGRAM_RAMr BCM56800_A0_READ_CMIC_LEDUP_PROGRAM_RAMr
#define WRITE_CMIC_LEDUP_PROGRAM_RAMr BCM56800_A0_WRITE_CMIC_LEDUP_PROGRAM_RAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_LEDUP_PROGRAM_RAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_LEDUP_STATUS
 * BLOCKS:   CMIC
 * DESC:     LEDUP Status
 * SIZE:     32
 * FIELDS:
 *     PROGRAM_COUNTER  LEDUP Program Counter
 *     LEDUP_RUNNING    LEDUP Running
 *     LEDUP_INITIALISING LEDUP Initialising
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_LEDUP_STATUSr 0x00001004

#define BCM56800_A0_CMIC_LEDUP_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LEDUP_STATUS.
 *
 */
typedef union BCM56800_A0_CMIC_LEDUP_STATUSr_s {
	uint32_t v[1];
	uint32_t cmic_ledup_status[1];
	uint32_t _cmic_ledup_status;
} BCM56800_A0_CMIC_LEDUP_STATUSr_t;

#define BCM56800_A0_CMIC_LEDUP_STATUSr_CLR(r) (r).cmic_ledup_status[0] = 0
#define BCM56800_A0_CMIC_LEDUP_STATUSr_SET(r,d) (r).cmic_ledup_status[0] = d
#define BCM56800_A0_CMIC_LEDUP_STATUSr_GET(r) (r).cmic_ledup_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET(r) (((r).cmic_ledup_status[0]) & 0xff)
#define BCM56800_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET(r) ((((r).cmic_ledup_status[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET(r) ((((r).cmic_ledup_status[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET(r,f) (r).cmic_ledup_status[0]=(((r).cmic_ledup_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access CMIC_LEDUP_STATUS.
 *
 */
#define BCM56800_A0_READ_CMIC_LEDUP_STATUSr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_LEDUP_STATUSr,r._cmic_ledup_status)
#define BCM56800_A0_WRITE_CMIC_LEDUP_STATUSr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_LEDUP_STATUSr,r._cmic_ledup_status)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LEDUP_STATUSr BCM56800_A0_CMIC_LEDUP_STATUSr
#define CMIC_LEDUP_STATUSr_SIZE BCM56800_A0_CMIC_LEDUP_STATUSr_SIZE
typedef BCM56800_A0_CMIC_LEDUP_STATUSr_t CMIC_LEDUP_STATUSr_t;
#define CMIC_LEDUP_STATUSr_CLR BCM56800_A0_CMIC_LEDUP_STATUSr_CLR
#define CMIC_LEDUP_STATUSr_SET BCM56800_A0_CMIC_LEDUP_STATUSr_SET
#define CMIC_LEDUP_STATUSr_GET BCM56800_A0_CMIC_LEDUP_STATUSr_GET
#define CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET BCM56800_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_GET
#define CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET BCM56800_A0_CMIC_LEDUP_STATUSr_PROGRAM_COUNTERf_SET
#define CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET BCM56800_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_GET
#define CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET BCM56800_A0_CMIC_LEDUP_STATUSr_LEDUP_RUNNINGf_SET
#define CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET BCM56800_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_GET
#define CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET BCM56800_A0_CMIC_LEDUP_STATUSr_LEDUP_INITIALISINGf_SET
#define READ_CMIC_LEDUP_STATUSr BCM56800_A0_READ_CMIC_LEDUP_STATUSr
#define WRITE_CMIC_LEDUP_STATUSr BCM56800_A0_WRITE_CMIC_LEDUP_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_LEDUP_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_LINK_STAT
 * BLOCKS:   CMIC
 * DESC:     Link Status Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link Up / Down Register
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_LINK_STATr 0x00000140

#define BCM56800_A0_CMIC_LINK_STATr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_LINK_STAT.
 *
 */
typedef union BCM56800_A0_CMIC_LINK_STATr_s {
	uint32_t v[1];
	uint32_t cmic_link_stat[1];
	uint32_t _cmic_link_stat;
} BCM56800_A0_CMIC_LINK_STATr_t;

#define BCM56800_A0_CMIC_LINK_STATr_CLR(r) (r).cmic_link_stat[0] = 0
#define BCM56800_A0_CMIC_LINK_STATr_SET(r,d) (r).cmic_link_stat[0] = d
#define BCM56800_A0_CMIC_LINK_STATr_GET(r) (r).cmic_link_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_LINK_STATr_PORT_BITMAPf_GET(r) ((r).cmic_link_stat[0])
#define BCM56800_A0_CMIC_LINK_STATr_PORT_BITMAPf_SET(r,f) (r).cmic_link_stat[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_LINK_STAT.
 *
 */
#define BCM56800_A0_READ_CMIC_LINK_STATr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_LINK_STATr,r._cmic_link_stat)
#define BCM56800_A0_WRITE_CMIC_LINK_STATr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_LINK_STATr,r._cmic_link_stat)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_LINK_STATr BCM56800_A0_CMIC_LINK_STATr
#define CMIC_LINK_STATr_SIZE BCM56800_A0_CMIC_LINK_STATr_SIZE
typedef BCM56800_A0_CMIC_LINK_STATr_t CMIC_LINK_STATr_t;
#define CMIC_LINK_STATr_CLR BCM56800_A0_CMIC_LINK_STATr_CLR
#define CMIC_LINK_STATr_SET BCM56800_A0_CMIC_LINK_STATr_SET
#define CMIC_LINK_STATr_GET BCM56800_A0_CMIC_LINK_STATr_GET
#define CMIC_LINK_STATr_PORT_BITMAPf_GET BCM56800_A0_CMIC_LINK_STATr_PORT_BITMAPf_GET
#define CMIC_LINK_STATr_PORT_BITMAPf_SET BCM56800_A0_CMIC_LINK_STATr_PORT_BITMAPf_SET
#define READ_CMIC_LINK_STATr BCM56800_A0_READ_CMIC_LINK_STATr
#define WRITE_CMIC_LINK_STATr BCM56800_A0_WRITE_CMIC_LINK_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_LINK_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_ADDRESS
 * BLOCKS:   CMIC
 * DESC:     Supplies the register address of MIIM reads and writes.
For clause 22 devices, bits [4:0] supply the REGAD.
For clause 45 devices, bits [20:16] supply the DTYPE,
                   and bits [15: 0] supply the reg address

 * SIZE:     32
 * FIELDS:
 *     CLAUSE_22_REGADR Register address for associated read or write
 *     RESERVED_1       Reserved
 *     CLAUSE_45_REGADR Register address for associated read or write
 *     CLAUSE_45_DTYPE  Block-within-PHY address for associated read or write
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_ADDRESSr 0x000004a0

#define BCM56800_A0_CMIC_MIIM_ADDRESSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_ADDRESS.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_ADDRESSr_s {
	uint32_t v[1];
	uint32_t cmic_miim_address[1];
	uint32_t _cmic_miim_address;
} BCM56800_A0_CMIC_MIIM_ADDRESSr_t;

#define BCM56800_A0_CMIC_MIIM_ADDRESSr_CLR(r) (r).cmic_miim_address[0] = 0
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_SET(r,d) (r).cmic_miim_address[0] = d
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_GET(r) (r).cmic_miim_address[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET(r) (((r).cmic_miim_address[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_GET(r) ((((r).cmic_miim_address[0]) >> 21) & 0x7ff)
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET(r) (((r).cmic_miim_address[0]) & 0xffff)
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET(r) ((((r).cmic_miim_address[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET(r,f) (r).cmic_miim_address[0]=(((r).cmic_miim_address[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))

/*
 * These macros can be used to access CMIC_MIIM_ADDRESS.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_ADDRESSr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_ADDRESSr,r._cmic_miim_address)
#define BCM56800_A0_WRITE_CMIC_MIIM_ADDRESSr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_ADDRESSr,r._cmic_miim_address)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_ADDRESSr BCM56800_A0_CMIC_MIIM_ADDRESSr
#define CMIC_MIIM_ADDRESSr_SIZE BCM56800_A0_CMIC_MIIM_ADDRESSr_SIZE
typedef BCM56800_A0_CMIC_MIIM_ADDRESSr_t CMIC_MIIM_ADDRESSr_t;
#define CMIC_MIIM_ADDRESSr_CLR BCM56800_A0_CMIC_MIIM_ADDRESSr_CLR
#define CMIC_MIIM_ADDRESSr_SET BCM56800_A0_CMIC_MIIM_ADDRESSr_SET
#define CMIC_MIIM_ADDRESSr_GET BCM56800_A0_CMIC_MIIM_ADDRESSr_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_22_REGADRf_SET
#define CMIC_MIIM_ADDRESSr_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_GET
#define CMIC_MIIM_ADDRESSr_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_ADDRESSr_RESERVED_1f_SET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_REGADRf_SET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_GET
#define CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET BCM56800_A0_CMIC_MIIM_ADDRESSr_CLAUSE_45_DTYPEf_SET
#define READ_CMIC_MIIM_ADDRESSr BCM56800_A0_READ_CMIC_MIIM_ADDRESSr
#define WRITE_CMIC_MIIM_ADDRESSr BCM56800_A0_WRITE_CMIC_MIIM_ADDRESSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_ADDRESSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 11:8
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_8         Phy ID of external phy for Port 8
 *     RESERVED_0       Reserved
 *     PHY_ID_9         Phy ID of external phy for Port 9
 *     RESERVED_1       Reserved
 *     PHY_ID_10        Phy ID of external phy for Port 10
 *     RESERVED_2       Reserved
 *     PHY_ID_11        Phy ID of external phy for Port 11
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r 0x000004c8

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_11_8[1];
	uint32_t _cmic_miim_ext_phy_addr_map_11_8;
} BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t;

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR(r) (r).cmic_miim_ext_phy_addr_map_11_8[0] = 0
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_11_8[0] = d
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET(r) (r).cmic_miim_ext_phy_addr_map_11_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET(r) (((r).cmic_miim_ext_phy_addr_map_11_8[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 5) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 13) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_11_8[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_11_8[0]=(((r).cmic_miim_ext_phy_addr_map_11_8[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r,r._cmic_miim_ext_phy_addr_map_11_8)
#define BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r,r._cmic_miim_ext_phy_addr_map_11_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SIZE
typedef BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_8f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_9f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_10f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_PHY_ID_11f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_11_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 15:12
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_12        Phy ID of external phy for Port 12
 *     RESERVED_0       Reserved
 *     PHY_ID_13        Phy ID of external phy for Port 13
 *     RESERVED_1       Reserved
 *     PHY_ID_14        Phy ID of external phy for Port 14
 *     RESERVED_2       Reserved
 *     PHY_ID_15        Phy ID of external phy for Port 15
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r 0x000004cc

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_15_12[1];
	uint32_t _cmic_miim_ext_phy_addr_map_15_12;
} BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t;

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR(r) (r).cmic_miim_ext_phy_addr_map_15_12[0] = 0
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_15_12[0] = d
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET(r) (r).cmic_miim_ext_phy_addr_map_15_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET(r) (((r).cmic_miim_ext_phy_addr_map_15_12[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 5) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 13) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_15_12[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_15_12[0]=(((r).cmic_miim_ext_phy_addr_map_15_12[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r,r._cmic_miim_ext_phy_addr_map_15_12)
#define BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r,r._cmic_miim_ext_phy_addr_map_15_12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SIZE
typedef BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_12f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_13f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_14f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_PHY_ID_15f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_15_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 19:16
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_16        Phy ID of external phy for Port 16
 *     RESERVED_0       Reserved
 *     PHY_ID_17        Phy ID of external phy for Port 17
 *     RESERVED_1       Reserved
 *     PHY_ID_18        Phy ID of external phy for Port 18
 *     RESERVED_2       Reserved
 *     PHY_ID_19        Phy ID of external phy for Port 19
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r 0x000004d0

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_19_16[1];
	uint32_t _cmic_miim_ext_phy_addr_map_19_16;
} BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t;

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR(r) (r).cmic_miim_ext_phy_addr_map_19_16[0] = 0
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_19_16[0] = d
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET(r) (r).cmic_miim_ext_phy_addr_map_19_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET(r) (((r).cmic_miim_ext_phy_addr_map_19_16[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 5) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 13) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_19_16[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_19_16[0]=(((r).cmic_miim_ext_phy_addr_map_19_16[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r,r._cmic_miim_ext_phy_addr_map_19_16)
#define BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r,r._cmic_miim_ext_phy_addr_map_19_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SIZE
typedef BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_16f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_17f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_18f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_PHY_ID_19f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_19_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 23:20
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_20        Phy ID of external phy for Port 20
 *     RESERVED_0       Reserved
 *     PHY_ID_21        Phy ID of external phy for Port 21
 *     RESERVED_1       Reserved
 *     PHY_ID_22        Phy ID of external phy for Port 22
 *     RESERVED_2       Reserved
 *     PHY_ID_23        Phy ID of external phy for Port 23
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r 0x000004d4

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_23_20[1];
	uint32_t _cmic_miim_ext_phy_addr_map_23_20;
} BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t;

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR(r) (r).cmic_miim_ext_phy_addr_map_23_20[0] = 0
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_23_20[0] = d
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET(r) (r).cmic_miim_ext_phy_addr_map_23_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET(r) (((r).cmic_miim_ext_phy_addr_map_23_20[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 5) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 13) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_23_20[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_23_20[0]=(((r).cmic_miim_ext_phy_addr_map_23_20[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r,r._cmic_miim_ext_phy_addr_map_23_20)
#define BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r,r._cmic_miim_ext_phy_addr_map_23_20)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SIZE
typedef BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_20f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_21f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_22f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_PHY_ID_23f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_23_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 27:24
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_24        Phy ID of external phy for Port 24
 *     RESERVED_0       Reserved
 *     PHY_ID_25        Phy ID of external phy for Port 25
 *     RESERVED_1       Reserved
 *     PHY_ID_26        Phy ID of external phy for Port 26
 *     RESERVED_2       Reserved
 *     PHY_ID_27        Phy ID of external phy for Port 27
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r 0x000004d8

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_27_24[1];
	uint32_t _cmic_miim_ext_phy_addr_map_27_24;
} BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t;

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR(r) (r).cmic_miim_ext_phy_addr_map_27_24[0] = 0
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_27_24[0] = d
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET(r) (r).cmic_miim_ext_phy_addr_map_27_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET(r) (((r).cmic_miim_ext_phy_addr_map_27_24[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 5) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 13) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_27_24[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_27_24[0]=(((r).cmic_miim_ext_phy_addr_map_27_24[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r,r._cmic_miim_ext_phy_addr_map_27_24)
#define BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r,r._cmic_miim_ext_phy_addr_map_27_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SIZE
typedef BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_24f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_25f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_26f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_PHY_ID_27f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_27_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 31:28
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_28        Phy ID of external phy for Port 28
 *     RESERVED_0       Reserved
 *     PHY_ID_29        Phy ID of external phy for Port 29
 *     RESERVED_1       Reserved
 *     PHY_ID_30        Phy ID of external phy for Port 30
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r 0x000004dc

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_31_28[1];
	uint32_t _cmic_miim_ext_phy_addr_map_31_28;
} BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t;

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR(r) (r).cmic_miim_ext_phy_addr_map_31_28[0] = 0
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_31_28[0] = d
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET(r) (r).cmic_miim_ext_phy_addr_map_31_28[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET(r) (((r).cmic_miim_ext_phy_addr_map_31_28[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 5) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 13) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_31_28[0]) >> 21) & 0x7ff)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_31_28[0]=(((r).cmic_miim_ext_phy_addr_map_31_28[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r,r._cmic_miim_ext_phy_addr_map_31_28)
#define BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r,r._cmic_miim_ext_phy_addr_map_31_28)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SIZE
typedef BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_28f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_29f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_PHY_ID_30f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_31_28r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 3:0
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_0         Phy ID of external phy for Port 0
 *     RESERVED_0       Reserved
 *     PHY_ID_1         Phy ID of external phy for Port 1
 *     RESERVED_1       Reserved
 *     PHY_ID_2         Phy ID of external phy for Port 2
 *     RESERVED_2       Reserved
 *     PHY_ID_3         Phy ID of external phy for Port 3
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r 0x000004c0

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_3_0[1];
	uint32_t _cmic_miim_ext_phy_addr_map_3_0;
} BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t;

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR(r) (r).cmic_miim_ext_phy_addr_map_3_0[0] = 0
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_3_0[0] = d
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET(r) (r).cmic_miim_ext_phy_addr_map_3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET(r) (((r).cmic_miim_ext_phy_addr_map_3_0[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 5) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 13) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_3_0[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_3_0[0]=(((r).cmic_miim_ext_phy_addr_map_3_0[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r,r._cmic_miim_ext_phy_addr_map_3_0)
#define BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r,r._cmic_miim_ext_phy_addr_map_3_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SIZE
typedef BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_PHY_ID_3f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4
 * BLOCKS:   CMIC
 * DESC:     MIIM Phy Address map, Port 7:4
 * SIZE:     32
 * FIELDS:
 *     PHY_ID_4         Phy ID of external phy for Port 4
 *     RESERVED_0       Reserved
 *     PHY_ID_5         Phy ID of external phy for Port 5
 *     RESERVED_1       Reserved
 *     PHY_ID_6         Phy ID of external phy for Port 6
 *     RESERVED_2       Reserved
 *     PHY_ID_7         Phy ID of external phy for Port 7
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r 0x000004c4

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_s {
	uint32_t v[1];
	uint32_t cmic_miim_ext_phy_addr_map_7_4[1];
	uint32_t _cmic_miim_ext_phy_addr_map_7_4;
} BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t;

#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR(r) (r).cmic_miim_ext_phy_addr_map_7_4[0] = 0
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET(r,d) (r).cmic_miim_ext_phy_addr_map_7_4[0] = d
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET(r) (r).cmic_miim_ext_phy_addr_map_7_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET(r) (((r).cmic_miim_ext_phy_addr_map_7_4[0]) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 5) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 13) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_GET(r) ((((r).cmic_miim_ext_phy_addr_map_7_4[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_SET(r,f) (r).cmic_miim_ext_phy_addr_map_7_4[0]=(((r).cmic_miim_ext_phy_addr_map_7_4[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r,r._cmic_miim_ext_phy_addr_map_7_4)
#define BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r,r._cmic_miim_ext_phy_addr_map_7_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SIZE
typedef BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_t;
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_CLR
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_4f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_0f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_5f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_1f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_6f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_2f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_PHY_ID_7f_SET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_GET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_GET
#define CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_SET BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r_RESERVED_3f_SET
#define READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56800_A0_READ_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r
#define WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r BCM56800_A0_WRITE_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_EXT_PHY_ADDR_MAP_7_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_INT_SEL_MAP
 * BLOCKS:   CMIC
 * DESC:     Port bitmap specifying whether scan should be done
from internal or external phy.
0=external phy, 1=internal phy
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      0 bits imply get link status by scanning external phy1 bits imply get link status directly from internal phy
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr 0x000004ac

#define BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_INT_SEL_MAP.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_int_sel_map[1];
	uint32_t _cmic_miim_int_sel_map;
} BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_t;

#define BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_CLR(r) (r).cmic_miim_int_sel_map[0] = 0
#define BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_SET(r,d) (r).cmic_miim_int_sel_map[0] = d
#define BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_GET(r) (r).cmic_miim_int_sel_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET(r) ((r).cmic_miim_int_sel_map[0])
#define BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET(r,f) (r).cmic_miim_int_sel_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_INT_SEL_MAP.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_INT_SEL_MAPr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr,r._cmic_miim_int_sel_map)
#define BCM56800_A0_WRITE_CMIC_MIIM_INT_SEL_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr,r._cmic_miim_int_sel_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_INT_SEL_MAPr BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr
#define CMIC_MIIM_INT_SEL_MAPr_SIZE BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_SIZE
typedef BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_t CMIC_MIIM_INT_SEL_MAPr_t;
#define CMIC_MIIM_INT_SEL_MAPr_CLR BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_CLR
#define CMIC_MIIM_INT_SEL_MAPr_SET BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_SET
#define CMIC_MIIM_INT_SEL_MAPr_GET BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_GET
#define CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_GET
#define CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr_PORT_BITMAPf_SET
#define READ_CMIC_MIIM_INT_SEL_MAPr BCM56800_A0_READ_CMIC_MIIM_INT_SEL_MAPr
#define WRITE_CMIC_MIIM_INT_SEL_MAPr BCM56800_A0_WRITE_CMIC_MIIM_INT_SEL_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_INT_SEL_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_PARAM
 * BLOCKS:   CMIC
 * DESC:     MIIM Parameter Register
 * SIZE:     32
 * FIELDS:
 *     PHY_DATA         PHY register data
 *     PHY_ID           Port number (Phy ID is looked up from port number)
 *     C45_SEL          When set, send MIIM transaction using Clause 45.Otherwise, send as Clause 22 transaction.
 *     HG_SEL           When set, send MIIM transaction on Higig MDIO bus.Otherwise, send on Gig MDIO bus.
 *     INTERNAL_SEL     When set, send MIIM transaction on Internal MDIO bus.Otherwise, send on External MDIO bus.
 *     RESERVED_2       Reserved
 *     MIIM_CYCLE       This field is used to select which type of MIIM cycle to run.Normally, it should just be set to 000.    000: Automatically runs the proper read or write cycle based         on the ports' protocol preference, and whether a read         or write cycle was requested.  If the port is clause 45         enabled, then the read or write will be preceeded by         an address cycle.    001: requests a clause 22 write cycle;         use MIIM_WR_REG_EN control    010: requests a clause 22 read cycle;         use MIIM_RD_REG_EN control    100: requests a clause 45 address cycle;         use MIIM_WR_REG_EN control    101: requests a clause 45 write cycle;         use MIIM_WR_REG_EN control    110: requests a clause 45 read cycle w/addr increment;         use MIIM_RD_REG_EN control    111: requests a clause 45 read cycle;         use MIIM_RD_REG_EN control
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_PARAMr 0x00000158

#define BCM56800_A0_CMIC_MIIM_PARAMr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PARAM.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_PARAMr_s {
	uint32_t v[1];
	uint32_t cmic_miim_param[1];
	uint32_t _cmic_miim_param;
} BCM56800_A0_CMIC_MIIM_PARAMr_t;

#define BCM56800_A0_CMIC_MIIM_PARAMr_CLR(r) (r).cmic_miim_param[0] = 0
#define BCM56800_A0_CMIC_MIIM_PARAMr_SET(r,d) (r).cmic_miim_param[0] = d
#define BCM56800_A0_CMIC_MIIM_PARAMr_GET(r) (r).cmic_miim_param[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_PARAMr_PHY_DATAf_GET(r) (((r).cmic_miim_param[0]) & 0xffff)
#define BCM56800_A0_CMIC_MIIM_PARAMr_PHY_DATAf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CMIC_MIIM_PARAMr_PHY_IDf_GET(r) ((((r).cmic_miim_param[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_PARAMr_PHY_IDf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_MIIM_PARAMr_C45_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 21) & 0x1)
#define BCM56800_A0_CMIC_MIIM_PARAMr_C45_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_CMIC_MIIM_PARAMr_HG_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 22) & 0x1)
#define BCM56800_A0_CMIC_MIIM_PARAMr_HG_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_GET(r) ((((r).cmic_miim_param[0]) >> 23) & 0x1)
#define BCM56800_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_CMIC_MIIM_PARAMr_RESERVED_2f_GET(r) ((((r).cmic_miim_param[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_MIIM_PARAMr_RESERVED_2f_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET(r) ((((r).cmic_miim_param[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET(r,f) (r).cmic_miim_param[0]=(((r).cmic_miim_param[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_MIIM_PARAM.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_PARAMr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_PARAMr,r._cmic_miim_param)
#define BCM56800_A0_WRITE_CMIC_MIIM_PARAMr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_PARAMr,r._cmic_miim_param)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PARAMr BCM56800_A0_CMIC_MIIM_PARAMr
#define CMIC_MIIM_PARAMr_SIZE BCM56800_A0_CMIC_MIIM_PARAMr_SIZE
typedef BCM56800_A0_CMIC_MIIM_PARAMr_t CMIC_MIIM_PARAMr_t;
#define CMIC_MIIM_PARAMr_CLR BCM56800_A0_CMIC_MIIM_PARAMr_CLR
#define CMIC_MIIM_PARAMr_SET BCM56800_A0_CMIC_MIIM_PARAMr_SET
#define CMIC_MIIM_PARAMr_GET BCM56800_A0_CMIC_MIIM_PARAMr_GET
#define CMIC_MIIM_PARAMr_PHY_DATAf_GET BCM56800_A0_CMIC_MIIM_PARAMr_PHY_DATAf_GET
#define CMIC_MIIM_PARAMr_PHY_DATAf_SET BCM56800_A0_CMIC_MIIM_PARAMr_PHY_DATAf_SET
#define CMIC_MIIM_PARAMr_PHY_IDf_GET BCM56800_A0_CMIC_MIIM_PARAMr_PHY_IDf_GET
#define CMIC_MIIM_PARAMr_PHY_IDf_SET BCM56800_A0_CMIC_MIIM_PARAMr_PHY_IDf_SET
#define CMIC_MIIM_PARAMr_C45_SELf_GET BCM56800_A0_CMIC_MIIM_PARAMr_C45_SELf_GET
#define CMIC_MIIM_PARAMr_C45_SELf_SET BCM56800_A0_CMIC_MIIM_PARAMr_C45_SELf_SET
#define CMIC_MIIM_PARAMr_HG_SELf_GET BCM56800_A0_CMIC_MIIM_PARAMr_HG_SELf_GET
#define CMIC_MIIM_PARAMr_HG_SELf_SET BCM56800_A0_CMIC_MIIM_PARAMr_HG_SELf_SET
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_GET BCM56800_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_GET
#define CMIC_MIIM_PARAMr_INTERNAL_SELf_SET BCM56800_A0_CMIC_MIIM_PARAMr_INTERNAL_SELf_SET
#define CMIC_MIIM_PARAMr_RESERVED_2f_GET BCM56800_A0_CMIC_MIIM_PARAMr_RESERVED_2f_GET
#define CMIC_MIIM_PARAMr_RESERVED_2f_SET BCM56800_A0_CMIC_MIIM_PARAMr_RESERVED_2f_SET
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET BCM56800_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_GET
#define CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET BCM56800_A0_CMIC_MIIM_PARAMr_MIIM_CYCLEf_SET
#define READ_CMIC_MIIM_PARAMr BCM56800_A0_READ_CMIC_MIIM_PARAMr
#define WRITE_CMIC_MIIM_PARAMr BCM56800_A0_WRITE_CMIC_MIIM_PARAMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_PARAMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_PORT_TYPE_MAP
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so access   Gig MIIM interface1 bits are HG/XE ports, so access Higig MIIM interface
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr 0x000004a8

#define BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PORT_TYPE_MAP.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_port_type_map[1];
	uint32_t _cmic_miim_port_type_map;
} BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_t;

#define BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_CLR(r) (r).cmic_miim_port_type_map[0] = 0
#define BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_SET(r,d) (r).cmic_miim_port_type_map[0] = d
#define BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_GET(r) (r).cmic_miim_port_type_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET(r) ((r).cmic_miim_port_type_map[0])
#define BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET(r,f) (r).cmic_miim_port_type_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PORT_TYPE_MAP.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_PORT_TYPE_MAPr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr,r._cmic_miim_port_type_map)
#define BCM56800_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr,r._cmic_miim_port_type_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PORT_TYPE_MAPr BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr
#define CMIC_MIIM_PORT_TYPE_MAPr_SIZE BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_SIZE
typedef BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_t CMIC_MIIM_PORT_TYPE_MAPr_t;
#define CMIC_MIIM_PORT_TYPE_MAPr_CLR BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_CLR
#define CMIC_MIIM_PORT_TYPE_MAPr_SET BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_SET
#define CMIC_MIIM_PORT_TYPE_MAPr_GET BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_GET
#define CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_GET
#define CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr_BITMAPf_SET
#define READ_CMIC_MIIM_PORT_TYPE_MAPr BCM56800_A0_READ_CMIC_MIIM_PORT_TYPE_MAPr
#define WRITE_CMIC_MIIM_PORT_TYPE_MAPr BCM56800_A0_WRITE_CMIC_MIIM_PORT_TYPE_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_PORT_TYPE_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_PROTOCOL_MAP
 * BLOCKS:   CMIC
 * DESC:     Port bitmap of MIIM protocol: 0=clause 22, 1=clause 45
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are ports that use clause 22;1 bits are ports that use clause 45.Note: This register is shared by external and internal phy's, so it should be programmed appropriately beforelaunching MIIM wr/rd or link scan commands.
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr 0x000004a4

#define BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_PROTOCOL_MAP.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_miim_protocol_map[1];
	uint32_t _cmic_miim_protocol_map;
} BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_t;

#define BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_CLR(r) (r).cmic_miim_protocol_map[0] = 0
#define BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_SET(r,d) (r).cmic_miim_protocol_map[0] = d
#define BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_GET(r) (r).cmic_miim_protocol_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET(r) ((r).cmic_miim_protocol_map[0])
#define BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET(r,f) (r).cmic_miim_protocol_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_MIIM_PROTOCOL_MAP.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_PROTOCOL_MAPr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr,r._cmic_miim_protocol_map)
#define BCM56800_A0_WRITE_CMIC_MIIM_PROTOCOL_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr,r._cmic_miim_protocol_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_PROTOCOL_MAPr BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr
#define CMIC_MIIM_PROTOCOL_MAPr_SIZE BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_SIZE
typedef BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_t CMIC_MIIM_PROTOCOL_MAPr_t;
#define CMIC_MIIM_PROTOCOL_MAPr_CLR BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_CLR
#define CMIC_MIIM_PROTOCOL_MAPr_SET BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_SET
#define CMIC_MIIM_PROTOCOL_MAPr_GET BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_GET
#define CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_GET
#define CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr_BITMAPf_SET
#define READ_CMIC_MIIM_PROTOCOL_MAPr BCM56800_A0_READ_CMIC_MIIM_PROTOCOL_MAPr
#define WRITE_CMIC_MIIM_PROTOCOL_MAPr BCM56800_A0_WRITE_CMIC_MIIM_PROTOCOL_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_PROTOCOL_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_MIIM_READ_DATA
 * BLOCKS:   CMIC
 * DESC:     MIIM Read Data Register
 * SIZE:     32
 * FIELDS:
 *     DATA             MIIM Read Data Register
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_MIIM_READ_DATAr 0x0000015c

#define BCM56800_A0_CMIC_MIIM_READ_DATAr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_MIIM_READ_DATA.
 *
 */
typedef union BCM56800_A0_CMIC_MIIM_READ_DATAr_s {
	uint32_t v[1];
	uint32_t cmic_miim_read_data[1];
	uint32_t _cmic_miim_read_data;
} BCM56800_A0_CMIC_MIIM_READ_DATAr_t;

#define BCM56800_A0_CMIC_MIIM_READ_DATAr_CLR(r) (r).cmic_miim_read_data[0] = 0
#define BCM56800_A0_CMIC_MIIM_READ_DATAr_SET(r,d) (r).cmic_miim_read_data[0] = d
#define BCM56800_A0_CMIC_MIIM_READ_DATAr_GET(r) (r).cmic_miim_read_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_MIIM_READ_DATAr_DATAf_GET(r) (((r).cmic_miim_read_data[0]) & 0xffff)
#define BCM56800_A0_CMIC_MIIM_READ_DATAr_DATAf_SET(r,f) (r).cmic_miim_read_data[0]=(((r).cmic_miim_read_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access CMIC_MIIM_READ_DATA.
 *
 */
#define BCM56800_A0_READ_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)
#define BCM56800_A0_WRITE_CMIC_MIIM_READ_DATAr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_MIIM_READ_DATAr,r._cmic_miim_read_data)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_MIIM_READ_DATAr BCM56800_A0_CMIC_MIIM_READ_DATAr
#define CMIC_MIIM_READ_DATAr_SIZE BCM56800_A0_CMIC_MIIM_READ_DATAr_SIZE
typedef BCM56800_A0_CMIC_MIIM_READ_DATAr_t CMIC_MIIM_READ_DATAr_t;
#define CMIC_MIIM_READ_DATAr_CLR BCM56800_A0_CMIC_MIIM_READ_DATAr_CLR
#define CMIC_MIIM_READ_DATAr_SET BCM56800_A0_CMIC_MIIM_READ_DATAr_SET
#define CMIC_MIIM_READ_DATAr_GET BCM56800_A0_CMIC_MIIM_READ_DATAr_GET
#define CMIC_MIIM_READ_DATAr_DATAf_GET BCM56800_A0_CMIC_MIIM_READ_DATAr_DATAf_GET
#define CMIC_MIIM_READ_DATAr_DATAf_SET BCM56800_A0_CMIC_MIIM_READ_DATAr_DATAf_SET
#define READ_CMIC_MIIM_READ_DATAr BCM56800_A0_READ_CMIC_MIIM_READ_DATAr
#define WRITE_CMIC_MIIM_READ_DATAr BCM56800_A0_WRITE_CMIC_MIIM_READ_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_MIIM_READ_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_RATE_ADJUST
 * BLOCKS:   CMIC
 * DESC:     Various parts of the chip involved in rate control 
require a constant, known frequency. This reference 
frequency is based off of the chip 's core clock.
However, the core clock can be different in different
designs, thus the need for this register.

The core clock frequency is multiplied by the rational
quantity (DIVIDEND/DIVISOR), and the further divided
down by 2 to produce the actual MDIO operation freqeuncy.

To avoid skew, it is recommended that the DIVIDEND value
usually be set to 1.

The default values are for 133MHz operation:
DIVIDEND=1, DIVISOR=6, 
MDIO operation freq = 133MHz/(6*2) =~ 11MHz

For 157MHz core clock chips, set:
DIVIDEND=1, DIVISOR=7, 
MDIO operation freq = 133MHz/(7*2) =~ 11MHz


 * SIZE:     32
 * FIELDS:
 *     DIVISOR          Denominator of clock scale factor.
 *     DIVIDEND         Numerator of clock scale factor.
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_RATE_ADJUSTr 0x000001b0

#define BCM56800_A0_CMIC_RATE_ADJUSTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_RATE_ADJUST.
 *
 */
typedef union BCM56800_A0_CMIC_RATE_ADJUSTr_s {
	uint32_t v[1];
	uint32_t cmic_rate_adjust[1];
	uint32_t _cmic_rate_adjust;
} BCM56800_A0_CMIC_RATE_ADJUSTr_t;

#define BCM56800_A0_CMIC_RATE_ADJUSTr_CLR(r) (r).cmic_rate_adjust[0] = 0
#define BCM56800_A0_CMIC_RATE_ADJUSTr_SET(r,d) (r).cmic_rate_adjust[0] = d
#define BCM56800_A0_CMIC_RATE_ADJUSTr_GET(r) (r).cmic_rate_adjust[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_RATE_ADJUSTr_DIVISORf_GET(r) (((r).cmic_rate_adjust[0]) & 0xffff)
#define BCM56800_A0_CMIC_RATE_ADJUSTr_DIVISORf_SET(r,f) (r).cmic_rate_adjust[0]=(((r).cmic_rate_adjust[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_GET(r) ((((r).cmic_rate_adjust[0]) >> 16) & 0xffff)
#define BCM56800_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_SET(r,f) (r).cmic_rate_adjust[0]=(((r).cmic_rate_adjust[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access CMIC_RATE_ADJUST.
 *
 */
#define BCM56800_A0_READ_CMIC_RATE_ADJUSTr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_RATE_ADJUSTr,r._cmic_rate_adjust)
#define BCM56800_A0_WRITE_CMIC_RATE_ADJUSTr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_RATE_ADJUSTr,r._cmic_rate_adjust)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_RATE_ADJUSTr BCM56800_A0_CMIC_RATE_ADJUSTr
#define CMIC_RATE_ADJUSTr_SIZE BCM56800_A0_CMIC_RATE_ADJUSTr_SIZE
typedef BCM56800_A0_CMIC_RATE_ADJUSTr_t CMIC_RATE_ADJUSTr_t;
#define CMIC_RATE_ADJUSTr_CLR BCM56800_A0_CMIC_RATE_ADJUSTr_CLR
#define CMIC_RATE_ADJUSTr_SET BCM56800_A0_CMIC_RATE_ADJUSTr_SET
#define CMIC_RATE_ADJUSTr_GET BCM56800_A0_CMIC_RATE_ADJUSTr_GET
#define CMIC_RATE_ADJUSTr_DIVISORf_GET BCM56800_A0_CMIC_RATE_ADJUSTr_DIVISORf_GET
#define CMIC_RATE_ADJUSTr_DIVISORf_SET BCM56800_A0_CMIC_RATE_ADJUSTr_DIVISORf_SET
#define CMIC_RATE_ADJUSTr_DIVIDENDf_GET BCM56800_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_GET
#define CMIC_RATE_ADJUSTr_DIVIDENDf_SET BCM56800_A0_CMIC_RATE_ADJUSTr_DIVIDENDf_SET
#define READ_CMIC_RATE_ADJUSTr BCM56800_A0_READ_CMIC_RATE_ADJUSTr
#define WRITE_CMIC_RATE_ADJUSTr BCM56800_A0_WRITE_CMIC_RATE_ADJUSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_RATE_ADJUSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SBUS_RING_MAP
 * BLOCKS:   CMIC
 * DESC:     Map of S-bus agents on all 3 S-bus rings in the chip
 * SIZE:     32
 * FIELDS:
 *     RING_NUM_SBUS_ID_0 S-bus ring number for agent with S-bus ID  0
 *     RING_NUM_SBUS_ID_1 S-bus ring number for agent with S-bus ID  1
 *     RING_NUM_SBUS_ID_2 S-bus ring number for agent with S-bus ID  2
 *     RING_NUM_SBUS_ID_3 S-bus ring number for agent with S-bus ID  3
 *     RING_NUM_SBUS_ID_4 S-bus ring number for agent with S-bus ID  4
 *     RING_NUM_SBUS_ID_5 S-bus ring number for agent with S-bus ID  5
 *     RING_NUM_SBUS_ID_6 S-bus ring number for agent with S-bus ID  6
 *     RING_NUM_SBUS_ID_7 S-bus ring number for agent with S-bus ID  7
 *     RING_NUM_SBUS_ID_8 S-bus ring number for agent with S-bus ID  8
 *     RING_NUM_SBUS_ID_9 S-bus ring number for agent with S-bus ID  9
 *     RING_NUM_SBUS_ID_10 S-bus ring number for agent with S-bus ID 10
 *     RING_NUM_SBUS_ID_11 S-bus ring number for agent with S-bus ID 11
 *     RING_NUM_SBUS_ID_12 S-bus ring number for agent with S-bus ID 12
 *     RING_NUM_SBUS_ID_13 S-bus ring number for agent with S-bus ID 13
 *     RING_NUM_SBUS_ID_14 S-bus ring number for agent with S-bus ID 14
 *     RING_NUM_SBUS_ID_15 S-bus ring number for agent with S-bus ID 15
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SBUS_RING_MAPr 0x00000400

#define BCM56800_A0_CMIC_SBUS_RING_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_RING_MAP.
 *
 */
typedef union BCM56800_A0_CMIC_SBUS_RING_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_sbus_ring_map[1];
	uint32_t _cmic_sbus_ring_map;
} BCM56800_A0_CMIC_SBUS_RING_MAPr_t;

#define BCM56800_A0_CMIC_SBUS_RING_MAPr_CLR(r) (r).cmic_sbus_ring_map[0] = 0
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_SET(r,d) (r).cmic_sbus_ring_map[0] = d
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_GET(r) (r).cmic_sbus_ring_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET(r) (((r).cmic_sbus_ring_map[0]) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 2) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 4) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 6) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 8) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 10) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 12) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 14) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 16) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 18) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 20) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 22) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 24) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 26) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 28) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET(r) ((((r).cmic_sbus_ring_map[0]) >> 30) & 0x3)
#define BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET(r,f) (r).cmic_sbus_ring_map[0]=(((r).cmic_sbus_ring_map[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_SBUS_RING_MAP.
 *
 */
#define BCM56800_A0_READ_CMIC_SBUS_RING_MAPr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SBUS_RING_MAPr,r._cmic_sbus_ring_map)
#define BCM56800_A0_WRITE_CMIC_SBUS_RING_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SBUS_RING_MAPr,r._cmic_sbus_ring_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SBUS_RING_MAPr BCM56800_A0_CMIC_SBUS_RING_MAPr
#define CMIC_SBUS_RING_MAPr_SIZE BCM56800_A0_CMIC_SBUS_RING_MAPr_SIZE
typedef BCM56800_A0_CMIC_SBUS_RING_MAPr_t CMIC_SBUS_RING_MAPr_t;
#define CMIC_SBUS_RING_MAPr_CLR BCM56800_A0_CMIC_SBUS_RING_MAPr_CLR
#define CMIC_SBUS_RING_MAPr_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_SET
#define CMIC_SBUS_RING_MAPr_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_0f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_1f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_2f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_3f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_4f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_5f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_6f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_7f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_8f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_9f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_10f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_11f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_12f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_13f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_14f_SET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_GET
#define CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET BCM56800_A0_CMIC_SBUS_RING_MAPr_RING_NUM_SBUS_ID_15f_SET
#define READ_CMIC_SBUS_RING_MAPr BCM56800_A0_READ_CMIC_SBUS_RING_MAPr
#define WRITE_CMIC_SBUS_RING_MAPr BCM56800_A0_WRITE_CMIC_SBUS_RING_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SBUS_RING_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SBUS_TIMEOUT
 * BLOCKS:   CMIC
 * DESC:     Secret register that allows software to program the
S-bus operation completion time limit (in terms of 
number of core clocks).
If this limit is exceeded, the CMIC will set the SW PIO
"DONE" bit and the "ERROR" bit to indicate the timeout.

 * SIZE:     32
 * FIELDS:
 *     TIMEOUT_VAL      Timeout value in core clocks
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SBUS_TIMEOUTr 0x00000408

#define BCM56800_A0_CMIC_SBUS_TIMEOUTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SBUS_TIMEOUT.
 *
 */
typedef union BCM56800_A0_CMIC_SBUS_TIMEOUTr_s {
	uint32_t v[1];
	uint32_t cmic_sbus_timeout[1];
	uint32_t _cmic_sbus_timeout;
} BCM56800_A0_CMIC_SBUS_TIMEOUTr_t;

#define BCM56800_A0_CMIC_SBUS_TIMEOUTr_CLR(r) (r).cmic_sbus_timeout[0] = 0
#define BCM56800_A0_CMIC_SBUS_TIMEOUTr_SET(r,d) (r).cmic_sbus_timeout[0] = d
#define BCM56800_A0_CMIC_SBUS_TIMEOUTr_GET(r) (r).cmic_sbus_timeout[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET(r) ((r).cmic_sbus_timeout[0])
#define BCM56800_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET(r,f) (r).cmic_sbus_timeout[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SBUS_TIMEOUT.
 *
 */
#define BCM56800_A0_READ_CMIC_SBUS_TIMEOUTr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SBUS_TIMEOUTr,r._cmic_sbus_timeout)
#define BCM56800_A0_WRITE_CMIC_SBUS_TIMEOUTr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SBUS_TIMEOUTr,r._cmic_sbus_timeout)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SBUS_TIMEOUTr BCM56800_A0_CMIC_SBUS_TIMEOUTr
#define CMIC_SBUS_TIMEOUTr_SIZE BCM56800_A0_CMIC_SBUS_TIMEOUTr_SIZE
typedef BCM56800_A0_CMIC_SBUS_TIMEOUTr_t CMIC_SBUS_TIMEOUTr_t;
#define CMIC_SBUS_TIMEOUTr_CLR BCM56800_A0_CMIC_SBUS_TIMEOUTr_CLR
#define CMIC_SBUS_TIMEOUTr_SET BCM56800_A0_CMIC_SBUS_TIMEOUTr_SET
#define CMIC_SBUS_TIMEOUTr_GET BCM56800_A0_CMIC_SBUS_TIMEOUTr_GET
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET BCM56800_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_GET
#define CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET BCM56800_A0_CMIC_SBUS_TIMEOUTr_TIMEOUT_VALf_SET
#define READ_CMIC_SBUS_TIMEOUTr BCM56800_A0_READ_CMIC_SBUS_TIMEOUTr
#define WRITE_CMIC_SBUS_TIMEOUTr BCM56800_A0_WRITE_CMIC_SBUS_TIMEOUTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SBUS_TIMEOUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SCAN_PORTS
 * BLOCKS:   CMIC
 * DESC:     Scan Ports Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      SCAN ports Register
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SCAN_PORTSr 0x00000160

#define BCM56800_A0_CMIC_SCAN_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCAN_PORTS.
 *
 */
typedef union BCM56800_A0_CMIC_SCAN_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_scan_ports[1];
	uint32_t _cmic_scan_ports;
} BCM56800_A0_CMIC_SCAN_PORTSr_t;

#define BCM56800_A0_CMIC_SCAN_PORTSr_CLR(r) (r).cmic_scan_ports[0] = 0
#define BCM56800_A0_CMIC_SCAN_PORTSr_SET(r,d) (r).cmic_scan_ports[0] = d
#define BCM56800_A0_CMIC_SCAN_PORTSr_GET(r) (r).cmic_scan_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_GET(r) ((r).cmic_scan_ports[0])
#define BCM56800_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_SET(r,f) (r).cmic_scan_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCAN_PORTS.
 *
 */
#define BCM56800_A0_READ_CMIC_SCAN_PORTSr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SCAN_PORTSr,r._cmic_scan_ports)
#define BCM56800_A0_WRITE_CMIC_SCAN_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SCAN_PORTSr,r._cmic_scan_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCAN_PORTSr BCM56800_A0_CMIC_SCAN_PORTSr
#define CMIC_SCAN_PORTSr_SIZE BCM56800_A0_CMIC_SCAN_PORTSr_SIZE
typedef BCM56800_A0_CMIC_SCAN_PORTSr_t CMIC_SCAN_PORTSr_t;
#define CMIC_SCAN_PORTSr_CLR BCM56800_A0_CMIC_SCAN_PORTSr_CLR
#define CMIC_SCAN_PORTSr_SET BCM56800_A0_CMIC_SCAN_PORTSr_SET
#define CMIC_SCAN_PORTSr_GET BCM56800_A0_CMIC_SCAN_PORTSr_GET
#define CMIC_SCAN_PORTSr_PORT_BITMAPf_GET BCM56800_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_GET
#define CMIC_SCAN_PORTSr_PORT_BITMAPf_SET BCM56800_A0_CMIC_SCAN_PORTSr_PORT_BITMAPf_SET
#define READ_CMIC_SCAN_PORTSr BCM56800_A0_READ_CMIC_SCAN_PORTSr
#define WRITE_CMIC_SCAN_PORTSr BCM56800_A0_WRITE_CMIC_SCAN_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SCAN_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SCHAN_CTRL
 * BLOCKS:   CMIC
 * DESC:     Status and Control Register
 * SIZE:     32
 * FIELDS:
 *     MSG_START        Set by CPU to start an SCH operation
 *     MSG_DONE         Set by CMIC to indicate an SCH operation completion
 *     RESERVED_1       Reserved
 *     LINK_STATUS_CHANGE Set by CMIC to indicate Link status changed
 *     PCI_FATAL_ERR    Set by CMIC to indicate a Fatal Error during PCI master Operation
 *     PCI_PARITY_ERR   Set by CMIC to indicate a Parity Error during PCI master Operation
 *     RESERVED_3       Reserved
 *     MIIM_SCAN_BUSY   Set by CMIC indicating that MIIM scan cycle is in progress
 *     RESERVED_4       Reserved
 *     MIIM_RD_START    Set by CPU to start a Read operation on MIIM Interface
 *     MIIM_WR_START    Set by CPU to start a Write operation on MIIM Interface
 *     MIIM_OP_DONE     Set by CMIC to indicate Completion of MIIM Rd/Wr Operation
 *     MIIM_LINK_SCAN_EN Set by CPU to start automatic Link Status scanning
 *     RESERVED_5       Reserved
 *     NACK             Set by CMIC to indicate last S-bus operation resulted in a NACK(i.e., command was legal, but could not be serviced due tohardware resource limitations)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *     TIMEOUT          Set by CMIC to indicate last S-bus operation resulted in a TIMEOUT.(i.e., no ACK was received by CMIC within the TIMEOUT intervalspecified in CMIC_SBUS_TIMEOUT)Clearing the SCH_PIO_OPN_COMPLETE bit or starting a new SCH operation will automatically clear this bit
 *     BIT_POS          Selects one of 32 bits positions to be Set/Reset
 *     BIT_VAL          Set to 1 to set a bit, 0 to reset a bit
 *     RESERVED_6       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SCHAN_CTRLr 0x00000050

#define BCM56800_A0_CMIC_SCHAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_CTRL.
 *
 */
typedef union BCM56800_A0_CMIC_SCHAN_CTRLr_s {
	uint32_t v[1];
	uint32_t cmic_schan_ctrl[1];
	uint32_t _cmic_schan_ctrl;
} BCM56800_A0_CMIC_SCHAN_CTRLr_t;

#define BCM56800_A0_CMIC_SCHAN_CTRLr_CLR(r) (r).cmic_schan_ctrl[0] = 0
#define BCM56800_A0_CMIC_SCHAN_CTRLr_SET(r,d) (r).cmic_schan_ctrl[0] = d
#define BCM56800_A0_CMIC_SCHAN_CTRLr_GET(r) (r).cmic_schan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 2) & 0x3f)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 10) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 11) & 0x7)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 14) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 15) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 16) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 19) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 20) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_NACKf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 21) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_NACKf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_BIT_POSf_GET(r) (((r).cmic_schan_ctrl[0]) & 0x1f)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_BIT_POSf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_BIT_VALf_GET(r) ((((r).cmic_schan_ctrl[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_BIT_VALf_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_GET(r) ((((r).cmic_schan_ctrl[0]) >> 22) & 0x3ff)
#define BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_SET(r,f) (r).cmic_schan_ctrl[0]=(((r).cmic_schan_ctrl[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_SCHAN_CTRL.
 *
 */
#define BCM56800_A0_READ_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)
#define BCM56800_A0_WRITE_CMIC_SCHAN_CTRLr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SCHAN_CTRLr,r._cmic_schan_ctrl)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_CTRLr BCM56800_A0_CMIC_SCHAN_CTRLr
#define CMIC_SCHAN_CTRLr_SIZE BCM56800_A0_CMIC_SCHAN_CTRLr_SIZE
typedef BCM56800_A0_CMIC_SCHAN_CTRLr_t CMIC_SCHAN_CTRLr_t;
#define CMIC_SCHAN_CTRLr_CLR BCM56800_A0_CMIC_SCHAN_CTRLr_CLR
#define CMIC_SCHAN_CTRLr_SET BCM56800_A0_CMIC_SCHAN_CTRLr_SET
#define CMIC_SCHAN_CTRLr_GET BCM56800_A0_CMIC_SCHAN_CTRLr_GET
#define CMIC_SCHAN_CTRLr_MSG_STARTf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_GET
#define CMIC_SCHAN_CTRLr_MSG_STARTf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_MSG_STARTf_SET
#define CMIC_SCHAN_CTRLr_MSG_DONEf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_GET
#define CMIC_SCHAN_CTRLr_MSG_DONEf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_MSG_DONEf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_1f_GET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_1f_SET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_1f_SET
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_GET
#define CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_LINK_STATUS_CHANGEf_SET
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_GET
#define CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_PCI_FATAL_ERRf_SET
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_GET
#define CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_PCI_PARITY_ERRf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_3f_GET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_3f_SET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_3f_SET
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_GET
#define CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_SCAN_BUSYf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_4f_GET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_4f_SET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_4f_SET
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_GET
#define CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_RD_STARTf_SET
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_GET
#define CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_WR_STARTf_SET
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_GET
#define CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_OP_DONEf_SET
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_GET
#define CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_MIIM_LINK_SCAN_ENf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_5f_GET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_5f_SET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_5f_SET
#define CMIC_SCHAN_CTRLr_NACKf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_NACKf_GET
#define CMIC_SCHAN_CTRLr_NACKf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_NACKf_SET
#define CMIC_SCHAN_CTRLr_TIMEOUTf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_GET
#define CMIC_SCHAN_CTRLr_TIMEOUTf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_TIMEOUTf_SET
#define CMIC_SCHAN_CTRLr_BIT_POSf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_BIT_POSf_GET
#define CMIC_SCHAN_CTRLr_BIT_POSf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_BIT_POSf_SET
#define CMIC_SCHAN_CTRLr_BIT_VALf_GET BCM56800_A0_CMIC_SCHAN_CTRLr_BIT_VALf_GET
#define CMIC_SCHAN_CTRLr_BIT_VALf_SET BCM56800_A0_CMIC_SCHAN_CTRLr_BIT_VALf_SET
#define CMIC_SCHAN_CTRLr_RESERVED_6f_GET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_GET
#define CMIC_SCHAN_CTRLr_RESERVED_6f_SET BCM56800_A0_CMIC_SCHAN_CTRLr_RESERVED_6f_SET
#define READ_CMIC_SCHAN_CTRLr BCM56800_A0_READ_CMIC_SCHAN_CTRLr
#define WRITE_CMIC_SCHAN_CTRLr BCM56800_A0_WRITE_CMIC_SCHAN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SCHAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SCHAN_ERR
 * BLOCKS:   CMIC
 * DESC:     Error Status Register
 * SIZE:     32
 * FIELDS:
 *     NACK             When set, indicates the last S-bus command resulted in an NACK(i.e., could not be fulfilled due to hardware resource limitations).
 *     RESERVED_1       Reserved
 *     ERR_CODE         Error code in the SCH Error message
 *     ERRBIT           When set, indicates the last S-bus command resulted in an error(i.e., the command was illegal, or accessed an invalid address)
 *     DATA_LEN         Data length in the SCH Error ACK message
 *     SRC_PORT         Source port in the SCH Error ACK message(not guaranteed to be set by all blocks)
 *     DST_PORT         Dest port in the SCH Error ACK message
 *     OP_CODE          Opcode in the SCH Error ACK message
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SCHAN_ERRr 0x0000005c

#define BCM56800_A0_CMIC_SCHAN_ERRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_ERR.
 *
 */
typedef union BCM56800_A0_CMIC_SCHAN_ERRr_s {
	uint32_t v[1];
	uint32_t cmic_schan_err[1];
	uint32_t _cmic_schan_err;
} BCM56800_A0_CMIC_SCHAN_ERRr_t;

#define BCM56800_A0_CMIC_SCHAN_ERRr_CLR(r) (r).cmic_schan_err[0] = 0
#define BCM56800_A0_CMIC_SCHAN_ERRr_SET(r,d) (r).cmic_schan_err[0] = d
#define BCM56800_A0_CMIC_SCHAN_ERRr_GET(r) (r).cmic_schan_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SCHAN_ERRr_NACKf_GET(r) (((r).cmic_schan_err[0]) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_ERRr_NACKf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_SCHAN_ERRr_RESERVED_1f_GET(r) ((((r).cmic_schan_err[0]) >> 1) & 0x7)
#define BCM56800_A0_CMIC_SCHAN_ERRr_RESERVED_1f_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56800_A0_CMIC_SCHAN_ERRr_ERR_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 4) & 0x3)
#define BCM56800_A0_CMIC_SCHAN_ERRr_ERR_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_CMIC_SCHAN_ERRr_ERRBITf_GET(r) ((((r).cmic_schan_err[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_SCHAN_ERRr_ERRBITf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_SCHAN_ERRr_DATA_LENf_GET(r) ((((r).cmic_schan_err[0]) >> 7) & 0x7f)
#define BCM56800_A0_CMIC_SCHAN_ERRr_DATA_LENf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCM56800_A0_CMIC_SCHAN_ERRr_SRC_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 14) & 0x3f)
#define BCM56800_A0_CMIC_SCHAN_ERRr_SRC_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM56800_A0_CMIC_SCHAN_ERRr_DST_PORTf_GET(r) ((((r).cmic_schan_err[0]) >> 20) & 0x3f)
#define BCM56800_A0_CMIC_SCHAN_ERRr_DST_PORTf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM56800_A0_CMIC_SCHAN_ERRr_OP_CODEf_GET(r) ((((r).cmic_schan_err[0]) >> 26) & 0x3f)
#define BCM56800_A0_CMIC_SCHAN_ERRr_OP_CODEf_SET(r,f) (r).cmic_schan_err[0]=(((r).cmic_schan_err[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_SCHAN_ERR.
 *
 */
#define BCM56800_A0_READ_CMIC_SCHAN_ERRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SCHAN_ERRr,r._cmic_schan_err)
#define BCM56800_A0_WRITE_CMIC_SCHAN_ERRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SCHAN_ERRr,r._cmic_schan_err)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_ERRr BCM56800_A0_CMIC_SCHAN_ERRr
#define CMIC_SCHAN_ERRr_SIZE BCM56800_A0_CMIC_SCHAN_ERRr_SIZE
typedef BCM56800_A0_CMIC_SCHAN_ERRr_t CMIC_SCHAN_ERRr_t;
#define CMIC_SCHAN_ERRr_CLR BCM56800_A0_CMIC_SCHAN_ERRr_CLR
#define CMIC_SCHAN_ERRr_SET BCM56800_A0_CMIC_SCHAN_ERRr_SET
#define CMIC_SCHAN_ERRr_GET BCM56800_A0_CMIC_SCHAN_ERRr_GET
#define CMIC_SCHAN_ERRr_NACKf_GET BCM56800_A0_CMIC_SCHAN_ERRr_NACKf_GET
#define CMIC_SCHAN_ERRr_NACKf_SET BCM56800_A0_CMIC_SCHAN_ERRr_NACKf_SET
#define CMIC_SCHAN_ERRr_RESERVED_1f_GET BCM56800_A0_CMIC_SCHAN_ERRr_RESERVED_1f_GET
#define CMIC_SCHAN_ERRr_RESERVED_1f_SET BCM56800_A0_CMIC_SCHAN_ERRr_RESERVED_1f_SET
#define CMIC_SCHAN_ERRr_ERR_CODEf_GET BCM56800_A0_CMIC_SCHAN_ERRr_ERR_CODEf_GET
#define CMIC_SCHAN_ERRr_ERR_CODEf_SET BCM56800_A0_CMIC_SCHAN_ERRr_ERR_CODEf_SET
#define CMIC_SCHAN_ERRr_ERRBITf_GET BCM56800_A0_CMIC_SCHAN_ERRr_ERRBITf_GET
#define CMIC_SCHAN_ERRr_ERRBITf_SET BCM56800_A0_CMIC_SCHAN_ERRr_ERRBITf_SET
#define CMIC_SCHAN_ERRr_DATA_LENf_GET BCM56800_A0_CMIC_SCHAN_ERRr_DATA_LENf_GET
#define CMIC_SCHAN_ERRr_DATA_LENf_SET BCM56800_A0_CMIC_SCHAN_ERRr_DATA_LENf_SET
#define CMIC_SCHAN_ERRr_SRC_PORTf_GET BCM56800_A0_CMIC_SCHAN_ERRr_SRC_PORTf_GET
#define CMIC_SCHAN_ERRr_SRC_PORTf_SET BCM56800_A0_CMIC_SCHAN_ERRr_SRC_PORTf_SET
#define CMIC_SCHAN_ERRr_DST_PORTf_GET BCM56800_A0_CMIC_SCHAN_ERRr_DST_PORTf_GET
#define CMIC_SCHAN_ERRr_DST_PORTf_SET BCM56800_A0_CMIC_SCHAN_ERRr_DST_PORTf_SET
#define CMIC_SCHAN_ERRr_OP_CODEf_GET BCM56800_A0_CMIC_SCHAN_ERRr_OP_CODEf_GET
#define CMIC_SCHAN_ERRr_OP_CODEf_SET BCM56800_A0_CMIC_SCHAN_ERRr_OP_CODEf_SET
#define READ_CMIC_SCHAN_ERRr BCM56800_A0_READ_CMIC_SCHAN_ERRr
#define WRITE_CMIC_SCHAN_ERRr BCM56800_A0_WRITE_CMIC_SCHAN_ERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SCHAN_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SCHAN_MESSAGE
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SCHAN_MESSAGEr 0x00000000

#define BCM56800_A0_CMIC_SCHAN_MESSAGEr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE.
 *
 */
typedef union BCM56800_A0_CMIC_SCHAN_MESSAGEr_s {
	uint32_t v[1];
	uint32_t cmic_schan_message[1];
	uint32_t _cmic_schan_message;
} BCM56800_A0_CMIC_SCHAN_MESSAGEr_t;

#define BCM56800_A0_CMIC_SCHAN_MESSAGEr_CLR(r) (r).cmic_schan_message[0] = 0
#define BCM56800_A0_CMIC_SCHAN_MESSAGEr_SET(r,d) (r).cmic_schan_message[0] = d
#define BCM56800_A0_CMIC_SCHAN_MESSAGEr_GET(r) (r).cmic_schan_message[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SCHAN_MESSAGEr_DATAf_GET(r) ((r).cmic_schan_message[0])
#define BCM56800_A0_CMIC_SCHAN_MESSAGEr_DATAf_SET(r,f) (r).cmic_schan_message[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE.
 *
 */
#define BCM56800_A0_READ_CMIC_SCHAN_MESSAGEr(u,i,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SCHAN_MESSAGEr+(4*(i)),r._cmic_schan_message)
#define BCM56800_A0_WRITE_CMIC_SCHAN_MESSAGEr(u,i,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SCHAN_MESSAGEr+(4*(i)),r._cmic_schan_message)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_MESSAGEr BCM56800_A0_CMIC_SCHAN_MESSAGEr
#define CMIC_SCHAN_MESSAGEr_SIZE BCM56800_A0_CMIC_SCHAN_MESSAGEr_SIZE
typedef BCM56800_A0_CMIC_SCHAN_MESSAGEr_t CMIC_SCHAN_MESSAGEr_t;
#define CMIC_SCHAN_MESSAGEr_CLR BCM56800_A0_CMIC_SCHAN_MESSAGEr_CLR
#define CMIC_SCHAN_MESSAGEr_SET BCM56800_A0_CMIC_SCHAN_MESSAGEr_SET
#define CMIC_SCHAN_MESSAGEr_GET BCM56800_A0_CMIC_SCHAN_MESSAGEr_GET
#define CMIC_SCHAN_MESSAGEr_DATAf_GET BCM56800_A0_CMIC_SCHAN_MESSAGEr_DATAf_GET
#define CMIC_SCHAN_MESSAGEr_DATAf_SET BCM56800_A0_CMIC_SCHAN_MESSAGEr_DATAf_SET
#define READ_CMIC_SCHAN_MESSAGEr BCM56800_A0_READ_CMIC_SCHAN_MESSAGEr
#define WRITE_CMIC_SCHAN_MESSAGEr BCM56800_A0_WRITE_CMIC_SCHAN_MESSAGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SCHAN_MESSAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SCHAN_MESSAGE_EXT
 * BLOCKS:   CMIC
 * DESC:     S-bus PIO Message Register Set (extended)
 * SIZE:     32
 * FIELDS:
 *     DATA             S-channel data (Rd/Wr) word
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr 0x00000800

#define BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SCHAN_MESSAGE_EXT.
 *
 */
typedef union BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_s {
	uint32_t v[1];
	uint32_t cmic_schan_message_ext[1];
	uint32_t _cmic_schan_message_ext;
} BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_t;

#define BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_CLR(r) (r).cmic_schan_message_ext[0] = 0
#define BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_SET(r,d) (r).cmic_schan_message_ext[0] = d
#define BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_GET(r) (r).cmic_schan_message_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET(r) ((r).cmic_schan_message_ext[0])
#define BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET(r,f) (r).cmic_schan_message_ext[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SCHAN_MESSAGE_EXT.
 *
 */
#define BCM56800_A0_READ_CMIC_SCHAN_MESSAGE_EXTr(u,i,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr+(4*(i)),r._cmic_schan_message_ext)
#define BCM56800_A0_WRITE_CMIC_SCHAN_MESSAGE_EXTr(u,i,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr+(4*(i)),r._cmic_schan_message_ext)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SCHAN_MESSAGE_EXTr BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr
#define CMIC_SCHAN_MESSAGE_EXTr_SIZE BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_SIZE
typedef BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_t CMIC_SCHAN_MESSAGE_EXTr_t;
#define CMIC_SCHAN_MESSAGE_EXTr_CLR BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_CLR
#define CMIC_SCHAN_MESSAGE_EXTr_SET BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_SET
#define CMIC_SCHAN_MESSAGE_EXTr_GET BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_GET
#define CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_GET
#define CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr_DATAf_SET
#define READ_CMIC_SCHAN_MESSAGE_EXTr BCM56800_A0_READ_CMIC_SCHAN_MESSAGE_EXTr
#define WRITE_CMIC_SCHAN_MESSAGE_EXTr BCM56800_A0_WRITE_CMIC_SCHAN_MESSAGE_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SCHAN_MESSAGE_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SLAM_DMA_CFG
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Config Register
 * SIZE:     32
 * FIELDS:
 *     EN               Set by CPU to Enable Slam DMA Transfer
 *     ABORT            Set by CPU to Abort Slam DMA Transfer
 *     DONE             Set by CMIC to indicate Slam DMA Transfer CompletionCan be cleared (but not set) by CPU.
 *     ERROR            Set by CMIC to indicate Slam DMA Transfer wasaborted due to an error (most probably due to a NACK).Can be cleared (but not set) by CPU.
 *     RESERVED_1       Reserved
 *     BEATS            Written by CPU indicating number of data beats.For Slam DMA purposes, each table entry is 32-bit aligned.The widest S-bus table wr/rd supported is 640 bits.So, the valid values for this field are 1-20 (beats).
 *     ORDER            Set by CPU to specify Slam DMA order:'0' =>  forward (used for DELETE operations)'1' => backward (used for INSERT operations)
 *     REV_MODULO_COUNT Set by CPU to specify 'Entry count for the first iteration ofa Reverse Slam DMA operation'. The formula for this value is:( CMIC_SLAM_DMA_ENTRY_COUNT[23:0] % ( 64 / BEATS[4:0] ) )
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr 0x0000044c

#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_CFG.
 *
 */
typedef union BCM56800_A0_CMIC_SLAM_DMA_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_cfg[1];
	uint32_t _cmic_slam_dma_cfg;
} BCM56800_A0_CMIC_SLAM_DMA_CFGr_t;

#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_CLR(r) (r).cmic_slam_dma_cfg[0] = 0
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_SET(r,d) (r).cmic_slam_dma_cfg[0] = d
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_GET(r) (r).cmic_slam_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_ENf_GET(r) (((r).cmic_slam_dma_cfg[0]) & 0x1)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_ENf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_DONEf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_DONEf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_ERRORf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_ERRORf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 4) & 0xfff)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_BEATSf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_BEATSf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_ORDERf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 21) & 0x1)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_ORDERf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 22) & 0x3f)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0x3f << 22)) | ((((uint32_t)f) & 0x3f) << 22))
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET(r) ((((r).cmic_slam_dma_cfg[0]) >> 28) & 0xf)
#define BCM56800_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET(r,f) (r).cmic_slam_dma_cfg[0]=(((r).cmic_slam_dma_cfg[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_SLAM_DMA_CFG.
 *
 */
#define BCM56800_A0_READ_CMIC_SLAM_DMA_CFGr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SLAM_DMA_CFGr,r._cmic_slam_dma_cfg)
#define BCM56800_A0_WRITE_CMIC_SLAM_DMA_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SLAM_DMA_CFGr,r._cmic_slam_dma_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_CFGr BCM56800_A0_CMIC_SLAM_DMA_CFGr
#define CMIC_SLAM_DMA_CFGr_SIZE BCM56800_A0_CMIC_SLAM_DMA_CFGr_SIZE
typedef BCM56800_A0_CMIC_SLAM_DMA_CFGr_t CMIC_SLAM_DMA_CFGr_t;
#define CMIC_SLAM_DMA_CFGr_CLR BCM56800_A0_CMIC_SLAM_DMA_CFGr_CLR
#define CMIC_SLAM_DMA_CFGr_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_SET
#define CMIC_SLAM_DMA_CFGr_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_GET
#define CMIC_SLAM_DMA_CFGr_ENf_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_ENf_GET
#define CMIC_SLAM_DMA_CFGr_ENf_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_ENf_SET
#define CMIC_SLAM_DMA_CFGr_ABORTf_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_ABORTf_GET
#define CMIC_SLAM_DMA_CFGr_ABORTf_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_ABORTf_SET
#define CMIC_SLAM_DMA_CFGr_DONEf_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_DONEf_GET
#define CMIC_SLAM_DMA_CFGr_DONEf_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_DONEf_SET
#define CMIC_SLAM_DMA_CFGr_ERRORf_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_ERRORf_GET
#define CMIC_SLAM_DMA_CFGr_ERRORf_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_ERRORf_SET
#define CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_GET
#define CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_RESERVED_1f_SET
#define CMIC_SLAM_DMA_CFGr_BEATSf_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_BEATSf_GET
#define CMIC_SLAM_DMA_CFGr_BEATSf_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_BEATSf_SET
#define CMIC_SLAM_DMA_CFGr_ORDERf_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_ORDERf_GET
#define CMIC_SLAM_DMA_CFGr_ORDERf_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_ORDERf_SET
#define CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_GET
#define CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_REV_MODULO_COUNTf_SET
#define CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET BCM56800_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_GET
#define CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET BCM56800_A0_CMIC_SLAM_DMA_CFGr_RESERVED_2f_SET
#define READ_CMIC_SLAM_DMA_CFGr BCM56800_A0_READ_CMIC_SLAM_DMA_CFGr
#define WRITE_CMIC_SLAM_DMA_CFGr BCM56800_A0_WRITE_CMIC_SLAM_DMA_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SLAM_DMA_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Current Entry S-bus Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CMIC indicating S-bus address of the Table Entrycurrently being processed
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr 0x00000454

#define BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
typedef union BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_cur_entry_sbus_addr[1];
	uint32_t _cmic_slam_dma_cur_entry_sbus_addr;
} BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t;

#define BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR(r) (r).cmic_slam_dma_cur_entry_sbus_addr[0] = 0
#define BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET(r,d) (r).cmic_slam_dma_cur_entry_sbus_addr[0] = d
#define BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET(r) (r).cmic_slam_dma_cur_entry_sbus_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_cur_entry_sbus_addr[0])
#define BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_cur_entry_sbus_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_slam_dma_cur_entry_sbus_addr)
#define BCM56800_A0_WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_slam_dma_cur_entry_sbus_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE
typedef BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_t;
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_CLR
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_SET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_GET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56800_A0_READ_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr
#define WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr BCM56800_A0_WRITE_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SLAM_DMA_CUR_ENTRY_SBUS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SLAM_DMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * DESC:     Slam DMA Entry Count Register
 * SIZE:     32
 * FIELDS:
 *     COUNT            Written by CPU indicating number of Slam entries for Slam DMA.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr 0x00000448

#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_ENTRY_COUNT.
 *
 */
typedef union BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_entry_count[1];
	uint32_t _cmic_slam_dma_entry_count;
} BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_t;

#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_CLR(r) (r).cmic_slam_dma_entry_count[0] = 0
#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SET(r,d) (r).cmic_slam_dma_entry_count[0] = d
#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_GET(r) (r).cmic_slam_dma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_slam_dma_entry_count[0]) & 0xffffff)
#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_slam_dma_entry_count[0]=(((r).cmic_slam_dma_entry_count[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET(r) ((((r).cmic_slam_dma_entry_count[0]) >> 24) & 0xff)
#define BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET(r,f) (r).cmic_slam_dma_entry_count[0]=(((r).cmic_slam_dma_entry_count[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_SLAM_DMA_ENTRY_COUNT.
 *
 */
#define BCM56800_A0_READ_CMIC_SLAM_DMA_ENTRY_COUNTr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr,r._cmic_slam_dma_entry_count)
#define BCM56800_A0_WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr,r._cmic_slam_dma_entry_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_ENTRY_COUNTr BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr
#define CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SIZE
typedef BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_t CMIC_SLAM_DMA_ENTRY_COUNTr_t;
#define CMIC_SLAM_DMA_ENTRY_COUNTr_CLR BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_CLR
#define CMIC_SLAM_DMA_ENTRY_COUNTr_SET BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_SET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_GET BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_COUNTf_SET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_GET
#define CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr_RESERVED_1f_SET
#define READ_CMIC_SLAM_DMA_ENTRY_COUNTr BCM56800_A0_READ_CMIC_SLAM_DMA_ENTRY_COUNTr
#define WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr BCM56800_A0_WRITE_CMIC_SLAM_DMA_ENTRY_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SLAM_DMA_ENTRY_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SLAM_DMA_PCIMEM_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA PCI Memory Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Slam DMA Physical (PCI) Memory Start Address
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr 0x00000440

#define BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_PCIMEM_START_ADDR.
 *
 */
typedef union BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_pcimem_start_addr[1];
	uint32_t _cmic_slam_dma_pcimem_start_addr;
} BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t;

#define BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR(r) (r).cmic_slam_dma_pcimem_start_addr[0] = 0
#define BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET(r,d) (r).cmic_slam_dma_pcimem_start_addr[0] = d
#define BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET(r) (r).cmic_slam_dma_pcimem_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_pcimem_start_addr[0])
#define BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_pcimem_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_PCIMEM_START_ADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr,r._cmic_slam_dma_pcimem_start_addr)
#define BCM56800_A0_WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr,r._cmic_slam_dma_pcimem_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SIZE
typedef BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t CMIC_SLAM_DMA_PCIMEM_START_ADDRr_t;
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_CLR
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_SET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_GET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56800_A0_READ_CMIC_SLAM_DMA_PCIMEM_START_ADDRr
#define WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr BCM56800_A0_WRITE_CMIC_SLAM_DMA_PCIMEM_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SLAM_DMA_PCIMEM_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SLAM_DMA_SBUS_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Slam DMA S-bus Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Slam DMA Logical (S-bus) Memory Start Address. This address has the followingfields: table (6b), block (4b) and region+index (20b)
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr 0x00000444

#define BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SLAM_DMA_SBUS_START_ADDR.
 *
 */
typedef union BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_slam_dma_sbus_start_addr[1];
	uint32_t _cmic_slam_dma_sbus_start_addr;
} BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_t;

#define BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR(r) (r).cmic_slam_dma_sbus_start_addr[0] = 0
#define BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SET(r,d) (r).cmic_slam_dma_sbus_start_addr[0] = d
#define BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_GET(r) (r).cmic_slam_dma_sbus_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET(r) ((r).cmic_slam_dma_sbus_start_addr[0])
#define BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET(r,f) (r).cmic_slam_dma_sbus_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_SLAM_DMA_SBUS_START_ADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_SLAM_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr,r._cmic_slam_dma_sbus_start_addr)
#define BCM56800_A0_WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr,r._cmic_slam_dma_sbus_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SIZE
typedef BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_t CMIC_SLAM_DMA_SBUS_START_ADDRr_t;
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_CLR
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_SET BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_SET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_GET BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_GET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_GET
#define CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr_ADDRf_SET
#define READ_CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56800_A0_READ_CMIC_SLAM_DMA_SBUS_START_ADDRr
#define WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr BCM56800_A0_WRITE_CMIC_SLAM_DMA_SBUS_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SLAM_DMA_SBUS_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SOFT_RESET_REG
 * BLOCKS:   CMIC
 * DESC:     CMIC Soft Reset register
 * SIZE:     32
 * FIELDS:
 *     CMIC_GP_RST_L    Gport Reset (active low)
 *     CMIC_GX4_RST_L   GX4 Reset (active low)
 *     RESERVED_0       Reserved
 *     CMIC_XP_RST_L    Xport Reset (active low)
 *     CMIC_XGXS_RST_L  XGXS Reset (active low)
 *     CMIC_MMU_RST_L   MMU Reset (active low)
 *     CMIC_IP_RST_L    IP Reset (active low)
 *     RESERVED_1       Reserved
 *     CMIC_EP_RST_L    EP Reset (active low)
 *     RESERVED_2       Reserved
 *     CMIC_BSAFE_RST_L BSafe Reset (active low)
 *     CMIC_BSAFE_CLKGEN_RST_L BSafe Clkgen Reset (active low)
 *     RESERVED_3       Reserved
 *     CMIC_XG_PLL0_RST_L XG PLL 0 Reset (active low)
 *     CMIC_XG_PLL1_RST_L XG PLL 1 Reset (active low)
 *     RESERVED_4       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SOFT_RESET_REGr 0x00000580

#define BCM56800_A0_CMIC_SOFT_RESET_REGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SOFT_RESET_REG.
 *
 */
typedef union BCM56800_A0_CMIC_SOFT_RESET_REGr_s {
	uint32_t v[1];
	uint32_t cmic_soft_reset_reg[1];
	uint32_t _cmic_soft_reset_reg;
} BCM56800_A0_CMIC_SOFT_RESET_REGr_t;

#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CLR(r) (r).cmic_soft_reset_reg[0] = 0
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_SET(r,d) (r).cmic_soft_reset_reg[0] = d
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_GET(r) (r).cmic_soft_reset_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET(r) (((r).cmic_soft_reset_reg[0]) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 2) & 0x3)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 5) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_2f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 10) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_2f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 11) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 12) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_3f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 13) & 0xf)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_3f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0xf << 13)) | ((((uint32_t)f) & 0xf) << 13))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL0_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL0_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL1_RST_Lf_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL1_RST_Lf_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_4f_GET(r) ((((r).cmic_soft_reset_reg[0]) >> 19) & 0x1fff)
#define BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_4f_SET(r,f) (r).cmic_soft_reset_reg[0]=(((r).cmic_soft_reset_reg[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access CMIC_SOFT_RESET_REG.
 *
 */
#define BCM56800_A0_READ_CMIC_SOFT_RESET_REGr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SOFT_RESET_REGr,r._cmic_soft_reset_reg)
#define BCM56800_A0_WRITE_CMIC_SOFT_RESET_REGr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SOFT_RESET_REGr,r._cmic_soft_reset_reg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SOFT_RESET_REGr BCM56800_A0_CMIC_SOFT_RESET_REGr
#define CMIC_SOFT_RESET_REGr_SIZE BCM56800_A0_CMIC_SOFT_RESET_REGr_SIZE
typedef BCM56800_A0_CMIC_SOFT_RESET_REGr_t CMIC_SOFT_RESET_REGr_t;
#define CMIC_SOFT_RESET_REGr_CLR BCM56800_A0_CMIC_SOFT_RESET_REGr_CLR
#define CMIC_SOFT_RESET_REGr_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_SET
#define CMIC_SOFT_RESET_REGr_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_GP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_GX4_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_0f_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_0f_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_0f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XGXS_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_MMU_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_IP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_1f_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_1f_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_1f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_EP_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_2f_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_2f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_2f_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_2f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_BSAFE_CLKGEN_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_3f_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_3f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_3f_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_3f_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL0_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL0_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL0_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL0_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL1_RST_Lf_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL1_RST_Lf_GET
#define CMIC_SOFT_RESET_REGr_CMIC_XG_PLL1_RST_Lf_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_CMIC_XG_PLL1_RST_Lf_SET
#define CMIC_SOFT_RESET_REGr_RESERVED_4f_GET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_4f_GET
#define CMIC_SOFT_RESET_REGr_RESERVED_4f_SET BCM56800_A0_CMIC_SOFT_RESET_REGr_RESERVED_4f_SET
#define READ_CMIC_SOFT_RESET_REGr BCM56800_A0_READ_CMIC_SOFT_RESET_REGr
#define WRITE_CMIC_SOFT_RESET_REGr BCM56800_A0_WRITE_CMIC_SOFT_RESET_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SOFT_RESET_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_ADDR
 * BLOCKS:   CMIC
 * DESC:     Stats memory start address

 * SIZE:     32
 * FIELDS:
 *     ADDR             Start memory address where the stats counters willbe written to
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_ADDRr 0x00000164

#define BCM56800_A0_CMIC_STAT_DMA_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_ADDR.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_addr[1];
	uint32_t _cmic_stat_dma_addr;
} BCM56800_A0_CMIC_STAT_DMA_ADDRr_t;

#define BCM56800_A0_CMIC_STAT_DMA_ADDRr_CLR(r) (r).cmic_stat_dma_addr[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_ADDRr_SET(r,d) (r).cmic_stat_dma_addr[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_ADDRr_GET(r) (r).cmic_stat_dma_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_ADDRr_ADDRf_GET(r) ((r).cmic_stat_dma_addr[0])
#define BCM56800_A0_CMIC_STAT_DMA_ADDRr_ADDRf_SET(r,f) (r).cmic_stat_dma_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_ADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_ADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_ADDRr,r._cmic_stat_dma_addr)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_ADDRr,r._cmic_stat_dma_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_ADDRr BCM56800_A0_CMIC_STAT_DMA_ADDRr
#define CMIC_STAT_DMA_ADDRr_SIZE BCM56800_A0_CMIC_STAT_DMA_ADDRr_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_ADDRr_t CMIC_STAT_DMA_ADDRr_t;
#define CMIC_STAT_DMA_ADDRr_CLR BCM56800_A0_CMIC_STAT_DMA_ADDRr_CLR
#define CMIC_STAT_DMA_ADDRr_SET BCM56800_A0_CMIC_STAT_DMA_ADDRr_SET
#define CMIC_STAT_DMA_ADDRr_GET BCM56800_A0_CMIC_STAT_DMA_ADDRr_GET
#define CMIC_STAT_DMA_ADDRr_ADDRf_GET BCM56800_A0_CMIC_STAT_DMA_ADDRr_ADDRf_GET
#define CMIC_STAT_DMA_ADDRr_ADDRf_SET BCM56800_A0_CMIC_STAT_DMA_ADDRr_ADDRf_SET
#define READ_CMIC_STAT_DMA_ADDRr BCM56800_A0_READ_CMIC_STAT_DMA_ADDRr
#define WRITE_CMIC_STAT_DMA_ADDRr BCM56800_A0_WRITE_CMIC_STAT_DMA_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_15_8
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 15 to 8

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_8    S-bus block number for port  8
 *     SBUS_BLKNUM_9    S-bus block number for port  9
 *     SBUS_BLKNUM_10   S-bus block number for port 10
 *     SBUS_BLKNUM_11   S-bus block number for port 11
 *     SBUS_BLKNUM_12   S-bus block number for port 12
 *     SBUS_BLKNUM_13   S-bus block number for port 13
 *     SBUS_BLKNUM_14   S-bus block number for port 14
 *     SBUS_BLKNUM_15   S-bus block number for port 15
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r 0x00000484

#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_15_8.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_15_8[1];
	uint32_t _cmic_stat_dma_blknum_map_15_8;
} BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t;

#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR(r) (r).cmic_stat_dma_blknum_map_15_8[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET(r,d) (r).cmic_stat_dma_blknum_map_15_8[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET(r) (r).cmic_stat_dma_blknum_map_15_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET(r) (((r).cmic_stat_dma_blknum_map_15_8[0]) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 8) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 12) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 16) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 20) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 24) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET(r) ((((r).cmic_stat_dma_blknum_map_15_8[0]) >> 28) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET(r,f) (r).cmic_stat_dma_blknum_map_15_8[0]=(((r).cmic_stat_dma_blknum_map_15_8[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_15_8.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r,r._cmic_stat_dma_blknum_map_15_8)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r,r._cmic_stat_dma_blknum_map_15_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t CMIC_STAT_DMA_BLKNUM_MAP_15_8r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_8f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_9f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_10f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_11f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_12f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_13f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_14f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r_SBUS_BLKNUM_15f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56800_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_15_8r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r BCM56800_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_15_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_15_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_23_16
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 23 to 16

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_16   S-bus block number for port 16
 *     SBUS_BLKNUM_17   S-bus block number for port 17
 *     SBUS_BLKNUM_18   S-bus block number for port 18
 *     SBUS_BLKNUM_19   S-bus block number for port 19
 *     SBUS_BLKNUM_20   S-bus block number for port 20
 *     SBUS_BLKNUM_21   S-bus block number for port 21
 *     SBUS_BLKNUM_22   S-bus block number for port 22
 *     SBUS_BLKNUM_23   S-bus block number for port 23
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r 0x00000488

#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_23_16.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_23_16[1];
	uint32_t _cmic_stat_dma_blknum_map_23_16;
} BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t;

#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR(r) (r).cmic_stat_dma_blknum_map_23_16[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET(r,d) (r).cmic_stat_dma_blknum_map_23_16[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET(r) (r).cmic_stat_dma_blknum_map_23_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET(r) (((r).cmic_stat_dma_blknum_map_23_16[0]) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 8) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 12) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 16) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 20) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 24) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET(r) ((((r).cmic_stat_dma_blknum_map_23_16[0]) >> 28) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET(r,f) (r).cmic_stat_dma_blknum_map_23_16[0]=(((r).cmic_stat_dma_blknum_map_23_16[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_23_16.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r,r._cmic_stat_dma_blknum_map_23_16)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r,r._cmic_stat_dma_blknum_map_23_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t CMIC_STAT_DMA_BLKNUM_MAP_23_16r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_16f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_17f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_18f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_19f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_20f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_21f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_22f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r_SBUS_BLKNUM_23f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56800_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_23_16r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r BCM56800_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_23_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_23_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_31_24
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 31 to 24

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_24   S-bus block number for port 24
 *     SBUS_BLKNUM_25   S-bus block number for port 25
 *     SBUS_BLKNUM_26   S-bus block number for port 26
 *     SBUS_BLKNUM_27   S-bus block number for port 27
 *     SBUS_BLKNUM_28   S-bus block number for port 28
 *     SBUS_BLKNUM_29   S-bus block number for port 29
 *     SBUS_BLKNUM_30   S-bus block number for port 30
 *     SBUS_BLKNUM_31   S-bus block number for port 31
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r 0x0000048c

#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_31_24.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_31_24[1];
	uint32_t _cmic_stat_dma_blknum_map_31_24;
} BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t;

#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR(r) (r).cmic_stat_dma_blknum_map_31_24[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET(r,d) (r).cmic_stat_dma_blknum_map_31_24[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET(r) (r).cmic_stat_dma_blknum_map_31_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET(r) (((r).cmic_stat_dma_blknum_map_31_24[0]) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 8) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 12) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 16) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 20) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 24) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET(r) ((((r).cmic_stat_dma_blknum_map_31_24[0]) >> 28) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET(r,f) (r).cmic_stat_dma_blknum_map_31_24[0]=(((r).cmic_stat_dma_blknum_map_31_24[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_31_24.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r,r._cmic_stat_dma_blknum_map_31_24)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r,r._cmic_stat_dma_blknum_map_31_24)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t CMIC_STAT_DMA_BLKNUM_MAP_31_24r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_24f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_25f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_26f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_27f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_28f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_29f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_30f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r_SBUS_BLKNUM_31f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56800_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_31_24r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r BCM56800_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_31_24r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_31_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_BLKNUM_MAP_7_0
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> block-number map, ports 7 to 0

 * SIZE:     32
 * FIELDS:
 *     SBUS_BLKNUM_0    S-bus block number for port 0
 *     SBUS_BLKNUM_1    S-bus block number for port 1
 *     SBUS_BLKNUM_2    S-bus block number for port 2
 *     SBUS_BLKNUM_3    S-bus block number for port 3
 *     SBUS_BLKNUM_4    S-bus block number for port 4
 *     SBUS_BLKNUM_5    S-bus block number for port 5
 *     SBUS_BLKNUM_6    S-bus block number for port 6
 *     SBUS_BLKNUM_7    S-bus block number for port 7
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r 0x00000480

#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_BLKNUM_MAP_7_0.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_blknum_map_7_0[1];
	uint32_t _cmic_stat_dma_blknum_map_7_0;
} BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t;

#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR(r) (r).cmic_stat_dma_blknum_map_7_0[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET(r,d) (r).cmic_stat_dma_blknum_map_7_0[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET(r) (r).cmic_stat_dma_blknum_map_7_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET(r) (((r).cmic_stat_dma_blknum_map_7_0[0]) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 8) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 12) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 16) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 20) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 24) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET(r) ((((r).cmic_stat_dma_blknum_map_7_0[0]) >> 28) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET(r,f) (r).cmic_stat_dma_blknum_map_7_0[0]=(((r).cmic_stat_dma_blknum_map_7_0[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_STAT_DMA_BLKNUM_MAP_7_0.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r,r._cmic_stat_dma_blknum_map_7_0)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r,r._cmic_stat_dma_blknum_map_7_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t CMIC_STAT_DMA_BLKNUM_MAP_7_0r_t;
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_CLR
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_0f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_1f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_2f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_3f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_4f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_5f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_6f_SET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_GET
#define CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r_SBUS_BLKNUM_7f_SET
#define READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56800_A0_READ_CMIC_STAT_DMA_BLKNUM_MAP_7_0r
#define WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r BCM56800_A0_WRITE_CMIC_STAT_DMA_BLKNUM_MAP_7_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_BLKNUM_MAP_7_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_CURRENT
 * BLOCKS:   CMIC
 * DESC:     Current Stat Counter Value Register
 * SIZE:     32
 * FIELDS:
 *     DATA             Address of Stat counter currently being processed bythe Stats DMA engine
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_CURRENTr 0x00000170

#define BCM56800_A0_CMIC_STAT_DMA_CURRENTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_CURRENT.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_CURRENTr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_current[1];
	uint32_t _cmic_stat_dma_current;
} BCM56800_A0_CMIC_STAT_DMA_CURRENTr_t;

#define BCM56800_A0_CMIC_STAT_DMA_CURRENTr_CLR(r) (r).cmic_stat_dma_current[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_CURRENTr_SET(r,d) (r).cmic_stat_dma_current[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_CURRENTr_GET(r) (r).cmic_stat_dma_current[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_CURRENTr_DATAf_GET(r) ((r).cmic_stat_dma_current[0])
#define BCM56800_A0_CMIC_STAT_DMA_CURRENTr_DATAf_SET(r,f) (r).cmic_stat_dma_current[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_CURRENT.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_CURRENTr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_CURRENTr,r._cmic_stat_dma_current)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_CURRENTr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_CURRENTr,r._cmic_stat_dma_current)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_CURRENTr BCM56800_A0_CMIC_STAT_DMA_CURRENTr
#define CMIC_STAT_DMA_CURRENTr_SIZE BCM56800_A0_CMIC_STAT_DMA_CURRENTr_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_CURRENTr_t CMIC_STAT_DMA_CURRENTr_t;
#define CMIC_STAT_DMA_CURRENTr_CLR BCM56800_A0_CMIC_STAT_DMA_CURRENTr_CLR
#define CMIC_STAT_DMA_CURRENTr_SET BCM56800_A0_CMIC_STAT_DMA_CURRENTr_SET
#define CMIC_STAT_DMA_CURRENTr_GET BCM56800_A0_CMIC_STAT_DMA_CURRENTr_GET
#define CMIC_STAT_DMA_CURRENTr_DATAf_GET BCM56800_A0_CMIC_STAT_DMA_CURRENTr_DATAf_GET
#define CMIC_STAT_DMA_CURRENTr_DATAf_SET BCM56800_A0_CMIC_STAT_DMA_CURRENTr_DATAf_SET
#define READ_CMIC_STAT_DMA_CURRENTr BCM56800_A0_READ_CMIC_STAT_DMA_CURRENTr
#define WRITE_CMIC_STAT_DMA_CURRENTr BCM56800_A0_WRITE_CMIC_STAT_DMA_CURRENTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_CURRENTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_EGR_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA Egress stats config register
 * SIZE:     32
 * FIELDS:
 *     EGR_ETH_BLK_NUM  S-bus block number of Egress for stats counters
 *     RESERVED_1       Reserved
 *     EGR_STAT_COUNTERS_NUM Number of Egress Stats counters per port
 *     RESERVED_2       Reserved
 *     EGR_STATS_PIPELINE_STAGE_NUM Egress pipeline stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr 0x00000464

#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_EGR_STATS_CFG.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_egr_stats_cfg[1];
	uint32_t _cmic_stat_dma_egr_stats_cfg;
} BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_t;

#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_CLR(r) (r).cmic_stat_dma_egr_stats_cfg[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_egr_stats_cfg[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_GET(r) (r).cmic_stat_dma_egr_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET(r) (((r).cmic_stat_dma_egr_stats_cfg[0]) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 8) & 0x3f)
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 14) & 0x3)
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_egr_stats_cfg[0]) >> 22) & 0x3ff)
#define BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_egr_stats_cfg[0]=(((r).cmic_stat_dma_egr_stats_cfg[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_STAT_DMA_EGR_STATS_CFG.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_EGR_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr,r._cmic_stat_dma_egr_stats_cfg)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr,r._cmic_stat_dma_egr_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_EGR_STATS_CFGr BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr
#define CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_t CMIC_STAT_DMA_EGR_STATS_CFGr_t;
#define CMIC_STAT_DMA_EGR_STATS_CFGr_CLR BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_CLR
#define CMIC_STAT_DMA_EGR_STATS_CFGr_SET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_GET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_ETH_BLK_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_EGR_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr_RESERVED_3f_SET
#define READ_CMIC_STAT_DMA_EGR_STATS_CFGr BCM56800_A0_READ_CMIC_STAT_DMA_EGR_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr BCM56800_A0_WRITE_CMIC_STAT_DMA_EGR_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_EGR_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_ING_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA Ingress stats config register
 * SIZE:     32
 * FIELDS:
 *     ING_ETH_BLK_NUM  S-bus block number of Ingress for stats counters
 *     RESERVED_1       Reserved
 *     ING_STAT_COUNTERS_NUM Number of Ingress Stats counters per port
 *     RESERVED_2       Reserved
 *     ING_STATS_PIPELINE_STAGE_NUM Ingress pipeline stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr 0x00000460

#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_ING_STATS_CFG.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ing_stats_cfg[1];
	uint32_t _cmic_stat_dma_ing_stats_cfg;
} BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_t;

#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_CLR(r) (r).cmic_stat_dma_ing_stats_cfg[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_ing_stats_cfg[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_GET(r) (r).cmic_stat_dma_ing_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET(r) (((r).cmic_stat_dma_ing_stats_cfg[0]) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 8) & 0x3f)
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 14) & 0x3)
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_ing_stats_cfg[0]) >> 22) & 0x3ff)
#define BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_ing_stats_cfg[0]=(((r).cmic_stat_dma_ing_stats_cfg[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access CMIC_STAT_DMA_ING_STATS_CFG.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_ING_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr,r._cmic_stat_dma_ing_stats_cfg)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_ING_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr,r._cmic_stat_dma_ing_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_ING_STATS_CFGr BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr
#define CMIC_STAT_DMA_ING_STATS_CFGr_SIZE BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_t CMIC_STAT_DMA_ING_STATS_CFGr_t;
#define CMIC_STAT_DMA_ING_STATS_CFGr_CLR BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_CLR
#define CMIC_STAT_DMA_ING_STATS_CFGr_SET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_GET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_ETH_BLK_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_1f_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_2f_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_ING_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr_RESERVED_3f_SET
#define READ_CMIC_STAT_DMA_ING_STATS_CFGr BCM56800_A0_READ_CMIC_STAT_DMA_ING_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_ING_STATS_CFGr BCM56800_A0_WRITE_CMIC_STAT_DMA_ING_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_ING_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_MAC_STATS_CFG
 * BLOCKS:   CMIC
 * DESC:     Stats DMA MAC stats config register
 * SIZE:     32
 * FIELDS:
 *     MAC_G_STAT_COUNTERS_NUM Number of MAC GPORT Stats counters per port
 *     MAC_X_STAT_COUNTERS_NUM Number of MAC XPORT Stats counters per port
 *     MAC_STATS_PIPELINE_STAGE_NUM MAC stats counter stage number (if any), 
 *     RESERVED_3       Reserved
 *     CPU_STATS_PORT_NUM CPU Port number (for Stats DMA purposes), 
 *     RESERVED_4       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr 0x00000468

#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_MAC_STATS_CFG.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_mac_stats_cfg[1];
	uint32_t _cmic_stat_dma_mac_stats_cfg;
} BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_t;

#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CLR(r) (r).cmic_stat_dma_mac_stats_cfg[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SET(r,d) (r).cmic_stat_dma_mac_stats_cfg[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_GET(r) (r).cmic_stat_dma_mac_stats_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET(r) (((r).cmic_stat_dma_mac_stats_cfg[0]) & 0xff)
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 8) & 0xff)
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 16) & 0x3f)
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 22) & 0x3)
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 24) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_GET(r) ((((r).cmic_stat_dma_mac_stats_cfg[0]) >> 29) & 0x7)
#define BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_SET(r,f) (r).cmic_stat_dma_mac_stats_cfg[0]=(((r).cmic_stat_dma_mac_stats_cfg[0] & ~((uint32_t)0x7 << 29)) | ((((uint32_t)f) & 0x7) << 29))

/*
 * These macros can be used to access CMIC_STAT_DMA_MAC_STATS_CFG.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_MAC_STATS_CFGr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr,r._cmic_stat_dma_mac_stats_cfg)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr,r._cmic_stat_dma_mac_stats_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_MAC_STATS_CFGr BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr
#define CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_t CMIC_STAT_DMA_MAC_STATS_CFGr_t;
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CLR BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CLR
#define CMIC_STAT_DMA_MAC_STATS_CFGr_SET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_GET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_G_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_X_STAT_COUNTERS_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_MAC_STATS_PIPELINE_STAGE_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_GET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_SET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_3f_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_CPU_STATS_PORT_NUMf_SET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_GET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_GET
#define CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_SET BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr_RESERVED_4f_SET
#define READ_CMIC_STAT_DMA_MAC_STATS_CFGr BCM56800_A0_READ_CMIC_STAT_DMA_MAC_STATS_CFGr
#define WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr BCM56800_A0_WRITE_CMIC_STAT_DMA_MAC_STATS_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_MAC_STATS_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_11_6
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 11 to 6

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_6   S-bus port number for port  6
 *     SBUS_PORTNUM_7   S-bus port number for port 7
 *     SBUS_PORTNUM_8   S-bus port number for port 8
 *     SBUS_PORTNUM_9   S-bus port number for port 9
 *     SBUS_PORTNUM_10  S-bus port number for port 10
 *     SBUS_PORTNUM_11  S-bus port number for port 10
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r 0x00000494

#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_11_6.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_11_6[1];
	uint32_t _cmic_stat_dma_portnum_map_11_6;
} BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_t;

#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_CLR(r) (r).cmic_stat_dma_portnum_map_11_6[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SET(r,d) (r).cmic_stat_dma_portnum_map_11_6[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_GET(r) (r).cmic_stat_dma_portnum_map_11_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_6f_GET(r) (((r).cmic_stat_dma_portnum_map_11_6[0]) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_6f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_6[0]=(((r).cmic_stat_dma_portnum_map_11_6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_7f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_6[0]) >> 5) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_7f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_6[0]=(((r).cmic_stat_dma_portnum_map_11_6[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_8f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_6[0]) >> 10) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_8f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_6[0]=(((r).cmic_stat_dma_portnum_map_11_6[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_9f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_6[0]) >> 15) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_9f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_6[0]=(((r).cmic_stat_dma_portnum_map_11_6[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_10f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_6[0]) >> 20) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_10f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_6[0]=(((r).cmic_stat_dma_portnum_map_11_6[0] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_11f_GET(r) ((((r).cmic_stat_dma_portnum_map_11_6[0]) >> 25) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_11f_SET(r,f) (r).cmic_stat_dma_portnum_map_11_6[0]=(((r).cmic_stat_dma_portnum_map_11_6[0] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_RESERVEDf_GET(r) ((((r).cmic_stat_dma_portnum_map_11_6[0]) >> 30) & 0x3)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_RESERVEDf_SET(r,f) (r).cmic_stat_dma_portnum_map_11_6[0]=(((r).cmic_stat_dma_portnum_map_11_6[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_11_6.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_11_6r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r,r._cmic_stat_dma_portnum_map_11_6)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_6r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r,r._cmic_stat_dma_portnum_map_11_6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SIZE BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_t CMIC_STAT_DMA_PORTNUM_MAP_11_6r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_CLR BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_6f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_6f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_6f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_6f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_7f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_7f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_7f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_7f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_8f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_8f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_8f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_8f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_9f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_9f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_9f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_9f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_10f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_10f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_10f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_10f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_11f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_11f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_11f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_SBUS_PORTNUM_11f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_RESERVEDf_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_RESERVEDf_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_11_6r_RESERVEDf_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r_RESERVEDf_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_11_6r BCM56800_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_11_6r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_6r BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_11_6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_11_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_17_12
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 17 to 12

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_12  S-bus port number for port 12
 *     SBUS_PORTNUM_13  S-bus port number for port 13
 *     SBUS_PORTNUM_14  S-bus port number for port 14
 *     SBUS_PORTNUM_15  S-bus port number for port 15
 *     SBUS_PORTNUM_16  S-bus port number for port 16
 *     SBUS_PORTNUM_17  S-bus port number for port 17
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r 0x00000498

#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_17_12.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_17_12[1];
	uint32_t _cmic_stat_dma_portnum_map_17_12;
} BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_t;

#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_CLR(r) (r).cmic_stat_dma_portnum_map_17_12[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SET(r,d) (r).cmic_stat_dma_portnum_map_17_12[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_GET(r) (r).cmic_stat_dma_portnum_map_17_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_12f_GET(r) (((r).cmic_stat_dma_portnum_map_17_12[0]) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_12f_SET(r,f) (r).cmic_stat_dma_portnum_map_17_12[0]=(((r).cmic_stat_dma_portnum_map_17_12[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_13f_GET(r) ((((r).cmic_stat_dma_portnum_map_17_12[0]) >> 5) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_13f_SET(r,f) (r).cmic_stat_dma_portnum_map_17_12[0]=(((r).cmic_stat_dma_portnum_map_17_12[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_14f_GET(r) ((((r).cmic_stat_dma_portnum_map_17_12[0]) >> 10) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_14f_SET(r,f) (r).cmic_stat_dma_portnum_map_17_12[0]=(((r).cmic_stat_dma_portnum_map_17_12[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_15f_GET(r) ((((r).cmic_stat_dma_portnum_map_17_12[0]) >> 15) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_15f_SET(r,f) (r).cmic_stat_dma_portnum_map_17_12[0]=(((r).cmic_stat_dma_portnum_map_17_12[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_16f_GET(r) ((((r).cmic_stat_dma_portnum_map_17_12[0]) >> 20) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_16f_SET(r,f) (r).cmic_stat_dma_portnum_map_17_12[0]=(((r).cmic_stat_dma_portnum_map_17_12[0] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_17f_GET(r) ((((r).cmic_stat_dma_portnum_map_17_12[0]) >> 25) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_17f_SET(r,f) (r).cmic_stat_dma_portnum_map_17_12[0]=(((r).cmic_stat_dma_portnum_map_17_12[0] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_RESERVEDf_GET(r) ((((r).cmic_stat_dma_portnum_map_17_12[0]) >> 30) & 0x3)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_RESERVEDf_SET(r,f) (r).cmic_stat_dma_portnum_map_17_12[0]=(((r).cmic_stat_dma_portnum_map_17_12[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_17_12.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_17_12r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r,r._cmic_stat_dma_portnum_map_17_12)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_17_12r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r,r._cmic_stat_dma_portnum_map_17_12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SIZE BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_t CMIC_STAT_DMA_PORTNUM_MAP_17_12r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_CLR BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_12f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_12f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_12f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_12f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_13f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_13f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_13f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_13f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_14f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_14f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_14f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_14f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_15f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_15f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_15f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_15f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_16f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_16f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_16f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_16f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_17f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_17f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_17f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_SBUS_PORTNUM_17f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_RESERVEDf_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_RESERVEDf_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_17_12r_RESERVEDf_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r_RESERVEDf_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_17_12r BCM56800_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_17_12r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_17_12r BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_17_12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_17_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_23_18
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 18 to 23

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_18  S-bus port number for port 18
 *     SBUS_PORTNUM_19  S-bus port number for port 19
 *     SBUS_PORTNUM_20  S-bus port number for port 20
 *     SBUS_PORTNUM_21  S-bus port number for port 21
 *     SBUS_PORTNUM_22  S-bus port number for port 22
 *     SBUS_PORTNUM_23  S-bus port number for port 23
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r 0x0000049c

#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_23_18.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_23_18[1];
	uint32_t _cmic_stat_dma_portnum_map_23_18;
} BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_t;

#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_CLR(r) (r).cmic_stat_dma_portnum_map_23_18[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SET(r,d) (r).cmic_stat_dma_portnum_map_23_18[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_GET(r) (r).cmic_stat_dma_portnum_map_23_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_18f_GET(r) (((r).cmic_stat_dma_portnum_map_23_18[0]) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_18f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_18[0]=(((r).cmic_stat_dma_portnum_map_23_18[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_19f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_18[0]) >> 5) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_19f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_18[0]=(((r).cmic_stat_dma_portnum_map_23_18[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_20f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_18[0]) >> 10) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_20f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_18[0]=(((r).cmic_stat_dma_portnum_map_23_18[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_21f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_18[0]) >> 15) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_21f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_18[0]=(((r).cmic_stat_dma_portnum_map_23_18[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_22f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_18[0]) >> 20) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_22f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_18[0]=(((r).cmic_stat_dma_portnum_map_23_18[0] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_23f_GET(r) ((((r).cmic_stat_dma_portnum_map_23_18[0]) >> 25) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_23f_SET(r,f) (r).cmic_stat_dma_portnum_map_23_18[0]=(((r).cmic_stat_dma_portnum_map_23_18[0] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_RESERVEDf_GET(r) ((((r).cmic_stat_dma_portnum_map_23_18[0]) >> 30) & 0x3)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_RESERVEDf_SET(r,f) (r).cmic_stat_dma_portnum_map_23_18[0]=(((r).cmic_stat_dma_portnum_map_23_18[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_23_18.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_23_18r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r,r._cmic_stat_dma_portnum_map_23_18)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_18r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r,r._cmic_stat_dma_portnum_map_23_18)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SIZE BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_t CMIC_STAT_DMA_PORTNUM_MAP_23_18r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_CLR BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_18f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_18f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_18f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_18f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_19f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_19f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_19f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_19f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_20f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_20f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_20f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_20f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_21f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_21f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_21f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_21f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_22f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_22f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_22f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_22f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_23f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_23f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_23f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_SBUS_PORTNUM_23f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_RESERVEDf_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_RESERVEDf_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_23_18r_RESERVEDf_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r_RESERVEDf_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_23_18r BCM56800_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_23_18r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_18r BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_23_18r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_23_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_PORTNUM_MAP_5_0
 * BLOCKS:   CMIC
 * DESC:     Stats DMA port <-> port-number map, ports 5 to 0

 * SIZE:     32
 * FIELDS:
 *     SBUS_PORTNUM_0   S-bus port number for port 0
 *     SBUS_PORTNUM_1   S-bus port number for port 1
 *     SBUS_PORTNUM_2   S-bus port number for port 2
 *     SBUS_PORTNUM_3   S-bus port number for port 3
 *     SBUS_PORTNUM_4   S-bus port number for port 4
 *     SBUS_PORTNUM_5   S-bus port number for port 5
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r 0x00000490

#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTNUM_MAP_5_0.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_portnum_map_5_0[1];
	uint32_t _cmic_stat_dma_portnum_map_5_0;
} BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_t;

#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_CLR(r) (r).cmic_stat_dma_portnum_map_5_0[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SET(r,d) (r).cmic_stat_dma_portnum_map_5_0[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_GET(r) (r).cmic_stat_dma_portnum_map_5_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_0f_GET(r) (((r).cmic_stat_dma_portnum_map_5_0[0]) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_0f_SET(r,f) (r).cmic_stat_dma_portnum_map_5_0[0]=(((r).cmic_stat_dma_portnum_map_5_0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_1f_GET(r) ((((r).cmic_stat_dma_portnum_map_5_0[0]) >> 5) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_1f_SET(r,f) (r).cmic_stat_dma_portnum_map_5_0[0]=(((r).cmic_stat_dma_portnum_map_5_0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_2f_GET(r) ((((r).cmic_stat_dma_portnum_map_5_0[0]) >> 10) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_2f_SET(r,f) (r).cmic_stat_dma_portnum_map_5_0[0]=(((r).cmic_stat_dma_portnum_map_5_0[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_3f_GET(r) ((((r).cmic_stat_dma_portnum_map_5_0[0]) >> 15) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_3f_SET(r,f) (r).cmic_stat_dma_portnum_map_5_0[0]=(((r).cmic_stat_dma_portnum_map_5_0[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_4f_GET(r) ((((r).cmic_stat_dma_portnum_map_5_0[0]) >> 20) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_4f_SET(r,f) (r).cmic_stat_dma_portnum_map_5_0[0]=(((r).cmic_stat_dma_portnum_map_5_0[0] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_5f_GET(r) ((((r).cmic_stat_dma_portnum_map_5_0[0]) >> 25) & 0x1f)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_5f_SET(r,f) (r).cmic_stat_dma_portnum_map_5_0[0]=(((r).cmic_stat_dma_portnum_map_5_0[0] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_RESERVEDf_GET(r) ((((r).cmic_stat_dma_portnum_map_5_0[0]) >> 30) & 0x3)
#define BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_RESERVEDf_SET(r,f) (r).cmic_stat_dma_portnum_map_5_0[0]=(((r).cmic_stat_dma_portnum_map_5_0[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTNUM_MAP_5_0.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_5_0r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r,r._cmic_stat_dma_portnum_map_5_0)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_5_0r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r,r._cmic_stat_dma_portnum_map_5_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SIZE BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_t CMIC_STAT_DMA_PORTNUM_MAP_5_0r_t;
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_CLR BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_CLR
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_0f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_0f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_0f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_0f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_1f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_1f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_1f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_1f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_2f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_2f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_2f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_2f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_3f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_3f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_3f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_3f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_4f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_4f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_4f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_4f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_5f_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_5f_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_5f_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_SBUS_PORTNUM_5f_SET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_RESERVEDf_GET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_RESERVEDf_GET
#define CMIC_STAT_DMA_PORTNUM_MAP_5_0r_RESERVEDf_SET BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r_RESERVEDf_SET
#define READ_CMIC_STAT_DMA_PORTNUM_MAP_5_0r BCM56800_A0_READ_CMIC_STAT_DMA_PORTNUM_MAP_5_0r
#define WRITE_CMIC_STAT_DMA_PORTNUM_MAP_5_0r BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTNUM_MAP_5_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_PORTNUM_MAP_5_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_PORTS
 * BLOCKS:   CMIC
 * DESC:     Stat Counter Port Bit Map Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Stat Counter Port Bit Map
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_PORTSr 0x0000016c

#define BCM56800_A0_CMIC_STAT_DMA_PORTSr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORTS.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_PORTSr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_ports[1];
	uint32_t _cmic_stat_dma_ports;
} BCM56800_A0_CMIC_STAT_DMA_PORTSr_t;

#define BCM56800_A0_CMIC_STAT_DMA_PORTSr_CLR(r) (r).cmic_stat_dma_ports[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_PORTSr_SET(r,d) (r).cmic_stat_dma_ports[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_PORTSr_GET(r) (r).cmic_stat_dma_ports[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_GET(r) ((r).cmic_stat_dma_ports[0])
#define BCM56800_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_SET(r,f) (r).cmic_stat_dma_ports[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORTS.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_PORTSr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_PORTSr,r._cmic_stat_dma_ports)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTSr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_PORTSr,r._cmic_stat_dma_ports)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORTSr BCM56800_A0_CMIC_STAT_DMA_PORTSr
#define CMIC_STAT_DMA_PORTSr_SIZE BCM56800_A0_CMIC_STAT_DMA_PORTSr_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_PORTSr_t CMIC_STAT_DMA_PORTSr_t;
#define CMIC_STAT_DMA_PORTSr_CLR BCM56800_A0_CMIC_STAT_DMA_PORTSr_CLR
#define CMIC_STAT_DMA_PORTSr_SET BCM56800_A0_CMIC_STAT_DMA_PORTSr_SET
#define CMIC_STAT_DMA_PORTSr_GET BCM56800_A0_CMIC_STAT_DMA_PORTSr_GET
#define CMIC_STAT_DMA_PORTSr_BITMAPf_GET BCM56800_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_GET
#define CMIC_STAT_DMA_PORTSr_BITMAPf_SET BCM56800_A0_CMIC_STAT_DMA_PORTSr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORTSr BCM56800_A0_READ_CMIC_STAT_DMA_PORTSr
#define WRITE_CMIC_STAT_DMA_PORTSr BCM56800_A0_WRITE_CMIC_STAT_DMA_PORTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_PORTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_PORT_TYPE_MAP
 * BLOCKS:   CMIC
 * DESC:     Port type bitmap for Stat DMA: 0=Gig port, 1=Higig port
Note: The bitmap is index by port number.

 * SIZE:     32
 * FIELDS:
 *     BITMAP           0 bits are   Gig ports, so get MAC_G_STAT_COUNTERS_NUM counters1 bits are Higig ports, so get MAC_X_STAT_COUNTERS_NUM counters
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr 0x0000046c

#define BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_PORT_TYPE_MAP.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_port_type_map[1];
	uint32_t _cmic_stat_dma_port_type_map;
} BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_t;

#define BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR(r) (r).cmic_stat_dma_port_type_map[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SET(r,d) (r).cmic_stat_dma_port_type_map[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_GET(r) (r).cmic_stat_dma_port_type_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET(r) ((r).cmic_stat_dma_port_type_map[0])
#define BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET(r,f) (r).cmic_stat_dma_port_type_map[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_STAT_DMA_PORT_TYPE_MAP.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAPr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr,r._cmic_stat_dma_port_type_map)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr,r._cmic_stat_dma_port_type_map)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_t CMIC_STAT_DMA_PORT_TYPE_MAPr_t;
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_CLR
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_SET BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_SET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_GET BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_GET
#define CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr_BITMAPf_SET
#define READ_CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56800_A0_READ_CMIC_STAT_DMA_PORT_TYPE_MAPr
#define WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr BCM56800_A0_WRITE_CMIC_STAT_DMA_PORT_TYPE_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_PORT_TYPE_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_STAT_DMA_SETUP
 * BLOCKS:   CMIC
 * DESC:     Stat Counter DMA Access Setup Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_1       Reserved
 *     TIME_VAL         Timer Value
 *     E_T              Enable Timer
 *     EN               Enable DMA
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr 0x00000168

#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_STAT_DMA_SETUP.
 *
 */
typedef union BCM56800_A0_CMIC_STAT_DMA_SETUPr_s {
	uint32_t v[1];
	uint32_t cmic_stat_dma_setup[1];
	uint32_t _cmic_stat_dma_setup;
} BCM56800_A0_CMIC_STAT_DMA_SETUPr_t;

#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_CLR(r) (r).cmic_stat_dma_setup[0] = 0
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_SET(r,d) (r).cmic_stat_dma_setup[0] = d
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_GET(r) (r).cmic_stat_dma_setup[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET(r) (((r).cmic_stat_dma_setup[0]) & 0xffff)
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 16) & 0x3fff)
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x3fff << 16)) | ((((uint32_t)f) & 0x3fff) << 16))
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_E_Tf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 30) & 0x1)
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_E_Tf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_ENf_GET(r) ((((r).cmic_stat_dma_setup[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_STAT_DMA_SETUPr_ENf_SET(r,f) (r).cmic_stat_dma_setup[0]=(((r).cmic_stat_dma_setup[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_STAT_DMA_SETUP.
 *
 */
#define BCM56800_A0_READ_CMIC_STAT_DMA_SETUPr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_STAT_DMA_SETUPr,r._cmic_stat_dma_setup)
#define BCM56800_A0_WRITE_CMIC_STAT_DMA_SETUPr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_STAT_DMA_SETUPr,r._cmic_stat_dma_setup)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_STAT_DMA_SETUPr BCM56800_A0_CMIC_STAT_DMA_SETUPr
#define CMIC_STAT_DMA_SETUPr_SIZE BCM56800_A0_CMIC_STAT_DMA_SETUPr_SIZE
typedef BCM56800_A0_CMIC_STAT_DMA_SETUPr_t CMIC_STAT_DMA_SETUPr_t;
#define CMIC_STAT_DMA_SETUPr_CLR BCM56800_A0_CMIC_STAT_DMA_SETUPr_CLR
#define CMIC_STAT_DMA_SETUPr_SET BCM56800_A0_CMIC_STAT_DMA_SETUPr_SET
#define CMIC_STAT_DMA_SETUPr_GET BCM56800_A0_CMIC_STAT_DMA_SETUPr_GET
#define CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET BCM56800_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_GET
#define CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET BCM56800_A0_CMIC_STAT_DMA_SETUPr_RESERVED_1f_SET
#define CMIC_STAT_DMA_SETUPr_TIME_VALf_GET BCM56800_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_GET
#define CMIC_STAT_DMA_SETUPr_TIME_VALf_SET BCM56800_A0_CMIC_STAT_DMA_SETUPr_TIME_VALf_SET
#define CMIC_STAT_DMA_SETUPr_E_Tf_GET BCM56800_A0_CMIC_STAT_DMA_SETUPr_E_Tf_GET
#define CMIC_STAT_DMA_SETUPr_E_Tf_SET BCM56800_A0_CMIC_STAT_DMA_SETUPr_E_Tf_SET
#define CMIC_STAT_DMA_SETUPr_ENf_GET BCM56800_A0_CMIC_STAT_DMA_SETUPr_ENf_GET
#define CMIC_STAT_DMA_SETUPr_ENf_SET BCM56800_A0_CMIC_STAT_DMA_SETUPr_ENf_SET
#define READ_CMIC_STAT_DMA_SETUPr BCM56800_A0_READ_CMIC_STAT_DMA_SETUPr
#define WRITE_CMIC_STAT_DMA_SETUPr BCM56800_A0_WRITE_CMIC_STAT_DMA_SETUPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_STAT_DMA_SETUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_SW_PIO_ACK_DATA_BEAT_COUNT
 * BLOCKS:   CMIC
 * DESC:     Debug register that provides the number of data
beats in the last SW PIO S-bus ACK

 * SIZE:     32
 * FIELDS:
 *     BEAT_COUNT       Beat count
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr 0x00000404

#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_SW_PIO_ACK_DATA_BEAT_COUNT.
 *
 */
typedef union BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_sw_pio_ack_data_beat_count[1];
	uint32_t _cmic_sw_pio_ack_data_beat_count;
} BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t;

#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR(r) (r).cmic_sw_pio_ack_data_beat_count[0] = 0
#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET(r,d) (r).cmic_sw_pio_ack_data_beat_count[0] = d
#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET(r) (r).cmic_sw_pio_ack_data_beat_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET(r) (((r).cmic_sw_pio_ack_data_beat_count[0]) & 0x1f)
#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET(r,f) (r).cmic_sw_pio_ack_data_beat_count[0]=(((r).cmic_sw_pio_ack_data_beat_count[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET(r) ((((r).cmic_sw_pio_ack_data_beat_count[0]) >> 5) & 0x7ffffff)
#define BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET(r,f) (r).cmic_sw_pio_ack_data_beat_count[0]=(((r).cmic_sw_pio_ack_data_beat_count[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_SW_PIO_ACK_DATA_BEAT_COUNT.
 *
 */
#define BCM56800_A0_READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr,r._cmic_sw_pio_ack_data_beat_count)
#define BCM56800_A0_WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr,r._cmic_sw_pio_ack_data_beat_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SIZE
typedef BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_t;
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_CLR
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_SET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_BEAT_COUNTf_SET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_GET
#define CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr_RESERVED_0f_SET
#define READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56800_A0_READ_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr
#define WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr BCM56800_A0_WRITE_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_SW_PIO_ACK_DATA_BEAT_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TABLE_DMA_CFG
 * BLOCKS:   CMIC
 * DESC:     Table DMA Config Register
 * SIZE:     32
 * FIELDS:
 *     EN               Set by CPU to Enable Table DMA Transfer
 *     ABORT            Set by CPU to Abort Table DMA Transfer
 *     DONE             Set by CMIC to indicate Table DMA Transfer Completion.Can be cleared (but not set) by CPU.
 *     ERROR            Set by CMIC to indicate Table DMA Transfer wasaborted due to an error (most probably due to a NACK).Can be cleared (but not set) by CPU.
 *     RESERVED_1       Reserved
 *     BEATS            Written by CPU indicating number of data beats.For Table DMA purposes, each table entry is 32-bit aligned.The widest S-bus table wr/rd supported is 640 bits.So, the valid values for this field are 1-20 (beats).
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr 0x0000042c

#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_CFG.
 *
 */
typedef union BCM56800_A0_CMIC_TABLE_DMA_CFGr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_cfg[1];
	uint32_t _cmic_table_dma_cfg;
} BCM56800_A0_CMIC_TABLE_DMA_CFGr_t;

#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_CLR(r) (r).cmic_table_dma_cfg[0] = 0
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_SET(r,d) (r).cmic_table_dma_cfg[0] = d
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_GET(r) (r).cmic_table_dma_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_ENf_GET(r) (((r).cmic_table_dma_cfg[0]) & 0x1)
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_ENf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_ABORTf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_ABORTf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_DONEf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_DONEf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_ERRORf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_ERRORf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 4) & 0xfff)
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_BEATSf_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 16) & 0x1f)
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_BEATSf_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET(r) ((((r).cmic_table_dma_cfg[0]) >> 21) & 0x7ff)
#define BCM56800_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET(r,f) (r).cmic_table_dma_cfg[0]=(((r).cmic_table_dma_cfg[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access CMIC_TABLE_DMA_CFG.
 *
 */
#define BCM56800_A0_READ_CMIC_TABLE_DMA_CFGr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TABLE_DMA_CFGr,r._cmic_table_dma_cfg)
#define BCM56800_A0_WRITE_CMIC_TABLE_DMA_CFGr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TABLE_DMA_CFGr,r._cmic_table_dma_cfg)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_CFGr BCM56800_A0_CMIC_TABLE_DMA_CFGr
#define CMIC_TABLE_DMA_CFGr_SIZE BCM56800_A0_CMIC_TABLE_DMA_CFGr_SIZE
typedef BCM56800_A0_CMIC_TABLE_DMA_CFGr_t CMIC_TABLE_DMA_CFGr_t;
#define CMIC_TABLE_DMA_CFGr_CLR BCM56800_A0_CMIC_TABLE_DMA_CFGr_CLR
#define CMIC_TABLE_DMA_CFGr_SET BCM56800_A0_CMIC_TABLE_DMA_CFGr_SET
#define CMIC_TABLE_DMA_CFGr_GET BCM56800_A0_CMIC_TABLE_DMA_CFGr_GET
#define CMIC_TABLE_DMA_CFGr_ENf_GET BCM56800_A0_CMIC_TABLE_DMA_CFGr_ENf_GET
#define CMIC_TABLE_DMA_CFGr_ENf_SET BCM56800_A0_CMIC_TABLE_DMA_CFGr_ENf_SET
#define CMIC_TABLE_DMA_CFGr_ABORTf_GET BCM56800_A0_CMIC_TABLE_DMA_CFGr_ABORTf_GET
#define CMIC_TABLE_DMA_CFGr_ABORTf_SET BCM56800_A0_CMIC_TABLE_DMA_CFGr_ABORTf_SET
#define CMIC_TABLE_DMA_CFGr_DONEf_GET BCM56800_A0_CMIC_TABLE_DMA_CFGr_DONEf_GET
#define CMIC_TABLE_DMA_CFGr_DONEf_SET BCM56800_A0_CMIC_TABLE_DMA_CFGr_DONEf_SET
#define CMIC_TABLE_DMA_CFGr_ERRORf_GET BCM56800_A0_CMIC_TABLE_DMA_CFGr_ERRORf_GET
#define CMIC_TABLE_DMA_CFGr_ERRORf_SET BCM56800_A0_CMIC_TABLE_DMA_CFGr_ERRORf_SET
#define CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET BCM56800_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_GET
#define CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET BCM56800_A0_CMIC_TABLE_DMA_CFGr_RESERVED_1f_SET
#define CMIC_TABLE_DMA_CFGr_BEATSf_GET BCM56800_A0_CMIC_TABLE_DMA_CFGr_BEATSf_GET
#define CMIC_TABLE_DMA_CFGr_BEATSf_SET BCM56800_A0_CMIC_TABLE_DMA_CFGr_BEATSf_SET
#define CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET BCM56800_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_GET
#define CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET BCM56800_A0_CMIC_TABLE_DMA_CFGr_RESERVED_2f_SET
#define READ_CMIC_TABLE_DMA_CFGr BCM56800_A0_READ_CMIC_TABLE_DMA_CFGr
#define WRITE_CMIC_TABLE_DMA_CFGr BCM56800_A0_WRITE_CMIC_TABLE_DMA_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TABLE_DMA_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA Current Entry S-bus Address Register
 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CMIC indicating S-bus address of the Table Entrycurrently being processed
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr 0x00000434

#define BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
typedef union BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_cur_entry_sbus_addr[1];
	uint32_t _cmic_table_dma_cur_entry_sbus_addr;
} BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t;

#define BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR(r) (r).cmic_table_dma_cur_entry_sbus_addr[0] = 0
#define BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET(r,d) (r).cmic_table_dma_cur_entry_sbus_addr[0] = d
#define BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET(r) (r).cmic_table_dma_cur_entry_sbus_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_cur_entry_sbus_addr[0])
#define BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_cur_entry_sbus_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_table_dma_cur_entry_sbus_addr)
#define BCM56800_A0_WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr,r._cmic_table_dma_cur_entry_sbus_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SIZE
typedef BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_t;
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_CLR
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_SET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_GET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56800_A0_READ_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr
#define WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr BCM56800_A0_WRITE_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TABLE_DMA_CUR_ENTRY_SBUS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TABLE_DMA_ENTRY_COUNT
 * BLOCKS:   CMIC
 * DESC:     Table DMA Entry Count Register
 * SIZE:     32
 * FIELDS:
 *     COUNT            Written by CPU indicating number of Table entries for Table DMA.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr 0x00000428

#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_ENTRY_COUNT.
 *
 */
typedef union BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_entry_count[1];
	uint32_t _cmic_table_dma_entry_count;
} BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_t;

#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_CLR(r) (r).cmic_table_dma_entry_count[0] = 0
#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SET(r,d) (r).cmic_table_dma_entry_count[0] = d
#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_GET(r) (r).cmic_table_dma_entry_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET(r) (((r).cmic_table_dma_entry_count[0]) & 0xffffff)
#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET(r,f) (r).cmic_table_dma_entry_count[0]=(((r).cmic_table_dma_entry_count[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET(r) ((((r).cmic_table_dma_entry_count[0]) >> 24) & 0xff)
#define BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET(r,f) (r).cmic_table_dma_entry_count[0]=(((r).cmic_table_dma_entry_count[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access CMIC_TABLE_DMA_ENTRY_COUNT.
 *
 */
#define BCM56800_A0_READ_CMIC_TABLE_DMA_ENTRY_COUNTr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr,r._cmic_table_dma_entry_count)
#define BCM56800_A0_WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr,r._cmic_table_dma_entry_count)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_ENTRY_COUNTr BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr
#define CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SIZE
typedef BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_t CMIC_TABLE_DMA_ENTRY_COUNTr_t;
#define CMIC_TABLE_DMA_ENTRY_COUNTr_CLR BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_CLR
#define CMIC_TABLE_DMA_ENTRY_COUNTr_SET BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_SET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_GET BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_COUNTf_SET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_GET
#define CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr_RESERVED_1f_SET
#define READ_CMIC_TABLE_DMA_ENTRY_COUNTr BCM56800_A0_READ_CMIC_TABLE_DMA_ENTRY_COUNTr
#define WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr BCM56800_A0_WRITE_CMIC_TABLE_DMA_ENTRY_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TABLE_DMA_ENTRY_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TABLE_DMA_PCIMEM_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA PCI Memory Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Table DMA Physical (PCI) Memory Start Address
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr 0x00000420

#define BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_PCIMEM_START_ADDR.
 *
 */
typedef union BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_pcimem_start_addr[1];
	uint32_t _cmic_table_dma_pcimem_start_addr;
} BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t;

#define BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR(r) (r).cmic_table_dma_pcimem_start_addr[0] = 0
#define BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET(r,d) (r).cmic_table_dma_pcimem_start_addr[0] = d
#define BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET(r) (r).cmic_table_dma_pcimem_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_pcimem_start_addr[0])
#define BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_pcimem_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_PCIMEM_START_ADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr,r._cmic_table_dma_pcimem_start_addr)
#define BCM56800_A0_WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr,r._cmic_table_dma_pcimem_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SIZE
typedef BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t CMIC_TABLE_DMA_PCIMEM_START_ADDRr_t;
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_CLR
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_SET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_GET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56800_A0_READ_CMIC_TABLE_DMA_PCIMEM_START_ADDRr
#define WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr BCM56800_A0_WRITE_CMIC_TABLE_DMA_PCIMEM_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TABLE_DMA_PCIMEM_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TABLE_DMA_SBUS_START_ADDR
 * BLOCKS:   CMIC
 * DESC:     Table DMA S-bus Start Address Register

 * SIZE:     32
 * FIELDS:
 *     ADDR             Written by CPU indicating Table DMA Logical (S-bus) Memory Start Address. This address has the followingfields: table (6b), block (4b) and region+index (20b)
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr 0x00000424

#define BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TABLE_DMA_SBUS_START_ADDR.
 *
 */
typedef union BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_s {
	uint32_t v[1];
	uint32_t cmic_table_dma_sbus_start_addr[1];
	uint32_t _cmic_table_dma_sbus_start_addr;
} BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_t;

#define BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR(r) (r).cmic_table_dma_sbus_start_addr[0] = 0
#define BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SET(r,d) (r).cmic_table_dma_sbus_start_addr[0] = d
#define BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_GET(r) (r).cmic_table_dma_sbus_start_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET(r) ((r).cmic_table_dma_sbus_start_addr[0])
#define BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET(r,f) (r).cmic_table_dma_sbus_start_addr[0]=((uint32_t)f)

/*
 * These macros can be used to access CMIC_TABLE_DMA_SBUS_START_ADDR.
 *
 */
#define BCM56800_A0_READ_CMIC_TABLE_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr,r._cmic_table_dma_sbus_start_addr)
#define BCM56800_A0_WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr,r._cmic_table_dma_sbus_start_addr)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SIZE
typedef BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_t CMIC_TABLE_DMA_SBUS_START_ADDRr_t;
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_CLR
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_SET BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_SET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_GET BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_GET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_GET
#define CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr_ADDRf_SET
#define READ_CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56800_A0_READ_CMIC_TABLE_DMA_SBUS_START_ADDRr
#define WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr BCM56800_A0_WRITE_CMIC_TABLE_DMA_SBUS_START_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TABLE_DMA_SBUS_START_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TAP_CONTROL
 * BLOCKS:   CMIC
 * DESC:     Must follow TAP protocol to initiate BIST and read BIST results

 * SIZE:     32
 * FIELDS:
 *     TDI              Tap control data in
 *     TMS              Test mode select
 *     TCK              TAP clock
 *     TRST             TAP reset
 *     TDO              TAP data out
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TAP_CONTROLr 0x00000194

#define BCM56800_A0_CMIC_TAP_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TAP_CONTROL.
 *
 */
typedef union BCM56800_A0_CMIC_TAP_CONTROLr_s {
	uint32_t v[1];
	uint32_t cmic_tap_control[1];
	uint32_t _cmic_tap_control;
} BCM56800_A0_CMIC_TAP_CONTROLr_t;

#define BCM56800_A0_CMIC_TAP_CONTROLr_CLR(r) (r).cmic_tap_control[0] = 0
#define BCM56800_A0_CMIC_TAP_CONTROLr_SET(r,d) (r).cmic_tap_control[0] = d
#define BCM56800_A0_CMIC_TAP_CONTROLr_GET(r) (r).cmic_tap_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TAP_CONTROLr_TDIf_GET(r) (((r).cmic_tap_control[0]) & 0x1)
#define BCM56800_A0_CMIC_TAP_CONTROLr_TDIf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_TAP_CONTROLr_TMSf_GET(r) ((((r).cmic_tap_control[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_TAP_CONTROLr_TMSf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_TAP_CONTROLr_TCKf_GET(r) ((((r).cmic_tap_control[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_TAP_CONTROLr_TCKf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_TAP_CONTROLr_TRSTf_GET(r) ((((r).cmic_tap_control[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_TAP_CONTROLr_TRSTf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_TAP_CONTROLr_TDOf_GET(r) ((((r).cmic_tap_control[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_TAP_CONTROLr_TDOf_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_TAP_CONTROLr_RESERVED_1f_GET(r) ((((r).cmic_tap_control[0]) >> 5) & 0x7ffffff)
#define BCM56800_A0_CMIC_TAP_CONTROLr_RESERVED_1f_SET(r,f) (r).cmic_tap_control[0]=(((r).cmic_tap_control[0] & ~((uint32_t)0x7ffffff << 5)) | ((((uint32_t)f) & 0x7ffffff) << 5))

/*
 * These macros can be used to access CMIC_TAP_CONTROL.
 *
 */
#define BCM56800_A0_READ_CMIC_TAP_CONTROLr(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TAP_CONTROLr,r._cmic_tap_control)
#define BCM56800_A0_WRITE_CMIC_TAP_CONTROLr(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TAP_CONTROLr,r._cmic_tap_control)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TAP_CONTROLr BCM56800_A0_CMIC_TAP_CONTROLr
#define CMIC_TAP_CONTROLr_SIZE BCM56800_A0_CMIC_TAP_CONTROLr_SIZE
typedef BCM56800_A0_CMIC_TAP_CONTROLr_t CMIC_TAP_CONTROLr_t;
#define CMIC_TAP_CONTROLr_CLR BCM56800_A0_CMIC_TAP_CONTROLr_CLR
#define CMIC_TAP_CONTROLr_SET BCM56800_A0_CMIC_TAP_CONTROLr_SET
#define CMIC_TAP_CONTROLr_GET BCM56800_A0_CMIC_TAP_CONTROLr_GET
#define CMIC_TAP_CONTROLr_TDIf_GET BCM56800_A0_CMIC_TAP_CONTROLr_TDIf_GET
#define CMIC_TAP_CONTROLr_TDIf_SET BCM56800_A0_CMIC_TAP_CONTROLr_TDIf_SET
#define CMIC_TAP_CONTROLr_TMSf_GET BCM56800_A0_CMIC_TAP_CONTROLr_TMSf_GET
#define CMIC_TAP_CONTROLr_TMSf_SET BCM56800_A0_CMIC_TAP_CONTROLr_TMSf_SET
#define CMIC_TAP_CONTROLr_TCKf_GET BCM56800_A0_CMIC_TAP_CONTROLr_TCKf_GET
#define CMIC_TAP_CONTROLr_TCKf_SET BCM56800_A0_CMIC_TAP_CONTROLr_TCKf_SET
#define CMIC_TAP_CONTROLr_TRSTf_GET BCM56800_A0_CMIC_TAP_CONTROLr_TRSTf_GET
#define CMIC_TAP_CONTROLr_TRSTf_SET BCM56800_A0_CMIC_TAP_CONTROLr_TRSTf_SET
#define CMIC_TAP_CONTROLr_TDOf_GET BCM56800_A0_CMIC_TAP_CONTROLr_TDOf_GET
#define CMIC_TAP_CONTROLr_TDOf_SET BCM56800_A0_CMIC_TAP_CONTROLr_TDOf_SET
#define CMIC_TAP_CONTROLr_RESERVED_1f_GET BCM56800_A0_CMIC_TAP_CONTROLr_RESERVED_1f_GET
#define CMIC_TAP_CONTROLr_RESERVED_1f_SET BCM56800_A0_CMIC_TAP_CONTROLr_RESERVED_1f_SET
#define READ_CMIC_TAP_CONTROLr BCM56800_A0_READ_CMIC_TAP_CONTROLr
#define WRITE_CMIC_TAP_CONTROLr BCM56800_A0_WRITE_CMIC_TAP_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TAP_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TO_CORE_PLL_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     Core PLL Control[31:0]
 * SIZE:     32
 * FIELDS:
 *     P1_DIVIDER       0001	Divide ratio= 1:	:1110	Divide ratio= 141111	Divide ratio= 15
 *     P2_DIVIDER       0001	Divide ratio= 1:	:1110	Divide ratio= 141111	Divide ratio= 15
 *     PH_DET_DIS       Phase lock detector enable
 *     FREQ_DET_DIS     Frequency lock detector enable
 *     ICPX             000000	Bias current scaling: 0 uA:	:000001	Bias current scaling: 2.5 uA000010	Bias current scaling: 5.0 uA111110	Bias current scaling: 150 uA111111	Bias current scaling: 157.5 uA
 *     RX               00	Rzero= 1.295Kohm, Gma= 57.1uA/Volt01	Rzero= 863ohm, Gma= 71.4uA/Volt10	Rzero= 648ohm, Gma= 95.2uA/Volt11	Rzero= 518ohm, Gma= 95.2uA/Volt
 *     VC_EN            0	VDD/R bias current generator enabled1	Self bias (Vc) current generator enabled
 *     VCO_RNG          00	Fvco range: 460 ? 710 MHz01	Fvco range: 570 ? 1070 MHz10	Fvco range: 910 ? 1930 MHz11	Fvco range: 1700 ? 3500 MHz
 *     KVCO_XF          000	Fast Gm nominal scaling001	Fast Gm 1.5X scaling010	Fast Gm 2X scaling011	Fast Gm 2.5X scaling100	Fast Gm 2.5X scaling101	Fast Gm 3X scaling110	Fast Gm 3.5X scaling111	Fast Gm 4X scaling
 *     KVCO_XS          000	Fast Gm nominal scaling001	Fast Gm 1.5X scaling010	Fast Gm 2X scaling011	Fast Gm 2.5X scaling100	Fast Gm 2.5X scaling101	Fast Gm 3X scaling110	Fast Gm 3.5X scaling111	Fast Gm 4X scaling
 *     TESTD_EN         Digital test enable
 *     TESTD_SEL        000	clk2_out001	clk1_out010	fdbk_out011	fdbk2x_out100	N divider output101	lock detector output110	fbclki signal111	refclki signal
 *     TESTA_EN         Analog DC test enable
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r 0x00000914

#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TO_CORE_PLL_CONTROL_1.
 *
 */
typedef union BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_to_core_pll_control_1[1];
	uint32_t _cmic_to_core_pll_control_1;
} BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_t;

#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_CLR(r) (r).cmic_to_core_pll_control_1[0] = 0
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_SET(r,d) (r).cmic_to_core_pll_control_1[0] = d
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_GET(r) (r).cmic_to_core_pll_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_P1_DIVIDERf_GET(r) (((r).cmic_to_core_pll_control_1[0]) & 0xf)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_P1_DIVIDERf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_P2_DIVIDERf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_P2_DIVIDERf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_PH_DET_DISf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_PH_DET_DISf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_FREQ_DET_DISf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_FREQ_DET_DISf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_ICPXf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 10) & 0x3f)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_ICPXf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_RXf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 16) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_RXf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_VC_ENf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_VC_ENf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_VCO_RNGf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 19) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_VCO_RNGf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XFf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XFf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XSf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 24) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XSf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_ENf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_ENf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_SELf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 28) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_SELf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTA_ENf_GET(r) ((((r).cmic_to_core_pll_control_1[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTA_ENf_SET(r,f) (r).cmic_to_core_pll_control_1[0]=(((r).cmic_to_core_pll_control_1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_TO_CORE_PLL_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_CMIC_TO_CORE_PLL_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r,r._cmic_to_core_pll_control_1)
#define BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r,r._cmic_to_core_pll_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TO_CORE_PLL_CONTROL_1r BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r
#define CMIC_TO_CORE_PLL_CONTROL_1r_SIZE BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_SIZE
typedef BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_t CMIC_TO_CORE_PLL_CONTROL_1r_t;
#define CMIC_TO_CORE_PLL_CONTROL_1r_CLR BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_CLR
#define CMIC_TO_CORE_PLL_CONTROL_1r_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_P1_DIVIDERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_P1_DIVIDERf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_P1_DIVIDERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_P1_DIVIDERf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_P2_DIVIDERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_P2_DIVIDERf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_P2_DIVIDERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_P2_DIVIDERf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_PH_DET_DISf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_PH_DET_DISf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_PH_DET_DISf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_PH_DET_DISf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_FREQ_DET_DISf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_FREQ_DET_DISf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_FREQ_DET_DISf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_FREQ_DET_DISf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_ICPXf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_ICPXf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_ICPXf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_ICPXf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_RXf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_RXf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_RXf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_RXf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_VC_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_VC_ENf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_VC_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_VC_ENf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_VCO_RNGf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_VCO_RNGf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_VCO_RNGf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_VCO_RNGf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XFf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XFf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XFf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XFf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XSf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XSf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XSf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_KVCO_XSf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_ENf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_ENf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_SELf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_SELf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_SELf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTD_SELf_SET
#define CMIC_TO_CORE_PLL_CONTROL_1r_TESTA_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTA_ENf_GET
#define CMIC_TO_CORE_PLL_CONTROL_1r_TESTA_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r_TESTA_ENf_SET
#define READ_CMIC_TO_CORE_PLL_CONTROL_1r BCM56800_A0_READ_CMIC_TO_CORE_PLL_CONTROL_1r
#define WRITE_CMIC_TO_CORE_PLL_CONTROL_1r BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TO_CORE_PLL_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     Core PLL Control[63:32]
 * SIZE:     32
 * FIELDS:
 *     TESTA_SEL        00: vco_vreg DC probe point; 01: vcf loop filter DC probe point; 10: vcs loop filter DC probe point; 11: vci loop filter DC probe point
 *     ATTEN_FREF       0: FREF input attenuator= 0 dB; 1: FREF input attenuator= 6 dB
 *     DIV_BY_2         VCO divide-by-2 CML output enable
 *     RESERVED         Reserved
 *     PWRDN_CK_DRIVER  Power down ckdriver
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r 0x00000918

#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TO_CORE_PLL_CONTROL_2.
 *
 */
typedef union BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_to_core_pll_control_2[1];
	uint32_t _cmic_to_core_pll_control_2;
} BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_t;

#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_CLR(r) (r).cmic_to_core_pll_control_2[0] = 0
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_SET(r,d) (r).cmic_to_core_pll_control_2[0] = d
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_GET(r) (r).cmic_to_core_pll_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_TESTA_SELf_GET(r) (((r).cmic_to_core_pll_control_2[0]) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_TESTA_SELf_SET(r,f) (r).cmic_to_core_pll_control_2[0]=(((r).cmic_to_core_pll_control_2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_ATTEN_FREFf_GET(r) ((((r).cmic_to_core_pll_control_2[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_ATTEN_FREFf_SET(r,f) (r).cmic_to_core_pll_control_2[0]=(((r).cmic_to_core_pll_control_2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_DIV_BY_2f_GET(r) ((((r).cmic_to_core_pll_control_2[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_DIV_BY_2f_SET(r,f) (r).cmic_to_core_pll_control_2[0]=(((r).cmic_to_core_pll_control_2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_RESERVEDf_GET(r) ((((r).cmic_to_core_pll_control_2[0]) >> 4) & 0x7ffffff)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_RESERVEDf_SET(r,f) (r).cmic_to_core_pll_control_2[0]=(((r).cmic_to_core_pll_control_2[0] & ~((uint32_t)0x7ffffff << 4)) | ((((uint32_t)f) & 0x7ffffff) << 4))
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_PWRDN_CK_DRIVERf_GET(r) ((((r).cmic_to_core_pll_control_2[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_PWRDN_CK_DRIVERf_SET(r,f) (r).cmic_to_core_pll_control_2[0]=(((r).cmic_to_core_pll_control_2[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_TO_CORE_PLL_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_CMIC_TO_CORE_PLL_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r,r._cmic_to_core_pll_control_2)
#define BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r,r._cmic_to_core_pll_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TO_CORE_PLL_CONTROL_2r BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r
#define CMIC_TO_CORE_PLL_CONTROL_2r_SIZE BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_SIZE
typedef BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_t CMIC_TO_CORE_PLL_CONTROL_2r_t;
#define CMIC_TO_CORE_PLL_CONTROL_2r_CLR BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_CLR
#define CMIC_TO_CORE_PLL_CONTROL_2r_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_SET
#define CMIC_TO_CORE_PLL_CONTROL_2r_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_GET
#define CMIC_TO_CORE_PLL_CONTROL_2r_TESTA_SELf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_TESTA_SELf_GET
#define CMIC_TO_CORE_PLL_CONTROL_2r_TESTA_SELf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_TESTA_SELf_SET
#define CMIC_TO_CORE_PLL_CONTROL_2r_ATTEN_FREFf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_ATTEN_FREFf_GET
#define CMIC_TO_CORE_PLL_CONTROL_2r_ATTEN_FREFf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_ATTEN_FREFf_SET
#define CMIC_TO_CORE_PLL_CONTROL_2r_DIV_BY_2f_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_DIV_BY_2f_GET
#define CMIC_TO_CORE_PLL_CONTROL_2r_DIV_BY_2f_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_DIV_BY_2f_SET
#define CMIC_TO_CORE_PLL_CONTROL_2r_RESERVEDf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_RESERVEDf_GET
#define CMIC_TO_CORE_PLL_CONTROL_2r_RESERVEDf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_RESERVEDf_SET
#define CMIC_TO_CORE_PLL_CONTROL_2r_PWRDN_CK_DRIVERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_PWRDN_CK_DRIVERf_GET
#define CMIC_TO_CORE_PLL_CONTROL_2r_PWRDN_CK_DRIVERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r_PWRDN_CK_DRIVERf_SET
#define READ_CMIC_TO_CORE_PLL_CONTROL_2r BCM56800_A0_READ_CMIC_TO_CORE_PLL_CONTROL_2r
#define WRITE_CMIC_TO_CORE_PLL_CONTROL_2r BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TO_CORE_PLL_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TO_CORE_PLL_X2_1_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     Core X2 PLL 1 Control[31:0]
 * SIZE:     32
 * FIELDS:
 *     P1_DIVIDER       0001	Divide ratio= 1:	:1110	Divide ratio= 141111	Divide ratio= 15
 *     P2_DIVIDER       0001	Divide ratio= 1:	:1110	Divide ratio= 141111	Divide ratio= 15
 *     PH_DET_DIS       Phase lock detector enable
 *     FREQ_DET_DIS     Frequency lock detector enable
 *     ICPX             000000	Bias current scaling: 0 uA000001	Bias current scaling: 2.5 uA000010	Bias current scaling: 5.0 uA:	:111110	Bias current scaling: 150 uA111111	Bias current scaling: 157.5 uA
 *     RX               00	Rzero= 1.295Kohm, Gma= 57.1uA/Volt01	Rzero= 863ohm, Gma= 71.4uA/Volt10	Rzero= 648ohm, Gma= 95.2uA/Volt11	Rzero= 518ohm, Gma= 95.2uA/Volt
 *     VC_EN            0	VDD/R bias current generator enabled1	Self bias (Vc) current generator enabled
 *     VCO_RNG          00	Fvco range: 460 ? 710 MHz01	Fvco range: 570 ? 1070 MHz10	Fvco range: 910 ? 1930 MHz11	Fvco range: 1700 ? 3500 MHz
 *     KVCO_XF          000	Fast Gm nominal scaling001	Fast Gm 1.5X scaling010	Fast Gm 2X scaling011	Fast Gm 2.5X scaling100	Fast Gm 2.5X scaling101	Fast Gm 3X scaling110	Fast Gm 3.5X scaling111	Fast Gm 4X scaling
 *     KVCO_XS          000	Fast Gm nominal scaling001	Fast Gm 1.5X scaling010	Fast Gm 2X scaling011	Fast Gm 2.5X scaling100	Fast Gm 2.5X scaling101	Fast Gm 3X scaling110	Fast Gm 3.5X scaling111	Fast Gm 4X scaling
 *     TESTD_EN         Digital test enable
 *     TESTD_SEL        000	clk2_out001	clk1_out010	fdbk_out011	fdbk2x_out100	N divider output101	lock detector output110	fbclki signal111	refclki signal
 *     TESTA_EN         Analog DC test enable
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r 0x0000091c

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TO_CORE_PLL_X2_1_CONTROL_1.
 *
 */
typedef union BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_to_core_pll_x2_1_control_1[1];
	uint32_t _cmic_to_core_pll_x2_1_control_1;
} BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_t;

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_CLR(r) (r).cmic_to_core_pll_x2_1_control_1[0] = 0
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_SET(r,d) (r).cmic_to_core_pll_x2_1_control_1[0] = d
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_GET(r) (r).cmic_to_core_pll_x2_1_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P1_DIVIDERf_GET(r) (((r).cmic_to_core_pll_x2_1_control_1[0]) & 0xf)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P1_DIVIDERf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P2_DIVIDERf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P2_DIVIDERf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_PH_DET_DISf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_PH_DET_DISf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_FREQ_DET_DISf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_FREQ_DET_DISf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_ICPXf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 10) & 0x3f)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_ICPXf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_RXf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 16) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_RXf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VC_ENf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VC_ENf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VCO_RNGf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 19) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VCO_RNGf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XFf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XFf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XSf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 24) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XSf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_ENf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_ENf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_SELf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 28) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_SELf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTA_ENf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_1[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTA_ENf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_1[0]=(((r).cmic_to_core_pll_x2_1_control_1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_TO_CORE_PLL_X2_1_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r,r._cmic_to_core_pll_x2_1_control_1)
#define BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r,r._cmic_to_core_pll_x2_1_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_SIZE BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_SIZE
typedef BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_t CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_t;
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_CLR BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_CLR
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P1_DIVIDERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P1_DIVIDERf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P1_DIVIDERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P1_DIVIDERf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P2_DIVIDERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P2_DIVIDERf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P2_DIVIDERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_P2_DIVIDERf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_PH_DET_DISf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_PH_DET_DISf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_PH_DET_DISf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_PH_DET_DISf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_FREQ_DET_DISf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_FREQ_DET_DISf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_FREQ_DET_DISf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_FREQ_DET_DISf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_ICPXf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_ICPXf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_ICPXf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_ICPXf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_RXf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_RXf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_RXf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_RXf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VC_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VC_ENf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VC_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VC_ENf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VCO_RNGf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VCO_RNGf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VCO_RNGf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_VCO_RNGf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XFf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XFf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XFf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XFf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XSf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XSf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XSf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_KVCO_XSf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_ENf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_ENf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_SELf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_SELf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_SELf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTD_SELf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTA_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTA_ENf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTA_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r_TESTA_ENf_SET
#define READ_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r
#define WRITE_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TO_CORE_PLL_X2_1_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     Core X2 PLL 1 Control[63:32]
 * SIZE:     32
 * FIELDS:
 *     TESTA_SEL        00: vco_vreg DC probe point; 01: vcf loop filter DC probe point; 10: vcs loop filter DC probe point; 11: vci loop filter DC probe point
 *     ATTEN_FREF       0: FREF input attenuator= 0 dB; 1: FREF input attenuator= 6 dB
 *     DIV_BY_2         VCO divide-by-2 CML output enable
 *     RESERVED         Reserved
 *     PWRDN_CK_DRIVER  Power down ckdriver
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r 0x00000928

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TO_CORE_PLL_X2_1_CONTROL_2.
 *
 */
typedef union BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_to_core_pll_x2_1_control_2[1];
	uint32_t _cmic_to_core_pll_x2_1_control_2;
} BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_t;

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_CLR(r) (r).cmic_to_core_pll_x2_1_control_2[0] = 0
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_SET(r,d) (r).cmic_to_core_pll_x2_1_control_2[0] = d
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_GET(r) (r).cmic_to_core_pll_x2_1_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_TESTA_SELf_GET(r) (((r).cmic_to_core_pll_x2_1_control_2[0]) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_TESTA_SELf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_2[0]=(((r).cmic_to_core_pll_x2_1_control_2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_ATTEN_FREFf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_2[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_ATTEN_FREFf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_2[0]=(((r).cmic_to_core_pll_x2_1_control_2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_DIV_BY_2f_GET(r) ((((r).cmic_to_core_pll_x2_1_control_2[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_DIV_BY_2f_SET(r,f) (r).cmic_to_core_pll_x2_1_control_2[0]=(((r).cmic_to_core_pll_x2_1_control_2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_RESERVEDf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_2[0]) >> 4) & 0x7ffffff)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_RESERVEDf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_2[0]=(((r).cmic_to_core_pll_x2_1_control_2[0] & ~((uint32_t)0x7ffffff << 4)) | ((((uint32_t)f) & 0x7ffffff) << 4))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_PWRDN_CK_DRIVERf_GET(r) ((((r).cmic_to_core_pll_x2_1_control_2[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_PWRDN_CK_DRIVERf_SET(r,f) (r).cmic_to_core_pll_x2_1_control_2[0]=(((r).cmic_to_core_pll_x2_1_control_2[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_TO_CORE_PLL_X2_1_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r,r._cmic_to_core_pll_x2_1_control_2)
#define BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r,r._cmic_to_core_pll_x2_1_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_SIZE BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_SIZE
typedef BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_t CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_t;
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_CLR BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_CLR
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_TESTA_SELf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_TESTA_SELf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_TESTA_SELf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_TESTA_SELf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_ATTEN_FREFf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_ATTEN_FREFf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_ATTEN_FREFf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_ATTEN_FREFf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_DIV_BY_2f_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_DIV_BY_2f_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_DIV_BY_2f_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_DIV_BY_2f_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_RESERVEDf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_RESERVEDf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_RESERVEDf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_RESERVEDf_SET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_PWRDN_CK_DRIVERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_PWRDN_CK_DRIVERf_GET
#define CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_PWRDN_CK_DRIVERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r_PWRDN_CK_DRIVERf_SET
#define READ_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r
#define WRITE_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TO_CORE_PLL_X2_1_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TO_CORE_PLL_X2_2_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     Core X2 PLL 2 Control[31:0]
 * SIZE:     32
 * FIELDS:
 *     P1_DIVIDER       0001	Divide ratio= 1:	:1110	Divide ratio= 141111	Divide ratio= 15
 *     P2_DIVIDER       0001	Divide ratio= 1:	:1110	Divide ratio= 141111	Divide ratio= 15
 *     PH_DET_DIS       Phase lock detector enable
 *     FREQ_DET_DIS     Frequency lock detector enable
 *     ICPX             000000	Bias current scaling: 0 uA000001	Bias current scaling: 2.5 uA000010	Bias current scaling: 5.0 uA:	:111110	Bias current scaling: 150 uA111111	Bias current scaling: 157.5 uA
 *     RX               00	Rzero= 1.295Kohm, Gma= 57.1uA/Volt01	Rzero= 863ohm, Gma= 71.4uA/Volt10	Rzero= 648ohm, Gma= 95.2uA/Volt11	Rzero= 518ohm, Gma= 95.2uA/Volt
 *     VC_EN            0	VDD/R bias current generator enabled1	Self bias (Vc) current generator enabled
 *     VCO_RNG          00	Fvco range: 460 ? 710 MHz01	Fvco range: 570 ? 1070 MHz10	Fvco range: 910 ? 1930 MHz11	Fvco range: 1700 ? 3500 MHz
 *     KVCO_XF          000	Fast Gm nominal scaling001	Fast Gm 1.5X scaling010	Fast Gm 2X scaling011	Fast Gm 2.5X scaling100	Fast Gm 2.5X scaling101	Fast Gm 3X scaling110	Fast Gm 3.5X scaling111	Fast Gm 4X scaling
 *     KVCO_XS          000	Fast Gm nominal scaling001	Fast Gm 1.5X scaling010	Fast Gm 2X scaling011	Fast Gm 2.5X scaling100	Fast Gm 2.5X scaling101	Fast Gm 3X scaling110	Fast Gm 3.5X scaling111	Fast Gm 4X scaling
 *     TESTD_EN         Digital test enable
 *     TESTD_SEL        000	clk2_out001	clk1_out010	fdbk_out011	fdbk2x_out100	N divider output101	lock detector output110	fbclki signal111	refclki signal
 *     TESTA_EN         Analog DC test enable
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r 0x0000092c

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TO_CORE_PLL_X2_2_CONTROL_1.
 *
 */
typedef union BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_to_core_pll_x2_2_control_1[1];
	uint32_t _cmic_to_core_pll_x2_2_control_1;
} BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_t;

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_CLR(r) (r).cmic_to_core_pll_x2_2_control_1[0] = 0
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_SET(r,d) (r).cmic_to_core_pll_x2_2_control_1[0] = d
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_GET(r) (r).cmic_to_core_pll_x2_2_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P1_DIVIDERf_GET(r) (((r).cmic_to_core_pll_x2_2_control_1[0]) & 0xf)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P1_DIVIDERf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P2_DIVIDERf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P2_DIVIDERf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_PH_DET_DISf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_PH_DET_DISf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_FREQ_DET_DISf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_FREQ_DET_DISf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_ICPXf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 10) & 0x3f)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_ICPXf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_RXf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 16) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_RXf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VC_ENf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VC_ENf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VCO_RNGf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 19) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VCO_RNGf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XFf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XFf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XSf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 24) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XSf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_ENf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_ENf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_SELf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 28) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_SELf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTA_ENf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_1[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTA_ENf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_1[0]=(((r).cmic_to_core_pll_x2_2_control_1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_TO_CORE_PLL_X2_2_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r,r._cmic_to_core_pll_x2_2_control_1)
#define BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r,r._cmic_to_core_pll_x2_2_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_SIZE BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_SIZE
typedef BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_t CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_t;
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_CLR BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_CLR
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P1_DIVIDERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P1_DIVIDERf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P1_DIVIDERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P1_DIVIDERf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P2_DIVIDERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P2_DIVIDERf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P2_DIVIDERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_P2_DIVIDERf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_PH_DET_DISf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_PH_DET_DISf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_PH_DET_DISf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_PH_DET_DISf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_FREQ_DET_DISf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_FREQ_DET_DISf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_FREQ_DET_DISf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_FREQ_DET_DISf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_ICPXf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_ICPXf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_ICPXf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_ICPXf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_RXf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_RXf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_RXf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_RXf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VC_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VC_ENf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VC_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VC_ENf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VCO_RNGf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VCO_RNGf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VCO_RNGf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_VCO_RNGf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XFf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XFf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XFf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XFf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XSf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XSf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XSf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_KVCO_XSf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_ENf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_ENf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_SELf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_SELf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_SELf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTD_SELf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTA_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTA_ENf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTA_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r_TESTA_ENf_SET
#define READ_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r
#define WRITE_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TO_CORE_PLL_X2_2_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     Core X2 PLL 2 Control[63:32]
 * SIZE:     32
 * FIELDS:
 *     TESTA_SEL        00: vco_vreg DC probe point; 01: vcf loop filter DC probe point; 10: vcs loop filter DC probe point; 11: vci loop filter DC probe point
 *     ATTEN_FREF       0: FREF input attenuator= 0 dB; 1: FREF input attenuator= 6 dB
 *     DIV_BY_2         VCO divide-by-2 CML output enable
 *     RESERVED         Reserved
 *     PWRDN_CK_DRIVER  Power down ckdriver
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r 0x00000930

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TO_CORE_PLL_X2_2_CONTROL_2.
 *
 */
typedef union BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_to_core_pll_x2_2_control_2[1];
	uint32_t _cmic_to_core_pll_x2_2_control_2;
} BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_t;

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_CLR(r) (r).cmic_to_core_pll_x2_2_control_2[0] = 0
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_SET(r,d) (r).cmic_to_core_pll_x2_2_control_2[0] = d
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_GET(r) (r).cmic_to_core_pll_x2_2_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_TESTA_SELf_GET(r) (((r).cmic_to_core_pll_x2_2_control_2[0]) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_TESTA_SELf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_2[0]=(((r).cmic_to_core_pll_x2_2_control_2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_ATTEN_FREFf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_2[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_ATTEN_FREFf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_2[0]=(((r).cmic_to_core_pll_x2_2_control_2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_DIV_BY_2f_GET(r) ((((r).cmic_to_core_pll_x2_2_control_2[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_DIV_BY_2f_SET(r,f) (r).cmic_to_core_pll_x2_2_control_2[0]=(((r).cmic_to_core_pll_x2_2_control_2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_RESERVEDf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_2[0]) >> 4) & 0x7ffffff)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_RESERVEDf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_2[0]=(((r).cmic_to_core_pll_x2_2_control_2[0] & ~((uint32_t)0x7ffffff << 4)) | ((((uint32_t)f) & 0x7ffffff) << 4))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_PWRDN_CK_DRIVERf_GET(r) ((((r).cmic_to_core_pll_x2_2_control_2[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_PWRDN_CK_DRIVERf_SET(r,f) (r).cmic_to_core_pll_x2_2_control_2[0]=(((r).cmic_to_core_pll_x2_2_control_2[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_TO_CORE_PLL_X2_2_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r,r._cmic_to_core_pll_x2_2_control_2)
#define BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r,r._cmic_to_core_pll_x2_2_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_SIZE BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_SIZE
typedef BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_t CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_t;
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_CLR BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_CLR
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_TESTA_SELf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_TESTA_SELf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_TESTA_SELf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_TESTA_SELf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_ATTEN_FREFf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_ATTEN_FREFf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_ATTEN_FREFf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_ATTEN_FREFf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_DIV_BY_2f_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_DIV_BY_2f_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_DIV_BY_2f_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_DIV_BY_2f_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_RESERVEDf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_RESERVEDf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_RESERVEDf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_RESERVEDf_SET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_PWRDN_CK_DRIVERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_PWRDN_CK_DRIVERf_GET
#define CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_PWRDN_CK_DRIVERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r_PWRDN_CK_DRIVERf_SET
#define READ_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r
#define WRITE_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TO_CORE_PLL_X2_2_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TO_CORE_PLL_X2_3_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     Core X2 PLL 2 Control[31:0]
 * SIZE:     32
 * FIELDS:
 *     P1_DIVIDER       0001	Divide ratio= 1:	:1110	Divide ratio= 141111	Divide ratio= 15
 *     P2_DIVIDER       0001	Divide ratio= 1:	:1110	Divide ratio= 141111	Divide ratio= 15
 *     PH_DET_DIS       Phase lock detector enable
 *     FREQ_DET_DIS     Frequency lock detector enable
 *     ICPX             000000	Bias current scaling: 0 uA000001	Bias current scaling: 2.5 uA000010	Bias current scaling: 5.0 uA:	:111110	Bias current scaling: 150 uA111111	Bias current scaling: 157.5 uA
 *     RX               00	Rzero= 1.295Kohm, Gma= 57.1uA/Volt01	Rzero= 863ohm, Gma= 71.4uA/Volt10	Rzero= 648ohm, Gma= 95.2uA/Volt11	Rzero= 518ohm, Gma= 95.2uA/Volt
 *     VC_EN            0	VDD/R bias current generator enabled1	Self bias (Vc) current generator enabled
 *     VCO_RNG          00	Fvco range: 460 ? 710 MHz01	Fvco range: 570 ? 1070 MHz10	Fvco range: 910 ? 1930 MHz11	Fvco range: 1700 ? 3500 MHz
 *     KVCO_XF          000	Fast Gm nominal scaling001	Fast Gm 1.5X scaling010	Fast Gm 2X scaling011	Fast Gm 2.5X scaling100	Fast Gm 2.5X scaling101	Fast Gm 3X scaling110	Fast Gm 3.5X scaling111	Fast Gm 4X scaling
 *     KVCO_XS          000	Fast Gm nominal scaling001	Fast Gm 1.5X scaling010	Fast Gm 2X scaling011	Fast Gm 2.5X scaling100	Fast Gm 2.5X scaling101	Fast Gm 3X scaling110	Fast Gm 3.5X scaling111	Fast Gm 4X scaling
 *     TESTD_EN         Digital test enable
 *     TESTD_SEL        000	clk2_out001	clk1_out010	fdbk_out011	fdbk2x_out100	N divider output101	lock detector output110	fbclki signal111	refclki signal
 *     TESTA_EN         Analog DC test enable
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r 0x00000594

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TO_CORE_PLL_X2_3_CONTROL_1.
 *
 */
typedef union BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_to_core_pll_x2_3_control_1[1];
	uint32_t _cmic_to_core_pll_x2_3_control_1;
} BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_t;

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_CLR(r) (r).cmic_to_core_pll_x2_3_control_1[0] = 0
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_SET(r,d) (r).cmic_to_core_pll_x2_3_control_1[0] = d
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_GET(r) (r).cmic_to_core_pll_x2_3_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P1_DIVIDERf_GET(r) (((r).cmic_to_core_pll_x2_3_control_1[0]) & 0xf)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P1_DIVIDERf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P2_DIVIDERf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 4) & 0xf)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P2_DIVIDERf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_PH_DET_DISf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_PH_DET_DISf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_FREQ_DET_DISf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 9) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_FREQ_DET_DISf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_ICPXf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 10) & 0x3f)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_ICPXf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_RXf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 16) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_RXf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VC_ENf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VC_ENf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VCO_RNGf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 19) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VCO_RNGf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XFf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 21) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XFf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XSf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 24) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XSf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_ENf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_ENf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_SELf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 28) & 0x7)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_SELf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTA_ENf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_1[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTA_ENf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_1[0]=(((r).cmic_to_core_pll_x2_3_control_1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_TO_CORE_PLL_X2_3_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r,r._cmic_to_core_pll_x2_3_control_1)
#define BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r,r._cmic_to_core_pll_x2_3_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_SIZE BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_SIZE
typedef BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_t CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_t;
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_CLR BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_CLR
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P1_DIVIDERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P1_DIVIDERf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P1_DIVIDERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P1_DIVIDERf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P2_DIVIDERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P2_DIVIDERf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P2_DIVIDERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_P2_DIVIDERf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_PH_DET_DISf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_PH_DET_DISf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_PH_DET_DISf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_PH_DET_DISf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_FREQ_DET_DISf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_FREQ_DET_DISf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_FREQ_DET_DISf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_FREQ_DET_DISf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_ICPXf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_ICPXf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_ICPXf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_ICPXf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_RXf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_RXf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_RXf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_RXf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VC_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VC_ENf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VC_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VC_ENf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VCO_RNGf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VCO_RNGf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VCO_RNGf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_VCO_RNGf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XFf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XFf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XFf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XFf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XSf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XSf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XSf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_KVCO_XSf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_ENf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_ENf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_SELf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_SELf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_SELf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTD_SELf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTA_ENf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTA_ENf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTA_ENf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r_TESTA_ENf_SET
#define READ_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r
#define WRITE_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_TO_CORE_PLL_X2_3_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     Core X2 PLL 2 Control[63:32]
 * SIZE:     32
 * FIELDS:
 *     TESTA_SEL        00: vco_vreg DC probe point; 01: vcf loop filter DC probe point; 10: vcs loop filter DC probe point; 11: vci loop filter DC probe point
 *     ATTEN_FREF       0: FREF input attenuator= 0 dB; 1: FREF input attenuator= 6 dB
 *     DIV_BY_2         VCO divide-by-2 CML output enable
 *     RESERVED         Reserved
 *     PWRDN_CK_DRIVER  Power down ckdriver
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r 0x00000598

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_TO_CORE_PLL_X2_3_CONTROL_2.
 *
 */
typedef union BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_to_core_pll_x2_3_control_2[1];
	uint32_t _cmic_to_core_pll_x2_3_control_2;
} BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_t;

#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_CLR(r) (r).cmic_to_core_pll_x2_3_control_2[0] = 0
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_SET(r,d) (r).cmic_to_core_pll_x2_3_control_2[0] = d
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_GET(r) (r).cmic_to_core_pll_x2_3_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_TESTA_SELf_GET(r) (((r).cmic_to_core_pll_x2_3_control_2[0]) & 0x3)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_TESTA_SELf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_2[0]=(((r).cmic_to_core_pll_x2_3_control_2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_ATTEN_FREFf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_2[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_ATTEN_FREFf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_2[0]=(((r).cmic_to_core_pll_x2_3_control_2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_DIV_BY_2f_GET(r) ((((r).cmic_to_core_pll_x2_3_control_2[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_DIV_BY_2f_SET(r,f) (r).cmic_to_core_pll_x2_3_control_2[0]=(((r).cmic_to_core_pll_x2_3_control_2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_RESERVEDf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_2[0]) >> 4) & 0x7ffffff)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_RESERVEDf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_2[0]=(((r).cmic_to_core_pll_x2_3_control_2[0] & ~((uint32_t)0x7ffffff << 4)) | ((((uint32_t)f) & 0x7ffffff) << 4))
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_PWRDN_CK_DRIVERf_GET(r) ((((r).cmic_to_core_pll_x2_3_control_2[0]) >> 31) & 0x1)
#define BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_PWRDN_CK_DRIVERf_SET(r,f) (r).cmic_to_core_pll_x2_3_control_2[0]=(((r).cmic_to_core_pll_x2_3_control_2[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access CMIC_TO_CORE_PLL_X2_3_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r,r._cmic_to_core_pll_x2_3_control_2)
#define BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r,r._cmic_to_core_pll_x2_3_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_SIZE BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_SIZE
typedef BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_t CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_t;
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_CLR BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_CLR
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_TESTA_SELf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_TESTA_SELf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_TESTA_SELf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_TESTA_SELf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_ATTEN_FREFf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_ATTEN_FREFf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_ATTEN_FREFf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_ATTEN_FREFf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_DIV_BY_2f_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_DIV_BY_2f_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_DIV_BY_2f_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_DIV_BY_2f_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_RESERVEDf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_RESERVEDf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_RESERVEDf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_RESERVEDf_SET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_PWRDN_CK_DRIVERf_GET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_PWRDN_CK_DRIVERf_GET
#define CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_PWRDN_CK_DRIVERf_SET BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r_PWRDN_CK_DRIVERf_SET
#define READ_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r BCM56800_A0_READ_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r
#define WRITE_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r BCM56800_A0_WRITE_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_TO_CORE_PLL_X2_3_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS0_PLL_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL 0 Control register 1
 * SIZE:     32
 * FIELDS:
 *     OAC              XAUI PLL 0 CONTROL register bits [2:0] - Output Amplitude Control
 *     LCP_CTRL         XAUI PLL 0 CONTROL register bits [5:3] - Charge Pump Current Control
 *     BIAS_CTRL        XAUI PLLCONTROL register bits [7:6] - Bias Control
 *     PLL_OBSERVE      XAUI PLL 0 CONTROL register bits [10:8] - PLL Observe;000=test none, 001=test Vc, 010=test CK, 100=test bias
 *     VTH_CTRL         XAUI PLL 0 CONTROL register bits [12:11] - Comparator Threshold Control
 *     PLL_SEQSTART     Enables VCO tuning sequencer
 *     RESERVED_0       Reserved
 *     CAP_RETRY_EN     Enable retry on cap search failure (inverted)
 *     FREQ_MONITOR_EN  Continuously monitor VCO freq (inverted)
 *     FREQDETRESTART_EN Enable restart on freq det failure (inverted)
 *     FREQDETRETRY_EN  Enable retry on freq det failure (inverted)
 *     PLLFORCEDONE_EN  Enable pllForceFdone and pllForceFpass into pllSeq
 *     PLLFORCEFDONE    Force freqDone
 *     PLLFORCEFPASS    Force freqPass
 *     PLLFORCECAPDONE_EN Enable pllForceCapDone
 *     PLLFORCECAPDONE  Force capDone
 *     PLLFORCECAPPASS_EN Enable pllForceCapPass
 *     PLLFORCECAPPASS  pllForceCapPass
 *     CAPRESTART       Force cap sequencer to restart
 *     CAPSELECTM_EN    Enable cap select register bits
 *     CAPSELECT_3_0    Lower four bits of VCO cap select; 0000 for most cap and lowest frequency
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r 0x00000584

#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS0_PLL_CONTROL_1.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs0_pll_control_1[1];
	uint32_t _cmic_xgxs0_pll_control_1;
} BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_t;

#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CLR(r) (r).cmic_xgxs0_pll_control_1[0] = 0
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_SET(r,d) (r).cmic_xgxs0_pll_control_1[0] = d
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_GET(r) (r).cmic_xgxs0_pll_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_OACf_GET(r) (((r).cmic_xgxs0_pll_control_1[0]) & 0x7)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_OACf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_LCP_CTRLf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 3) & 0x7)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_LCP_CTRLf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_BIAS_CTRLf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 6) & 0x3)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_BIAS_CTRLf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLL_OBSERVEf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 8) & 0x7)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLL_OBSERVEf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_VTH_CTRLf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 11) & 0x3)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_VTH_CTRLf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLL_SEQSTARTf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLL_SEQSTARTf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_RESERVED_0f_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 14) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_RESERVED_0f_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAP_RETRY_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 15) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAP_RETRY_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQ_MONITOR_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 16) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQ_MONITOR_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRESTART_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRESTART_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRETRY_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRETRY_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEDONE_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 19) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEDONE_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFDONEf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 20) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFDONEf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFPASSf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 21) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFPASSf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 22) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONEf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 23) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONEf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 24) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASSf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 25) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASSf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPRESTARTf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 26) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPRESTARTf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECTM_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECTM_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECT_3_0f_GET(r) ((((r).cmic_xgxs0_pll_control_1[0]) >> 28) & 0xf)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECT_3_0f_SET(r,f) (r).cmic_xgxs0_pll_control_1[0]=(((r).cmic_xgxs0_pll_control_1[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_XGXS0_PLL_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS0_PLL_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r,r._cmic_xgxs0_pll_control_1)
#define BCM56800_A0_WRITE_CMIC_XGXS0_PLL_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r,r._cmic_xgxs0_pll_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS0_PLL_CONTROL_1r BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r
#define CMIC_XGXS0_PLL_CONTROL_1r_SIZE BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_SIZE
typedef BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_t CMIC_XGXS0_PLL_CONTROL_1r_t;
#define CMIC_XGXS0_PLL_CONTROL_1r_CLR BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CLR
#define CMIC_XGXS0_PLL_CONTROL_1r_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_OACf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_OACf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_OACf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_OACf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_LCP_CTRLf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_LCP_CTRLf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_LCP_CTRLf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_LCP_CTRLf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_BIAS_CTRLf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_BIAS_CTRLf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_BIAS_CTRLf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_BIAS_CTRLf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLL_OBSERVEf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLL_OBSERVEf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLL_OBSERVEf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLL_OBSERVEf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_VTH_CTRLf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_VTH_CTRLf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_VTH_CTRLf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_VTH_CTRLf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLL_SEQSTARTf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLL_SEQSTARTf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLL_SEQSTARTf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLL_SEQSTARTf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_RESERVED_0f_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_RESERVED_0f_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_CAP_RETRY_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAP_RETRY_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_CAP_RETRY_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAP_RETRY_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_FREQ_MONITOR_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQ_MONITOR_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_FREQ_MONITOR_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQ_MONITOR_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRESTART_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRESTART_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRESTART_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRESTART_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRETRY_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRETRY_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRETRY_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_FREQDETRETRY_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEDONE_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEDONE_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEDONE_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEDONE_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFDONEf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFDONEf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFDONEf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFDONEf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFPASSf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFPASSf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFPASSf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCEFPASSf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONEf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONEf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONEf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPDONEf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASSf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASSf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASSf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_PLLFORCECAPPASSf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_CAPRESTARTf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPRESTARTf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_CAPRESTARTf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPRESTARTf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECTM_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECTM_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECTM_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECTM_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECT_3_0f_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECT_3_0f_GET
#define CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECT_3_0f_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r_CAPSELECT_3_0f_SET
#define READ_CMIC_XGXS0_PLL_CONTROL_1r BCM56800_A0_READ_CMIC_XGXS0_PLL_CONTROL_1r
#define WRITE_CMIC_XGXS0_PLL_CONTROL_1r BCM56800_A0_WRITE_CMIC_XGXS0_PLL_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS0_PLL_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS 0 PLL Control register 2
 * SIZE:     32
 * FIELDS:
 *     CAPSELECT_4      MS bit of VCO cap select; 0000 for most cap and lowest frequency (bit 32 of PLLCTRL[35:0])
 *     CAPFORCESLOWDOWN_EN Enable capForceSlowdown into capSeq (bit 33 of PLLCTRL[35:0])
 *     CAPFORCESLOWDOWN Force slowdown (bit 34 of PLLCTRL[35:0])
 *     SLOWDOWN_XOR     Invert slowdown (bit 35 of PLLCTRL[35:0])
 *     XGPLL_EN125      Enable 125MHz clock
 *     XGPLL_BYPASS_CML Bypass reference input REFP/N to 156.25MHz outputs.
 *     XGPLL_BYPASS_CMOS XG PLL 0 bypass CMOS clock: 0=LCPLL 156MHz clock, 1=input bypass clock
 *     XGPLL_BYPASS_CLK156 XG PLL 0 bypass CLK156
 *     XGPLL_CONTROL_PWRDN XG PLL 0 Control power down
 *     XGPLL_STATUS     XAUI PLL 0 Status bits [15:0]
 *     CMIC_XGPLL_LOCK  XGXS PLL 0 Lock
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r 0x00000588

#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS0_PLL_CONTROL_2.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs0_pll_control_2[1];
	uint32_t _cmic_xgxs0_pll_control_2;
} BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_t;

#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CLR(r) (r).cmic_xgxs0_pll_control_2[0] = 0
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_SET(r,d) (r).cmic_xgxs0_pll_control_2[0] = d
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_GET(r) (r).cmic_xgxs0_pll_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPSELECT_4f_GET(r) (((r).cmic_xgxs0_pll_control_2[0]) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPSELECT_4f_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_SLOWDOWN_XORf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_SLOWDOWN_XORf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_EN125f_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_EN125f_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 5) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_STATUSf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 9) & 0xffff)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_STATUSf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 25) & 0x1)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_RESERVEDf_GET(r) ((((r).cmic_xgxs0_pll_control_2[0]) >> 26) & 0x3f)
#define BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_RESERVEDf_SET(r,f) (r).cmic_xgxs0_pll_control_2[0]=(((r).cmic_xgxs0_pll_control_2[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_XGXS0_PLL_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS0_PLL_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r,r._cmic_xgxs0_pll_control_2)
#define BCM56800_A0_WRITE_CMIC_XGXS0_PLL_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r,r._cmic_xgxs0_pll_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS0_PLL_CONTROL_2r BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r
#define CMIC_XGXS0_PLL_CONTROL_2r_SIZE BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_SIZE
typedef BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_t CMIC_XGXS0_PLL_CONTROL_2r_t;
#define CMIC_XGXS0_PLL_CONTROL_2r_CLR BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CLR
#define CMIC_XGXS0_PLL_CONTROL_2r_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_CAPSELECT_4f_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPSELECT_4f_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_CAPSELECT_4f_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPSELECT_4f_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_SLOWDOWN_XORf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_SLOWDOWN_XORf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_SLOWDOWN_XORf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_SLOWDOWN_XORf_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_EN125f_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_EN125f_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_EN125f_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_EN125f_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_STATUSf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_STATUSf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_STATUSf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_XGPLL_STATUSf_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_SET
#define CMIC_XGXS0_PLL_CONTROL_2r_RESERVEDf_GET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_RESERVEDf_GET
#define CMIC_XGXS0_PLL_CONTROL_2r_RESERVEDf_SET BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r_RESERVEDf_SET
#define READ_CMIC_XGXS0_PLL_CONTROL_2r BCM56800_A0_READ_CMIC_XGXS0_PLL_CONTROL_2r
#define WRITE_CMIC_XGXS0_PLL_CONTROL_2r BCM56800_A0_WRITE_CMIC_XGXS0_PLL_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS0_PLL_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS1_PLL_CONTROL_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL 1 Control register 1
 * SIZE:     32
 * FIELDS:
 *     OAC              XAUI PLL 0 CONTROL register bits [2:0] - Output Amplitude Control
 *     LCP_CTRL         XAUI PLL 0 CONTROL register bits [5:3] - Charge Pump Current Control
 *     BIAS_CTRL        XAUI PLLCONTROL register bits [7:6] - Bias Control
 *     PLL_OBSERVE      XAUI PLL 0 CONTROL register bits [10:8] - PLL Observe;000=test none, 001=test Vc, 010=test CK, 100=test bias
 *     VTH_CTRL         XAUI PLL 0 CONTROL register bits [12:11] - Comparator Threshold Control
 *     PLL_SEQSTART     Enables VCO tuning sequencer
 *     RESERVED_0       Reserved
 *     CAP_RETRY_EN     Enable retry on cap search failure (inverted)
 *     FREQ_MONITOR_EN  Continuously monitor VCO freq (inverted)
 *     FREQDETRESTART_EN Enable restart on freq det failure (inverted)
 *     FREQDETRETRY_EN  Enable retry on freq det failure (inverted)
 *     PLLFORCEDONE_EN  Enable pllForceFdone and pllForceFpass into pllSeq
 *     PLLFORCEFDONE    Force freqDone
 *     PLLFORCEFPASS    Force freqPass
 *     PLLFORCECAPDONE_EN Enable pllForceCapDone
 *     PLLFORCECAPDONE  Force capDone
 *     PLLFORCECAPPASS_EN Enable pllForceCapPass
 *     PLLFORCECAPPASS  pllForceCapPass
 *     CAPRESTART       Force cap sequencer to restart
 *     CAPSELECTM_EN    Enable cap select register bits
 *     CAPSELECT_3_0    Lower four bits of VCO cap select; 0000 for most cap and lowest frequency
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r 0x0000058c

#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS1_PLL_CONTROL_1.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs1_pll_control_1[1];
	uint32_t _cmic_xgxs1_pll_control_1;
} BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_t;

#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CLR(r) (r).cmic_xgxs1_pll_control_1[0] = 0
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_SET(r,d) (r).cmic_xgxs1_pll_control_1[0] = d
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_GET(r) (r).cmic_xgxs1_pll_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_OACf_GET(r) (((r).cmic_xgxs1_pll_control_1[0]) & 0x7)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_OACf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_LCP_CTRLf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 3) & 0x7)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_LCP_CTRLf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_BIAS_CTRLf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 6) & 0x3)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_BIAS_CTRLf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLL_OBSERVEf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 8) & 0x7)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLL_OBSERVEf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_VTH_CTRLf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 11) & 0x3)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_VTH_CTRLf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLL_SEQSTARTf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLL_SEQSTARTf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_RESERVED_0f_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 14) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_RESERVED_0f_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAP_RETRY_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 15) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAP_RETRY_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQ_MONITOR_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 16) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQ_MONITOR_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRESTART_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 17) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRESTART_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRETRY_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRETRY_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEDONE_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 19) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEDONE_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFDONEf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 20) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFDONEf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFPASSf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 21) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFPASSf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 22) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONEf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 23) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONEf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 24) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASSf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 25) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASSf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPRESTARTf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 26) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPRESTARTf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECTM_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 27) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECTM_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECT_3_0f_GET(r) ((((r).cmic_xgxs1_pll_control_1[0]) >> 28) & 0xf)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECT_3_0f_SET(r,f) (r).cmic_xgxs1_pll_control_1[0]=(((r).cmic_xgxs1_pll_control_1[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CMIC_XGXS1_PLL_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS1_PLL_CONTROL_1r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r,r._cmic_xgxs1_pll_control_1)
#define BCM56800_A0_WRITE_CMIC_XGXS1_PLL_CONTROL_1r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r,r._cmic_xgxs1_pll_control_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS1_PLL_CONTROL_1r BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r
#define CMIC_XGXS1_PLL_CONTROL_1r_SIZE BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_SIZE
typedef BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_t CMIC_XGXS1_PLL_CONTROL_1r_t;
#define CMIC_XGXS1_PLL_CONTROL_1r_CLR BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CLR
#define CMIC_XGXS1_PLL_CONTROL_1r_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_OACf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_OACf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_OACf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_OACf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_LCP_CTRLf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_LCP_CTRLf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_LCP_CTRLf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_LCP_CTRLf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_BIAS_CTRLf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_BIAS_CTRLf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_BIAS_CTRLf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_BIAS_CTRLf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLL_OBSERVEf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLL_OBSERVEf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLL_OBSERVEf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLL_OBSERVEf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_VTH_CTRLf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_VTH_CTRLf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_VTH_CTRLf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_VTH_CTRLf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLL_SEQSTARTf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLL_SEQSTARTf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLL_SEQSTARTf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLL_SEQSTARTf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_RESERVED_0f_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_RESERVED_0f_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_CAP_RETRY_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAP_RETRY_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_CAP_RETRY_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAP_RETRY_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_FREQ_MONITOR_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQ_MONITOR_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_FREQ_MONITOR_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQ_MONITOR_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRESTART_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRESTART_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRESTART_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRESTART_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRETRY_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRETRY_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRETRY_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_FREQDETRETRY_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEDONE_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEDONE_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEDONE_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEDONE_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFDONEf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFDONEf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFDONEf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFDONEf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFPASSf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFPASSf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFPASSf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCEFPASSf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONE_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONEf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONEf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONEf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPDONEf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASS_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASSf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASSf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASSf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_PLLFORCECAPPASSf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_CAPRESTARTf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPRESTARTf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_CAPRESTARTf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPRESTARTf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECTM_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECTM_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECTM_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECTM_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECT_3_0f_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECT_3_0f_GET
#define CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECT_3_0f_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r_CAPSELECT_3_0f_SET
#define READ_CMIC_XGXS1_PLL_CONTROL_1r BCM56800_A0_READ_CMIC_XGXS1_PLL_CONTROL_1r
#define WRITE_CMIC_XGXS1_PLL_CONTROL_1r BCM56800_A0_WRITE_CMIC_XGXS1_PLL_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS1_PLL_CONTROL_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS PLL 1 Control register 2
 * SIZE:     32
 * FIELDS:
 *     CAPSELECT_4      MS bit of VCO cap select; 0000 for most cap and lowest frequency (bit 32 of PLLCTRL[35:0])
 *     CAPFORCESLOWDOWN_EN Enable capForceSlowdown into capSeq (bit 33 of PLLCTRL[35:0])
 *     CAPFORCESLOWDOWN Force slowdown (bit 34 of PLLCTRL[35:0])
 *     SLOWDOWN_XOR     Invert slowdown (bit 35 of PLLCTRL[35:0])
 *     XGPLL_EN125      Enable 125MHz clock
 *     XGPLL_BYPASS_CML Bypass reference input REFP/N to 156.25MHz outputs.
 *     XGPLL_BYPASS_CMOS XG PLL 0 bypass CMOS clock: 0=LCPLL 156MHz clock, 1=input bypass clock
 *     XGPLL_BYPASS_CLK156 XG PLL 0 bypass CLK156
 *     XGPLL_CONTROL_PWRDN XG PLL 0 Control power down
 *     XGPLL_STATUS     XAUI PLL 0 Status bits [15:0]
 *     CMIC_XGPLL_LOCK  XGXS PLL 0 Lock
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r 0x00000590

#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS1_PLL_CONTROL_2.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs1_pll_control_2[1];
	uint32_t _cmic_xgxs1_pll_control_2;
} BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_t;

#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CLR(r) (r).cmic_xgxs1_pll_control_2[0] = 0
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_SET(r,d) (r).cmic_xgxs1_pll_control_2[0] = d
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_GET(r) (r).cmic_xgxs1_pll_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPSELECT_4f_GET(r) (((r).cmic_xgxs1_pll_control_2[0]) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPSELECT_4f_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 1) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 2) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_SLOWDOWN_XORf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 3) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_SLOWDOWN_XORf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_EN125f_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 4) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_EN125f_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 5) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 6) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 7) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 8) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_STATUSf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 9) & 0xffff)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_STATUSf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 25) & 0x1)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_RESERVEDf_GET(r) ((((r).cmic_xgxs1_pll_control_2[0]) >> 26) & 0x3f)
#define BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_RESERVEDf_SET(r,f) (r).cmic_xgxs1_pll_control_2[0]=(((r).cmic_xgxs1_pll_control_2[0] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))

/*
 * These macros can be used to access CMIC_XGXS1_PLL_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS1_PLL_CONTROL_2r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r,r._cmic_xgxs1_pll_control_2)
#define BCM56800_A0_WRITE_CMIC_XGXS1_PLL_CONTROL_2r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r,r._cmic_xgxs1_pll_control_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS1_PLL_CONTROL_2r BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r
#define CMIC_XGXS1_PLL_CONTROL_2r_SIZE BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_SIZE
typedef BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_t CMIC_XGXS1_PLL_CONTROL_2r_t;
#define CMIC_XGXS1_PLL_CONTROL_2r_CLR BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CLR
#define CMIC_XGXS1_PLL_CONTROL_2r_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_CAPSELECT_4f_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPSELECT_4f_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_CAPSELECT_4f_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPSELECT_4f_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWN_ENf_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CAPFORCESLOWDOWNf_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_SLOWDOWN_XORf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_SLOWDOWN_XORf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_SLOWDOWN_XORf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_SLOWDOWN_XORf_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_EN125f_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_EN125f_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_EN125f_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_EN125f_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMLf_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CMOSf_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_BYPASS_CLK156f_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_CONTROL_PWRDNf_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_STATUSf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_STATUSf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_STATUSf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_XGPLL_STATUSf_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_CMIC_XGPLL_LOCKf_SET
#define CMIC_XGXS1_PLL_CONTROL_2r_RESERVEDf_GET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_RESERVEDf_GET
#define CMIC_XGXS1_PLL_CONTROL_2r_RESERVEDf_SET BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r_RESERVEDf_SET
#define READ_CMIC_XGXS1_PLL_CONTROL_2r BCM56800_A0_READ_CMIC_XGXS1_PLL_CONTROL_2r
#define WRITE_CMIC_XGXS1_PLL_CONTROL_2r BCM56800_A0_WRITE_CMIC_XGXS1_PLL_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS1_PLL_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 0 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr 0x00000500

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config[1];
	uint32_t _cmic_xgxs_mdio_config;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_CLR(r) (r).cmic_xgxs_mdio_config[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_SET(r,d) (r).cmic_xgxs_mdio_config[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_GET(r) (r).cmic_xgxs_mdio_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config[0]=(((r).cmic_xgxs_mdio_config[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config[0]=(((r).cmic_xgxs_mdio_config[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config[0]=(((r).cmic_xgxs_mdio_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config[0]=(((r).cmic_xgxs_mdio_config[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIGr(u,i,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr+(4*(i)),r._cmic_xgxs_mdio_config)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIGr(u,i,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr+(4*(i)),r._cmic_xgxs_mdio_config)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIGr BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr
#define CMIC_XGXS_MDIO_CONFIGr_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_t CMIC_XGXS_MDIO_CONFIGr_t;
#define CMIC_XGXS_MDIO_CONFIGr_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_CLR
#define CMIC_XGXS_MDIO_CONFIGr_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_SET
#define CMIC_XGXS_MDIO_CONFIGr_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_GET
#define CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIGr_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIGr_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIGr BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIGr
#define WRITE_CMIC_XGXS_MDIO_CONFIGr BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_0
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 0 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r 0x00000500

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_0.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_0[1];
	uint32_t _cmic_xgxs_mdio_config_0;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_CLR(r) (r).cmic_xgxs_mdio_config_0[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_SET(r,d) (r).cmic_xgxs_mdio_config_0[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_GET(r) (r).cmic_xgxs_mdio_config_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_0[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_0[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_0[0]=(((r).cmic_xgxs_mdio_config_0[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_0.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_0r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r,r._cmic_xgxs_mdio_config_0)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_0r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r,r._cmic_xgxs_mdio_config_0)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_0r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r
#define CMIC_XGXS_MDIO_CONFIG_0r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_t CMIC_XGXS_MDIO_CONFIG_0r_t;
#define CMIC_XGXS_MDIO_CONFIG_0r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_CLR
#define CMIC_XGXS_MDIO_CONFIG_0r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_0r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_0r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_0r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_1
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 1 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r 0x00000504

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_1.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_1[1];
	uint32_t _cmic_xgxs_mdio_config_1;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_CLR(r) (r).cmic_xgxs_mdio_config_1[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_SET(r,d) (r).cmic_xgxs_mdio_config_1[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_GET(r) (r).cmic_xgxs_mdio_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_1[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_1[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_1[0]=(((r).cmic_xgxs_mdio_config_1[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_1.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_1r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r,r._cmic_xgxs_mdio_config_1)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_1r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r,r._cmic_xgxs_mdio_config_1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_1r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r
#define CMIC_XGXS_MDIO_CONFIG_1r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_t CMIC_XGXS_MDIO_CONFIG_1r_t;
#define CMIC_XGXS_MDIO_CONFIG_1r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_CLR
#define CMIC_XGXS_MDIO_CONFIG_1r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_1r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_1r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_1r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_10
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 10 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r 0x00000528

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_10.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_10[1];
	uint32_t _cmic_xgxs_mdio_config_10;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_CLR(r) (r).cmic_xgxs_mdio_config_10[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_SET(r,d) (r).cmic_xgxs_mdio_config_10[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_GET(r) (r).cmic_xgxs_mdio_config_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_10[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_10[0]=(((r).cmic_xgxs_mdio_config_10[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_10[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_10[0]=(((r).cmic_xgxs_mdio_config_10[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_10[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_10[0]=(((r).cmic_xgxs_mdio_config_10[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_10[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_10[0]=(((r).cmic_xgxs_mdio_config_10[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_10.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_10r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r,r._cmic_xgxs_mdio_config_10)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_10r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r,r._cmic_xgxs_mdio_config_10)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_10r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r
#define CMIC_XGXS_MDIO_CONFIG_10r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_t CMIC_XGXS_MDIO_CONFIG_10r_t;
#define CMIC_XGXS_MDIO_CONFIG_10r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_CLR
#define CMIC_XGXS_MDIO_CONFIG_10r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_SET
#define CMIC_XGXS_MDIO_CONFIG_10r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_GET
#define CMIC_XGXS_MDIO_CONFIG_10r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_10r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_10r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_10r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_10r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_10r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_10r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_10r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_10r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_10r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_10r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_10r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_11
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 11 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r 0x0000052c

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_11.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_11[1];
	uint32_t _cmic_xgxs_mdio_config_11;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_CLR(r) (r).cmic_xgxs_mdio_config_11[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_SET(r,d) (r).cmic_xgxs_mdio_config_11[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_GET(r) (r).cmic_xgxs_mdio_config_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_11[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_11[0]=(((r).cmic_xgxs_mdio_config_11[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_11[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_11[0]=(((r).cmic_xgxs_mdio_config_11[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_11[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_11[0]=(((r).cmic_xgxs_mdio_config_11[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_11[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_11[0]=(((r).cmic_xgxs_mdio_config_11[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_11.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_11r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r,r._cmic_xgxs_mdio_config_11)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_11r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r,r._cmic_xgxs_mdio_config_11)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_11r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r
#define CMIC_XGXS_MDIO_CONFIG_11r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_t CMIC_XGXS_MDIO_CONFIG_11r_t;
#define CMIC_XGXS_MDIO_CONFIG_11r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_CLR
#define CMIC_XGXS_MDIO_CONFIG_11r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_SET
#define CMIC_XGXS_MDIO_CONFIG_11r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_GET
#define CMIC_XGXS_MDIO_CONFIG_11r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_11r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_11r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_11r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_11r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_11r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_11r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_11r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_11r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_11r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_11r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_11r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_12
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 12 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r 0x00000530

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_12.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_12[1];
	uint32_t _cmic_xgxs_mdio_config_12;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_CLR(r) (r).cmic_xgxs_mdio_config_12[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_SET(r,d) (r).cmic_xgxs_mdio_config_12[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_GET(r) (r).cmic_xgxs_mdio_config_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_12[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_12[0]=(((r).cmic_xgxs_mdio_config_12[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_12[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_12[0]=(((r).cmic_xgxs_mdio_config_12[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_12[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_12[0]=(((r).cmic_xgxs_mdio_config_12[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_12[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_12[0]=(((r).cmic_xgxs_mdio_config_12[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_12.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_12r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r,r._cmic_xgxs_mdio_config_12)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_12r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r,r._cmic_xgxs_mdio_config_12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_12r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r
#define CMIC_XGXS_MDIO_CONFIG_12r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_t CMIC_XGXS_MDIO_CONFIG_12r_t;
#define CMIC_XGXS_MDIO_CONFIG_12r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_CLR
#define CMIC_XGXS_MDIO_CONFIG_12r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_SET
#define CMIC_XGXS_MDIO_CONFIG_12r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_GET
#define CMIC_XGXS_MDIO_CONFIG_12r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_12r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_12r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_12r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_12r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_12r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_12r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_12r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_12r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_12r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_12r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_12r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_13
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 13 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r 0x00000534

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_13.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_13[1];
	uint32_t _cmic_xgxs_mdio_config_13;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_CLR(r) (r).cmic_xgxs_mdio_config_13[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_SET(r,d) (r).cmic_xgxs_mdio_config_13[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_GET(r) (r).cmic_xgxs_mdio_config_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_13[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_13[0]=(((r).cmic_xgxs_mdio_config_13[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_13[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_13[0]=(((r).cmic_xgxs_mdio_config_13[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_13[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_13[0]=(((r).cmic_xgxs_mdio_config_13[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_13[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_13[0]=(((r).cmic_xgxs_mdio_config_13[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_13.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_13r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r,r._cmic_xgxs_mdio_config_13)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_13r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r,r._cmic_xgxs_mdio_config_13)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_13r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r
#define CMIC_XGXS_MDIO_CONFIG_13r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_t CMIC_XGXS_MDIO_CONFIG_13r_t;
#define CMIC_XGXS_MDIO_CONFIG_13r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_CLR
#define CMIC_XGXS_MDIO_CONFIG_13r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_SET
#define CMIC_XGXS_MDIO_CONFIG_13r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_GET
#define CMIC_XGXS_MDIO_CONFIG_13r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_13r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_13r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_13r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_13r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_13r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_13r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_13r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_13r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_13r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_13r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_13r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_14
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 14 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r 0x00000538

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_14.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_14[1];
	uint32_t _cmic_xgxs_mdio_config_14;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_CLR(r) (r).cmic_xgxs_mdio_config_14[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_SET(r,d) (r).cmic_xgxs_mdio_config_14[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_GET(r) (r).cmic_xgxs_mdio_config_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_14[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_14[0]=(((r).cmic_xgxs_mdio_config_14[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_14[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_14[0]=(((r).cmic_xgxs_mdio_config_14[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_14[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_14[0]=(((r).cmic_xgxs_mdio_config_14[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_14[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_14[0]=(((r).cmic_xgxs_mdio_config_14[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_14.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_14r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r,r._cmic_xgxs_mdio_config_14)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_14r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r,r._cmic_xgxs_mdio_config_14)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_14r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r
#define CMIC_XGXS_MDIO_CONFIG_14r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_t CMIC_XGXS_MDIO_CONFIG_14r_t;
#define CMIC_XGXS_MDIO_CONFIG_14r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_CLR
#define CMIC_XGXS_MDIO_CONFIG_14r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_SET
#define CMIC_XGXS_MDIO_CONFIG_14r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_GET
#define CMIC_XGXS_MDIO_CONFIG_14r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_14r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_14r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_14r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_14r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_14r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_14r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_14r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_14r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_14r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_14r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_14r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_15
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 3 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r 0x0000053c

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_15.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_15[1];
	uint32_t _cmic_xgxs_mdio_config_15;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_CLR(r) (r).cmic_xgxs_mdio_config_15[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_SET(r,d) (r).cmic_xgxs_mdio_config_15[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_GET(r) (r).cmic_xgxs_mdio_config_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_15[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_15[0]=(((r).cmic_xgxs_mdio_config_15[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_15[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_15[0]=(((r).cmic_xgxs_mdio_config_15[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_15[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_15[0]=(((r).cmic_xgxs_mdio_config_15[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_15[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_15[0]=(((r).cmic_xgxs_mdio_config_15[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_15.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_15r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r,r._cmic_xgxs_mdio_config_15)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_15r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r,r._cmic_xgxs_mdio_config_15)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_15r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r
#define CMIC_XGXS_MDIO_CONFIG_15r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_t CMIC_XGXS_MDIO_CONFIG_15r_t;
#define CMIC_XGXS_MDIO_CONFIG_15r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_CLR
#define CMIC_XGXS_MDIO_CONFIG_15r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_SET
#define CMIC_XGXS_MDIO_CONFIG_15r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_GET
#define CMIC_XGXS_MDIO_CONFIG_15r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_15r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_15r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_15r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_15r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_15r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_15r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_15r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_15r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_15r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_15r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_15r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_16
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 16 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r 0x00000540

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_16.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_16[1];
	uint32_t _cmic_xgxs_mdio_config_16;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_CLR(r) (r).cmic_xgxs_mdio_config_16[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_SET(r,d) (r).cmic_xgxs_mdio_config_16[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_GET(r) (r).cmic_xgxs_mdio_config_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_16[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_16[0]=(((r).cmic_xgxs_mdio_config_16[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_16[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_16[0]=(((r).cmic_xgxs_mdio_config_16[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_16[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_16[0]=(((r).cmic_xgxs_mdio_config_16[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_16[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_16[0]=(((r).cmic_xgxs_mdio_config_16[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_16.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_16r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r,r._cmic_xgxs_mdio_config_16)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_16r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r,r._cmic_xgxs_mdio_config_16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_16r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r
#define CMIC_XGXS_MDIO_CONFIG_16r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_t CMIC_XGXS_MDIO_CONFIG_16r_t;
#define CMIC_XGXS_MDIO_CONFIG_16r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_CLR
#define CMIC_XGXS_MDIO_CONFIG_16r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_SET
#define CMIC_XGXS_MDIO_CONFIG_16r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_GET
#define CMIC_XGXS_MDIO_CONFIG_16r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_16r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_16r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_16r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_16r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_16r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_16r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_16r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_16r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_16r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_16r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_16r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_17
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 1 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r 0x00000544

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_17.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_17[1];
	uint32_t _cmic_xgxs_mdio_config_17;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_CLR(r) (r).cmic_xgxs_mdio_config_17[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_SET(r,d) (r).cmic_xgxs_mdio_config_17[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_GET(r) (r).cmic_xgxs_mdio_config_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_17[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_17[0]=(((r).cmic_xgxs_mdio_config_17[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_17[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_17[0]=(((r).cmic_xgxs_mdio_config_17[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_17[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_17[0]=(((r).cmic_xgxs_mdio_config_17[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_17[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_17[0]=(((r).cmic_xgxs_mdio_config_17[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_17.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_17r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r,r._cmic_xgxs_mdio_config_17)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_17r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r,r._cmic_xgxs_mdio_config_17)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_17r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r
#define CMIC_XGXS_MDIO_CONFIG_17r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_t CMIC_XGXS_MDIO_CONFIG_17r_t;
#define CMIC_XGXS_MDIO_CONFIG_17r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_CLR
#define CMIC_XGXS_MDIO_CONFIG_17r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_SET
#define CMIC_XGXS_MDIO_CONFIG_17r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_GET
#define CMIC_XGXS_MDIO_CONFIG_17r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_17r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_17r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_17r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_17r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_17r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_17r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_17r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_17r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_17r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_17r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_17r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_18
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 18 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r 0x00000548

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_18.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_18[1];
	uint32_t _cmic_xgxs_mdio_config_18;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_CLR(r) (r).cmic_xgxs_mdio_config_18[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_SET(r,d) (r).cmic_xgxs_mdio_config_18[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_GET(r) (r).cmic_xgxs_mdio_config_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_18[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_18[0]=(((r).cmic_xgxs_mdio_config_18[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_18[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_18[0]=(((r).cmic_xgxs_mdio_config_18[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_18[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_18[0]=(((r).cmic_xgxs_mdio_config_18[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_18[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_18[0]=(((r).cmic_xgxs_mdio_config_18[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_18.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_18r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r,r._cmic_xgxs_mdio_config_18)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_18r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r,r._cmic_xgxs_mdio_config_18)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_18r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r
#define CMIC_XGXS_MDIO_CONFIG_18r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_t CMIC_XGXS_MDIO_CONFIG_18r_t;
#define CMIC_XGXS_MDIO_CONFIG_18r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_CLR
#define CMIC_XGXS_MDIO_CONFIG_18r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_SET
#define CMIC_XGXS_MDIO_CONFIG_18r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_GET
#define CMIC_XGXS_MDIO_CONFIG_18r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_18r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_18r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_18r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_18r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_18r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_18r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_18r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_18r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_18r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_18r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_18r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_19
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 3 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r 0x0000054c

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_19.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_19[1];
	uint32_t _cmic_xgxs_mdio_config_19;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_CLR(r) (r).cmic_xgxs_mdio_config_19[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_SET(r,d) (r).cmic_xgxs_mdio_config_19[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_GET(r) (r).cmic_xgxs_mdio_config_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_19[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_19[0]=(((r).cmic_xgxs_mdio_config_19[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_19[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_19[0]=(((r).cmic_xgxs_mdio_config_19[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_19[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_19[0]=(((r).cmic_xgxs_mdio_config_19[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_19[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_19[0]=(((r).cmic_xgxs_mdio_config_19[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_19.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_19r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r,r._cmic_xgxs_mdio_config_19)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_19r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r,r._cmic_xgxs_mdio_config_19)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_19r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r
#define CMIC_XGXS_MDIO_CONFIG_19r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_t CMIC_XGXS_MDIO_CONFIG_19r_t;
#define CMIC_XGXS_MDIO_CONFIG_19r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_CLR
#define CMIC_XGXS_MDIO_CONFIG_19r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_SET
#define CMIC_XGXS_MDIO_CONFIG_19r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_GET
#define CMIC_XGXS_MDIO_CONFIG_19r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_19r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_19r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_19r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_19r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_19r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_19r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_19r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_19r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_19r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_19r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_19r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_2
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 2 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r 0x00000508

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_2.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_2[1];
	uint32_t _cmic_xgxs_mdio_config_2;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_CLR(r) (r).cmic_xgxs_mdio_config_2[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_SET(r,d) (r).cmic_xgxs_mdio_config_2[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_GET(r) (r).cmic_xgxs_mdio_config_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_2[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_2[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_2[0]=(((r).cmic_xgxs_mdio_config_2[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_2.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_2r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r,r._cmic_xgxs_mdio_config_2)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_2r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r,r._cmic_xgxs_mdio_config_2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_2r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r
#define CMIC_XGXS_MDIO_CONFIG_2r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_t CMIC_XGXS_MDIO_CONFIG_2r_t;
#define CMIC_XGXS_MDIO_CONFIG_2r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_CLR
#define CMIC_XGXS_MDIO_CONFIG_2r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_2r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_2r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_2r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_3
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 3 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r 0x0000050c

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_3.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_3[1];
	uint32_t _cmic_xgxs_mdio_config_3;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_CLR(r) (r).cmic_xgxs_mdio_config_3[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_SET(r,d) (r).cmic_xgxs_mdio_config_3[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_GET(r) (r).cmic_xgxs_mdio_config_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_3[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_3[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_3[0]=(((r).cmic_xgxs_mdio_config_3[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_3.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_3r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r,r._cmic_xgxs_mdio_config_3)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_3r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r,r._cmic_xgxs_mdio_config_3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_3r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r
#define CMIC_XGXS_MDIO_CONFIG_3r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_t CMIC_XGXS_MDIO_CONFIG_3r_t;
#define CMIC_XGXS_MDIO_CONFIG_3r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_CLR
#define CMIC_XGXS_MDIO_CONFIG_3r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_3r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_3r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_3r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_4
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 4 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r 0x00000510

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_4.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_4[1];
	uint32_t _cmic_xgxs_mdio_config_4;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_CLR(r) (r).cmic_xgxs_mdio_config_4[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_SET(r,d) (r).cmic_xgxs_mdio_config_4[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_GET(r) (r).cmic_xgxs_mdio_config_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_4[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_4[0]=(((r).cmic_xgxs_mdio_config_4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_4[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_4[0]=(((r).cmic_xgxs_mdio_config_4[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_4[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_4[0]=(((r).cmic_xgxs_mdio_config_4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_4[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_4[0]=(((r).cmic_xgxs_mdio_config_4[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_4.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_4r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r,r._cmic_xgxs_mdio_config_4)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_4r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r,r._cmic_xgxs_mdio_config_4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_4r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r
#define CMIC_XGXS_MDIO_CONFIG_4r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_t CMIC_XGXS_MDIO_CONFIG_4r_t;
#define CMIC_XGXS_MDIO_CONFIG_4r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_CLR
#define CMIC_XGXS_MDIO_CONFIG_4r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_SET
#define CMIC_XGXS_MDIO_CONFIG_4r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_GET
#define CMIC_XGXS_MDIO_CONFIG_4r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_4r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_4r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_4r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_4r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_4r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_4r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_4r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_4r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_4r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_4r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_5
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 5 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r 0x00000514

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_5.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_5[1];
	uint32_t _cmic_xgxs_mdio_config_5;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_CLR(r) (r).cmic_xgxs_mdio_config_5[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_SET(r,d) (r).cmic_xgxs_mdio_config_5[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_GET(r) (r).cmic_xgxs_mdio_config_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_5[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_5[0]=(((r).cmic_xgxs_mdio_config_5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_5[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_5[0]=(((r).cmic_xgxs_mdio_config_5[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_5[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_5[0]=(((r).cmic_xgxs_mdio_config_5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_5[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_5[0]=(((r).cmic_xgxs_mdio_config_5[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_5.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_5r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r,r._cmic_xgxs_mdio_config_5)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_5r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r,r._cmic_xgxs_mdio_config_5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_5r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r
#define CMIC_XGXS_MDIO_CONFIG_5r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_t CMIC_XGXS_MDIO_CONFIG_5r_t;
#define CMIC_XGXS_MDIO_CONFIG_5r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_CLR
#define CMIC_XGXS_MDIO_CONFIG_5r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_SET
#define CMIC_XGXS_MDIO_CONFIG_5r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_GET
#define CMIC_XGXS_MDIO_CONFIG_5r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_5r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_5r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_5r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_5r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_5r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_5r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_5r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_5r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_5r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_5r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_6
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 6 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r 0x00000518

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_6.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_6[1];
	uint32_t _cmic_xgxs_mdio_config_6;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_CLR(r) (r).cmic_xgxs_mdio_config_6[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_SET(r,d) (r).cmic_xgxs_mdio_config_6[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_GET(r) (r).cmic_xgxs_mdio_config_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_6[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_6[0]=(((r).cmic_xgxs_mdio_config_6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_6[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_6[0]=(((r).cmic_xgxs_mdio_config_6[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_6[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_6[0]=(((r).cmic_xgxs_mdio_config_6[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_6[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_6[0]=(((r).cmic_xgxs_mdio_config_6[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_6.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_6r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r,r._cmic_xgxs_mdio_config_6)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_6r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r,r._cmic_xgxs_mdio_config_6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_6r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r
#define CMIC_XGXS_MDIO_CONFIG_6r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_t CMIC_XGXS_MDIO_CONFIG_6r_t;
#define CMIC_XGXS_MDIO_CONFIG_6r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_CLR
#define CMIC_XGXS_MDIO_CONFIG_6r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_SET
#define CMIC_XGXS_MDIO_CONFIG_6r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_GET
#define CMIC_XGXS_MDIO_CONFIG_6r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_6r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_6r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_6r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_6r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_6r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_6r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_6r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_6r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_6r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_6r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_7
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 7 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r 0x0000051c

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_7.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_7[1];
	uint32_t _cmic_xgxs_mdio_config_7;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_CLR(r) (r).cmic_xgxs_mdio_config_7[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_SET(r,d) (r).cmic_xgxs_mdio_config_7[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_GET(r) (r).cmic_xgxs_mdio_config_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_7[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_7[0]=(((r).cmic_xgxs_mdio_config_7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_7[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_7[0]=(((r).cmic_xgxs_mdio_config_7[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_7[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_7[0]=(((r).cmic_xgxs_mdio_config_7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_7[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_7[0]=(((r).cmic_xgxs_mdio_config_7[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_7.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_7r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r,r._cmic_xgxs_mdio_config_7)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_7r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r,r._cmic_xgxs_mdio_config_7)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_7r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r
#define CMIC_XGXS_MDIO_CONFIG_7r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_t CMIC_XGXS_MDIO_CONFIG_7r_t;
#define CMIC_XGXS_MDIO_CONFIG_7r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_CLR
#define CMIC_XGXS_MDIO_CONFIG_7r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_SET
#define CMIC_XGXS_MDIO_CONFIG_7r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_GET
#define CMIC_XGXS_MDIO_CONFIG_7r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_7r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_7r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_7r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_7r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_7r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_7r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_7r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_7r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_7r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_7r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_8
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 8 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r 0x00000520

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_8.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_8[1];
	uint32_t _cmic_xgxs_mdio_config_8;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_CLR(r) (r).cmic_xgxs_mdio_config_8[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_SET(r,d) (r).cmic_xgxs_mdio_config_8[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_GET(r) (r).cmic_xgxs_mdio_config_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_8[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_8[0]=(((r).cmic_xgxs_mdio_config_8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_8[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_8[0]=(((r).cmic_xgxs_mdio_config_8[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_8[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_8[0]=(((r).cmic_xgxs_mdio_config_8[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_8[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_8[0]=(((r).cmic_xgxs_mdio_config_8[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_8.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_8r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r,r._cmic_xgxs_mdio_config_8)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_8r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r,r._cmic_xgxs_mdio_config_8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_8r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r
#define CMIC_XGXS_MDIO_CONFIG_8r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_t CMIC_XGXS_MDIO_CONFIG_8r_t;
#define CMIC_XGXS_MDIO_CONFIG_8r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_CLR
#define CMIC_XGXS_MDIO_CONFIG_8r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_SET
#define CMIC_XGXS_MDIO_CONFIG_8r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_GET
#define CMIC_XGXS_MDIO_CONFIG_8r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_8r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_8r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_8r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_8r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_8r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_8r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_8r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_8r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_8r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_8r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CMIC_XGXS_MDIO_CONFIG_9
 * BLOCKS:   CMIC
 * DESC:     CMIC XGXS MDIO Config 9 register
 * SIZE:     32
 * FIELDS:
 *     IEEE_DEVICES_IN_PKG IEEE devices in XGXS package
 *     MD_DEVAD         MDIO Device address
 *     MD_ST            Internal phy clause 45 select bitWhen 0, use clause 22 MIIM (historic)  addressing.When 1, use clause 45 MIIM (new style) addressing.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r 0x00000524

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_SIZE 4

/*
 * This structure should be used to declare and program CMIC_XGXS_MDIO_CONFIG_9.
 *
 */
typedef union BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_s {
	uint32_t v[1];
	uint32_t cmic_xgxs_mdio_config_9[1];
	uint32_t _cmic_xgxs_mdio_config_9;
} BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_t;

#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_CLR(r) (r).cmic_xgxs_mdio_config_9[0] = 0
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_SET(r,d) (r).cmic_xgxs_mdio_config_9[0] = d
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_GET(r) (r).cmic_xgxs_mdio_config_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_IEEE_DEVICES_IN_PKGf_GET(r) (((r).cmic_xgxs_mdio_config_9[0]) & 0xff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_IEEE_DEVICES_IN_PKGf_SET(r,f) (r).cmic_xgxs_mdio_config_9[0]=(((r).cmic_xgxs_mdio_config_9[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_MD_DEVADf_GET(r) ((((r).cmic_xgxs_mdio_config_9[0]) >> 8) & 0x1f)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_MD_DEVADf_SET(r,f) (r).cmic_xgxs_mdio_config_9[0]=(((r).cmic_xgxs_mdio_config_9[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_MD_STf_GET(r) ((((r).cmic_xgxs_mdio_config_9[0]) >> 13) & 0x1)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_MD_STf_SET(r,f) (r).cmic_xgxs_mdio_config_9[0]=(((r).cmic_xgxs_mdio_config_9[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_RESERVED_0f_GET(r) ((((r).cmic_xgxs_mdio_config_9[0]) >> 14) & 0x3ffff)
#define BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_RESERVED_0f_SET(r,f) (r).cmic_xgxs_mdio_config_9[0]=(((r).cmic_xgxs_mdio_config_9[0] & ~((uint32_t)0x3ffff << 14)) | ((((uint32_t)f) & 0x3ffff) << 14))

/*
 * These macros can be used to access CMIC_XGXS_MDIO_CONFIG_9.
 *
 */
#define BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_9r(u,r) CDK_DEV_READ32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r,r._cmic_xgxs_mdio_config_9)
#define BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_9r(u,r) CDK_DEV_WRITE32(u,BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r,r._cmic_xgxs_mdio_config_9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CMIC_XGXS_MDIO_CONFIG_9r BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r
#define CMIC_XGXS_MDIO_CONFIG_9r_SIZE BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_SIZE
typedef BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_t CMIC_XGXS_MDIO_CONFIG_9r_t;
#define CMIC_XGXS_MDIO_CONFIG_9r_CLR BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_CLR
#define CMIC_XGXS_MDIO_CONFIG_9r_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_SET
#define CMIC_XGXS_MDIO_CONFIG_9r_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_GET
#define CMIC_XGXS_MDIO_CONFIG_9r_IEEE_DEVICES_IN_PKGf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_IEEE_DEVICES_IN_PKGf_GET
#define CMIC_XGXS_MDIO_CONFIG_9r_IEEE_DEVICES_IN_PKGf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_IEEE_DEVICES_IN_PKGf_SET
#define CMIC_XGXS_MDIO_CONFIG_9r_MD_DEVADf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_MD_DEVADf_GET
#define CMIC_XGXS_MDIO_CONFIG_9r_MD_DEVADf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_MD_DEVADf_SET
#define CMIC_XGXS_MDIO_CONFIG_9r_MD_STf_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_MD_STf_GET
#define CMIC_XGXS_MDIO_CONFIG_9r_MD_STf_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_MD_STf_SET
#define CMIC_XGXS_MDIO_CONFIG_9r_RESERVED_0f_GET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_RESERVED_0f_GET
#define CMIC_XGXS_MDIO_CONFIG_9r_RESERVED_0f_SET BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r_RESERVED_0f_SET
#define READ_CMIC_XGXS_MDIO_CONFIG_9r BCM56800_A0_READ_CMIC_XGXS_MDIO_CONFIG_9r
#define WRITE_CMIC_XGXS_MDIO_CONFIG_9r BCM56800_A0_WRITE_CMIC_XGXS_MDIO_CONFIG_9r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CMIC_XGXS_MDIO_CONFIG_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CNG_MAP
 * BLOCKS:   IPIPE
 * DESC:     CNG Mapping Register
 * SIZE:     32
 * FIELDS:
 *     PRIORITY0_CNG    Maps the priority(0) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY1_CNG    Maps the priority(1) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY2_CNG    Maps the priority(2) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY3_CNG    Maps the priority(3) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY4_CNG    Maps the priority(4) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY5_CNG    Maps the priority(5) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY6_CNG    Maps the priority(6) to a default CNG (congestion value for untrusted ports)
 *     PRIORITY7_CNG    Maps the priority(7) to a default CNG (congestion value for untrusted ports)
 *     CFI0_CNG         Maps the incoming CFI(0) to a default CNG (if CFI_AS_CNG is set in ING_CONFIG)
 *     CFI1_CNG         Maps the incoming CFI(1) to a default CNG (if CFI_AS_CNG is set in ING_CONFIG)
 *
 ******************************************************************************/
#define BCM56800_A0_CNG_MAPr 0x0b100000

#define BCM56800_A0_CNG_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CNG_MAP.
 *
 */
typedef union BCM56800_A0_CNG_MAPr_s {
	uint32_t v[1];
	uint32_t cng_map[1];
	uint32_t _cng_map;
} BCM56800_A0_CNG_MAPr_t;

#define BCM56800_A0_CNG_MAPr_CLR(r) (r).cng_map[0] = 0
#define BCM56800_A0_CNG_MAPr_SET(r,d) (r).cng_map[0] = d
#define BCM56800_A0_CNG_MAPr_GET(r) (r).cng_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CNG_MAPr_PRIORITY0_CNGf_GET(r) (((r).cng_map[0]) & 0x3)
#define BCM56800_A0_CNG_MAPr_PRIORITY0_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_CNG_MAPr_PRIORITY1_CNGf_GET(r) ((((r).cng_map[0]) >> 2) & 0x3)
#define BCM56800_A0_CNG_MAPr_PRIORITY1_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_CNG_MAPr_PRIORITY2_CNGf_GET(r) ((((r).cng_map[0]) >> 4) & 0x3)
#define BCM56800_A0_CNG_MAPr_PRIORITY2_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_CNG_MAPr_PRIORITY3_CNGf_GET(r) ((((r).cng_map[0]) >> 6) & 0x3)
#define BCM56800_A0_CNG_MAPr_PRIORITY3_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_CNG_MAPr_PRIORITY4_CNGf_GET(r) ((((r).cng_map[0]) >> 8) & 0x3)
#define BCM56800_A0_CNG_MAPr_PRIORITY4_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56800_A0_CNG_MAPr_PRIORITY5_CNGf_GET(r) ((((r).cng_map[0]) >> 10) & 0x3)
#define BCM56800_A0_CNG_MAPr_PRIORITY5_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56800_A0_CNG_MAPr_PRIORITY6_CNGf_GET(r) ((((r).cng_map[0]) >> 12) & 0x3)
#define BCM56800_A0_CNG_MAPr_PRIORITY6_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56800_A0_CNG_MAPr_PRIORITY7_CNGf_GET(r) ((((r).cng_map[0]) >> 14) & 0x3)
#define BCM56800_A0_CNG_MAPr_PRIORITY7_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56800_A0_CNG_MAPr_CFI0_CNGf_GET(r) ((((r).cng_map[0]) >> 16) & 0x3)
#define BCM56800_A0_CNG_MAPr_CFI0_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_CNG_MAPr_CFI1_CNGf_GET(r) ((((r).cng_map[0]) >> 18) & 0x3)
#define BCM56800_A0_CNG_MAPr_CFI1_CNGf_SET(r,f) (r).cng_map[0]=(((r).cng_map[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))

/*
 * These macros can be used to access CNG_MAP.
 *
 */
#define BCM56800_A0_READ_CNG_MAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_CNG_MAPr,(r._cng_map))
#define BCM56800_A0_WRITE_CNG_MAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_CNG_MAPr,&(r._cng_map))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CNG_MAPr BCM56800_A0_CNG_MAPr
#define CNG_MAPr_SIZE BCM56800_A0_CNG_MAPr_SIZE
typedef BCM56800_A0_CNG_MAPr_t CNG_MAPr_t;
#define CNG_MAPr_CLR BCM56800_A0_CNG_MAPr_CLR
#define CNG_MAPr_SET BCM56800_A0_CNG_MAPr_SET
#define CNG_MAPr_GET BCM56800_A0_CNG_MAPr_GET
#define CNG_MAPr_PRIORITY0_CNGf_GET BCM56800_A0_CNG_MAPr_PRIORITY0_CNGf_GET
#define CNG_MAPr_PRIORITY0_CNGf_SET BCM56800_A0_CNG_MAPr_PRIORITY0_CNGf_SET
#define CNG_MAPr_PRIORITY1_CNGf_GET BCM56800_A0_CNG_MAPr_PRIORITY1_CNGf_GET
#define CNG_MAPr_PRIORITY1_CNGf_SET BCM56800_A0_CNG_MAPr_PRIORITY1_CNGf_SET
#define CNG_MAPr_PRIORITY2_CNGf_GET BCM56800_A0_CNG_MAPr_PRIORITY2_CNGf_GET
#define CNG_MAPr_PRIORITY2_CNGf_SET BCM56800_A0_CNG_MAPr_PRIORITY2_CNGf_SET
#define CNG_MAPr_PRIORITY3_CNGf_GET BCM56800_A0_CNG_MAPr_PRIORITY3_CNGf_GET
#define CNG_MAPr_PRIORITY3_CNGf_SET BCM56800_A0_CNG_MAPr_PRIORITY3_CNGf_SET
#define CNG_MAPr_PRIORITY4_CNGf_GET BCM56800_A0_CNG_MAPr_PRIORITY4_CNGf_GET
#define CNG_MAPr_PRIORITY4_CNGf_SET BCM56800_A0_CNG_MAPr_PRIORITY4_CNGf_SET
#define CNG_MAPr_PRIORITY5_CNGf_GET BCM56800_A0_CNG_MAPr_PRIORITY5_CNGf_GET
#define CNG_MAPr_PRIORITY5_CNGf_SET BCM56800_A0_CNG_MAPr_PRIORITY5_CNGf_SET
#define CNG_MAPr_PRIORITY6_CNGf_GET BCM56800_A0_CNG_MAPr_PRIORITY6_CNGf_GET
#define CNG_MAPr_PRIORITY6_CNGf_SET BCM56800_A0_CNG_MAPr_PRIORITY6_CNGf_SET
#define CNG_MAPr_PRIORITY7_CNGf_GET BCM56800_A0_CNG_MAPr_PRIORITY7_CNGf_GET
#define CNG_MAPr_PRIORITY7_CNGf_SET BCM56800_A0_CNG_MAPr_PRIORITY7_CNGf_SET
#define CNG_MAPr_CFI0_CNGf_GET BCM56800_A0_CNG_MAPr_CFI0_CNGf_GET
#define CNG_MAPr_CFI0_CNGf_SET BCM56800_A0_CNG_MAPr_CFI0_CNGf_SET
#define CNG_MAPr_CFI1_CNGf_GET BCM56800_A0_CNG_MAPr_CFI1_CNGf_GET
#define CNG_MAPr_CFI1_CNGf_SET BCM56800_A0_CNG_MAPr_CFI1_CNGf_SET
#define READ_CNG_MAPr BCM56800_A0_READ_CNG_MAPr
#define WRITE_CNG_MAPr BCM56800_A0_WRITE_CNG_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CNG_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  COSMASK
 * BLOCKS:   MMU
 * DESC:     Egress Scheduler Configuration Register
 * SIZE:     32
 * FIELDS:
 *     COSMASK          For XPORT0~19, this mask is received status from XPOIRT MAC. For CPU port this mask is driven from CMI block. Bit [9] = 1, QM queue is flow Controlled and mask out. Bit [8] = 1, SC queue is flow Controlled and mask out. Bit [7] = 1, COS7 queue is flow Controlled and mask out. Bit [6] = 1, COS6 queue is flow Controlled and mask out. Bit [5] = 1, COS5 queue is flow Controlled and mask out. Bit [4] = 1, COS4 queue is flow Controlled and mask out. Bit [3] = 1, COS3 queue is flow Controlled and mask out. Bit [2] = 1, COS2 queue is flow Controlled and mask out. Bit [1] = 1, COS1 queue is flow Controlled and mask out. Bit [0] = 1, COS0 queue is flow Controlled and mask out.For debug purpose, users can overwrite the value of this mask. Please note overwrite this mask will stop each COS queues ability to transmit packets. 
 *     COSMASKRXEN      COSMASKRxEn for normalo xport is to enable ES block to be able to receive new COS Mask from INTF block. COSMASKRxEn for CPU port is to enable ES block to be able to receive new COS Mask from CMIC block.1: To enable to receive new COS Mask.0: To Block to receive new COS Mask.Default setting is 1b0.
 *
 ******************************************************************************/
#define BCM56800_A0_COSMASKr 0x06d00020

#define BCM56800_A0_COSMASKr_SIZE 4

/*
 * This structure should be used to declare and program COSMASK.
 *
 */
typedef union BCM56800_A0_COSMASKr_s {
	uint32_t v[1];
	uint32_t cosmask[1];
	uint32_t _cosmask;
} BCM56800_A0_COSMASKr_t;

#define BCM56800_A0_COSMASKr_CLR(r) (r).cosmask[0] = 0
#define BCM56800_A0_COSMASKr_SET(r,d) (r).cosmask[0] = d
#define BCM56800_A0_COSMASKr_GET(r) (r).cosmask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_COSMASKr_COSMASKf_GET(r) (((r).cosmask[0]) & 0x3ff)
#define BCM56800_A0_COSMASKr_COSMASKf_SET(r,f) (r).cosmask[0]=(((r).cosmask[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM56800_A0_COSMASKr_COSMASKRXENf_GET(r) ((((r).cosmask[0]) >> 10) & 0x1)
#define BCM56800_A0_COSMASKr_COSMASKRXENf_SET(r,f) (r).cosmask[0]=(((r).cosmask[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))

/*
 * These macros can be used to access COSMASK.
 *
 */
#define BCM56800_A0_READ_COSMASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_COSMASKr,(r._cosmask))
#define BCM56800_A0_WRITE_COSMASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_COSMASKr,&(r._cosmask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COSMASKr BCM56800_A0_COSMASKr
#define COSMASKr_SIZE BCM56800_A0_COSMASKr_SIZE
typedef BCM56800_A0_COSMASKr_t COSMASKr_t;
#define COSMASKr_CLR BCM56800_A0_COSMASKr_CLR
#define COSMASKr_SET BCM56800_A0_COSMASKr_SET
#define COSMASKr_GET BCM56800_A0_COSMASKr_GET
#define COSMASKr_COSMASKf_GET BCM56800_A0_COSMASKr_COSMASKf_GET
#define COSMASKr_COSMASKf_SET BCM56800_A0_COSMASKr_COSMASKf_SET
#define COSMASKr_COSMASKRXENf_GET BCM56800_A0_COSMASKr_COSMASKRXENf_GET
#define COSMASKr_COSMASKRXENf_SET BCM56800_A0_COSMASKr_COSMASKRXENf_SET
#define READ_COSMASKr BCM56800_A0_READ_COSMASKr
#define WRITE_COSMASKr BCM56800_A0_WRITE_COSMASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_COSMASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  COSWEIGHTS
 * BLOCKS:   MMU
 * DESC:     Egress Scheduler Weight for each COS in WRR & WDRR modes
 * SIZE:     32
 * FIELDS:
 *     COSWEIGHTS       When Weighted Round Robin Scheduling selected, the value is in unit of Packet.Higher the number, the more the packets get scheduling.When Weighted Deficit Round Robin Scheduling selected, the value is in unit of128 bytes. Higher the value the lower the bandwidth is allocated.If value is reset to zero, it means this COS will be treates as Strict Priorityscheduling while the other COS is in WRR or WDRR scheduling.
 *
 ******************************************************************************/
#define BCM56800_A0_COSWEIGHTSr 0x06d00010

#define BCM56800_A0_COSWEIGHTSr_SIZE 4

/*
 * This structure should be used to declare and program COSWEIGHTS.
 *
 */
typedef union BCM56800_A0_COSWEIGHTSr_s {
	uint32_t v[1];
	uint32_t cosweights[1];
	uint32_t _cosweights;
} BCM56800_A0_COSWEIGHTSr_t;

#define BCM56800_A0_COSWEIGHTSr_CLR(r) (r).cosweights[0] = 0
#define BCM56800_A0_COSWEIGHTSr_SET(r,d) (r).cosweights[0] = d
#define BCM56800_A0_COSWEIGHTSr_GET(r) (r).cosweights[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_COSWEIGHTSr_COSWEIGHTSf_GET(r) (((r).cosweights[0]) & 0x7f)
#define BCM56800_A0_COSWEIGHTSr_COSWEIGHTSf_SET(r,f) (r).cosweights[0]=(((r).cosweights[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access COSWEIGHTS.
 *
 */
#define BCM56800_A0_READ_COSWEIGHTSr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_COSWEIGHTSr+(i),(r._cosweights))
#define BCM56800_A0_WRITE_COSWEIGHTSr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_COSWEIGHTSr+(i),&(r._cosweights))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COSWEIGHTSr BCM56800_A0_COSWEIGHTSr
#define COSWEIGHTSr_SIZE BCM56800_A0_COSWEIGHTSr_SIZE
typedef BCM56800_A0_COSWEIGHTSr_t COSWEIGHTSr_t;
#define COSWEIGHTSr_CLR BCM56800_A0_COSWEIGHTSr_CLR
#define COSWEIGHTSr_SET BCM56800_A0_COSWEIGHTSr_SET
#define COSWEIGHTSr_GET BCM56800_A0_COSWEIGHTSr_GET
#define COSWEIGHTSr_COSWEIGHTSf_GET BCM56800_A0_COSWEIGHTSr_COSWEIGHTSf_GET
#define COSWEIGHTSr_COSWEIGHTSf_SET BCM56800_A0_COSWEIGHTSr_COSWEIGHTSf_SET
#define READ_COSWEIGHTSr BCM56800_A0_READ_COSWEIGHTSr
#define WRITE_COSWEIGHTSr BCM56800_A0_WRITE_COSWEIGHTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_COSWEIGHTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  COS_SEL
 * BLOCKS:   IPIPE
 * DESC:     COS Queue Mapping Register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     COS0             COS-0 Value
 *     COS1             COS-1 Value
 *     COS2             COS-2 Value
 *     COS3             COS-3 Value
 *     COS4             COS-4 Value
 *     COS5             COS-5 Value
 *     COS6             COS-6 Value
 *     COS7             COS-7 Value
 *
 ******************************************************************************/
#define BCM56800_A0_COS_SELr 0x0e100045

#define BCM56800_A0_COS_SELr_SIZE 4

/*
 * This structure should be used to declare and program COS_SEL.
 *
 */
typedef union BCM56800_A0_COS_SELr_s {
	uint32_t v[1];
	uint32_t cos_sel[1];
	uint32_t _cos_sel;
} BCM56800_A0_COS_SELr_t;

#define BCM56800_A0_COS_SELr_CLR(r) (r).cos_sel[0] = 0
#define BCM56800_A0_COS_SELr_SET(r,d) (r).cos_sel[0] = d
#define BCM56800_A0_COS_SELr_GET(r) (r).cos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_COS_SELr_COS0f_GET(r) (((r).cos_sel[0]) & 0xf)
#define BCM56800_A0_COS_SELr_COS0f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_COS_SELr_COS1f_GET(r) ((((r).cos_sel[0]) >> 4) & 0xf)
#define BCM56800_A0_COS_SELr_COS1f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_COS_SELr_COS2f_GET(r) ((((r).cos_sel[0]) >> 8) & 0xf)
#define BCM56800_A0_COS_SELr_COS2f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_COS_SELr_COS3f_GET(r) ((((r).cos_sel[0]) >> 12) & 0xf)
#define BCM56800_A0_COS_SELr_COS3f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_COS_SELr_COS4f_GET(r) ((((r).cos_sel[0]) >> 16) & 0xf)
#define BCM56800_A0_COS_SELr_COS4f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_COS_SELr_COS5f_GET(r) ((((r).cos_sel[0]) >> 20) & 0xf)
#define BCM56800_A0_COS_SELr_COS5f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_COS_SELr_COS6f_GET(r) ((((r).cos_sel[0]) >> 24) & 0xf)
#define BCM56800_A0_COS_SELr_COS6f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_COS_SELr_COS7f_GET(r) ((((r).cos_sel[0]) >> 28) & 0xf)
#define BCM56800_A0_COS_SELr_COS7f_SET(r,f) (r).cos_sel[0]=(((r).cos_sel[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access COS_SEL.
 *
 */
#define BCM56800_A0_READ_COS_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_COS_SELr,(r._cos_sel))
#define BCM56800_A0_WRITE_COS_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_COS_SELr,&(r._cos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COS_SELr BCM56800_A0_COS_SELr
#define COS_SELr_SIZE BCM56800_A0_COS_SELr_SIZE
typedef BCM56800_A0_COS_SELr_t COS_SELr_t;
#define COS_SELr_CLR BCM56800_A0_COS_SELr_CLR
#define COS_SELr_SET BCM56800_A0_COS_SELr_SET
#define COS_SELr_GET BCM56800_A0_COS_SELr_GET
#define COS_SELr_COS0f_GET BCM56800_A0_COS_SELr_COS0f_GET
#define COS_SELr_COS0f_SET BCM56800_A0_COS_SELr_COS0f_SET
#define COS_SELr_COS1f_GET BCM56800_A0_COS_SELr_COS1f_GET
#define COS_SELr_COS1f_SET BCM56800_A0_COS_SELr_COS1f_SET
#define COS_SELr_COS2f_GET BCM56800_A0_COS_SELr_COS2f_GET
#define COS_SELr_COS2f_SET BCM56800_A0_COS_SELr_COS2f_SET
#define COS_SELr_COS3f_GET BCM56800_A0_COS_SELr_COS3f_GET
#define COS_SELr_COS3f_SET BCM56800_A0_COS_SELr_COS3f_SET
#define COS_SELr_COS4f_GET BCM56800_A0_COS_SELr_COS4f_GET
#define COS_SELr_COS4f_SET BCM56800_A0_COS_SELr_COS4f_SET
#define COS_SELr_COS5f_GET BCM56800_A0_COS_SELr_COS5f_GET
#define COS_SELr_COS5f_SET BCM56800_A0_COS_SELr_COS5f_SET
#define COS_SELr_COS6f_GET BCM56800_A0_COS_SELr_COS6f_GET
#define COS_SELr_COS6f_SET BCM56800_A0_COS_SELr_COS6f_SET
#define COS_SELr_COS7f_GET BCM56800_A0_COS_SELr_COS7f_GET
#define COS_SELr_COS7f_SET BCM56800_A0_COS_SELr_COS7f_SET
#define READ_COS_SELr BCM56800_A0_READ_COS_SELr
#define WRITE_COS_SELr BCM56800_A0_WRITE_COS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_COS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  COS_SEL_2
 * BLOCKS:   IPIPE
 * DESC:     COS Queue Mapping Register 2, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     COS8             COS-8 Value
 *     COS9             COS-9 Value
 *     COS10            COS-10 Value
 *     COS11            COS-11 Value
 *     COS12            COS-12 Value
 *     COS13            COS-13 Value
 *     COS14            COS-14 Value
 *     COS15            COS-15 Value
 *
 ******************************************************************************/
#define BCM56800_A0_COS_SEL_2r 0x0e100046

#define BCM56800_A0_COS_SEL_2r_SIZE 4

/*
 * This structure should be used to declare and program COS_SEL_2.
 *
 */
typedef union BCM56800_A0_COS_SEL_2r_s {
	uint32_t v[1];
	uint32_t cos_sel_2[1];
	uint32_t _cos_sel_2;
} BCM56800_A0_COS_SEL_2r_t;

#define BCM56800_A0_COS_SEL_2r_CLR(r) (r).cos_sel_2[0] = 0
#define BCM56800_A0_COS_SEL_2r_SET(r,d) (r).cos_sel_2[0] = d
#define BCM56800_A0_COS_SEL_2r_GET(r) (r).cos_sel_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_COS_SEL_2r_COS8f_GET(r) (((r).cos_sel_2[0]) & 0xf)
#define BCM56800_A0_COS_SEL_2r_COS8f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_COS_SEL_2r_COS9f_GET(r) ((((r).cos_sel_2[0]) >> 4) & 0xf)
#define BCM56800_A0_COS_SEL_2r_COS9f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_COS_SEL_2r_COS10f_GET(r) ((((r).cos_sel_2[0]) >> 8) & 0xf)
#define BCM56800_A0_COS_SEL_2r_COS10f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_COS_SEL_2r_COS11f_GET(r) ((((r).cos_sel_2[0]) >> 12) & 0xf)
#define BCM56800_A0_COS_SEL_2r_COS11f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_COS_SEL_2r_COS12f_GET(r) ((((r).cos_sel_2[0]) >> 16) & 0xf)
#define BCM56800_A0_COS_SEL_2r_COS12f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_COS_SEL_2r_COS13f_GET(r) ((((r).cos_sel_2[0]) >> 20) & 0xf)
#define BCM56800_A0_COS_SEL_2r_COS13f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_COS_SEL_2r_COS14f_GET(r) ((((r).cos_sel_2[0]) >> 24) & 0xf)
#define BCM56800_A0_COS_SEL_2r_COS14f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_COS_SEL_2r_COS15f_GET(r) ((((r).cos_sel_2[0]) >> 28) & 0xf)
#define BCM56800_A0_COS_SEL_2r_COS15f_SET(r,f) (r).cos_sel_2[0]=(((r).cos_sel_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access COS_SEL_2.
 *
 */
#define BCM56800_A0_READ_COS_SEL_2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_COS_SEL_2r,(r._cos_sel_2))
#define BCM56800_A0_WRITE_COS_SEL_2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_COS_SEL_2r,&(r._cos_sel_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COS_SEL_2r BCM56800_A0_COS_SEL_2r
#define COS_SEL_2r_SIZE BCM56800_A0_COS_SEL_2r_SIZE
typedef BCM56800_A0_COS_SEL_2r_t COS_SEL_2r_t;
#define COS_SEL_2r_CLR BCM56800_A0_COS_SEL_2r_CLR
#define COS_SEL_2r_SET BCM56800_A0_COS_SEL_2r_SET
#define COS_SEL_2r_GET BCM56800_A0_COS_SEL_2r_GET
#define COS_SEL_2r_COS8f_GET BCM56800_A0_COS_SEL_2r_COS8f_GET
#define COS_SEL_2r_COS8f_SET BCM56800_A0_COS_SEL_2r_COS8f_SET
#define COS_SEL_2r_COS9f_GET BCM56800_A0_COS_SEL_2r_COS9f_GET
#define COS_SEL_2r_COS9f_SET BCM56800_A0_COS_SEL_2r_COS9f_SET
#define COS_SEL_2r_COS10f_GET BCM56800_A0_COS_SEL_2r_COS10f_GET
#define COS_SEL_2r_COS10f_SET BCM56800_A0_COS_SEL_2r_COS10f_SET
#define COS_SEL_2r_COS11f_GET BCM56800_A0_COS_SEL_2r_COS11f_GET
#define COS_SEL_2r_COS11f_SET BCM56800_A0_COS_SEL_2r_COS11f_SET
#define COS_SEL_2r_COS12f_GET BCM56800_A0_COS_SEL_2r_COS12f_GET
#define COS_SEL_2r_COS12f_SET BCM56800_A0_COS_SEL_2r_COS12f_SET
#define COS_SEL_2r_COS13f_GET BCM56800_A0_COS_SEL_2r_COS13f_GET
#define COS_SEL_2r_COS13f_SET BCM56800_A0_COS_SEL_2r_COS13f_SET
#define COS_SEL_2r_COS14f_GET BCM56800_A0_COS_SEL_2r_COS14f_GET
#define COS_SEL_2r_COS14f_SET BCM56800_A0_COS_SEL_2r_COS14f_SET
#define COS_SEL_2r_COS15f_GET BCM56800_A0_COS_SEL_2r_COS15f_GET
#define COS_SEL_2r_COS15f_SET BCM56800_A0_COS_SEL_2r_COS15f_SET
#define READ_COS_SEL_2r BCM56800_A0_READ_COS_SEL_2r
#define WRITE_COS_SEL_2r BCM56800_A0_WRITE_COS_SEL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_COS_SEL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CPU_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU
 * SIZE:     32
 * FIELDS:
 *     STATICMOVE_TOCPU Static move send to CPU enable
 *     NONSTATICMOVE_TOCPU Non-static move send to CPU enable
 *     UIPMC_TOCPU      Unknown IPMC (IPMC miss) send to CPU enable
 *     UMC_TOCPU        Unknown multicast (L2MC miss) send to CPU enable
 *     UUCAST_TOCPU     Unknown unicast send to CPU enable
 *     V4L3ERR_TOCPU    IPv4 L3 error send to CPU enable
 *     IPMCERR_TOCPU    IPMC error send to CPU enable
 *     UVLAN_TOCPU      Unknown VLAN send to CPU enable
 *     UNRESOLVEDL3SRC_TOCPU Unresolved source for L3 send to CPU enable
 *     V6L3DSTMISS_TOCPU IPv6 L3 unicast destination miss send to CPU enable
 *     V4L3DSTMISS_TOCPU IPv4 L3 unicast destination miss send to CPU enable
 *     IPMCPORTMISS_TOCPU IPMC port mismatch send to CPU enable
 *     SRCROUTE_TOCPU   If SA[40] set, send to CPU enable
 *     V6L3ERR_TOCPU    IPv6 L3 error send to CPU enable
 *     MARTIAN_ADDR_TOCPU Martian address send to CPU enable
 *     TUNNEL_ERR_TOCPU Tunnel error send to CPU enable
 *     DOSATTACK_TOCPU  DOS attack send to CPU enable
 *     L3UC_TTL_ERR_TOCPU L3 unicast TTL error send to CPU enable
 *     IPMC_TTL_ERR_TOCPU L3 multicast TTL error send to CPU enable
 *     ICMP_REDIRECT_TOCPU ICMP redirect send to CPU enable
 *     L3_SLOWPATH_TOCPU L3 slow path to CPU enable
 *     PARITY_ERR_TOCPU Parity Error to CPU enable
 *     L3_MTU_FAIL_TOCPU L3 MTU Fail to CPU enable
 *     NIP_L3ERR_TOCPU  NON IP L3 error send to CPU enable
 *     MC_INDEX_ERROR_TOCPU MC index error to CPU enable
 *     HG_HDR_ERROR_TOCPU HiGig header error to CPU enable
 *     HG_HDR_TYPE1_TOCPU HiGig header type = 1 to CPU enable
 *
 ******************************************************************************/
#define BCM56800_A0_CPU_CONTROL_1r 0x0b180604

#define BCM56800_A0_CPU_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_1.
 *
 */
typedef union BCM56800_A0_CPU_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t cpu_control_1[1];
	uint32_t _cpu_control_1;
} BCM56800_A0_CPU_CONTROL_1r_t;

#define BCM56800_A0_CPU_CONTROL_1r_CLR(r) (r).cpu_control_1[0] = 0
#define BCM56800_A0_CPU_CONTROL_1r_SET(r,d) (r).cpu_control_1[0] = d
#define BCM56800_A0_CPU_CONTROL_1r_GET(r) (r).cpu_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET(r) (((r).cpu_control_1[0]) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 1) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 2) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_CPU_CONTROL_1r_UMC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 3) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_UMC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 4) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 5) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 6) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 7) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 8) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 9) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 10) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 11) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 12) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 13) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 14) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 15) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 16) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 17) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 19) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 20) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 21) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 22) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 23) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 24) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 25) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET(r) ((((r).cpu_control_1[0]) >> 26) & 0x1)
#define BCM56800_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET(r,f) (r).cpu_control_1[0]=(((r).cpu_control_1[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access CPU_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_CPU_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CPU_CONTROL_1r,(r._cpu_control_1))
#define BCM56800_A0_WRITE_CPU_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CPU_CONTROL_1r,&(r._cpu_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_1r BCM56800_A0_CPU_CONTROL_1r
#define CPU_CONTROL_1r_SIZE BCM56800_A0_CPU_CONTROL_1r_SIZE
typedef BCM56800_A0_CPU_CONTROL_1r_t CPU_CONTROL_1r_t;
#define CPU_CONTROL_1r_CLR BCM56800_A0_CPU_CONTROL_1r_CLR
#define CPU_CONTROL_1r_SET BCM56800_A0_CPU_CONTROL_1r_SET
#define CPU_CONTROL_1r_GET BCM56800_A0_CPU_CONTROL_1r_GET
#define CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_GET
#define CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_STATICMOVE_TOCPUf_SET
#define CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_GET
#define CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_NONSTATICMOVE_TOCPUf_SET
#define CPU_CONTROL_1r_UIPMC_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_GET
#define CPU_CONTROL_1r_UIPMC_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_UIPMC_TOCPUf_SET
#define CPU_CONTROL_1r_UMC_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_UMC_TOCPUf_GET
#define CPU_CONTROL_1r_UMC_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_UMC_TOCPUf_SET
#define CPU_CONTROL_1r_UUCAST_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_GET
#define CPU_CONTROL_1r_UUCAST_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_UUCAST_TOCPUf_SET
#define CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_V4L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMCERR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMCERR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_IPMCERR_TOCPUf_SET
#define CPU_CONTROL_1r_UVLAN_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_GET
#define CPU_CONTROL_1r_UVLAN_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_UVLAN_TOCPUf_SET
#define CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_GET
#define CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_UNRESOLVEDL3SRC_TOCPUf_SET
#define CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_V6L3DSTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_V4L3DSTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_GET
#define CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_IPMCPORTMISS_TOCPUf_SET
#define CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_GET
#define CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_SRCROUTE_TOCPUf_SET
#define CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_V6L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_GET
#define CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_MARTIAN_ADDR_TOCPUf_SET
#define CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_TUNNEL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_GET
#define CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_DOSATTACK_TOCPUf_SET
#define CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_L3UC_TTL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_IPMC_TTL_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_GET
#define CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_ICMP_REDIRECT_TOCPUf_SET
#define CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_GET
#define CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_L3_SLOWPATH_TOCPUf_SET
#define CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_GET
#define CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_PARITY_ERR_TOCPUf_SET
#define CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_GET
#define CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_L3_MTU_FAIL_TOCPUf_SET
#define CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_GET
#define CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_NIP_L3ERR_TOCPUf_SET
#define CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_GET
#define CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_MC_INDEX_ERROR_TOCPUf_SET
#define CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_GET
#define CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_HG_HDR_ERROR_TOCPUf_SET
#define CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET BCM56800_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_GET
#define CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET BCM56800_A0_CPU_CONTROL_1r_HG_HDR_TYPE1_TOCPUf_SET
#define READ_CPU_CONTROL_1r BCM56800_A0_READ_CPU_CONTROL_1r
#define WRITE_CPU_CONTROL_1r BCM56800_A0_WRITE_CPU_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CPU_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CPU_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU
 * SIZE:     32
 * FIELDS:
 *     CPU_MH_CONTROL_PRIORITY CPU OPCODE CONTROL Priority
 *     CPU_LKUPFAIL_PRIORITY CPU Lookup Fail Priority
 *     CPU_SFLOW_PRIORITY CPU SFLOW Priority
 *     CPU_DEFAULT_PRIORITY CPU Default Priority
 *     CPU_MTUFAIL_PRIORITY CPU MTU fail Priority
 *     CPU_FPCOPY_PRIORITY CPU FP copy to cpu Priority
 *     CPU_ICMP_REDIRECT_PRIORITY CPU ICMP Redirect Priority
 *     CPU_MIRROR_PRIORITY CPU Mirror Priority
 *
 ******************************************************************************/
#define BCM56800_A0_CPU_CONTROL_2r 0x0e18061f

#define BCM56800_A0_CPU_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_2.
 *
 */
typedef union BCM56800_A0_CPU_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t cpu_control_2[1];
	uint32_t _cpu_control_2;
} BCM56800_A0_CPU_CONTROL_2r_t;

#define BCM56800_A0_CPU_CONTROL_2r_CLR(r) (r).cpu_control_2[0] = 0
#define BCM56800_A0_CPU_CONTROL_2r_SET(r,d) (r).cpu_control_2[0] = d
#define BCM56800_A0_CPU_CONTROL_2r_GET(r) (r).cpu_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET(r) (((r).cpu_control_2[0]) & 0xf)
#define BCM56800_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 4) & 0xf)
#define BCM56800_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 8) & 0xf)
#define BCM56800_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 12) & 0xf)
#define BCM56800_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 16) & 0xf)
#define BCM56800_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 20) & 0xf)
#define BCM56800_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 24) & 0xf)
#define BCM56800_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET(r) ((((r).cpu_control_2[0]) >> 28) & 0xf)
#define BCM56800_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET(r,f) (r).cpu_control_2[0]=(((r).cpu_control_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_CPU_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CPU_CONTROL_2r,(r._cpu_control_2))
#define BCM56800_A0_WRITE_CPU_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CPU_CONTROL_2r,&(r._cpu_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_2r BCM56800_A0_CPU_CONTROL_2r
#define CPU_CONTROL_2r_SIZE BCM56800_A0_CPU_CONTROL_2r_SIZE
typedef BCM56800_A0_CPU_CONTROL_2r_t CPU_CONTROL_2r_t;
#define CPU_CONTROL_2r_CLR BCM56800_A0_CPU_CONTROL_2r_CLR
#define CPU_CONTROL_2r_SET BCM56800_A0_CPU_CONTROL_2r_SET
#define CPU_CONTROL_2r_GET BCM56800_A0_CPU_CONTROL_2r_GET
#define CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_2r_CPU_MH_CONTROL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_2r_CPU_LKUPFAIL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_2r_CPU_SFLOW_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_2r_CPU_DEFAULT_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_2r_CPU_MTUFAIL_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_2r_CPU_FPCOPY_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_2r_CPU_ICMP_REDIRECT_PRIORITYf_SET
#define CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_GET
#define CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_2r_CPU_MIRROR_PRIORITYf_SET
#define READ_CPU_CONTROL_2r BCM56800_A0_READ_CPU_CONTROL_2r
#define WRITE_CPU_CONTROL_2r BCM56800_A0_WRITE_CPU_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CPU_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CPU_CONTROL_3
 * BLOCKS:   IPIPE
 * DESC:     Control Register for Packets sent to the CPU
 * SIZE:     32
 * FIELDS:
 *     CPU_PROTO_EXCEPTIONS_PRIORITY Priority for IPv4/IPv6 pkts with TTL=1 when it is copied/trapped to CPU.
 *     CPU_PROTO_IP_OPTIONS_PRIORITY Priority for IPv4/IPv6 pkts with options or IPv6 pkts with payload len zero (jumbo option) when it is copied/trapped to CPU.
 *     CPU_PROTO_IPMC_RESERVED_PRIORITY Priority for IPv4/IPv6 reserved multicast pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_DHCP_PRIORITY Priority for DHCP pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_IGMP_PRIORITY Priority for IGMP/MLD pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_ARP_PRIORITY Priority for ARP/ND pkts when it is copied/trapped to CPU.
 *     CPU_PROTO_BPDU_PRIORITY Priority for BPDU pkts when it is copied/trapped to CPU.
 *
 ******************************************************************************/
#define BCM56800_A0_CPU_CONTROL_3r 0x0e18064a

#define BCM56800_A0_CPU_CONTROL_3r_SIZE 4

/*
 * This structure should be used to declare and program CPU_CONTROL_3.
 *
 */
typedef union BCM56800_A0_CPU_CONTROL_3r_s {
	uint32_t v[1];
	uint32_t cpu_control_3[1];
	uint32_t _cpu_control_3;
} BCM56800_A0_CPU_CONTROL_3r_t;

#define BCM56800_A0_CPU_CONTROL_3r_CLR(r) (r).cpu_control_3[0] = 0
#define BCM56800_A0_CPU_CONTROL_3r_SET(r,d) (r).cpu_control_3[0] = d
#define BCM56800_A0_CPU_CONTROL_3r_GET(r) (r).cpu_control_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET(r) (((r).cpu_control_3[0]) & 0xf)
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 4) & 0xf)
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 8) & 0xf)
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 12) & 0xf)
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 16) & 0xf)
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 20) & 0xf)
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET(r) ((((r).cpu_control_3[0]) >> 24) & 0xf)
#define BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET(r,f) (r).cpu_control_3[0]=(((r).cpu_control_3[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))

/*
 * These macros can be used to access CPU_CONTROL_3.
 *
 */
#define BCM56800_A0_READ_CPU_CONTROL_3r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CPU_CONTROL_3r,(r._cpu_control_3))
#define BCM56800_A0_WRITE_CPU_CONTROL_3r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CPU_CONTROL_3r,&(r._cpu_control_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_CONTROL_3r BCM56800_A0_CPU_CONTROL_3r
#define CPU_CONTROL_3r_SIZE BCM56800_A0_CPU_CONTROL_3r_SIZE
typedef BCM56800_A0_CPU_CONTROL_3r_t CPU_CONTROL_3r_t;
#define CPU_CONTROL_3r_CLR BCM56800_A0_CPU_CONTROL_3r_CLR
#define CPU_CONTROL_3r_SET BCM56800_A0_CPU_CONTROL_3r_SET
#define CPU_CONTROL_3r_GET BCM56800_A0_CPU_CONTROL_3r_GET
#define CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_EXCEPTIONS_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IP_OPTIONS_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IPMC_RESERVED_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_DHCP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_IGMP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_ARP_PRIORITYf_SET
#define CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_GET
#define CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET BCM56800_A0_CPU_CONTROL_3r_CPU_PROTO_BPDU_PRIORITYf_SET
#define READ_CPU_CONTROL_3r BCM56800_A0_READ_CPU_CONTROL_3r
#define WRITE_CPU_CONTROL_3r BCM56800_A0_WRITE_CPU_CONTROL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CPU_CONTROL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CPU_COS_SEL
 * BLOCKS:   IPIPE
 * DESC:     CPU COS Select Register
 * SIZE:     32
 * FIELDS:
 *     COS0             COS 0 value
 *     COS1             COS 1 value
 *     COS2             COS 2 value
 *     COS3             COS 3 value
 *     COS4             COS 4 value
 *     COS5             COS 5 value
 *     COS6             COS 6 value
 *     COS7             COS 7 value
 *
 ******************************************************************************/
#define BCM56800_A0_CPU_COS_SELr 0x0e180625

#define BCM56800_A0_CPU_COS_SELr_SIZE 4

/*
 * This structure should be used to declare and program CPU_COS_SEL.
 *
 */
typedef union BCM56800_A0_CPU_COS_SELr_s {
	uint32_t v[1];
	uint32_t cpu_cos_sel[1];
	uint32_t _cpu_cos_sel;
} BCM56800_A0_CPU_COS_SELr_t;

#define BCM56800_A0_CPU_COS_SELr_CLR(r) (r).cpu_cos_sel[0] = 0
#define BCM56800_A0_CPU_COS_SELr_SET(r,d) (r).cpu_cos_sel[0] = d
#define BCM56800_A0_CPU_COS_SELr_GET(r) (r).cpu_cos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CPU_COS_SELr_COS0f_GET(r) (((r).cpu_cos_sel[0]) & 0xf)
#define BCM56800_A0_CPU_COS_SELr_COS0f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CPU_COS_SELr_COS1f_GET(r) ((((r).cpu_cos_sel[0]) >> 4) & 0xf)
#define BCM56800_A0_CPU_COS_SELr_COS1f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CPU_COS_SELr_COS2f_GET(r) ((((r).cpu_cos_sel[0]) >> 8) & 0xf)
#define BCM56800_A0_CPU_COS_SELr_COS2f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CPU_COS_SELr_COS3f_GET(r) ((((r).cpu_cos_sel[0]) >> 12) & 0xf)
#define BCM56800_A0_CPU_COS_SELr_COS3f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CPU_COS_SELr_COS4f_GET(r) ((((r).cpu_cos_sel[0]) >> 16) & 0xf)
#define BCM56800_A0_CPU_COS_SELr_COS4f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CPU_COS_SELr_COS5f_GET(r) ((((r).cpu_cos_sel[0]) >> 20) & 0xf)
#define BCM56800_A0_CPU_COS_SELr_COS5f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CPU_COS_SELr_COS6f_GET(r) ((((r).cpu_cos_sel[0]) >> 24) & 0xf)
#define BCM56800_A0_CPU_COS_SELr_COS6f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CPU_COS_SELr_COS7f_GET(r) ((((r).cpu_cos_sel[0]) >> 28) & 0xf)
#define BCM56800_A0_CPU_COS_SELr_COS7f_SET(r,f) (r).cpu_cos_sel[0]=(((r).cpu_cos_sel[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_COS_SEL.
 *
 */
#define BCM56800_A0_READ_CPU_COS_SELr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CPU_COS_SELr,(r._cpu_cos_sel))
#define BCM56800_A0_WRITE_CPU_COS_SELr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CPU_COS_SELr,&(r._cpu_cos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_COS_SELr BCM56800_A0_CPU_COS_SELr
#define CPU_COS_SELr_SIZE BCM56800_A0_CPU_COS_SELr_SIZE
typedef BCM56800_A0_CPU_COS_SELr_t CPU_COS_SELr_t;
#define CPU_COS_SELr_CLR BCM56800_A0_CPU_COS_SELr_CLR
#define CPU_COS_SELr_SET BCM56800_A0_CPU_COS_SELr_SET
#define CPU_COS_SELr_GET BCM56800_A0_CPU_COS_SELr_GET
#define CPU_COS_SELr_COS0f_GET BCM56800_A0_CPU_COS_SELr_COS0f_GET
#define CPU_COS_SELr_COS0f_SET BCM56800_A0_CPU_COS_SELr_COS0f_SET
#define CPU_COS_SELr_COS1f_GET BCM56800_A0_CPU_COS_SELr_COS1f_GET
#define CPU_COS_SELr_COS1f_SET BCM56800_A0_CPU_COS_SELr_COS1f_SET
#define CPU_COS_SELr_COS2f_GET BCM56800_A0_CPU_COS_SELr_COS2f_GET
#define CPU_COS_SELr_COS2f_SET BCM56800_A0_CPU_COS_SELr_COS2f_SET
#define CPU_COS_SELr_COS3f_GET BCM56800_A0_CPU_COS_SELr_COS3f_GET
#define CPU_COS_SELr_COS3f_SET BCM56800_A0_CPU_COS_SELr_COS3f_SET
#define CPU_COS_SELr_COS4f_GET BCM56800_A0_CPU_COS_SELr_COS4f_GET
#define CPU_COS_SELr_COS4f_SET BCM56800_A0_CPU_COS_SELr_COS4f_SET
#define CPU_COS_SELr_COS5f_GET BCM56800_A0_CPU_COS_SELr_COS5f_GET
#define CPU_COS_SELr_COS5f_SET BCM56800_A0_CPU_COS_SELr_COS5f_SET
#define CPU_COS_SELr_COS6f_GET BCM56800_A0_CPU_COS_SELr_COS6f_GET
#define CPU_COS_SELr_COS6f_SET BCM56800_A0_CPU_COS_SELr_COS6f_SET
#define CPU_COS_SELr_COS7f_GET BCM56800_A0_CPU_COS_SELr_COS7f_GET
#define CPU_COS_SELr_COS7f_SET BCM56800_A0_CPU_COS_SELr_COS7f_SET
#define READ_CPU_COS_SELr BCM56800_A0_READ_CPU_COS_SELr
#define WRITE_CPU_COS_SELr BCM56800_A0_WRITE_CPU_COS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CPU_COS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CPU_COS_SEL_2
 * BLOCKS:   IPIPE
 * DESC:     CPU COS Select Register 2
 * SIZE:     32
 * FIELDS:
 *     COS8             COS 8 value
 *     COS9             COS 9 value
 *     COS10            COS 10 value
 *     COS11            COS 11 value
 *     COS12            COS 12 value
 *     COS13            COS 13 value
 *     COS14            COS 14 value
 *     COS15            COS 15 value
 *
 ******************************************************************************/
#define BCM56800_A0_CPU_COS_SEL_2r 0x0e180626

#define BCM56800_A0_CPU_COS_SEL_2r_SIZE 4

/*
 * This structure should be used to declare and program CPU_COS_SEL_2.
 *
 */
typedef union BCM56800_A0_CPU_COS_SEL_2r_s {
	uint32_t v[1];
	uint32_t cpu_cos_sel_2[1];
	uint32_t _cpu_cos_sel_2;
} BCM56800_A0_CPU_COS_SEL_2r_t;

#define BCM56800_A0_CPU_COS_SEL_2r_CLR(r) (r).cpu_cos_sel_2[0] = 0
#define BCM56800_A0_CPU_COS_SEL_2r_SET(r,d) (r).cpu_cos_sel_2[0] = d
#define BCM56800_A0_CPU_COS_SEL_2r_GET(r) (r).cpu_cos_sel_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CPU_COS_SEL_2r_COS8f_GET(r) (((r).cpu_cos_sel_2[0]) & 0xf)
#define BCM56800_A0_CPU_COS_SEL_2r_COS8f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CPU_COS_SEL_2r_COS9f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 4) & 0xf)
#define BCM56800_A0_CPU_COS_SEL_2r_COS9f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CPU_COS_SEL_2r_COS10f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 8) & 0xf)
#define BCM56800_A0_CPU_COS_SEL_2r_COS10f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CPU_COS_SEL_2r_COS11f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 12) & 0xf)
#define BCM56800_A0_CPU_COS_SEL_2r_COS11f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CPU_COS_SEL_2r_COS12f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 16) & 0xf)
#define BCM56800_A0_CPU_COS_SEL_2r_COS12f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CPU_COS_SEL_2r_COS13f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 20) & 0xf)
#define BCM56800_A0_CPU_COS_SEL_2r_COS13f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CPU_COS_SEL_2r_COS14f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 24) & 0xf)
#define BCM56800_A0_CPU_COS_SEL_2r_COS14f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CPU_COS_SEL_2r_COS15f_GET(r) ((((r).cpu_cos_sel_2[0]) >> 28) & 0xf)
#define BCM56800_A0_CPU_COS_SEL_2r_COS15f_SET(r,f) (r).cpu_cos_sel_2[0]=(((r).cpu_cos_sel_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_COS_SEL_2.
 *
 */
#define BCM56800_A0_READ_CPU_COS_SEL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CPU_COS_SEL_2r,(r._cpu_cos_sel_2))
#define BCM56800_A0_WRITE_CPU_COS_SEL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CPU_COS_SEL_2r,&(r._cpu_cos_sel_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_COS_SEL_2r BCM56800_A0_CPU_COS_SEL_2r
#define CPU_COS_SEL_2r_SIZE BCM56800_A0_CPU_COS_SEL_2r_SIZE
typedef BCM56800_A0_CPU_COS_SEL_2r_t CPU_COS_SEL_2r_t;
#define CPU_COS_SEL_2r_CLR BCM56800_A0_CPU_COS_SEL_2r_CLR
#define CPU_COS_SEL_2r_SET BCM56800_A0_CPU_COS_SEL_2r_SET
#define CPU_COS_SEL_2r_GET BCM56800_A0_CPU_COS_SEL_2r_GET
#define CPU_COS_SEL_2r_COS8f_GET BCM56800_A0_CPU_COS_SEL_2r_COS8f_GET
#define CPU_COS_SEL_2r_COS8f_SET BCM56800_A0_CPU_COS_SEL_2r_COS8f_SET
#define CPU_COS_SEL_2r_COS9f_GET BCM56800_A0_CPU_COS_SEL_2r_COS9f_GET
#define CPU_COS_SEL_2r_COS9f_SET BCM56800_A0_CPU_COS_SEL_2r_COS9f_SET
#define CPU_COS_SEL_2r_COS10f_GET BCM56800_A0_CPU_COS_SEL_2r_COS10f_GET
#define CPU_COS_SEL_2r_COS10f_SET BCM56800_A0_CPU_COS_SEL_2r_COS10f_SET
#define CPU_COS_SEL_2r_COS11f_GET BCM56800_A0_CPU_COS_SEL_2r_COS11f_GET
#define CPU_COS_SEL_2r_COS11f_SET BCM56800_A0_CPU_COS_SEL_2r_COS11f_SET
#define CPU_COS_SEL_2r_COS12f_GET BCM56800_A0_CPU_COS_SEL_2r_COS12f_GET
#define CPU_COS_SEL_2r_COS12f_SET BCM56800_A0_CPU_COS_SEL_2r_COS12f_SET
#define CPU_COS_SEL_2r_COS13f_GET BCM56800_A0_CPU_COS_SEL_2r_COS13f_GET
#define CPU_COS_SEL_2r_COS13f_SET BCM56800_A0_CPU_COS_SEL_2r_COS13f_SET
#define CPU_COS_SEL_2r_COS14f_GET BCM56800_A0_CPU_COS_SEL_2r_COS14f_GET
#define CPU_COS_SEL_2r_COS14f_SET BCM56800_A0_CPU_COS_SEL_2r_COS14f_SET
#define CPU_COS_SEL_2r_COS15f_GET BCM56800_A0_CPU_COS_SEL_2r_COS15f_GET
#define CPU_COS_SEL_2r_COS15f_SET BCM56800_A0_CPU_COS_SEL_2r_COS15f_SET
#define READ_CPU_COS_SEL_2r BCM56800_A0_READ_CPU_COS_SEL_2r
#define WRITE_CPU_COS_SEL_2r BCM56800_A0_WRITE_CPU_COS_SEL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CPU_COS_SEL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CPU_PRIORITY_SEL
 * BLOCKS:   IPIPE
 * DESC:     CPU Priority Select Register
 * SIZE:     32
 * FIELDS:
 *     PRI0             Priority 0 value
 *     PRI1             Priority 1 value
 *     PRI2             Priority 2 value
 *     PRI3             Priority 3 value
 *     PRI4             Priority 4 value
 *     PRI5             Priority 5 value
 *     PRI6             Priority 6 value
 *     PRI7             Priority 7 value
 *
 ******************************************************************************/
#define BCM56800_A0_CPU_PRIORITY_SELr 0x0e180623

#define BCM56800_A0_CPU_PRIORITY_SELr_SIZE 4

/*
 * This structure should be used to declare and program CPU_PRIORITY_SEL.
 *
 */
typedef union BCM56800_A0_CPU_PRIORITY_SELr_s {
	uint32_t v[1];
	uint32_t cpu_priority_sel[1];
	uint32_t _cpu_priority_sel;
} BCM56800_A0_CPU_PRIORITY_SELr_t;

#define BCM56800_A0_CPU_PRIORITY_SELr_CLR(r) (r).cpu_priority_sel[0] = 0
#define BCM56800_A0_CPU_PRIORITY_SELr_SET(r,d) (r).cpu_priority_sel[0] = d
#define BCM56800_A0_CPU_PRIORITY_SELr_GET(r) (r).cpu_priority_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI0f_GET(r) (((r).cpu_priority_sel[0]) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI0f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI1f_GET(r) ((((r).cpu_priority_sel[0]) >> 4) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI1f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI2f_GET(r) ((((r).cpu_priority_sel[0]) >> 8) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI2f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI3f_GET(r) ((((r).cpu_priority_sel[0]) >> 12) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI3f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI4f_GET(r) ((((r).cpu_priority_sel[0]) >> 16) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI4f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI5f_GET(r) ((((r).cpu_priority_sel[0]) >> 20) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI5f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI6f_GET(r) ((((r).cpu_priority_sel[0]) >> 24) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI6f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI7f_GET(r) ((((r).cpu_priority_sel[0]) >> 28) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SELr_PRI7f_SET(r,f) (r).cpu_priority_sel[0]=(((r).cpu_priority_sel[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_PRIORITY_SEL.
 *
 */
#define BCM56800_A0_READ_CPU_PRIORITY_SELr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CPU_PRIORITY_SELr,(r._cpu_priority_sel))
#define BCM56800_A0_WRITE_CPU_PRIORITY_SELr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CPU_PRIORITY_SELr,&(r._cpu_priority_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_PRIORITY_SELr BCM56800_A0_CPU_PRIORITY_SELr
#define CPU_PRIORITY_SELr_SIZE BCM56800_A0_CPU_PRIORITY_SELr_SIZE
typedef BCM56800_A0_CPU_PRIORITY_SELr_t CPU_PRIORITY_SELr_t;
#define CPU_PRIORITY_SELr_CLR BCM56800_A0_CPU_PRIORITY_SELr_CLR
#define CPU_PRIORITY_SELr_SET BCM56800_A0_CPU_PRIORITY_SELr_SET
#define CPU_PRIORITY_SELr_GET BCM56800_A0_CPU_PRIORITY_SELr_GET
#define CPU_PRIORITY_SELr_PRI0f_GET BCM56800_A0_CPU_PRIORITY_SELr_PRI0f_GET
#define CPU_PRIORITY_SELr_PRI0f_SET BCM56800_A0_CPU_PRIORITY_SELr_PRI0f_SET
#define CPU_PRIORITY_SELr_PRI1f_GET BCM56800_A0_CPU_PRIORITY_SELr_PRI1f_GET
#define CPU_PRIORITY_SELr_PRI1f_SET BCM56800_A0_CPU_PRIORITY_SELr_PRI1f_SET
#define CPU_PRIORITY_SELr_PRI2f_GET BCM56800_A0_CPU_PRIORITY_SELr_PRI2f_GET
#define CPU_PRIORITY_SELr_PRI2f_SET BCM56800_A0_CPU_PRIORITY_SELr_PRI2f_SET
#define CPU_PRIORITY_SELr_PRI3f_GET BCM56800_A0_CPU_PRIORITY_SELr_PRI3f_GET
#define CPU_PRIORITY_SELr_PRI3f_SET BCM56800_A0_CPU_PRIORITY_SELr_PRI3f_SET
#define CPU_PRIORITY_SELr_PRI4f_GET BCM56800_A0_CPU_PRIORITY_SELr_PRI4f_GET
#define CPU_PRIORITY_SELr_PRI4f_SET BCM56800_A0_CPU_PRIORITY_SELr_PRI4f_SET
#define CPU_PRIORITY_SELr_PRI5f_GET BCM56800_A0_CPU_PRIORITY_SELr_PRI5f_GET
#define CPU_PRIORITY_SELr_PRI5f_SET BCM56800_A0_CPU_PRIORITY_SELr_PRI5f_SET
#define CPU_PRIORITY_SELr_PRI6f_GET BCM56800_A0_CPU_PRIORITY_SELr_PRI6f_GET
#define CPU_PRIORITY_SELr_PRI6f_SET BCM56800_A0_CPU_PRIORITY_SELr_PRI6f_SET
#define CPU_PRIORITY_SELr_PRI7f_GET BCM56800_A0_CPU_PRIORITY_SELr_PRI7f_GET
#define CPU_PRIORITY_SELr_PRI7f_SET BCM56800_A0_CPU_PRIORITY_SELr_PRI7f_SET
#define READ_CPU_PRIORITY_SELr BCM56800_A0_READ_CPU_PRIORITY_SELr
#define WRITE_CPU_PRIORITY_SELr BCM56800_A0_WRITE_CPU_PRIORITY_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CPU_PRIORITY_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  CPU_PRIORITY_SEL_2
 * BLOCKS:   IPIPE
 * DESC:     CPU Priority Select Register 2
 * SIZE:     32
 * FIELDS:
 *     PRI8             Priority 8 value
 *     PRI9             Priority 9 value
 *     PRI10            Priority 10 value
 *     PRI11            Priority 11 value
 *     PRI12            Priority 12 value
 *     PRI13            Priority 13 value
 *     PRI14            Priority 14 value
 *     PRI15            Priority 15 value
 *
 ******************************************************************************/
#define BCM56800_A0_CPU_PRIORITY_SEL_2r 0x0e180624

#define BCM56800_A0_CPU_PRIORITY_SEL_2r_SIZE 4

/*
 * This structure should be used to declare and program CPU_PRIORITY_SEL_2.
 *
 */
typedef union BCM56800_A0_CPU_PRIORITY_SEL_2r_s {
	uint32_t v[1];
	uint32_t cpu_priority_sel_2[1];
	uint32_t _cpu_priority_sel_2;
} BCM56800_A0_CPU_PRIORITY_SEL_2r_t;

#define BCM56800_A0_CPU_PRIORITY_SEL_2r_CLR(r) (r).cpu_priority_sel_2[0] = 0
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_SET(r,d) (r).cpu_priority_sel_2[0] = d
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_GET(r) (r).cpu_priority_sel_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI8f_GET(r) (((r).cpu_priority_sel_2[0]) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI8f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI9f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 4) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI9f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI10f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 8) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI10f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI11f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 12) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI11f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI12f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 16) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI12f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI13f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 20) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI13f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI14f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 24) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI14f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI15f_GET(r) ((((r).cpu_priority_sel_2[0]) >> 28) & 0xf)
#define BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI15f_SET(r,f) (r).cpu_priority_sel_2[0]=(((r).cpu_priority_sel_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access CPU_PRIORITY_SEL_2.
 *
 */
#define BCM56800_A0_READ_CPU_PRIORITY_SEL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_CPU_PRIORITY_SEL_2r,(r._cpu_priority_sel_2))
#define BCM56800_A0_WRITE_CPU_PRIORITY_SEL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_CPU_PRIORITY_SEL_2r,&(r._cpu_priority_sel_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU_PRIORITY_SEL_2r BCM56800_A0_CPU_PRIORITY_SEL_2r
#define CPU_PRIORITY_SEL_2r_SIZE BCM56800_A0_CPU_PRIORITY_SEL_2r_SIZE
typedef BCM56800_A0_CPU_PRIORITY_SEL_2r_t CPU_PRIORITY_SEL_2r_t;
#define CPU_PRIORITY_SEL_2r_CLR BCM56800_A0_CPU_PRIORITY_SEL_2r_CLR
#define CPU_PRIORITY_SEL_2r_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_SET
#define CPU_PRIORITY_SEL_2r_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_GET
#define CPU_PRIORITY_SEL_2r_PRI8f_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI8f_GET
#define CPU_PRIORITY_SEL_2r_PRI8f_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI8f_SET
#define CPU_PRIORITY_SEL_2r_PRI9f_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI9f_GET
#define CPU_PRIORITY_SEL_2r_PRI9f_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI9f_SET
#define CPU_PRIORITY_SEL_2r_PRI10f_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI10f_GET
#define CPU_PRIORITY_SEL_2r_PRI10f_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI10f_SET
#define CPU_PRIORITY_SEL_2r_PRI11f_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI11f_GET
#define CPU_PRIORITY_SEL_2r_PRI11f_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI11f_SET
#define CPU_PRIORITY_SEL_2r_PRI12f_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI12f_GET
#define CPU_PRIORITY_SEL_2r_PRI12f_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI12f_SET
#define CPU_PRIORITY_SEL_2r_PRI13f_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI13f_GET
#define CPU_PRIORITY_SEL_2r_PRI13f_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI13f_SET
#define CPU_PRIORITY_SEL_2r_PRI14f_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI14f_GET
#define CPU_PRIORITY_SEL_2r_PRI14f_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI14f_SET
#define CPU_PRIORITY_SEL_2r_PRI15f_GET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI15f_GET
#define CPU_PRIORITY_SEL_2r_PRI15f_SET BCM56800_A0_CPU_PRIORITY_SEL_2r_PRI15f_SET
#define READ_CPU_PRIORITY_SEL_2r BCM56800_A0_READ_CPU_PRIORITY_SEL_2r
#define WRITE_CPU_PRIORITY_SEL_2r BCM56800_A0_WRITE_CPU_PRIORITY_SEL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_CPU_PRIORITY_SEL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DEBUG0
 * BLOCKS:   MMU
 * DESC:     Debug 0
 * SIZE:     32
 * FIELDS:
 *     TM_CTR           CTR memory TM input
 *     RESV             Debug data
 *
 ******************************************************************************/
#define BCM56800_A0_DEBUG0r 0x0dd80002

#define BCM56800_A0_DEBUG0r_SIZE 4

/*
 * This structure should be used to declare and program DEBUG0.
 *
 */
typedef union BCM56800_A0_DEBUG0r_s {
	uint32_t v[1];
	uint32_t debug0[1];
	uint32_t _debug0;
} BCM56800_A0_DEBUG0r_t;

#define BCM56800_A0_DEBUG0r_CLR(r) (r).debug0[0] = 0
#define BCM56800_A0_DEBUG0r_SET(r,d) (r).debug0[0] = d
#define BCM56800_A0_DEBUG0r_GET(r) (r).debug0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DEBUG0r_TM_CTRf_GET(r) (((r).debug0[0]) & 0xff)
#define BCM56800_A0_DEBUG0r_TM_CTRf_SET(r,f) (r).debug0[0]=(((r).debug0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_DEBUG0r_RESVf_GET(r) ((((r).debug0[0]) >> 8) & 0xffffff)
#define BCM56800_A0_DEBUG0r_RESVf_SET(r,f) (r).debug0[0]=(((r).debug0[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access DEBUG0.
 *
 */
#define BCM56800_A0_READ_DEBUG0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_DEBUG0r,(r._debug0))
#define BCM56800_A0_WRITE_DEBUG0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_DEBUG0r,&(r._debug0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG0r BCM56800_A0_DEBUG0r
#define DEBUG0r_SIZE BCM56800_A0_DEBUG0r_SIZE
typedef BCM56800_A0_DEBUG0r_t DEBUG0r_t;
#define DEBUG0r_CLR BCM56800_A0_DEBUG0r_CLR
#define DEBUG0r_SET BCM56800_A0_DEBUG0r_SET
#define DEBUG0r_GET BCM56800_A0_DEBUG0r_GET
#define DEBUG0r_TM_CTRf_GET BCM56800_A0_DEBUG0r_TM_CTRf_GET
#define DEBUG0r_TM_CTRf_SET BCM56800_A0_DEBUG0r_TM_CTRf_SET
#define DEBUG0r_RESVf_GET BCM56800_A0_DEBUG0r_RESVf_GET
#define DEBUG0r_RESVf_SET BCM56800_A0_DEBUG0r_RESVf_SET
#define READ_DEBUG0r BCM56800_A0_READ_DEBUG0r
#define WRITE_DEBUG0r BCM56800_A0_WRITE_DEBUG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DEBUG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DEBUG1
 * BLOCKS:   MMU
 * DESC:     Debug 1
 * SIZE:     32
 * FIELDS:
 *     TM_EXP           EXP memory TM input
 *     RESV             Debug data
 *
 ******************************************************************************/
#define BCM56800_A0_DEBUG1r 0x0dd80003

#define BCM56800_A0_DEBUG1r_SIZE 4

/*
 * This structure should be used to declare and program DEBUG1.
 *
 */
typedef union BCM56800_A0_DEBUG1r_s {
	uint32_t v[1];
	uint32_t debug1[1];
	uint32_t _debug1;
} BCM56800_A0_DEBUG1r_t;

#define BCM56800_A0_DEBUG1r_CLR(r) (r).debug1[0] = 0
#define BCM56800_A0_DEBUG1r_SET(r,d) (r).debug1[0] = d
#define BCM56800_A0_DEBUG1r_GET(r) (r).debug1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DEBUG1r_TM_EXPf_GET(r) (((r).debug1[0]) & 0xff)
#define BCM56800_A0_DEBUG1r_TM_EXPf_SET(r,f) (r).debug1[0]=(((r).debug1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_DEBUG1r_RESVf_GET(r) ((((r).debug1[0]) >> 8) & 0xffffff)
#define BCM56800_A0_DEBUG1r_RESVf_SET(r,f) (r).debug1[0]=(((r).debug1[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access DEBUG1.
 *
 */
#define BCM56800_A0_READ_DEBUG1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_DEBUG1r,(r._debug1))
#define BCM56800_A0_WRITE_DEBUG1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_DEBUG1r,&(r._debug1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG1r BCM56800_A0_DEBUG1r
#define DEBUG1r_SIZE BCM56800_A0_DEBUG1r_SIZE
typedef BCM56800_A0_DEBUG1r_t DEBUG1r_t;
#define DEBUG1r_CLR BCM56800_A0_DEBUG1r_CLR
#define DEBUG1r_SET BCM56800_A0_DEBUG1r_SET
#define DEBUG1r_GET BCM56800_A0_DEBUG1r_GET
#define DEBUG1r_TM_EXPf_GET BCM56800_A0_DEBUG1r_TM_EXPf_GET
#define DEBUG1r_TM_EXPf_SET BCM56800_A0_DEBUG1r_TM_EXPf_SET
#define DEBUG1r_RESVf_GET BCM56800_A0_DEBUG1r_RESVf_GET
#define DEBUG1r_RESVf_SET BCM56800_A0_DEBUG1r_RESVf_SET
#define READ_DEBUG1r BCM56800_A0_READ_DEBUG1r
#define WRITE_DEBUG1r BCM56800_A0_WRITE_DEBUG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DEBUG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DEQ_AGINGMASK
 * BLOCKS:   MMU
 * DESC:     Aging mask bitmap
 * SIZE:     32
 * FIELDS:
 *     AGINGMASK        Mask per port per switch CoS aging state:write logic high will mask out de-queue cell aging statuswrite logic low has no affect to de-queue cell aging status.
 *
 ******************************************************************************/
#define BCM56800_A0_DEQ_AGINGMASKr 0x05d00003

#define BCM56800_A0_DEQ_AGINGMASKr_SIZE 4

/*
 * This structure should be used to declare and program DEQ_AGINGMASK.
 *
 */
typedef union BCM56800_A0_DEQ_AGINGMASKr_s {
	uint32_t v[1];
	uint32_t deq_agingmask[1];
	uint32_t _deq_agingmask;
} BCM56800_A0_DEQ_AGINGMASKr_t;

#define BCM56800_A0_DEQ_AGINGMASKr_CLR(r) (r).deq_agingmask[0] = 0
#define BCM56800_A0_DEQ_AGINGMASKr_SET(r,d) (r).deq_agingmask[0] = d
#define BCM56800_A0_DEQ_AGINGMASKr_GET(r) (r).deq_agingmask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DEQ_AGINGMASKr_AGINGMASKf_GET(r) (((r).deq_agingmask[0]) & 0xff)
#define BCM56800_A0_DEQ_AGINGMASKr_AGINGMASKf_SET(r,f) (r).deq_agingmask[0]=(((r).deq_agingmask[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access DEQ_AGINGMASK.
 *
 */
#define BCM56800_A0_READ_DEQ_AGINGMASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_DEQ_AGINGMASKr,(r._deq_agingmask))
#define BCM56800_A0_WRITE_DEQ_AGINGMASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_DEQ_AGINGMASKr,&(r._deq_agingmask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEQ_AGINGMASKr BCM56800_A0_DEQ_AGINGMASKr
#define DEQ_AGINGMASKr_SIZE BCM56800_A0_DEQ_AGINGMASKr_SIZE
typedef BCM56800_A0_DEQ_AGINGMASKr_t DEQ_AGINGMASKr_t;
#define DEQ_AGINGMASKr_CLR BCM56800_A0_DEQ_AGINGMASKr_CLR
#define DEQ_AGINGMASKr_SET BCM56800_A0_DEQ_AGINGMASKr_SET
#define DEQ_AGINGMASKr_GET BCM56800_A0_DEQ_AGINGMASKr_GET
#define DEQ_AGINGMASKr_AGINGMASKf_GET BCM56800_A0_DEQ_AGINGMASKr_AGINGMASKf_GET
#define DEQ_AGINGMASKr_AGINGMASKf_SET BCM56800_A0_DEQ_AGINGMASKr_AGINGMASKf_SET
#define READ_DEQ_AGINGMASKr BCM56800_A0_READ_DEQ_AGINGMASKr
#define WRITE_DEQ_AGINGMASKr BCM56800_A0_WRITE_DEQ_AGINGMASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DEQ_AGINGMASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DEQ_BYPASSMMU
 * BLOCKS:   MMU
 * DESC:     MMUBYPASS
 * SIZE:     32
 * FIELDS:
 *     BYPASSMMU        MMU is bypassed if this bit is set to logic one, PBI bus is tied to PBE bus directly.
 *
 ******************************************************************************/
#define BCM56800_A0_DEQ_BYPASSMMUr 0x05d80018

#define BCM56800_A0_DEQ_BYPASSMMUr_SIZE 4

/*
 * This structure should be used to declare and program DEQ_BYPASSMMU.
 *
 */
typedef union BCM56800_A0_DEQ_BYPASSMMUr_s {
	uint32_t v[1];
	uint32_t deq_bypassmmu[1];
	uint32_t _deq_bypassmmu;
} BCM56800_A0_DEQ_BYPASSMMUr_t;

#define BCM56800_A0_DEQ_BYPASSMMUr_CLR(r) (r).deq_bypassmmu[0] = 0
#define BCM56800_A0_DEQ_BYPASSMMUr_SET(r,d) (r).deq_bypassmmu[0] = d
#define BCM56800_A0_DEQ_BYPASSMMUr_GET(r) (r).deq_bypassmmu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DEQ_BYPASSMMUr_BYPASSMMUf_GET(r) (((r).deq_bypassmmu[0]) & 0x1)
#define BCM56800_A0_DEQ_BYPASSMMUr_BYPASSMMUf_SET(r,f) (r).deq_bypassmmu[0]=(((r).deq_bypassmmu[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access DEQ_BYPASSMMU.
 *
 */
#define BCM56800_A0_READ_DEQ_BYPASSMMUr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_DEQ_BYPASSMMUr,(r._deq_bypassmmu))
#define BCM56800_A0_WRITE_DEQ_BYPASSMMUr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_DEQ_BYPASSMMUr,&(r._deq_bypassmmu))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEQ_BYPASSMMUr BCM56800_A0_DEQ_BYPASSMMUr
#define DEQ_BYPASSMMUr_SIZE BCM56800_A0_DEQ_BYPASSMMUr_SIZE
typedef BCM56800_A0_DEQ_BYPASSMMUr_t DEQ_BYPASSMMUr_t;
#define DEQ_BYPASSMMUr_CLR BCM56800_A0_DEQ_BYPASSMMUr_CLR
#define DEQ_BYPASSMMUr_SET BCM56800_A0_DEQ_BYPASSMMUr_SET
#define DEQ_BYPASSMMUr_GET BCM56800_A0_DEQ_BYPASSMMUr_GET
#define DEQ_BYPASSMMUr_BYPASSMMUf_GET BCM56800_A0_DEQ_BYPASSMMUr_BYPASSMMUf_GET
#define DEQ_BYPASSMMUr_BYPASSMMUf_SET BCM56800_A0_DEQ_BYPASSMMUr_BYPASSMMUf_SET
#define READ_DEQ_BYPASSMMUr BCM56800_A0_READ_DEQ_BYPASSMMUr
#define WRITE_DEQ_BYPASSMMUr BCM56800_A0_WRITE_DEQ_BYPASSMMUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DEQ_BYPASSMMUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DEQ_CBPERRPTR
 * BLOCKS:   MMU
 * DESC:     Captutred CBP pointer address
 * SIZE:     32
 * FIELDS:
 *     CBPERRORPOINTER  CBP Memory CRC error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_DEQ_CBPERRPTRr 0x05d80000

#define BCM56800_A0_DEQ_CBPERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program DEQ_CBPERRPTR.
 *
 */
typedef union BCM56800_A0_DEQ_CBPERRPTRr_s {
	uint32_t v[1];
	uint32_t deq_cbperrptr[1];
	uint32_t _deq_cbperrptr;
} BCM56800_A0_DEQ_CBPERRPTRr_t;

#define BCM56800_A0_DEQ_CBPERRPTRr_CLR(r) (r).deq_cbperrptr[0] = 0
#define BCM56800_A0_DEQ_CBPERRPTRr_SET(r,d) (r).deq_cbperrptr[0] = d
#define BCM56800_A0_DEQ_CBPERRPTRr_GET(r) (r).deq_cbperrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DEQ_CBPERRPTRr_CBPERRORPOINTERf_GET(r) (((r).deq_cbperrptr[0]) & 0x3fff)
#define BCM56800_A0_DEQ_CBPERRPTRr_CBPERRORPOINTERf_SET(r,f) (r).deq_cbperrptr[0]=(((r).deq_cbperrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access DEQ_CBPERRPTR.
 *
 */
#define BCM56800_A0_READ_DEQ_CBPERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_DEQ_CBPERRPTRr,(r._deq_cbperrptr))
#define BCM56800_A0_WRITE_DEQ_CBPERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_DEQ_CBPERRPTRr,&(r._deq_cbperrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEQ_CBPERRPTRr BCM56800_A0_DEQ_CBPERRPTRr
#define DEQ_CBPERRPTRr_SIZE BCM56800_A0_DEQ_CBPERRPTRr_SIZE
typedef BCM56800_A0_DEQ_CBPERRPTRr_t DEQ_CBPERRPTRr_t;
#define DEQ_CBPERRPTRr_CLR BCM56800_A0_DEQ_CBPERRPTRr_CLR
#define DEQ_CBPERRPTRr_SET BCM56800_A0_DEQ_CBPERRPTRr_SET
#define DEQ_CBPERRPTRr_GET BCM56800_A0_DEQ_CBPERRPTRr_GET
#define DEQ_CBPERRPTRr_CBPERRORPOINTERf_GET BCM56800_A0_DEQ_CBPERRPTRr_CBPERRORPOINTERf_GET
#define DEQ_CBPERRPTRr_CBPERRORPOINTERf_SET BCM56800_A0_DEQ_CBPERRPTRr_CBPERRORPOINTERf_SET
#define READ_DEQ_CBPERRPTRr BCM56800_A0_READ_DEQ_CBPERRPTRr
#define WRITE_DEQ_CBPERRPTRr BCM56800_A0_WRITE_DEQ_CBPERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DEQ_CBPERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DEQ_PKTHDR0ERRPTR
 * BLOCKS:   MMU
 * DESC:     Captutred PKT HDR 0 pointer address
 * SIZE:     32
 * FIELDS:
 *     PH0ERRORPOINTER  Packet Header 0 Memory parity error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_DEQ_PKTHDR0ERRPTRr 0x05d80001

#define BCM56800_A0_DEQ_PKTHDR0ERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program DEQ_PKTHDR0ERRPTR.
 *
 */
typedef union BCM56800_A0_DEQ_PKTHDR0ERRPTRr_s {
	uint32_t v[1];
	uint32_t deq_pkthdr0errptr[1];
	uint32_t _deq_pkthdr0errptr;
} BCM56800_A0_DEQ_PKTHDR0ERRPTRr_t;

#define BCM56800_A0_DEQ_PKTHDR0ERRPTRr_CLR(r) (r).deq_pkthdr0errptr[0] = 0
#define BCM56800_A0_DEQ_PKTHDR0ERRPTRr_SET(r,d) (r).deq_pkthdr0errptr[0] = d
#define BCM56800_A0_DEQ_PKTHDR0ERRPTRr_GET(r) (r).deq_pkthdr0errptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DEQ_PKTHDR0ERRPTRr_PH0ERRORPOINTERf_GET(r) (((r).deq_pkthdr0errptr[0]) & 0x3fff)
#define BCM56800_A0_DEQ_PKTHDR0ERRPTRr_PH0ERRORPOINTERf_SET(r,f) (r).deq_pkthdr0errptr[0]=(((r).deq_pkthdr0errptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access DEQ_PKTHDR0ERRPTR.
 *
 */
#define BCM56800_A0_READ_DEQ_PKTHDR0ERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_DEQ_PKTHDR0ERRPTRr,(r._deq_pkthdr0errptr))
#define BCM56800_A0_WRITE_DEQ_PKTHDR0ERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_DEQ_PKTHDR0ERRPTRr,&(r._deq_pkthdr0errptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEQ_PKTHDR0ERRPTRr BCM56800_A0_DEQ_PKTHDR0ERRPTRr
#define DEQ_PKTHDR0ERRPTRr_SIZE BCM56800_A0_DEQ_PKTHDR0ERRPTRr_SIZE
typedef BCM56800_A0_DEQ_PKTHDR0ERRPTRr_t DEQ_PKTHDR0ERRPTRr_t;
#define DEQ_PKTHDR0ERRPTRr_CLR BCM56800_A0_DEQ_PKTHDR0ERRPTRr_CLR
#define DEQ_PKTHDR0ERRPTRr_SET BCM56800_A0_DEQ_PKTHDR0ERRPTRr_SET
#define DEQ_PKTHDR0ERRPTRr_GET BCM56800_A0_DEQ_PKTHDR0ERRPTRr_GET
#define DEQ_PKTHDR0ERRPTRr_PH0ERRORPOINTERf_GET BCM56800_A0_DEQ_PKTHDR0ERRPTRr_PH0ERRORPOINTERf_GET
#define DEQ_PKTHDR0ERRPTRr_PH0ERRORPOINTERf_SET BCM56800_A0_DEQ_PKTHDR0ERRPTRr_PH0ERRORPOINTERf_SET
#define READ_DEQ_PKTHDR0ERRPTRr BCM56800_A0_READ_DEQ_PKTHDR0ERRPTRr
#define WRITE_DEQ_PKTHDR0ERRPTRr BCM56800_A0_WRITE_DEQ_PKTHDR0ERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DEQ_PKTHDR0ERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DEQ_PKTHDRCPUERRPTR
 * BLOCKS:   MMU
 * DESC:     Captutred PKT HDR CPU pointer address
 * SIZE:     32
 * FIELDS:
 *     PH0ERRORPOINTER  Packet Header CPU Memory parity error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_DEQ_PKTHDRCPUERRPTRr 0x05d80002

#define BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program DEQ_PKTHDRCPUERRPTR.
 *
 */
typedef union BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_s {
	uint32_t v[1];
	uint32_t deq_pkthdrcpuerrptr[1];
	uint32_t _deq_pkthdrcpuerrptr;
} BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_t;

#define BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_CLR(r) (r).deq_pkthdrcpuerrptr[0] = 0
#define BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_SET(r,d) (r).deq_pkthdrcpuerrptr[0] = d
#define BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_GET(r) (r).deq_pkthdrcpuerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_PH0ERRORPOINTERf_GET(r) (((r).deq_pkthdrcpuerrptr[0]) & 0x3fff)
#define BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_PH0ERRORPOINTERf_SET(r,f) (r).deq_pkthdrcpuerrptr[0]=(((r).deq_pkthdrcpuerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access DEQ_PKTHDRCPUERRPTR.
 *
 */
#define BCM56800_A0_READ_DEQ_PKTHDRCPUERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_DEQ_PKTHDRCPUERRPTRr,(r._deq_pkthdrcpuerrptr))
#define BCM56800_A0_WRITE_DEQ_PKTHDRCPUERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_DEQ_PKTHDRCPUERRPTRr,&(r._deq_pkthdrcpuerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEQ_PKTHDRCPUERRPTRr BCM56800_A0_DEQ_PKTHDRCPUERRPTRr
#define DEQ_PKTHDRCPUERRPTRr_SIZE BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_SIZE
typedef BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_t DEQ_PKTHDRCPUERRPTRr_t;
#define DEQ_PKTHDRCPUERRPTRr_CLR BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_CLR
#define DEQ_PKTHDRCPUERRPTRr_SET BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_SET
#define DEQ_PKTHDRCPUERRPTRr_GET BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_GET
#define DEQ_PKTHDRCPUERRPTRr_PH0ERRORPOINTERf_GET BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_PH0ERRORPOINTERf_GET
#define DEQ_PKTHDRCPUERRPTRr_PH0ERRORPOINTERf_SET BCM56800_A0_DEQ_PKTHDRCPUERRPTRr_PH0ERRORPOINTERf_SET
#define READ_DEQ_PKTHDRCPUERRPTRr BCM56800_A0_READ_DEQ_PKTHDRCPUERRPTRr
#define WRITE_DEQ_PKTHDRCPUERRPTRr BCM56800_A0_WRITE_DEQ_PKTHDRCPUERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DEQ_PKTHDRCPUERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DLFBC_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet DLF Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           DLF rate control enable
 *
 ******************************************************************************/
#define BCM56800_A0_DLFBC_STORM_CONTROLr 0x0b100003

#define BCM56800_A0_DLFBC_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DLFBC_STORM_CONTROL.
 *
 */
typedef union BCM56800_A0_DLFBC_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t dlfbc_storm_control[1];
	uint32_t _dlfbc_storm_control;
} BCM56800_A0_DLFBC_STORM_CONTROLr_t;

#define BCM56800_A0_DLFBC_STORM_CONTROLr_CLR(r) (r).dlfbc_storm_control[0] = 0
#define BCM56800_A0_DLFBC_STORM_CONTROLr_SET(r,d) (r).dlfbc_storm_control[0] = d
#define BCM56800_A0_DLFBC_STORM_CONTROLr_GET(r) (r).dlfbc_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).dlfbc_storm_control[0]) & 0x1ffffff)
#define BCM56800_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).dlfbc_storm_control[0]=(((r).dlfbc_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56800_A0_DLFBC_STORM_CONTROLr_ENABLEf_GET(r) ((((r).dlfbc_storm_control[0]) >> 25) & 0x1)
#define BCM56800_A0_DLFBC_STORM_CONTROLr_ENABLEf_SET(r,f) (r).dlfbc_storm_control[0]=(((r).dlfbc_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access DLFBC_STORM_CONTROL.
 *
 */
#define BCM56800_A0_READ_DLFBC_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_DLFBC_STORM_CONTROLr,(r._dlfbc_storm_control))
#define BCM56800_A0_WRITE_DLFBC_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_DLFBC_STORM_CONTROLr,&(r._dlfbc_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DLFBC_STORM_CONTROLr BCM56800_A0_DLFBC_STORM_CONTROLr
#define DLFBC_STORM_CONTROLr_SIZE BCM56800_A0_DLFBC_STORM_CONTROLr_SIZE
typedef BCM56800_A0_DLFBC_STORM_CONTROLr_t DLFBC_STORM_CONTROLr_t;
#define DLFBC_STORM_CONTROLr_CLR BCM56800_A0_DLFBC_STORM_CONTROLr_CLR
#define DLFBC_STORM_CONTROLr_SET BCM56800_A0_DLFBC_STORM_CONTROLr_SET
#define DLFBC_STORM_CONTROLr_GET BCM56800_A0_DLFBC_STORM_CONTROLr_GET
#define DLFBC_STORM_CONTROLr_THRESHOLDf_GET BCM56800_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_GET
#define DLFBC_STORM_CONTROLr_THRESHOLDf_SET BCM56800_A0_DLFBC_STORM_CONTROLr_THRESHOLDf_SET
#define DLFBC_STORM_CONTROLr_ENABLEf_GET BCM56800_A0_DLFBC_STORM_CONTROLr_ENABLEf_GET
#define DLFBC_STORM_CONTROLr_ENABLEf_SET BCM56800_A0_DLFBC_STORM_CONTROLr_ENABLEf_SET
#define READ_DLFBC_STORM_CONTROLr BCM56800_A0_READ_DLFBC_STORM_CONTROLr
#define WRITE_DLFBC_STORM_CONTROLr BCM56800_A0_WRITE_DLFBC_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DLFBC_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DOS_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register
 * SIZE:     32
 * FIELDS:
 *     ICMP_CHECK_ENABLE Enable ICMP DOS attack checks
 *     TCP_FRAG_CHECK_ENABLE Enable checking TCP DOS fragment attack
 *     L4_PORT_CHECK_ENABLE Enable checking TCP/UDP DOS attack for dropping packet if TCP/UDP source port == destination port
 *     TCP_FLAGS_CHECK_ENABLE Enable checking TCP DOS attacks on invalid flags
 *     IPV4_FIRST_FRAG_CHECK_ENABLE Enable checking DOS attacks on IP first fragments
 *     BIG_ICMP_PKT_SIZE Maximum length ICMP packet allowed before dropping (maximum 16k bytes)
 *     MIN_TCPHDR_SIZE  Minimum TCP header length allowed (minimum 0 bytes, maximum 255 bytes)
 *     DROP_IF_SIP_EQUALS_DIP Drop IPv4/IPv6 packets if the SIP == DIP
 *
 ******************************************************************************/
#define BCM56800_A0_DOS_CONTROLr 0x01180601

#define BCM56800_A0_DOS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL.
 *
 */
typedef union BCM56800_A0_DOS_CONTROLr_s {
	uint32_t v[1];
	uint32_t dos_control[1];
	uint32_t _dos_control;
} BCM56800_A0_DOS_CONTROLr_t;

#define BCM56800_A0_DOS_CONTROLr_CLR(r) (r).dos_control[0] = 0
#define BCM56800_A0_DOS_CONTROLr_SET(r,d) (r).dos_control[0] = d
#define BCM56800_A0_DOS_CONTROLr_GET(r) (r).dos_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DOS_CONTROLr_ICMP_CHECK_ENABLEf_GET(r) (((r).dos_control[0]) & 0x1)
#define BCM56800_A0_DOS_CONTROLr_ICMP_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 1) & 0x1)
#define BCM56800_A0_DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 2) & 0x1)
#define BCM56800_A0_DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 3) & 0x1)
#define BCM56800_A0_DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET(r) ((((r).dos_control[0]) >> 4) & 0x1)
#define BCM56800_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET(r) ((((r).dos_control[0]) >> 5) & 0xffff)
#define BCM56800_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0xffff << 5)) | ((((uint32_t)f) & 0xffff) << 5))
#define BCM56800_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET(r) ((((r).dos_control[0]) >> 21) & 0xff)
#define BCM56800_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))
#define BCM56800_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET(r) ((((r).dos_control[0]) >> 29) & 0x1)
#define BCM56800_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET(r,f) (r).dos_control[0]=(((r).dos_control[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access DOS_CONTROL.
 *
 */
#define BCM56800_A0_READ_DOS_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_DOS_CONTROLr,(r._dos_control))
#define BCM56800_A0_WRITE_DOS_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_DOS_CONTROLr,&(r._dos_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CONTROLr BCM56800_A0_DOS_CONTROLr
#define DOS_CONTROLr_SIZE BCM56800_A0_DOS_CONTROLr_SIZE
typedef BCM56800_A0_DOS_CONTROLr_t DOS_CONTROLr_t;
#define DOS_CONTROLr_CLR BCM56800_A0_DOS_CONTROLr_CLR
#define DOS_CONTROLr_SET BCM56800_A0_DOS_CONTROLr_SET
#define DOS_CONTROLr_GET BCM56800_A0_DOS_CONTROLr_GET
#define DOS_CONTROLr_ICMP_CHECK_ENABLEf_GET BCM56800_A0_DOS_CONTROLr_ICMP_CHECK_ENABLEf_GET
#define DOS_CONTROLr_ICMP_CHECK_ENABLEf_SET BCM56800_A0_DOS_CONTROLr_ICMP_CHECK_ENABLEf_SET
#define DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_GET BCM56800_A0_DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_GET
#define DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_SET BCM56800_A0_DOS_CONTROLr_TCP_FRAG_CHECK_ENABLEf_SET
#define DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_GET BCM56800_A0_DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_GET
#define DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_SET BCM56800_A0_DOS_CONTROLr_L4_PORT_CHECK_ENABLEf_SET
#define DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_GET BCM56800_A0_DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_GET
#define DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_SET BCM56800_A0_DOS_CONTROLr_TCP_FLAGS_CHECK_ENABLEf_SET
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET BCM56800_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_GET
#define DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET BCM56800_A0_DOS_CONTROLr_IPV4_FIRST_FRAG_CHECK_ENABLEf_SET
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET BCM56800_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_GET
#define DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET BCM56800_A0_DOS_CONTROLr_BIG_ICMP_PKT_SIZEf_SET
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET BCM56800_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_GET
#define DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET BCM56800_A0_DOS_CONTROLr_MIN_TCPHDR_SIZEf_SET
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET BCM56800_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_GET
#define DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET BCM56800_A0_DOS_CONTROLr_DROP_IF_SIP_EQUALS_DIPf_SET
#define READ_DOS_CONTROLr BCM56800_A0_READ_DOS_CONTROLr
#define WRITE_DOS_CONTROLr BCM56800_A0_WRITE_DOS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DOS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DOS_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     DOS (Denial of Service) Attack Control Register #2
 * SIZE:     32
 * FIELDS:
 *     BIG_ICMPV6_PKT_SIZE Maximum length ICMPv6 ping packet allowed before dropping (maximum 16k bytes)
 *
 ******************************************************************************/
#define BCM56800_A0_DOS_CONTROL_2r 0x01180602

#define BCM56800_A0_DOS_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program DOS_CONTROL_2.
 *
 */
typedef union BCM56800_A0_DOS_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t dos_control_2[1];
	uint32_t _dos_control_2;
} BCM56800_A0_DOS_CONTROL_2r_t;

#define BCM56800_A0_DOS_CONTROL_2r_CLR(r) (r).dos_control_2[0] = 0
#define BCM56800_A0_DOS_CONTROL_2r_SET(r,d) (r).dos_control_2[0] = d
#define BCM56800_A0_DOS_CONTROL_2r_GET(r) (r).dos_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET(r) (((r).dos_control_2[0]) & 0xffff)
#define BCM56800_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET(r,f) (r).dos_control_2[0]=(((r).dos_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DOS_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_DOS_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_DOS_CONTROL_2r,(r._dos_control_2))
#define BCM56800_A0_WRITE_DOS_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_DOS_CONTROL_2r,&(r._dos_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CONTROL_2r BCM56800_A0_DOS_CONTROL_2r
#define DOS_CONTROL_2r_SIZE BCM56800_A0_DOS_CONTROL_2r_SIZE
typedef BCM56800_A0_DOS_CONTROL_2r_t DOS_CONTROL_2r_t;
#define DOS_CONTROL_2r_CLR BCM56800_A0_DOS_CONTROL_2r_CLR
#define DOS_CONTROL_2r_SET BCM56800_A0_DOS_CONTROL_2r_SET
#define DOS_CONTROL_2r_GET BCM56800_A0_DOS_CONTROL_2r_GET
#define DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET BCM56800_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_GET
#define DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET BCM56800_A0_DOS_CONTROL_2r_BIG_ICMPV6_PKT_SIZEf_SET
#define READ_DOS_CONTROL_2r BCM56800_A0_READ_DOS_CONTROL_2r
#define WRITE_DOS_CONTROL_2r BCM56800_A0_WRITE_DOS_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DOS_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  DROP_PKT_CNT
 * BLOCKS:   MMU
 * DESC:     Drop packet counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Drop packet count
 *
 ******************************************************************************/
#define BCM56800_A0_DROP_PKT_CNTr 0x0ed00030

#define BCM56800_A0_DROP_PKT_CNTr_SIZE 4

/*
 * This structure should be used to declare and program DROP_PKT_CNT.
 *
 */
typedef union BCM56800_A0_DROP_PKT_CNTr_s {
	uint32_t v[1];
	uint32_t drop_pkt_cnt[1];
	uint32_t _drop_pkt_cnt;
} BCM56800_A0_DROP_PKT_CNTr_t;

#define BCM56800_A0_DROP_PKT_CNTr_CLR(r) (r).drop_pkt_cnt[0] = 0
#define BCM56800_A0_DROP_PKT_CNTr_SET(r,d) (r).drop_pkt_cnt[0] = d
#define BCM56800_A0_DROP_PKT_CNTr_GET(r) (r).drop_pkt_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DROP_PKT_CNTr_COUNTf_GET(r) ((r).drop_pkt_cnt[0])
#define BCM56800_A0_DROP_PKT_CNTr_COUNTf_SET(r,f) (r).drop_pkt_cnt[0]=((uint32_t)f)

/*
 * These macros can be used to access DROP_PKT_CNT.
 *
 */
#define BCM56800_A0_READ_DROP_PKT_CNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_DROP_PKT_CNTr,(r._drop_pkt_cnt))
#define BCM56800_A0_WRITE_DROP_PKT_CNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_DROP_PKT_CNTr,&(r._drop_pkt_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DROP_PKT_CNTr BCM56800_A0_DROP_PKT_CNTr
#define DROP_PKT_CNTr_SIZE BCM56800_A0_DROP_PKT_CNTr_SIZE
typedef BCM56800_A0_DROP_PKT_CNTr_t DROP_PKT_CNTr_t;
#define DROP_PKT_CNTr_CLR BCM56800_A0_DROP_PKT_CNTr_CLR
#define DROP_PKT_CNTr_SET BCM56800_A0_DROP_PKT_CNTr_SET
#define DROP_PKT_CNTr_GET BCM56800_A0_DROP_PKT_CNTr_GET
#define DROP_PKT_CNTr_COUNTf_GET BCM56800_A0_DROP_PKT_CNTr_COUNTf_GET
#define DROP_PKT_CNTr_COUNTf_SET BCM56800_A0_DROP_PKT_CNTr_COUNTf_SET
#define READ_DROP_PKT_CNTr BCM56800_A0_READ_DROP_PKT_CNTr
#define WRITE_DROP_PKT_CNTr BCM56800_A0_WRITE_DROP_PKT_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DROP_PKT_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  DSCP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Diff Serv Code Point Table
 * SIZE:     11
 * FIELDS:
 *     DSCP             New Diff Serv Code Point
 *     PRI              Priority
 *     CNG              Congestion bits
 *
 ******************************************************************************/
#define BCM56800_A0_DSCP_TABLEm 0x08160000

#define BCM56800_A0_DSCP_TABLEm_MIN 0
#define BCM56800_A0_DSCP_TABLEm_MAX 63
#define BCM56800_A0_DSCP_TABLEm_CMAX(u) 63
#define BCM56800_A0_DSCP_TABLEm_SIZE 2

/*
 * This structure should be used to declare and program DSCP_TABLE.
 *
 */
typedef union BCM56800_A0_DSCP_TABLEm_s {
	uint32_t v[1];
	uint32_t dscp_table[1];
	uint32_t _dscp_table;
} BCM56800_A0_DSCP_TABLEm_t;

#define BCM56800_A0_DSCP_TABLEm_CLR(r) (r).dscp_table[0] = 0
#define BCM56800_A0_DSCP_TABLEm_SET(r,d) (r).dscp_table[0] = d
#define BCM56800_A0_DSCP_TABLEm_GET(r) (r).dscp_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_DSCP_TABLEm_DSCPf_GET(r) (((r).dscp_table[0]) & 0x3f)
#define BCM56800_A0_DSCP_TABLEm_DSCPf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_DSCP_TABLEm_PRIf_GET(r) ((((r).dscp_table[0]) >> 6) & 0x7)
#define BCM56800_A0_DSCP_TABLEm_PRIf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56800_A0_DSCP_TABLEm_CNGf_GET(r) ((((r).dscp_table[0]) >> 9) & 0x3)
#define BCM56800_A0_DSCP_TABLEm_CNGf_SET(r,f) (r).dscp_table[0]=(((r).dscp_table[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))

/*
 * These macros can be used to access DSCP_TABLE.
 *
 */
#define BCM56800_A0_READ_DSCP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_DSCP_TABLEm,i,(m._dscp_table),1)
#define BCM56800_A0_WRITE_DSCP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_DSCP_TABLEm,i,&(m._dscp_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DSCP_TABLEm BCM56800_A0_DSCP_TABLEm
#define DSCP_TABLEm_MIN BCM56800_A0_DSCP_TABLEm_MIN
#define DSCP_TABLEm_MAX BCM56800_A0_DSCP_TABLEm_MAX
#define DSCP_TABLEm_CMAX(u) BCM56800_A0_DSCP_TABLEm_CMAX(u)
#define DSCP_TABLEm_SIZE BCM56800_A0_DSCP_TABLEm_SIZE
typedef BCM56800_A0_DSCP_TABLEm_t DSCP_TABLEm_t;
#define DSCP_TABLEm_CLR BCM56800_A0_DSCP_TABLEm_CLR
#define DSCP_TABLEm_SET BCM56800_A0_DSCP_TABLEm_SET
#define DSCP_TABLEm_GET BCM56800_A0_DSCP_TABLEm_GET
#define DSCP_TABLEm_DSCPf_GET BCM56800_A0_DSCP_TABLEm_DSCPf_GET
#define DSCP_TABLEm_DSCPf_SET BCM56800_A0_DSCP_TABLEm_DSCPf_SET
#define DSCP_TABLEm_PRIf_GET BCM56800_A0_DSCP_TABLEm_PRIf_GET
#define DSCP_TABLEm_PRIf_SET BCM56800_A0_DSCP_TABLEm_PRIf_SET
#define DSCP_TABLEm_CNGf_GET BCM56800_A0_DSCP_TABLEm_CNGf_GET
#define DSCP_TABLEm_CNGf_SET BCM56800_A0_DSCP_TABLEm_CNGf_SET
#define READ_DSCP_TABLEm BCM56800_A0_READ_DSCP_TABLEm
#define WRITE_DSCP_TABLEm BCM56800_A0_WRITE_DSCP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_DSCP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_HOL_EN
 * BLOCKS:   MMU
 * DESC:     E2E HOL report enable
 * SIZE:     32
 * FIELDS:
 *     EN               report enable
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_HOL_ENr 0x0bd80000

#define BCM56800_A0_E2E_HOL_ENr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_EN.
 *
 */
typedef union BCM56800_A0_E2E_HOL_ENr_s {
	uint32_t v[1];
	uint32_t e2e_hol_en[1];
	uint32_t _e2e_hol_en;
} BCM56800_A0_E2E_HOL_ENr_t;

#define BCM56800_A0_E2E_HOL_ENr_CLR(r) (r).e2e_hol_en[0] = 0
#define BCM56800_A0_E2E_HOL_ENr_SET(r,d) (r).e2e_hol_en[0] = d
#define BCM56800_A0_E2E_HOL_ENr_GET(r) (r).e2e_hol_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_HOL_ENr_ENf_GET(r) (((r).e2e_hol_en[0]) & 0x1)
#define BCM56800_A0_E2E_HOL_ENr_ENf_SET(r,f) (r).e2e_hol_en[0]=(((r).e2e_hol_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access E2E_HOL_EN.
 *
 */
#define BCM56800_A0_READ_E2E_HOL_ENr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_HOL_ENr,(r._e2e_hol_en))
#define BCM56800_A0_WRITE_E2E_HOL_ENr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_HOL_ENr,&(r._e2e_hol_en))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_ENr BCM56800_A0_E2E_HOL_ENr
#define E2E_HOL_ENr_SIZE BCM56800_A0_E2E_HOL_ENr_SIZE
typedef BCM56800_A0_E2E_HOL_ENr_t E2E_HOL_ENr_t;
#define E2E_HOL_ENr_CLR BCM56800_A0_E2E_HOL_ENr_CLR
#define E2E_HOL_ENr_SET BCM56800_A0_E2E_HOL_ENr_SET
#define E2E_HOL_ENr_GET BCM56800_A0_E2E_HOL_ENr_GET
#define E2E_HOL_ENr_ENf_GET BCM56800_A0_E2E_HOL_ENr_ENf_GET
#define E2E_HOL_ENr_ENf_SET BCM56800_A0_E2E_HOL_ENr_ENf_SET
#define READ_E2E_HOL_ENr BCM56800_A0_READ_E2E_HOL_ENr
#define WRITE_E2E_HOL_ENr BCM56800_A0_WRITE_E2E_HOL_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_HOL_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_HOL_PBM
 * BLOCKS:   MMU
 * DESC:     E2E HOL port bitmap/index
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      port bitmap
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_HOL_PBMr 0x0bd80001

#define BCM56800_A0_E2E_HOL_PBMr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_PBM.
 *
 */
typedef union BCM56800_A0_E2E_HOL_PBMr_s {
	uint32_t v[1];
	uint32_t e2e_hol_pbm[1];
	uint32_t _e2e_hol_pbm;
} BCM56800_A0_E2E_HOL_PBMr_t;

#define BCM56800_A0_E2E_HOL_PBMr_CLR(r) (r).e2e_hol_pbm[0] = 0
#define BCM56800_A0_E2E_HOL_PBMr_SET(r,d) (r).e2e_hol_pbm[0] = d
#define BCM56800_A0_E2E_HOL_PBMr_GET(r) (r).e2e_hol_pbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_HOL_PBMr_PORT_BITMAPf_GET(r) (((r).e2e_hol_pbm[0]) & 0xfffff)
#define BCM56800_A0_E2E_HOL_PBMr_PORT_BITMAPf_SET(r,f) (r).e2e_hol_pbm[0]=(((r).e2e_hol_pbm[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))

/*
 * These macros can be used to access E2E_HOL_PBM.
 *
 */
#define BCM56800_A0_READ_E2E_HOL_PBMr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_HOL_PBMr,(r._e2e_hol_pbm))
#define BCM56800_A0_WRITE_E2E_HOL_PBMr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_HOL_PBMr,&(r._e2e_hol_pbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_PBMr BCM56800_A0_E2E_HOL_PBMr
#define E2E_HOL_PBMr_SIZE BCM56800_A0_E2E_HOL_PBMr_SIZE
typedef BCM56800_A0_E2E_HOL_PBMr_t E2E_HOL_PBMr_t;
#define E2E_HOL_PBMr_CLR BCM56800_A0_E2E_HOL_PBMr_CLR
#define E2E_HOL_PBMr_SET BCM56800_A0_E2E_HOL_PBMr_SET
#define E2E_HOL_PBMr_GET BCM56800_A0_E2E_HOL_PBMr_GET
#define E2E_HOL_PBMr_PORT_BITMAPf_GET BCM56800_A0_E2E_HOL_PBMr_PORT_BITMAPf_GET
#define E2E_HOL_PBMr_PORT_BITMAPf_SET BCM56800_A0_E2E_HOL_PBMr_PORT_BITMAPf_SET
#define READ_E2E_HOL_PBMr BCM56800_A0_READ_E2E_HOL_PBMr
#define WRITE_E2E_HOL_PBMr BCM56800_A0_WRITE_E2E_HOL_PBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_HOL_PBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_HOL_RX_DA_LS
 * BLOCKS:   IPIPE
 * DESC:     End-to-End HOL LSB DA Register
 * SIZE:     32
 * FIELDS:
 *     DA               Least significant 16-bits of the DA for receive E2E HOL messages
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_HOL_RX_DA_LSr 0x02180601

#define BCM56800_A0_E2E_HOL_RX_DA_LSr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_RX_DA_LS.
 *
 */
typedef union BCM56800_A0_E2E_HOL_RX_DA_LSr_s {
	uint32_t v[1];
	uint32_t e2e_hol_rx_da_ls[1];
	uint32_t _e2e_hol_rx_da_ls;
} BCM56800_A0_E2E_HOL_RX_DA_LSr_t;

#define BCM56800_A0_E2E_HOL_RX_DA_LSr_CLR(r) (r).e2e_hol_rx_da_ls[0] = 0
#define BCM56800_A0_E2E_HOL_RX_DA_LSr_SET(r,d) (r).e2e_hol_rx_da_ls[0] = d
#define BCM56800_A0_E2E_HOL_RX_DA_LSr_GET(r) (r).e2e_hol_rx_da_ls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_HOL_RX_DA_LSr_DAf_GET(r) ((r).e2e_hol_rx_da_ls[0])
#define BCM56800_A0_E2E_HOL_RX_DA_LSr_DAf_SET(r,f) (r).e2e_hol_rx_da_ls[0]=((uint32_t)f)

/*
 * These macros can be used to access E2E_HOL_RX_DA_LS.
 *
 */
#define BCM56800_A0_READ_E2E_HOL_RX_DA_LSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_HOL_RX_DA_LSr,(r._e2e_hol_rx_da_ls))
#define BCM56800_A0_WRITE_E2E_HOL_RX_DA_LSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_HOL_RX_DA_LSr,&(r._e2e_hol_rx_da_ls))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_RX_DA_LSr BCM56800_A0_E2E_HOL_RX_DA_LSr
#define E2E_HOL_RX_DA_LSr_SIZE BCM56800_A0_E2E_HOL_RX_DA_LSr_SIZE
typedef BCM56800_A0_E2E_HOL_RX_DA_LSr_t E2E_HOL_RX_DA_LSr_t;
#define E2E_HOL_RX_DA_LSr_CLR BCM56800_A0_E2E_HOL_RX_DA_LSr_CLR
#define E2E_HOL_RX_DA_LSr_SET BCM56800_A0_E2E_HOL_RX_DA_LSr_SET
#define E2E_HOL_RX_DA_LSr_GET BCM56800_A0_E2E_HOL_RX_DA_LSr_GET
#define E2E_HOL_RX_DA_LSr_DAf_GET BCM56800_A0_E2E_HOL_RX_DA_LSr_DAf_GET
#define E2E_HOL_RX_DA_LSr_DAf_SET BCM56800_A0_E2E_HOL_RX_DA_LSr_DAf_SET
#define READ_E2E_HOL_RX_DA_LSr BCM56800_A0_READ_E2E_HOL_RX_DA_LSr
#define WRITE_E2E_HOL_RX_DA_LSr BCM56800_A0_WRITE_E2E_HOL_RX_DA_LSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_HOL_RX_DA_LSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_HOL_RX_DA_MS
 * BLOCKS:   IPIPE
 * DESC:     End-to-End HOL MSB DA Register
 * SIZE:     32
 * FIELDS:
 *     DA               Most significant 16-bits of the DA for receive E2E HOL messages
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_HOL_RX_DA_MSr 0x02180600

#define BCM56800_A0_E2E_HOL_RX_DA_MSr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_RX_DA_MS.
 *
 */
typedef union BCM56800_A0_E2E_HOL_RX_DA_MSr_s {
	uint32_t v[1];
	uint32_t e2e_hol_rx_da_ms[1];
	uint32_t _e2e_hol_rx_da_ms;
} BCM56800_A0_E2E_HOL_RX_DA_MSr_t;

#define BCM56800_A0_E2E_HOL_RX_DA_MSr_CLR(r) (r).e2e_hol_rx_da_ms[0] = 0
#define BCM56800_A0_E2E_HOL_RX_DA_MSr_SET(r,d) (r).e2e_hol_rx_da_ms[0] = d
#define BCM56800_A0_E2E_HOL_RX_DA_MSr_GET(r) (r).e2e_hol_rx_da_ms[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_HOL_RX_DA_MSr_DAf_GET(r) (((r).e2e_hol_rx_da_ms[0]) & 0xffff)
#define BCM56800_A0_E2E_HOL_RX_DA_MSr_DAf_SET(r,f) (r).e2e_hol_rx_da_ms[0]=(((r).e2e_hol_rx_da_ms[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_HOL_RX_DA_MS.
 *
 */
#define BCM56800_A0_READ_E2E_HOL_RX_DA_MSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_HOL_RX_DA_MSr,(r._e2e_hol_rx_da_ms))
#define BCM56800_A0_WRITE_E2E_HOL_RX_DA_MSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_HOL_RX_DA_MSr,&(r._e2e_hol_rx_da_ms))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_RX_DA_MSr BCM56800_A0_E2E_HOL_RX_DA_MSr
#define E2E_HOL_RX_DA_MSr_SIZE BCM56800_A0_E2E_HOL_RX_DA_MSr_SIZE
typedef BCM56800_A0_E2E_HOL_RX_DA_MSr_t E2E_HOL_RX_DA_MSr_t;
#define E2E_HOL_RX_DA_MSr_CLR BCM56800_A0_E2E_HOL_RX_DA_MSr_CLR
#define E2E_HOL_RX_DA_MSr_SET BCM56800_A0_E2E_HOL_RX_DA_MSr_SET
#define E2E_HOL_RX_DA_MSr_GET BCM56800_A0_E2E_HOL_RX_DA_MSr_GET
#define E2E_HOL_RX_DA_MSr_DAf_GET BCM56800_A0_E2E_HOL_RX_DA_MSr_DAf_GET
#define E2E_HOL_RX_DA_MSr_DAf_SET BCM56800_A0_E2E_HOL_RX_DA_MSr_DAf_SET
#define READ_E2E_HOL_RX_DA_MSr BCM56800_A0_READ_E2E_HOL_RX_DA_MSr
#define WRITE_E2E_HOL_RX_DA_MSr BCM56800_A0_WRITE_E2E_HOL_RX_DA_MSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_HOL_RX_DA_MSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_HOL_RX_LENGTH_TYPE
 * BLOCKS:   IPIPE
 * DESC:     End-to-End HOL Length/Type Register
 * SIZE:     32
 * FIELDS:
 *     LENGTH_TYPE      Length/Type Field for receive E2E HOL messages
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr 0x02180602

#define BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_RX_LENGTH_TYPE.
 *
 */
typedef union BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_s {
	uint32_t v[1];
	uint32_t e2e_hol_rx_length_type[1];
	uint32_t _e2e_hol_rx_length_type;
} BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_t;

#define BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_CLR(r) (r).e2e_hol_rx_length_type[0] = 0
#define BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_SET(r,d) (r).e2e_hol_rx_length_type[0] = d
#define BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_GET(r) (r).e2e_hol_rx_length_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET(r) (((r).e2e_hol_rx_length_type[0]) & 0xffff)
#define BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET(r,f) (r).e2e_hol_rx_length_type[0]=(((r).e2e_hol_rx_length_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_HOL_RX_LENGTH_TYPE.
 *
 */
#define BCM56800_A0_READ_E2E_HOL_RX_LENGTH_TYPEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr,(r._e2e_hol_rx_length_type))
#define BCM56800_A0_WRITE_E2E_HOL_RX_LENGTH_TYPEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr,&(r._e2e_hol_rx_length_type))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_RX_LENGTH_TYPEr BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr
#define E2E_HOL_RX_LENGTH_TYPEr_SIZE BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_SIZE
typedef BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_t E2E_HOL_RX_LENGTH_TYPEr_t;
#define E2E_HOL_RX_LENGTH_TYPEr_CLR BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_CLR
#define E2E_HOL_RX_LENGTH_TYPEr_SET BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_SET
#define E2E_HOL_RX_LENGTH_TYPEr_GET BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_GET
#define E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET
#define E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET
#define READ_E2E_HOL_RX_LENGTH_TYPEr BCM56800_A0_READ_E2E_HOL_RX_LENGTH_TYPEr
#define WRITE_E2E_HOL_RX_LENGTH_TYPEr BCM56800_A0_WRITE_E2E_HOL_RX_LENGTH_TYPEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_HOL_RX_LENGTH_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_HOL_RX_OPCODE
 * BLOCKS:   IPIPE
 * DESC:     End-to-End HOL Opcode Register
 * SIZE:     32
 * FIELDS:
 *     OPCODE           Opcode Field for receive E2E HOL messages
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_HOL_RX_OPCODEr 0x02180603

#define BCM56800_A0_E2E_HOL_RX_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program E2E_HOL_RX_OPCODE.
 *
 */
typedef union BCM56800_A0_E2E_HOL_RX_OPCODEr_s {
	uint32_t v[1];
	uint32_t e2e_hol_rx_opcode[1];
	uint32_t _e2e_hol_rx_opcode;
} BCM56800_A0_E2E_HOL_RX_OPCODEr_t;

#define BCM56800_A0_E2E_HOL_RX_OPCODEr_CLR(r) (r).e2e_hol_rx_opcode[0] = 0
#define BCM56800_A0_E2E_HOL_RX_OPCODEr_SET(r,d) (r).e2e_hol_rx_opcode[0] = d
#define BCM56800_A0_E2E_HOL_RX_OPCODEr_GET(r) (r).e2e_hol_rx_opcode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_HOL_RX_OPCODEr_OPCODEf_GET(r) (((r).e2e_hol_rx_opcode[0]) & 0xffff)
#define BCM56800_A0_E2E_HOL_RX_OPCODEr_OPCODEf_SET(r,f) (r).e2e_hol_rx_opcode[0]=(((r).e2e_hol_rx_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_HOL_RX_OPCODE.
 *
 */
#define BCM56800_A0_READ_E2E_HOL_RX_OPCODEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_HOL_RX_OPCODEr,(r._e2e_hol_rx_opcode))
#define BCM56800_A0_WRITE_E2E_HOL_RX_OPCODEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_HOL_RX_OPCODEr,&(r._e2e_hol_rx_opcode))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_RX_OPCODEr BCM56800_A0_E2E_HOL_RX_OPCODEr
#define E2E_HOL_RX_OPCODEr_SIZE BCM56800_A0_E2E_HOL_RX_OPCODEr_SIZE
typedef BCM56800_A0_E2E_HOL_RX_OPCODEr_t E2E_HOL_RX_OPCODEr_t;
#define E2E_HOL_RX_OPCODEr_CLR BCM56800_A0_E2E_HOL_RX_OPCODEr_CLR
#define E2E_HOL_RX_OPCODEr_SET BCM56800_A0_E2E_HOL_RX_OPCODEr_SET
#define E2E_HOL_RX_OPCODEr_GET BCM56800_A0_E2E_HOL_RX_OPCODEr_GET
#define E2E_HOL_RX_OPCODEr_OPCODEf_GET BCM56800_A0_E2E_HOL_RX_OPCODEr_OPCODEf_GET
#define E2E_HOL_RX_OPCODEr_OPCODEf_SET BCM56800_A0_E2E_HOL_RX_OPCODEr_OPCODEf_SET
#define READ_E2E_HOL_RX_OPCODEr BCM56800_A0_READ_E2E_HOL_RX_OPCODEr
#define WRITE_E2E_HOL_RX_OPCODEr BCM56800_A0_WRITE_E2E_HOL_RX_OPCODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_HOL_RX_OPCODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  E2E_HOL_STATUS
 * BLOCKS:   IPIPE
 * DESC:     Remote Module End-to-End HOL Status Table
 * SIZE:     256
 * FIELDS:
 *     COS0_HOL_BITMAP  COS0 Port Bitmap
 *     COS1_HOL_BITMAP  COS1 Port Bitmap
 *     COS2_HOL_BITMAP  COS2 Port Bitmap
 *     COS3_HOL_BITMAP  COS3 Port Bitmap
 *     COS4_HOL_BITMAP  COS4 Port Bitmap
 *     COS5_HOL_BITMAP  COS5 Port Bitmap
 *     COS6_HOL_BITMAP  COS6 Port Bitmap
 *     COS7_HOL_BITMAP  COS7 Port Bitmap
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_HOL_STATUSm 0x0e127000

#define BCM56800_A0_E2E_HOL_STATUSm_MIN 0
#define BCM56800_A0_E2E_HOL_STATUSm_MAX 127
#define BCM56800_A0_E2E_HOL_STATUSm_CMAX(u) 127
#define BCM56800_A0_E2E_HOL_STATUSm_SIZE 32

/*
 * This structure should be used to declare and program E2E_HOL_STATUS.
 *
 */
typedef union BCM56800_A0_E2E_HOL_STATUSm_s {
	uint32_t v[8];
	uint32_t e2e_hol_status[8];
	uint32_t _e2e_hol_status;
} BCM56800_A0_E2E_HOL_STATUSm_t;

#define BCM56800_A0_E2E_HOL_STATUSm_CLR(r) CDK_MEMSET(&((r)._e2e_hol_status), 0, sizeof(BCM56800_A0_E2E_HOL_STATUSm_t))
#define BCM56800_A0_E2E_HOL_STATUSm_SET(r,i,d) (r).e2e_hol_status[i] = d
#define BCM56800_A0_E2E_HOL_STATUSm_GET(r,i) (r).e2e_hol_status[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_HOL_STATUSm_COS0_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[0])
#define BCM56800_A0_E2E_HOL_STATUSm_COS0_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[0]=((uint32_t)f)
#define BCM56800_A0_E2E_HOL_STATUSm_COS1_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[1])
#define BCM56800_A0_E2E_HOL_STATUSm_COS1_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[1]=((uint32_t)f)
#define BCM56800_A0_E2E_HOL_STATUSm_COS2_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[2])
#define BCM56800_A0_E2E_HOL_STATUSm_COS2_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[2]=((uint32_t)f)
#define BCM56800_A0_E2E_HOL_STATUSm_COS3_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[3])
#define BCM56800_A0_E2E_HOL_STATUSm_COS3_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[3]=((uint32_t)f)
#define BCM56800_A0_E2E_HOL_STATUSm_COS4_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[4])
#define BCM56800_A0_E2E_HOL_STATUSm_COS4_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[4]=((uint32_t)f)
#define BCM56800_A0_E2E_HOL_STATUSm_COS5_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[5])
#define BCM56800_A0_E2E_HOL_STATUSm_COS5_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[5]=((uint32_t)f)
#define BCM56800_A0_E2E_HOL_STATUSm_COS6_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[6])
#define BCM56800_A0_E2E_HOL_STATUSm_COS6_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[6]=((uint32_t)f)
#define BCM56800_A0_E2E_HOL_STATUSm_COS7_HOL_BITMAPf_GET(r) ((r).e2e_hol_status[7])
#define BCM56800_A0_E2E_HOL_STATUSm_COS7_HOL_BITMAPf_SET(r,f) (r).e2e_hol_status[7]=((uint32_t)f)

/*
 * These macros can be used to access E2E_HOL_STATUS.
 *
 */
#define BCM56800_A0_READ_E2E_HOL_STATUSm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_E2E_HOL_STATUSm,i,(m._e2e_hol_status),8)
#define BCM56800_A0_WRITE_E2E_HOL_STATUSm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_E2E_HOL_STATUSm,i,&(m._e2e_hol_status),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_HOL_STATUSm BCM56800_A0_E2E_HOL_STATUSm
#define E2E_HOL_STATUSm_MIN BCM56800_A0_E2E_HOL_STATUSm_MIN
#define E2E_HOL_STATUSm_MAX BCM56800_A0_E2E_HOL_STATUSm_MAX
#define E2E_HOL_STATUSm_CMAX(u) BCM56800_A0_E2E_HOL_STATUSm_CMAX(u)
#define E2E_HOL_STATUSm_SIZE BCM56800_A0_E2E_HOL_STATUSm_SIZE
typedef BCM56800_A0_E2E_HOL_STATUSm_t E2E_HOL_STATUSm_t;
#define E2E_HOL_STATUSm_CLR BCM56800_A0_E2E_HOL_STATUSm_CLR
#define E2E_HOL_STATUSm_SET BCM56800_A0_E2E_HOL_STATUSm_SET
#define E2E_HOL_STATUSm_GET BCM56800_A0_E2E_HOL_STATUSm_GET
#define E2E_HOL_STATUSm_COS0_HOL_BITMAPf_GET BCM56800_A0_E2E_HOL_STATUSm_COS0_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS0_HOL_BITMAPf_SET BCM56800_A0_E2E_HOL_STATUSm_COS0_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS1_HOL_BITMAPf_GET BCM56800_A0_E2E_HOL_STATUSm_COS1_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS1_HOL_BITMAPf_SET BCM56800_A0_E2E_HOL_STATUSm_COS1_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS2_HOL_BITMAPf_GET BCM56800_A0_E2E_HOL_STATUSm_COS2_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS2_HOL_BITMAPf_SET BCM56800_A0_E2E_HOL_STATUSm_COS2_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS3_HOL_BITMAPf_GET BCM56800_A0_E2E_HOL_STATUSm_COS3_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS3_HOL_BITMAPf_SET BCM56800_A0_E2E_HOL_STATUSm_COS3_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS4_HOL_BITMAPf_GET BCM56800_A0_E2E_HOL_STATUSm_COS4_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS4_HOL_BITMAPf_SET BCM56800_A0_E2E_HOL_STATUSm_COS4_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS5_HOL_BITMAPf_GET BCM56800_A0_E2E_HOL_STATUSm_COS5_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS5_HOL_BITMAPf_SET BCM56800_A0_E2E_HOL_STATUSm_COS5_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS6_HOL_BITMAPf_GET BCM56800_A0_E2E_HOL_STATUSm_COS6_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS6_HOL_BITMAPf_SET BCM56800_A0_E2E_HOL_STATUSm_COS6_HOL_BITMAPf_SET
#define E2E_HOL_STATUSm_COS7_HOL_BITMAPf_GET BCM56800_A0_E2E_HOL_STATUSm_COS7_HOL_BITMAPf_GET
#define E2E_HOL_STATUSm_COS7_HOL_BITMAPf_SET BCM56800_A0_E2E_HOL_STATUSm_COS7_HOL_BITMAPf_SET
#define READ_E2E_HOL_STATUSm BCM56800_A0_READ_E2E_HOL_STATUSm
#define WRITE_E2E_HOL_STATUSm BCM56800_A0_WRITE_E2E_HOL_STATUSm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_HOL_STATUSm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_IBP_RX_DA_LS
 * BLOCKS:   IPIPE
 * DESC:     End-to-End IBP LSB DA Register
 * SIZE:     32
 * FIELDS:
 *     DA               Least significant 16-bits of the DA for receive E2E IBP messages
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_IBP_RX_DA_LSr 0x02180605

#define BCM56800_A0_E2E_IBP_RX_DA_LSr_SIZE 4

/*
 * This structure should be used to declare and program E2E_IBP_RX_DA_LS.
 *
 */
typedef union BCM56800_A0_E2E_IBP_RX_DA_LSr_s {
	uint32_t v[1];
	uint32_t e2e_ibp_rx_da_ls[1];
	uint32_t _e2e_ibp_rx_da_ls;
} BCM56800_A0_E2E_IBP_RX_DA_LSr_t;

#define BCM56800_A0_E2E_IBP_RX_DA_LSr_CLR(r) (r).e2e_ibp_rx_da_ls[0] = 0
#define BCM56800_A0_E2E_IBP_RX_DA_LSr_SET(r,d) (r).e2e_ibp_rx_da_ls[0] = d
#define BCM56800_A0_E2E_IBP_RX_DA_LSr_GET(r) (r).e2e_ibp_rx_da_ls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_IBP_RX_DA_LSr_DAf_GET(r) ((r).e2e_ibp_rx_da_ls[0])
#define BCM56800_A0_E2E_IBP_RX_DA_LSr_DAf_SET(r,f) (r).e2e_ibp_rx_da_ls[0]=((uint32_t)f)

/*
 * These macros can be used to access E2E_IBP_RX_DA_LS.
 *
 */
#define BCM56800_A0_READ_E2E_IBP_RX_DA_LSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_IBP_RX_DA_LSr,(r._e2e_ibp_rx_da_ls))
#define BCM56800_A0_WRITE_E2E_IBP_RX_DA_LSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_IBP_RX_DA_LSr,&(r._e2e_ibp_rx_da_ls))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_IBP_RX_DA_LSr BCM56800_A0_E2E_IBP_RX_DA_LSr
#define E2E_IBP_RX_DA_LSr_SIZE BCM56800_A0_E2E_IBP_RX_DA_LSr_SIZE
typedef BCM56800_A0_E2E_IBP_RX_DA_LSr_t E2E_IBP_RX_DA_LSr_t;
#define E2E_IBP_RX_DA_LSr_CLR BCM56800_A0_E2E_IBP_RX_DA_LSr_CLR
#define E2E_IBP_RX_DA_LSr_SET BCM56800_A0_E2E_IBP_RX_DA_LSr_SET
#define E2E_IBP_RX_DA_LSr_GET BCM56800_A0_E2E_IBP_RX_DA_LSr_GET
#define E2E_IBP_RX_DA_LSr_DAf_GET BCM56800_A0_E2E_IBP_RX_DA_LSr_DAf_GET
#define E2E_IBP_RX_DA_LSr_DAf_SET BCM56800_A0_E2E_IBP_RX_DA_LSr_DAf_SET
#define READ_E2E_IBP_RX_DA_LSr BCM56800_A0_READ_E2E_IBP_RX_DA_LSr
#define WRITE_E2E_IBP_RX_DA_LSr BCM56800_A0_WRITE_E2E_IBP_RX_DA_LSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_IBP_RX_DA_LSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_IBP_RX_DA_MS
 * BLOCKS:   IPIPE
 * DESC:     End-to-End IBP MSB DA Register
 * SIZE:     32
 * FIELDS:
 *     DA               Most significant 16-bits of the DA for receive E2E IBP messages
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_IBP_RX_DA_MSr 0x02180604

#define BCM56800_A0_E2E_IBP_RX_DA_MSr_SIZE 4

/*
 * This structure should be used to declare and program E2E_IBP_RX_DA_MS.
 *
 */
typedef union BCM56800_A0_E2E_IBP_RX_DA_MSr_s {
	uint32_t v[1];
	uint32_t e2e_ibp_rx_da_ms[1];
	uint32_t _e2e_ibp_rx_da_ms;
} BCM56800_A0_E2E_IBP_RX_DA_MSr_t;

#define BCM56800_A0_E2E_IBP_RX_DA_MSr_CLR(r) (r).e2e_ibp_rx_da_ms[0] = 0
#define BCM56800_A0_E2E_IBP_RX_DA_MSr_SET(r,d) (r).e2e_ibp_rx_da_ms[0] = d
#define BCM56800_A0_E2E_IBP_RX_DA_MSr_GET(r) (r).e2e_ibp_rx_da_ms[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_IBP_RX_DA_MSr_DAf_GET(r) (((r).e2e_ibp_rx_da_ms[0]) & 0xffff)
#define BCM56800_A0_E2E_IBP_RX_DA_MSr_DAf_SET(r,f) (r).e2e_ibp_rx_da_ms[0]=(((r).e2e_ibp_rx_da_ms[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_IBP_RX_DA_MS.
 *
 */
#define BCM56800_A0_READ_E2E_IBP_RX_DA_MSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_IBP_RX_DA_MSr,(r._e2e_ibp_rx_da_ms))
#define BCM56800_A0_WRITE_E2E_IBP_RX_DA_MSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_IBP_RX_DA_MSr,&(r._e2e_ibp_rx_da_ms))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_IBP_RX_DA_MSr BCM56800_A0_E2E_IBP_RX_DA_MSr
#define E2E_IBP_RX_DA_MSr_SIZE BCM56800_A0_E2E_IBP_RX_DA_MSr_SIZE
typedef BCM56800_A0_E2E_IBP_RX_DA_MSr_t E2E_IBP_RX_DA_MSr_t;
#define E2E_IBP_RX_DA_MSr_CLR BCM56800_A0_E2E_IBP_RX_DA_MSr_CLR
#define E2E_IBP_RX_DA_MSr_SET BCM56800_A0_E2E_IBP_RX_DA_MSr_SET
#define E2E_IBP_RX_DA_MSr_GET BCM56800_A0_E2E_IBP_RX_DA_MSr_GET
#define E2E_IBP_RX_DA_MSr_DAf_GET BCM56800_A0_E2E_IBP_RX_DA_MSr_DAf_GET
#define E2E_IBP_RX_DA_MSr_DAf_SET BCM56800_A0_E2E_IBP_RX_DA_MSr_DAf_SET
#define READ_E2E_IBP_RX_DA_MSr BCM56800_A0_READ_E2E_IBP_RX_DA_MSr
#define WRITE_E2E_IBP_RX_DA_MSr BCM56800_A0_WRITE_E2E_IBP_RX_DA_MSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_IBP_RX_DA_MSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_IBP_RX_LENGTH_TYPE
 * BLOCKS:   IPIPE
 * DESC:     End-to-End IBP Length/Type Register
 * SIZE:     32
 * FIELDS:
 *     LENGTH_TYPE      Length/Type Field for receive E2E IBP messages
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr 0x02180606

#define BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program E2E_IBP_RX_LENGTH_TYPE.
 *
 */
typedef union BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_s {
	uint32_t v[1];
	uint32_t e2e_ibp_rx_length_type[1];
	uint32_t _e2e_ibp_rx_length_type;
} BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_t;

#define BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_CLR(r) (r).e2e_ibp_rx_length_type[0] = 0
#define BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_SET(r,d) (r).e2e_ibp_rx_length_type[0] = d
#define BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_GET(r) (r).e2e_ibp_rx_length_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET(r) (((r).e2e_ibp_rx_length_type[0]) & 0xffff)
#define BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET(r,f) (r).e2e_ibp_rx_length_type[0]=(((r).e2e_ibp_rx_length_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_IBP_RX_LENGTH_TYPE.
 *
 */
#define BCM56800_A0_READ_E2E_IBP_RX_LENGTH_TYPEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr,(r._e2e_ibp_rx_length_type))
#define BCM56800_A0_WRITE_E2E_IBP_RX_LENGTH_TYPEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr,&(r._e2e_ibp_rx_length_type))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_IBP_RX_LENGTH_TYPEr BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr
#define E2E_IBP_RX_LENGTH_TYPEr_SIZE BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_SIZE
typedef BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_t E2E_IBP_RX_LENGTH_TYPEr_t;
#define E2E_IBP_RX_LENGTH_TYPEr_CLR BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_CLR
#define E2E_IBP_RX_LENGTH_TYPEr_SET BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_SET
#define E2E_IBP_RX_LENGTH_TYPEr_GET BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_GET
#define E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET
#define E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET
#define READ_E2E_IBP_RX_LENGTH_TYPEr BCM56800_A0_READ_E2E_IBP_RX_LENGTH_TYPEr
#define WRITE_E2E_IBP_RX_LENGTH_TYPEr BCM56800_A0_WRITE_E2E_IBP_RX_LENGTH_TYPEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_IBP_RX_LENGTH_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_IBP_RX_OPCODE
 * BLOCKS:   IPIPE
 * DESC:     End-to-End IBP Opcode Register
 * SIZE:     32
 * FIELDS:
 *     OPCODE           Opcode Field for receive E2E IBP messages
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_IBP_RX_OPCODEr 0x02180607

#define BCM56800_A0_E2E_IBP_RX_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program E2E_IBP_RX_OPCODE.
 *
 */
typedef union BCM56800_A0_E2E_IBP_RX_OPCODEr_s {
	uint32_t v[1];
	uint32_t e2e_ibp_rx_opcode[1];
	uint32_t _e2e_ibp_rx_opcode;
} BCM56800_A0_E2E_IBP_RX_OPCODEr_t;

#define BCM56800_A0_E2E_IBP_RX_OPCODEr_CLR(r) (r).e2e_ibp_rx_opcode[0] = 0
#define BCM56800_A0_E2E_IBP_RX_OPCODEr_SET(r,d) (r).e2e_ibp_rx_opcode[0] = d
#define BCM56800_A0_E2E_IBP_RX_OPCODEr_GET(r) (r).e2e_ibp_rx_opcode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_IBP_RX_OPCODEr_OPCODEf_GET(r) (((r).e2e_ibp_rx_opcode[0]) & 0xffff)
#define BCM56800_A0_E2E_IBP_RX_OPCODEr_OPCODEf_SET(r,f) (r).e2e_ibp_rx_opcode[0]=(((r).e2e_ibp_rx_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access E2E_IBP_RX_OPCODE.
 *
 */
#define BCM56800_A0_READ_E2E_IBP_RX_OPCODEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_IBP_RX_OPCODEr,(r._e2e_ibp_rx_opcode))
#define BCM56800_A0_WRITE_E2E_IBP_RX_OPCODEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_IBP_RX_OPCODEr,&(r._e2e_ibp_rx_opcode))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_IBP_RX_OPCODEr BCM56800_A0_E2E_IBP_RX_OPCODEr
#define E2E_IBP_RX_OPCODEr_SIZE BCM56800_A0_E2E_IBP_RX_OPCODEr_SIZE
typedef BCM56800_A0_E2E_IBP_RX_OPCODEr_t E2E_IBP_RX_OPCODEr_t;
#define E2E_IBP_RX_OPCODEr_CLR BCM56800_A0_E2E_IBP_RX_OPCODEr_CLR
#define E2E_IBP_RX_OPCODEr_SET BCM56800_A0_E2E_IBP_RX_OPCODEr_SET
#define E2E_IBP_RX_OPCODEr_GET BCM56800_A0_E2E_IBP_RX_OPCODEr_GET
#define E2E_IBP_RX_OPCODEr_OPCODEf_GET BCM56800_A0_E2E_IBP_RX_OPCODEr_OPCODEf_GET
#define E2E_IBP_RX_OPCODEr_OPCODEf_SET BCM56800_A0_E2E_IBP_RX_OPCODEr_OPCODEf_SET
#define READ_E2E_IBP_RX_OPCODEr BCM56800_A0_READ_E2E_IBP_RX_OPCODEr
#define WRITE_E2E_IBP_RX_OPCODEr BCM56800_A0_WRITE_E2E_IBP_RX_OPCODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_IBP_RX_OPCODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_MAX_TX_TIMER
 * BLOCKS:   MMU
 * DESC:     E2E maximum force report timer code
 * SIZE:     32
 * FIELDS:
 *     CODE             E2E_MAX_TX_TIMER controls how long INTF waits (since the last report)before forcing to send another report if there's no status change. 0: Disable force report 1:  16 us 2:  32 us 3:  64 us 4: 128 us 5: 256 us 6: 512 us 7:   1 ms 8:   2 ms 9:   4 ms10:   8 ms11:  16 ms12:  32 ms13:  64 ms14: 128 ms15: 256 ms
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_MAX_TX_TIMERr 0x0bd80003

#define BCM56800_A0_E2E_MAX_TX_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program E2E_MAX_TX_TIMER.
 *
 */
typedef union BCM56800_A0_E2E_MAX_TX_TIMERr_s {
	uint32_t v[1];
	uint32_t e2e_max_tx_timer[1];
	uint32_t _e2e_max_tx_timer;
} BCM56800_A0_E2E_MAX_TX_TIMERr_t;

#define BCM56800_A0_E2E_MAX_TX_TIMERr_CLR(r) (r).e2e_max_tx_timer[0] = 0
#define BCM56800_A0_E2E_MAX_TX_TIMERr_SET(r,d) (r).e2e_max_tx_timer[0] = d
#define BCM56800_A0_E2E_MAX_TX_TIMERr_GET(r) (r).e2e_max_tx_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_MAX_TX_TIMERr_CODEf_GET(r) (((r).e2e_max_tx_timer[0]) & 0xf)
#define BCM56800_A0_E2E_MAX_TX_TIMERr_CODEf_SET(r,f) (r).e2e_max_tx_timer[0]=(((r).e2e_max_tx_timer[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access E2E_MAX_TX_TIMER.
 *
 */
#define BCM56800_A0_READ_E2E_MAX_TX_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_MAX_TX_TIMERr,(r._e2e_max_tx_timer))
#define BCM56800_A0_WRITE_E2E_MAX_TX_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_MAX_TX_TIMERr,&(r._e2e_max_tx_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_MAX_TX_TIMERr BCM56800_A0_E2E_MAX_TX_TIMERr
#define E2E_MAX_TX_TIMERr_SIZE BCM56800_A0_E2E_MAX_TX_TIMERr_SIZE
typedef BCM56800_A0_E2E_MAX_TX_TIMERr_t E2E_MAX_TX_TIMERr_t;
#define E2E_MAX_TX_TIMERr_CLR BCM56800_A0_E2E_MAX_TX_TIMERr_CLR
#define E2E_MAX_TX_TIMERr_SET BCM56800_A0_E2E_MAX_TX_TIMERr_SET
#define E2E_MAX_TX_TIMERr_GET BCM56800_A0_E2E_MAX_TX_TIMERr_GET
#define E2E_MAX_TX_TIMERr_CODEf_GET BCM56800_A0_E2E_MAX_TX_TIMERr_CODEf_GET
#define E2E_MAX_TX_TIMERr_CODEf_SET BCM56800_A0_E2E_MAX_TX_TIMERr_CODEf_SET
#define READ_E2E_MAX_TX_TIMERr BCM56800_A0_READ_E2E_MAX_TX_TIMERr
#define WRITE_E2E_MAX_TX_TIMERr BCM56800_A0_WRITE_E2E_MAX_TX_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_MAX_TX_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  E2E_MIN_TX_TIMER
 * BLOCKS:   MMU
 * DESC:     E2E minimum status change report timer code
 * SIZE:     32
 * FIELDS:
 *     CODE             E2E_MIN_TX_TIMER controls how long INTF waits (since the last report)before sending a new report even if there's a status change. 0: Illegal value 1:  16 us 2:  32 us 3:  64 us 4: 128 us 5: 256 us 6: 512 us 7:   1 ms 8:   2 ms 9:   4 ms10:   8 ms11:  16 ms12:  32 ms13:  64 ms14: 128 ms15: 256 ms
 *
 ******************************************************************************/
#define BCM56800_A0_E2E_MIN_TX_TIMERr 0x0bd80002

#define BCM56800_A0_E2E_MIN_TX_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program E2E_MIN_TX_TIMER.
 *
 */
typedef union BCM56800_A0_E2E_MIN_TX_TIMERr_s {
	uint32_t v[1];
	uint32_t e2e_min_tx_timer[1];
	uint32_t _e2e_min_tx_timer;
} BCM56800_A0_E2E_MIN_TX_TIMERr_t;

#define BCM56800_A0_E2E_MIN_TX_TIMERr_CLR(r) (r).e2e_min_tx_timer[0] = 0
#define BCM56800_A0_E2E_MIN_TX_TIMERr_SET(r,d) (r).e2e_min_tx_timer[0] = d
#define BCM56800_A0_E2E_MIN_TX_TIMERr_GET(r) (r).e2e_min_tx_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_E2E_MIN_TX_TIMERr_CODEf_GET(r) (((r).e2e_min_tx_timer[0]) & 0xf)
#define BCM56800_A0_E2E_MIN_TX_TIMERr_CODEf_SET(r,f) (r).e2e_min_tx_timer[0]=(((r).e2e_min_tx_timer[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access E2E_MIN_TX_TIMER.
 *
 */
#define BCM56800_A0_READ_E2E_MIN_TX_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_E2E_MIN_TX_TIMERr,(r._e2e_min_tx_timer))
#define BCM56800_A0_WRITE_E2E_MIN_TX_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_E2E_MIN_TX_TIMERr,&(r._e2e_min_tx_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define E2E_MIN_TX_TIMERr BCM56800_A0_E2E_MIN_TX_TIMERr
#define E2E_MIN_TX_TIMERr_SIZE BCM56800_A0_E2E_MIN_TX_TIMERr_SIZE
typedef BCM56800_A0_E2E_MIN_TX_TIMERr_t E2E_MIN_TX_TIMERr_t;
#define E2E_MIN_TX_TIMERr_CLR BCM56800_A0_E2E_MIN_TX_TIMERr_CLR
#define E2E_MIN_TX_TIMERr_SET BCM56800_A0_E2E_MIN_TX_TIMERr_SET
#define E2E_MIN_TX_TIMERr_GET BCM56800_A0_E2E_MIN_TX_TIMERr_GET
#define E2E_MIN_TX_TIMERr_CODEf_GET BCM56800_A0_E2E_MIN_TX_TIMERr_CODEf_GET
#define E2E_MIN_TX_TIMERr_CODEf_SET BCM56800_A0_E2E_MIN_TX_TIMERr_CODEf_SET
#define READ_E2E_MIN_TX_TIMERr BCM56800_A0_READ_E2E_MIN_TX_TIMERr
#define WRITE_E2E_MIN_TX_TIMERr BCM56800_A0_WRITE_E2E_MIN_TX_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_E2E_MIN_TX_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ECRC
 * BLOCKS:   MMU
 * DESC:     Egress cell request counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Egress cell request count:The maximum/minumum value for this register is 14/0 for XPORT portsand 2/0 for CMIC.  After reset is deasserted, Egress pipeturns on and requests all 14 cells right away.  The correspondingECRCs thus get incremented as well.
 *
 ******************************************************************************/
#define BCM56800_A0_ECRCr 0x0ed00031

#define BCM56800_A0_ECRCr_SIZE 4

/*
 * This structure should be used to declare and program ECRC.
 *
 */
typedef union BCM56800_A0_ECRCr_s {
	uint32_t v[1];
	uint32_t ecrc[1];
	uint32_t _ecrc;
} BCM56800_A0_ECRCr_t;

#define BCM56800_A0_ECRCr_CLR(r) (r).ecrc[0] = 0
#define BCM56800_A0_ECRCr_SET(r,d) (r).ecrc[0] = d
#define BCM56800_A0_ECRCr_GET(r) (r).ecrc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ECRCr_COUNTf_GET(r) (((r).ecrc[0]) & 0xf)
#define BCM56800_A0_ECRCr_COUNTf_SET(r,f) (r).ecrc[0]=(((r).ecrc[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ECRC.
 *
 */
#define BCM56800_A0_READ_ECRCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ECRCr,(r._ecrc))
#define BCM56800_A0_WRITE_ECRCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ECRCr,&(r._ecrc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ECRCr BCM56800_A0_ECRCr
#define ECRCr_SIZE BCM56800_A0_ECRCr_SIZE
typedef BCM56800_A0_ECRCr_t ECRCr_t;
#define ECRCr_CLR BCM56800_A0_ECRCr_CLR
#define ECRCr_SET BCM56800_A0_ECRCr_SET
#define ECRCr_GET BCM56800_A0_ECRCr_GET
#define ECRCr_COUNTf_GET BCM56800_A0_ECRCr_COUNTf_GET
#define ECRCr_COUNTf_SET BCM56800_A0_ECRCr_COUNTf_SET
#define READ_ECRCr BCM56800_A0_READ_ECRCr
#define WRITE_ECRCr BCM56800_A0_WRITE_ECRCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ECRCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGRMETERINGBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     BUCKET           Maximum rate bucket with unit is 0.5 bit.
 *     OUT_PROFILE_FLAG OUT_PROFILE_FLAG inidcates the current state of metering bucket1: out of profile0: In profileDefault value is in profile.
 *
 ******************************************************************************/
#define BCM56800_A0_EGRMETERINGBUCKETr 0x0ad00021

#define BCM56800_A0_EGRMETERINGBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGBUCKET.
 *
 */
typedef union BCM56800_A0_EGRMETERINGBUCKETr_s {
	uint32_t v[1];
	uint32_t egrmeteringbucket[1];
	uint32_t _egrmeteringbucket;
} BCM56800_A0_EGRMETERINGBUCKETr_t;

#define BCM56800_A0_EGRMETERINGBUCKETr_CLR(r) (r).egrmeteringbucket[0] = 0
#define BCM56800_A0_EGRMETERINGBUCKETr_SET(r,d) (r).egrmeteringbucket[0] = d
#define BCM56800_A0_EGRMETERINGBUCKETr_GET(r) (r).egrmeteringbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGRMETERINGBUCKETr_BUCKETf_GET(r) (((r).egrmeteringbucket[0]) & 0x1fffffff)
#define BCM56800_A0_EGRMETERINGBUCKETr_BUCKETf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56800_A0_EGRMETERINGBUCKETr_OUT_PROFILE_FLAGf_GET(r) ((((r).egrmeteringbucket[0]) >> 29) & 0x1)
#define BCM56800_A0_EGRMETERINGBUCKETr_OUT_PROFILE_FLAGf_SET(r,f) (r).egrmeteringbucket[0]=(((r).egrmeteringbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access EGRMETERINGBUCKET.
 *
 */
#define BCM56800_A0_READ_EGRMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGRMETERINGBUCKETr,(r._egrmeteringbucket))
#define BCM56800_A0_WRITE_EGRMETERINGBUCKETr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGRMETERINGBUCKETr,&(r._egrmeteringbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRMETERINGBUCKETr BCM56800_A0_EGRMETERINGBUCKETr
#define EGRMETERINGBUCKETr_SIZE BCM56800_A0_EGRMETERINGBUCKETr_SIZE
typedef BCM56800_A0_EGRMETERINGBUCKETr_t EGRMETERINGBUCKETr_t;
#define EGRMETERINGBUCKETr_CLR BCM56800_A0_EGRMETERINGBUCKETr_CLR
#define EGRMETERINGBUCKETr_SET BCM56800_A0_EGRMETERINGBUCKETr_SET
#define EGRMETERINGBUCKETr_GET BCM56800_A0_EGRMETERINGBUCKETr_GET
#define EGRMETERINGBUCKETr_BUCKETf_GET BCM56800_A0_EGRMETERINGBUCKETr_BUCKETf_GET
#define EGRMETERINGBUCKETr_BUCKETf_SET BCM56800_A0_EGRMETERINGBUCKETr_BUCKETf_SET
#define EGRMETERINGBUCKETr_OUT_PROFILE_FLAGf_GET BCM56800_A0_EGRMETERINGBUCKETr_OUT_PROFILE_FLAGf_GET
#define EGRMETERINGBUCKETr_OUT_PROFILE_FLAGf_SET BCM56800_A0_EGRMETERINGBUCKETr_OUT_PROFILE_FLAGf_SET
#define READ_EGRMETERINGBUCKETr BCM56800_A0_READ_EGRMETERINGBUCKETr
#define WRITE_EGRMETERINGBUCKETr BCM56800_A0_WRITE_EGRMETERINGBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGRMETERINGBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGRMETERINGCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     THD_SEL          Threshold for metering bucket. The setting of Threshold determines the size ofbucket and not related to rate. It also determines how burstness of traffic is.0x0: Disable, Egress Metering function is disabled.0x1:  32k bits, (32*1024),0x2:  64k bits, (64*1024),0x3: 128k bits, (128*1024),0x4: 256k bits, (256*1024),0x5: 512k bits, (512*1024),0x6:   1M bits, (1024*1024),0x7:   2M bits, (2*1024*1024),0x8:   4M bits, (4*1024*1024),0x9:   8M bits, (8*1024*1024),0xa:  16M bits, (16*1024*1024),0xb:  32M bits, (32*1024*1024),0xc:  64M bits, (64*1024*1024),0xd: 128M bits, (128*1024*1024),0xe: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,0xf: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,
 *     REFRESH          Refresh count for metering bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set REFRESH = 15624.
 *
 ******************************************************************************/
#define BCM56800_A0_EGRMETERINGCONFIGr 0x0ad00020

#define BCM56800_A0_EGRMETERINGCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGRMETERINGCONFIG.
 *
 */
typedef union BCM56800_A0_EGRMETERINGCONFIGr_s {
	uint32_t v[1];
	uint32_t egrmeteringconfig[1];
	uint32_t _egrmeteringconfig;
} BCM56800_A0_EGRMETERINGCONFIGr_t;

#define BCM56800_A0_EGRMETERINGCONFIGr_CLR(r) (r).egrmeteringconfig[0] = 0
#define BCM56800_A0_EGRMETERINGCONFIGr_SET(r,d) (r).egrmeteringconfig[0] = d
#define BCM56800_A0_EGRMETERINGCONFIGr_GET(r) (r).egrmeteringconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGRMETERINGCONFIGr_THD_SELf_GET(r) (((r).egrmeteringconfig[0]) & 0xf)
#define BCM56800_A0_EGRMETERINGCONFIGr_THD_SELf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_EGRMETERINGCONFIGr_REFRESHf_GET(r) ((((r).egrmeteringconfig[0]) >> 4) & 0x3ffff)
#define BCM56800_A0_EGRMETERINGCONFIGr_REFRESHf_SET(r,f) (r).egrmeteringconfig[0]=(((r).egrmeteringconfig[0] & ~((uint32_t)0x3ffff << 4)) | ((((uint32_t)f) & 0x3ffff) << 4))

/*
 * These macros can be used to access EGRMETERINGCONFIG.
 *
 */
#define BCM56800_A0_READ_EGRMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGRMETERINGCONFIGr,(r._egrmeteringconfig))
#define BCM56800_A0_WRITE_EGRMETERINGCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGRMETERINGCONFIGr,&(r._egrmeteringconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRMETERINGCONFIGr BCM56800_A0_EGRMETERINGCONFIGr
#define EGRMETERINGCONFIGr_SIZE BCM56800_A0_EGRMETERINGCONFIGr_SIZE
typedef BCM56800_A0_EGRMETERINGCONFIGr_t EGRMETERINGCONFIGr_t;
#define EGRMETERINGCONFIGr_CLR BCM56800_A0_EGRMETERINGCONFIGr_CLR
#define EGRMETERINGCONFIGr_SET BCM56800_A0_EGRMETERINGCONFIGr_SET
#define EGRMETERINGCONFIGr_GET BCM56800_A0_EGRMETERINGCONFIGr_GET
#define EGRMETERINGCONFIGr_THD_SELf_GET BCM56800_A0_EGRMETERINGCONFIGr_THD_SELf_GET
#define EGRMETERINGCONFIGr_THD_SELf_SET BCM56800_A0_EGRMETERINGCONFIGr_THD_SELf_SET
#define EGRMETERINGCONFIGr_REFRESHf_GET BCM56800_A0_EGRMETERINGCONFIGr_REFRESHf_GET
#define EGRMETERINGCONFIGr_REFRESHf_SET BCM56800_A0_EGRMETERINGCONFIGr_REFRESHf_SET
#define READ_EGRMETERINGCONFIGr BCM56800_A0_READ_EGRMETERINGCONFIGr
#define WRITE_EGRMETERINGCONFIGr BCM56800_A0_WRITE_EGRMETERINGCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGRMETERINGCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGRSHAPEPARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     MTRO Parity Error Pointer
 * SIZE:     32
 * FIELDS:
 *     PTR              The memory address at which the most recent MTRO parity error occurred.
 *     INSTANCE_NUM     The memory instance in which the most recent MTRO parity error occurred.If more than one memory instance has a parity error in a given cycle,the order of priority is: 0, then 1, then 2, and finally 3.
 *
 ******************************************************************************/
#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr 0x0ad80030

#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program EGRSHAPEPARITYERRORPTR.
 *
 */
typedef union BCM56800_A0_EGRSHAPEPARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t egrshapeparityerrorptr[1];
	uint32_t _egrshapeparityerrorptr;
} BCM56800_A0_EGRSHAPEPARITYERRORPTRr_t;

#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr_CLR(r) (r).egrshapeparityerrorptr[0] = 0
#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr_SET(r,d) (r).egrshapeparityerrorptr[0] = d
#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr_GET(r) (r).egrshapeparityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr_PTRf_GET(r) (((r).egrshapeparityerrorptr[0]) & 0x3f)
#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr_PTRf_SET(r,f) (r).egrshapeparityerrorptr[0]=(((r).egrshapeparityerrorptr[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr_INSTANCE_NUMf_GET(r) ((((r).egrshapeparityerrorptr[0]) >> 6) & 0x3)
#define BCM56800_A0_EGRSHAPEPARITYERRORPTRr_INSTANCE_NUMf_SET(r,f) (r).egrshapeparityerrorptr[0]=(((r).egrshapeparityerrorptr[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access EGRSHAPEPARITYERRORPTR.
 *
 */
#define BCM56800_A0_READ_EGRSHAPEPARITYERRORPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGRSHAPEPARITYERRORPTRr,(r._egrshapeparityerrorptr))
#define BCM56800_A0_WRITE_EGRSHAPEPARITYERRORPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGRSHAPEPARITYERRORPTRr,&(r._egrshapeparityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRSHAPEPARITYERRORPTRr BCM56800_A0_EGRSHAPEPARITYERRORPTRr
#define EGRSHAPEPARITYERRORPTRr_SIZE BCM56800_A0_EGRSHAPEPARITYERRORPTRr_SIZE
typedef BCM56800_A0_EGRSHAPEPARITYERRORPTRr_t EGRSHAPEPARITYERRORPTRr_t;
#define EGRSHAPEPARITYERRORPTRr_CLR BCM56800_A0_EGRSHAPEPARITYERRORPTRr_CLR
#define EGRSHAPEPARITYERRORPTRr_SET BCM56800_A0_EGRSHAPEPARITYERRORPTRr_SET
#define EGRSHAPEPARITYERRORPTRr_GET BCM56800_A0_EGRSHAPEPARITYERRORPTRr_GET
#define EGRSHAPEPARITYERRORPTRr_PTRf_GET BCM56800_A0_EGRSHAPEPARITYERRORPTRr_PTRf_GET
#define EGRSHAPEPARITYERRORPTRr_PTRf_SET BCM56800_A0_EGRSHAPEPARITYERRORPTRr_PTRf_SET
#define EGRSHAPEPARITYERRORPTRr_INSTANCE_NUMf_GET BCM56800_A0_EGRSHAPEPARITYERRORPTRr_INSTANCE_NUMf_GET
#define EGRSHAPEPARITYERRORPTRr_INSTANCE_NUMf_SET BCM56800_A0_EGRSHAPEPARITYERRORPTRr_INSTANCE_NUMf_SET
#define READ_EGRSHAPEPARITYERRORPTRr BCM56800_A0_READ_EGRSHAPEPARITYERRORPTRr
#define WRITE_EGRSHAPEPARITYERRORPTRr BCM56800_A0_WRITE_EGRSHAPEPARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGRSHAPEPARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_CONFIG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for the entire chip. 


 * SIZE:     32
 * FIELDS:
 *     DT_MODE          Double Tagging Mode is enabled or not.
 *     DRACO1_5_MIRROR  If set then Draco 1.5 style mirroring is enabled. Else Firebolt style of mirroring is enabled.
 *     CFI_AS_CNG       CFI-CNG mapping enabled. If this bit is set, Packet Modification stages will map the incoming CNG bits to CFI bits in the packet vlan tag. This bit is per chip.
 *     USE_LEARN_VID    Use the learn_vid for vid membership and stg state check.
 *     LEARN_VID        Vid to be used for vid membership and stg state check when USE_LEARN_VID is set.
 *     INNER_TPID       TPID to identify inner vlan tag of the packet when switch is operating in DT mode, i.e. DT_MODE bit is set.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_CONFIGr 0x01480600

#define BCM56800_A0_EGR_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG.
 *
 */
typedef union BCM56800_A0_EGR_CONFIGr_s {
	uint32_t v[1];
	uint32_t egr_config[1];
	uint32_t _egr_config;
} BCM56800_A0_EGR_CONFIGr_t;

#define BCM56800_A0_EGR_CONFIGr_CLR(r) (r).egr_config[0] = 0
#define BCM56800_A0_EGR_CONFIGr_SET(r,d) (r).egr_config[0] = d
#define BCM56800_A0_EGR_CONFIGr_GET(r) (r).egr_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_CONFIGr_DT_MODEf_GET(r) (((r).egr_config[0]) & 0x1)
#define BCM56800_A0_EGR_CONFIGr_DT_MODEf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_CONFIGr_DRACO1_5_MIRRORf_GET(r) ((((r).egr_config[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_CONFIGr_DRACO1_5_MIRRORf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_EGR_CONFIGr_CFI_AS_CNGf_GET(r) ((((r).egr_config[0]) >> 2) & 0x1)
#define BCM56800_A0_EGR_CONFIGr_CFI_AS_CNGf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_EGR_CONFIGr_USE_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 3) & 0x1)
#define BCM56800_A0_EGR_CONFIGr_USE_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_EGR_CONFIGr_LEARN_VIDf_GET(r) ((((r).egr_config[0]) >> 4) & 0xfff)
#define BCM56800_A0_EGR_CONFIGr_LEARN_VIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56800_A0_EGR_CONFIGr_INNER_TPIDf_GET(r) ((((r).egr_config[0]) >> 16) & 0xffff)
#define BCM56800_A0_EGR_CONFIGr_INNER_TPIDf_SET(r,f) (r).egr_config[0]=(((r).egr_config[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_CONFIG.
 *
 */
#define BCM56800_A0_READ_EGR_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_CONFIGr,(r._egr_config))
#define BCM56800_A0_WRITE_EGR_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_CONFIGr,&(r._egr_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_CONFIGr BCM56800_A0_EGR_CONFIGr
#define EGR_CONFIGr_SIZE BCM56800_A0_EGR_CONFIGr_SIZE
typedef BCM56800_A0_EGR_CONFIGr_t EGR_CONFIGr_t;
#define EGR_CONFIGr_CLR BCM56800_A0_EGR_CONFIGr_CLR
#define EGR_CONFIGr_SET BCM56800_A0_EGR_CONFIGr_SET
#define EGR_CONFIGr_GET BCM56800_A0_EGR_CONFIGr_GET
#define EGR_CONFIGr_DT_MODEf_GET BCM56800_A0_EGR_CONFIGr_DT_MODEf_GET
#define EGR_CONFIGr_DT_MODEf_SET BCM56800_A0_EGR_CONFIGr_DT_MODEf_SET
#define EGR_CONFIGr_DRACO1_5_MIRRORf_GET BCM56800_A0_EGR_CONFIGr_DRACO1_5_MIRRORf_GET
#define EGR_CONFIGr_DRACO1_5_MIRRORf_SET BCM56800_A0_EGR_CONFIGr_DRACO1_5_MIRRORf_SET
#define EGR_CONFIGr_CFI_AS_CNGf_GET BCM56800_A0_EGR_CONFIGr_CFI_AS_CNGf_GET
#define EGR_CONFIGr_CFI_AS_CNGf_SET BCM56800_A0_EGR_CONFIGr_CFI_AS_CNGf_SET
#define EGR_CONFIGr_USE_LEARN_VIDf_GET BCM56800_A0_EGR_CONFIGr_USE_LEARN_VIDf_GET
#define EGR_CONFIGr_USE_LEARN_VIDf_SET BCM56800_A0_EGR_CONFIGr_USE_LEARN_VIDf_SET
#define EGR_CONFIGr_LEARN_VIDf_GET BCM56800_A0_EGR_CONFIGr_LEARN_VIDf_GET
#define EGR_CONFIGr_LEARN_VIDf_SET BCM56800_A0_EGR_CONFIGr_LEARN_VIDf_SET
#define EGR_CONFIGr_INNER_TPIDf_GET BCM56800_A0_EGR_CONFIGr_INNER_TPIDf_GET
#define EGR_CONFIGr_INNER_TPIDf_SET BCM56800_A0_EGR_CONFIGr_INNER_TPIDf_SET
#define READ_EGR_CONFIGr BCM56800_A0_READ_EGR_CONFIGr
#define WRITE_EGR_CONFIGr BCM56800_A0_WRITE_EGR_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_CONFIG_1
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register Extension for the entire chip. 


 * SIZE:     32
 * FIELDS:
 *     RING_MODE        User should set it when FBs are cascaded in a ring fashion
 *     IPMC_ROUTE_SAME_VLAN When special processing is needed for IPMC replicated pkt which has same vlan as incoming packets vlan.
 *     FORCE_STATIC_MH_PFM Forces MH_PFM in the module header for pkts going to Higig Port.
 *     MH_PFM           PFM to be used to construct the Module Header.
 *     STACK_MODE       Enable to connect 5670/75's in ring topology.
 *     STRIP_PAD_EN     If set, then for L3 routed packets, padding will be stripped from the packet. Should not be set when ASF (cut-through mode) is enabled  
 *     IGNORE_HG_LAG_FAILOVER If set, then lag_failover action is not taken in EP
 *     IGNORE_HG_HDR_DONOT_LEARN If set, ignore the donot_learn (from ehcpm) bits for HG header
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_CONFIG_1r 0x01480601

#define BCM56800_A0_EGR_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_CONFIG_1.
 *
 */
typedef union BCM56800_A0_EGR_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t egr_config_1[1];
	uint32_t _egr_config_1;
} BCM56800_A0_EGR_CONFIG_1r_t;

#define BCM56800_A0_EGR_CONFIG_1r_CLR(r) (r).egr_config_1[0] = 0
#define BCM56800_A0_EGR_CONFIG_1r_SET(r,d) (r).egr_config_1[0] = d
#define BCM56800_A0_EGR_CONFIG_1r_GET(r) (r).egr_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_CONFIG_1r_RING_MODEf_GET(r) (((r).egr_config_1[0]) & 0x1)
#define BCM56800_A0_EGR_CONFIG_1r_RING_MODEf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET(r) ((((r).egr_config_1[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET(r) ((((r).egr_config_1[0]) >> 2) & 0x1)
#define BCM56800_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_EGR_CONFIG_1r_MH_PFMf_GET(r) ((((r).egr_config_1[0]) >> 3) & 0x3)
#define BCM56800_A0_EGR_CONFIG_1r_MH_PFMf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56800_A0_EGR_CONFIG_1r_STACK_MODEf_GET(r) ((((r).egr_config_1[0]) >> 5) & 0x3)
#define BCM56800_A0_EGR_CONFIG_1r_STACK_MODEf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56800_A0_EGR_CONFIG_1r_STRIP_PAD_ENf_GET(r) ((((r).egr_config_1[0]) >> 7) & 0x1)
#define BCM56800_A0_EGR_CONFIG_1r_STRIP_PAD_ENf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_EGR_CONFIG_1r_IGNORE_HG_LAG_FAILOVERf_GET(r) ((((r).egr_config_1[0]) >> 8) & 0x1)
#define BCM56800_A0_EGR_CONFIG_1r_IGNORE_HG_LAG_FAILOVERf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET(r) ((((r).egr_config_1[0]) >> 9) & 0x1)
#define BCM56800_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET(r,f) (r).egr_config_1[0]=(((r).egr_config_1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access EGR_CONFIG_1.
 *
 */
#define BCM56800_A0_READ_EGR_CONFIG_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_CONFIG_1r,(r._egr_config_1))
#define BCM56800_A0_WRITE_EGR_CONFIG_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_CONFIG_1r,&(r._egr_config_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_CONFIG_1r BCM56800_A0_EGR_CONFIG_1r
#define EGR_CONFIG_1r_SIZE BCM56800_A0_EGR_CONFIG_1r_SIZE
typedef BCM56800_A0_EGR_CONFIG_1r_t EGR_CONFIG_1r_t;
#define EGR_CONFIG_1r_CLR BCM56800_A0_EGR_CONFIG_1r_CLR
#define EGR_CONFIG_1r_SET BCM56800_A0_EGR_CONFIG_1r_SET
#define EGR_CONFIG_1r_GET BCM56800_A0_EGR_CONFIG_1r_GET
#define EGR_CONFIG_1r_RING_MODEf_GET BCM56800_A0_EGR_CONFIG_1r_RING_MODEf_GET
#define EGR_CONFIG_1r_RING_MODEf_SET BCM56800_A0_EGR_CONFIG_1r_RING_MODEf_SET
#define EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET BCM56800_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_GET
#define EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET BCM56800_A0_EGR_CONFIG_1r_IPMC_ROUTE_SAME_VLANf_SET
#define EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET BCM56800_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_GET
#define EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET BCM56800_A0_EGR_CONFIG_1r_FORCE_STATIC_MH_PFMf_SET
#define EGR_CONFIG_1r_MH_PFMf_GET BCM56800_A0_EGR_CONFIG_1r_MH_PFMf_GET
#define EGR_CONFIG_1r_MH_PFMf_SET BCM56800_A0_EGR_CONFIG_1r_MH_PFMf_SET
#define EGR_CONFIG_1r_STACK_MODEf_GET BCM56800_A0_EGR_CONFIG_1r_STACK_MODEf_GET
#define EGR_CONFIG_1r_STACK_MODEf_SET BCM56800_A0_EGR_CONFIG_1r_STACK_MODEf_SET
#define EGR_CONFIG_1r_STRIP_PAD_ENf_GET BCM56800_A0_EGR_CONFIG_1r_STRIP_PAD_ENf_GET
#define EGR_CONFIG_1r_STRIP_PAD_ENf_SET BCM56800_A0_EGR_CONFIG_1r_STRIP_PAD_ENf_SET
#define EGR_CONFIG_1r_IGNORE_HG_LAG_FAILOVERf_GET BCM56800_A0_EGR_CONFIG_1r_IGNORE_HG_LAG_FAILOVERf_GET
#define EGR_CONFIG_1r_IGNORE_HG_LAG_FAILOVERf_SET BCM56800_A0_EGR_CONFIG_1r_IGNORE_HG_LAG_FAILOVERf_SET
#define EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET BCM56800_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_GET
#define EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET BCM56800_A0_EGR_CONFIG_1r_IGNORE_HG_HDR_DONOT_LEARNf_SET
#define READ_EGR_CONFIG_1r BCM56800_A0_READ_EGR_CONFIG_1r
#define WRITE_EGR_CONFIG_1r BCM56800_A0_WRITE_EGR_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_DBG
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is same for GE, 10GE, Higig Ports.


 * SIZE:     32
 * FIELDS:
 *     RESURRECT        Enable the resurrect feature for purge, aged and cell_error packets.If this bit is set, the packets marked as Purge, Aged, Cell_error are not dropped in the chip.
 *     DISABLE_CRC_REGEN Disable CRC regeneration for GE ports only. In case of Higig or 10GE, theCRC regeration is config based in the mac.
 *     ALWAYS_CRC_REGEN Always regenrate the CRC for GE ports only. In case of Higig or 10GE, theCRC regeration is config based in the mac.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_DBGr 0x06400000

#define BCM56800_A0_EGR_DBGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_DBG.
 *
 */
typedef union BCM56800_A0_EGR_DBGr_s {
	uint32_t v[1];
	uint32_t egr_dbg[1];
	uint32_t _egr_dbg;
} BCM56800_A0_EGR_DBGr_t;

#define BCM56800_A0_EGR_DBGr_CLR(r) (r).egr_dbg[0] = 0
#define BCM56800_A0_EGR_DBGr_SET(r,d) (r).egr_dbg[0] = d
#define BCM56800_A0_EGR_DBGr_GET(r) (r).egr_dbg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_DBGr_RESURRECTf_GET(r) (((r).egr_dbg[0]) & 0x1)
#define BCM56800_A0_EGR_DBGr_RESURRECTf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_DBGr_DISABLE_CRC_REGENf_GET(r) ((((r).egr_dbg[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_DBGr_DISABLE_CRC_REGENf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_EGR_DBGr_ALWAYS_CRC_REGENf_GET(r) ((((r).egr_dbg[0]) >> 2) & 0x1)
#define BCM56800_A0_EGR_DBGr_ALWAYS_CRC_REGENf_SET(r,f) (r).egr_dbg[0]=(((r).egr_dbg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access EGR_DBG.
 *
 */
#define BCM56800_A0_READ_EGR_DBGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_DBGr,(r._egr_dbg))
#define BCM56800_A0_WRITE_EGR_DBGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_DBGr,&(r._egr_dbg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DBGr BCM56800_A0_EGR_DBGr
#define EGR_DBGr_SIZE BCM56800_A0_EGR_DBGr_SIZE
typedef BCM56800_A0_EGR_DBGr_t EGR_DBGr_t;
#define EGR_DBGr_CLR BCM56800_A0_EGR_DBGr_CLR
#define EGR_DBGr_SET BCM56800_A0_EGR_DBGr_SET
#define EGR_DBGr_GET BCM56800_A0_EGR_DBGr_GET
#define EGR_DBGr_RESURRECTf_GET BCM56800_A0_EGR_DBGr_RESURRECTf_GET
#define EGR_DBGr_RESURRECTf_SET BCM56800_A0_EGR_DBGr_RESURRECTf_SET
#define EGR_DBGr_DISABLE_CRC_REGENf_GET BCM56800_A0_EGR_DBGr_DISABLE_CRC_REGENf_GET
#define EGR_DBGr_DISABLE_CRC_REGENf_SET BCM56800_A0_EGR_DBGr_DISABLE_CRC_REGENf_SET
#define EGR_DBGr_ALWAYS_CRC_REGENf_GET BCM56800_A0_EGR_DBGr_ALWAYS_CRC_REGENf_GET
#define EGR_DBGr_ALWAYS_CRC_REGENf_SET BCM56800_A0_EGR_DBGr_ALWAYS_CRC_REGENf_SET
#define READ_EGR_DBGr BCM56800_A0_READ_EGR_DBGr
#define WRITE_EGR_DBGr BCM56800_A0_WRITE_EGR_DBGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_DBGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_DROP_VECTOR
 * BLOCKS:   EPIPE
 * DESC:     Sticky drop vector register. On a per block (X or Y) basis. If a packet is dropped on a block, then this register is updated with the reason.This is a sticky register, so once a bit is set, it'll stay set till the software clears it.

 * SIZE:     32
 * FIELDS:
 *     DROP_VECTOR      Sticky drop vector bits.  Individual bits (drop reasons) are defined  below DROP REASON       BIT POSITION===============================              VXLT_MISS_DROP    0 TUNNEL_SNAP_DROP  1 CFI_DROP          2 TTL_DROP          3 NOT_VLAN_MEMBER   4 STG_BLOCK_DROP    5 IPMC_L2_SELF_PORT 6 PURGE_PKT         7 AGED_PKT          8 BAD_TDIP          9 ESIP_LINK_LOCAL   10 VLAN_NOT_FOUND    11 STG_DISABLE_DROP  12 HIGIG2_RSVD_DROP  13 HIGIG_RSVD_HGI    14 L2_MTU_FAIL_DROP  15 PARITY_ERR_DROP   16 IP_LEN_FAIL_DROP  17 MODID_GRT_31_DROP 18
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_DROP_VECTORr 0x09480c03

#define BCM56800_A0_EGR_DROP_VECTORr_SIZE 4

/*
 * This structure should be used to declare and program EGR_DROP_VECTOR.
 *
 */
typedef union BCM56800_A0_EGR_DROP_VECTORr_s {
	uint32_t v[1];
	uint32_t egr_drop_vector[1];
	uint32_t _egr_drop_vector;
} BCM56800_A0_EGR_DROP_VECTORr_t;

#define BCM56800_A0_EGR_DROP_VECTORr_CLR(r) (r).egr_drop_vector[0] = 0
#define BCM56800_A0_EGR_DROP_VECTORr_SET(r,d) (r).egr_drop_vector[0] = d
#define BCM56800_A0_EGR_DROP_VECTORr_GET(r) (r).egr_drop_vector[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_DROP_VECTORr_DROP_VECTORf_GET(r) (((r).egr_drop_vector[0]) & 0x7ffff)
#define BCM56800_A0_EGR_DROP_VECTORr_DROP_VECTORf_SET(r,f) (r).egr_drop_vector[0]=(((r).egr_drop_vector[0] & ~((uint32_t)0x7ffff)) | (((uint32_t)f) & 0x7ffff))

/*
 * These macros can be used to access EGR_DROP_VECTOR.
 *
 */
#define BCM56800_A0_READ_EGR_DROP_VECTORr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_DROP_VECTORr,(r._egr_drop_vector))
#define BCM56800_A0_WRITE_EGR_DROP_VECTORr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_DROP_VECTORr,&(r._egr_drop_vector))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DROP_VECTORr BCM56800_A0_EGR_DROP_VECTORr
#define EGR_DROP_VECTORr_SIZE BCM56800_A0_EGR_DROP_VECTORr_SIZE
typedef BCM56800_A0_EGR_DROP_VECTORr_t EGR_DROP_VECTORr_t;
#define EGR_DROP_VECTORr_CLR BCM56800_A0_EGR_DROP_VECTORr_CLR
#define EGR_DROP_VECTORr_SET BCM56800_A0_EGR_DROP_VECTORr_SET
#define EGR_DROP_VECTORr_GET BCM56800_A0_EGR_DROP_VECTORr_GET
#define EGR_DROP_VECTORr_DROP_VECTORf_GET BCM56800_A0_EGR_DROP_VECTORr_DROP_VECTORf_GET
#define EGR_DROP_VECTORr_DROP_VECTORf_SET BCM56800_A0_EGR_DROP_VECTORr_DROP_VECTORf_SET
#define READ_EGR_DROP_VECTORr BCM56800_A0_READ_EGR_DROP_VECTORr
#define WRITE_EGR_DROP_VECTORr BCM56800_A0_WRITE_EGR_DROP_VECTORr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_DROP_VECTORr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_DROP_VECTOR_X
 * BLOCKS:   EPIPE
 * DESC:     Sticky drop vector register. On a per block (X or Y) basis. If a packet is dropped on a block, then this register is updated with the reason.This is a sticky register, so once a bit is set, it'll stay set till the software clears it.

 * SIZE:     32
 * FIELDS:
 *     DROP_VECTOR      Sticky drop vector bits.  Individual bits (drop reasons) are defined  below DROP REASON       BIT POSITION===============================              VXLT_MISS_DROP    0 TUNNEL_SNAP_DROP  1 CFI_DROP          2 TTL_DROP          3 NOT_VLAN_MEMBER   4 STG_BLOCK_DROP    5 IPMC_L2_SELF_PORT 6 PURGE_PKT         7 AGED_PKT          8 BAD_TDIP          9 ESIP_LINK_LOCAL   10 VLAN_NOT_FOUND    11 STG_DISABLE_DROP  12 HIGIG2_RSVD_DROP  13 HIGIG_RSVD_HGI    14 L2_MTU_FAIL_DROP  15 PARITY_ERR_DROP   16 IP_LEN_FAIL_DROP  17 MODID_GRT_31_DROP 18
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_DROP_VECTOR_Xr 0x09480203

#define BCM56800_A0_EGR_DROP_VECTOR_Xr_SIZE 4

/*
 * This structure should be used to declare and program EGR_DROP_VECTOR_X.
 *
 */
typedef union BCM56800_A0_EGR_DROP_VECTOR_Xr_s {
	uint32_t v[1];
	uint32_t egr_drop_vector_x[1];
	uint32_t _egr_drop_vector_x;
} BCM56800_A0_EGR_DROP_VECTOR_Xr_t;

#define BCM56800_A0_EGR_DROP_VECTOR_Xr_CLR(r) (r).egr_drop_vector_x[0] = 0
#define BCM56800_A0_EGR_DROP_VECTOR_Xr_SET(r,d) (r).egr_drop_vector_x[0] = d
#define BCM56800_A0_EGR_DROP_VECTOR_Xr_GET(r) (r).egr_drop_vector_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_DROP_VECTOR_Xr_DROP_VECTORf_GET(r) (((r).egr_drop_vector_x[0]) & 0x7ffff)
#define BCM56800_A0_EGR_DROP_VECTOR_Xr_DROP_VECTORf_SET(r,f) (r).egr_drop_vector_x[0]=(((r).egr_drop_vector_x[0] & ~((uint32_t)0x7ffff)) | (((uint32_t)f) & 0x7ffff))

/*
 * These macros can be used to access EGR_DROP_VECTOR_X.
 *
 */
#define BCM56800_A0_READ_EGR_DROP_VECTOR_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_DROP_VECTOR_Xr,(r._egr_drop_vector_x))
#define BCM56800_A0_WRITE_EGR_DROP_VECTOR_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_DROP_VECTOR_Xr,&(r._egr_drop_vector_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DROP_VECTOR_Xr BCM56800_A0_EGR_DROP_VECTOR_Xr
#define EGR_DROP_VECTOR_Xr_SIZE BCM56800_A0_EGR_DROP_VECTOR_Xr_SIZE
typedef BCM56800_A0_EGR_DROP_VECTOR_Xr_t EGR_DROP_VECTOR_Xr_t;
#define EGR_DROP_VECTOR_Xr_CLR BCM56800_A0_EGR_DROP_VECTOR_Xr_CLR
#define EGR_DROP_VECTOR_Xr_SET BCM56800_A0_EGR_DROP_VECTOR_Xr_SET
#define EGR_DROP_VECTOR_Xr_GET BCM56800_A0_EGR_DROP_VECTOR_Xr_GET
#define EGR_DROP_VECTOR_Xr_DROP_VECTORf_GET BCM56800_A0_EGR_DROP_VECTOR_Xr_DROP_VECTORf_GET
#define EGR_DROP_VECTOR_Xr_DROP_VECTORf_SET BCM56800_A0_EGR_DROP_VECTOR_Xr_DROP_VECTORf_SET
#define READ_EGR_DROP_VECTOR_Xr BCM56800_A0_READ_EGR_DROP_VECTOR_Xr
#define WRITE_EGR_DROP_VECTOR_Xr BCM56800_A0_WRITE_EGR_DROP_VECTOR_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_DROP_VECTOR_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_DROP_VECTOR_Y
 * BLOCKS:   EPIPE
 * DESC:     Sticky drop vector register. On a per block (X or Y) basis. If a packet is dropped on a block, then this register is updated with the reason.This is a sticky register, so once a bit is set, it'll stay set till the software clears it.

 * SIZE:     32
 * FIELDS:
 *     DROP_VECTOR      Sticky drop vector bits.  Individual bits (drop reasons) are defined  below DROP REASON       BIT POSITION===============================              VXLT_MISS_DROP    0 TUNNEL_SNAP_DROP  1 CFI_DROP          2 TTL_DROP          3 NOT_VLAN_MEMBER   4 STG_BLOCK_DROP    5 IPMC_L2_SELF_PORT 6 PURGE_PKT         7 AGED_PKT          8 BAD_TDIP          9 ESIP_LINK_LOCAL   10 VLAN_NOT_FOUND    11 STG_DISABLE_DROP  12 HIGIG2_RSVD_DROP  13 HIGIG_RSVD_HGI    14 L2_MTU_FAIL_DROP  15 PARITY_ERR_DROP   16 IP_LEN_FAIL_DROP  17 MODID_GRT_31_DROP 18
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_DROP_VECTOR_Yr 0x09480403

#define BCM56800_A0_EGR_DROP_VECTOR_Yr_SIZE 4

/*
 * This structure should be used to declare and program EGR_DROP_VECTOR_Y.
 *
 */
typedef union BCM56800_A0_EGR_DROP_VECTOR_Yr_s {
	uint32_t v[1];
	uint32_t egr_drop_vector_y[1];
	uint32_t _egr_drop_vector_y;
} BCM56800_A0_EGR_DROP_VECTOR_Yr_t;

#define BCM56800_A0_EGR_DROP_VECTOR_Yr_CLR(r) (r).egr_drop_vector_y[0] = 0
#define BCM56800_A0_EGR_DROP_VECTOR_Yr_SET(r,d) (r).egr_drop_vector_y[0] = d
#define BCM56800_A0_EGR_DROP_VECTOR_Yr_GET(r) (r).egr_drop_vector_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_DROP_VECTOR_Yr_DROP_VECTORf_GET(r) (((r).egr_drop_vector_y[0]) & 0x7ffff)
#define BCM56800_A0_EGR_DROP_VECTOR_Yr_DROP_VECTORf_SET(r,f) (r).egr_drop_vector_y[0]=(((r).egr_drop_vector_y[0] & ~((uint32_t)0x7ffff)) | (((uint32_t)f) & 0x7ffff))

/*
 * These macros can be used to access EGR_DROP_VECTOR_Y.
 *
 */
#define BCM56800_A0_READ_EGR_DROP_VECTOR_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_DROP_VECTOR_Yr,(r._egr_drop_vector_y))
#define BCM56800_A0_WRITE_EGR_DROP_VECTOR_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_DROP_VECTOR_Yr,&(r._egr_drop_vector_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DROP_VECTOR_Yr BCM56800_A0_EGR_DROP_VECTOR_Yr
#define EGR_DROP_VECTOR_Yr_SIZE BCM56800_A0_EGR_DROP_VECTOR_Yr_SIZE
typedef BCM56800_A0_EGR_DROP_VECTOR_Yr_t EGR_DROP_VECTOR_Yr_t;
#define EGR_DROP_VECTOR_Yr_CLR BCM56800_A0_EGR_DROP_VECTOR_Yr_CLR
#define EGR_DROP_VECTOR_Yr_SET BCM56800_A0_EGR_DROP_VECTOR_Yr_SET
#define EGR_DROP_VECTOR_Yr_GET BCM56800_A0_EGR_DROP_VECTOR_Yr_GET
#define EGR_DROP_VECTOR_Yr_DROP_VECTORf_GET BCM56800_A0_EGR_DROP_VECTOR_Yr_DROP_VECTORf_GET
#define EGR_DROP_VECTOR_Yr_DROP_VECTORf_SET BCM56800_A0_EGR_DROP_VECTOR_Yr_DROP_VECTORf_SET
#define READ_EGR_DROP_VECTOR_Yr BCM56800_A0_READ_EGR_DROP_VECTOR_Yr
#define WRITE_EGR_DROP_VECTOR_Yr BCM56800_A0_WRITE_EGR_DROP_VECTOR_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_DROP_VECTOR_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_DSCP_ECN_MAP
 * BLOCKS:   EPIPE
 * DESC:     Egress ECN Map Table to select the ECN interpretation mode based on DSCP.
 * SIZE:     1
 * FIELDS:
 *     ECN_MODE         Select for mode of interpreation of ECN bits, either based on RFC or Draft.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_DSCP_ECN_MAPm 0x0546b000

#define BCM56800_A0_EGR_DSCP_ECN_MAPm_MIN 0
#define BCM56800_A0_EGR_DSCP_ECN_MAPm_MAX 63
#define BCM56800_A0_EGR_DSCP_ECN_MAPm_CMAX(u) 63
#define BCM56800_A0_EGR_DSCP_ECN_MAPm_SIZE 1

/*
 * This structure should be used to declare and program EGR_DSCP_ECN_MAP.
 *
 */
typedef union BCM56800_A0_EGR_DSCP_ECN_MAPm_s {
	uint32_t v[1];
	uint32_t egr_dscp_ecn_map[1];
	uint32_t _egr_dscp_ecn_map;
} BCM56800_A0_EGR_DSCP_ECN_MAPm_t;

#define BCM56800_A0_EGR_DSCP_ECN_MAPm_CLR(r) (r).egr_dscp_ecn_map[0] = 0
#define BCM56800_A0_EGR_DSCP_ECN_MAPm_SET(r,d) (r).egr_dscp_ecn_map[0] = d
#define BCM56800_A0_EGR_DSCP_ECN_MAPm_GET(r) (r).egr_dscp_ecn_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_DSCP_ECN_MAPm_ECN_MODEf_GET(r) (((r).egr_dscp_ecn_map[0]) & 0x1)
#define BCM56800_A0_EGR_DSCP_ECN_MAPm_ECN_MODEf_SET(r,f) (r).egr_dscp_ecn_map[0]=(((r).egr_dscp_ecn_map[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_DSCP_ECN_MAP.
 *
 */
#define BCM56800_A0_READ_EGR_DSCP_ECN_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_DSCP_ECN_MAPm,i,(m._egr_dscp_ecn_map),1)
#define BCM56800_A0_WRITE_EGR_DSCP_ECN_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_DSCP_ECN_MAPm,i,&(m._egr_dscp_ecn_map),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DSCP_ECN_MAPm BCM56800_A0_EGR_DSCP_ECN_MAPm
#define EGR_DSCP_ECN_MAPm_MIN BCM56800_A0_EGR_DSCP_ECN_MAPm_MIN
#define EGR_DSCP_ECN_MAPm_MAX BCM56800_A0_EGR_DSCP_ECN_MAPm_MAX
#define EGR_DSCP_ECN_MAPm_CMAX(u) BCM56800_A0_EGR_DSCP_ECN_MAPm_CMAX(u)
#define EGR_DSCP_ECN_MAPm_SIZE BCM56800_A0_EGR_DSCP_ECN_MAPm_SIZE
typedef BCM56800_A0_EGR_DSCP_ECN_MAPm_t EGR_DSCP_ECN_MAPm_t;
#define EGR_DSCP_ECN_MAPm_CLR BCM56800_A0_EGR_DSCP_ECN_MAPm_CLR
#define EGR_DSCP_ECN_MAPm_SET BCM56800_A0_EGR_DSCP_ECN_MAPm_SET
#define EGR_DSCP_ECN_MAPm_GET BCM56800_A0_EGR_DSCP_ECN_MAPm_GET
#define EGR_DSCP_ECN_MAPm_ECN_MODEf_GET BCM56800_A0_EGR_DSCP_ECN_MAPm_ECN_MODEf_GET
#define EGR_DSCP_ECN_MAPm_ECN_MODEf_SET BCM56800_A0_EGR_DSCP_ECN_MAPm_ECN_MODEf_SET
#define READ_EGR_DSCP_ECN_MAPm BCM56800_A0_READ_EGR_DSCP_ECN_MAPm
#define WRITE_EGR_DSCP_ECN_MAPm BCM56800_A0_WRITE_EGR_DSCP_ECN_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_DSCP_ECN_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_DSCP_TABLE
 * BLOCKS:   EPIPE
 * DESC:     Egress DSCP Table to select the new dscp for outer tunnel header packets.
 * SIZE:     6
 * FIELDS:
 *     DSCP             New DSCP to be used for the outer tunnel header based on the incoming mmu priority and the DSCP_SEL field from the EGR_IP_TUNNEL table.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_DSCP_TABLEm 0x0546a000

#define BCM56800_A0_EGR_DSCP_TABLEm_MIN 0
#define BCM56800_A0_EGR_DSCP_TABLEm_MAX 31
#define BCM56800_A0_EGR_DSCP_TABLEm_CMAX(u) 31
#define BCM56800_A0_EGR_DSCP_TABLEm_SIZE 1

/*
 * This structure should be used to declare and program EGR_DSCP_TABLE.
 *
 */
typedef union BCM56800_A0_EGR_DSCP_TABLEm_s {
	uint32_t v[1];
	uint32_t egr_dscp_table[1];
	uint32_t _egr_dscp_table;
} BCM56800_A0_EGR_DSCP_TABLEm_t;

#define BCM56800_A0_EGR_DSCP_TABLEm_CLR(r) (r).egr_dscp_table[0] = 0
#define BCM56800_A0_EGR_DSCP_TABLEm_SET(r,d) (r).egr_dscp_table[0] = d
#define BCM56800_A0_EGR_DSCP_TABLEm_GET(r) (r).egr_dscp_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_DSCP_TABLEm_DSCPf_GET(r) (((r).egr_dscp_table[0]) & 0x3f)
#define BCM56800_A0_EGR_DSCP_TABLEm_DSCPf_SET(r,f) (r).egr_dscp_table[0]=(((r).egr_dscp_table[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access EGR_DSCP_TABLE.
 *
 */
#define BCM56800_A0_READ_EGR_DSCP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_DSCP_TABLEm,i,(m._egr_dscp_table),1)
#define BCM56800_A0_WRITE_EGR_DSCP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_DSCP_TABLEm,i,&(m._egr_dscp_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_DSCP_TABLEm BCM56800_A0_EGR_DSCP_TABLEm
#define EGR_DSCP_TABLEm_MIN BCM56800_A0_EGR_DSCP_TABLEm_MIN
#define EGR_DSCP_TABLEm_MAX BCM56800_A0_EGR_DSCP_TABLEm_MAX
#define EGR_DSCP_TABLEm_CMAX(u) BCM56800_A0_EGR_DSCP_TABLEm_CMAX(u)
#define EGR_DSCP_TABLEm_SIZE BCM56800_A0_EGR_DSCP_TABLEm_SIZE
typedef BCM56800_A0_EGR_DSCP_TABLEm_t EGR_DSCP_TABLEm_t;
#define EGR_DSCP_TABLEm_CLR BCM56800_A0_EGR_DSCP_TABLEm_CLR
#define EGR_DSCP_TABLEm_SET BCM56800_A0_EGR_DSCP_TABLEm_SET
#define EGR_DSCP_TABLEm_GET BCM56800_A0_EGR_DSCP_TABLEm_GET
#define EGR_DSCP_TABLEm_DSCPf_GET BCM56800_A0_EGR_DSCP_TABLEm_DSCPf_GET
#define EGR_DSCP_TABLEm_DSCPf_SET BCM56800_A0_EGR_DSCP_TABLEm_DSCPf_SET
#define READ_EGR_DSCP_TABLEm BCM56800_A0_READ_EGR_DSCP_TABLEm
#define WRITE_EGR_DSCP_TABLEm BCM56800_A0_WRITE_EGR_DSCP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_DSCP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_ECC_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     EGR_ECC_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables both ECC correction for cell data and 2 bit parity erro detection.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_ECC_CONTROLr 0x08480c06

#define BCM56800_A0_EGR_ECC_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_ECC_CONTROL.
 *
 */
typedef union BCM56800_A0_EGR_ECC_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_ecc_control[1];
	uint32_t _egr_ecc_control;
} BCM56800_A0_EGR_ECC_CONTROLr_t;

#define BCM56800_A0_EGR_ECC_CONTROLr_CLR(r) (r).egr_ecc_control[0] = 0
#define BCM56800_A0_EGR_ECC_CONTROLr_SET(r,d) (r).egr_ecc_control[0] = d
#define BCM56800_A0_EGR_ECC_CONTROLr_GET(r) (r).egr_ecc_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_ECC_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).egr_ecc_control[0]) & 0x1)
#define BCM56800_A0_EGR_ECC_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).egr_ecc_control[0]=(((r).egr_ecc_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_ECC_CONTROLr_PARITY_ENf_GET(r) ((((r).egr_ecc_control[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_ECC_CONTROLr_PARITY_ENf_SET(r,f) (r).egr_ecc_control[0]=(((r).egr_ecc_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_ECC_CONTROL.
 *
 */
#define BCM56800_A0_READ_EGR_ECC_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_ECC_CONTROLr,(r._egr_ecc_control))
#define BCM56800_A0_WRITE_EGR_ECC_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_ECC_CONTROLr,&(r._egr_ecc_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_ECC_CONTROLr BCM56800_A0_EGR_ECC_CONTROLr
#define EGR_ECC_CONTROLr_SIZE BCM56800_A0_EGR_ECC_CONTROLr_SIZE
typedef BCM56800_A0_EGR_ECC_CONTROLr_t EGR_ECC_CONTROLr_t;
#define EGR_ECC_CONTROLr_CLR BCM56800_A0_EGR_ECC_CONTROLr_CLR
#define EGR_ECC_CONTROLr_SET BCM56800_A0_EGR_ECC_CONTROLr_SET
#define EGR_ECC_CONTROLr_GET BCM56800_A0_EGR_ECC_CONTROLr_GET
#define EGR_ECC_CONTROLr_PARITY_IRQ_ENf_GET BCM56800_A0_EGR_ECC_CONTROLr_PARITY_IRQ_ENf_GET
#define EGR_ECC_CONTROLr_PARITY_IRQ_ENf_SET BCM56800_A0_EGR_ECC_CONTROLr_PARITY_IRQ_ENf_SET
#define EGR_ECC_CONTROLr_PARITY_ENf_GET BCM56800_A0_EGR_ECC_CONTROLr_PARITY_ENf_GET
#define EGR_ECC_CONTROLr_PARITY_ENf_SET BCM56800_A0_EGR_ECC_CONTROLr_PARITY_ENf_SET
#define READ_EGR_ECC_CONTROLr BCM56800_A0_READ_EGR_ECC_CONTROLr
#define WRITE_EGR_ECC_CONTROLr BCM56800_A0_WRITE_EGR_ECC_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_ECC_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_ECC_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_ECC_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that two bits parity error has been detected.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_ECC_STATUSr 0x08480c07

#define BCM56800_A0_EGR_ECC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_ECC_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_ECC_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_ecc_status[1];
	uint32_t _egr_ecc_status;
} BCM56800_A0_EGR_ECC_STATUSr_t;

#define BCM56800_A0_EGR_ECC_STATUSr_CLR(r) (r).egr_ecc_status[0] = 0
#define BCM56800_A0_EGR_ECC_STATUSr_SET(r,d) (r).egr_ecc_status[0] = d
#define BCM56800_A0_EGR_ECC_STATUSr_GET(r) (r).egr_ecc_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_ECC_STATUSr_PARITY_ERRf_GET(r) (((r).egr_ecc_status[0]) & 0x1)
#define BCM56800_A0_EGR_ECC_STATUSr_PARITY_ERRf_SET(r,f) (r).egr_ecc_status[0]=(((r).egr_ecc_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_ECC_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_ECC_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_ECC_STATUSr,(r._egr_ecc_status))
#define BCM56800_A0_WRITE_EGR_ECC_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_ECC_STATUSr,&(r._egr_ecc_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_ECC_STATUSr BCM56800_A0_EGR_ECC_STATUSr
#define EGR_ECC_STATUSr_SIZE BCM56800_A0_EGR_ECC_STATUSr_SIZE
typedef BCM56800_A0_EGR_ECC_STATUSr_t EGR_ECC_STATUSr_t;
#define EGR_ECC_STATUSr_CLR BCM56800_A0_EGR_ECC_STATUSr_CLR
#define EGR_ECC_STATUSr_SET BCM56800_A0_EGR_ECC_STATUSr_SET
#define EGR_ECC_STATUSr_GET BCM56800_A0_EGR_ECC_STATUSr_GET
#define EGR_ECC_STATUSr_PARITY_ERRf_GET BCM56800_A0_EGR_ECC_STATUSr_PARITY_ERRf_GET
#define EGR_ECC_STATUSr_PARITY_ERRf_SET BCM56800_A0_EGR_ECC_STATUSr_PARITY_ERRf_SET
#define READ_EGR_ECC_STATUSr BCM56800_A0_READ_EGR_ECC_STATUSr
#define WRITE_EGR_ECC_STATUSr BCM56800_A0_WRITE_EGR_ECC_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_ECC_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_EM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[5:4],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     12
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_EM_MTP_INDEXm 0x05469000

#define BCM56800_A0_EGR_EM_MTP_INDEXm_MIN 0
#define BCM56800_A0_EGR_EM_MTP_INDEXm_MAX 31
#define BCM56800_A0_EGR_EM_MTP_INDEXm_CMAX(u) 31
#define BCM56800_A0_EGR_EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EGR_EM_MTP_INDEX.
 *
 */
typedef union BCM56800_A0_EGR_EM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t egr_em_mtp_index[1];
	uint32_t _egr_em_mtp_index;
} BCM56800_A0_EGR_EM_MTP_INDEXm_t;

#define BCM56800_A0_EGR_EM_MTP_INDEXm_CLR(r) (r).egr_em_mtp_index[0] = 0
#define BCM56800_A0_EGR_EM_MTP_INDEXm_SET(r,d) (r).egr_em_mtp_index[0] = d
#define BCM56800_A0_EGR_EM_MTP_INDEXm_GET(r) (r).egr_em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_em_mtp_index[0]) & 0x7f)
#define BCM56800_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56800_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_em_mtp_index[0]) >> 7) & 0x1f)
#define BCM56800_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_em_mtp_index[0]=(((r).egr_em_mtp_index[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7))

/*
 * These macros can be used to access EGR_EM_MTP_INDEX.
 *
 */
#define BCM56800_A0_READ_EGR_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_EM_MTP_INDEXm,i,(m._egr_em_mtp_index),1)
#define BCM56800_A0_WRITE_EGR_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_EM_MTP_INDEXm,i,&(m._egr_em_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_EM_MTP_INDEXm BCM56800_A0_EGR_EM_MTP_INDEXm
#define EGR_EM_MTP_INDEXm_MIN BCM56800_A0_EGR_EM_MTP_INDEXm_MIN
#define EGR_EM_MTP_INDEXm_MAX BCM56800_A0_EGR_EM_MTP_INDEXm_MAX
#define EGR_EM_MTP_INDEXm_CMAX(u) BCM56800_A0_EGR_EM_MTP_INDEXm_CMAX(u)
#define EGR_EM_MTP_INDEXm_SIZE BCM56800_A0_EGR_EM_MTP_INDEXm_SIZE
typedef BCM56800_A0_EGR_EM_MTP_INDEXm_t EGR_EM_MTP_INDEXm_t;
#define EGR_EM_MTP_INDEXm_CLR BCM56800_A0_EGR_EM_MTP_INDEXm_CLR
#define EGR_EM_MTP_INDEXm_SET BCM56800_A0_EGR_EM_MTP_INDEXm_SET
#define EGR_EM_MTP_INDEXm_GET BCM56800_A0_EGR_EM_MTP_INDEXm_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET BCM56800_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET BCM56800_A0_EGR_EM_MTP_INDEXm_MTP_DST_MODIDf_SET
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET BCM56800_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_GET
#define EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET BCM56800_A0_EGR_EM_MTP_INDEXm_MTP_DST_PORTf_SET
#define READ_EGR_EM_MTP_INDEXm BCM56800_A0_READ_EGR_EM_MTP_INDEXm
#define WRITE_EGR_EM_MTP_INDEXm BCM56800_A0_WRITE_EGR_EM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_EM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_ENABLE
 * BLOCKS:   EPIPE
 * DESC:     Enables the Egress Port for transmission.

 * SIZE:     32
 * FIELDS:
 *     PRT_ENABLE       Port is enabled. If this bit is set, the requests to MMU will be made from this port to the MMU.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_ENABLEr 0x0a4000f1

#define BCM56800_A0_EGR_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program EGR_ENABLE.
 *
 */
typedef union BCM56800_A0_EGR_ENABLEr_s {
	uint32_t v[1];
	uint32_t egr_enable[1];
	uint32_t _egr_enable;
} BCM56800_A0_EGR_ENABLEr_t;

#define BCM56800_A0_EGR_ENABLEr_CLR(r) (r).egr_enable[0] = 0
#define BCM56800_A0_EGR_ENABLEr_SET(r,d) (r).egr_enable[0] = d
#define BCM56800_A0_EGR_ENABLEr_GET(r) (r).egr_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_ENABLEr_PRT_ENABLEf_GET(r) (((r).egr_enable[0]) & 0x1)
#define BCM56800_A0_EGR_ENABLEr_PRT_ENABLEf_SET(r,f) (r).egr_enable[0]=(((r).egr_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_ENABLE.
 *
 */
#define BCM56800_A0_READ_EGR_ENABLEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_ENABLEr,(r._egr_enable))
#define BCM56800_A0_WRITE_EGR_ENABLEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_ENABLEr,&(r._egr_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_ENABLEr BCM56800_A0_EGR_ENABLEr
#define EGR_ENABLEr_SIZE BCM56800_A0_EGR_ENABLEr_SIZE
typedef BCM56800_A0_EGR_ENABLEr_t EGR_ENABLEr_t;
#define EGR_ENABLEr_CLR BCM56800_A0_EGR_ENABLEr_CLR
#define EGR_ENABLEr_SET BCM56800_A0_EGR_ENABLEr_SET
#define EGR_ENABLEr_GET BCM56800_A0_EGR_ENABLEr_GET
#define EGR_ENABLEr_PRT_ENABLEf_GET BCM56800_A0_EGR_ENABLEr_PRT_ENABLEf_GET
#define EGR_ENABLEr_PRT_ENABLEf_SET BCM56800_A0_EGR_ENABLEr_PRT_ENABLEf_SET
#define READ_EGR_ENABLEr BCM56800_A0_READ_EGR_ENABLEr
#define WRITE_EGR_ENABLEr BCM56800_A0_WRITE_EGR_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_FUSE_REGS_ADDR
 * BLOCKS:   EPIPE
 * DESC:     EGR_FUSE_REGS_ADDR, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     MEM_SEL          select the memory be accessed,0: sel_ep1_cntrl_ep_vlan_member_LV = 1'b1;1: sel_ep1_cntrl_ep_next_hop_LV = 1'b1;2: sel_ep2_cntrl_ep_l3_intf_LV = 1'b1;
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_FUSE_REGS_ADDRr 0x05480c01

#define BCM56800_A0_EGR_FUSE_REGS_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program EGR_FUSE_REGS_ADDR.
 *
 */
typedef union BCM56800_A0_EGR_FUSE_REGS_ADDRr_s {
	uint32_t v[1];
	uint32_t egr_fuse_regs_addr[1];
	uint32_t _egr_fuse_regs_addr;
} BCM56800_A0_EGR_FUSE_REGS_ADDRr_t;

#define BCM56800_A0_EGR_FUSE_REGS_ADDRr_CLR(r) (r).egr_fuse_regs_addr[0] = 0
#define BCM56800_A0_EGR_FUSE_REGS_ADDRr_SET(r,d) (r).egr_fuse_regs_addr[0] = d
#define BCM56800_A0_EGR_FUSE_REGS_ADDRr_GET(r) (r).egr_fuse_regs_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_FUSE_REGS_ADDRr_MEM_SELf_GET(r) (((r).egr_fuse_regs_addr[0]) & 0x3)
#define BCM56800_A0_EGR_FUSE_REGS_ADDRr_MEM_SELf_SET(r,f) (r).egr_fuse_regs_addr[0]=(((r).egr_fuse_regs_addr[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access EGR_FUSE_REGS_ADDR.
 *
 */
#define BCM56800_A0_READ_EGR_FUSE_REGS_ADDRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_FUSE_REGS_ADDRr,(r._egr_fuse_regs_addr))
#define BCM56800_A0_WRITE_EGR_FUSE_REGS_ADDRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_FUSE_REGS_ADDRr,&(r._egr_fuse_regs_addr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_FUSE_REGS_ADDRr BCM56800_A0_EGR_FUSE_REGS_ADDRr
#define EGR_FUSE_REGS_ADDRr_SIZE BCM56800_A0_EGR_FUSE_REGS_ADDRr_SIZE
typedef BCM56800_A0_EGR_FUSE_REGS_ADDRr_t EGR_FUSE_REGS_ADDRr_t;
#define EGR_FUSE_REGS_ADDRr_CLR BCM56800_A0_EGR_FUSE_REGS_ADDRr_CLR
#define EGR_FUSE_REGS_ADDRr_SET BCM56800_A0_EGR_FUSE_REGS_ADDRr_SET
#define EGR_FUSE_REGS_ADDRr_GET BCM56800_A0_EGR_FUSE_REGS_ADDRr_GET
#define EGR_FUSE_REGS_ADDRr_MEM_SELf_GET BCM56800_A0_EGR_FUSE_REGS_ADDRr_MEM_SELf_GET
#define EGR_FUSE_REGS_ADDRr_MEM_SELf_SET BCM56800_A0_EGR_FUSE_REGS_ADDRr_MEM_SELf_SET
#define READ_EGR_FUSE_REGS_ADDRr BCM56800_A0_READ_EGR_FUSE_REGS_ADDRr
#define WRITE_EGR_FUSE_REGS_ADDRr BCM56800_A0_WRITE_EGR_FUSE_REGS_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_FUSE_REGS_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_FUSE_REGS_DATA
 * BLOCKS:   EPIPE
 * DESC:     EGR_FUSE_REGS_DATA, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S_RF             memory test s_rf value
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_FUSE_REGS_DATAr 0x05480c02

#define BCM56800_A0_EGR_FUSE_REGS_DATAr_SIZE 4

/*
 * This structure should be used to declare and program EGR_FUSE_REGS_DATA.
 *
 */
typedef union BCM56800_A0_EGR_FUSE_REGS_DATAr_s {
	uint32_t v[1];
	uint32_t egr_fuse_regs_data[1];
	uint32_t _egr_fuse_regs_data;
} BCM56800_A0_EGR_FUSE_REGS_DATAr_t;

#define BCM56800_A0_EGR_FUSE_REGS_DATAr_CLR(r) (r).egr_fuse_regs_data[0] = 0
#define BCM56800_A0_EGR_FUSE_REGS_DATAr_SET(r,d) (r).egr_fuse_regs_data[0] = d
#define BCM56800_A0_EGR_FUSE_REGS_DATAr_GET(r) (r).egr_fuse_regs_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_FUSE_REGS_DATAr_S_RFf_GET(r) ((r).egr_fuse_regs_data[0])
#define BCM56800_A0_EGR_FUSE_REGS_DATAr_S_RFf_SET(r,f) (r).egr_fuse_regs_data[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_FUSE_REGS_DATA.
 *
 */
#define BCM56800_A0_READ_EGR_FUSE_REGS_DATAr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_FUSE_REGS_DATAr,(r._egr_fuse_regs_data))
#define BCM56800_A0_WRITE_EGR_FUSE_REGS_DATAr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_FUSE_REGS_DATAr,&(r._egr_fuse_regs_data))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_FUSE_REGS_DATAr BCM56800_A0_EGR_FUSE_REGS_DATAr
#define EGR_FUSE_REGS_DATAr_SIZE BCM56800_A0_EGR_FUSE_REGS_DATAr_SIZE
typedef BCM56800_A0_EGR_FUSE_REGS_DATAr_t EGR_FUSE_REGS_DATAr_t;
#define EGR_FUSE_REGS_DATAr_CLR BCM56800_A0_EGR_FUSE_REGS_DATAr_CLR
#define EGR_FUSE_REGS_DATAr_SET BCM56800_A0_EGR_FUSE_REGS_DATAr_SET
#define EGR_FUSE_REGS_DATAr_GET BCM56800_A0_EGR_FUSE_REGS_DATAr_GET
#define EGR_FUSE_REGS_DATAr_S_RFf_GET BCM56800_A0_EGR_FUSE_REGS_DATAr_S_RFf_GET
#define EGR_FUSE_REGS_DATAr_S_RFf_SET BCM56800_A0_EGR_FUSE_REGS_DATAr_S_RFf_SET
#define READ_EGR_FUSE_REGS_DATAr BCM56800_A0_READ_EGR_FUSE_REGS_DATAr
#define WRITE_EGR_FUSE_REGS_DATAr BCM56800_A0_WRITE_EGR_FUSE_REGS_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_FUSE_REGS_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_HW_RESET_CONTROL_0
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.
This register should be programmed before programming EGR_HW_RESET_CONTROL_1 register.

 * SIZE:     32
 * FIELDS:
 *     STAGE_NUMBER     Stage Number where table to be reset is located. This is NOT used when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *     START_ADDRESS    20 bit starting address for the memory. HW starts incrementing from this address until EGR_HW_RESET_CONTROL_1.COUNT is completed.  START_ADDRESS is relevant even when EGR_HW_RESET_CONTROL_1.RESET_ALL bit is set.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r 0x00480600

#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_0.
 *
 */
typedef union BCM56800_A0_EGR_HW_RESET_CONTROL_0r_s {
	uint32_t v[1];
	uint32_t egr_hw_reset_control_0[1];
	uint32_t _egr_hw_reset_control_0;
} BCM56800_A0_EGR_HW_RESET_CONTROL_0r_t;

#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r_CLR(r) (r).egr_hw_reset_control_0[0] = 0
#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r_SET(r,d) (r).egr_hw_reset_control_0[0] = d
#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r_GET(r) (r).egr_hw_reset_control_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET(r) (((r).egr_hw_reset_control_0[0]) & 0x3f)
#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET(r) ((((r).egr_hw_reset_control_0[0]) >> 6) & 0xfffff)
#define BCM56800_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET(r,f) (r).egr_hw_reset_control_0[0]=(((r).egr_hw_reset_control_0[0] & ~((uint32_t)0xfffff << 6)) | ((((uint32_t)f) & 0xfffff) << 6))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_0.
 *
 */
#define BCM56800_A0_READ_EGR_HW_RESET_CONTROL_0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_HW_RESET_CONTROL_0r,(r._egr_hw_reset_control_0))
#define BCM56800_A0_WRITE_EGR_HW_RESET_CONTROL_0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_HW_RESET_CONTROL_0r,&(r._egr_hw_reset_control_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_HW_RESET_CONTROL_0r BCM56800_A0_EGR_HW_RESET_CONTROL_0r
#define EGR_HW_RESET_CONTROL_0r_SIZE BCM56800_A0_EGR_HW_RESET_CONTROL_0r_SIZE
typedef BCM56800_A0_EGR_HW_RESET_CONTROL_0r_t EGR_HW_RESET_CONTROL_0r_t;
#define EGR_HW_RESET_CONTROL_0r_CLR BCM56800_A0_EGR_HW_RESET_CONTROL_0r_CLR
#define EGR_HW_RESET_CONTROL_0r_SET BCM56800_A0_EGR_HW_RESET_CONTROL_0r_SET
#define EGR_HW_RESET_CONTROL_0r_GET BCM56800_A0_EGR_HW_RESET_CONTROL_0r_GET
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET BCM56800_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_GET
#define EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET BCM56800_A0_EGR_HW_RESET_CONTROL_0r_STAGE_NUMBERf_SET
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET BCM56800_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_GET
#define EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET BCM56800_A0_EGR_HW_RESET_CONTROL_0r_START_ADDRESSf_SET
#define READ_EGR_HW_RESET_CONTROL_0r BCM56800_A0_READ_EGR_HW_RESET_CONTROL_0r
#define WRITE_EGR_HW_RESET_CONTROL_0r BCM56800_A0_WRITE_EGR_HW_RESET_CONTROL_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_HW_RESET_CONTROL_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_HW_RESET_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     This register is for controlling the HW Table Initialization Feature of the Egress Pipeline.

 * SIZE:     32
 * FIELDS:
 *     COUNT            Count of entries which need to be resetted starting from EGR_HW_RESET_CONTROL_0.START_ADDRESS.
 *     RESET_ALL        If set, then ALL Tables in the Egress Pipeline will be resetted for COUNT entries. STAGE_NUMBER is ignored when this bit is set. 
 *     VALID            The HW table initialization will start after Logic sees this bit as set.
 *     DONE             After HW has issued memory reset commands equal to COUNT times, it will set DONE bit,SW can poll this bit from time to time and whenever it is set, SW should reset DONE and VALIDbits to 0. This will end the HW Reset Sequence of memories in the HW.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r 0x00480601

#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_HW_RESET_CONTROL_1.
 *
 */
typedef union BCM56800_A0_EGR_HW_RESET_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_hw_reset_control_1[1];
	uint32_t _egr_hw_reset_control_1;
} BCM56800_A0_EGR_HW_RESET_CONTROL_1r_t;

#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_CLR(r) (r).egr_hw_reset_control_1[0] = 0
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_SET(r,d) (r).egr_hw_reset_control_1[0] = d
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_GET(r) (r).egr_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_GET(r) (((r).egr_hw_reset_control_1[0]) & 0xffff)
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 16) & 0x1)
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 17) & 0x1)
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_DONEf_GET(r) ((((r).egr_hw_reset_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_EGR_HW_RESET_CONTROL_1r_DONEf_SET(r,f) (r).egr_hw_reset_control_1[0]=(((r).egr_hw_reset_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_HW_RESET_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_EGR_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_HW_RESET_CONTROL_1r,(r._egr_hw_reset_control_1))
#define BCM56800_A0_WRITE_EGR_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_HW_RESET_CONTROL_1r,&(r._egr_hw_reset_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_HW_RESET_CONTROL_1r BCM56800_A0_EGR_HW_RESET_CONTROL_1r
#define EGR_HW_RESET_CONTROL_1r_SIZE BCM56800_A0_EGR_HW_RESET_CONTROL_1r_SIZE
typedef BCM56800_A0_EGR_HW_RESET_CONTROL_1r_t EGR_HW_RESET_CONTROL_1r_t;
#define EGR_HW_RESET_CONTROL_1r_CLR BCM56800_A0_EGR_HW_RESET_CONTROL_1r_CLR
#define EGR_HW_RESET_CONTROL_1r_SET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_SET
#define EGR_HW_RESET_CONTROL_1r_GET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_GET
#define EGR_HW_RESET_CONTROL_1r_COUNTf_GET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_GET
#define EGR_HW_RESET_CONTROL_1r_COUNTf_SET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_COUNTf_SET
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_GET
#define EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_RESET_ALLf_SET
#define EGR_HW_RESET_CONTROL_1r_VALIDf_GET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_GET
#define EGR_HW_RESET_CONTROL_1r_VALIDf_SET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_VALIDf_SET
#define EGR_HW_RESET_CONTROL_1r_DONEf_GET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_DONEf_GET
#define EGR_HW_RESET_CONTROL_1r_DONEf_SET BCM56800_A0_EGR_HW_RESET_CONTROL_1r_DONEf_SET
#define READ_EGR_HW_RESET_CONTROL_1r BCM56800_A0_READ_EGR_HW_RESET_CONTROL_1r
#define WRITE_EGR_HW_RESET_CONTROL_1r BCM56800_A0_WRITE_EGR_HW_RESET_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_HW_RESET_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_IM_MTP_INDEX
 * BLOCKS:   EPIPE
 * DESC:     Mirror to Port Table to be used for IM tagged packets. 
Index is constructed using pbe.mtp_index[6:0] field.
We use {pbe.mtp_index[4:3],pbe.mtp_index[2:0]} as index into this table.

 * SIZE:     12
 * FIELDS:
 *     MTP_DST_MODID    DST_MODID field to be used in the module header in case of mirroring.
 *     MTP_DST_PORT     DST_PORT field to be used in module header in case of mirroring.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_IM_MTP_INDEXm 0x05468000

#define BCM56800_A0_EGR_IM_MTP_INDEXm_MIN 0
#define BCM56800_A0_EGR_IM_MTP_INDEXm_MAX 31
#define BCM56800_A0_EGR_IM_MTP_INDEXm_CMAX(u) 31
#define BCM56800_A0_EGR_IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EGR_IM_MTP_INDEX.
 *
 */
typedef union BCM56800_A0_EGR_IM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t egr_im_mtp_index[1];
	uint32_t _egr_im_mtp_index;
} BCM56800_A0_EGR_IM_MTP_INDEXm_t;

#define BCM56800_A0_EGR_IM_MTP_INDEXm_CLR(r) (r).egr_im_mtp_index[0] = 0
#define BCM56800_A0_EGR_IM_MTP_INDEXm_SET(r,d) (r).egr_im_mtp_index[0] = d
#define BCM56800_A0_EGR_IM_MTP_INDEXm_GET(r) (r).egr_im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET(r) (((r).egr_im_mtp_index[0]) & 0x7f)
#define BCM56800_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56800_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET(r) ((((r).egr_im_mtp_index[0]) >> 7) & 0x1f)
#define BCM56800_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET(r,f) (r).egr_im_mtp_index[0]=(((r).egr_im_mtp_index[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7))

/*
 * These macros can be used to access EGR_IM_MTP_INDEX.
 *
 */
#define BCM56800_A0_READ_EGR_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_IM_MTP_INDEXm,i,(m._egr_im_mtp_index),1)
#define BCM56800_A0_WRITE_EGR_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_IM_MTP_INDEXm,i,&(m._egr_im_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_IM_MTP_INDEXm BCM56800_A0_EGR_IM_MTP_INDEXm
#define EGR_IM_MTP_INDEXm_MIN BCM56800_A0_EGR_IM_MTP_INDEXm_MIN
#define EGR_IM_MTP_INDEXm_MAX BCM56800_A0_EGR_IM_MTP_INDEXm_MAX
#define EGR_IM_MTP_INDEXm_CMAX(u) BCM56800_A0_EGR_IM_MTP_INDEXm_CMAX(u)
#define EGR_IM_MTP_INDEXm_SIZE BCM56800_A0_EGR_IM_MTP_INDEXm_SIZE
typedef BCM56800_A0_EGR_IM_MTP_INDEXm_t EGR_IM_MTP_INDEXm_t;
#define EGR_IM_MTP_INDEXm_CLR BCM56800_A0_EGR_IM_MTP_INDEXm_CLR
#define EGR_IM_MTP_INDEXm_SET BCM56800_A0_EGR_IM_MTP_INDEXm_SET
#define EGR_IM_MTP_INDEXm_GET BCM56800_A0_EGR_IM_MTP_INDEXm_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET BCM56800_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET BCM56800_A0_EGR_IM_MTP_INDEXm_MTP_DST_MODIDf_SET
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET BCM56800_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_GET
#define EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET BCM56800_A0_EGR_IM_MTP_INDEXm_MTP_DST_PORTf_SET
#define READ_EGR_IM_MTP_INDEXm BCM56800_A0_READ_EGR_IM_MTP_INDEXm
#define WRITE_EGR_IM_MTP_INDEXm BCM56800_A0_WRITE_EGR_IM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_IM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_IPMC_CFG2
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for IPMC related modifications. FeatureSpecific-Ethernet


 * SIZE:     32
 * FIELDS:
 *     DISABLE_TTL_DECREMENT Disable the TTL decrement in case of IPMC L3 routed packet.
 *     DISABLE_SA_REPLACE Disable the SA Replacement in case of IPMC L3 routed packet. 
 *     UNTAG            Untag the pkt in case of IPMC L3 routing. 
 *     VID              VID to be used for IPMC L3 packet untagging. For an IPMC L3 Routed packet, If UNTAG bit is set and the packet vid matches the VID field, the vlan tag is removed from the packet.For this function packet vid is selected on following basis.	For L3 packets 		- Vid from the interface table.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_IPMC_CFG2r 0x06400001

#define BCM56800_A0_EGR_IPMC_CFG2r_SIZE 4

/*
 * This structure should be used to declare and program EGR_IPMC_CFG2.
 *
 */
typedef union BCM56800_A0_EGR_IPMC_CFG2r_s {
	uint32_t v[1];
	uint32_t egr_ipmc_cfg2[1];
	uint32_t _egr_ipmc_cfg2;
} BCM56800_A0_EGR_IPMC_CFG2r_t;

#define BCM56800_A0_EGR_IPMC_CFG2r_CLR(r) (r).egr_ipmc_cfg2[0] = 0
#define BCM56800_A0_EGR_IPMC_CFG2r_SET(r,d) (r).egr_ipmc_cfg2[0] = d
#define BCM56800_A0_EGR_IPMC_CFG2r_GET(r) (r).egr_ipmc_cfg2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_GET(r) (((r).egr_ipmc_cfg2[0]) & 0x1)
#define BCM56800_A0_EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_SET(r,f) (r).egr_ipmc_cfg2[0]=(((r).egr_ipmc_cfg2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_GET(r) ((((r).egr_ipmc_cfg2[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_SET(r,f) (r).egr_ipmc_cfg2[0]=(((r).egr_ipmc_cfg2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_EGR_IPMC_CFG2r_UNTAGf_GET(r) ((((r).egr_ipmc_cfg2[0]) >> 2) & 0x1)
#define BCM56800_A0_EGR_IPMC_CFG2r_UNTAGf_SET(r,f) (r).egr_ipmc_cfg2[0]=(((r).egr_ipmc_cfg2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_EGR_IPMC_CFG2r_VIDf_GET(r) ((((r).egr_ipmc_cfg2[0]) >> 3) & 0xfff)
#define BCM56800_A0_EGR_IPMC_CFG2r_VIDf_SET(r,f) (r).egr_ipmc_cfg2[0]=(((r).egr_ipmc_cfg2[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access EGR_IPMC_CFG2.
 *
 */
#define BCM56800_A0_READ_EGR_IPMC_CFG2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_IPMC_CFG2r,(r._egr_ipmc_cfg2))
#define BCM56800_A0_WRITE_EGR_IPMC_CFG2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_IPMC_CFG2r,&(r._egr_ipmc_cfg2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_IPMC_CFG2r BCM56800_A0_EGR_IPMC_CFG2r
#define EGR_IPMC_CFG2r_SIZE BCM56800_A0_EGR_IPMC_CFG2r_SIZE
typedef BCM56800_A0_EGR_IPMC_CFG2r_t EGR_IPMC_CFG2r_t;
#define EGR_IPMC_CFG2r_CLR BCM56800_A0_EGR_IPMC_CFG2r_CLR
#define EGR_IPMC_CFG2r_SET BCM56800_A0_EGR_IPMC_CFG2r_SET
#define EGR_IPMC_CFG2r_GET BCM56800_A0_EGR_IPMC_CFG2r_GET
#define EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_GET BCM56800_A0_EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_GET
#define EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_SET BCM56800_A0_EGR_IPMC_CFG2r_DISABLE_TTL_DECREMENTf_SET
#define EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_GET BCM56800_A0_EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_GET
#define EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_SET BCM56800_A0_EGR_IPMC_CFG2r_DISABLE_SA_REPLACEf_SET
#define EGR_IPMC_CFG2r_UNTAGf_GET BCM56800_A0_EGR_IPMC_CFG2r_UNTAGf_GET
#define EGR_IPMC_CFG2r_UNTAGf_SET BCM56800_A0_EGR_IPMC_CFG2r_UNTAGf_SET
#define EGR_IPMC_CFG2r_VIDf_GET BCM56800_A0_EGR_IPMC_CFG2r_VIDf_GET
#define EGR_IPMC_CFG2r_VIDf_SET BCM56800_A0_EGR_IPMC_CFG2r_VIDf_SET
#define READ_EGR_IPMC_CFG2r BCM56800_A0_READ_EGR_IPMC_CFG2r
#define WRITE_EGR_IPMC_CFG2r BCM56800_A0_WRITE_EGR_IPMC_CFG2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_IPMC_CFG2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_IP_TUNNEL
 * BLOCKS:   EPIPE
 * DESC:     Egress IP Tunnel Table. Used to Make new Tunnel Header. FeatureSpecific-Ethernet
 * SIZE:     134
 * FIELDS:
 *     DEST_ADDR        MAC DA to be used to change the pkt mac da in case of IP Tunneling.
 *     TTL              TTL to be used in the IP Tunnel Header.
 *     SIP              Source IP Address to be used in the IP Tunnel Header.
 *     DIP              Destination IP Address to be used in the IP Tunnel Header.
 *     TUNNEL_TYPE      Specifies which Tunnel Protocol is Supported by this entry.
 *     DSCP             Specifies what should be the new DSCP to be put int he tunnel header.
 *     DSCP_SEL         Specifies which dscp to choose to put in the outer tunnel header.               DSCP_SEL                Defines selection of DSCP               00 - Pick up from Tunnel Table               01 - Pick up from Packet (PICK_FROM_PACKET)               10 - Pick up from DSCP table (PICK_FROM_DSCP_TABLE)               11 - Reserved
 *     IPV4_DF_SEL      Specifies how to construct DF field if tunnel initiation is done for a v4 packet.		00 - Set DF to 0		01 - Set DF to 1		10 - Copy Inner IP Header DF field to tunnel header		11 - Copy Inner IP Header DF field to tunnel header
 *     IPV6_DF_SEL      Specifies how to construct DF field if tunnel initiation is done for a v6 packet.		0 - Set DF to 0		1 - Set DF to 1
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_IP_TUNNELm 0x05467000

#define BCM56800_A0_EGR_IP_TUNNELm_MIN 0
#define BCM56800_A0_EGR_IP_TUNNELm_MAX 127
#define BCM56800_A0_EGR_IP_TUNNELm_CMAX(u) 127
#define BCM56800_A0_EGR_IP_TUNNELm_SIZE 17

/*
 * This structure should be used to declare and program EGR_IP_TUNNEL.
 *
 */
typedef union BCM56800_A0_EGR_IP_TUNNELm_s {
	uint32_t v[5];
	uint32_t egr_ip_tunnel[5];
	uint32_t _egr_ip_tunnel;
} BCM56800_A0_EGR_IP_TUNNELm_t;

#define BCM56800_A0_EGR_IP_TUNNELm_CLR(r) CDK_MEMSET(&((r)._egr_ip_tunnel), 0, sizeof(BCM56800_A0_EGR_IP_TUNNELm_t))
#define BCM56800_A0_EGR_IP_TUNNELm_SET(r,i,d) (r).egr_ip_tunnel[i] = d
#define BCM56800_A0_EGR_IP_TUNNELm_GET(r,i) (r).egr_ip_tunnel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_IP_TUNNELm_DEST_ADDRf_GET(r,a) cdk_field_get((r).egr_ip_tunnel,0,47,a)
#define BCM56800_A0_EGR_IP_TUNNELm_DEST_ADDRf_SET(r,a) cdk_field_set((r).egr_ip_tunnel,0,47,a)
#define BCM56800_A0_EGR_IP_TUNNELm_TTLf_GET(r) ((((r).egr_ip_tunnel[1]) >> 16) & 0xff)
#define BCM56800_A0_EGR_IP_TUNNELm_TTLf_SET(r,f) (r).egr_ip_tunnel[1]=(((r).egr_ip_tunnel[1] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_EGR_IP_TUNNELm_SIPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,56,87)
#define BCM56800_A0_EGR_IP_TUNNELm_SIPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,56,87,f)
#define BCM56800_A0_EGR_IP_TUNNELm_DIPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,88,119)
#define BCM56800_A0_EGR_IP_TUNNELm_DIPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,88,119,f)
#define BCM56800_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_GET(r) ((((r).egr_ip_tunnel[3]) >> 24) & 0x7)
#define BCM56800_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_SET(r,f) (r).egr_ip_tunnel[3]=(((r).egr_ip_tunnel[3] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56800_A0_EGR_IP_TUNNELm_DSCPf_GET(r) cdk_field32_get((r).egr_ip_tunnel,123,128)
#define BCM56800_A0_EGR_IP_TUNNELm_DSCPf_SET(r,f) cdk_field32_set((r).egr_ip_tunnel,123,128,f)
#define BCM56800_A0_EGR_IP_TUNNELm_DSCP_SELf_GET(r) ((((r).egr_ip_tunnel[4]) >> 1) & 0x3)
#define BCM56800_A0_EGR_IP_TUNNELm_DSCP_SELf_SET(r,f) (r).egr_ip_tunnel[4]=(((r).egr_ip_tunnel[4] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56800_A0_EGR_IP_TUNNELm_IPV4_DF_SELf_GET(r) ((((r).egr_ip_tunnel[4]) >> 3) & 0x3)
#define BCM56800_A0_EGR_IP_TUNNELm_IPV4_DF_SELf_SET(r,f) (r).egr_ip_tunnel[4]=(((r).egr_ip_tunnel[4] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56800_A0_EGR_IP_TUNNELm_IPV6_DF_SELf_GET(r) ((((r).egr_ip_tunnel[4]) >> 5) & 0x1)
#define BCM56800_A0_EGR_IP_TUNNELm_IPV6_DF_SELf_SET(r,f) (r).egr_ip_tunnel[4]=(((r).egr_ip_tunnel[4] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access EGR_IP_TUNNEL.
 *
 */
#define BCM56800_A0_READ_EGR_IP_TUNNELm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_IP_TUNNELm,i,(m._egr_ip_tunnel),5)
#define BCM56800_A0_WRITE_EGR_IP_TUNNELm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_IP_TUNNELm,i,&(m._egr_ip_tunnel),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_IP_TUNNELm BCM56800_A0_EGR_IP_TUNNELm
#define EGR_IP_TUNNELm_MIN BCM56800_A0_EGR_IP_TUNNELm_MIN
#define EGR_IP_TUNNELm_MAX BCM56800_A0_EGR_IP_TUNNELm_MAX
#define EGR_IP_TUNNELm_CMAX(u) BCM56800_A0_EGR_IP_TUNNELm_CMAX(u)
#define EGR_IP_TUNNELm_SIZE BCM56800_A0_EGR_IP_TUNNELm_SIZE
typedef BCM56800_A0_EGR_IP_TUNNELm_t EGR_IP_TUNNELm_t;
#define EGR_IP_TUNNELm_CLR BCM56800_A0_EGR_IP_TUNNELm_CLR
#define EGR_IP_TUNNELm_SET BCM56800_A0_EGR_IP_TUNNELm_SET
#define EGR_IP_TUNNELm_GET BCM56800_A0_EGR_IP_TUNNELm_GET
#define EGR_IP_TUNNELm_DEST_ADDRf_GET BCM56800_A0_EGR_IP_TUNNELm_DEST_ADDRf_GET
#define EGR_IP_TUNNELm_DEST_ADDRf_SET BCM56800_A0_EGR_IP_TUNNELm_DEST_ADDRf_SET
#define EGR_IP_TUNNELm_TTLf_GET BCM56800_A0_EGR_IP_TUNNELm_TTLf_GET
#define EGR_IP_TUNNELm_TTLf_SET BCM56800_A0_EGR_IP_TUNNELm_TTLf_SET
#define EGR_IP_TUNNELm_SIPf_GET BCM56800_A0_EGR_IP_TUNNELm_SIPf_GET
#define EGR_IP_TUNNELm_SIPf_SET BCM56800_A0_EGR_IP_TUNNELm_SIPf_SET
#define EGR_IP_TUNNELm_DIPf_GET BCM56800_A0_EGR_IP_TUNNELm_DIPf_GET
#define EGR_IP_TUNNELm_DIPf_SET BCM56800_A0_EGR_IP_TUNNELm_DIPf_SET
#define EGR_IP_TUNNELm_TUNNEL_TYPEf_GET BCM56800_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_GET
#define EGR_IP_TUNNELm_TUNNEL_TYPEf_SET BCM56800_A0_EGR_IP_TUNNELm_TUNNEL_TYPEf_SET
#define EGR_IP_TUNNELm_DSCPf_GET BCM56800_A0_EGR_IP_TUNNELm_DSCPf_GET
#define EGR_IP_TUNNELm_DSCPf_SET BCM56800_A0_EGR_IP_TUNNELm_DSCPf_SET
#define EGR_IP_TUNNELm_DSCP_SELf_GET BCM56800_A0_EGR_IP_TUNNELm_DSCP_SELf_GET
#define EGR_IP_TUNNELm_DSCP_SELf_SET BCM56800_A0_EGR_IP_TUNNELm_DSCP_SELf_SET
#define EGR_IP_TUNNELm_IPV4_DF_SELf_GET BCM56800_A0_EGR_IP_TUNNELm_IPV4_DF_SELf_GET
#define EGR_IP_TUNNELm_IPV4_DF_SELf_SET BCM56800_A0_EGR_IP_TUNNELm_IPV4_DF_SELf_SET
#define EGR_IP_TUNNELm_IPV6_DF_SELf_GET BCM56800_A0_EGR_IP_TUNNELm_IPV6_DF_SELf_GET
#define EGR_IP_TUNNELm_IPV6_DF_SELf_SET BCM56800_A0_EGR_IP_TUNNELm_IPV6_DF_SELf_SET
#define READ_EGR_IP_TUNNELm BCM56800_A0_READ_EGR_IP_TUNNELm
#define WRITE_EGR_IP_TUNNELm BCM56800_A0_WRITE_EGR_IP_TUNNELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_IP_TUNNELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_L3_INTF
 * BLOCKS:   EPIPE
 * DESC:     L3 Interface Table, FeatureSpecific-Ethernet
 * SIZE:     77
 * FIELDS:
 *     TUNNEL_INDEX     Tunnel Index to be used to index EGR_IP_TUNNEL table.
 *     L2_SWITCH        Indicates if the packet needs to be only L2 Switched and only L2 modifications needs to be done.
 *     VID              VID to be used for L3 replacement
 *     TTL_THRESHOLD    TTL Threshold to be used for L3 TTL checks.
 *     MAC_ADDRESS      MAC Address to be used for SA Replacement in the L3 modifications.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_L3_INTFm 0x03462000

#define BCM56800_A0_EGR_L3_INTFm_MIN 0
#define BCM56800_A0_EGR_L3_INTFm_MAX 4095
#define BCM56800_A0_EGR_L3_INTFm_CMAX(u) 4095
#define BCM56800_A0_EGR_L3_INTFm_SIZE 10

/*
 * This structure should be used to declare and program EGR_L3_INTF.
 *
 */
typedef union BCM56800_A0_EGR_L3_INTFm_s {
	uint32_t v[3];
	uint32_t egr_l3_intf[3];
	uint32_t _egr_l3_intf;
} BCM56800_A0_EGR_L3_INTFm_t;

#define BCM56800_A0_EGR_L3_INTFm_CLR(r) CDK_MEMSET(&((r)._egr_l3_intf), 0, sizeof(BCM56800_A0_EGR_L3_INTFm_t))
#define BCM56800_A0_EGR_L3_INTFm_SET(r,i,d) (r).egr_l3_intf[i] = d
#define BCM56800_A0_EGR_L3_INTFm_GET(r,i) (r).egr_l3_intf[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_L3_INTFm_TUNNEL_INDEXf_GET(r) (((r).egr_l3_intf[0]) & 0x7f)
#define BCM56800_A0_EGR_L3_INTFm_TUNNEL_INDEXf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56800_A0_EGR_L3_INTFm_L2_SWITCHf_GET(r) ((((r).egr_l3_intf[0]) >> 7) & 0x1)
#define BCM56800_A0_EGR_L3_INTFm_L2_SWITCHf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_EGR_L3_INTFm_VIDf_GET(r) ((((r).egr_l3_intf[0]) >> 8) & 0xfff)
#define BCM56800_A0_EGR_L3_INTFm_VIDf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM56800_A0_EGR_L3_INTFm_TTL_THRESHOLDf_GET(r) ((((r).egr_l3_intf[0]) >> 20) & 0xff)
#define BCM56800_A0_EGR_L3_INTFm_TTL_THRESHOLDf_SET(r,f) (r).egr_l3_intf[0]=(((r).egr_l3_intf[0] & ~((uint32_t)0xff << 20)) | ((((uint32_t)f) & 0xff) << 20))
#define BCM56800_A0_EGR_L3_INTFm_MAC_ADDRESSf_GET(r,a) cdk_field_get((r).egr_l3_intf,28,75,a)
#define BCM56800_A0_EGR_L3_INTFm_MAC_ADDRESSf_SET(r,a) cdk_field_set((r).egr_l3_intf,28,75,a)
#define BCM56800_A0_EGR_L3_INTFm_EVEN_PARITYf_GET(r) ((((r).egr_l3_intf[2]) >> 12) & 0x1)
#define BCM56800_A0_EGR_L3_INTFm_EVEN_PARITYf_SET(r,f) (r).egr_l3_intf[2]=(((r).egr_l3_intf[2] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access EGR_L3_INTF.
 *
 */
#define BCM56800_A0_READ_EGR_L3_INTFm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_L3_INTFm,i,(m._egr_l3_intf),3)
#define BCM56800_A0_WRITE_EGR_L3_INTFm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_L3_INTFm,i,&(m._egr_l3_intf),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_INTFm BCM56800_A0_EGR_L3_INTFm
#define EGR_L3_INTFm_MIN BCM56800_A0_EGR_L3_INTFm_MIN
#define EGR_L3_INTFm_MAX BCM56800_A0_EGR_L3_INTFm_MAX
#define EGR_L3_INTFm_CMAX(u) BCM56800_A0_EGR_L3_INTFm_CMAX(u)
#define EGR_L3_INTFm_SIZE BCM56800_A0_EGR_L3_INTFm_SIZE
typedef BCM56800_A0_EGR_L3_INTFm_t EGR_L3_INTFm_t;
#define EGR_L3_INTFm_CLR BCM56800_A0_EGR_L3_INTFm_CLR
#define EGR_L3_INTFm_SET BCM56800_A0_EGR_L3_INTFm_SET
#define EGR_L3_INTFm_GET BCM56800_A0_EGR_L3_INTFm_GET
#define EGR_L3_INTFm_TUNNEL_INDEXf_GET BCM56800_A0_EGR_L3_INTFm_TUNNEL_INDEXf_GET
#define EGR_L3_INTFm_TUNNEL_INDEXf_SET BCM56800_A0_EGR_L3_INTFm_TUNNEL_INDEXf_SET
#define EGR_L3_INTFm_L2_SWITCHf_GET BCM56800_A0_EGR_L3_INTFm_L2_SWITCHf_GET
#define EGR_L3_INTFm_L2_SWITCHf_SET BCM56800_A0_EGR_L3_INTFm_L2_SWITCHf_SET
#define EGR_L3_INTFm_VIDf_GET BCM56800_A0_EGR_L3_INTFm_VIDf_GET
#define EGR_L3_INTFm_VIDf_SET BCM56800_A0_EGR_L3_INTFm_VIDf_SET
#define EGR_L3_INTFm_TTL_THRESHOLDf_GET BCM56800_A0_EGR_L3_INTFm_TTL_THRESHOLDf_GET
#define EGR_L3_INTFm_TTL_THRESHOLDf_SET BCM56800_A0_EGR_L3_INTFm_TTL_THRESHOLDf_SET
#define EGR_L3_INTFm_MAC_ADDRESSf_GET BCM56800_A0_EGR_L3_INTFm_MAC_ADDRESSf_GET
#define EGR_L3_INTFm_MAC_ADDRESSf_SET BCM56800_A0_EGR_L3_INTFm_MAC_ADDRESSf_SET
#define EGR_L3_INTFm_EVEN_PARITYf_GET BCM56800_A0_EGR_L3_INTFm_EVEN_PARITYf_GET
#define EGR_L3_INTFm_EVEN_PARITYf_SET BCM56800_A0_EGR_L3_INTFm_EVEN_PARITYf_SET
#define READ_EGR_L3_INTFm BCM56800_A0_READ_EGR_L3_INTFm
#define WRITE_EGR_L3_INTFm BCM56800_A0_WRITE_EGR_L3_INTFm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_L3_INTFm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_L3_INTF_PARITY_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     EGR_L3_INTF_PARITY_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the EGR_L3_INTF table.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr 0x03480c00

#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_L3_INTF_PARITY_CONTROL.
 *
 */
typedef union BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_l3_intf_parity_control[1];
	uint32_t _egr_l3_intf_parity_control;
} BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_t;

#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_CLR(r) (r).egr_l3_intf_parity_control[0] = 0
#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_SET(r,d) (r).egr_l3_intf_parity_control[0] = d
#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_GET(r) (r).egr_l3_intf_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).egr_l3_intf_parity_control[0]) & 0x1)
#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).egr_l3_intf_parity_control[0]=(((r).egr_l3_intf_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).egr_l3_intf_parity_control[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).egr_l3_intf_parity_control[0]=(((r).egr_l3_intf_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_L3_INTF_PARITY_CONTROL.
 *
 */
#define BCM56800_A0_READ_EGR_L3_INTF_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr,(r._egr_l3_intf_parity_control))
#define BCM56800_A0_WRITE_EGR_L3_INTF_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr,&(r._egr_l3_intf_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_INTF_PARITY_CONTROLr BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr
#define EGR_L3_INTF_PARITY_CONTROLr_SIZE BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_SIZE
typedef BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_t EGR_L3_INTF_PARITY_CONTROLr_t;
#define EGR_L3_INTF_PARITY_CONTROLr_CLR BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_CLR
#define EGR_L3_INTF_PARITY_CONTROLr_SET BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_SET
#define EGR_L3_INTF_PARITY_CONTROLr_GET BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_GET
#define EGR_L3_INTF_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define EGR_L3_INTF_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define EGR_L3_INTF_PARITY_CONTROLr_PARITY_ENf_GET BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_PARITY_ENf_GET
#define EGR_L3_INTF_PARITY_CONTROLr_PARITY_ENf_SET BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_EGR_L3_INTF_PARITY_CONTROLr BCM56800_A0_READ_EGR_L3_INTF_PARITY_CONTROLr
#define WRITE_EGR_L3_INTF_PARITY_CONTROLr BCM56800_A0_WRITE_EGR_L3_INTF_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_L3_INTF_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_L3_INTF_PARITY_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_L3_INTF_PARITY_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     IDX              This field indicates the index to the bucket in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr 0x03480c01

#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_L3_INTF_PARITY_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_l3_intf_parity_status[1];
	uint32_t _egr_l3_intf_parity_status;
} BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_t;

#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_CLR(r) (r).egr_l3_intf_parity_status[0] = 0
#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_SET(r,d) (r).egr_l3_intf_parity_status[0] = d
#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_GET(r) (r).egr_l3_intf_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).egr_l3_intf_parity_status[0]) & 0x1)
#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).egr_l3_intf_parity_status[0]=(((r).egr_l3_intf_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_IDXf_GET(r) ((((r).egr_l3_intf_parity_status[0]) >> 1) & 0xfff)
#define BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_IDXf_SET(r,f) (r).egr_l3_intf_parity_status[0]=(((r).egr_l3_intf_parity_status[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))

/*
 * These macros can be used to access EGR_L3_INTF_PARITY_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_L3_INTF_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr,(r._egr_l3_intf_parity_status))
#define BCM56800_A0_WRITE_EGR_L3_INTF_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr,&(r._egr_l3_intf_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_INTF_PARITY_STATUSr BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr
#define EGR_L3_INTF_PARITY_STATUSr_SIZE BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_SIZE
typedef BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_t EGR_L3_INTF_PARITY_STATUSr_t;
#define EGR_L3_INTF_PARITY_STATUSr_CLR BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_CLR
#define EGR_L3_INTF_PARITY_STATUSr_SET BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_SET
#define EGR_L3_INTF_PARITY_STATUSr_GET BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_GET
#define EGR_L3_INTF_PARITY_STATUSr_PARITY_ERRf_GET BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_PARITY_ERRf_GET
#define EGR_L3_INTF_PARITY_STATUSr_PARITY_ERRf_SET BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_PARITY_ERRf_SET
#define EGR_L3_INTF_PARITY_STATUSr_IDXf_GET BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_IDXf_GET
#define EGR_L3_INTF_PARITY_STATUSr_IDXf_SET BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr_IDXf_SET
#define READ_EGR_L3_INTF_PARITY_STATUSr BCM56800_A0_READ_EGR_L3_INTF_PARITY_STATUSr
#define WRITE_EGR_L3_INTF_PARITY_STATUSr BCM56800_A0_WRITE_EGR_L3_INTF_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_L3_INTF_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_L3_NEXT_HOP
 * BLOCKS:   EPIPE
 * DESC:     Next Hop Table, FeatureSpecific-Ethernet
 * SIZE:     61
 * FIELDS:
 *     INTF_NUM         Interface Number to be used as index for L3_INTF table or VID for FP pkt change cases.
 *     MAC_ADDRESS      Mac Addres to be used for DA replacement by L3UC or FP modified packets.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_L3_NEXT_HOPm 0x03461000

#define BCM56800_A0_EGR_L3_NEXT_HOPm_MIN 0
#define BCM56800_A0_EGR_L3_NEXT_HOPm_MAX 2047
#define BCM56800_A0_EGR_L3_NEXT_HOPm_CMAX(u) 2047
#define BCM56800_A0_EGR_L3_NEXT_HOPm_SIZE 8

/*
 * This structure should be used to declare and program EGR_L3_NEXT_HOP.
 *
 */
typedef union BCM56800_A0_EGR_L3_NEXT_HOPm_s {
	uint32_t v[2];
	uint32_t egr_l3_next_hop[2];
	uint32_t _egr_l3_next_hop;
} BCM56800_A0_EGR_L3_NEXT_HOPm_t;

#define BCM56800_A0_EGR_L3_NEXT_HOPm_CLR(r) CDK_MEMSET(&((r)._egr_l3_next_hop), 0, sizeof(BCM56800_A0_EGR_L3_NEXT_HOPm_t))
#define BCM56800_A0_EGR_L3_NEXT_HOPm_SET(r,i,d) (r).egr_l3_next_hop[i] = d
#define BCM56800_A0_EGR_L3_NEXT_HOPm_GET(r,i) (r).egr_l3_next_hop[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_GET(r) (((r).egr_l3_next_hop[0]) & 0xfff)
#define BCM56800_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_SET(r,f) (r).egr_l3_next_hop[0]=(((r).egr_l3_next_hop[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET(r,a) cdk_field_get((r).egr_l3_next_hop,12,59,a)
#define BCM56800_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET(r,a) cdk_field_set((r).egr_l3_next_hop,12,59,a)
#define BCM56800_A0_EGR_L3_NEXT_HOPm_EVEN_PARITYf_GET(r) ((((r).egr_l3_next_hop[1]) >> 28) & 0x1)
#define BCM56800_A0_EGR_L3_NEXT_HOPm_EVEN_PARITYf_SET(r,f) (r).egr_l3_next_hop[1]=(((r).egr_l3_next_hop[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access EGR_L3_NEXT_HOP.
 *
 */
#define BCM56800_A0_READ_EGR_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_L3_NEXT_HOPm,i,(m._egr_l3_next_hop),2)
#define BCM56800_A0_WRITE_EGR_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_L3_NEXT_HOPm,i,&(m._egr_l3_next_hop),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_NEXT_HOPm BCM56800_A0_EGR_L3_NEXT_HOPm
#define EGR_L3_NEXT_HOPm_MIN BCM56800_A0_EGR_L3_NEXT_HOPm_MIN
#define EGR_L3_NEXT_HOPm_MAX BCM56800_A0_EGR_L3_NEXT_HOPm_MAX
#define EGR_L3_NEXT_HOPm_CMAX(u) BCM56800_A0_EGR_L3_NEXT_HOPm_CMAX(u)
#define EGR_L3_NEXT_HOPm_SIZE BCM56800_A0_EGR_L3_NEXT_HOPm_SIZE
typedef BCM56800_A0_EGR_L3_NEXT_HOPm_t EGR_L3_NEXT_HOPm_t;
#define EGR_L3_NEXT_HOPm_CLR BCM56800_A0_EGR_L3_NEXT_HOPm_CLR
#define EGR_L3_NEXT_HOPm_SET BCM56800_A0_EGR_L3_NEXT_HOPm_SET
#define EGR_L3_NEXT_HOPm_GET BCM56800_A0_EGR_L3_NEXT_HOPm_GET
#define EGR_L3_NEXT_HOPm_INTF_NUMf_GET BCM56800_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_GET
#define EGR_L3_NEXT_HOPm_INTF_NUMf_SET BCM56800_A0_EGR_L3_NEXT_HOPm_INTF_NUMf_SET
#define EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET BCM56800_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_GET
#define EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET BCM56800_A0_EGR_L3_NEXT_HOPm_MAC_ADDRESSf_SET
#define EGR_L3_NEXT_HOPm_EVEN_PARITYf_GET BCM56800_A0_EGR_L3_NEXT_HOPm_EVEN_PARITYf_GET
#define EGR_L3_NEXT_HOPm_EVEN_PARITYf_SET BCM56800_A0_EGR_L3_NEXT_HOPm_EVEN_PARITYf_SET
#define READ_EGR_L3_NEXT_HOPm BCM56800_A0_READ_EGR_L3_NEXT_HOPm
#define WRITE_EGR_L3_NEXT_HOPm BCM56800_A0_WRITE_EGR_L3_NEXT_HOPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_L3_NEXT_HOPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_L3_NEXT_HOP_PARITY_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     EGR_L3_NEXT_HOP_PARITY_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the EGR_L3_NEXT_HOP table.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr 0x03480c02

#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_L3_NEXT_HOP_PARITY_CONTROL.
 *
 */
typedef union BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_l3_next_hop_parity_control[1];
	uint32_t _egr_l3_next_hop_parity_control;
} BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_t;

#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_CLR(r) (r).egr_l3_next_hop_parity_control[0] = 0
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_SET(r,d) (r).egr_l3_next_hop_parity_control[0] = d
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_GET(r) (r).egr_l3_next_hop_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).egr_l3_next_hop_parity_control[0]) & 0x1)
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).egr_l3_next_hop_parity_control[0]=(((r).egr_l3_next_hop_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).egr_l3_next_hop_parity_control[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).egr_l3_next_hop_parity_control[0]=(((r).egr_l3_next_hop_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_L3_NEXT_HOP_PARITY_CONTROL.
 *
 */
#define BCM56800_A0_READ_EGR_L3_NEXT_HOP_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr,(r._egr_l3_next_hop_parity_control))
#define BCM56800_A0_WRITE_EGR_L3_NEXT_HOP_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr,&(r._egr_l3_next_hop_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_NEXT_HOP_PARITY_CONTROLr BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr
#define EGR_L3_NEXT_HOP_PARITY_CONTROLr_SIZE BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_SIZE
typedef BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_t EGR_L3_NEXT_HOP_PARITY_CONTROLr_t;
#define EGR_L3_NEXT_HOP_PARITY_CONTROLr_CLR BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_CLR
#define EGR_L3_NEXT_HOP_PARITY_CONTROLr_SET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_SET
#define EGR_L3_NEXT_HOP_PARITY_CONTROLr_GET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_GET
#define EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_ENf_GET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_ENf_GET
#define EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_ENf_SET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_EGR_L3_NEXT_HOP_PARITY_CONTROLr BCM56800_A0_READ_EGR_L3_NEXT_HOP_PARITY_CONTROLr
#define WRITE_EGR_L3_NEXT_HOP_PARITY_CONTROLr BCM56800_A0_WRITE_EGR_L3_NEXT_HOP_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_L3_NEXT_HOP_PARITY_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_L3_NEXT_HOP_PARITY_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     IDX              This field indicates the index to the bucket in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr 0x03480c03

#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_L3_NEXT_HOP_PARITY_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_l3_next_hop_parity_status[1];
	uint32_t _egr_l3_next_hop_parity_status;
} BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_t;

#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_CLR(r) (r).egr_l3_next_hop_parity_status[0] = 0
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_SET(r,d) (r).egr_l3_next_hop_parity_status[0] = d
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_GET(r) (r).egr_l3_next_hop_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).egr_l3_next_hop_parity_status[0]) & 0x1)
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).egr_l3_next_hop_parity_status[0]=(((r).egr_l3_next_hop_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_IDXf_GET(r) ((((r).egr_l3_next_hop_parity_status[0]) >> 1) & 0x7ff)
#define BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_IDXf_SET(r,f) (r).egr_l3_next_hop_parity_status[0]=(((r).egr_l3_next_hop_parity_status[0] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))

/*
 * These macros can be used to access EGR_L3_NEXT_HOP_PARITY_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_L3_NEXT_HOP_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr,(r._egr_l3_next_hop_parity_status))
#define BCM56800_A0_WRITE_EGR_L3_NEXT_HOP_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr,&(r._egr_l3_next_hop_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_L3_NEXT_HOP_PARITY_STATUSr BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr
#define EGR_L3_NEXT_HOP_PARITY_STATUSr_SIZE BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_SIZE
typedef BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_t EGR_L3_NEXT_HOP_PARITY_STATUSr_t;
#define EGR_L3_NEXT_HOP_PARITY_STATUSr_CLR BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_CLR
#define EGR_L3_NEXT_HOP_PARITY_STATUSr_SET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_SET
#define EGR_L3_NEXT_HOP_PARITY_STATUSr_GET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_GET
#define EGR_L3_NEXT_HOP_PARITY_STATUSr_PARITY_ERRf_GET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_PARITY_ERRf_GET
#define EGR_L3_NEXT_HOP_PARITY_STATUSr_PARITY_ERRf_SET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_PARITY_ERRf_SET
#define EGR_L3_NEXT_HOP_PARITY_STATUSr_IDXf_GET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_IDXf_GET
#define EGR_L3_NEXT_HOP_PARITY_STATUSr_IDXf_SET BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr_IDXf_SET
#define READ_EGR_L3_NEXT_HOP_PARITY_STATUSr BCM56800_A0_READ_EGR_L3_NEXT_HOP_PARITY_STATUSr
#define WRITE_EGR_L3_NEXT_HOP_PARITY_STATUSr BCM56800_A0_WRITE_EGR_L3_NEXT_HOP_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_L3_NEXT_HOP_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_MAP_MH_PRI0
 * BLOCKS:   EPIPE
 * DESC:     Used for mapping incoming PBE MH_PRIORITY into a new MH_PRIORITY/TC For Higig+/Higig2 header, for MH_PRI values 0-7

 * SIZE:     32
 * FIELDS:
 *     MH_PRI0          new MH prioroty value when PBE.MH_PRI=0
 *     MH_PRI1          new MH prioroty value when PBE.MH_PRI=1
 *     MH_PRI2          new MH prioroty value when PBE.MH_PRI=2
 *     MH_PRI3          new MH prioroty value when PBE.MH_PRI=3
 *     MH_PRI4          new MH prioroty value when PBE.MH_PRI=4
 *     MH_PRI5          new MH prioroty value when PBE.MH_PRI=5
 *     MH_PRI6          new MH prioroty value when PBE.MH_PRI=6
 *     MH_PRI7          new MH prioroty value when PBE.MH_PRI=7
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MAP_MH_PRI0r 0x01400005

#define BCM56800_A0_EGR_MAP_MH_PRI0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_MAP_MH_PRI0.
 *
 */
typedef union BCM56800_A0_EGR_MAP_MH_PRI0r_s {
	uint32_t v[1];
	uint32_t egr_map_mh_pri0[1];
	uint32_t _egr_map_mh_pri0;
} BCM56800_A0_EGR_MAP_MH_PRI0r_t;

#define BCM56800_A0_EGR_MAP_MH_PRI0r_CLR(r) (r).egr_map_mh_pri0[0] = 0
#define BCM56800_A0_EGR_MAP_MH_PRI0r_SET(r,d) (r).egr_map_mh_pri0[0] = d
#define BCM56800_A0_EGR_MAP_MH_PRI0r_GET(r) (r).egr_map_mh_pri0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI0f_GET(r) (((r).egr_map_mh_pri0[0]) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI0f_SET(r,f) (r).egr_map_mh_pri0[0]=(((r).egr_map_mh_pri0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI1f_GET(r) ((((r).egr_map_mh_pri0[0]) >> 4) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI1f_SET(r,f) (r).egr_map_mh_pri0[0]=(((r).egr_map_mh_pri0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI2f_GET(r) ((((r).egr_map_mh_pri0[0]) >> 8) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI2f_SET(r,f) (r).egr_map_mh_pri0[0]=(((r).egr_map_mh_pri0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI3f_GET(r) ((((r).egr_map_mh_pri0[0]) >> 12) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI3f_SET(r,f) (r).egr_map_mh_pri0[0]=(((r).egr_map_mh_pri0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI4f_GET(r) ((((r).egr_map_mh_pri0[0]) >> 16) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI4f_SET(r,f) (r).egr_map_mh_pri0[0]=(((r).egr_map_mh_pri0[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI5f_GET(r) ((((r).egr_map_mh_pri0[0]) >> 20) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI5f_SET(r,f) (r).egr_map_mh_pri0[0]=(((r).egr_map_mh_pri0[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI6f_GET(r) ((((r).egr_map_mh_pri0[0]) >> 24) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI6f_SET(r,f) (r).egr_map_mh_pri0[0]=(((r).egr_map_mh_pri0[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI7f_GET(r) ((((r).egr_map_mh_pri0[0]) >> 28) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI7f_SET(r,f) (r).egr_map_mh_pri0[0]=(((r).egr_map_mh_pri0[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access EGR_MAP_MH_PRI0.
 *
 */
#define BCM56800_A0_READ_EGR_MAP_MH_PRI0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_MAP_MH_PRI0r,(r._egr_map_mh_pri0))
#define BCM56800_A0_WRITE_EGR_MAP_MH_PRI0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_MAP_MH_PRI0r,&(r._egr_map_mh_pri0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MAP_MH_PRI0r BCM56800_A0_EGR_MAP_MH_PRI0r
#define EGR_MAP_MH_PRI0r_SIZE BCM56800_A0_EGR_MAP_MH_PRI0r_SIZE
typedef BCM56800_A0_EGR_MAP_MH_PRI0r_t EGR_MAP_MH_PRI0r_t;
#define EGR_MAP_MH_PRI0r_CLR BCM56800_A0_EGR_MAP_MH_PRI0r_CLR
#define EGR_MAP_MH_PRI0r_SET BCM56800_A0_EGR_MAP_MH_PRI0r_SET
#define EGR_MAP_MH_PRI0r_GET BCM56800_A0_EGR_MAP_MH_PRI0r_GET
#define EGR_MAP_MH_PRI0r_MH_PRI0f_GET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI0f_GET
#define EGR_MAP_MH_PRI0r_MH_PRI0f_SET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI0f_SET
#define EGR_MAP_MH_PRI0r_MH_PRI1f_GET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI1f_GET
#define EGR_MAP_MH_PRI0r_MH_PRI1f_SET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI1f_SET
#define EGR_MAP_MH_PRI0r_MH_PRI2f_GET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI2f_GET
#define EGR_MAP_MH_PRI0r_MH_PRI2f_SET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI2f_SET
#define EGR_MAP_MH_PRI0r_MH_PRI3f_GET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI3f_GET
#define EGR_MAP_MH_PRI0r_MH_PRI3f_SET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI3f_SET
#define EGR_MAP_MH_PRI0r_MH_PRI4f_GET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI4f_GET
#define EGR_MAP_MH_PRI0r_MH_PRI4f_SET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI4f_SET
#define EGR_MAP_MH_PRI0r_MH_PRI5f_GET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI5f_GET
#define EGR_MAP_MH_PRI0r_MH_PRI5f_SET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI5f_SET
#define EGR_MAP_MH_PRI0r_MH_PRI6f_GET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI6f_GET
#define EGR_MAP_MH_PRI0r_MH_PRI6f_SET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI6f_SET
#define EGR_MAP_MH_PRI0r_MH_PRI7f_GET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI7f_GET
#define EGR_MAP_MH_PRI0r_MH_PRI7f_SET BCM56800_A0_EGR_MAP_MH_PRI0r_MH_PRI7f_SET
#define READ_EGR_MAP_MH_PRI0r BCM56800_A0_READ_EGR_MAP_MH_PRI0r
#define WRITE_EGR_MAP_MH_PRI0r BCM56800_A0_WRITE_EGR_MAP_MH_PRI0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MAP_MH_PRI0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_MAP_MH_PRI1
 * BLOCKS:   EPIPE
 * DESC:     Used for mapping incoming PBE MH_PRIORITY into a new MH_PRIORITY/TC For Higig+/Higig2 header, for MH_PRI values 8-15

 * SIZE:     32
 * FIELDS:
 *     MH_PRI8          new MH prioroty value when PBE.MH_PRI=8
 *     MH_PRI9          new MH prioroty value when PBE.MH_PRI=9
 *     MH_PRI10         new MH prioroty value when PBE.MH_PRI=10
 *     MH_PRI11         new MH prioroty value when PBE.MH_PRI=11
 *     MH_PRI12         new MH prioroty value when PBE.MH_PRI=12
 *     MH_PRI13         new MH prioroty value when PBE.MH_PRI=13
 *     MH_PRI14         new MH prioroty value when PBE.MH_PRI=14
 *     MH_PRI15         new MH prioroty value when PBE.MH_PRI=15
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MAP_MH_PRI1r 0x01400006

#define BCM56800_A0_EGR_MAP_MH_PRI1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_MAP_MH_PRI1.
 *
 */
typedef union BCM56800_A0_EGR_MAP_MH_PRI1r_s {
	uint32_t v[1];
	uint32_t egr_map_mh_pri1[1];
	uint32_t _egr_map_mh_pri1;
} BCM56800_A0_EGR_MAP_MH_PRI1r_t;

#define BCM56800_A0_EGR_MAP_MH_PRI1r_CLR(r) (r).egr_map_mh_pri1[0] = 0
#define BCM56800_A0_EGR_MAP_MH_PRI1r_SET(r,d) (r).egr_map_mh_pri1[0] = d
#define BCM56800_A0_EGR_MAP_MH_PRI1r_GET(r) (r).egr_map_mh_pri1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI8f_GET(r) (((r).egr_map_mh_pri1[0]) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI8f_SET(r,f) (r).egr_map_mh_pri1[0]=(((r).egr_map_mh_pri1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI9f_GET(r) ((((r).egr_map_mh_pri1[0]) >> 4) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI9f_SET(r,f) (r).egr_map_mh_pri1[0]=(((r).egr_map_mh_pri1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI10f_GET(r) ((((r).egr_map_mh_pri1[0]) >> 8) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI10f_SET(r,f) (r).egr_map_mh_pri1[0]=(((r).egr_map_mh_pri1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI11f_GET(r) ((((r).egr_map_mh_pri1[0]) >> 12) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI11f_SET(r,f) (r).egr_map_mh_pri1[0]=(((r).egr_map_mh_pri1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI12f_GET(r) ((((r).egr_map_mh_pri1[0]) >> 16) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI12f_SET(r,f) (r).egr_map_mh_pri1[0]=(((r).egr_map_mh_pri1[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI13f_GET(r) ((((r).egr_map_mh_pri1[0]) >> 20) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI13f_SET(r,f) (r).egr_map_mh_pri1[0]=(((r).egr_map_mh_pri1[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI14f_GET(r) ((((r).egr_map_mh_pri1[0]) >> 24) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI14f_SET(r,f) (r).egr_map_mh_pri1[0]=(((r).egr_map_mh_pri1[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI15f_GET(r) ((((r).egr_map_mh_pri1[0]) >> 28) & 0xf)
#define BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI15f_SET(r,f) (r).egr_map_mh_pri1[0]=(((r).egr_map_mh_pri1[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access EGR_MAP_MH_PRI1.
 *
 */
#define BCM56800_A0_READ_EGR_MAP_MH_PRI1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_MAP_MH_PRI1r,(r._egr_map_mh_pri1))
#define BCM56800_A0_WRITE_EGR_MAP_MH_PRI1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_MAP_MH_PRI1r,&(r._egr_map_mh_pri1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MAP_MH_PRI1r BCM56800_A0_EGR_MAP_MH_PRI1r
#define EGR_MAP_MH_PRI1r_SIZE BCM56800_A0_EGR_MAP_MH_PRI1r_SIZE
typedef BCM56800_A0_EGR_MAP_MH_PRI1r_t EGR_MAP_MH_PRI1r_t;
#define EGR_MAP_MH_PRI1r_CLR BCM56800_A0_EGR_MAP_MH_PRI1r_CLR
#define EGR_MAP_MH_PRI1r_SET BCM56800_A0_EGR_MAP_MH_PRI1r_SET
#define EGR_MAP_MH_PRI1r_GET BCM56800_A0_EGR_MAP_MH_PRI1r_GET
#define EGR_MAP_MH_PRI1r_MH_PRI8f_GET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI8f_GET
#define EGR_MAP_MH_PRI1r_MH_PRI8f_SET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI8f_SET
#define EGR_MAP_MH_PRI1r_MH_PRI9f_GET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI9f_GET
#define EGR_MAP_MH_PRI1r_MH_PRI9f_SET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI9f_SET
#define EGR_MAP_MH_PRI1r_MH_PRI10f_GET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI10f_GET
#define EGR_MAP_MH_PRI1r_MH_PRI10f_SET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI10f_SET
#define EGR_MAP_MH_PRI1r_MH_PRI11f_GET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI11f_GET
#define EGR_MAP_MH_PRI1r_MH_PRI11f_SET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI11f_SET
#define EGR_MAP_MH_PRI1r_MH_PRI12f_GET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI12f_GET
#define EGR_MAP_MH_PRI1r_MH_PRI12f_SET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI12f_SET
#define EGR_MAP_MH_PRI1r_MH_PRI13f_GET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI13f_GET
#define EGR_MAP_MH_PRI1r_MH_PRI13f_SET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI13f_SET
#define EGR_MAP_MH_PRI1r_MH_PRI14f_GET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI14f_GET
#define EGR_MAP_MH_PRI1r_MH_PRI14f_SET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI14f_SET
#define EGR_MAP_MH_PRI1r_MH_PRI15f_GET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI15f_GET
#define EGR_MAP_MH_PRI1r_MH_PRI15f_SET BCM56800_A0_EGR_MAP_MH_PRI1r_MH_PRI15f_SET
#define READ_EGR_MAP_MH_PRI1r BCM56800_A0_READ_EGR_MAP_MH_PRI1r
#define WRITE_EGR_MAP_MH_PRI1r BCM56800_A0_WRITE_EGR_MAP_MH_PRI1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MAP_MH_PRI1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_MASK
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table
 * SIZE:     21
 * FIELDS:
 *     EGRESS_MASK      Egress mask block mask for source port
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MASKm 0x0e160000

#define BCM56800_A0_EGR_MASKm_MIN 0
#define BCM56800_A0_EGR_MASKm_MAX 4095
#define BCM56800_A0_EGR_MASKm_CMAX(u) 4095
#define BCM56800_A0_EGR_MASKm_SIZE 3

/*
 * This structure should be used to declare and program EGR_MASK.
 *
 */
typedef union BCM56800_A0_EGR_MASKm_s {
	uint32_t v[1];
	uint32_t egr_mask[1];
	uint32_t _egr_mask;
} BCM56800_A0_EGR_MASKm_t;

#define BCM56800_A0_EGR_MASKm_CLR(r) (r).egr_mask[0] = 0
#define BCM56800_A0_EGR_MASKm_SET(r,d) (r).egr_mask[0] = d
#define BCM56800_A0_EGR_MASKm_GET(r) (r).egr_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MASKm_EGRESS_MASKf_GET(r) (((r).egr_mask[0]) & 0x1fffff)
#define BCM56800_A0_EGR_MASKm_EGRESS_MASKf_SET(r,f) (r).egr_mask[0]=(((r).egr_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access EGR_MASK.
 *
 */
#define BCM56800_A0_READ_EGR_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_MASKm,i,(m._egr_mask),1)
#define BCM56800_A0_WRITE_EGR_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_MASKm,i,&(m._egr_mask),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MASKm BCM56800_A0_EGR_MASKm
#define EGR_MASKm_MIN BCM56800_A0_EGR_MASKm_MIN
#define EGR_MASKm_MAX BCM56800_A0_EGR_MASKm_MAX
#define EGR_MASKm_CMAX(u) BCM56800_A0_EGR_MASKm_CMAX(u)
#define EGR_MASKm_SIZE BCM56800_A0_EGR_MASKm_SIZE
typedef BCM56800_A0_EGR_MASKm_t EGR_MASKm_t;
#define EGR_MASKm_CLR BCM56800_A0_EGR_MASKm_CLR
#define EGR_MASKm_SET BCM56800_A0_EGR_MASKm_SET
#define EGR_MASKm_GET BCM56800_A0_EGR_MASKm_GET
#define EGR_MASKm_EGRESS_MASKf_GET BCM56800_A0_EGR_MASKm_EGRESS_MASKf_GET
#define EGR_MASKm_EGRESS_MASKf_SET BCM56800_A0_EGR_MASKm_EGRESS_MASKf_SET
#define READ_EGR_MASKm BCM56800_A0_READ_EGR_MASKm
#define WRITE_EGR_MASKm BCM56800_A0_WRITE_EGR_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_MC_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     TBfilled 

 * SIZE:     32
 * FIELDS:
 *     HIGIG2_BC_BASE_OFFSET TBF
 *     HIGIG2_L2MC_BASE_OFFSET TBF
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MC_CONTROL_1r 0x09480601

#define BCM56800_A0_EGR_MC_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_MC_CONTROL_1.
 *
 */
typedef union BCM56800_A0_EGR_MC_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_mc_control_1[1];
	uint32_t _egr_mc_control_1;
} BCM56800_A0_EGR_MC_CONTROL_1r_t;

#define BCM56800_A0_EGR_MC_CONTROL_1r_CLR(r) (r).egr_mc_control_1[0] = 0
#define BCM56800_A0_EGR_MC_CONTROL_1r_SET(r,d) (r).egr_mc_control_1[0] = d
#define BCM56800_A0_EGR_MC_CONTROL_1r_GET(r) (r).egr_mc_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET(r) (((r).egr_mc_control_1[0]) & 0xffff)
#define BCM56800_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET(r,f) (r).egr_mc_control_1[0]=(((r).egr_mc_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_EGR_MC_CONTROL_1r_HIGIG2_L2MC_BASE_OFFSETf_GET(r) ((((r).egr_mc_control_1[0]) >> 16) & 0xffff)
#define BCM56800_A0_EGR_MC_CONTROL_1r_HIGIG2_L2MC_BASE_OFFSETf_SET(r,f) (r).egr_mc_control_1[0]=(((r).egr_mc_control_1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_MC_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_EGR_MC_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_MC_CONTROL_1r,(r._egr_mc_control_1))
#define BCM56800_A0_WRITE_EGR_MC_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_MC_CONTROL_1r,&(r._egr_mc_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MC_CONTROL_1r BCM56800_A0_EGR_MC_CONTROL_1r
#define EGR_MC_CONTROL_1r_SIZE BCM56800_A0_EGR_MC_CONTROL_1r_SIZE
typedef BCM56800_A0_EGR_MC_CONTROL_1r_t EGR_MC_CONTROL_1r_t;
#define EGR_MC_CONTROL_1r_CLR BCM56800_A0_EGR_MC_CONTROL_1r_CLR
#define EGR_MC_CONTROL_1r_SET BCM56800_A0_EGR_MC_CONTROL_1r_SET
#define EGR_MC_CONTROL_1r_GET BCM56800_A0_EGR_MC_CONTROL_1r_GET
#define EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET BCM56800_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET
#define EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET BCM56800_A0_EGR_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET
#define EGR_MC_CONTROL_1r_HIGIG2_L2MC_BASE_OFFSETf_GET BCM56800_A0_EGR_MC_CONTROL_1r_HIGIG2_L2MC_BASE_OFFSETf_GET
#define EGR_MC_CONTROL_1r_HIGIG2_L2MC_BASE_OFFSETf_SET BCM56800_A0_EGR_MC_CONTROL_1r_HIGIG2_L2MC_BASE_OFFSETf_SET
#define READ_EGR_MC_CONTROL_1r BCM56800_A0_READ_EGR_MC_CONTROL_1r
#define WRITE_EGR_MC_CONTROL_1r BCM56800_A0_WRITE_EGR_MC_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MC_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_MC_CONTROL_2
 * BLOCKS:   EPIPE
 * DESC:     TBfilled 

 * SIZE:     32
 * FIELDS:
 *     HIGIG2_IPMC_BASE_OFFSET TBF
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MC_CONTROL_2r 0x09480602

#define BCM56800_A0_EGR_MC_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program EGR_MC_CONTROL_2.
 *
 */
typedef union BCM56800_A0_EGR_MC_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t egr_mc_control_2[1];
	uint32_t _egr_mc_control_2;
} BCM56800_A0_EGR_MC_CONTROL_2r_t;

#define BCM56800_A0_EGR_MC_CONTROL_2r_CLR(r) (r).egr_mc_control_2[0] = 0
#define BCM56800_A0_EGR_MC_CONTROL_2r_SET(r,d) (r).egr_mc_control_2[0] = d
#define BCM56800_A0_EGR_MC_CONTROL_2r_GET(r) (r).egr_mc_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MC_CONTROL_2r_HIGIG2_IPMC_BASE_OFFSETf_GET(r) (((r).egr_mc_control_2[0]) & 0xffff)
#define BCM56800_A0_EGR_MC_CONTROL_2r_HIGIG2_IPMC_BASE_OFFSETf_SET(r,f) (r).egr_mc_control_2[0]=(((r).egr_mc_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_MC_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_EGR_MC_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_MC_CONTROL_2r,(r._egr_mc_control_2))
#define BCM56800_A0_WRITE_EGR_MC_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_MC_CONTROL_2r,&(r._egr_mc_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MC_CONTROL_2r BCM56800_A0_EGR_MC_CONTROL_2r
#define EGR_MC_CONTROL_2r_SIZE BCM56800_A0_EGR_MC_CONTROL_2r_SIZE
typedef BCM56800_A0_EGR_MC_CONTROL_2r_t EGR_MC_CONTROL_2r_t;
#define EGR_MC_CONTROL_2r_CLR BCM56800_A0_EGR_MC_CONTROL_2r_CLR
#define EGR_MC_CONTROL_2r_SET BCM56800_A0_EGR_MC_CONTROL_2r_SET
#define EGR_MC_CONTROL_2r_GET BCM56800_A0_EGR_MC_CONTROL_2r_GET
#define EGR_MC_CONTROL_2r_HIGIG2_IPMC_BASE_OFFSETf_GET BCM56800_A0_EGR_MC_CONTROL_2r_HIGIG2_IPMC_BASE_OFFSETf_GET
#define EGR_MC_CONTROL_2r_HIGIG2_IPMC_BASE_OFFSETf_SET BCM56800_A0_EGR_MC_CONTROL_2r_HIGIG2_IPMC_BASE_OFFSETf_SET
#define READ_EGR_MC_CONTROL_2r BCM56800_A0_READ_EGR_MC_CONTROL_2r
#define WRITE_EGR_MC_CONTROL_2r BCM56800_A0_WRITE_EGR_MC_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MC_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_MMU_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This register contains the cell requests asserted by TP for individual ports to MMU.
Meaning of cell request is 1024 bits data. All it shows is the number of times cell_request signal
was asserted by TP to MMU for each port. 

 * SIZE:     32
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MMU_REQUESTSr 0x0a4000f3

#define BCM56800_A0_EGR_MMU_REQUESTSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MMU_REQUESTS.
 *
 */
typedef union BCM56800_A0_EGR_MMU_REQUESTSr_s {
	uint32_t v[1];
	uint32_t egr_mmu_requests[1];
	uint32_t _egr_mmu_requests;
} BCM56800_A0_EGR_MMU_REQUESTSr_t;

#define BCM56800_A0_EGR_MMU_REQUESTSr_CLR(r) (r).egr_mmu_requests[0] = 0
#define BCM56800_A0_EGR_MMU_REQUESTSr_SET(r,d) (r).egr_mmu_requests[0] = d
#define BCM56800_A0_EGR_MMU_REQUESTSr_GET(r) (r).egr_mmu_requests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_mmu_requests[0]) & 0xf)
#define BCM56800_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_mmu_requests[0]=(((r).egr_mmu_requests[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGR_MMU_REQUESTS.
 *
 */
#define BCM56800_A0_READ_EGR_MMU_REQUESTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_MMU_REQUESTSr,(r._egr_mmu_requests))
#define BCM56800_A0_WRITE_EGR_MMU_REQUESTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_MMU_REQUESTSr,&(r._egr_mmu_requests))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MMU_REQUESTSr BCM56800_A0_EGR_MMU_REQUESTSr
#define EGR_MMU_REQUESTSr_SIZE BCM56800_A0_EGR_MMU_REQUESTSr_SIZE
typedef BCM56800_A0_EGR_MMU_REQUESTSr_t EGR_MMU_REQUESTSr_t;
#define EGR_MMU_REQUESTSr_CLR BCM56800_A0_EGR_MMU_REQUESTSr_CLR
#define EGR_MMU_REQUESTSr_SET BCM56800_A0_EGR_MMU_REQUESTSr_SET
#define EGR_MMU_REQUESTSr_GET BCM56800_A0_EGR_MMU_REQUESTSr_GET
#define EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET BCM56800_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET
#define EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET BCM56800_A0_EGR_MMU_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET
#define READ_EGR_MMU_REQUESTSr BCM56800_A0_READ_EGR_MMU_REQUESTSr
#define WRITE_EGR_MMU_REQUESTSr BCM56800_A0_WRITE_EGR_MMU_REQUESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MMU_REQUESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_MODMAP_CTRL
 * BLOCKS:   EPIPE
 * DESC:     Module Mapping Control

 * SIZE:     32
 * FIELDS:
 *     MODULEID_OFFSET  Module Id.
 *     EGR_MAP_EN       Enables the module remapping feature.
 *     EGR_MOD_MAP_ID   Module Id.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MODMAP_CTRLr 0x08400004

#define BCM56800_A0_EGR_MODMAP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MODMAP_CTRL.
 *
 */
typedef union BCM56800_A0_EGR_MODMAP_CTRLr_s {
	uint32_t v[1];
	uint32_t egr_modmap_ctrl[1];
	uint32_t _egr_modmap_ctrl;
} BCM56800_A0_EGR_MODMAP_CTRLr_t;

#define BCM56800_A0_EGR_MODMAP_CTRLr_CLR(r) (r).egr_modmap_ctrl[0] = 0
#define BCM56800_A0_EGR_MODMAP_CTRLr_SET(r,d) (r).egr_modmap_ctrl[0] = d
#define BCM56800_A0_EGR_MODMAP_CTRLr_GET(r) (r).egr_modmap_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MODMAP_CTRLr_MODULEID_OFFSETf_GET(r) (((r).egr_modmap_ctrl[0]) & 0x7f)
#define BCM56800_A0_EGR_MODMAP_CTRLr_MODULEID_OFFSETf_SET(r,f) (r).egr_modmap_ctrl[0]=(((r).egr_modmap_ctrl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56800_A0_EGR_MODMAP_CTRLr_EGR_MAP_ENf_GET(r) ((((r).egr_modmap_ctrl[0]) >> 7) & 0x1)
#define BCM56800_A0_EGR_MODMAP_CTRLr_EGR_MAP_ENf_SET(r,f) (r).egr_modmap_ctrl[0]=(((r).egr_modmap_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_EGR_MODMAP_CTRLr_EGR_MOD_MAP_IDf_GET(r) ((((r).egr_modmap_ctrl[0]) >> 8) & 0x1)
#define BCM56800_A0_EGR_MODMAP_CTRLr_EGR_MOD_MAP_IDf_SET(r,f) (r).egr_modmap_ctrl[0]=(((r).egr_modmap_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access EGR_MODMAP_CTRL.
 *
 */
#define BCM56800_A0_READ_EGR_MODMAP_CTRLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_MODMAP_CTRLr,(r._egr_modmap_ctrl))
#define BCM56800_A0_WRITE_EGR_MODMAP_CTRLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_MODMAP_CTRLr,&(r._egr_modmap_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MODMAP_CTRLr BCM56800_A0_EGR_MODMAP_CTRLr
#define EGR_MODMAP_CTRLr_SIZE BCM56800_A0_EGR_MODMAP_CTRLr_SIZE
typedef BCM56800_A0_EGR_MODMAP_CTRLr_t EGR_MODMAP_CTRLr_t;
#define EGR_MODMAP_CTRLr_CLR BCM56800_A0_EGR_MODMAP_CTRLr_CLR
#define EGR_MODMAP_CTRLr_SET BCM56800_A0_EGR_MODMAP_CTRLr_SET
#define EGR_MODMAP_CTRLr_GET BCM56800_A0_EGR_MODMAP_CTRLr_GET
#define EGR_MODMAP_CTRLr_MODULEID_OFFSETf_GET BCM56800_A0_EGR_MODMAP_CTRLr_MODULEID_OFFSETf_GET
#define EGR_MODMAP_CTRLr_MODULEID_OFFSETf_SET BCM56800_A0_EGR_MODMAP_CTRLr_MODULEID_OFFSETf_SET
#define EGR_MODMAP_CTRLr_EGR_MAP_ENf_GET BCM56800_A0_EGR_MODMAP_CTRLr_EGR_MAP_ENf_GET
#define EGR_MODMAP_CTRLr_EGR_MAP_ENf_SET BCM56800_A0_EGR_MODMAP_CTRLr_EGR_MAP_ENf_SET
#define EGR_MODMAP_CTRLr_EGR_MOD_MAP_IDf_GET BCM56800_A0_EGR_MODMAP_CTRLr_EGR_MOD_MAP_IDf_GET
#define EGR_MODMAP_CTRLr_EGR_MOD_MAP_IDf_SET BCM56800_A0_EGR_MODMAP_CTRLr_EGR_MOD_MAP_IDf_SET
#define READ_EGR_MODMAP_CTRLr BCM56800_A0_READ_EGR_MODMAP_CTRLr
#define WRITE_EGR_MODMAP_CTRLr BCM56800_A0_WRITE_EGR_MODMAP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MODMAP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_MOD_MAP_TABLE
 * BLOCKS:   EPIPE
 * DESC:     Egress Module Remapping Table
 * SIZE:     11
 * FIELDS:
 *     PORT_OFFSET      offset added to the Src_port  to generate FID-view src_port.
 *     MODID            Src Modid for FID view
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MOD_MAP_TABLEm 0x08461000

#define BCM56800_A0_EGR_MOD_MAP_TABLEm_MIN 0
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_MAX 255
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_CMAX(u) 255
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_SIZE 2

/*
 * This structure should be used to declare and program EGR_MOD_MAP_TABLE.
 *
 */
typedef union BCM56800_A0_EGR_MOD_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t egr_mod_map_table[1];
	uint32_t _egr_mod_map_table;
} BCM56800_A0_EGR_MOD_MAP_TABLEm_t;

#define BCM56800_A0_EGR_MOD_MAP_TABLEm_CLR(r) (r).egr_mod_map_table[0] = 0
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_SET(r,d) (r).egr_mod_map_table[0] = d
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_GET(r) (r).egr_mod_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_PORT_OFFSETf_GET(r) (((r).egr_mod_map_table[0]) & 0x1f)
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_PORT_OFFSETf_SET(r,f) (r).egr_mod_map_table[0]=(((r).egr_mod_map_table[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_MODIDf_GET(r) ((((r).egr_mod_map_table[0]) >> 5) & 0x3f)
#define BCM56800_A0_EGR_MOD_MAP_TABLEm_MODIDf_SET(r,f) (r).egr_mod_map_table[0]=(((r).egr_mod_map_table[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5))

/*
 * These macros can be used to access EGR_MOD_MAP_TABLE.
 *
 */
#define BCM56800_A0_READ_EGR_MOD_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_MOD_MAP_TABLEm,i,(m._egr_mod_map_table),1)
#define BCM56800_A0_WRITE_EGR_MOD_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_MOD_MAP_TABLEm,i,&(m._egr_mod_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MOD_MAP_TABLEm BCM56800_A0_EGR_MOD_MAP_TABLEm
#define EGR_MOD_MAP_TABLEm_MIN BCM56800_A0_EGR_MOD_MAP_TABLEm_MIN
#define EGR_MOD_MAP_TABLEm_MAX BCM56800_A0_EGR_MOD_MAP_TABLEm_MAX
#define EGR_MOD_MAP_TABLEm_CMAX(u) BCM56800_A0_EGR_MOD_MAP_TABLEm_CMAX(u)
#define EGR_MOD_MAP_TABLEm_SIZE BCM56800_A0_EGR_MOD_MAP_TABLEm_SIZE
typedef BCM56800_A0_EGR_MOD_MAP_TABLEm_t EGR_MOD_MAP_TABLEm_t;
#define EGR_MOD_MAP_TABLEm_CLR BCM56800_A0_EGR_MOD_MAP_TABLEm_CLR
#define EGR_MOD_MAP_TABLEm_SET BCM56800_A0_EGR_MOD_MAP_TABLEm_SET
#define EGR_MOD_MAP_TABLEm_GET BCM56800_A0_EGR_MOD_MAP_TABLEm_GET
#define EGR_MOD_MAP_TABLEm_PORT_OFFSETf_GET BCM56800_A0_EGR_MOD_MAP_TABLEm_PORT_OFFSETf_GET
#define EGR_MOD_MAP_TABLEm_PORT_OFFSETf_SET BCM56800_A0_EGR_MOD_MAP_TABLEm_PORT_OFFSETf_SET
#define EGR_MOD_MAP_TABLEm_MODIDf_GET BCM56800_A0_EGR_MOD_MAP_TABLEm_MODIDf_GET
#define EGR_MOD_MAP_TABLEm_MODIDf_SET BCM56800_A0_EGR_MOD_MAP_TABLEm_MODIDf_SET
#define READ_EGR_MOD_MAP_TABLEm BCM56800_A0_READ_EGR_MOD_MAP_TABLEm
#define WRITE_EGR_MOD_MAP_TABLEm BCM56800_A0_WRITE_EGR_MOD_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MOD_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_MTU_SIZE
 * BLOCKS:   IPIPE
 * DESC:     Egress MTU Size Register
 * SIZE:     32
 * FIELDS:
 *     MTU_SIZE         Egress ports MTU limit
 *     L3_MTU_SIZE      Egress ports L3 MTU limit
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_MTU_SIZEr 0x0e100662

#define BCM56800_A0_EGR_MTU_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program EGR_MTU_SIZE.
 *
 */
typedef union BCM56800_A0_EGR_MTU_SIZEr_s {
	uint32_t v[1];
	uint32_t egr_mtu_size[1];
	uint32_t _egr_mtu_size;
} BCM56800_A0_EGR_MTU_SIZEr_t;

#define BCM56800_A0_EGR_MTU_SIZEr_CLR(r) (r).egr_mtu_size[0] = 0
#define BCM56800_A0_EGR_MTU_SIZEr_SET(r,d) (r).egr_mtu_size[0] = d
#define BCM56800_A0_EGR_MTU_SIZEr_GET(r) (r).egr_mtu_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_MTU_SIZEr_MTU_SIZEf_GET(r) (((r).egr_mtu_size[0]) & 0x3fff)
#define BCM56800_A0_EGR_MTU_SIZEr_MTU_SIZEf_SET(r,f) (r).egr_mtu_size[0]=(((r).egr_mtu_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_EGR_MTU_SIZEr_L3_MTU_SIZEf_GET(r) ((((r).egr_mtu_size[0]) >> 14) & 0x3fff)
#define BCM56800_A0_EGR_MTU_SIZEr_L3_MTU_SIZEf_SET(r,f) (r).egr_mtu_size[0]=(((r).egr_mtu_size[0] & ~((uint32_t)0x3fff << 14)) | ((((uint32_t)f) & 0x3fff) << 14))

/*
 * These macros can be used to access EGR_MTU_SIZE.
 *
 */
#define BCM56800_A0_READ_EGR_MTU_SIZEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_MTU_SIZEr,(r._egr_mtu_size))
#define BCM56800_A0_WRITE_EGR_MTU_SIZEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_MTU_SIZEr,&(r._egr_mtu_size))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_MTU_SIZEr BCM56800_A0_EGR_MTU_SIZEr
#define EGR_MTU_SIZEr_SIZE BCM56800_A0_EGR_MTU_SIZEr_SIZE
typedef BCM56800_A0_EGR_MTU_SIZEr_t EGR_MTU_SIZEr_t;
#define EGR_MTU_SIZEr_CLR BCM56800_A0_EGR_MTU_SIZEr_CLR
#define EGR_MTU_SIZEr_SET BCM56800_A0_EGR_MTU_SIZEr_SET
#define EGR_MTU_SIZEr_GET BCM56800_A0_EGR_MTU_SIZEr_GET
#define EGR_MTU_SIZEr_MTU_SIZEf_GET BCM56800_A0_EGR_MTU_SIZEr_MTU_SIZEf_GET
#define EGR_MTU_SIZEr_MTU_SIZEf_SET BCM56800_A0_EGR_MTU_SIZEr_MTU_SIZEf_SET
#define EGR_MTU_SIZEr_L3_MTU_SIZEf_GET BCM56800_A0_EGR_MTU_SIZEr_L3_MTU_SIZEf_GET
#define EGR_MTU_SIZEr_L3_MTU_SIZEf_SET BCM56800_A0_EGR_MTU_SIZEr_L3_MTU_SIZEf_SET
#define READ_EGR_MTU_SIZEr BCM56800_A0_READ_EGR_MTU_SIZEr
#define WRITE_EGR_MTU_SIZEr BCM56800_A0_WRITE_EGR_MTU_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_MTU_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_PORT
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port. FeatureSpecific-Ethernet


 * SIZE:     32
 * FIELDS:
 *     PORT_TYPE        Specifies the type of the port. Bit[0] of PORT_TYPE field is HIGIG_BIT. If it is set, then the port is in Higig Mode.	0 = GE/10GE/CPU Port.	1 = HIGIG Port.Bit[1] of PORT_TYPE field is NNI_BIT. If it is set, then the port is NNI port, else UNI Port.	0 = UNI Port.	1 = NNI Port.
 *     EN_EFILTER       If this bit is set, the VLAN Membership check is done for the outgoing port.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     CFI              If CFI-CNG mapping is enabled for the chip, i.e. EGR_CONFIG.CFI_AS_CNG bit is set, then thisfield corresponds to the values of CNG coming from MMU. e.g. If MMU.CNG = 0, then Packet.CFI = CFI[0]     If MMU.CNG = 1, then Packet.CFI = CFI[1] and so on.
 *     EM_SRCMOD_CHANGE Set to change the src_modid for the egress mirrored pkts going out of the higig port.
 *     MY_MODID         Module ID of this chip.
 *     HIGIG2           Higig 2 thing.
 *     HIGIG_PACKET     This port is a higig port.
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_PORTr 0x01400602

#define BCM56800_A0_EGR_PORTr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT.
 *
 */
typedef union BCM56800_A0_EGR_PORTr_s {
	uint32_t v[1];
	uint32_t egr_port[1];
	uint32_t _egr_port;
} BCM56800_A0_EGR_PORTr_t;

#define BCM56800_A0_EGR_PORTr_CLR(r) (r).egr_port[0] = 0
#define BCM56800_A0_EGR_PORTr_SET(r,d) (r).egr_port[0] = d
#define BCM56800_A0_EGR_PORTr_GET(r) (r).egr_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_PORTr_PORT_TYPEf_GET(r) (((r).egr_port[0]) & 0x3)
#define BCM56800_A0_EGR_PORTr_PORT_TYPEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_EGR_PORTr_EN_EFILTERf_GET(r) ((((r).egr_port[0]) >> 2) & 0x1)
#define BCM56800_A0_EGR_PORTr_EN_EFILTERf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_EGR_PORTr_PRESERVE_CPU_TAGf_GET(r) ((((r).egr_port[0]) >> 3) & 0x1)
#define BCM56800_A0_EGR_PORTr_PRESERVE_CPU_TAGf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_EGR_PORTr_CFIf_GET(r) ((((r).egr_port[0]) >> 4) & 0xf)
#define BCM56800_A0_EGR_PORTr_CFIf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_GET(r) ((((r).egr_port[0]) >> 8) & 0x1)
#define BCM56800_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_EGR_PORTr_MY_MODIDf_GET(r) ((((r).egr_port[0]) >> 9) & 0x7f)
#define BCM56800_A0_EGR_PORTr_MY_MODIDf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM56800_A0_EGR_PORTr_HIGIG2f_GET(r) ((((r).egr_port[0]) >> 16) & 0x1)
#define BCM56800_A0_EGR_PORTr_HIGIG2f_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_EGR_PORTr_HIGIG_PACKETf_GET(r) (((r).egr_port[0]) & 0x1)
#define BCM56800_A0_EGR_PORTr_HIGIG_PACKETf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_PORTr_NNI_PORTf_GET(r) ((((r).egr_port[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_PORTr_NNI_PORTf_SET(r,f) (r).egr_port[0]=(((r).egr_port[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_PORT.
 *
 */
#define BCM56800_A0_READ_EGR_PORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_PORTr,(r._egr_port))
#define BCM56800_A0_WRITE_EGR_PORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_PORTr,&(r._egr_port))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORTr BCM56800_A0_EGR_PORTr
#define EGR_PORTr_SIZE BCM56800_A0_EGR_PORTr_SIZE
typedef BCM56800_A0_EGR_PORTr_t EGR_PORTr_t;
#define EGR_PORTr_CLR BCM56800_A0_EGR_PORTr_CLR
#define EGR_PORTr_SET BCM56800_A0_EGR_PORTr_SET
#define EGR_PORTr_GET BCM56800_A0_EGR_PORTr_GET
#define EGR_PORTr_PORT_TYPEf_GET BCM56800_A0_EGR_PORTr_PORT_TYPEf_GET
#define EGR_PORTr_PORT_TYPEf_SET BCM56800_A0_EGR_PORTr_PORT_TYPEf_SET
#define EGR_PORTr_EN_EFILTERf_GET BCM56800_A0_EGR_PORTr_EN_EFILTERf_GET
#define EGR_PORTr_EN_EFILTERf_SET BCM56800_A0_EGR_PORTr_EN_EFILTERf_SET
#define EGR_PORTr_PRESERVE_CPU_TAGf_GET BCM56800_A0_EGR_PORTr_PRESERVE_CPU_TAGf_GET
#define EGR_PORTr_PRESERVE_CPU_TAGf_SET BCM56800_A0_EGR_PORTr_PRESERVE_CPU_TAGf_SET
#define EGR_PORTr_CFIf_GET BCM56800_A0_EGR_PORTr_CFIf_GET
#define EGR_PORTr_CFIf_SET BCM56800_A0_EGR_PORTr_CFIf_SET
#define EGR_PORTr_EM_SRCMOD_CHANGEf_GET BCM56800_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_GET
#define EGR_PORTr_EM_SRCMOD_CHANGEf_SET BCM56800_A0_EGR_PORTr_EM_SRCMOD_CHANGEf_SET
#define EGR_PORTr_MY_MODIDf_GET BCM56800_A0_EGR_PORTr_MY_MODIDf_GET
#define EGR_PORTr_MY_MODIDf_SET BCM56800_A0_EGR_PORTr_MY_MODIDf_SET
#define EGR_PORTr_HIGIG2f_GET BCM56800_A0_EGR_PORTr_HIGIG2f_GET
#define EGR_PORTr_HIGIG2f_SET BCM56800_A0_EGR_PORTr_HIGIG2f_SET
#define EGR_PORTr_HIGIG_PACKETf_GET BCM56800_A0_EGR_PORTr_HIGIG_PACKETf_GET
#define EGR_PORTr_HIGIG_PACKETf_SET BCM56800_A0_EGR_PORTr_HIGIG_PACKETf_SET
#define EGR_PORTr_NNI_PORTf_GET BCM56800_A0_EGR_PORTr_NNI_PORTf_GET
#define EGR_PORTr_NNI_PORTf_SET BCM56800_A0_EGR_PORTr_NNI_PORTf_SET
#define READ_EGR_PORTr BCM56800_A0_READ_EGR_PORTr
#define WRITE_EGR_PORTr BCM56800_A0_WRITE_EGR_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_PORT_L3UC_MODS
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for IPMC related modifications. FeatureSpecific-Ethernet


 * SIZE:     32
 * FIELDS:
 *     L3_UC_SA_DISABLE Disable the SA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_DA_DISABLE Disable the DA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_TTL_DISABLE Disable the TTL decrement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_VLAN_DISABLE Disable the outer VID replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_PORT_L3UC_MODSr 0x01400607

#define BCM56800_A0_EGR_PORT_L3UC_MODSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_L3UC_MODS.
 *
 */
typedef union BCM56800_A0_EGR_PORT_L3UC_MODSr_s {
	uint32_t v[1];
	uint32_t egr_port_l3uc_mods[1];
	uint32_t _egr_port_l3uc_mods;
} BCM56800_A0_EGR_PORT_L3UC_MODSr_t;

#define BCM56800_A0_EGR_PORT_L3UC_MODSr_CLR(r) (r).egr_port_l3uc_mods[0] = 0
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_SET(r,d) (r).egr_port_l3uc_mods[0] = d
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_GET(r) (r).egr_port_l3uc_mods[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET(r) (((r).egr_port_l3uc_mods[0]) & 0x1)
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 2) & 0x1)
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET(r) ((((r).egr_port_l3uc_mods[0]) >> 3) & 0x1)
#define BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET(r,f) (r).egr_port_l3uc_mods[0]=(((r).egr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access EGR_PORT_L3UC_MODS.
 *
 */
#define BCM56800_A0_READ_EGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_PORT_L3UC_MODSr,(r._egr_port_l3uc_mods))
#define BCM56800_A0_WRITE_EGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_PORT_L3UC_MODSr,&(r._egr_port_l3uc_mods))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORT_L3UC_MODSr BCM56800_A0_EGR_PORT_L3UC_MODSr
#define EGR_PORT_L3UC_MODSr_SIZE BCM56800_A0_EGR_PORT_L3UC_MODSr_SIZE
typedef BCM56800_A0_EGR_PORT_L3UC_MODSr_t EGR_PORT_L3UC_MODSr_t;
#define EGR_PORT_L3UC_MODSr_CLR BCM56800_A0_EGR_PORT_L3UC_MODSr_CLR
#define EGR_PORT_L3UC_MODSr_SET BCM56800_A0_EGR_PORT_L3UC_MODSr_SET
#define EGR_PORT_L3UC_MODSr_GET BCM56800_A0_EGR_PORT_L3UC_MODSr_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET
#define EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET
#define EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET BCM56800_A0_EGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET
#define READ_EGR_PORT_L3UC_MODSr BCM56800_A0_READ_EGR_PORT_L3UC_MODSr
#define WRITE_EGR_PORT_L3UC_MODSr BCM56800_A0_WRITE_EGR_PORT_L3UC_MODSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_PORT_L3UC_MODSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_PORT_REQUESTS
 * BLOCKS:   EPIPE
 * DESC:     This register contains the cell requests asserted by individual ports from GPORT, XPORT, CMIC
blocks. Meaning of cell request is different for different ports, but this register has no
understanding of those meanings. All it shows is the number of times cell_request signal
was asserted by each port to TP. 

 * SIZE:     32
 * FIELDS:
 *     OUTSTANDING_PORT_REQUESTS Number of cell requests.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_PORT_REQUESTSr 0x0a4000f2

#define BCM56800_A0_EGR_PORT_REQUESTSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_PORT_REQUESTS.
 *
 */
typedef union BCM56800_A0_EGR_PORT_REQUESTSr_s {
	uint32_t v[1];
	uint32_t egr_port_requests[1];
	uint32_t _egr_port_requests;
} BCM56800_A0_EGR_PORT_REQUESTSr_t;

#define BCM56800_A0_EGR_PORT_REQUESTSr_CLR(r) (r).egr_port_requests[0] = 0
#define BCM56800_A0_EGR_PORT_REQUESTSr_SET(r,d) (r).egr_port_requests[0] = d
#define BCM56800_A0_EGR_PORT_REQUESTSr_GET(r) (r).egr_port_requests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET(r) (((r).egr_port_requests[0]) & 0xf)
#define BCM56800_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET(r,f) (r).egr_port_requests[0]=(((r).egr_port_requests[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access EGR_PORT_REQUESTS.
 *
 */
#define BCM56800_A0_READ_EGR_PORT_REQUESTSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_PORT_REQUESTSr,(r._egr_port_requests))
#define BCM56800_A0_WRITE_EGR_PORT_REQUESTSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_PORT_REQUESTSr,&(r._egr_port_requests))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_PORT_REQUESTSr BCM56800_A0_EGR_PORT_REQUESTSr
#define EGR_PORT_REQUESTSr_SIZE BCM56800_A0_EGR_PORT_REQUESTSr_SIZE
typedef BCM56800_A0_EGR_PORT_REQUESTSr_t EGR_PORT_REQUESTSr_t;
#define EGR_PORT_REQUESTSr_CLR BCM56800_A0_EGR_PORT_REQUESTSr_CLR
#define EGR_PORT_REQUESTSr_SET BCM56800_A0_EGR_PORT_REQUESTSr_SET
#define EGR_PORT_REQUESTSr_GET BCM56800_A0_EGR_PORT_REQUESTSr_GET
#define EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET BCM56800_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_GET
#define EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET BCM56800_A0_EGR_PORT_REQUESTSr_OUTSTANDING_PORT_REQUESTSf_SET
#define READ_EGR_PORT_REQUESTSr BCM56800_A0_READ_EGR_PORT_REQUESTSr
#define WRITE_EGR_PORT_REQUESTSr BCM56800_A0_WRITE_EGR_PORT_REQUESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_PORT_REQUESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_Q_BEGIN
 * BLOCKS:   EPIPE
 * DESC:     Register starts an EQ Bus which is provided for later ECO reasons, if any.

 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_Q_BEGINr 0x00480602

#define BCM56800_A0_EGR_Q_BEGINr_SIZE 4

/*
 * This structure should be used to declare and program EGR_Q_BEGIN.
 *
 */
typedef union BCM56800_A0_EGR_Q_BEGINr_s {
	uint32_t v[1];
	uint32_t egr_q_begin[1];
	uint32_t _egr_q_begin;
} BCM56800_A0_EGR_Q_BEGINr_t;

#define BCM56800_A0_EGR_Q_BEGINr_CLR(r) (r).egr_q_begin[0] = 0
#define BCM56800_A0_EGR_Q_BEGINr_SET(r,d) (r).egr_q_begin[0] = d
#define BCM56800_A0_EGR_Q_BEGINr_GET(r) (r).egr_q_begin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_Q_BEGINr_QBUSf_GET(r) ((r).egr_q_begin[0])
#define BCM56800_A0_EGR_Q_BEGINr_QBUSf_SET(r,f) (r).egr_q_begin[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_Q_BEGIN.
 *
 */
#define BCM56800_A0_READ_EGR_Q_BEGINr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_Q_BEGINr,(r._egr_q_begin))
#define BCM56800_A0_WRITE_EGR_Q_BEGINr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_Q_BEGINr,&(r._egr_q_begin))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_Q_BEGINr BCM56800_A0_EGR_Q_BEGINr
#define EGR_Q_BEGINr_SIZE BCM56800_A0_EGR_Q_BEGINr_SIZE
typedef BCM56800_A0_EGR_Q_BEGINr_t EGR_Q_BEGINr_t;
#define EGR_Q_BEGINr_CLR BCM56800_A0_EGR_Q_BEGINr_CLR
#define EGR_Q_BEGINr_SET BCM56800_A0_EGR_Q_BEGINr_SET
#define EGR_Q_BEGINr_GET BCM56800_A0_EGR_Q_BEGINr_GET
#define EGR_Q_BEGINr_QBUSf_GET BCM56800_A0_EGR_Q_BEGINr_QBUSf_GET
#define EGR_Q_BEGINr_QBUSf_SET BCM56800_A0_EGR_Q_BEGINr_QBUSf_SET
#define READ_EGR_Q_BEGINr BCM56800_A0_READ_EGR_Q_BEGINr
#define WRITE_EGR_Q_BEGINr BCM56800_A0_WRITE_EGR_Q_BEGINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_Q_BEGINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_Q_END
 * BLOCKS:   EPIPE
 * DESC:     Register starts an EQ Bus which is provided for later ECO reasons, if any.

 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_Q_ENDr 0x0a4806f4

#define BCM56800_A0_EGR_Q_ENDr_SIZE 4

/*
 * This structure should be used to declare and program EGR_Q_END.
 *
 */
typedef union BCM56800_A0_EGR_Q_ENDr_s {
	uint32_t v[1];
	uint32_t egr_q_end[1];
	uint32_t _egr_q_end;
} BCM56800_A0_EGR_Q_ENDr_t;

#define BCM56800_A0_EGR_Q_ENDr_CLR(r) (r).egr_q_end[0] = 0
#define BCM56800_A0_EGR_Q_ENDr_SET(r,d) (r).egr_q_end[0] = d
#define BCM56800_A0_EGR_Q_ENDr_GET(r) (r).egr_q_end[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_Q_ENDr_QBUSf_GET(r) ((r).egr_q_end[0])
#define BCM56800_A0_EGR_Q_ENDr_QBUSf_SET(r,f) (r).egr_q_end[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_Q_END.
 *
 */
#define BCM56800_A0_READ_EGR_Q_ENDr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_Q_ENDr,(r._egr_q_end))
#define BCM56800_A0_WRITE_EGR_Q_ENDr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_Q_ENDr,&(r._egr_q_end))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_Q_ENDr BCM56800_A0_EGR_Q_ENDr
#define EGR_Q_ENDr_SIZE BCM56800_A0_EGR_Q_ENDr_SIZE
typedef BCM56800_A0_EGR_Q_ENDr_t EGR_Q_ENDr_t;
#define EGR_Q_ENDr_CLR BCM56800_A0_EGR_Q_ENDr_CLR
#define EGR_Q_ENDr_SET BCM56800_A0_EGR_Q_ENDr_SET
#define EGR_Q_ENDr_GET BCM56800_A0_EGR_Q_ENDr_GET
#define EGR_Q_ENDr_QBUSf_GET BCM56800_A0_EGR_Q_ENDr_QBUSf_GET
#define EGR_Q_ENDr_QBUSf_SET BCM56800_A0_EGR_Q_ENDr_QBUSf_SET
#define READ_EGR_Q_ENDr BCM56800_A0_READ_EGR_Q_ENDr
#define WRITE_EGR_Q_ENDr BCM56800_A0_WRITE_EGR_Q_ENDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_Q_ENDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_RSPAN_VLAN_TAG
 * BLOCKS:   EPIPE
 * DESC:     For RSPAN feature, the vlan tag is picked up from here.


 * SIZE:     32
 * FIELDS:
 *     TAG              This field contains the entire 4 bytes (32 bits wide) tag to be added to the packet for RSPAN.The way it should be programmed is, 	TAG[31:16] = TPID,Tpid to be used when rspan tag will be added in the packet modifier. 	TAG[15:13] = Priority to be used when rspan tag will be added in the packet modifier. 	TAG[12]    = CFI to be used when rspan tag will be added in the packet modifier. 	TAG[11:0]  = VID to be used when rspan tag will be added in the packet modifier. If TAG is all zero then it means we do not add the rspan tag.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_RSPAN_VLAN_TAGr 0x09400000

#define BCM56800_A0_EGR_RSPAN_VLAN_TAGr_SIZE 4

/*
 * This structure should be used to declare and program EGR_RSPAN_VLAN_TAG.
 *
 */
typedef union BCM56800_A0_EGR_RSPAN_VLAN_TAGr_s {
	uint32_t v[1];
	uint32_t egr_rspan_vlan_tag[1];
	uint32_t _egr_rspan_vlan_tag;
} BCM56800_A0_EGR_RSPAN_VLAN_TAGr_t;

#define BCM56800_A0_EGR_RSPAN_VLAN_TAGr_CLR(r) (r).egr_rspan_vlan_tag[0] = 0
#define BCM56800_A0_EGR_RSPAN_VLAN_TAGr_SET(r,d) (r).egr_rspan_vlan_tag[0] = d
#define BCM56800_A0_EGR_RSPAN_VLAN_TAGr_GET(r) (r).egr_rspan_vlan_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_RSPAN_VLAN_TAGr_TAGf_GET(r) ((r).egr_rspan_vlan_tag[0])
#define BCM56800_A0_EGR_RSPAN_VLAN_TAGr_TAGf_SET(r,f) (r).egr_rspan_vlan_tag[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_RSPAN_VLAN_TAG.
 *
 */
#define BCM56800_A0_READ_EGR_RSPAN_VLAN_TAGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_RSPAN_VLAN_TAGr,(r._egr_rspan_vlan_tag))
#define BCM56800_A0_WRITE_EGR_RSPAN_VLAN_TAGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_RSPAN_VLAN_TAGr,&(r._egr_rspan_vlan_tag))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_RSPAN_VLAN_TAGr BCM56800_A0_EGR_RSPAN_VLAN_TAGr
#define EGR_RSPAN_VLAN_TAGr_SIZE BCM56800_A0_EGR_RSPAN_VLAN_TAGr_SIZE
typedef BCM56800_A0_EGR_RSPAN_VLAN_TAGr_t EGR_RSPAN_VLAN_TAGr_t;
#define EGR_RSPAN_VLAN_TAGr_CLR BCM56800_A0_EGR_RSPAN_VLAN_TAGr_CLR
#define EGR_RSPAN_VLAN_TAGr_SET BCM56800_A0_EGR_RSPAN_VLAN_TAGr_SET
#define EGR_RSPAN_VLAN_TAGr_GET BCM56800_A0_EGR_RSPAN_VLAN_TAGr_GET
#define EGR_RSPAN_VLAN_TAGr_TAGf_GET BCM56800_A0_EGR_RSPAN_VLAN_TAGr_TAGf_GET
#define EGR_RSPAN_VLAN_TAGr_TAGf_SET BCM56800_A0_EGR_RSPAN_VLAN_TAGr_TAGf_SET
#define READ_EGR_RSPAN_VLAN_TAGr BCM56800_A0_READ_EGR_RSPAN_VLAN_TAGr
#define WRITE_EGR_RSPAN_VLAN_TAGr BCM56800_A0_WRITE_EGR_RSPAN_VLAN_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_RSPAN_VLAN_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_SBS_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     EP sbs control reg to select the pipe for acc_type 6 regs and mems
 * SIZE:     32
 * FIELDS:
 *     PIPE_SELECT      For shadow register reads and registers access type 6 registers write an read.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_SBS_CONTROLr 0x0b480600

#define BCM56800_A0_EGR_SBS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_SBS_CONTROL.
 *
 */
typedef union BCM56800_A0_EGR_SBS_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_sbs_control[1];
	uint32_t _egr_sbs_control;
} BCM56800_A0_EGR_SBS_CONTROLr_t;

#define BCM56800_A0_EGR_SBS_CONTROLr_CLR(r) (r).egr_sbs_control[0] = 0
#define BCM56800_A0_EGR_SBS_CONTROLr_SET(r,d) (r).egr_sbs_control[0] = d
#define BCM56800_A0_EGR_SBS_CONTROLr_GET(r) (r).egr_sbs_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_SBS_CONTROLr_PIPE_SELECTf_GET(r) (((r).egr_sbs_control[0]) & 0x1)
#define BCM56800_A0_EGR_SBS_CONTROLr_PIPE_SELECTf_SET(r,f) (r).egr_sbs_control[0]=(((r).egr_sbs_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access EGR_SBS_CONTROL.
 *
 */
#define BCM56800_A0_READ_EGR_SBS_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_SBS_CONTROLr,(r._egr_sbs_control))
#define BCM56800_A0_WRITE_EGR_SBS_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_SBS_CONTROLr,&(r._egr_sbs_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_SBS_CONTROLr BCM56800_A0_EGR_SBS_CONTROLr
#define EGR_SBS_CONTROLr_SIZE BCM56800_A0_EGR_SBS_CONTROLr_SIZE
typedef BCM56800_A0_EGR_SBS_CONTROLr_t EGR_SBS_CONTROLr_t;
#define EGR_SBS_CONTROLr_CLR BCM56800_A0_EGR_SBS_CONTROLr_CLR
#define EGR_SBS_CONTROLr_SET BCM56800_A0_EGR_SBS_CONTROLr_SET
#define EGR_SBS_CONTROLr_GET BCM56800_A0_EGR_SBS_CONTROLr_GET
#define EGR_SBS_CONTROLr_PIPE_SELECTf_GET BCM56800_A0_EGR_SBS_CONTROLr_PIPE_SELECTf_GET
#define EGR_SBS_CONTROLr_PIPE_SELECTf_SET BCM56800_A0_EGR_SBS_CONTROLr_PIPE_SELECTf_SET
#define READ_EGR_SBS_CONTROLr BCM56800_A0_READ_EGR_SBS_CONTROLr
#define WRITE_EGR_SBS_CONTROLr BCM56800_A0_WRITE_EGR_SBS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_SBS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_SF_SRC_MODID_CHECK
 * BLOCKS:   EPIPE
 * DESC:     Module Mapping Control

 * SIZE:     32
 * FIELDS:
 *     MODID0           Module Id.
 *     SF_MODID0        Module Id.
 *     SF_MODID0_VALID  Module Id.
 *     MODID1           Module Id.
 *     SF_MODID1        Enables the module remapping feature.
 *     SF_MODID1_VALID  Module Id.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr 0x08400005

#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SIZE 4

/*
 * This structure should be used to declare and program EGR_SF_SRC_MODID_CHECK.
 *
 */
typedef union BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_s {
	uint32_t v[1];
	uint32_t egr_sf_src_modid_check[1];
	uint32_t _egr_sf_src_modid_check;
} BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_t;

#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_CLR(r) (r).egr_sf_src_modid_check[0] = 0
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SET(r,d) (r).egr_sf_src_modid_check[0] = d
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_GET(r) (r).egr_sf_src_modid_check[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_MODID0f_GET(r) (((r).egr_sf_src_modid_check[0]) & 0x3f)
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_MODID0f_SET(r,f) (r).egr_sf_src_modid_check[0]=(((r).egr_sf_src_modid_check[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID0f_GET(r) ((((r).egr_sf_src_modid_check[0]) >> 6) & 0x7f)
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID0f_SET(r,f) (r).egr_sf_src_modid_check[0]=(((r).egr_sf_src_modid_check[0] & ~((uint32_t)0x7f << 6)) | ((((uint32_t)f) & 0x7f) << 6))
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID0_VALIDf_GET(r) ((((r).egr_sf_src_modid_check[0]) >> 13) & 0x1)
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID0_VALIDf_SET(r,f) (r).egr_sf_src_modid_check[0]=(((r).egr_sf_src_modid_check[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_MODID1f_GET(r) ((((r).egr_sf_src_modid_check[0]) >> 14) & 0x3f)
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_MODID1f_SET(r,f) (r).egr_sf_src_modid_check[0]=(((r).egr_sf_src_modid_check[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID1f_GET(r) ((((r).egr_sf_src_modid_check[0]) >> 20) & 0x7f)
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID1f_SET(r,f) (r).egr_sf_src_modid_check[0]=(((r).egr_sf_src_modid_check[0] & ~((uint32_t)0x7f << 20)) | ((((uint32_t)f) & 0x7f) << 20))
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID1_VALIDf_GET(r) ((((r).egr_sf_src_modid_check[0]) >> 27) & 0x1)
#define BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID1_VALIDf_SET(r,f) (r).egr_sf_src_modid_check[0]=(((r).egr_sf_src_modid_check[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))

/*
 * These macros can be used to access EGR_SF_SRC_MODID_CHECK.
 *
 */
#define BCM56800_A0_READ_EGR_SF_SRC_MODID_CHECKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_SF_SRC_MODID_CHECKr,(r._egr_sf_src_modid_check))
#define BCM56800_A0_WRITE_EGR_SF_SRC_MODID_CHECKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_SF_SRC_MODID_CHECKr,&(r._egr_sf_src_modid_check))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_SF_SRC_MODID_CHECKr BCM56800_A0_EGR_SF_SRC_MODID_CHECKr
#define EGR_SF_SRC_MODID_CHECKr_SIZE BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SIZE
typedef BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_t EGR_SF_SRC_MODID_CHECKr_t;
#define EGR_SF_SRC_MODID_CHECKr_CLR BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_CLR
#define EGR_SF_SRC_MODID_CHECKr_SET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SET
#define EGR_SF_SRC_MODID_CHECKr_GET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_GET
#define EGR_SF_SRC_MODID_CHECKr_MODID0f_GET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_MODID0f_GET
#define EGR_SF_SRC_MODID_CHECKr_MODID0f_SET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_MODID0f_SET
#define EGR_SF_SRC_MODID_CHECKr_SF_MODID0f_GET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID0f_GET
#define EGR_SF_SRC_MODID_CHECKr_SF_MODID0f_SET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID0f_SET
#define EGR_SF_SRC_MODID_CHECKr_SF_MODID0_VALIDf_GET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID0_VALIDf_GET
#define EGR_SF_SRC_MODID_CHECKr_SF_MODID0_VALIDf_SET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID0_VALIDf_SET
#define EGR_SF_SRC_MODID_CHECKr_MODID1f_GET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_MODID1f_GET
#define EGR_SF_SRC_MODID_CHECKr_MODID1f_SET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_MODID1f_SET
#define EGR_SF_SRC_MODID_CHECKr_SF_MODID1f_GET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID1f_GET
#define EGR_SF_SRC_MODID_CHECKr_SF_MODID1f_SET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID1f_SET
#define EGR_SF_SRC_MODID_CHECKr_SF_MODID1_VALIDf_GET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID1_VALIDf_GET
#define EGR_SF_SRC_MODID_CHECKr_SF_MODID1_VALIDf_SET BCM56800_A0_EGR_SF_SRC_MODID_CHECKr_SF_MODID1_VALIDf_SET
#define READ_EGR_SF_SRC_MODID_CHECKr BCM56800_A0_READ_EGR_SF_SRC_MODID_CHECKr
#define WRITE_EGR_SF_SRC_MODID_CHECKr BCM56800_A0_WRITE_EGR_SF_SRC_MODID_CHECKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_SF_SRC_MODID_CHECKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_SHAPING_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     Specifies control fields Egress for the Shaping Counters.

 * SIZE:     32
 * FIELDS:
 *     PACKET_IFG_BYTES Number of Preamble and IFG bytes to be added in the Shaping counters.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_SHAPING_CONTROLr 0x0a4806f5

#define BCM56800_A0_EGR_SHAPING_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_SHAPING_CONTROL.
 *
 */
typedef union BCM56800_A0_EGR_SHAPING_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_shaping_control[1];
	uint32_t _egr_shaping_control;
} BCM56800_A0_EGR_SHAPING_CONTROLr_t;

#define BCM56800_A0_EGR_SHAPING_CONTROLr_CLR(r) (r).egr_shaping_control[0] = 0
#define BCM56800_A0_EGR_SHAPING_CONTROLr_SET(r,d) (r).egr_shaping_control[0] = d
#define BCM56800_A0_EGR_SHAPING_CONTROLr_GET(r) (r).egr_shaping_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET(r) (((r).egr_shaping_control[0]) & 0x1f)
#define BCM56800_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET(r,f) (r).egr_shaping_control[0]=(((r).egr_shaping_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access EGR_SHAPING_CONTROL.
 *
 */
#define BCM56800_A0_READ_EGR_SHAPING_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_SHAPING_CONTROLr,(r._egr_shaping_control))
#define BCM56800_A0_WRITE_EGR_SHAPING_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_SHAPING_CONTROLr,&(r._egr_shaping_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_SHAPING_CONTROLr BCM56800_A0_EGR_SHAPING_CONTROLr
#define EGR_SHAPING_CONTROLr_SIZE BCM56800_A0_EGR_SHAPING_CONTROLr_SIZE
typedef BCM56800_A0_EGR_SHAPING_CONTROLr_t EGR_SHAPING_CONTROLr_t;
#define EGR_SHAPING_CONTROLr_CLR BCM56800_A0_EGR_SHAPING_CONTROLr_CLR
#define EGR_SHAPING_CONTROLr_SET BCM56800_A0_EGR_SHAPING_CONTROLr_SET
#define EGR_SHAPING_CONTROLr_GET BCM56800_A0_EGR_SHAPING_CONTROLr_GET
#define EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET BCM56800_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_GET
#define EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET BCM56800_A0_EGR_SHAPING_CONTROLr_PACKET_IFG_BYTESf_SET
#define READ_EGR_SHAPING_CONTROLr BCM56800_A0_READ_EGR_SHAPING_CONTROLr
#define WRITE_EGR_SHAPING_CONTROLr BCM56800_A0_WRITE_EGR_SHAPING_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_SHAPING_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_TUNNEL_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     Global ID value for Tunnel Pkts. This value is passed in the pkt whenever tunnel
is encapsulated in a packet in Transmit Pipeline. FeatureSpecific-Ethernet


 * SIZE:     32
 * FIELDS:
 *     IPV4_ID          Global id to be inserted in the packet. This is the running ID, i.e. whenever a pkt is transmitted, the value is incremented here.
 *     START_IPV4_ID    Global ID written by CPU. This is written by logic when CPU writes to the IPV4_ID field. After that START_IPV4_ID field remains constant, which is useful for debugging to see what was the starting id for this chip, as IPV4_ID keeps on changing with each encapped packet.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_TUNNEL_CONTROLr 0x07480600

#define BCM56800_A0_EGR_TUNNEL_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_CONTROL.
 *
 */
typedef union BCM56800_A0_EGR_TUNNEL_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_tunnel_control[1];
	uint32_t _egr_tunnel_control;
} BCM56800_A0_EGR_TUNNEL_CONTROLr_t;

#define BCM56800_A0_EGR_TUNNEL_CONTROLr_CLR(r) (r).egr_tunnel_control[0] = 0
#define BCM56800_A0_EGR_TUNNEL_CONTROLr_SET(r,d) (r).egr_tunnel_control[0] = d
#define BCM56800_A0_EGR_TUNNEL_CONTROLr_GET(r) (r).egr_tunnel_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_GET(r) (((r).egr_tunnel_control[0]) & 0xffff)
#define BCM56800_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_SET(r,f) (r).egr_tunnel_control[0]=(((r).egr_tunnel_control[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET(r) ((((r).egr_tunnel_control[0]) >> 16) & 0xffff)
#define BCM56800_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET(r,f) (r).egr_tunnel_control[0]=(((r).egr_tunnel_control[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access EGR_TUNNEL_CONTROL.
 *
 */
#define BCM56800_A0_READ_EGR_TUNNEL_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_TUNNEL_CONTROLr,(r._egr_tunnel_control))
#define BCM56800_A0_WRITE_EGR_TUNNEL_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_TUNNEL_CONTROLr,&(r._egr_tunnel_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_CONTROLr BCM56800_A0_EGR_TUNNEL_CONTROLr
#define EGR_TUNNEL_CONTROLr_SIZE BCM56800_A0_EGR_TUNNEL_CONTROLr_SIZE
typedef BCM56800_A0_EGR_TUNNEL_CONTROLr_t EGR_TUNNEL_CONTROLr_t;
#define EGR_TUNNEL_CONTROLr_CLR BCM56800_A0_EGR_TUNNEL_CONTROLr_CLR
#define EGR_TUNNEL_CONTROLr_SET BCM56800_A0_EGR_TUNNEL_CONTROLr_SET
#define EGR_TUNNEL_CONTROLr_GET BCM56800_A0_EGR_TUNNEL_CONTROLr_GET
#define EGR_TUNNEL_CONTROLr_IPV4_IDf_GET BCM56800_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_GET
#define EGR_TUNNEL_CONTROLr_IPV4_IDf_SET BCM56800_A0_EGR_TUNNEL_CONTROLr_IPV4_IDf_SET
#define EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET BCM56800_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_GET
#define EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET BCM56800_A0_EGR_TUNNEL_CONTROLr_START_IPV4_IDf_SET
#define READ_EGR_TUNNEL_CONTROLr BCM56800_A0_READ_EGR_TUNNEL_CONTROLr
#define WRITE_EGR_TUNNEL_CONTROLr BCM56800_A0_WRITE_EGR_TUNNEL_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_TUNNEL_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_TUNNEL_ID_MASK
 * BLOCKS:   EPIPE
 * DESC:     Global ID mask value for Tunnel Pkts. FeatureSpecific-Ethernet


 * SIZE:     32
 * FIELDS:
 *     IPV4_ID_MASK     Global id mask to be used before inserting the tag in the packet.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_TUNNEL_ID_MASKr 0x07480601

#define BCM56800_A0_EGR_TUNNEL_ID_MASKr_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_ID_MASK.
 *
 */
typedef union BCM56800_A0_EGR_TUNNEL_ID_MASKr_s {
	uint32_t v[1];
	uint32_t egr_tunnel_id_mask[1];
	uint32_t _egr_tunnel_id_mask;
} BCM56800_A0_EGR_TUNNEL_ID_MASKr_t;

#define BCM56800_A0_EGR_TUNNEL_ID_MASKr_CLR(r) (r).egr_tunnel_id_mask[0] = 0
#define BCM56800_A0_EGR_TUNNEL_ID_MASKr_SET(r,d) (r).egr_tunnel_id_mask[0] = d
#define BCM56800_A0_EGR_TUNNEL_ID_MASKr_GET(r) (r).egr_tunnel_id_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET(r) (((r).egr_tunnel_id_mask[0]) & 0xffff)
#define BCM56800_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET(r,f) (r).egr_tunnel_id_mask[0]=(((r).egr_tunnel_id_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_TUNNEL_ID_MASK.
 *
 */
#define BCM56800_A0_READ_EGR_TUNNEL_ID_MASKr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_TUNNEL_ID_MASKr,(r._egr_tunnel_id_mask))
#define BCM56800_A0_WRITE_EGR_TUNNEL_ID_MASKr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_TUNNEL_ID_MASKr,&(r._egr_tunnel_id_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_ID_MASKr BCM56800_A0_EGR_TUNNEL_ID_MASKr
#define EGR_TUNNEL_ID_MASKr_SIZE BCM56800_A0_EGR_TUNNEL_ID_MASKr_SIZE
typedef BCM56800_A0_EGR_TUNNEL_ID_MASKr_t EGR_TUNNEL_ID_MASKr_t;
#define EGR_TUNNEL_ID_MASKr_CLR BCM56800_A0_EGR_TUNNEL_ID_MASKr_CLR
#define EGR_TUNNEL_ID_MASKr_SET BCM56800_A0_EGR_TUNNEL_ID_MASKr_SET
#define EGR_TUNNEL_ID_MASKr_GET BCM56800_A0_EGR_TUNNEL_ID_MASKr_GET
#define EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET BCM56800_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_GET
#define EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET BCM56800_A0_EGR_TUNNEL_ID_MASKr_IPV4_ID_MASKf_SET
#define READ_EGR_TUNNEL_ID_MASKr BCM56800_A0_READ_EGR_TUNNEL_ID_MASKr
#define WRITE_EGR_TUNNEL_ID_MASKr BCM56800_A0_WRITE_EGR_TUNNEL_ID_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_TUNNEL_ID_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_TUNNEL_PIMDR1_CFG0
 * BLOCKS:   EPIPE
 * DESC:     For PIMSM-DR1 type of tunnel pkts, MS 4 bytes are specified here, so that they
can be inserted in the packet. FeatureSpecific-Ethernet

 * SIZE:     32
 * FIELDS:
 *     MS_PIMSM_HDR     Specifies the MS 32 bits of the PIMSM-DR1 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r 0x08480600

#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR1_CFG0.
 *
 */
typedef union BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr1_cfg0[1];
	uint32_t _egr_tunnel_pimdr1_cfg0;
} BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_t;

#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_CLR(r) (r).egr_tunnel_pimdr1_cfg0[0] = 0
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_SET(r,d) (r).egr_tunnel_pimdr1_cfg0[0] = d
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_GET(r) (r).egr_tunnel_pimdr1_cfg0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr1_cfg0[0])
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr1_cfg0[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR1_CFG0.
 *
 */
#define BCM56800_A0_READ_EGR_TUNNEL_PIMDR1_CFG0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r,(r._egr_tunnel_pimdr1_cfg0))
#define BCM56800_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r,&(r._egr_tunnel_pimdr1_cfg0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR1_CFG0r BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r
#define EGR_TUNNEL_PIMDR1_CFG0r_SIZE BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_SIZE
typedef BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_t EGR_TUNNEL_PIMDR1_CFG0r_t;
#define EGR_TUNNEL_PIMDR1_CFG0r_CLR BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_CLR
#define EGR_TUNNEL_PIMDR1_CFG0r_SET BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_SET
#define EGR_TUNNEL_PIMDR1_CFG0r_GET BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_GET
#define EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r_MS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR1_CFG0r BCM56800_A0_READ_EGR_TUNNEL_PIMDR1_CFG0r
#define WRITE_EGR_TUNNEL_PIMDR1_CFG0r BCM56800_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_TUNNEL_PIMDR1_CFG1
 * BLOCKS:   EPIPE
 * DESC:     For PIMSM-DR1 type of tunnel pkts, LS 4 bytes are specified here, so that they
can be inserted in the packet. FeatureSpecific-Ethernet

 * SIZE:     32
 * FIELDS:
 *     LS_PIMSM_HDR     Specifies the LS 32 bits of the PIMSM-DR1 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r 0x08480601

#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR1_CFG1.
 *
 */
typedef union BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr1_cfg1[1];
	uint32_t _egr_tunnel_pimdr1_cfg1;
} BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_t;

#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_CLR(r) (r).egr_tunnel_pimdr1_cfg1[0] = 0
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_SET(r,d) (r).egr_tunnel_pimdr1_cfg1[0] = d
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_GET(r) (r).egr_tunnel_pimdr1_cfg1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr1_cfg1[0])
#define BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr1_cfg1[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR1_CFG1.
 *
 */
#define BCM56800_A0_READ_EGR_TUNNEL_PIMDR1_CFG1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r,(r._egr_tunnel_pimdr1_cfg1))
#define BCM56800_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r,&(r._egr_tunnel_pimdr1_cfg1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR1_CFG1r BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r
#define EGR_TUNNEL_PIMDR1_CFG1r_SIZE BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_SIZE
typedef BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_t EGR_TUNNEL_PIMDR1_CFG1r_t;
#define EGR_TUNNEL_PIMDR1_CFG1r_CLR BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_CLR
#define EGR_TUNNEL_PIMDR1_CFG1r_SET BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_SET
#define EGR_TUNNEL_PIMDR1_CFG1r_GET BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_GET
#define EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r_LS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR1_CFG1r BCM56800_A0_READ_EGR_TUNNEL_PIMDR1_CFG1r
#define WRITE_EGR_TUNNEL_PIMDR1_CFG1r BCM56800_A0_WRITE_EGR_TUNNEL_PIMDR1_CFG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_TUNNEL_PIMDR1_CFG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_TUNNEL_PIMDR2_CFG0
 * BLOCKS:   EPIPE
 * DESC:     For PIMSM-DR2 type of tunnel pkts, MS 4 bytes are specified here, so that they
can be inserted in the packet. FeatureSpecific-Ethernet

 * SIZE:     32
 * FIELDS:
 *     MS_PIMSM_HDR     Specifies the MS 32 bits PIMSM-DR2 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r 0x08480602

#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR2_CFG0.
 *
 */
typedef union BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr2_cfg0[1];
	uint32_t _egr_tunnel_pimdr2_cfg0;
} BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_t;

#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_CLR(r) (r).egr_tunnel_pimdr2_cfg0[0] = 0
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_SET(r,d) (r).egr_tunnel_pimdr2_cfg0[0] = d
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_GET(r) (r).egr_tunnel_pimdr2_cfg0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr2_cfg0[0])
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr2_cfg0[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR2_CFG0.
 *
 */
#define BCM56800_A0_READ_EGR_TUNNEL_PIMDR2_CFG0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r,(r._egr_tunnel_pimdr2_cfg0))
#define BCM56800_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r,&(r._egr_tunnel_pimdr2_cfg0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR2_CFG0r BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r
#define EGR_TUNNEL_PIMDR2_CFG0r_SIZE BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_SIZE
typedef BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_t EGR_TUNNEL_PIMDR2_CFG0r_t;
#define EGR_TUNNEL_PIMDR2_CFG0r_CLR BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_CLR
#define EGR_TUNNEL_PIMDR2_CFG0r_SET BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_SET
#define EGR_TUNNEL_PIMDR2_CFG0r_GET BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_GET
#define EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r_MS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR2_CFG0r BCM56800_A0_READ_EGR_TUNNEL_PIMDR2_CFG0r
#define WRITE_EGR_TUNNEL_PIMDR2_CFG0r BCM56800_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_TUNNEL_PIMDR2_CFG1
 * BLOCKS:   EPIPE
 * DESC:     For PIMSM-DR2 type of tunnel pkts, LS 4 bytes are specified here, so that they
can be inserted in the packet. FeatureSpecific-Ethernet

 * SIZE:     32
 * FIELDS:
 *     LS_PIMSM_HDR     Specifies the LS 32 bits PIMSM-DR2 Header, which needs to be inserted in the packet, if tunnel table search results in pkt encap.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r 0x08480603

#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_TUNNEL_PIMDR2_CFG1.
 *
 */
typedef union BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_s {
	uint32_t v[1];
	uint32_t egr_tunnel_pimdr2_cfg1[1];
	uint32_t _egr_tunnel_pimdr2_cfg1;
} BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_t;

#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_CLR(r) (r).egr_tunnel_pimdr2_cfg1[0] = 0
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_SET(r,d) (r).egr_tunnel_pimdr2_cfg1[0] = d
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_GET(r) (r).egr_tunnel_pimdr2_cfg1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET(r) ((r).egr_tunnel_pimdr2_cfg1[0])
#define BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET(r,f) (r).egr_tunnel_pimdr2_cfg1[0]=((uint32_t)f)

/*
 * These macros can be used to access EGR_TUNNEL_PIMDR2_CFG1.
 *
 */
#define BCM56800_A0_READ_EGR_TUNNEL_PIMDR2_CFG1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r,(r._egr_tunnel_pimdr2_cfg1))
#define BCM56800_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r,&(r._egr_tunnel_pimdr2_cfg1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_TUNNEL_PIMDR2_CFG1r BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r
#define EGR_TUNNEL_PIMDR2_CFG1r_SIZE BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_SIZE
typedef BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_t EGR_TUNNEL_PIMDR2_CFG1r_t;
#define EGR_TUNNEL_PIMDR2_CFG1r_CLR BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_CLR
#define EGR_TUNNEL_PIMDR2_CFG1r_SET BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_SET
#define EGR_TUNNEL_PIMDR2_CFG1r_GET BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_GET
#define EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_GET
#define EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r_LS_PIMSM_HDRf_SET
#define READ_EGR_TUNNEL_PIMDR2_CFG1r BCM56800_A0_READ_EGR_TUNNEL_PIMDR2_CFG1r
#define WRITE_EGR_TUNNEL_PIMDR2_CFG1r BCM56800_A0_WRITE_EGR_TUNNEL_PIMDR2_CFG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_TUNNEL_PIMDR2_CFG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_VLAN
 * BLOCKS:   EPIPE EPIPE
 * DESC:     Vlan Membership Table for Egress
 * SIZE:     51
 * FIELDS:
 *     UT_BITMAP        Alias for UT_PORT_BITMAP
 *     PORT_BITMAP      Indiactes which port is member of this VLAN.  A bit for CPU is needed.
 *     STG              Spanning Tree Group Number. To be used for indexing VLAN_STG table.
 *     VALID            Indicates if the entry is valid.
 *     EVEN_PARITY      PARITY BIT to make the entry parity even
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLANm 0x04461000

#define BCM56800_A0_EGR_VLANm_MIN 0
#define BCM56800_A0_EGR_VLANm_MAX 4095
#define BCM56800_A0_EGR_VLANm_CMAX(u) 4095
#define BCM56800_A0_EGR_VLANm_SIZE 7

/*
 * This structure should be used to declare and program EGR_VLAN.
 *
 */
typedef union BCM56800_A0_EGR_VLANm_s {
	uint32_t v[2];
	uint32_t egr_vlan[2];
	uint32_t _egr_vlan;
} BCM56800_A0_EGR_VLANm_t;

#define BCM56800_A0_EGR_VLANm_CLR(r) CDK_MEMSET(&((r)._egr_vlan), 0, sizeof(BCM56800_A0_EGR_VLANm_t))
#define BCM56800_A0_EGR_VLANm_SET(r,i,d) (r).egr_vlan[i] = d
#define BCM56800_A0_EGR_VLANm_GET(r,i) (r).egr_vlan[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLANm_UT_BITMAPf_GET(r) (((r).egr_vlan[0]) & 0xfffff)
#define BCM56800_A0_EGR_VLANm_UT_BITMAPf_SET(r,f) (r).egr_vlan[0]=(((r).egr_vlan[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM56800_A0_EGR_VLANm_PORT_BITMAPf_GET(r) cdk_field32_get((r).egr_vlan,20,40)
#define BCM56800_A0_EGR_VLANm_PORT_BITMAPf_SET(r,f) cdk_field32_set((r).egr_vlan,20,40,f)
#define BCM56800_A0_EGR_VLANm_STGf_GET(r) ((((r).egr_vlan[1]) >> 9) & 0xff)
#define BCM56800_A0_EGR_VLANm_STGf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0xff << 9)) | ((((uint32_t)f) & 0xff) << 9))
#define BCM56800_A0_EGR_VLANm_VALIDf_GET(r) ((((r).egr_vlan[1]) >> 17) & 0x1)
#define BCM56800_A0_EGR_VLANm_VALIDf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_EGR_VLANm_EVEN_PARITYf_GET(r) ((((r).egr_vlan[1]) >> 18) & 0x1)
#define BCM56800_A0_EGR_VLANm_EVEN_PARITYf_SET(r,f) (r).egr_vlan[1]=(((r).egr_vlan[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_VLAN.
 *
 */
#define BCM56800_A0_READ_EGR_VLANm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_VLANm,i,(m._egr_vlan),2)
#define BCM56800_A0_WRITE_EGR_VLANm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_VLANm,i,&(m._egr_vlan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLANm BCM56800_A0_EGR_VLANm
#define EGR_VLANm_MIN BCM56800_A0_EGR_VLANm_MIN
#define EGR_VLANm_MAX BCM56800_A0_EGR_VLANm_MAX
#define EGR_VLANm_CMAX(u) BCM56800_A0_EGR_VLANm_CMAX(u)
#define EGR_VLANm_SIZE BCM56800_A0_EGR_VLANm_SIZE
typedef BCM56800_A0_EGR_VLANm_t EGR_VLANm_t;
#define EGR_VLANm_CLR BCM56800_A0_EGR_VLANm_CLR
#define EGR_VLANm_SET BCM56800_A0_EGR_VLANm_SET
#define EGR_VLANm_GET BCM56800_A0_EGR_VLANm_GET
#define EGR_VLANm_UT_BITMAPf_GET BCM56800_A0_EGR_VLANm_UT_BITMAPf_GET
#define EGR_VLANm_UT_BITMAPf_SET BCM56800_A0_EGR_VLANm_UT_BITMAPf_SET
#define EGR_VLANm_PORT_BITMAPf_GET BCM56800_A0_EGR_VLANm_PORT_BITMAPf_GET
#define EGR_VLANm_PORT_BITMAPf_SET BCM56800_A0_EGR_VLANm_PORT_BITMAPf_SET
#define EGR_VLANm_STGf_GET BCM56800_A0_EGR_VLANm_STGf_GET
#define EGR_VLANm_STGf_SET BCM56800_A0_EGR_VLANm_STGf_SET
#define EGR_VLANm_VALIDf_GET BCM56800_A0_EGR_VLANm_VALIDf_GET
#define EGR_VLANm_VALIDf_SET BCM56800_A0_EGR_VLANm_VALIDf_SET
#define EGR_VLANm_EVEN_PARITYf_GET BCM56800_A0_EGR_VLANm_EVEN_PARITYf_GET
#define EGR_VLANm_EVEN_PARITYf_SET BCM56800_A0_EGR_VLANm_EVEN_PARITYf_SET
#define READ_EGR_VLANm BCM56800_A0_READ_EGR_VLANm
#define WRITE_EGR_VLANm BCM56800_A0_WRITE_EGR_VLANm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLANm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VLAN_CONTROL_1
 * BLOCKS:   EPIPE
 * DESC:     Controls Vlan Translate and VLAN membership related functions.

 * SIZE:     32
 * FIELDS:
 *     VT_ENABLE        VLAN Translate is enabled on this port. If this bit is set, then the vid, pri obtained from the VXLTCAM Lookup is used.
 *     VT_MISS_DROP     If this bit is set, and a lookup in the vxlt cam table results in a miss, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *     OUTER_TPID       TPID to identify the outer tag. Also this tpid is used when packet modification stages add a vlan tag in the packet. 
 *     VT_MISS_UT_DROP  If this bit is set, and a lookup in the vxlt cam table results in a miss, AND pkt is untagged by vlan_table, then pkt is dropped.This bit is meaningful only when VT_ENABLE is set.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLAN_CONTROL_1r 0x01400004

#define BCM56800_A0_EGR_VLAN_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_CONTROL_1.
 *
 */
typedef union BCM56800_A0_EGR_VLAN_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t egr_vlan_control_1[1];
	uint32_t _egr_vlan_control_1;
} BCM56800_A0_EGR_VLAN_CONTROL_1r_t;

#define BCM56800_A0_EGR_VLAN_CONTROL_1r_CLR(r) (r).egr_vlan_control_1[0] = 0
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_SET(r,d) (r).egr_vlan_control_1[0] = d
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_GET(r) (r).egr_vlan_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET(r) (((r).egr_vlan_control_1[0]) & 0x1)
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET(r) ((((r).egr_vlan_control_1[0]) >> 2) & 0xffff)
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0xffff << 2)) | ((((uint32_t)f) & 0xffff) << 2))
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_GET(r) ((((r).egr_vlan_control_1[0]) >> 18) & 0x1)
#define BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_SET(r,f) (r).egr_vlan_control_1[0]=(((r).egr_vlan_control_1[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_VLAN_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_EGR_VLAN_CONTROL_1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EGR_VLAN_CONTROL_1r,(r._egr_vlan_control_1))
#define BCM56800_A0_WRITE_EGR_VLAN_CONTROL_1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EGR_VLAN_CONTROL_1r,&(r._egr_vlan_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_CONTROL_1r BCM56800_A0_EGR_VLAN_CONTROL_1r
#define EGR_VLAN_CONTROL_1r_SIZE BCM56800_A0_EGR_VLAN_CONTROL_1r_SIZE
typedef BCM56800_A0_EGR_VLAN_CONTROL_1r_t EGR_VLAN_CONTROL_1r_t;
#define EGR_VLAN_CONTROL_1r_CLR BCM56800_A0_EGR_VLAN_CONTROL_1r_CLR
#define EGR_VLAN_CONTROL_1r_SET BCM56800_A0_EGR_VLAN_CONTROL_1r_SET
#define EGR_VLAN_CONTROL_1r_GET BCM56800_A0_EGR_VLAN_CONTROL_1r_GET
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_GET
#define EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_ENABLEf_SET
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_GET
#define EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_MISS_DROPf_SET
#define EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET BCM56800_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_GET
#define EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET BCM56800_A0_EGR_VLAN_CONTROL_1r_OUTER_TPIDf_SET
#define EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_GET BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_GET
#define EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_SET BCM56800_A0_EGR_VLAN_CONTROL_1r_VT_MISS_UT_DROPf_SET
#define READ_EGR_VLAN_CONTROL_1r BCM56800_A0_READ_EGR_VLAN_CONTROL_1r
#define WRITE_EGR_VLAN_CONTROL_1r BCM56800_A0_WRITE_EGR_VLAN_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLAN_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VLAN_PARITY_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     EGR_VLAN_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the EGR_VLAN table.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr 0x04480c00

#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_PARITY_CONTROL.
 *
 */
typedef union BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_vlan_parity_control[1];
	uint32_t _egr_vlan_parity_control;
} BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_t;

#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_CLR(r) (r).egr_vlan_parity_control[0] = 0
#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_SET(r,d) (r).egr_vlan_parity_control[0] = d
#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_GET(r) (r).egr_vlan_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).egr_vlan_parity_control[0]) & 0x1)
#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).egr_vlan_parity_control[0]=(((r).egr_vlan_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).egr_vlan_parity_control[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).egr_vlan_parity_control[0]=(((r).egr_vlan_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_VLAN_PARITY_CONTROL.
 *
 */
#define BCM56800_A0_READ_EGR_VLAN_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VLAN_PARITY_CONTROLr,(r._egr_vlan_parity_control))
#define BCM56800_A0_WRITE_EGR_VLAN_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VLAN_PARITY_CONTROLr,&(r._egr_vlan_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_PARITY_CONTROLr BCM56800_A0_EGR_VLAN_PARITY_CONTROLr
#define EGR_VLAN_PARITY_CONTROLr_SIZE BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_SIZE
typedef BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_t EGR_VLAN_PARITY_CONTROLr_t;
#define EGR_VLAN_PARITY_CONTROLr_CLR BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_CLR
#define EGR_VLAN_PARITY_CONTROLr_SET BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_SET
#define EGR_VLAN_PARITY_CONTROLr_GET BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_GET
#define EGR_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define EGR_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define EGR_VLAN_PARITY_CONTROLr_PARITY_ENf_GET BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_PARITY_ENf_GET
#define EGR_VLAN_PARITY_CONTROLr_PARITY_ENf_SET BCM56800_A0_EGR_VLAN_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_EGR_VLAN_PARITY_CONTROLr BCM56800_A0_READ_EGR_VLAN_PARITY_CONTROLr
#define WRITE_EGR_VLAN_PARITY_CONTROLr BCM56800_A0_WRITE_EGR_VLAN_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLAN_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VLAN_PARITY_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VLAN_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     IDX              This field indicates the index to the bucket in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr 0x04480c01

#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VLAN_PARITY_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_VLAN_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vlan_parity_status[1];
	uint32_t _egr_vlan_parity_status;
} BCM56800_A0_EGR_VLAN_PARITY_STATUSr_t;

#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr_CLR(r) (r).egr_vlan_parity_status[0] = 0
#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr_SET(r,d) (r).egr_vlan_parity_status[0] = d
#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr_GET(r) (r).egr_vlan_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).egr_vlan_parity_status[0]) & 0x1)
#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).egr_vlan_parity_status[0]=(((r).egr_vlan_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr_IDXf_GET(r) ((((r).egr_vlan_parity_status[0]) >> 1) & 0xfff)
#define BCM56800_A0_EGR_VLAN_PARITY_STATUSr_IDXf_SET(r,f) (r).egr_vlan_parity_status[0]=(((r).egr_vlan_parity_status[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))

/*
 * These macros can be used to access EGR_VLAN_PARITY_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_VLAN_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VLAN_PARITY_STATUSr,(r._egr_vlan_parity_status))
#define BCM56800_A0_WRITE_EGR_VLAN_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VLAN_PARITY_STATUSr,&(r._egr_vlan_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_PARITY_STATUSr BCM56800_A0_EGR_VLAN_PARITY_STATUSr
#define EGR_VLAN_PARITY_STATUSr_SIZE BCM56800_A0_EGR_VLAN_PARITY_STATUSr_SIZE
typedef BCM56800_A0_EGR_VLAN_PARITY_STATUSr_t EGR_VLAN_PARITY_STATUSr_t;
#define EGR_VLAN_PARITY_STATUSr_CLR BCM56800_A0_EGR_VLAN_PARITY_STATUSr_CLR
#define EGR_VLAN_PARITY_STATUSr_SET BCM56800_A0_EGR_VLAN_PARITY_STATUSr_SET
#define EGR_VLAN_PARITY_STATUSr_GET BCM56800_A0_EGR_VLAN_PARITY_STATUSr_GET
#define EGR_VLAN_PARITY_STATUSr_PARITY_ERRf_GET BCM56800_A0_EGR_VLAN_PARITY_STATUSr_PARITY_ERRf_GET
#define EGR_VLAN_PARITY_STATUSr_PARITY_ERRf_SET BCM56800_A0_EGR_VLAN_PARITY_STATUSr_PARITY_ERRf_SET
#define EGR_VLAN_PARITY_STATUSr_IDXf_GET BCM56800_A0_EGR_VLAN_PARITY_STATUSr_IDXf_GET
#define EGR_VLAN_PARITY_STATUSr_IDXf_SET BCM56800_A0_EGR_VLAN_PARITY_STATUSr_IDXf_SET
#define READ_EGR_VLAN_PARITY_STATUSr BCM56800_A0_READ_EGR_VLAN_PARITY_STATUSr
#define WRITE_EGR_VLAN_PARITY_STATUSr BCM56800_A0_WRITE_EGR_VLAN_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLAN_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_VLAN_STG
 * BLOCKS:   EPIPE
 * DESC:     Egress Spanning Tree Stage Table, FeatureSpecific-Ethernet
 * SIZE:     40
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for Port 0.
 *     SP_TREE_PORT1    Spanning Tree State for Port 1.
 *     SP_TREE_PORT2    Spanning Tree State for Port 2.
 *     SP_TREE_PORT3    Spanning Tree State for Port 3.
 *     SP_TREE_PORT4    Spanning Tree State for Port 4.
 *     SP_TREE_PORT5    Spanning Tree State for Port 5.
 *     SP_TREE_PORT6    Spanning Tree State for Port 6.
 *     SP_TREE_PORT7    Spanning Tree State for Port 7.
 *     SP_TREE_PORT8    Spanning Tree State for Port 8.
 *     SP_TREE_PORT9    Spanning Tree State for Port 9.
 *     SP_TREE_PORT10   Spanning Tree State for Port 10.
 *     SP_TREE_PORT11   Spanning Tree State for Port 11.
 *     SP_TREE_PORT12   Spanning Tree State for Port 12.
 *     SP_TREE_PORT13   Spanning Tree State for Port 13.
 *     SP_TREE_PORT14   Spanning Tree State for Port 14.
 *     SP_TREE_PORT15   Spanning Tree State for Port 15.
 *     SP_TREE_PORT16   Spanning Tree State for Port 16.
 *     SP_TREE_PORT17   Spanning Tree State for Port 17.
 *     SP_TREE_PORT18   Spanning Tree State for Port 18.
 *     SP_TREE_PORT19   Spanning Tree State for Port 19.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLAN_STGm 0x04462000

#define BCM56800_A0_EGR_VLAN_STGm_MIN 0
#define BCM56800_A0_EGR_VLAN_STGm_MAX 255
#define BCM56800_A0_EGR_VLAN_STGm_CMAX(u) 255
#define BCM56800_A0_EGR_VLAN_STGm_SIZE 5

/*
 * This structure should be used to declare and program EGR_VLAN_STG.
 *
 */
typedef union BCM56800_A0_EGR_VLAN_STGm_s {
	uint32_t v[2];
	uint32_t egr_vlan_stg[2];
	uint32_t _egr_vlan_stg;
} BCM56800_A0_EGR_VLAN_STGm_t;

#define BCM56800_A0_EGR_VLAN_STGm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_stg), 0, sizeof(BCM56800_A0_EGR_VLAN_STGm_t))
#define BCM56800_A0_EGR_VLAN_STGm_SET(r,i,d) (r).egr_vlan_stg[i] = d
#define BCM56800_A0_EGR_VLAN_STGm_GET(r,i) (r).egr_vlan_stg[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_GET(r) (((r).egr_vlan_stg[0]) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_GET(r) ((((r).egr_vlan_stg[0]) >> 2) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_GET(r) ((((r).egr_vlan_stg[0]) >> 4) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_GET(r) ((((r).egr_vlan_stg[0]) >> 6) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_GET(r) ((((r).egr_vlan_stg[0]) >> 8) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_GET(r) ((((r).egr_vlan_stg[0]) >> 10) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_GET(r) ((((r).egr_vlan_stg[0]) >> 12) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_GET(r) ((((r).egr_vlan_stg[0]) >> 14) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_GET(r) ((((r).egr_vlan_stg[0]) >> 16) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_GET(r) ((((r).egr_vlan_stg[0]) >> 18) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_GET(r) ((((r).egr_vlan_stg[0]) >> 20) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_GET(r) ((((r).egr_vlan_stg[0]) >> 22) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_GET(r) ((((r).egr_vlan_stg[0]) >> 24) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_GET(r) ((((r).egr_vlan_stg[0]) >> 26) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_GET(r) ((((r).egr_vlan_stg[0]) >> 28) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_GET(r) ((((r).egr_vlan_stg[0]) >> 30) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_SET(r,f) (r).egr_vlan_stg[0]=(((r).egr_vlan_stg[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_GET(r) (((r).egr_vlan_stg[1]) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_GET(r) ((((r).egr_vlan_stg[1]) >> 2) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_GET(r) ((((r).egr_vlan_stg[1]) >> 4) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_GET(r) ((((r).egr_vlan_stg[1]) >> 6) & 0x3)
#define BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_SET(r,f) (r).egr_vlan_stg[1]=(((r).egr_vlan_stg[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access EGR_VLAN_STG.
 *
 */
#define BCM56800_A0_READ_EGR_VLAN_STGm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_VLAN_STGm,i,(m._egr_vlan_stg),2)
#define BCM56800_A0_WRITE_EGR_VLAN_STGm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_VLAN_STGm,i,&(m._egr_vlan_stg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_STGm BCM56800_A0_EGR_VLAN_STGm
#define EGR_VLAN_STGm_MIN BCM56800_A0_EGR_VLAN_STGm_MIN
#define EGR_VLAN_STGm_MAX BCM56800_A0_EGR_VLAN_STGm_MAX
#define EGR_VLAN_STGm_CMAX(u) BCM56800_A0_EGR_VLAN_STGm_CMAX(u)
#define EGR_VLAN_STGm_SIZE BCM56800_A0_EGR_VLAN_STGm_SIZE
typedef BCM56800_A0_EGR_VLAN_STGm_t EGR_VLAN_STGm_t;
#define EGR_VLAN_STGm_CLR BCM56800_A0_EGR_VLAN_STGm_CLR
#define EGR_VLAN_STGm_SET BCM56800_A0_EGR_VLAN_STGm_SET
#define EGR_VLAN_STGm_GET BCM56800_A0_EGR_VLAN_STGm_GET
#define EGR_VLAN_STGm_SP_TREE_PORT0f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT0f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT0f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT1f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT1f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT1f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT2f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT2f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT2f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT3f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT3f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT3f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT4f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT4f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT4f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT5f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT5f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT5f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT6f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT6f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT6f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT7f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT7f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT7f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT8f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT8f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT8f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT9f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT9f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT9f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT10f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT10f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT10f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT11f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT11f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT11f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT12f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT12f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT12f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT13f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT13f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT13f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT14f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT14f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT14f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT15f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT15f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT15f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT16f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT16f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT16f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT17f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT17f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT17f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT18f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT18f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT18f_SET
#define EGR_VLAN_STGm_SP_TREE_PORT19f_GET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_GET
#define EGR_VLAN_STGm_SP_TREE_PORT19f_SET BCM56800_A0_EGR_VLAN_STGm_SP_TREE_PORT19f_SET
#define READ_EGR_VLAN_STGm BCM56800_A0_READ_EGR_VLAN_STGm
#define WRITE_EGR_VLAN_STGm BCM56800_A0_WRITE_EGR_VLAN_STGm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLAN_STGm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_VLAN_XLATE
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate CAM-RAM Combined View for ports 0-9. FeatureSpecific-Ethernet
 * SIZE:     34
 * FIELDS:
 *     VALID            Valid Bit for the Entry. It has to be 0th bit in the CAM.
 *     VID              VID to be compared wrt the input Key.
 *     EGRESS_PORT      Destination port to be compared wrt the input key.
 *     NEW_VLAN_ID      VID to be used to translate the original packet or so far constructed VID at L3 stage.
 *     PRI              Priority to be used to translate the original priority.
 *     RPE              Used to determine if the vlan_xlate_data PRI needs to be replaced.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLAN_XLATEm 0x05461000

#define BCM56800_A0_EGR_VLAN_XLATEm_MIN 0
#define BCM56800_A0_EGR_VLAN_XLATEm_MAX 767
#define BCM56800_A0_EGR_VLAN_XLATEm_CMAX(u) 767
#define BCM56800_A0_EGR_VLAN_XLATEm_SIZE 5

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE.
 *
 */
typedef union BCM56800_A0_EGR_VLAN_XLATEm_s {
	uint32_t v[2];
	uint32_t egr_vlan_xlate[2];
	uint32_t _egr_vlan_xlate;
} BCM56800_A0_EGR_VLAN_XLATEm_t;

#define BCM56800_A0_EGR_VLAN_XLATEm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_xlate), 0, sizeof(BCM56800_A0_EGR_VLAN_XLATEm_t))
#define BCM56800_A0_EGR_VLAN_XLATEm_SET(r,i,d) (r).egr_vlan_xlate[i] = d
#define BCM56800_A0_EGR_VLAN_XLATEm_GET(r,i) (r).egr_vlan_xlate[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLAN_XLATEm_VALIDf_GET(r) (((r).egr_vlan_xlate[0]) & 0x1)
#define BCM56800_A0_EGR_VLAN_XLATEm_VALIDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_VLAN_XLATEm_VIDf_GET(r) ((((r).egr_vlan_xlate[0]) >> 1) & 0xfff)
#define BCM56800_A0_EGR_VLAN_XLATEm_VIDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))
#define BCM56800_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_GET(r) ((((r).egr_vlan_xlate[0]) >> 13) & 0x1f)
#define BCM56800_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM56800_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET(r) ((((r).egr_vlan_xlate[0]) >> 18) & 0xfff)
#define BCM56800_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET(r,f) (r).egr_vlan_xlate[0]=(((r).egr_vlan_xlate[0] & ~((uint32_t)0xfff << 18)) | ((((uint32_t)f) & 0xfff) << 18))
#define BCM56800_A0_EGR_VLAN_XLATEm_PRIf_GET(r) cdk_field32_get((r).egr_vlan_xlate,30,32)
#define BCM56800_A0_EGR_VLAN_XLATEm_PRIf_SET(r,f) cdk_field32_set((r).egr_vlan_xlate,30,32,f)
#define BCM56800_A0_EGR_VLAN_XLATEm_RPEf_GET(r) ((((r).egr_vlan_xlate[1]) >> 1) & 0x1)
#define BCM56800_A0_EGR_VLAN_XLATEm_RPEf_SET(r,f) (r).egr_vlan_xlate[1]=(((r).egr_vlan_xlate[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_VLAN_XLATE.
 *
 */
#define BCM56800_A0_READ_EGR_VLAN_XLATEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_VLAN_XLATEm,i,(m._egr_vlan_xlate),2)
#define BCM56800_A0_WRITE_EGR_VLAN_XLATEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_VLAN_XLATEm,i,&(m._egr_vlan_xlate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATEm BCM56800_A0_EGR_VLAN_XLATEm
#define EGR_VLAN_XLATEm_MIN BCM56800_A0_EGR_VLAN_XLATEm_MIN
#define EGR_VLAN_XLATEm_MAX BCM56800_A0_EGR_VLAN_XLATEm_MAX
#define EGR_VLAN_XLATEm_CMAX(u) BCM56800_A0_EGR_VLAN_XLATEm_CMAX(u)
#define EGR_VLAN_XLATEm_SIZE BCM56800_A0_EGR_VLAN_XLATEm_SIZE
typedef BCM56800_A0_EGR_VLAN_XLATEm_t EGR_VLAN_XLATEm_t;
#define EGR_VLAN_XLATEm_CLR BCM56800_A0_EGR_VLAN_XLATEm_CLR
#define EGR_VLAN_XLATEm_SET BCM56800_A0_EGR_VLAN_XLATEm_SET
#define EGR_VLAN_XLATEm_GET BCM56800_A0_EGR_VLAN_XLATEm_GET
#define EGR_VLAN_XLATEm_VALIDf_GET BCM56800_A0_EGR_VLAN_XLATEm_VALIDf_GET
#define EGR_VLAN_XLATEm_VALIDf_SET BCM56800_A0_EGR_VLAN_XLATEm_VALIDf_SET
#define EGR_VLAN_XLATEm_VIDf_GET BCM56800_A0_EGR_VLAN_XLATEm_VIDf_GET
#define EGR_VLAN_XLATEm_VIDf_SET BCM56800_A0_EGR_VLAN_XLATEm_VIDf_SET
#define EGR_VLAN_XLATEm_EGRESS_PORTf_GET BCM56800_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_GET
#define EGR_VLAN_XLATEm_EGRESS_PORTf_SET BCM56800_A0_EGR_VLAN_XLATEm_EGRESS_PORTf_SET
#define EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET BCM56800_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_GET
#define EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET BCM56800_A0_EGR_VLAN_XLATEm_NEW_VLAN_IDf_SET
#define EGR_VLAN_XLATEm_PRIf_GET BCM56800_A0_EGR_VLAN_XLATEm_PRIf_GET
#define EGR_VLAN_XLATEm_PRIf_SET BCM56800_A0_EGR_VLAN_XLATEm_PRIf_SET
#define EGR_VLAN_XLATEm_RPEf_GET BCM56800_A0_EGR_VLAN_XLATEm_RPEf_GET
#define EGR_VLAN_XLATEm_RPEf_SET BCM56800_A0_EGR_VLAN_XLATEm_RPEf_SET
#define READ_EGR_VLAN_XLATEm BCM56800_A0_READ_EGR_VLAN_XLATEm
#define WRITE_EGR_VLAN_XLATEm BCM56800_A0_WRITE_EGR_VLAN_XLATEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLAN_XLATEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_VLAN_XLATE_DATA_ONLY
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate Data Table only, FeatureSpecific-Ethernet
 * SIZE:     16
 * FIELDS:
 *     NEW_VID          VID to be used to translate the original packet or so far constructed VID at L3 stage.
 *     PRI              Priority to be used to translate the original priority.
 *     RPE              Used to determine if the vlan_xlate_data PRI needs to be replaced.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm 0x05464000

#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_MIN 0
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_MAX 767
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u) 767
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_SIZE 2

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE_DATA_ONLY.
 *
 */
typedef union BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t egr_vlan_xlate_data_only[1];
	uint32_t _egr_vlan_xlate_data_only;
} BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_t;

#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_CLR(r) (r).egr_vlan_xlate_data_only[0] = 0
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_SET(r,d) (r).egr_vlan_xlate_data_only[0] = d
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_GET(r) (r).egr_vlan_xlate_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET(r) (((r).egr_vlan_xlate_data_only[0]) & 0xfff)
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET(r) ((((r).egr_vlan_xlate_data_only[0]) >> 12) & 0x7)
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET(r) ((((r).egr_vlan_xlate_data_only[0]) >> 15) & 0x1)
#define BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET(r,f) (r).egr_vlan_xlate_data_only[0]=(((r).egr_vlan_xlate_data_only[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access EGR_VLAN_XLATE_DATA_ONLY.
 *
 */
#define BCM56800_A0_READ_EGR_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm,i,(m._egr_vlan_xlate_data_only),1)
#define BCM56800_A0_WRITE_EGR_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm,i,&(m._egr_vlan_xlate_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATE_DATA_ONLYm BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm
#define EGR_VLAN_XLATE_DATA_ONLYm_MIN BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_MIN
#define EGR_VLAN_XLATE_DATA_ONLYm_MAX BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_MAX
#define EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u) BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_CMAX(u)
#define EGR_VLAN_XLATE_DATA_ONLYm_SIZE BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_SIZE
typedef BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_t EGR_VLAN_XLATE_DATA_ONLYm_t;
#define EGR_VLAN_XLATE_DATA_ONLYm_CLR BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_CLR
#define EGR_VLAN_XLATE_DATA_ONLYm_SET BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_GET BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_NEW_VIDf_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_PRIf_SET
#define EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_GET
#define EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm_RPEf_SET
#define READ_EGR_VLAN_XLATE_DATA_ONLYm BCM56800_A0_READ_EGR_VLAN_XLATE_DATA_ONLYm
#define WRITE_EGR_VLAN_XLATE_DATA_ONLYm BCM56800_A0_WRITE_EGR_VLAN_XLATE_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLAN_XLATE_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_VLAN_XLATE_MASK
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate CAM-RAM Combined View with mask for ports 0-9. FeatureSpecific-Ethernet
 * SIZE:     51
 * FIELDS:
 *     VALID            Valid Bit for the Entry. It has to be 0th bit in the CAM.
 *     VID              VID to be compared wrt the input Key.
 *     EGRESS_PORT      Destination port to be compared wrt the input key.
 *     MASK             Mask for the {VID, EGRESS_PORT}
 *     NEW_VLAN_ID      VID to be used to translate the original packet or so far constructed VID at L3 stage.
 *     PRI              Priority to be used to translate the original priority.
 *     RPE              Used to determine if the vlan_xlate_data PRI needs to be replaced.
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm 0x05462000

#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_MIN 0
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_MAX 767
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_CMAX(u) 767
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_SIZE 7

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE_MASK.
 *
 */
typedef union BCM56800_A0_EGR_VLAN_XLATE_MASKm_s {
	uint32_t v[2];
	uint32_t egr_vlan_xlate_mask[2];
	uint32_t _egr_vlan_xlate_mask;
} BCM56800_A0_EGR_VLAN_XLATE_MASKm_t;

#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_xlate_mask), 0, sizeof(BCM56800_A0_EGR_VLAN_XLATE_MASKm_t))
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_SET(r,i,d) (r).egr_vlan_xlate_mask[i] = d
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_GET(r,i) (r).egr_vlan_xlate_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_VALIDf_GET(r) (((r).egr_vlan_xlate_mask[0]) & 0x1)
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_VALIDf_SET(r,f) (r).egr_vlan_xlate_mask[0]=(((r).egr_vlan_xlate_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_VIDf_GET(r) ((((r).egr_vlan_xlate_mask[0]) >> 1) & 0xfff)
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_VIDf_SET(r,f) (r).egr_vlan_xlate_mask[0]=(((r).egr_vlan_xlate_mask[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_EGRESS_PORTf_GET(r) ((((r).egr_vlan_xlate_mask[0]) >> 13) & 0x1f)
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_EGRESS_PORTf_SET(r,f) (r).egr_vlan_xlate_mask[0]=(((r).egr_vlan_xlate_mask[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_MASKf_GET(r) cdk_field32_get((r).egr_vlan_xlate_mask,18,34)
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_MASKf_SET(r,f) cdk_field32_set((r).egr_vlan_xlate_mask,18,34,f)
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_NEW_VLAN_IDf_GET(r) ((((r).egr_vlan_xlate_mask[1]) >> 3) & 0xfff)
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_NEW_VLAN_IDf_SET(r,f) (r).egr_vlan_xlate_mask[1]=(((r).egr_vlan_xlate_mask[1] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_PRIf_GET(r) ((((r).egr_vlan_xlate_mask[1]) >> 15) & 0x7)
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_PRIf_SET(r,f) (r).egr_vlan_xlate_mask[1]=(((r).egr_vlan_xlate_mask[1] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_RPEf_GET(r) ((((r).egr_vlan_xlate_mask[1]) >> 18) & 0x1)
#define BCM56800_A0_EGR_VLAN_XLATE_MASKm_RPEf_SET(r,f) (r).egr_vlan_xlate_mask[1]=(((r).egr_vlan_xlate_mask[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access EGR_VLAN_XLATE_MASK.
 *
 */
#define BCM56800_A0_READ_EGR_VLAN_XLATE_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_VLAN_XLATE_MASKm,i,(m._egr_vlan_xlate_mask),2)
#define BCM56800_A0_WRITE_EGR_VLAN_XLATE_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_VLAN_XLATE_MASKm,i,&(m._egr_vlan_xlate_mask),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATE_MASKm BCM56800_A0_EGR_VLAN_XLATE_MASKm
#define EGR_VLAN_XLATE_MASKm_MIN BCM56800_A0_EGR_VLAN_XLATE_MASKm_MIN
#define EGR_VLAN_XLATE_MASKm_MAX BCM56800_A0_EGR_VLAN_XLATE_MASKm_MAX
#define EGR_VLAN_XLATE_MASKm_CMAX(u) BCM56800_A0_EGR_VLAN_XLATE_MASKm_CMAX(u)
#define EGR_VLAN_XLATE_MASKm_SIZE BCM56800_A0_EGR_VLAN_XLATE_MASKm_SIZE
typedef BCM56800_A0_EGR_VLAN_XLATE_MASKm_t EGR_VLAN_XLATE_MASKm_t;
#define EGR_VLAN_XLATE_MASKm_CLR BCM56800_A0_EGR_VLAN_XLATE_MASKm_CLR
#define EGR_VLAN_XLATE_MASKm_SET BCM56800_A0_EGR_VLAN_XLATE_MASKm_SET
#define EGR_VLAN_XLATE_MASKm_GET BCM56800_A0_EGR_VLAN_XLATE_MASKm_GET
#define EGR_VLAN_XLATE_MASKm_VALIDf_GET BCM56800_A0_EGR_VLAN_XLATE_MASKm_VALIDf_GET
#define EGR_VLAN_XLATE_MASKm_VALIDf_SET BCM56800_A0_EGR_VLAN_XLATE_MASKm_VALIDf_SET
#define EGR_VLAN_XLATE_MASKm_VIDf_GET BCM56800_A0_EGR_VLAN_XLATE_MASKm_VIDf_GET
#define EGR_VLAN_XLATE_MASKm_VIDf_SET BCM56800_A0_EGR_VLAN_XLATE_MASKm_VIDf_SET
#define EGR_VLAN_XLATE_MASKm_EGRESS_PORTf_GET BCM56800_A0_EGR_VLAN_XLATE_MASKm_EGRESS_PORTf_GET
#define EGR_VLAN_XLATE_MASKm_EGRESS_PORTf_SET BCM56800_A0_EGR_VLAN_XLATE_MASKm_EGRESS_PORTf_SET
#define EGR_VLAN_XLATE_MASKm_MASKf_GET BCM56800_A0_EGR_VLAN_XLATE_MASKm_MASKf_GET
#define EGR_VLAN_XLATE_MASKm_MASKf_SET BCM56800_A0_EGR_VLAN_XLATE_MASKm_MASKf_SET
#define EGR_VLAN_XLATE_MASKm_NEW_VLAN_IDf_GET BCM56800_A0_EGR_VLAN_XLATE_MASKm_NEW_VLAN_IDf_GET
#define EGR_VLAN_XLATE_MASKm_NEW_VLAN_IDf_SET BCM56800_A0_EGR_VLAN_XLATE_MASKm_NEW_VLAN_IDf_SET
#define EGR_VLAN_XLATE_MASKm_PRIf_GET BCM56800_A0_EGR_VLAN_XLATE_MASKm_PRIf_GET
#define EGR_VLAN_XLATE_MASKm_PRIf_SET BCM56800_A0_EGR_VLAN_XLATE_MASKm_PRIf_SET
#define EGR_VLAN_XLATE_MASKm_RPEf_GET BCM56800_A0_EGR_VLAN_XLATE_MASKm_RPEf_GET
#define EGR_VLAN_XLATE_MASKm_RPEf_SET BCM56800_A0_EGR_VLAN_XLATE_MASKm_RPEf_SET
#define READ_EGR_VLAN_XLATE_MASKm BCM56800_A0_READ_EGR_VLAN_XLATE_MASKm
#define WRITE_EGR_VLAN_XLATE_MASKm BCM56800_A0_WRITE_EGR_VLAN_XLATE_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLAN_XLATE_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EGR_VLAN_XLATE_ONLY
 * BLOCKS:   EPIPE
 * DESC:     Egress Vlan Translate CAM only. FeatureSpecific-Ethernet
 * SIZE:     35
 * FIELDS:
 *     VALID            Valid Bit for the Entry. It has to be 0th bit in the CAM.
 *     VID              VID to be compared wrt the input Key.
 *     EGRESS_PORT      Destination port to be compared wrt the input key.
 *     MASK             Mask for the {VID, EGRESS_PORT}
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm 0x05463000

#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_MIN 0
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_MAX 767
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_CMAX(u) 767
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_SIZE 5

/*
 * This structure should be used to declare and program EGR_VLAN_XLATE_ONLY.
 *
 */
typedef union BCM56800_A0_EGR_VLAN_XLATE_ONLYm_s {
	uint32_t v[2];
	uint32_t egr_vlan_xlate_only[2];
	uint32_t _egr_vlan_xlate_only;
} BCM56800_A0_EGR_VLAN_XLATE_ONLYm_t;

#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_CLR(r) CDK_MEMSET(&((r)._egr_vlan_xlate_only), 0, sizeof(BCM56800_A0_EGR_VLAN_XLATE_ONLYm_t))
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_SET(r,i,d) (r).egr_vlan_xlate_only[i] = d
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_GET(r,i) (r).egr_vlan_xlate_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_GET(r) (((r).egr_vlan_xlate_only[0]) & 0x1)
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_VIDf_GET(r) ((((r).egr_vlan_xlate_only[0]) >> 1) & 0xfff)
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_VIDf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET(r) ((((r).egr_vlan_xlate_only[0]) >> 13) & 0x1f)
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET(r,f) (r).egr_vlan_xlate_only[0]=(((r).egr_vlan_xlate_only[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_MASKf_GET(r) cdk_field32_get((r).egr_vlan_xlate_only,18,34)
#define BCM56800_A0_EGR_VLAN_XLATE_ONLYm_MASKf_SET(r,f) cdk_field32_set((r).egr_vlan_xlate_only,18,34,f)

/*
 * These macros can be used to access EGR_VLAN_XLATE_ONLY.
 *
 */
#define BCM56800_A0_READ_EGR_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EGR_VLAN_XLATE_ONLYm,i,(m._egr_vlan_xlate_only),2)
#define BCM56800_A0_WRITE_EGR_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EGR_VLAN_XLATE_ONLYm,i,&(m._egr_vlan_xlate_only),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VLAN_XLATE_ONLYm BCM56800_A0_EGR_VLAN_XLATE_ONLYm
#define EGR_VLAN_XLATE_ONLYm_MIN BCM56800_A0_EGR_VLAN_XLATE_ONLYm_MIN
#define EGR_VLAN_XLATE_ONLYm_MAX BCM56800_A0_EGR_VLAN_XLATE_ONLYm_MAX
#define EGR_VLAN_XLATE_ONLYm_CMAX(u) BCM56800_A0_EGR_VLAN_XLATE_ONLYm_CMAX(u)
#define EGR_VLAN_XLATE_ONLYm_SIZE BCM56800_A0_EGR_VLAN_XLATE_ONLYm_SIZE
typedef BCM56800_A0_EGR_VLAN_XLATE_ONLYm_t EGR_VLAN_XLATE_ONLYm_t;
#define EGR_VLAN_XLATE_ONLYm_CLR BCM56800_A0_EGR_VLAN_XLATE_ONLYm_CLR
#define EGR_VLAN_XLATE_ONLYm_SET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_SET
#define EGR_VLAN_XLATE_ONLYm_GET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_GET
#define EGR_VLAN_XLATE_ONLYm_VALIDf_GET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_GET
#define EGR_VLAN_XLATE_ONLYm_VALIDf_SET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_VALIDf_SET
#define EGR_VLAN_XLATE_ONLYm_VIDf_GET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_VIDf_GET
#define EGR_VLAN_XLATE_ONLYm_VIDf_SET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_VIDf_SET
#define EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_GET
#define EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_EGRESS_PORTf_SET
#define EGR_VLAN_XLATE_ONLYm_MASKf_GET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_MASKf_GET
#define EGR_VLAN_XLATE_ONLYm_MASKf_SET BCM56800_A0_EGR_VLAN_XLATE_ONLYm_MASKf_SET
#define READ_EGR_VLAN_XLATE_ONLYm BCM56800_A0_READ_EGR_VLAN_XLATE_ONLYm
#define WRITE_EGR_VLAN_XLATE_ONLYm BCM56800_A0_WRITE_EGR_VLAN_XLATE_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VLAN_XLATE_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S10_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S10_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S10_STATUS       S10_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr 0x05480c0e

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s10_status[1];
	uint32_t _egr_vxlt_cam_bist_s10_status;
} BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_t;

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s10_status[0] = 0
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s10_status[0] = d
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_S10_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s10_status[0]) & 0x7ff)
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_S10_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s10_status[0]=(((r).egr_vxlt_cam_bist_s10_status[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr,(r._egr_vxlt_cam_bist_s10_status))
#define BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr,&(r._egr_vxlt_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S10_STATUSr BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr
#define EGR_VXLT_CAM_BIST_S10_STATUSr_SIZE BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_t EGR_VXLT_CAM_BIST_S10_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S10_STATUSr_CLR BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S10_STATUSr_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S10_STATUSr_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S10_STATUSr_S10_STATUSf_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_S10_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S10_STATUSr_S10_STATUSf_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr_S10_STATUSf_SET
#define READ_EGR_VXLT_CAM_BIST_S10_STATUSr BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S10_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S10_STATUSr BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VXLT_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S2_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S2_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S2_STATUS        S2_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr 0x05480c09

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s2_status[1];
	uint32_t _egr_vxlt_cam_bist_s2_status;
} BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_t;

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s2_status[0] = 0
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s2_status[0] = d
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_S2_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s2_status[0]) & 0xffff)
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_S2_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s2_status[0]=(((r).egr_vxlt_cam_bist_s2_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr,(r._egr_vxlt_cam_bist_s2_status))
#define BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr,&(r._egr_vxlt_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S2_STATUSr BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr
#define EGR_VXLT_CAM_BIST_S2_STATUSr_SIZE BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_t EGR_VXLT_CAM_BIST_S2_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S2_STATUSr_CLR BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S2_STATUSr_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_S2_STATUSf_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_S2_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S2_STATUSr_S2_STATUSf_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr_S2_STATUSf_SET
#define READ_EGR_VXLT_CAM_BIST_S2_STATUSr BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S2_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S2_STATUSr BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VXLT_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S3_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S3_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S3_STATUS        S3_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr 0x05480c0a

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s3_status[1];
	uint32_t _egr_vxlt_cam_bist_s3_status;
} BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_t;

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s3_status[0] = 0
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s3_status[0] = d
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_S3_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s3_status[0]) & 0x3fffff)
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_S3_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s3_status[0]=(((r).egr_vxlt_cam_bist_s3_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr,(r._egr_vxlt_cam_bist_s3_status))
#define BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr,&(r._egr_vxlt_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S3_STATUSr BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr
#define EGR_VXLT_CAM_BIST_S3_STATUSr_SIZE BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_t EGR_VXLT_CAM_BIST_S3_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S3_STATUSr_CLR BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S3_STATUSr_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_S3_STATUSf_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_S3_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S3_STATUSr_S3_STATUSf_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr_S3_STATUSf_SET
#define READ_EGR_VXLT_CAM_BIST_S3_STATUSr BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S3_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S3_STATUSr BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VXLT_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S5_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S5_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S5_STATUS        S5_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr 0x05480c0b

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s5_status[1];
	uint32_t _egr_vxlt_cam_bist_s5_status;
} BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_t;

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s5_status[0] = 0
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s5_status[0] = d
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_S5_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s5_status[0]) & 0xffff)
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_S5_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s5_status[0]=(((r).egr_vxlt_cam_bist_s5_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr,(r._egr_vxlt_cam_bist_s5_status))
#define BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr,&(r._egr_vxlt_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S5_STATUSr BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr
#define EGR_VXLT_CAM_BIST_S5_STATUSr_SIZE BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_t EGR_VXLT_CAM_BIST_S5_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S5_STATUSr_CLR BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S5_STATUSr_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_S5_STATUSf_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_S5_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S5_STATUSr_S5_STATUSf_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr_S5_STATUSf_SET
#define READ_EGR_VXLT_CAM_BIST_S5_STATUSr BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S5_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S5_STATUSr BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VXLT_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S6_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S6_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S6_STATUS        S6_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr 0x05480c0c

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s6_status[1];
	uint32_t _egr_vxlt_cam_bist_s6_status;
} BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_t;

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s6_status[0] = 0
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s6_status[0] = d
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_S6_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s6_status[0]) & 0x3fffff)
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_S6_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s6_status[0]=(((r).egr_vxlt_cam_bist_s6_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr,(r._egr_vxlt_cam_bist_s6_status))
#define BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr,&(r._egr_vxlt_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S6_STATUSr BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr
#define EGR_VXLT_CAM_BIST_S6_STATUSr_SIZE BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_t EGR_VXLT_CAM_BIST_S6_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S6_STATUSr_CLR BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S6_STATUSr_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_S6_STATUSf_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_S6_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S6_STATUSr_S6_STATUSf_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr_S6_STATUSf_SET
#define READ_EGR_VXLT_CAM_BIST_S6_STATUSr BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S6_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S6_STATUSr BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VXLT_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_S8_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_S8_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S8_STATUS        S8_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr 0x05480c0d

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_s8_status[1];
	uint32_t _egr_vxlt_cam_bist_s8_status;
} BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_t;

#define BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_s8_status[0] = 0
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_s8_status[0] = d
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_GET(r) (r).egr_vxlt_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_S8_STATUSf_GET(r) (((r).egr_vxlt_cam_bist_s8_status[0]) & 0x3fffff)
#define BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_S8_STATUSf_SET(r,f) (r).egr_vxlt_cam_bist_s8_status[0]=(((r).egr_vxlt_cam_bist_s8_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr,(r._egr_vxlt_cam_bist_s8_status))
#define BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr,&(r._egr_vxlt_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_S8_STATUSr BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr
#define EGR_VXLT_CAM_BIST_S8_STATUSr_SIZE BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_t EGR_VXLT_CAM_BIST_S8_STATUSr_t;
#define EGR_VXLT_CAM_BIST_S8_STATUSr_CLR BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_S8_STATUSr_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_SET
#define EGR_VXLT_CAM_BIST_S8_STATUSr_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_GET
#define EGR_VXLT_CAM_BIST_S8_STATUSr_S8_STATUSf_GET BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_S8_STATUSf_GET
#define EGR_VXLT_CAM_BIST_S8_STATUSr_S8_STATUSf_SET BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr_S8_STATUSf_SET
#define READ_EGR_VXLT_CAM_BIST_S8_STATUSr BCM56800_A0_READ_EGR_VXLT_CAM_BIST_S8_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_S8_STATUSr BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VXLT_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VXLT_CAM_BIST_STATUS
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_BIST_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag
 *     BIST_DONE        BIST completion status
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr 0x05480c08

#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_BIST_STATUS.
 *
 */
typedef union BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_bist_status[1];
	uint32_t _egr_vxlt_cam_bist_status;
} BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_t;

#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_CLR(r) (r).egr_vxlt_cam_bist_status[0] = 0
#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_SET(r,d) (r).egr_vxlt_cam_bist_status[0] = d
#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_GET(r) (r).egr_vxlt_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).egr_vxlt_cam_bist_status[0]) & 0x1)
#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).egr_vxlt_cam_bist_status[0]=(((r).egr_vxlt_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).egr_vxlt_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).egr_vxlt_cam_bist_status[0]=(((r).egr_vxlt_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access EGR_VXLT_CAM_BIST_STATUS.
 *
 */
#define BCM56800_A0_READ_EGR_VXLT_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr,(r._egr_vxlt_cam_bist_status))
#define BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr,&(r._egr_vxlt_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_BIST_STATUSr BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr
#define EGR_VXLT_CAM_BIST_STATUSr_SIZE BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_SIZE
typedef BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_t EGR_VXLT_CAM_BIST_STATUSr_t;
#define EGR_VXLT_CAM_BIST_STATUSr_CLR BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_CLR
#define EGR_VXLT_CAM_BIST_STATUSr_SET BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_SET
#define EGR_VXLT_CAM_BIST_STATUSr_GET BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_GET
#define EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_GET BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_GET
#define EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_SET BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_GOf_SET
#define EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_GET
#define EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_EGR_VXLT_CAM_BIST_STATUSr BCM56800_A0_READ_EGR_VXLT_CAM_BIST_STATUSr
#define WRITE_EGR_VXLT_CAM_BIST_STATUSr BCM56800_A0_WRITE_EGR_VXLT_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VXLT_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EGR_VXLT_CAM_CONTROL
 * BLOCKS:   EPIPE
 * DESC:     EGR_VXLT_CAM_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST_EN enable
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr 0x05480c00

#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EGR_VXLT_CAM_CONTROL.
 *
 */
typedef union BCM56800_A0_EGR_VXLT_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t egr_vxlt_cam_control[1];
	uint32_t _egr_vxlt_cam_control;
} BCM56800_A0_EGR_VXLT_CAM_CONTROLr_t;

#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr_CLR(r) (r).egr_vxlt_cam_control[0] = 0
#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr_SET(r,d) (r).egr_vxlt_cam_control[0] = d
#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr_GET(r) (r).egr_vxlt_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr_BIST_ENf_GET(r) (((r).egr_vxlt_cam_control[0]) & 0x1)
#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr_BIST_ENf_SET(r,f) (r).egr_vxlt_cam_control[0]=(((r).egr_vxlt_cam_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr_TMf_GET(r) ((((r).egr_vxlt_cam_control[0]) >> 1) & 0x7ff)
#define BCM56800_A0_EGR_VXLT_CAM_CONTROLr_TMf_SET(r,f) (r).egr_vxlt_cam_control[0]=(((r).egr_vxlt_cam_control[0] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))

/*
 * These macros can be used to access EGR_VXLT_CAM_CONTROL.
 *
 */
#define BCM56800_A0_READ_EGR_VXLT_CAM_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EGR_VXLT_CAM_CONTROLr,(r._egr_vxlt_cam_control))
#define BCM56800_A0_WRITE_EGR_VXLT_CAM_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EGR_VXLT_CAM_CONTROLr,&(r._egr_vxlt_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGR_VXLT_CAM_CONTROLr BCM56800_A0_EGR_VXLT_CAM_CONTROLr
#define EGR_VXLT_CAM_CONTROLr_SIZE BCM56800_A0_EGR_VXLT_CAM_CONTROLr_SIZE
typedef BCM56800_A0_EGR_VXLT_CAM_CONTROLr_t EGR_VXLT_CAM_CONTROLr_t;
#define EGR_VXLT_CAM_CONTROLr_CLR BCM56800_A0_EGR_VXLT_CAM_CONTROLr_CLR
#define EGR_VXLT_CAM_CONTROLr_SET BCM56800_A0_EGR_VXLT_CAM_CONTROLr_SET
#define EGR_VXLT_CAM_CONTROLr_GET BCM56800_A0_EGR_VXLT_CAM_CONTROLr_GET
#define EGR_VXLT_CAM_CONTROLr_BIST_ENf_GET BCM56800_A0_EGR_VXLT_CAM_CONTROLr_BIST_ENf_GET
#define EGR_VXLT_CAM_CONTROLr_BIST_ENf_SET BCM56800_A0_EGR_VXLT_CAM_CONTROLr_BIST_ENf_SET
#define EGR_VXLT_CAM_CONTROLr_TMf_GET BCM56800_A0_EGR_VXLT_CAM_CONTROLr_TMf_GET
#define EGR_VXLT_CAM_CONTROLr_TMf_SET BCM56800_A0_EGR_VXLT_CAM_CONTROLr_TMf_SET
#define READ_EGR_VXLT_CAM_CONTROLr BCM56800_A0_READ_EGR_VXLT_CAM_CONTROLr
#define WRITE_EGR_VXLT_CAM_CONTROLr BCM56800_A0_WRITE_EGR_VXLT_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EGR_VXLT_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EMIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Egress mirror bitmap register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM56800_A0_EMIRROR_CONTROLr 0x0e100044

#define BCM56800_A0_EMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program EMIRROR_CONTROL.
 *
 */
typedef union BCM56800_A0_EMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t emirror_control[1];
	uint32_t _emirror_control;
} BCM56800_A0_EMIRROR_CONTROLr_t;

#define BCM56800_A0_EMIRROR_CONTROLr_CLR(r) (r).emirror_control[0] = 0
#define BCM56800_A0_EMIRROR_CONTROLr_SET(r,d) (r).emirror_control[0] = d
#define BCM56800_A0_EMIRROR_CONTROLr_GET(r) (r).emirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EMIRROR_CONTROLr_BITMAPf_GET(r) (((r).emirror_control[0]) & 0x1fffff)
#define BCM56800_A0_EMIRROR_CONTROLr_BITMAPf_SET(r,f) (r).emirror_control[0]=(((r).emirror_control[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access EMIRROR_CONTROL.
 *
 */
#define BCM56800_A0_READ_EMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_EMIRROR_CONTROLr,(r._emirror_control))
#define BCM56800_A0_WRITE_EMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_EMIRROR_CONTROLr,&(r._emirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EMIRROR_CONTROLr BCM56800_A0_EMIRROR_CONTROLr
#define EMIRROR_CONTROLr_SIZE BCM56800_A0_EMIRROR_CONTROLr_SIZE
typedef BCM56800_A0_EMIRROR_CONTROLr_t EMIRROR_CONTROLr_t;
#define EMIRROR_CONTROLr_CLR BCM56800_A0_EMIRROR_CONTROLr_CLR
#define EMIRROR_CONTROLr_SET BCM56800_A0_EMIRROR_CONTROLr_SET
#define EMIRROR_CONTROLr_GET BCM56800_A0_EMIRROR_CONTROLr_GET
#define EMIRROR_CONTROLr_BITMAPf_GET BCM56800_A0_EMIRROR_CONTROLr_BITMAPf_GET
#define EMIRROR_CONTROLr_BITMAPf_SET BCM56800_A0_EMIRROR_CONTROLr_BITMAPf_SET
#define READ_EMIRROR_CONTROLr BCM56800_A0_READ_EMIRROR_CONTROLr
#define WRITE_EMIRROR_CONTROLr BCM56800_A0_WRITE_EMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EMMU_FUSE_DEBUG0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     S_RF             fuse values
 *
 ******************************************************************************/
#define BCM56800_A0_EMMU_FUSE_DEBUG0r 0x10d80027

#define BCM56800_A0_EMMU_FUSE_DEBUG0r_SIZE 4

/*
 * This structure should be used to declare and program EMMU_FUSE_DEBUG0.
 *
 */
typedef union BCM56800_A0_EMMU_FUSE_DEBUG0r_s {
	uint32_t v[1];
	uint32_t emmu_fuse_debug0[1];
	uint32_t _emmu_fuse_debug0;
} BCM56800_A0_EMMU_FUSE_DEBUG0r_t;

#define BCM56800_A0_EMMU_FUSE_DEBUG0r_CLR(r) (r).emmu_fuse_debug0[0] = 0
#define BCM56800_A0_EMMU_FUSE_DEBUG0r_SET(r,d) (r).emmu_fuse_debug0[0] = d
#define BCM56800_A0_EMMU_FUSE_DEBUG0r_GET(r) (r).emmu_fuse_debug0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EMMU_FUSE_DEBUG0r_S_RFf_GET(r) ((r).emmu_fuse_debug0[0])
#define BCM56800_A0_EMMU_FUSE_DEBUG0r_S_RFf_SET(r,f) (r).emmu_fuse_debug0[0]=((uint32_t)f)

/*
 * These macros can be used to access EMMU_FUSE_DEBUG0.
 *
 */
#define BCM56800_A0_READ_EMMU_FUSE_DEBUG0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EMMU_FUSE_DEBUG0r,(r._emmu_fuse_debug0))
#define BCM56800_A0_WRITE_EMMU_FUSE_DEBUG0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EMMU_FUSE_DEBUG0r,&(r._emmu_fuse_debug0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EMMU_FUSE_DEBUG0r BCM56800_A0_EMMU_FUSE_DEBUG0r
#define EMMU_FUSE_DEBUG0r_SIZE BCM56800_A0_EMMU_FUSE_DEBUG0r_SIZE
typedef BCM56800_A0_EMMU_FUSE_DEBUG0r_t EMMU_FUSE_DEBUG0r_t;
#define EMMU_FUSE_DEBUG0r_CLR BCM56800_A0_EMMU_FUSE_DEBUG0r_CLR
#define EMMU_FUSE_DEBUG0r_SET BCM56800_A0_EMMU_FUSE_DEBUG0r_SET
#define EMMU_FUSE_DEBUG0r_GET BCM56800_A0_EMMU_FUSE_DEBUG0r_GET
#define EMMU_FUSE_DEBUG0r_S_RFf_GET BCM56800_A0_EMMU_FUSE_DEBUG0r_S_RFf_GET
#define EMMU_FUSE_DEBUG0r_S_RFf_SET BCM56800_A0_EMMU_FUSE_DEBUG0r_S_RFf_SET
#define READ_EMMU_FUSE_DEBUG0r BCM56800_A0_READ_EMMU_FUSE_DEBUG0r
#define WRITE_EMMU_FUSE_DEBUG0r BCM56800_A0_WRITE_EMMU_FUSE_DEBUG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EMMU_FUSE_DEBUG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EMMU_FUSE_DEBUG1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     S_RF             fuse values
 *
 ******************************************************************************/
#define BCM56800_A0_EMMU_FUSE_DEBUG1r 0x10d80028

#define BCM56800_A0_EMMU_FUSE_DEBUG1r_SIZE 4

/*
 * This structure should be used to declare and program EMMU_FUSE_DEBUG1.
 *
 */
typedef union BCM56800_A0_EMMU_FUSE_DEBUG1r_s {
	uint32_t v[1];
	uint32_t emmu_fuse_debug1[1];
	uint32_t _emmu_fuse_debug1;
} BCM56800_A0_EMMU_FUSE_DEBUG1r_t;

#define BCM56800_A0_EMMU_FUSE_DEBUG1r_CLR(r) (r).emmu_fuse_debug1[0] = 0
#define BCM56800_A0_EMMU_FUSE_DEBUG1r_SET(r,d) (r).emmu_fuse_debug1[0] = d
#define BCM56800_A0_EMMU_FUSE_DEBUG1r_GET(r) (r).emmu_fuse_debug1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EMMU_FUSE_DEBUG1r_S_RFf_GET(r) ((r).emmu_fuse_debug1[0])
#define BCM56800_A0_EMMU_FUSE_DEBUG1r_S_RFf_SET(r,f) (r).emmu_fuse_debug1[0]=((uint32_t)f)

/*
 * These macros can be used to access EMMU_FUSE_DEBUG1.
 *
 */
#define BCM56800_A0_READ_EMMU_FUSE_DEBUG1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EMMU_FUSE_DEBUG1r,(r._emmu_fuse_debug1))
#define BCM56800_A0_WRITE_EMMU_FUSE_DEBUG1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EMMU_FUSE_DEBUG1r,&(r._emmu_fuse_debug1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EMMU_FUSE_DEBUG1r BCM56800_A0_EMMU_FUSE_DEBUG1r
#define EMMU_FUSE_DEBUG1r_SIZE BCM56800_A0_EMMU_FUSE_DEBUG1r_SIZE
typedef BCM56800_A0_EMMU_FUSE_DEBUG1r_t EMMU_FUSE_DEBUG1r_t;
#define EMMU_FUSE_DEBUG1r_CLR BCM56800_A0_EMMU_FUSE_DEBUG1r_CLR
#define EMMU_FUSE_DEBUG1r_SET BCM56800_A0_EMMU_FUSE_DEBUG1r_SET
#define EMMU_FUSE_DEBUG1r_GET BCM56800_A0_EMMU_FUSE_DEBUG1r_GET
#define EMMU_FUSE_DEBUG1r_S_RFf_GET BCM56800_A0_EMMU_FUSE_DEBUG1r_S_RFf_GET
#define EMMU_FUSE_DEBUG1r_S_RFf_SET BCM56800_A0_EMMU_FUSE_DEBUG1r_S_RFf_SET
#define READ_EMMU_FUSE_DEBUG1r BCM56800_A0_READ_EMMU_FUSE_DEBUG1r
#define WRITE_EMMU_FUSE_DEBUG1r BCM56800_A0_WRITE_EMMU_FUSE_DEBUG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EMMU_FUSE_DEBUG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EMMU_FUSE_DEBUG2
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     S_RF             fuse values
 *
 ******************************************************************************/
#define BCM56800_A0_EMMU_FUSE_DEBUG2r 0x10d80029

#define BCM56800_A0_EMMU_FUSE_DEBUG2r_SIZE 4

/*
 * This structure should be used to declare and program EMMU_FUSE_DEBUG2.
 *
 */
typedef union BCM56800_A0_EMMU_FUSE_DEBUG2r_s {
	uint32_t v[1];
	uint32_t emmu_fuse_debug2[1];
	uint32_t _emmu_fuse_debug2;
} BCM56800_A0_EMMU_FUSE_DEBUG2r_t;

#define BCM56800_A0_EMMU_FUSE_DEBUG2r_CLR(r) (r).emmu_fuse_debug2[0] = 0
#define BCM56800_A0_EMMU_FUSE_DEBUG2r_SET(r,d) (r).emmu_fuse_debug2[0] = d
#define BCM56800_A0_EMMU_FUSE_DEBUG2r_GET(r) (r).emmu_fuse_debug2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EMMU_FUSE_DEBUG2r_S_RFf_GET(r) (((r).emmu_fuse_debug2[0]) & 0xfffff)
#define BCM56800_A0_EMMU_FUSE_DEBUG2r_S_RFf_SET(r,f) (r).emmu_fuse_debug2[0]=(((r).emmu_fuse_debug2[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))

/*
 * These macros can be used to access EMMU_FUSE_DEBUG2.
 *
 */
#define BCM56800_A0_READ_EMMU_FUSE_DEBUG2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EMMU_FUSE_DEBUG2r,(r._emmu_fuse_debug2))
#define BCM56800_A0_WRITE_EMMU_FUSE_DEBUG2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EMMU_FUSE_DEBUG2r,&(r._emmu_fuse_debug2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EMMU_FUSE_DEBUG2r BCM56800_A0_EMMU_FUSE_DEBUG2r
#define EMMU_FUSE_DEBUG2r_SIZE BCM56800_A0_EMMU_FUSE_DEBUG2r_SIZE
typedef BCM56800_A0_EMMU_FUSE_DEBUG2r_t EMMU_FUSE_DEBUG2r_t;
#define EMMU_FUSE_DEBUG2r_CLR BCM56800_A0_EMMU_FUSE_DEBUG2r_CLR
#define EMMU_FUSE_DEBUG2r_SET BCM56800_A0_EMMU_FUSE_DEBUG2r_SET
#define EMMU_FUSE_DEBUG2r_GET BCM56800_A0_EMMU_FUSE_DEBUG2r_GET
#define EMMU_FUSE_DEBUG2r_S_RFf_GET BCM56800_A0_EMMU_FUSE_DEBUG2r_S_RFf_GET
#define EMMU_FUSE_DEBUG2r_S_RFf_SET BCM56800_A0_EMMU_FUSE_DEBUG2r_S_RFf_SET
#define READ_EMMU_FUSE_DEBUG2r BCM56800_A0_READ_EMMU_FUSE_DEBUG2r
#define WRITE_EMMU_FUSE_DEBUG2r BCM56800_A0_WRITE_EMMU_FUSE_DEBUG2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EMMU_FUSE_DEBUG2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  EM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Egress Mirror to Port Table
 * SIZE:     13
 * FIELDS:
 *     PORT_TGID        Mirror to port port/TGID
 *     MODULE_ID        Mirror to port module ID
 *
 ******************************************************************************/
#define BCM56800_A0_EM_MTP_INDEXm 0x0e169000

#define BCM56800_A0_EM_MTP_INDEXm_MIN 0
#define BCM56800_A0_EM_MTP_INDEXm_MAX 3
#define BCM56800_A0_EM_MTP_INDEXm_CMAX(u) 3
#define BCM56800_A0_EM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program EM_MTP_INDEX.
 *
 */
typedef union BCM56800_A0_EM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t em_mtp_index[1];
	uint32_t _em_mtp_index;
} BCM56800_A0_EM_MTP_INDEXm_t;

#define BCM56800_A0_EM_MTP_INDEXm_CLR(r) (r).em_mtp_index[0] = 0
#define BCM56800_A0_EM_MTP_INDEXm_SET(r,d) (r).em_mtp_index[0] = d
#define BCM56800_A0_EM_MTP_INDEXm_GET(r) (r).em_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EM_MTP_INDEXm_PORT_TGIDf_GET(r) (((r).em_mtp_index[0]) & 0x3f)
#define BCM56800_A0_EM_MTP_INDEXm_PORT_TGIDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_EM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).em_mtp_index[0]) >> 6) & 0x7f)
#define BCM56800_A0_EM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).em_mtp_index[0]=(((r).em_mtp_index[0] & ~((uint32_t)0x7f << 6)) | ((((uint32_t)f) & 0x7f) << 6))

/*
 * These macros can be used to access EM_MTP_INDEX.
 *
 */
#define BCM56800_A0_READ_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_EM_MTP_INDEXm,i,(m._em_mtp_index),1)
#define BCM56800_A0_WRITE_EM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_EM_MTP_INDEXm,i,&(m._em_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EM_MTP_INDEXm BCM56800_A0_EM_MTP_INDEXm
#define EM_MTP_INDEXm_MIN BCM56800_A0_EM_MTP_INDEXm_MIN
#define EM_MTP_INDEXm_MAX BCM56800_A0_EM_MTP_INDEXm_MAX
#define EM_MTP_INDEXm_CMAX(u) BCM56800_A0_EM_MTP_INDEXm_CMAX(u)
#define EM_MTP_INDEXm_SIZE BCM56800_A0_EM_MTP_INDEXm_SIZE
typedef BCM56800_A0_EM_MTP_INDEXm_t EM_MTP_INDEXm_t;
#define EM_MTP_INDEXm_CLR BCM56800_A0_EM_MTP_INDEXm_CLR
#define EM_MTP_INDEXm_SET BCM56800_A0_EM_MTP_INDEXm_SET
#define EM_MTP_INDEXm_GET BCM56800_A0_EM_MTP_INDEXm_GET
#define EM_MTP_INDEXm_PORT_TGIDf_GET BCM56800_A0_EM_MTP_INDEXm_PORT_TGIDf_GET
#define EM_MTP_INDEXm_PORT_TGIDf_SET BCM56800_A0_EM_MTP_INDEXm_PORT_TGIDf_SET
#define EM_MTP_INDEXm_MODULE_IDf_GET BCM56800_A0_EM_MTP_INDEXm_MODULE_IDf_GET
#define EM_MTP_INDEXm_MODULE_IDf_SET BCM56800_A0_EM_MTP_INDEXm_MODULE_IDf_SET
#define READ_EM_MTP_INDEXm BCM56800_A0_READ_EM_MTP_INDEXm
#define WRITE_EM_MTP_INDEXm BCM56800_A0_WRITE_EM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ENQ_IPMCGRP_TBL_PARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ADDR             parity error ptr.
 *
 ******************************************************************************/
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr 0x01d80000

#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program ENQ_IPMCGRP_TBL_PARITYERRORPTR.
 *
 */
typedef union BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t enq_ipmcgrp_tbl_parityerrorptr[1];
	uint32_t _enq_ipmcgrp_tbl_parityerrorptr;
} BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_t;

#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_CLR(r) (r).enq_ipmcgrp_tbl_parityerrorptr[0] = 0
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_SET(r,d) (r).enq_ipmcgrp_tbl_parityerrorptr[0] = d
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_GET(r) (r).enq_ipmcgrp_tbl_parityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_GET(r) (((r).enq_ipmcgrp_tbl_parityerrorptr[0]) & 0x3ff)
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_SET(r,f) (r).enq_ipmcgrp_tbl_parityerrorptr[0]=(((r).enq_ipmcgrp_tbl_parityerrorptr[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access ENQ_IPMCGRP_TBL_PARITYERRORPTR.
 *
 */
#define BCM56800_A0_READ_ENQ_IPMCGRP_TBL_PARITYERRORPTRr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr+(i),(r._enq_ipmcgrp_tbl_parityerrorptr))
#define BCM56800_A0_WRITE_ENQ_IPMCGRP_TBL_PARITYERRORPTRr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr+(i),&(r._enq_ipmcgrp_tbl_parityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ENQ_IPMCGRP_TBL_PARITYERRORPTRr BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr
#define ENQ_IPMCGRP_TBL_PARITYERRORPTRr_SIZE BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_SIZE
typedef BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_t ENQ_IPMCGRP_TBL_PARITYERRORPTRr_t;
#define ENQ_IPMCGRP_TBL_PARITYERRORPTRr_CLR BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_CLR
#define ENQ_IPMCGRP_TBL_PARITYERRORPTRr_SET BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_SET
#define ENQ_IPMCGRP_TBL_PARITYERRORPTRr_GET BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_GET
#define ENQ_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_GET BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_GET
#define ENQ_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_SET BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_SET
#define READ_ENQ_IPMCGRP_TBL_PARITYERRORPTRr BCM56800_A0_READ_ENQ_IPMCGRP_TBL_PARITYERRORPTRr
#define WRITE_ENQ_IPMCGRP_TBL_PARITYERRORPTRr BCM56800_A0_WRITE_ENQ_IPMCGRP_TBL_PARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ENQ_IPMCGRP_TBL_PARITYERROR_STATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     STATUS           parity error staus.
 *
 ******************************************************************************/
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr 0x01d80004

#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program ENQ_IPMCGRP_TBL_PARITYERROR_STATUS.
 *
 */
typedef union BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_s {
	uint32_t v[1];
	uint32_t enq_ipmcgrp_tbl_parityerror_status[1];
	uint32_t _enq_ipmcgrp_tbl_parityerror_status;
} BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_t;

#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_CLR(r) (r).enq_ipmcgrp_tbl_parityerror_status[0] = 0
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_SET(r,d) (r).enq_ipmcgrp_tbl_parityerror_status[0] = d
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_GET(r) (r).enq_ipmcgrp_tbl_parityerror_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_GET(r) (((r).enq_ipmcgrp_tbl_parityerror_status[0]) & 0xf)
#define BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_SET(r,f) (r).enq_ipmcgrp_tbl_parityerror_status[0]=(((r).enq_ipmcgrp_tbl_parityerror_status[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ENQ_IPMCGRP_TBL_PARITYERROR_STATUS.
 *
 */
#define BCM56800_A0_READ_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr,(r._enq_ipmcgrp_tbl_parityerror_status))
#define BCM56800_A0_WRITE_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr,&(r._enq_ipmcgrp_tbl_parityerror_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr
#define ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_SIZE BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_SIZE
typedef BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_t ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_t;
#define ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_CLR BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_CLR
#define ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_SET BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_SET
#define ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_GET BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_GET
#define ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_GET BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_GET
#define ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_SET BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_SET
#define READ_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr BCM56800_A0_READ_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr
#define WRITE_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr BCM56800_A0_WRITE_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ENQ_IPMCGRP_TBL_PARITYERROR_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  EPC_LINK_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Link status register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      Link status bitmap 
 *
 ******************************************************************************/
#define BCM56800_A0_EPC_LINK_BMAPr 0x0e18061e

#define BCM56800_A0_EPC_LINK_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program EPC_LINK_BMAP.
 *
 */
typedef union BCM56800_A0_EPC_LINK_BMAPr_s {
	uint32_t v[1];
	uint32_t epc_link_bmap[1];
	uint32_t _epc_link_bmap;
} BCM56800_A0_EPC_LINK_BMAPr_t;

#define BCM56800_A0_EPC_LINK_BMAPr_CLR(r) (r).epc_link_bmap[0] = 0
#define BCM56800_A0_EPC_LINK_BMAPr_SET(r,d) (r).epc_link_bmap[0] = d
#define BCM56800_A0_EPC_LINK_BMAPr_GET(r) (r).epc_link_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_EPC_LINK_BMAPr_PORT_BITMAPf_GET(r) (((r).epc_link_bmap[0]) & 0x1fffff)
#define BCM56800_A0_EPC_LINK_BMAPr_PORT_BITMAPf_SET(r,f) (r).epc_link_bmap[0]=(((r).epc_link_bmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access EPC_LINK_BMAP.
 *
 */
#define BCM56800_A0_READ_EPC_LINK_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_EPC_LINK_BMAPr,(r._epc_link_bmap))
#define BCM56800_A0_WRITE_EPC_LINK_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_EPC_LINK_BMAPr,&(r._epc_link_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EPC_LINK_BMAPr BCM56800_A0_EPC_LINK_BMAPr
#define EPC_LINK_BMAPr_SIZE BCM56800_A0_EPC_LINK_BMAPr_SIZE
typedef BCM56800_A0_EPC_LINK_BMAPr_t EPC_LINK_BMAPr_t;
#define EPC_LINK_BMAPr_CLR BCM56800_A0_EPC_LINK_BMAPr_CLR
#define EPC_LINK_BMAPr_SET BCM56800_A0_EPC_LINK_BMAPr_SET
#define EPC_LINK_BMAPr_GET BCM56800_A0_EPC_LINK_BMAPr_GET
#define EPC_LINK_BMAPr_PORT_BITMAPf_GET BCM56800_A0_EPC_LINK_BMAPr_PORT_BITMAPf_GET
#define EPC_LINK_BMAPr_PORT_BITMAPf_SET BCM56800_A0_EPC_LINK_BMAPr_PORT_BITMAPf_SET
#define READ_EPC_LINK_BMAPr BCM56800_A0_READ_EPC_LINK_BMAPr
#define WRITE_EPC_LINK_BMAPr BCM56800_A0_WRITE_EPC_LINK_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_EPC_LINK_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ESA0
 * BLOCKS:   GXPORT
 * DESC:     Station Adress[15:0]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [15:0]
 *
 ******************************************************************************/
#define BCM56800_A0_ESA0r 0x00f00210

#define BCM56800_A0_ESA0r_SIZE 4

/*
 * This structure should be used to declare and program ESA0.
 *
 */
typedef union BCM56800_A0_ESA0r_s {
	uint32_t v[1];
	uint32_t esa0[1];
	uint32_t _esa0;
} BCM56800_A0_ESA0r_t;

#define BCM56800_A0_ESA0r_CLR(r) (r).esa0[0] = 0
#define BCM56800_A0_ESA0r_SET(r,d) (r).esa0[0] = d
#define BCM56800_A0_ESA0r_GET(r) (r).esa0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ESA0r_STAD0f_GET(r) (((r).esa0[0]) & 0xffff)
#define BCM56800_A0_ESA0r_STAD0f_SET(r,f) (r).esa0[0]=(((r).esa0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA0.
 *
 */
#define BCM56800_A0_READ_ESA0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ESA0r,(r._esa0))
#define BCM56800_A0_WRITE_ESA0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ESA0r,&(r._esa0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA0r BCM56800_A0_ESA0r
#define ESA0r_SIZE BCM56800_A0_ESA0r_SIZE
typedef BCM56800_A0_ESA0r_t ESA0r_t;
#define ESA0r_CLR BCM56800_A0_ESA0r_CLR
#define ESA0r_SET BCM56800_A0_ESA0r_SET
#define ESA0r_GET BCM56800_A0_ESA0r_GET
#define ESA0r_STAD0f_GET BCM56800_A0_ESA0r_STAD0f_GET
#define ESA0r_STAD0f_SET BCM56800_A0_ESA0r_STAD0f_SET
#define READ_ESA0r BCM56800_A0_READ_ESA0r
#define WRITE_ESA0r BCM56800_A0_WRITE_ESA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ESA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ESA1
 * BLOCKS:   GXPORT
 * DESC:     Station Adress[31:16]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [31:16]
 *
 ******************************************************************************/
#define BCM56800_A0_ESA1r 0x00f00211

#define BCM56800_A0_ESA1r_SIZE 4

/*
 * This structure should be used to declare and program ESA1.
 *
 */
typedef union BCM56800_A0_ESA1r_s {
	uint32_t v[1];
	uint32_t esa1[1];
	uint32_t _esa1;
} BCM56800_A0_ESA1r_t;

#define BCM56800_A0_ESA1r_CLR(r) (r).esa1[0] = 0
#define BCM56800_A0_ESA1r_SET(r,d) (r).esa1[0] = d
#define BCM56800_A0_ESA1r_GET(r) (r).esa1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ESA1r_STAD0f_GET(r) (((r).esa1[0]) & 0xffff)
#define BCM56800_A0_ESA1r_STAD0f_SET(r,f) (r).esa1[0]=(((r).esa1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA1.
 *
 */
#define BCM56800_A0_READ_ESA1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ESA1r,(r._esa1))
#define BCM56800_A0_WRITE_ESA1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ESA1r,&(r._esa1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA1r BCM56800_A0_ESA1r
#define ESA1r_SIZE BCM56800_A0_ESA1r_SIZE
typedef BCM56800_A0_ESA1r_t ESA1r_t;
#define ESA1r_CLR BCM56800_A0_ESA1r_CLR
#define ESA1r_SET BCM56800_A0_ESA1r_SET
#define ESA1r_GET BCM56800_A0_ESA1r_GET
#define ESA1r_STAD0f_GET BCM56800_A0_ESA1r_STAD0f_GET
#define ESA1r_STAD0f_SET BCM56800_A0_ESA1r_STAD0f_SET
#define READ_ESA1r BCM56800_A0_READ_ESA1r
#define WRITE_ESA1r BCM56800_A0_WRITE_ESA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ESA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ESA2
 * BLOCKS:   GXPORT
 * DESC:     Station Adress[47:32]
 * SIZE:     32
 * FIELDS:
 *     STAD0            Station Address [47:32]
 *
 ******************************************************************************/
#define BCM56800_A0_ESA2r 0x00f00212

#define BCM56800_A0_ESA2r_SIZE 4

/*
 * This structure should be used to declare and program ESA2.
 *
 */
typedef union BCM56800_A0_ESA2r_s {
	uint32_t v[1];
	uint32_t esa2[1];
	uint32_t _esa2;
} BCM56800_A0_ESA2r_t;

#define BCM56800_A0_ESA2r_CLR(r) (r).esa2[0] = 0
#define BCM56800_A0_ESA2r_SET(r,d) (r).esa2[0] = d
#define BCM56800_A0_ESA2r_GET(r) (r).esa2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ESA2r_STAD0f_GET(r) (((r).esa2[0]) & 0xffff)
#define BCM56800_A0_ESA2r_STAD0f_SET(r,f) (r).esa2[0]=(((r).esa2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ESA2.
 *
 */
#define BCM56800_A0_READ_ESA2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ESA2r,(r._esa2))
#define BCM56800_A0_WRITE_ESA2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ESA2r,&(r._esa2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESA2r BCM56800_A0_ESA2r
#define ESA2r_SIZE BCM56800_A0_ESA2r_SIZE
typedef BCM56800_A0_ESA2r_t ESA2r_t;
#define ESA2r_CLR BCM56800_A0_ESA2r_CLR
#define ESA2r_SET BCM56800_A0_ESA2r_SET
#define ESA2r_GET BCM56800_A0_ESA2r_GET
#define ESA2r_STAD0f_GET BCM56800_A0_ESA2r_STAD0f_GET
#define ESA2r_STAD0f_SET BCM56800_A0_ESA2r_STAD0f_SET
#define READ_ESA2r BCM56800_A0_READ_ESA2r
#define WRITE_ESA2r BCM56800_A0_WRITE_ESA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ESA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ESCONFIG
 * BLOCKS:   MMU
 * DESC:     Egress Scheduler Configuration Register
 * SIZE:     32
 * FIELDS:
 *     SCHEDULING_SELECT Scheduling_Mode Options0: Strict Priority (SP) scheduling among valid COSs. (default value)1: Round Robin (RR) scheduling among valid COSs.2: Weightd Round Robin (WRR) scheduling according to each COS's Weight.3: Weighted Deficit Round Robin (WDRR) scheduling according to each COS's    length and weight.
 *     MTU_QUANTA_SELECT In WDRR mode, each weight is multiplied by MTU quanta which is defined by MTU_Quanta_Select:0: MTU Quanta is 2048 bytes. (default value)1: MTU Quanta is 4096 bytes.2: MTU Quanta is 8192 bytes.3: MTU Quanta is 16384 bytes 
 *
 ******************************************************************************/
#define BCM56800_A0_ESCONFIGr 0x06d00000

#define BCM56800_A0_ESCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ESCONFIG.
 *
 */
typedef union BCM56800_A0_ESCONFIGr_s {
	uint32_t v[1];
	uint32_t esconfig[1];
	uint32_t _esconfig;
} BCM56800_A0_ESCONFIGr_t;

#define BCM56800_A0_ESCONFIGr_CLR(r) (r).esconfig[0] = 0
#define BCM56800_A0_ESCONFIGr_SET(r,d) (r).esconfig[0] = d
#define BCM56800_A0_ESCONFIGr_GET(r) (r).esconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ESCONFIGr_SCHEDULING_SELECTf_GET(r) (((r).esconfig[0]) & 0x3)
#define BCM56800_A0_ESCONFIGr_SCHEDULING_SELECTf_SET(r,f) (r).esconfig[0]=(((r).esconfig[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_ESCONFIGr_MTU_QUANTA_SELECTf_GET(r) ((((r).esconfig[0]) >> 2) & 0x3)
#define BCM56800_A0_ESCONFIGr_MTU_QUANTA_SELECTf_SET(r,f) (r).esconfig[0]=(((r).esconfig[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))

/*
 * These macros can be used to access ESCONFIG.
 *
 */
#define BCM56800_A0_READ_ESCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ESCONFIGr,(r._esconfig))
#define BCM56800_A0_WRITE_ESCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ESCONFIGr,&(r._esconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESCONFIGr BCM56800_A0_ESCONFIGr
#define ESCONFIGr_SIZE BCM56800_A0_ESCONFIGr_SIZE
typedef BCM56800_A0_ESCONFIGr_t ESCONFIGr_t;
#define ESCONFIGr_CLR BCM56800_A0_ESCONFIGr_CLR
#define ESCONFIGr_SET BCM56800_A0_ESCONFIGr_SET
#define ESCONFIGr_GET BCM56800_A0_ESCONFIGr_GET
#define ESCONFIGr_SCHEDULING_SELECTf_GET BCM56800_A0_ESCONFIGr_SCHEDULING_SELECTf_GET
#define ESCONFIGr_SCHEDULING_SELECTf_SET BCM56800_A0_ESCONFIGr_SCHEDULING_SELECTf_SET
#define ESCONFIGr_MTU_QUANTA_SELECTf_GET BCM56800_A0_ESCONFIGr_MTU_QUANTA_SELECTf_GET
#define ESCONFIGr_MTU_QUANTA_SELECTf_SET BCM56800_A0_ESCONFIGr_MTU_QUANTA_SELECTf_SET
#define READ_ESCONFIGr BCM56800_A0_READ_ESCONFIGr
#define WRITE_ESCONFIGr BCM56800_A0_WRITE_ESCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ESCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ESTDMCONFIG
 * BLOCKS:   MMU
 * DESC:     Egress Scheduler TDM Mode Configuration Register
 * SIZE:     32
 * FIELDS:
 *     TDMMODE0         Port TDM Scheduling Select for Pipeline 0:0: 8 cycles for 12G HG ports,1: 10 cycles for 10G HG ports,
 *     TDMMODE1         Port TDM Scheduling Select for Pipeline 1:0: 8 cycles for 12G HG ports and one cpu port,1: 10 cycles for 10G HG ports and one cpu port,
 *     CMICSLOTSEL      Port TDM Scheduling Select for Pipeline 1:2'b00: 100-cycle slot time spacing for inserting one cpu slot,2'b01: 200-cycle slot time spacing for inserting one cpu slot,2'b10: 300-cycle slot time spacing for inserting one cpu slot,2'b11: 400-cycle slot time spacing for inserting one cpu slot,
 *
 ******************************************************************************/
#define BCM56800_A0_ESTDMCONFIGr 0x06d80004

#define BCM56800_A0_ESTDMCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ESTDMCONFIG.
 *
 */
typedef union BCM56800_A0_ESTDMCONFIGr_s {
	uint32_t v[1];
	uint32_t estdmconfig[1];
	uint32_t _estdmconfig;
} BCM56800_A0_ESTDMCONFIGr_t;

#define BCM56800_A0_ESTDMCONFIGr_CLR(r) (r).estdmconfig[0] = 0
#define BCM56800_A0_ESTDMCONFIGr_SET(r,d) (r).estdmconfig[0] = d
#define BCM56800_A0_ESTDMCONFIGr_GET(r) (r).estdmconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ESTDMCONFIGr_TDMMODE0f_GET(r) (((r).estdmconfig[0]) & 0x1)
#define BCM56800_A0_ESTDMCONFIGr_TDMMODE0f_SET(r,f) (r).estdmconfig[0]=(((r).estdmconfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_ESTDMCONFIGr_TDMMODE1f_GET(r) ((((r).estdmconfig[0]) >> 1) & 0x1)
#define BCM56800_A0_ESTDMCONFIGr_TDMMODE1f_SET(r,f) (r).estdmconfig[0]=(((r).estdmconfig[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_ESTDMCONFIGr_CMICSLOTSELf_GET(r) ((((r).estdmconfig[0]) >> 2) & 0x3)
#define BCM56800_A0_ESTDMCONFIGr_CMICSLOTSELf_SET(r,f) (r).estdmconfig[0]=(((r).estdmconfig[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))

/*
 * These macros can be used to access ESTDMCONFIG.
 *
 */
#define BCM56800_A0_READ_ESTDMCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ESTDMCONFIGr,(r._estdmconfig))
#define BCM56800_A0_WRITE_ESTDMCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ESTDMCONFIGr,&(r._estdmconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ESTDMCONFIGr BCM56800_A0_ESTDMCONFIGr
#define ESTDMCONFIGr_SIZE BCM56800_A0_ESTDMCONFIGr_SIZE
typedef BCM56800_A0_ESTDMCONFIGr_t ESTDMCONFIGr_t;
#define ESTDMCONFIGr_CLR BCM56800_A0_ESTDMCONFIGr_CLR
#define ESTDMCONFIGr_SET BCM56800_A0_ESTDMCONFIGr_SET
#define ESTDMCONFIGr_GET BCM56800_A0_ESTDMCONFIGr_GET
#define ESTDMCONFIGr_TDMMODE0f_GET BCM56800_A0_ESTDMCONFIGr_TDMMODE0f_GET
#define ESTDMCONFIGr_TDMMODE0f_SET BCM56800_A0_ESTDMCONFIGr_TDMMODE0f_SET
#define ESTDMCONFIGr_TDMMODE1f_GET BCM56800_A0_ESTDMCONFIGr_TDMMODE1f_GET
#define ESTDMCONFIGr_TDMMODE1f_SET BCM56800_A0_ESTDMCONFIGr_TDMMODE1f_SET
#define ESTDMCONFIGr_CMICSLOTSELf_GET BCM56800_A0_ESTDMCONFIGr_CMICSLOTSELf_GET
#define ESTDMCONFIGr_CMICSLOTSELf_SET BCM56800_A0_ESTDMCONFIGr_CMICSLOTSELf_SET
#define READ_ESTDMCONFIGr BCM56800_A0_READ_ESTDMCONFIGr
#define WRITE_ESTDMCONFIGr BCM56800_A0_WRITE_ESTDMCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ESTDMCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ES_BYPASSMMU
 * BLOCKS:   MMU
 * DESC:     MMUBYPASS
 * SIZE:     32
 * FIELDS:
 *     BYPASSMMU        MMU is bypassed if this bit is set to logic one, PBI bus is tied to PBE bus directly.This bypass register will stop egress scheduler reciving cell length informationfrom ep.
 *
 ******************************************************************************/
#define BCM56800_A0_ES_BYPASSMMUr 0x06d80050

#define BCM56800_A0_ES_BYPASSMMUr_SIZE 4

/*
 * This structure should be used to declare and program ES_BYPASSMMU.
 *
 */
typedef union BCM56800_A0_ES_BYPASSMMUr_s {
	uint32_t v[1];
	uint32_t es_bypassmmu[1];
	uint32_t _es_bypassmmu;
} BCM56800_A0_ES_BYPASSMMUr_t;

#define BCM56800_A0_ES_BYPASSMMUr_CLR(r) (r).es_bypassmmu[0] = 0
#define BCM56800_A0_ES_BYPASSMMUr_SET(r,d) (r).es_bypassmmu[0] = d
#define BCM56800_A0_ES_BYPASSMMUr_GET(r) (r).es_bypassmmu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ES_BYPASSMMUr_BYPASSMMUf_GET(r) (((r).es_bypassmmu[0]) & 0x1)
#define BCM56800_A0_ES_BYPASSMMUr_BYPASSMMUf_SET(r,f) (r).es_bypassmmu[0]=(((r).es_bypassmmu[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access ES_BYPASSMMU.
 *
 */
#define BCM56800_A0_READ_ES_BYPASSMMUr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ES_BYPASSMMUr,(r._es_bypassmmu))
#define BCM56800_A0_WRITE_ES_BYPASSMMUr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ES_BYPASSMMUr,&(r._es_bypassmmu))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ES_BYPASSMMUr BCM56800_A0_ES_BYPASSMMUr
#define ES_BYPASSMMUr_SIZE BCM56800_A0_ES_BYPASSMMUr_SIZE
typedef BCM56800_A0_ES_BYPASSMMUr_t ES_BYPASSMMUr_t;
#define ES_BYPASSMMUr_CLR BCM56800_A0_ES_BYPASSMMUr_CLR
#define ES_BYPASSMMUr_SET BCM56800_A0_ES_BYPASSMMUr_SET
#define ES_BYPASSMMUr_GET BCM56800_A0_ES_BYPASSMMUr_GET
#define ES_BYPASSMMUr_BYPASSMMUf_GET BCM56800_A0_ES_BYPASSMMUr_BYPASSMMUf_GET
#define ES_BYPASSMMUr_BYPASSMMUf_SET BCM56800_A0_ES_BYPASSMMUr_BYPASSMMUf_SET
#define READ_ES_BYPASSMMUr BCM56800_A0_READ_ES_BYPASSMMUr
#define WRITE_ES_BYPASSMMUr BCM56800_A0_WRITE_ES_BYPASSMMUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ES_BYPASSMMUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_CLRT
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet Collision Window/Retry Register.
 * SIZE:     32
 * FIELDS:
 *     RETRY            Number of retransmit attempts before aborting due to excessive collisions 
 *     COL_WIN          Slot time or collision window during which collisions occur
 *
 ******************************************************************************/
#define BCM56800_A0_FE_CLRTr 0x00f00204

#define BCM56800_A0_FE_CLRTr_SIZE 4

/*
 * This structure should be used to declare and program FE_CLRT.
 *
 */
typedef union BCM56800_A0_FE_CLRTr_s {
	uint32_t v[1];
	uint32_t fe_clrt[1];
	uint32_t _fe_clrt;
} BCM56800_A0_FE_CLRTr_t;

#define BCM56800_A0_FE_CLRTr_CLR(r) (r).fe_clrt[0] = 0
#define BCM56800_A0_FE_CLRTr_SET(r,d) (r).fe_clrt[0] = d
#define BCM56800_A0_FE_CLRTr_GET(r) (r).fe_clrt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_CLRTr_RETRYf_GET(r) (((r).fe_clrt[0]) & 0xf)
#define BCM56800_A0_FE_CLRTr_RETRYf_SET(r,f) (r).fe_clrt[0]=(((r).fe_clrt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_FE_CLRTr_COL_WINf_GET(r) ((((r).fe_clrt[0]) >> 8) & 0x3f)
#define BCM56800_A0_FE_CLRTr_COL_WINf_SET(r,f) (r).fe_clrt[0]=(((r).fe_clrt[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))

/*
 * These macros can be used to access FE_CLRT.
 *
 */
#define BCM56800_A0_READ_FE_CLRTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_CLRTr,(r._fe_clrt))
#define BCM56800_A0_WRITE_FE_CLRTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_CLRTr,&(r._fe_clrt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_CLRTr BCM56800_A0_FE_CLRTr
#define FE_CLRTr_SIZE BCM56800_A0_FE_CLRTr_SIZE
typedef BCM56800_A0_FE_CLRTr_t FE_CLRTr_t;
#define FE_CLRTr_CLR BCM56800_A0_FE_CLRTr_CLR
#define FE_CLRTr_SET BCM56800_A0_FE_CLRTr_SET
#define FE_CLRTr_GET BCM56800_A0_FE_CLRTr_GET
#define FE_CLRTr_RETRYf_GET BCM56800_A0_FE_CLRTr_RETRYf_GET
#define FE_CLRTr_RETRYf_SET BCM56800_A0_FE_CLRTr_RETRYf_SET
#define FE_CLRTr_COL_WINf_GET BCM56800_A0_FE_CLRTr_COL_WINf_GET
#define FE_CLRTr_COL_WINf_SET BCM56800_A0_FE_CLRTr_COL_WINf_SET
#define READ_FE_CLRTr BCM56800_A0_READ_FE_CLRTr
#define WRITE_FE_CLRTr BCM56800_A0_WRITE_FE_CLRTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_CLRTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_EXCESSIVE_DEFER_LIMIT
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet Excessive Deferral Limit Register
 * SIZE:     32
 * FIELDS:
 *     LIMIT            Excessive Deferral Limit Value (programmed to (4*MAX_FRAME-1)If FE_SUPP.BIT_MODE is set to 1'b1, then this register should be programmed to 16*(MAX_FRAME)-1
 *
 ******************************************************************************/
#define BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr 0x00f0020f

#define BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program FE_EXCESSIVE_DEFER_LIMIT.
 *
 */
typedef union BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_s {
	uint32_t v[1];
	uint32_t fe_excessive_defer_limit[1];
	uint32_t _fe_excessive_defer_limit;
} BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_t;

#define BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_CLR(r) (r).fe_excessive_defer_limit[0] = 0
#define BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_SET(r,d) (r).fe_excessive_defer_limit[0] = d
#define BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_GET(r) (r).fe_excessive_defer_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET(r) (((r).fe_excessive_defer_limit[0]) & 0xffff)
#define BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET(r,f) (r).fe_excessive_defer_limit[0]=(((r).fe_excessive_defer_limit[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FE_EXCESSIVE_DEFER_LIMIT.
 *
 */
#define BCM56800_A0_READ_FE_EXCESSIVE_DEFER_LIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr,(r._fe_excessive_defer_limit))
#define BCM56800_A0_WRITE_FE_EXCESSIVE_DEFER_LIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr,&(r._fe_excessive_defer_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_EXCESSIVE_DEFER_LIMITr BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr
#define FE_EXCESSIVE_DEFER_LIMITr_SIZE BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_SIZE
typedef BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_t FE_EXCESSIVE_DEFER_LIMITr_t;
#define FE_EXCESSIVE_DEFER_LIMITr_CLR BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_CLR
#define FE_EXCESSIVE_DEFER_LIMITr_SET BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_SET
#define FE_EXCESSIVE_DEFER_LIMITr_GET BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_GET
#define FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_GET
#define FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr_LIMITf_SET
#define READ_FE_EXCESSIVE_DEFER_LIMITr BCM56800_A0_READ_FE_EXCESSIVE_DEFER_LIMITr
#define WRITE_FE_EXCESSIVE_DEFER_LIMITr BCM56800_A0_WRITE_FE_EXCESSIVE_DEFER_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_EXCESSIVE_DEFER_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_IPGR
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet IPGR Register for non back to back transmit.
 * SIZE:     32
 * FIELDS:
 *     IPGR2            IPG Part 2 for non-back to back transmit
 *     IPGR1            IPG Part 1 for non-back to back transmit
 *
 ******************************************************************************/
#define BCM56800_A0_FE_IPGRr 0x00f00203

#define BCM56800_A0_FE_IPGRr_SIZE 4

/*
 * This structure should be used to declare and program FE_IPGR.
 *
 */
typedef union BCM56800_A0_FE_IPGRr_s {
	uint32_t v[1];
	uint32_t fe_ipgr[1];
	uint32_t _fe_ipgr;
} BCM56800_A0_FE_IPGRr_t;

#define BCM56800_A0_FE_IPGRr_CLR(r) (r).fe_ipgr[0] = 0
#define BCM56800_A0_FE_IPGRr_SET(r,d) (r).fe_ipgr[0] = d
#define BCM56800_A0_FE_IPGRr_GET(r) (r).fe_ipgr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_IPGRr_IPGR2f_GET(r) (((r).fe_ipgr[0]) & 0x7f)
#define BCM56800_A0_FE_IPGRr_IPGR2f_SET(r,f) (r).fe_ipgr[0]=(((r).fe_ipgr[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56800_A0_FE_IPGRr_IPGR1f_GET(r) ((((r).fe_ipgr[0]) >> 8) & 0x7f)
#define BCM56800_A0_FE_IPGRr_IPGR1f_SET(r,f) (r).fe_ipgr[0]=(((r).fe_ipgr[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))

/*
 * These macros can be used to access FE_IPGR.
 *
 */
#define BCM56800_A0_READ_FE_IPGRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_IPGRr,(r._fe_ipgr))
#define BCM56800_A0_WRITE_FE_IPGRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_IPGRr,&(r._fe_ipgr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_IPGRr BCM56800_A0_FE_IPGRr
#define FE_IPGRr_SIZE BCM56800_A0_FE_IPGRr_SIZE
typedef BCM56800_A0_FE_IPGRr_t FE_IPGRr_t;
#define FE_IPGRr_CLR BCM56800_A0_FE_IPGRr_CLR
#define FE_IPGRr_SET BCM56800_A0_FE_IPGRr_SET
#define FE_IPGRr_GET BCM56800_A0_FE_IPGRr_GET
#define FE_IPGRr_IPGR2f_GET BCM56800_A0_FE_IPGRr_IPGR2f_GET
#define FE_IPGRr_IPGR2f_SET BCM56800_A0_FE_IPGRr_IPGR2f_SET
#define FE_IPGRr_IPGR1f_GET BCM56800_A0_FE_IPGRr_IPGR1f_GET
#define FE_IPGRr_IPGR1f_SET BCM56800_A0_FE_IPGRr_IPGR1f_SET
#define READ_FE_IPGRr BCM56800_A0_READ_FE_IPGRr
#define WRITE_FE_IPGRr BCM56800_A0_WRITE_FE_IPGRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_IPGRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_IPGT
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet IPGT Register for back to back transmit.
 * SIZE:     32
 * FIELDS:
 *     IPGT             IPG between back to back transmit packets in units of bytes
 *
 ******************************************************************************/
#define BCM56800_A0_FE_IPGTr 0x00f00202

#define BCM56800_A0_FE_IPGTr_SIZE 4

/*
 * This structure should be used to declare and program FE_IPGT.
 *
 */
typedef union BCM56800_A0_FE_IPGTr_s {
	uint32_t v[1];
	uint32_t fe_ipgt[1];
	uint32_t _fe_ipgt;
} BCM56800_A0_FE_IPGTr_t;

#define BCM56800_A0_FE_IPGTr_CLR(r) (r).fe_ipgt[0] = 0
#define BCM56800_A0_FE_IPGTr_SET(r,d) (r).fe_ipgt[0] = d
#define BCM56800_A0_FE_IPGTr_GET(r) (r).fe_ipgt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_IPGTr_IPGTf_GET(r) (((r).fe_ipgt[0]) & 0x7f)
#define BCM56800_A0_FE_IPGTr_IPGTf_SET(r,f) (r).fe_ipgt[0]=(((r).fe_ipgt[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access FE_IPGT.
 *
 */
#define BCM56800_A0_READ_FE_IPGTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_IPGTr,(r._fe_ipgt))
#define BCM56800_A0_WRITE_FE_IPGTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_IPGTr,&(r._fe_ipgt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_IPGTr BCM56800_A0_FE_IPGTr
#define FE_IPGTr_SIZE BCM56800_A0_FE_IPGTr_SIZE
typedef BCM56800_A0_FE_IPGTr_t FE_IPGTr_t;
#define FE_IPGTr_CLR BCM56800_A0_FE_IPGTr_CLR
#define FE_IPGTr_SET BCM56800_A0_FE_IPGTr_SET
#define FE_IPGTr_GET BCM56800_A0_FE_IPGTr_GET
#define FE_IPGTr_IPGTf_GET BCM56800_A0_FE_IPGTr_IPGTf_GET
#define FE_IPGTr_IPGTf_SET BCM56800_A0_FE_IPGTr_IPGTf_SET
#define READ_FE_IPGTr BCM56800_A0_READ_FE_IPGTr
#define WRITE_FE_IPGTr BCM56800_A0_WRITE_FE_IPGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_IPGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_MAC1
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet MAC Configuration 1 Register.
 * SIZE:     32
 * FIELDS:
 *     RX_EN            RX Enable
 *     PASSALL          Pass All Rx Frames
 *     RX_PAU           RX Flow control
 *     TX_PAU           TX Flow control
 *     LBACK            Loopback
 *     HRTFN            reset for transmit blocks
 *     HRRFN            reset for receive blocks
 *     R_EXTEND_RANDOM_NUMBER_GENERATOR If 0, randon number generator in FE mac is unchanged.  If 1, random number generator in mac is extended to 23 bits with a new polynomial
 *     R_RNG_GATE       Disable (0) or enable (1) inclusion of state bits into random number generator in FE mac.
 *     RST_SIM          Reset Simulation
 *     SRST             Soft reset (Not used, control from GMACC0)
 *
 ******************************************************************************/
#define BCM56800_A0_FE_MAC1r 0x00f00200

#define BCM56800_A0_FE_MAC1r_SIZE 4

/*
 * This structure should be used to declare and program FE_MAC1.
 *
 */
typedef union BCM56800_A0_FE_MAC1r_s {
	uint32_t v[1];
	uint32_t fe_mac1[1];
	uint32_t _fe_mac1;
} BCM56800_A0_FE_MAC1r_t;

#define BCM56800_A0_FE_MAC1r_CLR(r) (r).fe_mac1[0] = 0
#define BCM56800_A0_FE_MAC1r_SET(r,d) (r).fe_mac1[0] = d
#define BCM56800_A0_FE_MAC1r_GET(r) (r).fe_mac1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_MAC1r_RX_ENf_GET(r) (((r).fe_mac1[0]) & 0x1)
#define BCM56800_A0_FE_MAC1r_RX_ENf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FE_MAC1r_PASSALLf_GET(r) ((((r).fe_mac1[0]) >> 1) & 0x1)
#define BCM56800_A0_FE_MAC1r_PASSALLf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_FE_MAC1r_RX_PAUf_GET(r) ((((r).fe_mac1[0]) >> 2) & 0x1)
#define BCM56800_A0_FE_MAC1r_RX_PAUf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_FE_MAC1r_TX_PAUf_GET(r) ((((r).fe_mac1[0]) >> 3) & 0x1)
#define BCM56800_A0_FE_MAC1r_TX_PAUf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_FE_MAC1r_LBACKf_GET(r) ((((r).fe_mac1[0]) >> 4) & 0x1)
#define BCM56800_A0_FE_MAC1r_LBACKf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_FE_MAC1r_HRTFNf_GET(r) ((((r).fe_mac1[0]) >> 8) & 0x1)
#define BCM56800_A0_FE_MAC1r_HRTFNf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_FE_MAC1r_HRRFNf_GET(r) ((((r).fe_mac1[0]) >> 10) & 0x1)
#define BCM56800_A0_FE_MAC1r_HRRFNf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET(r) ((((r).fe_mac1[0]) >> 12) & 0x1)
#define BCM56800_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_FE_MAC1r_R_RNG_GATEf_GET(r) ((((r).fe_mac1[0]) >> 13) & 0x1)
#define BCM56800_A0_FE_MAC1r_R_RNG_GATEf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_FE_MAC1r_RST_SIMf_GET(r) ((((r).fe_mac1[0]) >> 14) & 0x1)
#define BCM56800_A0_FE_MAC1r_RST_SIMf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_FE_MAC1r_SRSTf_GET(r) ((((r).fe_mac1[0]) >> 15) & 0x1)
#define BCM56800_A0_FE_MAC1r_SRSTf_SET(r,f) (r).fe_mac1[0]=(((r).fe_mac1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FE_MAC1.
 *
 */
#define BCM56800_A0_READ_FE_MAC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_MAC1r,(r._fe_mac1))
#define BCM56800_A0_WRITE_FE_MAC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_MAC1r,&(r._fe_mac1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAC1r BCM56800_A0_FE_MAC1r
#define FE_MAC1r_SIZE BCM56800_A0_FE_MAC1r_SIZE
typedef BCM56800_A0_FE_MAC1r_t FE_MAC1r_t;
#define FE_MAC1r_CLR BCM56800_A0_FE_MAC1r_CLR
#define FE_MAC1r_SET BCM56800_A0_FE_MAC1r_SET
#define FE_MAC1r_GET BCM56800_A0_FE_MAC1r_GET
#define FE_MAC1r_RX_ENf_GET BCM56800_A0_FE_MAC1r_RX_ENf_GET
#define FE_MAC1r_RX_ENf_SET BCM56800_A0_FE_MAC1r_RX_ENf_SET
#define FE_MAC1r_PASSALLf_GET BCM56800_A0_FE_MAC1r_PASSALLf_GET
#define FE_MAC1r_PASSALLf_SET BCM56800_A0_FE_MAC1r_PASSALLf_SET
#define FE_MAC1r_RX_PAUf_GET BCM56800_A0_FE_MAC1r_RX_PAUf_GET
#define FE_MAC1r_RX_PAUf_SET BCM56800_A0_FE_MAC1r_RX_PAUf_SET
#define FE_MAC1r_TX_PAUf_GET BCM56800_A0_FE_MAC1r_TX_PAUf_GET
#define FE_MAC1r_TX_PAUf_SET BCM56800_A0_FE_MAC1r_TX_PAUf_SET
#define FE_MAC1r_LBACKf_GET BCM56800_A0_FE_MAC1r_LBACKf_GET
#define FE_MAC1r_LBACKf_SET BCM56800_A0_FE_MAC1r_LBACKf_SET
#define FE_MAC1r_HRTFNf_GET BCM56800_A0_FE_MAC1r_HRTFNf_GET
#define FE_MAC1r_HRTFNf_SET BCM56800_A0_FE_MAC1r_HRTFNf_SET
#define FE_MAC1r_HRRFNf_GET BCM56800_A0_FE_MAC1r_HRRFNf_GET
#define FE_MAC1r_HRRFNf_SET BCM56800_A0_FE_MAC1r_HRRFNf_SET
#define FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET BCM56800_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_GET
#define FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET BCM56800_A0_FE_MAC1r_R_EXTEND_RANDOM_NUMBER_GENERATORf_SET
#define FE_MAC1r_R_RNG_GATEf_GET BCM56800_A0_FE_MAC1r_R_RNG_GATEf_GET
#define FE_MAC1r_R_RNG_GATEf_SET BCM56800_A0_FE_MAC1r_R_RNG_GATEf_SET
#define FE_MAC1r_RST_SIMf_GET BCM56800_A0_FE_MAC1r_RST_SIMf_GET
#define FE_MAC1r_RST_SIMf_SET BCM56800_A0_FE_MAC1r_RST_SIMf_SET
#define FE_MAC1r_SRSTf_GET BCM56800_A0_FE_MAC1r_SRSTf_GET
#define FE_MAC1r_SRSTf_SET BCM56800_A0_FE_MAC1r_SRSTf_SET
#define READ_FE_MAC1r BCM56800_A0_READ_FE_MAC1r
#define WRITE_FE_MAC1r BCM56800_A0_WRITE_FE_MAC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_MAC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_MAC2
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet MAC Configuration 2 Register.
 * SIZE:     32
 * FIELDS:
 *     FULL_DUP         Full Duplex Operation 0 = Enable Half Duplex 1 = Enable Full Duplex operation
 *     LG_CHK           Frame Length Checking 0 = Do not perform Frame Length checking 1 = Perform Frame Length checking if length/type field indicates one and report mismatches on xmit/recv statistics vector 
 *     HUGE_FR          Huge Frame Enable 0 = Huge frames are neither transmitted nor received 1 = Huge frames of any length are both transmitted and received
 *     DEL_CRC          Delayed CRC - determines the number of bytes of proprietary header information on the front of IEEE802.3 frames 0 = No proprietary header 1 = 4 bytes of proprietary header (ignored by CRC function)
 *     CRC_EN           Append CRC to frames 0 = Do not append CRC. Frame presented to MAC contains a CRC 1 = Append CRC to every frame, irrespective of padding requirement
 *     PAD_EN           Pad and add CRC to all short frames using bit setting of VLAN_PAD and AUTO_PAD 
 *     VLAN_PAD         Pad all short frames to 64 bytes and append a valid CRC
 *     AUTO_PAD         Automatic Detection of tagged and un-tagged frames and padding is performed accordingly 
 *     PURE_PAD         Pure Preamble Enforcement 0 = No preamble checking is performed 1 = Verify preamble contains 0x55 and is error free. Otherwise, discard the packet 
 *     LONG_PRE         Long Preamble Enforcement 0 = Receive packets with any length preamble per standard 1 = Receive packets with preamble fields less than 12 bytes in length 
 *     NO_BOFF          Backoff after collision. 0 = Use Binary exponential backoff algorithm 1 = Retransmit immediately
 *     BP_NO_BOFF       Back Pressure Backoff after collision. 0 = Use Binary exponential backoff algorithm 1 = Retransmit immediately
 *     EXC_DEF          Deferral to carrier. 0 = Abort when excessive deferral limit is reached and provide feedback to the host system 1 = Defer to carrier indefinitely as per standard
 *
 ******************************************************************************/
#define BCM56800_A0_FE_MAC2r 0x00f00201

#define BCM56800_A0_FE_MAC2r_SIZE 4

/*
 * This structure should be used to declare and program FE_MAC2.
 *
 */
typedef union BCM56800_A0_FE_MAC2r_s {
	uint32_t v[1];
	uint32_t fe_mac2[1];
	uint32_t _fe_mac2;
} BCM56800_A0_FE_MAC2r_t;

#define BCM56800_A0_FE_MAC2r_CLR(r) (r).fe_mac2[0] = 0
#define BCM56800_A0_FE_MAC2r_SET(r,d) (r).fe_mac2[0] = d
#define BCM56800_A0_FE_MAC2r_GET(r) (r).fe_mac2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_MAC2r_FULL_DUPf_GET(r) (((r).fe_mac2[0]) & 0x1)
#define BCM56800_A0_FE_MAC2r_FULL_DUPf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FE_MAC2r_LG_CHKf_GET(r) ((((r).fe_mac2[0]) >> 1) & 0x1)
#define BCM56800_A0_FE_MAC2r_LG_CHKf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_FE_MAC2r_HUGE_FRf_GET(r) ((((r).fe_mac2[0]) >> 2) & 0x1)
#define BCM56800_A0_FE_MAC2r_HUGE_FRf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_FE_MAC2r_DEL_CRCf_GET(r) ((((r).fe_mac2[0]) >> 3) & 0x1)
#define BCM56800_A0_FE_MAC2r_DEL_CRCf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_FE_MAC2r_CRC_ENf_GET(r) ((((r).fe_mac2[0]) >> 4) & 0x1)
#define BCM56800_A0_FE_MAC2r_CRC_ENf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_FE_MAC2r_PAD_ENf_GET(r) ((((r).fe_mac2[0]) >> 5) & 0x1)
#define BCM56800_A0_FE_MAC2r_PAD_ENf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_FE_MAC2r_VLAN_PADf_GET(r) ((((r).fe_mac2[0]) >> 6) & 0x1)
#define BCM56800_A0_FE_MAC2r_VLAN_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_FE_MAC2r_AUTO_PADf_GET(r) ((((r).fe_mac2[0]) >> 7) & 0x1)
#define BCM56800_A0_FE_MAC2r_AUTO_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_FE_MAC2r_PURE_PADf_GET(r) ((((r).fe_mac2[0]) >> 8) & 0x1)
#define BCM56800_A0_FE_MAC2r_PURE_PADf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_FE_MAC2r_LONG_PREf_GET(r) ((((r).fe_mac2[0]) >> 9) & 0x1)
#define BCM56800_A0_FE_MAC2r_LONG_PREf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_FE_MAC2r_NO_BOFFf_GET(r) ((((r).fe_mac2[0]) >> 12) & 0x1)
#define BCM56800_A0_FE_MAC2r_NO_BOFFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_FE_MAC2r_BP_NO_BOFFf_GET(r) ((((r).fe_mac2[0]) >> 13) & 0x1)
#define BCM56800_A0_FE_MAC2r_BP_NO_BOFFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_FE_MAC2r_EXC_DEFf_GET(r) ((((r).fe_mac2[0]) >> 14) & 0x1)
#define BCM56800_A0_FE_MAC2r_EXC_DEFf_SET(r,f) (r).fe_mac2[0]=(((r).fe_mac2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access FE_MAC2.
 *
 */
#define BCM56800_A0_READ_FE_MAC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_MAC2r,(r._fe_mac2))
#define BCM56800_A0_WRITE_FE_MAC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_MAC2r,&(r._fe_mac2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAC2r BCM56800_A0_FE_MAC2r
#define FE_MAC2r_SIZE BCM56800_A0_FE_MAC2r_SIZE
typedef BCM56800_A0_FE_MAC2r_t FE_MAC2r_t;
#define FE_MAC2r_CLR BCM56800_A0_FE_MAC2r_CLR
#define FE_MAC2r_SET BCM56800_A0_FE_MAC2r_SET
#define FE_MAC2r_GET BCM56800_A0_FE_MAC2r_GET
#define FE_MAC2r_FULL_DUPf_GET BCM56800_A0_FE_MAC2r_FULL_DUPf_GET
#define FE_MAC2r_FULL_DUPf_SET BCM56800_A0_FE_MAC2r_FULL_DUPf_SET
#define FE_MAC2r_LG_CHKf_GET BCM56800_A0_FE_MAC2r_LG_CHKf_GET
#define FE_MAC2r_LG_CHKf_SET BCM56800_A0_FE_MAC2r_LG_CHKf_SET
#define FE_MAC2r_HUGE_FRf_GET BCM56800_A0_FE_MAC2r_HUGE_FRf_GET
#define FE_MAC2r_HUGE_FRf_SET BCM56800_A0_FE_MAC2r_HUGE_FRf_SET
#define FE_MAC2r_DEL_CRCf_GET BCM56800_A0_FE_MAC2r_DEL_CRCf_GET
#define FE_MAC2r_DEL_CRCf_SET BCM56800_A0_FE_MAC2r_DEL_CRCf_SET
#define FE_MAC2r_CRC_ENf_GET BCM56800_A0_FE_MAC2r_CRC_ENf_GET
#define FE_MAC2r_CRC_ENf_SET BCM56800_A0_FE_MAC2r_CRC_ENf_SET
#define FE_MAC2r_PAD_ENf_GET BCM56800_A0_FE_MAC2r_PAD_ENf_GET
#define FE_MAC2r_PAD_ENf_SET BCM56800_A0_FE_MAC2r_PAD_ENf_SET
#define FE_MAC2r_VLAN_PADf_GET BCM56800_A0_FE_MAC2r_VLAN_PADf_GET
#define FE_MAC2r_VLAN_PADf_SET BCM56800_A0_FE_MAC2r_VLAN_PADf_SET
#define FE_MAC2r_AUTO_PADf_GET BCM56800_A0_FE_MAC2r_AUTO_PADf_GET
#define FE_MAC2r_AUTO_PADf_SET BCM56800_A0_FE_MAC2r_AUTO_PADf_SET
#define FE_MAC2r_PURE_PADf_GET BCM56800_A0_FE_MAC2r_PURE_PADf_GET
#define FE_MAC2r_PURE_PADf_SET BCM56800_A0_FE_MAC2r_PURE_PADf_SET
#define FE_MAC2r_LONG_PREf_GET BCM56800_A0_FE_MAC2r_LONG_PREf_GET
#define FE_MAC2r_LONG_PREf_SET BCM56800_A0_FE_MAC2r_LONG_PREf_SET
#define FE_MAC2r_NO_BOFFf_GET BCM56800_A0_FE_MAC2r_NO_BOFFf_GET
#define FE_MAC2r_NO_BOFFf_SET BCM56800_A0_FE_MAC2r_NO_BOFFf_SET
#define FE_MAC2r_BP_NO_BOFFf_GET BCM56800_A0_FE_MAC2r_BP_NO_BOFFf_GET
#define FE_MAC2r_BP_NO_BOFFf_SET BCM56800_A0_FE_MAC2r_BP_NO_BOFFf_SET
#define FE_MAC2r_EXC_DEFf_GET BCM56800_A0_FE_MAC2r_EXC_DEFf_GET
#define FE_MAC2r_EXC_DEFf_SET BCM56800_A0_FE_MAC2r_EXC_DEFf_SET
#define READ_FE_MAC2r BCM56800_A0_READ_FE_MAC2r
#define WRITE_FE_MAC2r BCM56800_A0_WRITE_FE_MAC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_MAC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_MAXF
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet Maximum Frame Length Register.
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Maximum frame length in bytes that will be received is now 1518 Decimal
 *
 ******************************************************************************/
#define BCM56800_A0_FE_MAXFr 0x00f00205

#define BCM56800_A0_FE_MAXFr_SIZE 4

/*
 * This structure should be used to declare and program FE_MAXF.
 *
 */
typedef union BCM56800_A0_FE_MAXFr_s {
	uint32_t v[1];
	uint32_t fe_maxf[1];
	uint32_t _fe_maxf;
} BCM56800_A0_FE_MAXFr_t;

#define BCM56800_A0_FE_MAXFr_CLR(r) (r).fe_maxf[0] = 0
#define BCM56800_A0_FE_MAXFr_SET(r,d) (r).fe_maxf[0] = d
#define BCM56800_A0_FE_MAXFr_GET(r) (r).fe_maxf[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_MAXFr_MAXFRf_GET(r) (((r).fe_maxf[0]) & 0xffff)
#define BCM56800_A0_FE_MAXFr_MAXFRf_SET(r,f) (r).fe_maxf[0]=(((r).fe_maxf[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FE_MAXF.
 *
 */
#define BCM56800_A0_READ_FE_MAXFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_MAXFr,(r._fe_maxf))
#define BCM56800_A0_WRITE_FE_MAXFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_MAXFr,&(r._fe_maxf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_MAXFr BCM56800_A0_FE_MAXFr
#define FE_MAXFr_SIZE BCM56800_A0_FE_MAXFr_SIZE
typedef BCM56800_A0_FE_MAXFr_t FE_MAXFr_t;
#define FE_MAXFr_CLR BCM56800_A0_FE_MAXFr_CLR
#define FE_MAXFr_SET BCM56800_A0_FE_MAXFr_SET
#define FE_MAXFr_GET BCM56800_A0_FE_MAXFr_GET
#define FE_MAXFr_MAXFRf_GET BCM56800_A0_FE_MAXFr_MAXFRf_GET
#define FE_MAXFr_MAXFRf_SET BCM56800_A0_FE_MAXFr_MAXFRf_SET
#define READ_FE_MAXFr BCM56800_A0_READ_FE_MAXFr
#define WRITE_FE_MAXFr BCM56800_A0_WRITE_FE_MAXFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_MAXFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_SUPP
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet Support Register.
 * SIZE:     32
 * FIELDS:
 *     BIT_MODE         ENDEC Mode where clock is the bit clock 0 = Disable ENDEC mode 1 = Enable ENDEC mode
 *     SPEED            Operating speed of the RMII 0 = 10Mb/sec mode 1 = 100Mb/sec mode
 *     PHYMOD           This bit controls whether the MAC is in MAC-to-MAC (0), or MAC-to-PHY (1) mode
 *
 ******************************************************************************/
#define BCM56800_A0_FE_SUPPr 0x00f00206

#define BCM56800_A0_FE_SUPPr_SIZE 4

/*
 * This structure should be used to declare and program FE_SUPP.
 *
 */
typedef union BCM56800_A0_FE_SUPPr_s {
	uint32_t v[1];
	uint32_t fe_supp[1];
	uint32_t _fe_supp;
} BCM56800_A0_FE_SUPPr_t;

#define BCM56800_A0_FE_SUPPr_CLR(r) (r).fe_supp[0] = 0
#define BCM56800_A0_FE_SUPPr_SET(r,d) (r).fe_supp[0] = d
#define BCM56800_A0_FE_SUPPr_GET(r) (r).fe_supp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_SUPPr_BIT_MODEf_GET(r) (((r).fe_supp[0]) & 0x1)
#define BCM56800_A0_FE_SUPPr_BIT_MODEf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FE_SUPPr_SPEEDf_GET(r) ((((r).fe_supp[0]) >> 8) & 0x1)
#define BCM56800_A0_FE_SUPPr_SPEEDf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_FE_SUPPr_PHYMODf_GET(r) ((((r).fe_supp[0]) >> 12) & 0x1)
#define BCM56800_A0_FE_SUPPr_PHYMODf_SET(r,f) (r).fe_supp[0]=(((r).fe_supp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access FE_SUPP.
 *
 */
#define BCM56800_A0_READ_FE_SUPPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_SUPPr,(r._fe_supp))
#define BCM56800_A0_WRITE_FE_SUPPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_SUPPr,&(r._fe_supp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_SUPPr BCM56800_A0_FE_SUPPr
#define FE_SUPPr_SIZE BCM56800_A0_FE_SUPPr_SIZE
typedef BCM56800_A0_FE_SUPPr_t FE_SUPPr_t;
#define FE_SUPPr_CLR BCM56800_A0_FE_SUPPr_CLR
#define FE_SUPPr_SET BCM56800_A0_FE_SUPPr_SET
#define FE_SUPPr_GET BCM56800_A0_FE_SUPPr_GET
#define FE_SUPPr_BIT_MODEf_GET BCM56800_A0_FE_SUPPr_BIT_MODEf_GET
#define FE_SUPPr_BIT_MODEf_SET BCM56800_A0_FE_SUPPr_BIT_MODEf_SET
#define FE_SUPPr_SPEEDf_GET BCM56800_A0_FE_SUPPr_SPEEDf_GET
#define FE_SUPPr_SPEEDf_SET BCM56800_A0_FE_SUPPr_SPEEDf_SET
#define FE_SUPPr_PHYMODf_GET BCM56800_A0_FE_SUPPr_PHYMODf_GET
#define FE_SUPPr_PHYMODf_SET BCM56800_A0_FE_SUPPr_PHYMODf_SET
#define READ_FE_SUPPr BCM56800_A0_READ_FE_SUPPr
#define WRITE_FE_SUPPr BCM56800_A0_WRITE_FE_SUPPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_SUPPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FE_TEST
 * BLOCKS:   GXPORT
 * DESC:     Fast Ethernet Test Register.
 * SIZE:     32
 * FIELDS:
 *     SHORT_QNTA       Shortcut Pause Quanta 0 = Do not configure ENDEC mode (clock is nibble clock) 1 = Configure ENDEC mode (clock is bit clock)
 *     TEST_PAUSE       Test Pause 0 = Do not reset RMII logic 1 = Reset RMII logic
 *     TEST_BACK        Test Back Pressure 0 = Do not assert backpressure 1 = Assert backpressure, causing preamble to be transmitted
 *
 ******************************************************************************/
#define BCM56800_A0_FE_TESTr 0x00f00207

#define BCM56800_A0_FE_TESTr_SIZE 4

/*
 * This structure should be used to declare and program FE_TEST.
 *
 */
typedef union BCM56800_A0_FE_TESTr_s {
	uint32_t v[1];
	uint32_t fe_test[1];
	uint32_t _fe_test;
} BCM56800_A0_FE_TESTr_t;

#define BCM56800_A0_FE_TESTr_CLR(r) (r).fe_test[0] = 0
#define BCM56800_A0_FE_TESTr_SET(r,d) (r).fe_test[0] = d
#define BCM56800_A0_FE_TESTr_GET(r) (r).fe_test[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FE_TESTr_SHORT_QNTAf_GET(r) (((r).fe_test[0]) & 0x1)
#define BCM56800_A0_FE_TESTr_SHORT_QNTAf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FE_TESTr_TEST_PAUSEf_GET(r) ((((r).fe_test[0]) >> 1) & 0x1)
#define BCM56800_A0_FE_TESTr_TEST_PAUSEf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_FE_TESTr_TEST_BACKf_GET(r) ((((r).fe_test[0]) >> 2) & 0x1)
#define BCM56800_A0_FE_TESTr_TEST_BACKf_SET(r,f) (r).fe_test[0]=(((r).fe_test[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access FE_TEST.
 *
 */
#define BCM56800_A0_READ_FE_TESTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_FE_TESTr,(r._fe_test))
#define BCM56800_A0_WRITE_FE_TESTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_FE_TESTr,&(r._fe_test))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FE_TESTr BCM56800_A0_FE_TESTr
#define FE_TESTr_SIZE BCM56800_A0_FE_TESTr_SIZE
typedef BCM56800_A0_FE_TESTr_t FE_TESTr_t;
#define FE_TESTr_CLR BCM56800_A0_FE_TESTr_CLR
#define FE_TESTr_SET BCM56800_A0_FE_TESTr_SET
#define FE_TESTr_GET BCM56800_A0_FE_TESTr_GET
#define FE_TESTr_SHORT_QNTAf_GET BCM56800_A0_FE_TESTr_SHORT_QNTAf_GET
#define FE_TESTr_SHORT_QNTAf_SET BCM56800_A0_FE_TESTr_SHORT_QNTAf_SET
#define FE_TESTr_TEST_PAUSEf_GET BCM56800_A0_FE_TESTr_TEST_PAUSEf_GET
#define FE_TESTr_TEST_PAUSEf_SET BCM56800_A0_FE_TESTr_TEST_PAUSEf_SET
#define FE_TESTr_TEST_BACKf_GET BCM56800_A0_FE_TESTr_TEST_BACKf_GET
#define FE_TESTr_TEST_BACKf_SET BCM56800_A0_FE_TESTr_TEST_BACKf_SET
#define READ_FE_TESTr BCM56800_A0_READ_FE_TESTr
#define WRITE_FE_TESTr BCM56800_A0_WRITE_FE_TESTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FE_TESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_ENABLE, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_BIST_ENABLE_SLICE_0 FP_CAM_BIST_ENABLE FOR FP SLICE 0
 *     FP_CAM_BIST_ENABLE_SLICE_1 FP_CAM_BIST_ENABLE FOR FP SLICE 1
 *     FP_CAM_BIST_ENABLE_SLICE_2 FP_CAM_BIST_ENABLE FOR FP SLICE 2
 *     FP_CAM_BIST_ENABLE_SLICE_3 FP_CAM_BIST_ENABLE FOR FP SLICE 3
 *     FP_CAM_BIST_ENABLE_SLICE_4 FP_CAM_BIST_ENABLE FOR FP SLICE 4
 *     FP_CAM_BIST_ENABLE_SLICE_5 FP_CAM_BIST_ENABLE FOR FP SLICE 5
 *     FP_CAM_BIST_ENABLE_SLICE_6 FP_CAM_BIST_ENABLE FOR FP SLICE 6
 *     FP_CAM_BIST_ENABLE_SLICE_7 FP_CAM_BIST_ENABLE FOR FP SLICE 7
 *     FP_CAM_DEBUG_ENABLE_SLICE_0 FP_CAM_DEBUG_ENABLE FOR FP SLICE 0
 *     FP_CAM_DEBUG_ENABLE_SLICE_1 FP_CAM_DEBUG_ENABLE FOR FP SLICE 1
 *     FP_CAM_DEBUG_ENABLE_SLICE_2 FP_CAM_DEBUG_ENABLE FOR FP SLICE 2
 *     FP_CAM_DEBUG_ENABLE_SLICE_3 FP_CAM_DEBUG_ENABLE FOR FP SLICE 3
 *     FP_CAM_DEBUG_ENABLE_SLICE_4 FP_CAM_DEBUG_ENABLE FOR FP SLICE 4
 *     FP_CAM_DEBUG_ENABLE_SLICE_5 FP_CAM_DEBUG_ENABLE FOR FP SLICE 5
 *     FP_CAM_DEBUG_ENABLE_SLICE_6 FP_CAM_DEBUG_ENABLE FOR FP SLICE 6
 *     FP_CAM_DEBUG_ENABLE_SLICE_7 FP_CAM_DEBUG_ENABLE FOR FP SLICE 7
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_ENABLEr 0x0c180c0a

#define BCM56800_A0_FP_CAM_BIST_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_ENABLE.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_ENABLEr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_enable[1];
	uint32_t _fp_cam_bist_enable;
} BCM56800_A0_FP_CAM_BIST_ENABLEr_t;

#define BCM56800_A0_FP_CAM_BIST_ENABLEr_CLR(r) (r).fp_cam_bist_enable[0] = 0
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_SET(r,d) (r).fp_cam_bist_enable[0] = d
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_GET(r) (r).fp_cam_bist_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET(r) (((r).fp_cam_bist_enable[0]) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 1) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 2) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 3) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 4) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 5) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 6) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 7) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 8) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 9) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 10) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 11) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 12) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 13) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 14) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_GET(r) ((((r).fp_cam_bist_enable[0]) >> 15) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_SET(r,f) (r).fp_cam_bist_enable[0]=(((r).fp_cam_bist_enable[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_CAM_BIST_ENABLE.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_ENABLEr,(r._fp_cam_bist_enable))
#define BCM56800_A0_WRITE_FP_CAM_BIST_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_ENABLEr,&(r._fp_cam_bist_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_ENABLEr BCM56800_A0_FP_CAM_BIST_ENABLEr
#define FP_CAM_BIST_ENABLEr_SIZE BCM56800_A0_FP_CAM_BIST_ENABLEr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_ENABLEr_t FP_CAM_BIST_ENABLEr_t;
#define FP_CAM_BIST_ENABLEr_CLR BCM56800_A0_FP_CAM_BIST_ENABLEr_CLR
#define FP_CAM_BIST_ENABLEr_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_SET
#define FP_CAM_BIST_ENABLEr_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_0f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_1f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_2f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_3f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_4f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_5f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_6f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_BIST_ENABLE_SLICE_7f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_0f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_1f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_2f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_3f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_4f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_5f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_6f_SET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_GET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_GET
#define FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_SET BCM56800_A0_FP_CAM_BIST_ENABLEr_FP_CAM_DEBUG_ENABLE_SLICE_7f_SET
#define READ_FP_CAM_BIST_ENABLEr BCM56800_A0_READ_FP_CAM_BIST_ENABLEr
#define WRITE_FP_CAM_BIST_ENABLEr BCM56800_A0_WRITE_FP_CAM_BIST_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S10_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S10_STATUS FP_CAM_BIST_S10_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S10_STATUSr 0x0c180c05

#define BCM56800_A0_FP_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s10_status[1];
	uint32_t _fp_cam_bist_s10_status;
} BCM56800_A0_FP_CAM_BIST_S10_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S10_STATUSr_CLR(r) (r).fp_cam_bist_s10_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S10_STATUSr_SET(r,d) (r).fp_cam_bist_s10_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S10_STATUSr_GET(r) (r).fp_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_GET(r) (((r).fp_cam_bist_s10_status[0]) & 0xff)
#define BCM56800_A0_FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_SET(r,f) (r).fp_cam_bist_s10_status[0]=(((r).fp_cam_bist_s10_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access FP_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S10_STATUSr,(r._fp_cam_bist_s10_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S10_STATUSr,&(r._fp_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S10_STATUSr BCM56800_A0_FP_CAM_BIST_S10_STATUSr
#define FP_CAM_BIST_S10_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S10_STATUSr_t FP_CAM_BIST_S10_STATUSr_t;
#define FP_CAM_BIST_S10_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S10_STATUSr_CLR
#define FP_CAM_BIST_S10_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S10_STATUSr_SET
#define FP_CAM_BIST_S10_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S10_STATUSr_GET
#define FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_GET
#define FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S10_STATUSr_FP_CAM_S10_STATUSf_SET
#define READ_FP_CAM_BIST_S10_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S10_STATUSr
#define WRITE_FP_CAM_BIST_S10_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S12_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S12_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S12_STATUS FP_CAM_BIST_S12_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S12_STATUSr 0x0c180c06

#define BCM56800_A0_FP_CAM_BIST_S12_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S12_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S12_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s12_status[1];
	uint32_t _fp_cam_bist_s12_status;
} BCM56800_A0_FP_CAM_BIST_S12_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S12_STATUSr_CLR(r) (r).fp_cam_bist_s12_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S12_STATUSr_SET(r,d) (r).fp_cam_bist_s12_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S12_STATUSr_GET(r) (r).fp_cam_bist_s12_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_GET(r) (((r).fp_cam_bist_s12_status[0]) & 0xffff)
#define BCM56800_A0_FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_SET(r,f) (r).fp_cam_bist_s12_status[0]=(((r).fp_cam_bist_s12_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S12_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S12_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S12_STATUSr,(r._fp_cam_bist_s12_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S12_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S12_STATUSr,&(r._fp_cam_bist_s12_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S12_STATUSr BCM56800_A0_FP_CAM_BIST_S12_STATUSr
#define FP_CAM_BIST_S12_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S12_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S12_STATUSr_t FP_CAM_BIST_S12_STATUSr_t;
#define FP_CAM_BIST_S12_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S12_STATUSr_CLR
#define FP_CAM_BIST_S12_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S12_STATUSr_SET
#define FP_CAM_BIST_S12_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S12_STATUSr_GET
#define FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_GET
#define FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S12_STATUSr_FP_CAM_S12_STATUSf_SET
#define READ_FP_CAM_BIST_S12_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S12_STATUSr
#define WRITE_FP_CAM_BIST_S12_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S12_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S12_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S14_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S14_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S14_STATUS FP_CAM_BIST_S14_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S14_STATUSr 0x0c180c07

#define BCM56800_A0_FP_CAM_BIST_S14_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S14_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S14_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s14_status[1];
	uint32_t _fp_cam_bist_s14_status;
} BCM56800_A0_FP_CAM_BIST_S14_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S14_STATUSr_CLR(r) (r).fp_cam_bist_s14_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S14_STATUSr_SET(r,d) (r).fp_cam_bist_s14_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S14_STATUSr_GET(r) (r).fp_cam_bist_s14_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_GET(r) (((r).fp_cam_bist_s14_status[0]) & 0xffff)
#define BCM56800_A0_FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_SET(r,f) (r).fp_cam_bist_s14_status[0]=(((r).fp_cam_bist_s14_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S14_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S14_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S14_STATUSr,(r._fp_cam_bist_s14_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S14_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S14_STATUSr,&(r._fp_cam_bist_s14_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S14_STATUSr BCM56800_A0_FP_CAM_BIST_S14_STATUSr
#define FP_CAM_BIST_S14_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S14_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S14_STATUSr_t FP_CAM_BIST_S14_STATUSr_t;
#define FP_CAM_BIST_S14_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S14_STATUSr_CLR
#define FP_CAM_BIST_S14_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S14_STATUSr_SET
#define FP_CAM_BIST_S14_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S14_STATUSr_GET
#define FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_GET
#define FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S14_STATUSr_FP_CAM_S14_STATUSf_SET
#define READ_FP_CAM_BIST_S14_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S14_STATUSr
#define WRITE_FP_CAM_BIST_S14_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S14_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S14_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S15_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S15_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S15_STATUS FP_CAM_BIST_S15_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S15_STATUSr 0x0c180c08

#define BCM56800_A0_FP_CAM_BIST_S15_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S15_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S15_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s15_status[1];
	uint32_t _fp_cam_bist_s15_status;
} BCM56800_A0_FP_CAM_BIST_S15_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S15_STATUSr_CLR(r) (r).fp_cam_bist_s15_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S15_STATUSr_SET(r,d) (r).fp_cam_bist_s15_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S15_STATUSr_GET(r) (r).fp_cam_bist_s15_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_GET(r) (((r).fp_cam_bist_s15_status[0]) & 0xff)
#define BCM56800_A0_FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_SET(r,f) (r).fp_cam_bist_s15_status[0]=(((r).fp_cam_bist_s15_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access FP_CAM_BIST_S15_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S15_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S15_STATUSr,(r._fp_cam_bist_s15_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S15_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S15_STATUSr,&(r._fp_cam_bist_s15_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S15_STATUSr BCM56800_A0_FP_CAM_BIST_S15_STATUSr
#define FP_CAM_BIST_S15_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S15_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S15_STATUSr_t FP_CAM_BIST_S15_STATUSr_t;
#define FP_CAM_BIST_S15_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S15_STATUSr_CLR
#define FP_CAM_BIST_S15_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S15_STATUSr_SET
#define FP_CAM_BIST_S15_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S15_STATUSr_GET
#define FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_GET
#define FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S15_STATUSr_FP_CAM_S15_STATUSf_SET
#define READ_FP_CAM_BIST_S15_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S15_STATUSr
#define WRITE_FP_CAM_BIST_S15_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S15_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S15_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S2_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S2_STATUS FP_CAM_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S2_STATUSr 0x0c180c00

#define BCM56800_A0_FP_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s2_status[1];
	uint32_t _fp_cam_bist_s2_status;
} BCM56800_A0_FP_CAM_BIST_S2_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S2_STATUSr_CLR(r) (r).fp_cam_bist_s2_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S2_STATUSr_SET(r,d) (r).fp_cam_bist_s2_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S2_STATUSr_GET(r) (r).fp_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_GET(r) (((r).fp_cam_bist_s2_status[0]) & 0x3ffff)
#define BCM56800_A0_FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_SET(r,f) (r).fp_cam_bist_s2_status[0]=(((r).fp_cam_bist_s2_status[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access FP_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S2_STATUSr,(r._fp_cam_bist_s2_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S2_STATUSr,&(r._fp_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S2_STATUSr BCM56800_A0_FP_CAM_BIST_S2_STATUSr
#define FP_CAM_BIST_S2_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S2_STATUSr_t FP_CAM_BIST_S2_STATUSr_t;
#define FP_CAM_BIST_S2_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S2_STATUSr_CLR
#define FP_CAM_BIST_S2_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S2_STATUSr_SET
#define FP_CAM_BIST_S2_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S2_STATUSr_GET
#define FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_GET
#define FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S2_STATUSr_FP_CAM_S2_STATUSf_SET
#define READ_FP_CAM_BIST_S2_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S2_STATUSr
#define WRITE_FP_CAM_BIST_S2_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S3_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S3_STATUS FP_CAM_BIST_S3_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S3_STATUSr 0x0c180c01

#define BCM56800_A0_FP_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s3_status[1];
	uint32_t _fp_cam_bist_s3_status;
} BCM56800_A0_FP_CAM_BIST_S3_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S3_STATUSr_CLR(r) (r).fp_cam_bist_s3_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S3_STATUSr_SET(r,d) (r).fp_cam_bist_s3_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S3_STATUSr_GET(r) (r).fp_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_GET(r) (((r).fp_cam_bist_s3_status[0]) & 0xffff)
#define BCM56800_A0_FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_SET(r,f) (r).fp_cam_bist_s3_status[0]=(((r).fp_cam_bist_s3_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S3_STATUSr,(r._fp_cam_bist_s3_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S3_STATUSr,&(r._fp_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S3_STATUSr BCM56800_A0_FP_CAM_BIST_S3_STATUSr
#define FP_CAM_BIST_S3_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S3_STATUSr_t FP_CAM_BIST_S3_STATUSr_t;
#define FP_CAM_BIST_S3_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S3_STATUSr_CLR
#define FP_CAM_BIST_S3_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S3_STATUSr_SET
#define FP_CAM_BIST_S3_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S3_STATUSr_GET
#define FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_GET
#define FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S3_STATUSr_FP_CAM_S3_STATUSf_SET
#define READ_FP_CAM_BIST_S3_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S3_STATUSr
#define WRITE_FP_CAM_BIST_S3_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S5_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S5_STATUS FP_CAM_BIST_S5_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S5_STATUSr 0x0c180c02

#define BCM56800_A0_FP_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s5_status[1];
	uint32_t _fp_cam_bist_s5_status;
} BCM56800_A0_FP_CAM_BIST_S5_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S5_STATUSr_CLR(r) (r).fp_cam_bist_s5_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S5_STATUSr_SET(r,d) (r).fp_cam_bist_s5_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S5_STATUSr_GET(r) (r).fp_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_GET(r) (((r).fp_cam_bist_s5_status[0]) & 0x3ffff)
#define BCM56800_A0_FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_SET(r,f) (r).fp_cam_bist_s5_status[0]=(((r).fp_cam_bist_s5_status[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access FP_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S5_STATUSr,(r._fp_cam_bist_s5_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S5_STATUSr,&(r._fp_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S5_STATUSr BCM56800_A0_FP_CAM_BIST_S5_STATUSr
#define FP_CAM_BIST_S5_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S5_STATUSr_t FP_CAM_BIST_S5_STATUSr_t;
#define FP_CAM_BIST_S5_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S5_STATUSr_CLR
#define FP_CAM_BIST_S5_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S5_STATUSr_SET
#define FP_CAM_BIST_S5_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S5_STATUSr_GET
#define FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_GET
#define FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S5_STATUSr_FP_CAM_S5_STATUSf_SET
#define READ_FP_CAM_BIST_S5_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S5_STATUSr
#define WRITE_FP_CAM_BIST_S5_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S6_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S6_STATUS FP_CAM_BIST_S6_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S6_STATUSr 0x0c180c03

#define BCM56800_A0_FP_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s6_status[1];
	uint32_t _fp_cam_bist_s6_status;
} BCM56800_A0_FP_CAM_BIST_S6_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S6_STATUSr_CLR(r) (r).fp_cam_bist_s6_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S6_STATUSr_SET(r,d) (r).fp_cam_bist_s6_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S6_STATUSr_GET(r) (r).fp_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_GET(r) (((r).fp_cam_bist_s6_status[0]) & 0xffff)
#define BCM56800_A0_FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_SET(r,f) (r).fp_cam_bist_s6_status[0]=(((r).fp_cam_bist_s6_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S6_STATUSr,(r._fp_cam_bist_s6_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S6_STATUSr,&(r._fp_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S6_STATUSr BCM56800_A0_FP_CAM_BIST_S6_STATUSr
#define FP_CAM_BIST_S6_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S6_STATUSr_t FP_CAM_BIST_S6_STATUSr_t;
#define FP_CAM_BIST_S6_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S6_STATUSr_CLR
#define FP_CAM_BIST_S6_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S6_STATUSr_SET
#define FP_CAM_BIST_S6_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S6_STATUSr_GET
#define FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_GET
#define FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S6_STATUSr_FP_CAM_S6_STATUSf_SET
#define READ_FP_CAM_BIST_S6_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S6_STATUSr
#define WRITE_FP_CAM_BIST_S6_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_S8_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_S8_STATUS FP_CAM_BIST_S8_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_S8_STATUSr 0x0c180c04

#define BCM56800_A0_FP_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_s8_status[1];
	uint32_t _fp_cam_bist_s8_status;
} BCM56800_A0_FP_CAM_BIST_S8_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_S8_STATUSr_CLR(r) (r).fp_cam_bist_s8_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_S8_STATUSr_SET(r,d) (r).fp_cam_bist_s8_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_S8_STATUSr_GET(r) (r).fp_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_GET(r) (((r).fp_cam_bist_s8_status[0]) & 0xffff)
#define BCM56800_A0_FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_SET(r,f) (r).fp_cam_bist_s8_status[0]=(((r).fp_cam_bist_s8_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FP_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_S8_STATUSr,(r._fp_cam_bist_s8_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_S8_STATUSr,&(r._fp_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_S8_STATUSr BCM56800_A0_FP_CAM_BIST_S8_STATUSr
#define FP_CAM_BIST_S8_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_S8_STATUSr_t FP_CAM_BIST_S8_STATUSr_t;
#define FP_CAM_BIST_S8_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_S8_STATUSr_CLR
#define FP_CAM_BIST_S8_STATUSr_SET BCM56800_A0_FP_CAM_BIST_S8_STATUSr_SET
#define FP_CAM_BIST_S8_STATUSr_GET BCM56800_A0_FP_CAM_BIST_S8_STATUSr_GET
#define FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_GET BCM56800_A0_FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_GET
#define FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_SET BCM56800_A0_FP_CAM_BIST_S8_STATUSr_FP_CAM_S8_STATUSf_SET
#define READ_FP_CAM_BIST_S8_STATUSr BCM56800_A0_READ_FP_CAM_BIST_S8_STATUSr
#define WRITE_FP_CAM_BIST_S8_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_BIST_STATUS, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_CAM_BIST_GO   CAM_BIST_GO_STATUS
 *     FP_CAM_BIST_DONE CAM_BIST_DONE_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_BIST_STATUSr 0x0c180c09

#define BCM56800_A0_FP_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_BIST_STATUS.
 *
 */
typedef union BCM56800_A0_FP_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t fp_cam_bist_status[1];
	uint32_t _fp_cam_bist_status;
} BCM56800_A0_FP_CAM_BIST_STATUSr_t;

#define BCM56800_A0_FP_CAM_BIST_STATUSr_CLR(r) (r).fp_cam_bist_status[0] = 0
#define BCM56800_A0_FP_CAM_BIST_STATUSr_SET(r,d) (r).fp_cam_bist_status[0] = d
#define BCM56800_A0_FP_CAM_BIST_STATUSr_GET(r) (r).fp_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET(r) (((r).fp_cam_bist_status[0]) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET(r,f) (r).fp_cam_bist_status[0]=(((r).fp_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET(r) ((((r).fp_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56800_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET(r,f) (r).fp_cam_bist_status[0]=(((r).fp_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_CAM_BIST_STATUS.
 *
 */
#define BCM56800_A0_READ_FP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_BIST_STATUSr,(r._fp_cam_bist_status))
#define BCM56800_A0_WRITE_FP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_BIST_STATUSr,&(r._fp_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_BIST_STATUSr BCM56800_A0_FP_CAM_BIST_STATUSr
#define FP_CAM_BIST_STATUSr_SIZE BCM56800_A0_FP_CAM_BIST_STATUSr_SIZE
typedef BCM56800_A0_FP_CAM_BIST_STATUSr_t FP_CAM_BIST_STATUSr_t;
#define FP_CAM_BIST_STATUSr_CLR BCM56800_A0_FP_CAM_BIST_STATUSr_CLR
#define FP_CAM_BIST_STATUSr_SET BCM56800_A0_FP_CAM_BIST_STATUSr_SET
#define FP_CAM_BIST_STATUSr_GET BCM56800_A0_FP_CAM_BIST_STATUSr_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET BCM56800_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET BCM56800_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_GOf_SET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET BCM56800_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_GET
#define FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET BCM56800_A0_FP_CAM_BIST_STATUSr_FP_CAM_BIST_DONEf_SET
#define READ_FP_CAM_BIST_STATUSr BCM56800_A0_READ_FP_CAM_BIST_STATUSr
#define WRITE_FP_CAM_BIST_STATUSr BCM56800_A0_WRITE_FP_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_CONTROL, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     TM               FP_CAM_CONTROL FOR CAM TEST MODE
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_CONTROLr 0x0c180c0d

#define BCM56800_A0_FP_CAM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_CONTROL.
 *
 */
typedef union BCM56800_A0_FP_CAM_CONTROLr_s {
	uint32_t v[1];
	uint32_t fp_cam_control[1];
	uint32_t _fp_cam_control;
} BCM56800_A0_FP_CAM_CONTROLr_t;

#define BCM56800_A0_FP_CAM_CONTROLr_CLR(r) (r).fp_cam_control[0] = 0
#define BCM56800_A0_FP_CAM_CONTROLr_SET(r,d) (r).fp_cam_control[0] = d
#define BCM56800_A0_FP_CAM_CONTROLr_GET(r) (r).fp_cam_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_CONTROLr_TMf_GET(r) (((r).fp_cam_control[0]) & 0x7ff)
#define BCM56800_A0_FP_CAM_CONTROLr_TMf_SET(r,f) (r).fp_cam_control[0]=(((r).fp_cam_control[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access FP_CAM_CONTROL.
 *
 */
#define BCM56800_A0_READ_FP_CAM_CONTROLr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_CONTROLr+(i),(r._fp_cam_control))
#define BCM56800_A0_WRITE_FP_CAM_CONTROLr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_CONTROLr+(i),&(r._fp_cam_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_CONTROLr BCM56800_A0_FP_CAM_CONTROLr
#define FP_CAM_CONTROLr_SIZE BCM56800_A0_FP_CAM_CONTROLr_SIZE
typedef BCM56800_A0_FP_CAM_CONTROLr_t FP_CAM_CONTROLr_t;
#define FP_CAM_CONTROLr_CLR BCM56800_A0_FP_CAM_CONTROLr_CLR
#define FP_CAM_CONTROLr_SET BCM56800_A0_FP_CAM_CONTROLr_SET
#define FP_CAM_CONTROLr_GET BCM56800_A0_FP_CAM_CONTROLr_GET
#define FP_CAM_CONTROLr_TMf_GET BCM56800_A0_FP_CAM_CONTROLr_TMf_GET
#define FP_CAM_CONTROLr_TMf_SET BCM56800_A0_FP_CAM_CONTROLr_TMf_SET
#define READ_FP_CAM_CONTROLr BCM56800_A0_READ_FP_CAM_CONTROLr
#define WRITE_FP_CAM_CONTROLr BCM56800_A0_WRITE_FP_CAM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_0
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_0, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[29:0] AND THE TWO VALID BITS
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_DEBUG_DATA_0r 0x0c180c15

#define BCM56800_A0_FP_CAM_DEBUG_DATA_0r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_0.
 *
 */
typedef union BCM56800_A0_FP_CAM_DEBUG_DATA_0r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_0[1];
	uint32_t _fp_cam_debug_data_0;
} BCM56800_A0_FP_CAM_DEBUG_DATA_0r_t;

#define BCM56800_A0_FP_CAM_DEBUG_DATA_0r_CLR(r) (r).fp_cam_debug_data_0[0] = 0
#define BCM56800_A0_FP_CAM_DEBUG_DATA_0r_SET(r,d) (r).fp_cam_debug_data_0[0] = d
#define BCM56800_A0_FP_CAM_DEBUG_DATA_0r_GET(r) (r).fp_cam_debug_data_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_0[0])
#define BCM56800_A0_FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_0[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_0.
 *
 */
#define BCM56800_A0_READ_FP_CAM_DEBUG_DATA_0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_DEBUG_DATA_0r,(r._fp_cam_debug_data_0))
#define BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_DEBUG_DATA_0r,&(r._fp_cam_debug_data_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_0r BCM56800_A0_FP_CAM_DEBUG_DATA_0r
#define FP_CAM_DEBUG_DATA_0r_SIZE BCM56800_A0_FP_CAM_DEBUG_DATA_0r_SIZE
typedef BCM56800_A0_FP_CAM_DEBUG_DATA_0r_t FP_CAM_DEBUG_DATA_0r_t;
#define FP_CAM_DEBUG_DATA_0r_CLR BCM56800_A0_FP_CAM_DEBUG_DATA_0r_CLR
#define FP_CAM_DEBUG_DATA_0r_SET BCM56800_A0_FP_CAM_DEBUG_DATA_0r_SET
#define FP_CAM_DEBUG_DATA_0r_GET BCM56800_A0_FP_CAM_DEBUG_DATA_0r_GET
#define FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_GET BCM56800_A0_FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_SET BCM56800_A0_FP_CAM_DEBUG_DATA_0r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_0r BCM56800_A0_READ_FP_CAM_DEBUG_DATA_0r
#define WRITE_FP_CAM_DEBUG_DATA_0r BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_DEBUG_DATA_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_1
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_1, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[61:30] 
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_DEBUG_DATA_1r 0x0c180c16

#define BCM56800_A0_FP_CAM_DEBUG_DATA_1r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_1.
 *
 */
typedef union BCM56800_A0_FP_CAM_DEBUG_DATA_1r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_1[1];
	uint32_t _fp_cam_debug_data_1;
} BCM56800_A0_FP_CAM_DEBUG_DATA_1r_t;

#define BCM56800_A0_FP_CAM_DEBUG_DATA_1r_CLR(r) (r).fp_cam_debug_data_1[0] = 0
#define BCM56800_A0_FP_CAM_DEBUG_DATA_1r_SET(r,d) (r).fp_cam_debug_data_1[0] = d
#define BCM56800_A0_FP_CAM_DEBUG_DATA_1r_GET(r) (r).fp_cam_debug_data_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_1[0])
#define BCM56800_A0_FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_1[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_1.
 *
 */
#define BCM56800_A0_READ_FP_CAM_DEBUG_DATA_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_DEBUG_DATA_1r,(r._fp_cam_debug_data_1))
#define BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_DEBUG_DATA_1r,&(r._fp_cam_debug_data_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_1r BCM56800_A0_FP_CAM_DEBUG_DATA_1r
#define FP_CAM_DEBUG_DATA_1r_SIZE BCM56800_A0_FP_CAM_DEBUG_DATA_1r_SIZE
typedef BCM56800_A0_FP_CAM_DEBUG_DATA_1r_t FP_CAM_DEBUG_DATA_1r_t;
#define FP_CAM_DEBUG_DATA_1r_CLR BCM56800_A0_FP_CAM_DEBUG_DATA_1r_CLR
#define FP_CAM_DEBUG_DATA_1r_SET BCM56800_A0_FP_CAM_DEBUG_DATA_1r_SET
#define FP_CAM_DEBUG_DATA_1r_GET BCM56800_A0_FP_CAM_DEBUG_DATA_1r_GET
#define FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_GET BCM56800_A0_FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_SET BCM56800_A0_FP_CAM_DEBUG_DATA_1r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_1r BCM56800_A0_READ_FP_CAM_DEBUG_DATA_1r
#define WRITE_FP_CAM_DEBUG_DATA_1r BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_DEBUG_DATA_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_2
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_2, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[93:62] 
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_DEBUG_DATA_2r 0x0c180c17

#define BCM56800_A0_FP_CAM_DEBUG_DATA_2r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_2.
 *
 */
typedef union BCM56800_A0_FP_CAM_DEBUG_DATA_2r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_2[1];
	uint32_t _fp_cam_debug_data_2;
} BCM56800_A0_FP_CAM_DEBUG_DATA_2r_t;

#define BCM56800_A0_FP_CAM_DEBUG_DATA_2r_CLR(r) (r).fp_cam_debug_data_2[0] = 0
#define BCM56800_A0_FP_CAM_DEBUG_DATA_2r_SET(r,d) (r).fp_cam_debug_data_2[0] = d
#define BCM56800_A0_FP_CAM_DEBUG_DATA_2r_GET(r) (r).fp_cam_debug_data_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_2[0])
#define BCM56800_A0_FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_2[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_2.
 *
 */
#define BCM56800_A0_READ_FP_CAM_DEBUG_DATA_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_DEBUG_DATA_2r,(r._fp_cam_debug_data_2))
#define BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_DEBUG_DATA_2r,&(r._fp_cam_debug_data_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_2r BCM56800_A0_FP_CAM_DEBUG_DATA_2r
#define FP_CAM_DEBUG_DATA_2r_SIZE BCM56800_A0_FP_CAM_DEBUG_DATA_2r_SIZE
typedef BCM56800_A0_FP_CAM_DEBUG_DATA_2r_t FP_CAM_DEBUG_DATA_2r_t;
#define FP_CAM_DEBUG_DATA_2r_CLR BCM56800_A0_FP_CAM_DEBUG_DATA_2r_CLR
#define FP_CAM_DEBUG_DATA_2r_SET BCM56800_A0_FP_CAM_DEBUG_DATA_2r_SET
#define FP_CAM_DEBUG_DATA_2r_GET BCM56800_A0_FP_CAM_DEBUG_DATA_2r_GET
#define FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_GET BCM56800_A0_FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_SET BCM56800_A0_FP_CAM_DEBUG_DATA_2r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_2r BCM56800_A0_READ_FP_CAM_DEBUG_DATA_2r
#define WRITE_FP_CAM_DEBUG_DATA_2r BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_DEBUG_DATA_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_3
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_3, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[125:94] 
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_DEBUG_DATA_3r 0x0c180c18

#define BCM56800_A0_FP_CAM_DEBUG_DATA_3r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_3.
 *
 */
typedef union BCM56800_A0_FP_CAM_DEBUG_DATA_3r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_3[1];
	uint32_t _fp_cam_debug_data_3;
} BCM56800_A0_FP_CAM_DEBUG_DATA_3r_t;

#define BCM56800_A0_FP_CAM_DEBUG_DATA_3r_CLR(r) (r).fp_cam_debug_data_3[0] = 0
#define BCM56800_A0_FP_CAM_DEBUG_DATA_3r_SET(r,d) (r).fp_cam_debug_data_3[0] = d
#define BCM56800_A0_FP_CAM_DEBUG_DATA_3r_GET(r) (r).fp_cam_debug_data_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_3[0])
#define BCM56800_A0_FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_3[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_3.
 *
 */
#define BCM56800_A0_READ_FP_CAM_DEBUG_DATA_3r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_DEBUG_DATA_3r,(r._fp_cam_debug_data_3))
#define BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_3r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_DEBUG_DATA_3r,&(r._fp_cam_debug_data_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_3r BCM56800_A0_FP_CAM_DEBUG_DATA_3r
#define FP_CAM_DEBUG_DATA_3r_SIZE BCM56800_A0_FP_CAM_DEBUG_DATA_3r_SIZE
typedef BCM56800_A0_FP_CAM_DEBUG_DATA_3r_t FP_CAM_DEBUG_DATA_3r_t;
#define FP_CAM_DEBUG_DATA_3r_CLR BCM56800_A0_FP_CAM_DEBUG_DATA_3r_CLR
#define FP_CAM_DEBUG_DATA_3r_SET BCM56800_A0_FP_CAM_DEBUG_DATA_3r_SET
#define FP_CAM_DEBUG_DATA_3r_GET BCM56800_A0_FP_CAM_DEBUG_DATA_3r_GET
#define FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_GET BCM56800_A0_FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_SET BCM56800_A0_FP_CAM_DEBUG_DATA_3r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_3r BCM56800_A0_READ_FP_CAM_DEBUG_DATA_3r
#define WRITE_FP_CAM_DEBUG_DATA_3r BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_DEBUG_DATA_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_4
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_4, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[157:126] 
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_DEBUG_DATA_4r 0x0c180c19

#define BCM56800_A0_FP_CAM_DEBUG_DATA_4r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_4.
 *
 */
typedef union BCM56800_A0_FP_CAM_DEBUG_DATA_4r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_4[1];
	uint32_t _fp_cam_debug_data_4;
} BCM56800_A0_FP_CAM_DEBUG_DATA_4r_t;

#define BCM56800_A0_FP_CAM_DEBUG_DATA_4r_CLR(r) (r).fp_cam_debug_data_4[0] = 0
#define BCM56800_A0_FP_CAM_DEBUG_DATA_4r_SET(r,d) (r).fp_cam_debug_data_4[0] = d
#define BCM56800_A0_FP_CAM_DEBUG_DATA_4r_GET(r) (r).fp_cam_debug_data_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_GET(r) ((r).fp_cam_debug_data_4[0])
#define BCM56800_A0_FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_4[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_4.
 *
 */
#define BCM56800_A0_READ_FP_CAM_DEBUG_DATA_4r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_DEBUG_DATA_4r,(r._fp_cam_debug_data_4))
#define BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_4r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_DEBUG_DATA_4r,&(r._fp_cam_debug_data_4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_4r BCM56800_A0_FP_CAM_DEBUG_DATA_4r
#define FP_CAM_DEBUG_DATA_4r_SIZE BCM56800_A0_FP_CAM_DEBUG_DATA_4r_SIZE
typedef BCM56800_A0_FP_CAM_DEBUG_DATA_4r_t FP_CAM_DEBUG_DATA_4r_t;
#define FP_CAM_DEBUG_DATA_4r_CLR BCM56800_A0_FP_CAM_DEBUG_DATA_4r_CLR
#define FP_CAM_DEBUG_DATA_4r_SET BCM56800_A0_FP_CAM_DEBUG_DATA_4r_SET
#define FP_CAM_DEBUG_DATA_4r_GET BCM56800_A0_FP_CAM_DEBUG_DATA_4r_GET
#define FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_GET BCM56800_A0_FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_SET BCM56800_A0_FP_CAM_DEBUG_DATA_4r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_4r BCM56800_A0_READ_FP_CAM_DEBUG_DATA_4r
#define WRITE_FP_CAM_DEBUG_DATA_4r BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_DEBUG_DATA_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_DEBUG_DATA_5
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_DATA_5, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING INPUT DATA[183:158] 
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_DEBUG_DATA_5r 0x0c180c1a

#define BCM56800_A0_FP_CAM_DEBUG_DATA_5r_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_DATA_5.
 *
 */
typedef union BCM56800_A0_FP_CAM_DEBUG_DATA_5r_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_data_5[1];
	uint32_t _fp_cam_debug_data_5;
} BCM56800_A0_FP_CAM_DEBUG_DATA_5r_t;

#define BCM56800_A0_FP_CAM_DEBUG_DATA_5r_CLR(r) (r).fp_cam_debug_data_5[0] = 0
#define BCM56800_A0_FP_CAM_DEBUG_DATA_5r_SET(r,d) (r).fp_cam_debug_data_5[0] = d
#define BCM56800_A0_FP_CAM_DEBUG_DATA_5r_GET(r) (r).fp_cam_debug_data_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_GET(r) (((r).fp_cam_debug_data_5[0]) & 0x3ffffff)
#define BCM56800_A0_FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_data_5[0]=(((r).fp_cam_debug_data_5[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access FP_CAM_DEBUG_DATA_5.
 *
 */
#define BCM56800_A0_READ_FP_CAM_DEBUG_DATA_5r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_DEBUG_DATA_5r,(r._fp_cam_debug_data_5))
#define BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_5r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_DEBUG_DATA_5r,&(r._fp_cam_debug_data_5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_DATA_5r BCM56800_A0_FP_CAM_DEBUG_DATA_5r
#define FP_CAM_DEBUG_DATA_5r_SIZE BCM56800_A0_FP_CAM_DEBUG_DATA_5r_SIZE
typedef BCM56800_A0_FP_CAM_DEBUG_DATA_5r_t FP_CAM_DEBUG_DATA_5r_t;
#define FP_CAM_DEBUG_DATA_5r_CLR BCM56800_A0_FP_CAM_DEBUG_DATA_5r_CLR
#define FP_CAM_DEBUG_DATA_5r_SET BCM56800_A0_FP_CAM_DEBUG_DATA_5r_SET
#define FP_CAM_DEBUG_DATA_5r_GET BCM56800_A0_FP_CAM_DEBUG_DATA_5r_GET
#define FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_GET BCM56800_A0_FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_GET
#define FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_SET BCM56800_A0_FP_CAM_DEBUG_DATA_5r_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_DATA_5r BCM56800_A0_READ_FP_CAM_DEBUG_DATA_5r
#define WRITE_FP_CAM_DEBUG_DATA_5r BCM56800_A0_WRITE_FP_CAM_DEBUG_DATA_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_DEBUG_DATA_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_DEBUG_GLOBAL_MASK
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_GLOBAL_MASK, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN LOADING GLOBAL MASK DATA[31:0] 
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr 0x0c180c1b

#define BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_GLOBAL_MASK.
 *
 */
typedef union BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_global_mask[1];
	uint32_t _fp_cam_debug_global_mask;
} BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_t;

#define BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_CLR(r) (r).fp_cam_debug_global_mask[0] = 0
#define BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_SET(r,d) (r).fp_cam_debug_global_mask[0] = d
#define BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_GET(r) (r).fp_cam_debug_global_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_LOAD_DATAf_GET(r) ((r).fp_cam_debug_global_mask[0])
#define BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_global_mask[0]=((uint32_t)f)

/*
 * These macros can be used to access FP_CAM_DEBUG_GLOBAL_MASK.
 *
 */
#define BCM56800_A0_READ_FP_CAM_DEBUG_GLOBAL_MASKr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr,(r._fp_cam_debug_global_mask))
#define BCM56800_A0_WRITE_FP_CAM_DEBUG_GLOBAL_MASKr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr,&(r._fp_cam_debug_global_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_GLOBAL_MASKr BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr
#define FP_CAM_DEBUG_GLOBAL_MASKr_SIZE BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_SIZE
typedef BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_t FP_CAM_DEBUG_GLOBAL_MASKr_t;
#define FP_CAM_DEBUG_GLOBAL_MASKr_CLR BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_CLR
#define FP_CAM_DEBUG_GLOBAL_MASKr_SET BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_SET
#define FP_CAM_DEBUG_GLOBAL_MASKr_GET BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_GET
#define FP_CAM_DEBUG_GLOBAL_MASKr_LOAD_DATAf_GET BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_LOAD_DATAf_GET
#define FP_CAM_DEBUG_GLOBAL_MASKr_LOAD_DATAf_SET BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_GLOBAL_MASKr BCM56800_A0_READ_FP_CAM_DEBUG_GLOBAL_MASKr
#define WRITE_FP_CAM_DEBUG_GLOBAL_MASKr BCM56800_A0_WRITE_FP_CAM_DEBUG_GLOBAL_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_DEBUG_GLOBAL_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_CAM_DEBUG_SEND
 * BLOCKS:   IPIPE
 * DESC:     FP_CAM_DEBUG_SEND, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     LOAD_DATA        RESULTS IN SENDING CAM DEBUG COMPARE CYCLE
 *
 ******************************************************************************/
#define BCM56800_A0_FP_CAM_DEBUG_SENDr 0x0c180c1c

#define BCM56800_A0_FP_CAM_DEBUG_SENDr_SIZE 4

/*
 * This structure should be used to declare and program FP_CAM_DEBUG_SEND.
 *
 */
typedef union BCM56800_A0_FP_CAM_DEBUG_SENDr_s {
	uint32_t v[1];
	uint32_t fp_cam_debug_send[1];
	uint32_t _fp_cam_debug_send;
} BCM56800_A0_FP_CAM_DEBUG_SENDr_t;

#define BCM56800_A0_FP_CAM_DEBUG_SENDr_CLR(r) (r).fp_cam_debug_send[0] = 0
#define BCM56800_A0_FP_CAM_DEBUG_SENDr_SET(r,d) (r).fp_cam_debug_send[0] = d
#define BCM56800_A0_FP_CAM_DEBUG_SENDr_GET(r) (r).fp_cam_debug_send[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_CAM_DEBUG_SENDr_LOAD_DATAf_GET(r) (((r).fp_cam_debug_send[0]) & 0x1)
#define BCM56800_A0_FP_CAM_DEBUG_SENDr_LOAD_DATAf_SET(r,f) (r).fp_cam_debug_send[0]=(((r).fp_cam_debug_send[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access FP_CAM_DEBUG_SEND.
 *
 */
#define BCM56800_A0_READ_FP_CAM_DEBUG_SENDr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_CAM_DEBUG_SENDr,(r._fp_cam_debug_send))
#define BCM56800_A0_WRITE_FP_CAM_DEBUG_SENDr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_CAM_DEBUG_SENDr,&(r._fp_cam_debug_send))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_CAM_DEBUG_SENDr BCM56800_A0_FP_CAM_DEBUG_SENDr
#define FP_CAM_DEBUG_SENDr_SIZE BCM56800_A0_FP_CAM_DEBUG_SENDr_SIZE
typedef BCM56800_A0_FP_CAM_DEBUG_SENDr_t FP_CAM_DEBUG_SENDr_t;
#define FP_CAM_DEBUG_SENDr_CLR BCM56800_A0_FP_CAM_DEBUG_SENDr_CLR
#define FP_CAM_DEBUG_SENDr_SET BCM56800_A0_FP_CAM_DEBUG_SENDr_SET
#define FP_CAM_DEBUG_SENDr_GET BCM56800_A0_FP_CAM_DEBUG_SENDr_GET
#define FP_CAM_DEBUG_SENDr_LOAD_DATAf_GET BCM56800_A0_FP_CAM_DEBUG_SENDr_LOAD_DATAf_GET
#define FP_CAM_DEBUG_SENDr_LOAD_DATAf_SET BCM56800_A0_FP_CAM_DEBUG_SENDr_LOAD_DATAf_SET
#define READ_FP_CAM_DEBUG_SENDr BCM56800_A0_READ_FP_CAM_DEBUG_SENDr
#define WRITE_FP_CAM_DEBUG_SENDr BCM56800_A0_WRITE_FP_CAM_DEBUG_SENDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_CAM_DEBUG_SENDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_COUNTER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     THIS ADDRESS WILL BE REMOVED when the c-code is updated to use _TABLE_X and _TABLE_Y. FeatureSpecific-FP
 * SIZE:     36
 * FIELDS:
 *     COUNTER          COUNTER
 *
 ******************************************************************************/
#define BCM56800_A0_FP_COUNTER_TABLEm 0x0c1c7000

#define BCM56800_A0_FP_COUNTER_TABLEm_MIN 0
#define BCM56800_A0_FP_COUNTER_TABLEm_MAX 1023
#define BCM56800_A0_FP_COUNTER_TABLEm_CMAX(u) 1023
#define BCM56800_A0_FP_COUNTER_TABLEm_SIZE 5

/*
 * This structure should be used to declare and program FP_COUNTER_TABLE.
 *
 */
typedef union BCM56800_A0_FP_COUNTER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_counter_table[2];
	uint32_t _fp_counter_table;
} BCM56800_A0_FP_COUNTER_TABLEm_t;

#define BCM56800_A0_FP_COUNTER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_counter_table), 0, sizeof(BCM56800_A0_FP_COUNTER_TABLEm_t))
#define BCM56800_A0_FP_COUNTER_TABLEm_SET(r,i,d) (r).fp_counter_table[i] = d
#define BCM56800_A0_FP_COUNTER_TABLEm_GET(r,i) (r).fp_counter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_COUNTER_TABLEm_COUNTERf_GET(r,a) cdk_field_get((r).fp_counter_table,0,35,a)
#define BCM56800_A0_FP_COUNTER_TABLEm_COUNTERf_SET(r,a) cdk_field_set((r).fp_counter_table,0,35,a)

/*
 * These macros can be used to access FP_COUNTER_TABLE.
 *
 */
#define BCM56800_A0_READ_FP_COUNTER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_COUNTER_TABLEm,i,(m._fp_counter_table),2)
#define BCM56800_A0_WRITE_FP_COUNTER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_COUNTER_TABLEm,i,&(m._fp_counter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_COUNTER_TABLEm BCM56800_A0_FP_COUNTER_TABLEm
#define FP_COUNTER_TABLEm_MIN BCM56800_A0_FP_COUNTER_TABLEm_MIN
#define FP_COUNTER_TABLEm_MAX BCM56800_A0_FP_COUNTER_TABLEm_MAX
#define FP_COUNTER_TABLEm_CMAX(u) BCM56800_A0_FP_COUNTER_TABLEm_CMAX(u)
#define FP_COUNTER_TABLEm_SIZE BCM56800_A0_FP_COUNTER_TABLEm_SIZE
typedef BCM56800_A0_FP_COUNTER_TABLEm_t FP_COUNTER_TABLEm_t;
#define FP_COUNTER_TABLEm_CLR BCM56800_A0_FP_COUNTER_TABLEm_CLR
#define FP_COUNTER_TABLEm_SET BCM56800_A0_FP_COUNTER_TABLEm_SET
#define FP_COUNTER_TABLEm_GET BCM56800_A0_FP_COUNTER_TABLEm_GET
#define FP_COUNTER_TABLEm_COUNTERf_GET BCM56800_A0_FP_COUNTER_TABLEm_COUNTERf_GET
#define FP_COUNTER_TABLEm_COUNTERf_SET BCM56800_A0_FP_COUNTER_TABLEm_COUNTERf_SET
#define READ_FP_COUNTER_TABLEm BCM56800_A0_READ_FP_COUNTER_TABLEm
#define WRITE_FP_COUNTER_TABLEm BCM56800_A0_WRITE_FP_COUNTER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_COUNTER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_COUNTER_TABLE_X
 * BLOCKS:   IPIPE
 * DESC:     COUNTER TABLE FOR THE FP in IPX. FeatureSpecific-FP
 * SIZE:     36
 * FIELDS:
 *     COUNTER          COUNTER
 *
 ******************************************************************************/
#define BCM56800_A0_FP_COUNTER_TABLE_Xm 0x0c127000

#define BCM56800_A0_FP_COUNTER_TABLE_Xm_MIN 0
#define BCM56800_A0_FP_COUNTER_TABLE_Xm_MAX 1023
#define BCM56800_A0_FP_COUNTER_TABLE_Xm_CMAX(u) 1023
#define BCM56800_A0_FP_COUNTER_TABLE_Xm_SIZE 5

/*
 * This structure should be used to declare and program FP_COUNTER_TABLE_X.
 *
 */
typedef union BCM56800_A0_FP_COUNTER_TABLE_Xm_s {
	uint32_t v[2];
	uint32_t fp_counter_table_x[2];
	uint32_t _fp_counter_table_x;
} BCM56800_A0_FP_COUNTER_TABLE_Xm_t;

#define BCM56800_A0_FP_COUNTER_TABLE_Xm_CLR(r) CDK_MEMSET(&((r)._fp_counter_table_x), 0, sizeof(BCM56800_A0_FP_COUNTER_TABLE_Xm_t))
#define BCM56800_A0_FP_COUNTER_TABLE_Xm_SET(r,i,d) (r).fp_counter_table_x[i] = d
#define BCM56800_A0_FP_COUNTER_TABLE_Xm_GET(r,i) (r).fp_counter_table_x[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_COUNTER_TABLE_Xm_COUNTERf_GET(r,a) cdk_field_get((r).fp_counter_table_x,0,35,a)
#define BCM56800_A0_FP_COUNTER_TABLE_Xm_COUNTERf_SET(r,a) cdk_field_set((r).fp_counter_table_x,0,35,a)

/*
 * These macros can be used to access FP_COUNTER_TABLE_X.
 *
 */
#define BCM56800_A0_READ_FP_COUNTER_TABLE_Xm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_COUNTER_TABLE_Xm,i,(m._fp_counter_table_x),2)
#define BCM56800_A0_WRITE_FP_COUNTER_TABLE_Xm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_COUNTER_TABLE_Xm,i,&(m._fp_counter_table_x),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_COUNTER_TABLE_Xm BCM56800_A0_FP_COUNTER_TABLE_Xm
#define FP_COUNTER_TABLE_Xm_MIN BCM56800_A0_FP_COUNTER_TABLE_Xm_MIN
#define FP_COUNTER_TABLE_Xm_MAX BCM56800_A0_FP_COUNTER_TABLE_Xm_MAX
#define FP_COUNTER_TABLE_Xm_CMAX(u) BCM56800_A0_FP_COUNTER_TABLE_Xm_CMAX(u)
#define FP_COUNTER_TABLE_Xm_SIZE BCM56800_A0_FP_COUNTER_TABLE_Xm_SIZE
typedef BCM56800_A0_FP_COUNTER_TABLE_Xm_t FP_COUNTER_TABLE_Xm_t;
#define FP_COUNTER_TABLE_Xm_CLR BCM56800_A0_FP_COUNTER_TABLE_Xm_CLR
#define FP_COUNTER_TABLE_Xm_SET BCM56800_A0_FP_COUNTER_TABLE_Xm_SET
#define FP_COUNTER_TABLE_Xm_GET BCM56800_A0_FP_COUNTER_TABLE_Xm_GET
#define FP_COUNTER_TABLE_Xm_COUNTERf_GET BCM56800_A0_FP_COUNTER_TABLE_Xm_COUNTERf_GET
#define FP_COUNTER_TABLE_Xm_COUNTERf_SET BCM56800_A0_FP_COUNTER_TABLE_Xm_COUNTERf_SET
#define READ_FP_COUNTER_TABLE_Xm BCM56800_A0_READ_FP_COUNTER_TABLE_Xm
#define WRITE_FP_COUNTER_TABLE_Xm BCM56800_A0_WRITE_FP_COUNTER_TABLE_Xm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_COUNTER_TABLE_Xm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_COUNTER_TABLE_Y
 * BLOCKS:   IPIPE
 * DESC:     COUNTER TABLE FOR THE FP in IPY. FeatureSpecific-FP
 * SIZE:     36
 * FIELDS:
 *     COUNTER          COUNTER
 *
 ******************************************************************************/
#define BCM56800_A0_FP_COUNTER_TABLE_Ym 0x0c147000

#define BCM56800_A0_FP_COUNTER_TABLE_Ym_MIN 0
#define BCM56800_A0_FP_COUNTER_TABLE_Ym_MAX 1023
#define BCM56800_A0_FP_COUNTER_TABLE_Ym_CMAX(u) 1023
#define BCM56800_A0_FP_COUNTER_TABLE_Ym_SIZE 5

/*
 * This structure should be used to declare and program FP_COUNTER_TABLE_Y.
 *
 */
typedef union BCM56800_A0_FP_COUNTER_TABLE_Ym_s {
	uint32_t v[2];
	uint32_t fp_counter_table_y[2];
	uint32_t _fp_counter_table_y;
} BCM56800_A0_FP_COUNTER_TABLE_Ym_t;

#define BCM56800_A0_FP_COUNTER_TABLE_Ym_CLR(r) CDK_MEMSET(&((r)._fp_counter_table_y), 0, sizeof(BCM56800_A0_FP_COUNTER_TABLE_Ym_t))
#define BCM56800_A0_FP_COUNTER_TABLE_Ym_SET(r,i,d) (r).fp_counter_table_y[i] = d
#define BCM56800_A0_FP_COUNTER_TABLE_Ym_GET(r,i) (r).fp_counter_table_y[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_COUNTER_TABLE_Ym_COUNTERf_GET(r,a) cdk_field_get((r).fp_counter_table_y,0,35,a)
#define BCM56800_A0_FP_COUNTER_TABLE_Ym_COUNTERf_SET(r,a) cdk_field_set((r).fp_counter_table_y,0,35,a)

/*
 * These macros can be used to access FP_COUNTER_TABLE_Y.
 *
 */
#define BCM56800_A0_READ_FP_COUNTER_TABLE_Ym(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_COUNTER_TABLE_Ym,i,(m._fp_counter_table_y),2)
#define BCM56800_A0_WRITE_FP_COUNTER_TABLE_Ym(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_COUNTER_TABLE_Ym,i,&(m._fp_counter_table_y),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_COUNTER_TABLE_Ym BCM56800_A0_FP_COUNTER_TABLE_Ym
#define FP_COUNTER_TABLE_Ym_MIN BCM56800_A0_FP_COUNTER_TABLE_Ym_MIN
#define FP_COUNTER_TABLE_Ym_MAX BCM56800_A0_FP_COUNTER_TABLE_Ym_MAX
#define FP_COUNTER_TABLE_Ym_CMAX(u) BCM56800_A0_FP_COUNTER_TABLE_Ym_CMAX(u)
#define FP_COUNTER_TABLE_Ym_SIZE BCM56800_A0_FP_COUNTER_TABLE_Ym_SIZE
typedef BCM56800_A0_FP_COUNTER_TABLE_Ym_t FP_COUNTER_TABLE_Ym_t;
#define FP_COUNTER_TABLE_Ym_CLR BCM56800_A0_FP_COUNTER_TABLE_Ym_CLR
#define FP_COUNTER_TABLE_Ym_SET BCM56800_A0_FP_COUNTER_TABLE_Ym_SET
#define FP_COUNTER_TABLE_Ym_GET BCM56800_A0_FP_COUNTER_TABLE_Ym_GET
#define FP_COUNTER_TABLE_Ym_COUNTERf_GET BCM56800_A0_FP_COUNTER_TABLE_Ym_COUNTERf_GET
#define FP_COUNTER_TABLE_Ym_COUNTERf_SET BCM56800_A0_FP_COUNTER_TABLE_Ym_COUNTERf_SET
#define READ_FP_COUNTER_TABLE_Ym BCM56800_A0_READ_FP_COUNTER_TABLE_Ym
#define WRITE_FP_COUNTER_TABLE_Ym BCM56800_A0_WRITE_FP_COUNTER_TABLE_Ym

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_COUNTER_TABLE_Ym'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_F4_SELECT
 * BLOCKS:   IPIPE
 * DESC:     FP_F4_SELECT, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     SLICE_0_F4       CONTROL for F4 selector for SLICE 0. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE_1_F4       CONTROL for F4 selector for SLICE 1. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE_2_F4       CONTROL for F4 selector for SLICE 2. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE_3_F4       CONTROL for F4 selector for SLICE 3. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE_4_F4       CONTROL for F4 selector for SLICE 4. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE_5_F4       CONTROL for F4 selector for SLICE 5. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE_6_F4       CONTROL for F4 selector for SLICE 6. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *     SLICE_7_F4       CONTROL for F4 selector for SLICE 7. 0=SRC_PORT_NUMBER, 1=PKT_FORMAT
 *
 ******************************************************************************/
#define BCM56800_A0_FP_F4_SELECTr 0x0c18061f

#define BCM56800_A0_FP_F4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program FP_F4_SELECT.
 *
 */
typedef union BCM56800_A0_FP_F4_SELECTr_s {
	uint32_t v[1];
	uint32_t fp_f4_select[1];
	uint32_t _fp_f4_select;
} BCM56800_A0_FP_F4_SELECTr_t;

#define BCM56800_A0_FP_F4_SELECTr_CLR(r) (r).fp_f4_select[0] = 0
#define BCM56800_A0_FP_F4_SELECTr_SET(r,d) (r).fp_f4_select[0] = d
#define BCM56800_A0_FP_F4_SELECTr_GET(r) (r).fp_f4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_F4_SELECTr_SLICE_0_F4f_GET(r) (((r).fp_f4_select[0]) & 0x1)
#define BCM56800_A0_FP_F4_SELECTr_SLICE_0_F4f_SET(r,f) (r).fp_f4_select[0]=(((r).fp_f4_select[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FP_F4_SELECTr_SLICE_1_F4f_GET(r) ((((r).fp_f4_select[0]) >> 1) & 0x1)
#define BCM56800_A0_FP_F4_SELECTr_SLICE_1_F4f_SET(r,f) (r).fp_f4_select[0]=(((r).fp_f4_select[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_FP_F4_SELECTr_SLICE_2_F4f_GET(r) ((((r).fp_f4_select[0]) >> 2) & 0x1)
#define BCM56800_A0_FP_F4_SELECTr_SLICE_2_F4f_SET(r,f) (r).fp_f4_select[0]=(((r).fp_f4_select[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_FP_F4_SELECTr_SLICE_3_F4f_GET(r) ((((r).fp_f4_select[0]) >> 3) & 0x1)
#define BCM56800_A0_FP_F4_SELECTr_SLICE_3_F4f_SET(r,f) (r).fp_f4_select[0]=(((r).fp_f4_select[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_FP_F4_SELECTr_SLICE_4_F4f_GET(r) ((((r).fp_f4_select[0]) >> 4) & 0x1)
#define BCM56800_A0_FP_F4_SELECTr_SLICE_4_F4f_SET(r,f) (r).fp_f4_select[0]=(((r).fp_f4_select[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_FP_F4_SELECTr_SLICE_5_F4f_GET(r) ((((r).fp_f4_select[0]) >> 5) & 0x1)
#define BCM56800_A0_FP_F4_SELECTr_SLICE_5_F4f_SET(r,f) (r).fp_f4_select[0]=(((r).fp_f4_select[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_FP_F4_SELECTr_SLICE_6_F4f_GET(r) ((((r).fp_f4_select[0]) >> 6) & 0x1)
#define BCM56800_A0_FP_F4_SELECTr_SLICE_6_F4f_SET(r,f) (r).fp_f4_select[0]=(((r).fp_f4_select[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_FP_F4_SELECTr_SLICE_7_F4f_GET(r) ((((r).fp_f4_select[0]) >> 7) & 0x1)
#define BCM56800_A0_FP_F4_SELECTr_SLICE_7_F4f_SET(r,f) (r).fp_f4_select[0]=(((r).fp_f4_select[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FP_F4_SELECT.
 *
 */
#define BCM56800_A0_READ_FP_F4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_F4_SELECTr,(r._fp_f4_select))
#define BCM56800_A0_WRITE_FP_F4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_F4_SELECTr,&(r._fp_f4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_F4_SELECTr BCM56800_A0_FP_F4_SELECTr
#define FP_F4_SELECTr_SIZE BCM56800_A0_FP_F4_SELECTr_SIZE
typedef BCM56800_A0_FP_F4_SELECTr_t FP_F4_SELECTr_t;
#define FP_F4_SELECTr_CLR BCM56800_A0_FP_F4_SELECTr_CLR
#define FP_F4_SELECTr_SET BCM56800_A0_FP_F4_SELECTr_SET
#define FP_F4_SELECTr_GET BCM56800_A0_FP_F4_SELECTr_GET
#define FP_F4_SELECTr_SLICE_0_F4f_GET BCM56800_A0_FP_F4_SELECTr_SLICE_0_F4f_GET
#define FP_F4_SELECTr_SLICE_0_F4f_SET BCM56800_A0_FP_F4_SELECTr_SLICE_0_F4f_SET
#define FP_F4_SELECTr_SLICE_1_F4f_GET BCM56800_A0_FP_F4_SELECTr_SLICE_1_F4f_GET
#define FP_F4_SELECTr_SLICE_1_F4f_SET BCM56800_A0_FP_F4_SELECTr_SLICE_1_F4f_SET
#define FP_F4_SELECTr_SLICE_2_F4f_GET BCM56800_A0_FP_F4_SELECTr_SLICE_2_F4f_GET
#define FP_F4_SELECTr_SLICE_2_F4f_SET BCM56800_A0_FP_F4_SELECTr_SLICE_2_F4f_SET
#define FP_F4_SELECTr_SLICE_3_F4f_GET BCM56800_A0_FP_F4_SELECTr_SLICE_3_F4f_GET
#define FP_F4_SELECTr_SLICE_3_F4f_SET BCM56800_A0_FP_F4_SELECTr_SLICE_3_F4f_SET
#define FP_F4_SELECTr_SLICE_4_F4f_GET BCM56800_A0_FP_F4_SELECTr_SLICE_4_F4f_GET
#define FP_F4_SELECTr_SLICE_4_F4f_SET BCM56800_A0_FP_F4_SELECTr_SLICE_4_F4f_SET
#define FP_F4_SELECTr_SLICE_5_F4f_GET BCM56800_A0_FP_F4_SELECTr_SLICE_5_F4f_GET
#define FP_F4_SELECTr_SLICE_5_F4f_SET BCM56800_A0_FP_F4_SELECTr_SLICE_5_F4f_SET
#define FP_F4_SELECTr_SLICE_6_F4f_GET BCM56800_A0_FP_F4_SELECTr_SLICE_6_F4f_GET
#define FP_F4_SELECTr_SLICE_6_F4f_SET BCM56800_A0_FP_F4_SELECTr_SLICE_6_F4f_SET
#define FP_F4_SELECTr_SLICE_7_F4f_GET BCM56800_A0_FP_F4_SELECTr_SLICE_7_F4f_GET
#define FP_F4_SELECTr_SLICE_7_F4f_SET BCM56800_A0_FP_F4_SELECTr_SLICE_7_F4f_SET
#define READ_FP_F4_SELECTr BCM56800_A0_READ_FP_F4_SELECTr
#define WRITE_FP_F4_SELECTr BCM56800_A0_WRITE_FP_F4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_F4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_METER_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     FP_METER_CONTROL, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     PACKET_IFG_BYTES BYTES TO ADD IN ADDITION TO THE PACKET BYTE COUNT FOR METERING
 *
 ******************************************************************************/
#define BCM56800_A0_FP_METER_CONTROLr 0x0c18060c

#define BCM56800_A0_FP_METER_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program FP_METER_CONTROL.
 *
 */
typedef union BCM56800_A0_FP_METER_CONTROLr_s {
	uint32_t v[1];
	uint32_t fp_meter_control[1];
	uint32_t _fp_meter_control;
} BCM56800_A0_FP_METER_CONTROLr_t;

#define BCM56800_A0_FP_METER_CONTROLr_CLR(r) (r).fp_meter_control[0] = 0
#define BCM56800_A0_FP_METER_CONTROLr_SET(r,d) (r).fp_meter_control[0] = d
#define BCM56800_A0_FP_METER_CONTROLr_GET(r) (r).fp_meter_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET(r) (((r).fp_meter_control[0]) & 0x1f)
#define BCM56800_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET(r,f) (r).fp_meter_control[0]=(((r).fp_meter_control[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access FP_METER_CONTROL.
 *
 */
#define BCM56800_A0_READ_FP_METER_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_METER_CONTROLr,(r._fp_meter_control))
#define BCM56800_A0_WRITE_FP_METER_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_METER_CONTROLr,&(r._fp_meter_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_METER_CONTROLr BCM56800_A0_FP_METER_CONTROLr
#define FP_METER_CONTROLr_SIZE BCM56800_A0_FP_METER_CONTROLr_SIZE
typedef BCM56800_A0_FP_METER_CONTROLr_t FP_METER_CONTROLr_t;
#define FP_METER_CONTROLr_CLR BCM56800_A0_FP_METER_CONTROLr_CLR
#define FP_METER_CONTROLr_SET BCM56800_A0_FP_METER_CONTROLr_SET
#define FP_METER_CONTROLr_GET BCM56800_A0_FP_METER_CONTROLr_GET
#define FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET BCM56800_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_GET
#define FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET BCM56800_A0_FP_METER_CONTROLr_PACKET_IFG_BYTESf_SET
#define READ_FP_METER_CONTROLr BCM56800_A0_READ_FP_METER_CONTROLr
#define WRITE_FP_METER_CONTROLr BCM56800_A0_WRITE_FP_METER_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_METER_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_METER_TABLE
 * BLOCKS:   IPIPE
 * DESC:     THIS ADDRESS WILL BE REMOVED when the c-code is updated to use _TABLE_X and _TABLE_Y. FeatureSpecific-FP
 * SIZE:     54
 * FIELDS:
 *     BUCKETCOUNT      BUCKETCOUNT
 *     BUCKETSIZE       BUCKETSIZE
 *     REFRESHCOUNT     REFRESHCOUNT
 *     REFRESH_MODE     REFRESH_MODE
 *
 ******************************************************************************/
#define BCM56800_A0_FP_METER_TABLEm 0x0c1c6000

#define BCM56800_A0_FP_METER_TABLEm_MIN 0
#define BCM56800_A0_FP_METER_TABLEm_MAX 1023
#define BCM56800_A0_FP_METER_TABLEm_CMAX(u) 1023
#define BCM56800_A0_FP_METER_TABLEm_SIZE 7

/*
 * This structure should be used to declare and program FP_METER_TABLE.
 *
 */
typedef union BCM56800_A0_FP_METER_TABLEm_s {
	uint32_t v[2];
	uint32_t fp_meter_table[2];
	uint32_t _fp_meter_table;
} BCM56800_A0_FP_METER_TABLEm_t;

#define BCM56800_A0_FP_METER_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_meter_table), 0, sizeof(BCM56800_A0_FP_METER_TABLEm_t))
#define BCM56800_A0_FP_METER_TABLEm_SET(r,i,d) (r).fp_meter_table[i] = d
#define BCM56800_A0_FP_METER_TABLEm_GET(r,i) (r).fp_meter_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_METER_TABLEm_BUCKETCOUNTf_GET(r) (((r).fp_meter_table[0]) & 0x3fffffff)
#define BCM56800_A0_FP_METER_TABLEm_BUCKETCOUNTf_SET(r,f) (r).fp_meter_table[0]=(((r).fp_meter_table[0] & ~((uint32_t)0x3fffffff)) | (((uint32_t)f) & 0x3fffffff))
#define BCM56800_A0_FP_METER_TABLEm_BUCKETSIZEf_GET(r) cdk_field32_get((r).fp_meter_table,30,33)
#define BCM56800_A0_FP_METER_TABLEm_BUCKETSIZEf_SET(r,f) cdk_field32_set((r).fp_meter_table,30,33,f)
#define BCM56800_A0_FP_METER_TABLEm_REFRESHCOUNTf_GET(r) ((((r).fp_meter_table[1]) >> 2) & 0x7ffff)
#define BCM56800_A0_FP_METER_TABLEm_REFRESHCOUNTf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x7ffff << 2)) | ((((uint32_t)f) & 0x7ffff) << 2))
#define BCM56800_A0_FP_METER_TABLEm_REFRESH_MODEf_GET(r) ((((r).fp_meter_table[1]) >> 21) & 0x1)
#define BCM56800_A0_FP_METER_TABLEm_REFRESH_MODEf_SET(r,f) (r).fp_meter_table[1]=(((r).fp_meter_table[1] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))

/*
 * These macros can be used to access FP_METER_TABLE.
 *
 */
#define BCM56800_A0_READ_FP_METER_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_METER_TABLEm,i,(m._fp_meter_table),2)
#define BCM56800_A0_WRITE_FP_METER_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_METER_TABLEm,i,&(m._fp_meter_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_METER_TABLEm BCM56800_A0_FP_METER_TABLEm
#define FP_METER_TABLEm_MIN BCM56800_A0_FP_METER_TABLEm_MIN
#define FP_METER_TABLEm_MAX BCM56800_A0_FP_METER_TABLEm_MAX
#define FP_METER_TABLEm_CMAX(u) BCM56800_A0_FP_METER_TABLEm_CMAX(u)
#define FP_METER_TABLEm_SIZE BCM56800_A0_FP_METER_TABLEm_SIZE
typedef BCM56800_A0_FP_METER_TABLEm_t FP_METER_TABLEm_t;
#define FP_METER_TABLEm_CLR BCM56800_A0_FP_METER_TABLEm_CLR
#define FP_METER_TABLEm_SET BCM56800_A0_FP_METER_TABLEm_SET
#define FP_METER_TABLEm_GET BCM56800_A0_FP_METER_TABLEm_GET
#define FP_METER_TABLEm_BUCKETCOUNTf_GET BCM56800_A0_FP_METER_TABLEm_BUCKETCOUNTf_GET
#define FP_METER_TABLEm_BUCKETCOUNTf_SET BCM56800_A0_FP_METER_TABLEm_BUCKETCOUNTf_SET
#define FP_METER_TABLEm_BUCKETSIZEf_GET BCM56800_A0_FP_METER_TABLEm_BUCKETSIZEf_GET
#define FP_METER_TABLEm_BUCKETSIZEf_SET BCM56800_A0_FP_METER_TABLEm_BUCKETSIZEf_SET
#define FP_METER_TABLEm_REFRESHCOUNTf_GET BCM56800_A0_FP_METER_TABLEm_REFRESHCOUNTf_GET
#define FP_METER_TABLEm_REFRESHCOUNTf_SET BCM56800_A0_FP_METER_TABLEm_REFRESHCOUNTf_SET
#define FP_METER_TABLEm_REFRESH_MODEf_GET BCM56800_A0_FP_METER_TABLEm_REFRESH_MODEf_GET
#define FP_METER_TABLEm_REFRESH_MODEf_SET BCM56800_A0_FP_METER_TABLEm_REFRESH_MODEf_SET
#define READ_FP_METER_TABLEm BCM56800_A0_READ_FP_METER_TABLEm
#define WRITE_FP_METER_TABLEm BCM56800_A0_WRITE_FP_METER_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_METER_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_POLICY_TABLE
 * BLOCKS:   IPIPE
 * DESC:     POLICY TABLE FOR DETERMINING ACTIONS IN THE FP, FeatureSpecific-FP
 * SIZE:     135
 * FIELDS:
 *     EM_MTP_INDEX     EM_MTP_INDEX
 *     IM_MTP_INDEX     IM_MTP_INDEX
 *     MTP_INDEX_SPARE  MTP_INDEX_SPARE
 *     REDIRECTION      REDIRECTION
 *     ECMP_PTR         ECMP_PTR
 *     ECMP_COUNT       ECMP_COUNT
 *     ECMP             ECMP
 *     DO_NOT_CHANGE_TTL DO NOT CHANGE TTL for L3 routed pkts.
 *     YP_DSCP          YP_DSCP
 *     RP_DSCP          RP_DSCP
 *     NEWDSCP_TOS      NEWDSCP_TOS
 *     NEWPRI           NEWPRI
 *     METER_PAIR_MODE  METER_PAIR_MODE
 *     METER_TEST_EVEN  METER_TEST_EVEN
 *     METER_TEST_ODD   METER_TEST_ODD
 *     METER_UPDATE_EVEN METER_UPDATE_EVEN
 *     METER_UPDATE_ODD METER_UPDATE_ODD
 *     METER_INDEX_EVEN METER_INDEX_EVEN
 *     METER_INDEX_ODD  METER_INDEX_ODD
 *     COUNTER_MODE     COUNTER_MODE
 *     COUNTER_INDEX    COUNTER_INDEX
 *     YP_CHANGE_DSCP   YP_CHANGE_DSCP
 *     YP_COPY_TO_CPU   YP_COPY_TO_CPU
 *     YP_DROP_PRECEDENCE YP_DROP_PRECEDENCE
 *     YP_DROP          YP_DROP
 *     RP_CHANGE_DSCP   RP_CHANGE_DSCP
 *     RP_COPY_TO_CPU   RP_COPY_TO_CPU
 *     RP_DROP_PRECEDENCE RP_DROP_PRECEDENCE
 *     RP_DROP          RP_DROP
 *     DROP_PRECEDENCE  DROP_PRECEDENCE
 *     L3SW_CHANGE_MACDA_OR_VLAN L3SW_CHANGE_MACDA_OR_VLAN
 *     MIRROR           MIRROR
 *     MIRROR_OVERRIDE  CONTROLS OVERRIDING MIRROR PROCESSING IN SW2 STAGE
 *     DROP             DROP
 *     CHAIN            CHAIN
 *     PACKET_REDIRECTION PACKET_REDIRECTION
 *     COPY_TO_CPU      COPY_TO_CPU
 *     CHANGE_DSCP_TOS  CHANGE_DSCP_TOS
 *     CHANGE_PRIORITY  CHANGE_PRIORITY
 *     ECN_CNG          CONTROL WHETHER DROP PRECEDENCE SETS ECN OR CNG BITS
 *     GREEN_TO_PID     GREEN_TO_PID CONTROLS WHETHER PACKET_REDIRECTION and L3SW_CHANGE_MACDA_OR_VLAN  are Green (0) or Color Independent (1) actions
 *     CHAIN_INDEX      CHAIN_INDEX
 *     CHAIN_VALID      CHAIN_VALID
 *     NEXT_HOP_INDEX   NEXT_HOP_INDEX
 *     CLASSIFICATION_TAG CLASSIFICATION_TAG
 *     MATCHED_RULE     MATCHED_RULE
 *
 ******************************************************************************/
#define BCM56800_A0_FP_POLICY_TABLEm 0x0c165000

#define BCM56800_A0_FP_POLICY_TABLEm_MIN 0
#define BCM56800_A0_FP_POLICY_TABLEm_MAX 1023
#define BCM56800_A0_FP_POLICY_TABLEm_CMAX(u) 1023
#define BCM56800_A0_FP_POLICY_TABLEm_SIZE 17

/*
 * This structure should be used to declare and program FP_POLICY_TABLE.
 *
 */
typedef union BCM56800_A0_FP_POLICY_TABLEm_s {
	uint32_t v[5];
	uint32_t fp_policy_table[5];
	uint32_t _fp_policy_table;
} BCM56800_A0_FP_POLICY_TABLEm_t;

#define BCM56800_A0_FP_POLICY_TABLEm_CLR(r) CDK_MEMSET(&((r)._fp_policy_table), 0, sizeof(BCM56800_A0_FP_POLICY_TABLEm_t))
#define BCM56800_A0_FP_POLICY_TABLEm_SET(r,i,d) (r).fp_policy_table[i] = d
#define BCM56800_A0_FP_POLICY_TABLEm_GET(r,i) (r).fp_policy_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_GET(r) (((r).fp_policy_table[0]) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_GET(r) ((((r).fp_policy_table[0]) >> 2) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET(r) ((((r).fp_policy_table[0]) >> 4) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_FP_POLICY_TABLEm_REDIRECTIONf_GET(r) ((((r).fp_policy_table[0]) >> 5) & 0x1fffff)
#define BCM56800_A0_FP_POLICY_TABLEm_REDIRECTIONf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x1fffff << 5)) | ((((uint32_t)f) & 0x1fffff) << 5))
#define BCM56800_A0_FP_POLICY_TABLEm_ECMP_PTRf_GET(r) cdk_field32_get((r).fp_policy_table,26,36)
#define BCM56800_A0_FP_POLICY_TABLEm_ECMP_PTRf_SET(r,f) cdk_field32_set((r).fp_policy_table,26,36,f)
#define BCM56800_A0_FP_POLICY_TABLEm_ECMP_COUNTf_GET(r) ((((r).fp_policy_table[1]) >> 5) & 0x1f)
#define BCM56800_A0_FP_POLICY_TABLEm_ECMP_COUNTf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_FP_POLICY_TABLEm_ECMPf_GET(r) ((((r).fp_policy_table[1]) >> 10) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_ECMPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET(r) ((((r).fp_policy_table[1]) >> 12) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_FP_POLICY_TABLEm_YP_DSCPf_GET(r) ((((r).fp_policy_table[1]) >> 13) & 0x3f)
#define BCM56800_A0_FP_POLICY_TABLEm_YP_DSCPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x3f << 13)) | ((((uint32_t)f) & 0x3f) << 13))
#define BCM56800_A0_FP_POLICY_TABLEm_RP_DSCPf_GET(r) ((((r).fp_policy_table[1]) >> 19) & 0x3f)
#define BCM56800_A0_FP_POLICY_TABLEm_RP_DSCPf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x3f << 19)) | ((((uint32_t)f) & 0x3f) << 19))
#define BCM56800_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_GET(r) ((((r).fp_policy_table[1]) >> 25) & 0x3f)
#define BCM56800_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0x3f << 25)) | ((((uint32_t)f) & 0x3f) << 25))
#define BCM56800_A0_FP_POLICY_TABLEm_NEWPRIf_GET(r) cdk_field32_get((r).fp_policy_table,63,66)
#define BCM56800_A0_FP_POLICY_TABLEm_NEWPRIf_SET(r,f) cdk_field32_set((r).fp_policy_table,63,66,f)
#define BCM56800_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_GET(r) ((((r).fp_policy_table[2]) >> 3) & 0x7)
#define BCM56800_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56800_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 6) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 7) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 8) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 9) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_GET(r) ((((r).fp_policy_table[2]) >> 10) & 0x3f)
#define BCM56800_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))
#define BCM56800_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_GET(r) ((((r).fp_policy_table[2]) >> 16) & 0x3f)
#define BCM56800_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56800_A0_FP_POLICY_TABLEm_COUNTER_MODEf_GET(r) ((((r).fp_policy_table[2]) >> 22) & 0xf)
#define BCM56800_A0_FP_POLICY_TABLEm_COUNTER_MODEf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define BCM56800_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_GET(r) ((((r).fp_policy_table[2]) >> 26) & 0x3f)
#define BCM56800_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_SET(r,f) (r).fp_policy_table[2]=(((r).fp_policy_table[2] & ~((uint32_t)0x3f << 26)) | ((((uint32_t)f) & 0x3f) << 26))
#define BCM56800_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET(r) (((r).fp_policy_table[3]) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[3]) >> 1) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56800_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 3) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56800_A0_FP_POLICY_TABLEm_YP_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 5) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_YP_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56800_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET(r) ((((r).fp_policy_table[3]) >> 7) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[3]) >> 8) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56800_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 10) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56800_A0_FP_POLICY_TABLEm_RP_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 12) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_RP_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56800_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET(r) ((((r).fp_policy_table[3]) >> 14) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56800_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET(r) ((((r).fp_policy_table[3]) >> 16) & 0x7)
#define BCM56800_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56800_A0_FP_POLICY_TABLEm_MIRRORf_GET(r) ((((r).fp_policy_table[3]) >> 19) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_MIRRORf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM56800_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET(r) ((((r).fp_policy_table[3]) >> 21) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_FP_POLICY_TABLEm_DROPf_GET(r) ((((r).fp_policy_table[3]) >> 22) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_DROPf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56800_A0_FP_POLICY_TABLEm_CHAINf_GET(r) ((((r).fp_policy_table[3]) >> 24) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_CHAINf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET(r) ((((r).fp_policy_table[3]) >> 25) & 0x7)
#define BCM56800_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56800_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_GET(r) ((((r).fp_policy_table[3]) >> 28) & 0x3)
#define BCM56800_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_SET(r,f) (r).fp_policy_table[3]=(((r).fp_policy_table[3] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56800_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET(r) cdk_field32_get((r).fp_policy_table,126,128)
#define BCM56800_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET(r,f) cdk_field32_set((r).fp_policy_table,126,128,f)
#define BCM56800_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET(r) ((((r).fp_policy_table[4]) >> 1) & 0xf)
#define BCM56800_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM56800_A0_FP_POLICY_TABLEm_ECN_CNGf_GET(r) ((((r).fp_policy_table[4]) >> 5) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_ECN_CNGf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_GET(r) ((((r).fp_policy_table[4]) >> 6) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_SET(r,f) (r).fp_policy_table[4]=(((r).fp_policy_table[4] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_GET(r) ((((r).fp_policy_table[0]) >> 18) & 0x7f)
#define BCM56800_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x7f << 18)) | ((((uint32_t)f) & 0x7f) << 18))
#define BCM56800_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_GET(r) ((((r).fp_policy_table[0]) >> 25) & 0x1)
#define BCM56800_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_SET(r,f) (r).fp_policy_table[0]=(((r).fp_policy_table[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET(r) cdk_field32_get((r).fp_policy_table,26,38)
#define BCM56800_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET(r,f) cdk_field32_set((r).fp_policy_table,26,38,f)
#define BCM56800_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET(r) cdk_field32_get((r).fp_policy_table,26,36)
#define BCM56800_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET(r,f) cdk_field32_set((r).fp_policy_table,26,36,f)
#define BCM56800_A0_FP_POLICY_TABLEm_MATCHED_RULEf_GET(r) ((((r).fp_policy_table[1]) >> 5) & 0xff)
#define BCM56800_A0_FP_POLICY_TABLEm_MATCHED_RULEf_SET(r,f) (r).fp_policy_table[1]=(((r).fp_policy_table[1] & ~((uint32_t)0xff << 5)) | ((((uint32_t)f) & 0xff) << 5))

/*
 * These macros can be used to access FP_POLICY_TABLE.
 *
 */
#define BCM56800_A0_READ_FP_POLICY_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_POLICY_TABLEm,i,(m._fp_policy_table),5)
#define BCM56800_A0_WRITE_FP_POLICY_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_POLICY_TABLEm,i,&(m._fp_policy_table),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_POLICY_TABLEm BCM56800_A0_FP_POLICY_TABLEm
#define FP_POLICY_TABLEm_MIN BCM56800_A0_FP_POLICY_TABLEm_MIN
#define FP_POLICY_TABLEm_MAX BCM56800_A0_FP_POLICY_TABLEm_MAX
#define FP_POLICY_TABLEm_CMAX(u) BCM56800_A0_FP_POLICY_TABLEm_CMAX(u)
#define FP_POLICY_TABLEm_SIZE BCM56800_A0_FP_POLICY_TABLEm_SIZE
typedef BCM56800_A0_FP_POLICY_TABLEm_t FP_POLICY_TABLEm_t;
#define FP_POLICY_TABLEm_CLR BCM56800_A0_FP_POLICY_TABLEm_CLR
#define FP_POLICY_TABLEm_SET BCM56800_A0_FP_POLICY_TABLEm_SET
#define FP_POLICY_TABLEm_GET BCM56800_A0_FP_POLICY_TABLEm_GET
#define FP_POLICY_TABLEm_EM_MTP_INDEXf_GET BCM56800_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_GET
#define FP_POLICY_TABLEm_EM_MTP_INDEXf_SET BCM56800_A0_FP_POLICY_TABLEm_EM_MTP_INDEXf_SET
#define FP_POLICY_TABLEm_IM_MTP_INDEXf_GET BCM56800_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_GET
#define FP_POLICY_TABLEm_IM_MTP_INDEXf_SET BCM56800_A0_FP_POLICY_TABLEm_IM_MTP_INDEXf_SET
#define FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET BCM56800_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_GET
#define FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET BCM56800_A0_FP_POLICY_TABLEm_MTP_INDEX_SPAREf_SET
#define FP_POLICY_TABLEm_REDIRECTIONf_GET BCM56800_A0_FP_POLICY_TABLEm_REDIRECTIONf_GET
#define FP_POLICY_TABLEm_REDIRECTIONf_SET BCM56800_A0_FP_POLICY_TABLEm_REDIRECTIONf_SET
#define FP_POLICY_TABLEm_ECMP_PTRf_GET BCM56800_A0_FP_POLICY_TABLEm_ECMP_PTRf_GET
#define FP_POLICY_TABLEm_ECMP_PTRf_SET BCM56800_A0_FP_POLICY_TABLEm_ECMP_PTRf_SET
#define FP_POLICY_TABLEm_ECMP_COUNTf_GET BCM56800_A0_FP_POLICY_TABLEm_ECMP_COUNTf_GET
#define FP_POLICY_TABLEm_ECMP_COUNTf_SET BCM56800_A0_FP_POLICY_TABLEm_ECMP_COUNTf_SET
#define FP_POLICY_TABLEm_ECMPf_GET BCM56800_A0_FP_POLICY_TABLEm_ECMPf_GET
#define FP_POLICY_TABLEm_ECMPf_SET BCM56800_A0_FP_POLICY_TABLEm_ECMPf_SET
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET BCM56800_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_GET
#define FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET BCM56800_A0_FP_POLICY_TABLEm_DO_NOT_CHANGE_TTLf_SET
#define FP_POLICY_TABLEm_YP_DSCPf_GET BCM56800_A0_FP_POLICY_TABLEm_YP_DSCPf_GET
#define FP_POLICY_TABLEm_YP_DSCPf_SET BCM56800_A0_FP_POLICY_TABLEm_YP_DSCPf_SET
#define FP_POLICY_TABLEm_RP_DSCPf_GET BCM56800_A0_FP_POLICY_TABLEm_RP_DSCPf_GET
#define FP_POLICY_TABLEm_RP_DSCPf_SET BCM56800_A0_FP_POLICY_TABLEm_RP_DSCPf_SET
#define FP_POLICY_TABLEm_NEWDSCP_TOSf_GET BCM56800_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_GET
#define FP_POLICY_TABLEm_NEWDSCP_TOSf_SET BCM56800_A0_FP_POLICY_TABLEm_NEWDSCP_TOSf_SET
#define FP_POLICY_TABLEm_NEWPRIf_GET BCM56800_A0_FP_POLICY_TABLEm_NEWPRIf_GET
#define FP_POLICY_TABLEm_NEWPRIf_SET BCM56800_A0_FP_POLICY_TABLEm_NEWPRIf_SET
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_GET BCM56800_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_GET
#define FP_POLICY_TABLEm_METER_PAIR_MODEf_SET BCM56800_A0_FP_POLICY_TABLEm_METER_PAIR_MODEf_SET
#define FP_POLICY_TABLEm_METER_TEST_EVENf_GET BCM56800_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_GET
#define FP_POLICY_TABLEm_METER_TEST_EVENf_SET BCM56800_A0_FP_POLICY_TABLEm_METER_TEST_EVENf_SET
#define FP_POLICY_TABLEm_METER_TEST_ODDf_GET BCM56800_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_GET
#define FP_POLICY_TABLEm_METER_TEST_ODDf_SET BCM56800_A0_FP_POLICY_TABLEm_METER_TEST_ODDf_SET
#define FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET BCM56800_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_GET
#define FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET BCM56800_A0_FP_POLICY_TABLEm_METER_UPDATE_EVENf_SET
#define FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET BCM56800_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_GET
#define FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET BCM56800_A0_FP_POLICY_TABLEm_METER_UPDATE_ODDf_SET
#define FP_POLICY_TABLEm_METER_INDEX_EVENf_GET BCM56800_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_GET
#define FP_POLICY_TABLEm_METER_INDEX_EVENf_SET BCM56800_A0_FP_POLICY_TABLEm_METER_INDEX_EVENf_SET
#define FP_POLICY_TABLEm_METER_INDEX_ODDf_GET BCM56800_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_GET
#define FP_POLICY_TABLEm_METER_INDEX_ODDf_SET BCM56800_A0_FP_POLICY_TABLEm_METER_INDEX_ODDf_SET
#define FP_POLICY_TABLEm_COUNTER_MODEf_GET BCM56800_A0_FP_POLICY_TABLEm_COUNTER_MODEf_GET
#define FP_POLICY_TABLEm_COUNTER_MODEf_SET BCM56800_A0_FP_POLICY_TABLEm_COUNTER_MODEf_SET
#define FP_POLICY_TABLEm_COUNTER_INDEXf_GET BCM56800_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_GET
#define FP_POLICY_TABLEm_COUNTER_INDEXf_SET BCM56800_A0_FP_POLICY_TABLEm_COUNTER_INDEXf_SET
#define FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET BCM56800_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_GET
#define FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET BCM56800_A0_FP_POLICY_TABLEm_YP_CHANGE_DSCPf_SET
#define FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET BCM56800_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET BCM56800_A0_FP_POLICY_TABLEm_YP_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET BCM56800_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET BCM56800_A0_FP_POLICY_TABLEm_YP_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_YP_DROPf_GET BCM56800_A0_FP_POLICY_TABLEm_YP_DROPf_GET
#define FP_POLICY_TABLEm_YP_DROPf_SET BCM56800_A0_FP_POLICY_TABLEm_YP_DROPf_SET
#define FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET BCM56800_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_GET
#define FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET BCM56800_A0_FP_POLICY_TABLEm_RP_CHANGE_DSCPf_SET
#define FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET BCM56800_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET BCM56800_A0_FP_POLICY_TABLEm_RP_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET BCM56800_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET BCM56800_A0_FP_POLICY_TABLEm_RP_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_RP_DROPf_GET BCM56800_A0_FP_POLICY_TABLEm_RP_DROPf_GET
#define FP_POLICY_TABLEm_RP_DROPf_SET BCM56800_A0_FP_POLICY_TABLEm_RP_DROPf_SET
#define FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET BCM56800_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_GET
#define FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET BCM56800_A0_FP_POLICY_TABLEm_DROP_PRECEDENCEf_SET
#define FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET BCM56800_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_GET
#define FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET BCM56800_A0_FP_POLICY_TABLEm_L3SW_CHANGE_MACDA_OR_VLANf_SET
#define FP_POLICY_TABLEm_MIRRORf_GET BCM56800_A0_FP_POLICY_TABLEm_MIRRORf_GET
#define FP_POLICY_TABLEm_MIRRORf_SET BCM56800_A0_FP_POLICY_TABLEm_MIRRORf_SET
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET BCM56800_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_GET
#define FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET BCM56800_A0_FP_POLICY_TABLEm_MIRROR_OVERRIDEf_SET
#define FP_POLICY_TABLEm_DROPf_GET BCM56800_A0_FP_POLICY_TABLEm_DROPf_GET
#define FP_POLICY_TABLEm_DROPf_SET BCM56800_A0_FP_POLICY_TABLEm_DROPf_SET
#define FP_POLICY_TABLEm_CHAINf_GET BCM56800_A0_FP_POLICY_TABLEm_CHAINf_GET
#define FP_POLICY_TABLEm_CHAINf_SET BCM56800_A0_FP_POLICY_TABLEm_CHAINf_SET
#define FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET BCM56800_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_GET
#define FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET BCM56800_A0_FP_POLICY_TABLEm_PACKET_REDIRECTIONf_SET
#define FP_POLICY_TABLEm_COPY_TO_CPUf_GET BCM56800_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_GET
#define FP_POLICY_TABLEm_COPY_TO_CPUf_SET BCM56800_A0_FP_POLICY_TABLEm_COPY_TO_CPUf_SET
#define FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET BCM56800_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_GET
#define FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET BCM56800_A0_FP_POLICY_TABLEm_CHANGE_DSCP_TOSf_SET
#define FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET BCM56800_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_GET
#define FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET BCM56800_A0_FP_POLICY_TABLEm_CHANGE_PRIORITYf_SET
#define FP_POLICY_TABLEm_ECN_CNGf_GET BCM56800_A0_FP_POLICY_TABLEm_ECN_CNGf_GET
#define FP_POLICY_TABLEm_ECN_CNGf_SET BCM56800_A0_FP_POLICY_TABLEm_ECN_CNGf_SET
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_GET BCM56800_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_GET
#define FP_POLICY_TABLEm_GREEN_TO_PIDf_SET BCM56800_A0_FP_POLICY_TABLEm_GREEN_TO_PIDf_SET
#define FP_POLICY_TABLEm_CHAIN_INDEXf_GET BCM56800_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_GET
#define FP_POLICY_TABLEm_CHAIN_INDEXf_SET BCM56800_A0_FP_POLICY_TABLEm_CHAIN_INDEXf_SET
#define FP_POLICY_TABLEm_CHAIN_VALIDf_GET BCM56800_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_GET
#define FP_POLICY_TABLEm_CHAIN_VALIDf_SET BCM56800_A0_FP_POLICY_TABLEm_CHAIN_VALIDf_SET
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET BCM56800_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_GET
#define FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET BCM56800_A0_FP_POLICY_TABLEm_NEXT_HOP_INDEXf_SET
#define FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET BCM56800_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_GET
#define FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET BCM56800_A0_FP_POLICY_TABLEm_CLASSIFICATION_TAGf_SET
#define FP_POLICY_TABLEm_MATCHED_RULEf_GET BCM56800_A0_FP_POLICY_TABLEm_MATCHED_RULEf_GET
#define FP_POLICY_TABLEm_MATCHED_RULEf_SET BCM56800_A0_FP_POLICY_TABLEm_MATCHED_RULEf_SET
#define READ_FP_POLICY_TABLEm BCM56800_A0_READ_FP_POLICY_TABLEm
#define WRITE_FP_POLICY_TABLEm BCM56800_A0_WRITE_FP_POLICY_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_POLICY_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_PORT_FIELD_SEL
 * BLOCKS:   IPIPE
 * DESC:     FIELD SELECT VALUE FOR EACH SLICE IN THE FP, FeatureSpecific-FP
 * SIZE:     80
 * FIELDS:
 *     SLICE0_F1        F1 field for slice 0.
 *     SLICE0_F2        F2 field for slice 0
 *     SLICE0_F3        F3 field for slice 0
 *     SLICE1_F1        F1 field for slice 1.
 *     SLICE1_F2        F2 field for slice 1
 *     SLICE1_F3        F3 field for slice 1
 *     SLICE2_F1        F1 field for slice 2.
 *     SLICE2_F2        F2 field for slice 2
 *     SLICE2_F3        F3 field for slice 2
 *     SLICE3_F1        F1 field for slice 3.
 *     SLICE3_F2        F2 field for slice 3
 *     SLICE3_F3        F3 field for slice 3
 *     SLICE4_F1        F1 field for slice 4.
 *     SLICE4_F2        F2 field for slice 4
 *     SLICE4_F3        F3 field for slice 4
 *     SLICE5_F1        F1 field for slice 5.
 *     SLICE5_F2        F2 field for slice 5
 *     SLICE5_F3        F3 field for slice 5
 *     SLICE6_F1        F1 field for slice 6.
 *     SLICE6_F2        F2 field for slice 6
 *     SLICE6_F3        F3 field for slice 6
 *     SLICE7_F1        F1 field for slice 7.
 *     SLICE7_F2        F2 field for slice 7
 *     SLICE7_F3        F3 field for slice 7
 *
 ******************************************************************************/
#define BCM56800_A0_FP_PORT_FIELD_SELm 0x0b100000

#define BCM56800_A0_FP_PORT_FIELD_SELm_MIN 0
#define BCM56800_A0_FP_PORT_FIELD_SELm_MAX 20
#define BCM56800_A0_FP_PORT_FIELD_SELm_CMAX(u) 20
#define BCM56800_A0_FP_PORT_FIELD_SELm_SIZE 10

/*
 * This structure should be used to declare and program FP_PORT_FIELD_SEL.
 *
 */
typedef union BCM56800_A0_FP_PORT_FIELD_SELm_s {
	uint32_t v[3];
	uint32_t fp_port_field_sel[3];
	uint32_t _fp_port_field_sel;
} BCM56800_A0_FP_PORT_FIELD_SELm_t;

#define BCM56800_A0_FP_PORT_FIELD_SELm_CLR(r) CDK_MEMSET(&((r)._fp_port_field_sel), 0, sizeof(BCM56800_A0_FP_PORT_FIELD_SELm_t))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SET(r,i,d) (r).fp_port_field_sel[i] = d
#define BCM56800_A0_FP_PORT_FIELD_SELm_GET(r,i) (r).fp_port_field_sel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_GET(r) (((r).fp_port_field_sel[0]) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 3) & 0xf)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 7) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 10) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 13) & 0xf)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 13)) | ((((uint32_t)f) & 0xf) << 13))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 17) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_GET(r) ((((r).fp_port_field_sel[0]) >> 20) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_GET(r) ((((r).fp_port_field_sel[0]) >> 23) & 0xf)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0xf << 23)) | ((((uint32_t)f) & 0xf) << 23))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_GET(r) ((((r).fp_port_field_sel[0]) >> 27) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_SET(r,f) (r).fp_port_field_sel[0]=(((r).fp_port_field_sel[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_GET(r) cdk_field32_get((r).fp_port_field_sel,30,32)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_SET(r,f) cdk_field32_set((r).fp_port_field_sel,30,32,f)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 1) & 0xf)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 5) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 8) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 11) & 0xf)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 15) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 18) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_GET(r) ((((r).fp_port_field_sel[1]) >> 21) & 0xf)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_GET(r) ((((r).fp_port_field_sel[1]) >> 25) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_GET(r) ((((r).fp_port_field_sel[1]) >> 28) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_SET(r,f) (r).fp_port_field_sel[1]=(((r).fp_port_field_sel[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_GET(r) cdk_field32_get((r).fp_port_field_sel,63,66)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_SET(r,f) cdk_field32_set((r).fp_port_field_sel,63,66,f)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 3) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_GET(r) ((((r).fp_port_field_sel[2]) >> 6) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_GET(r) ((((r).fp_port_field_sel[2]) >> 9) & 0xf)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_GET(r) ((((r).fp_port_field_sel[2]) >> 13) & 0x7)
#define BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_SET(r,f) (r).fp_port_field_sel[2]=(((r).fp_port_field_sel[2] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access FP_PORT_FIELD_SEL.
 *
 */
#define BCM56800_A0_READ_FP_PORT_FIELD_SELm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_PORT_FIELD_SELm,i,(m._fp_port_field_sel),3)
#define BCM56800_A0_WRITE_FP_PORT_FIELD_SELm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_PORT_FIELD_SELm,i,&(m._fp_port_field_sel),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_PORT_FIELD_SELm BCM56800_A0_FP_PORT_FIELD_SELm
#define FP_PORT_FIELD_SELm_MIN BCM56800_A0_FP_PORT_FIELD_SELm_MIN
#define FP_PORT_FIELD_SELm_MAX BCM56800_A0_FP_PORT_FIELD_SELm_MAX
#define FP_PORT_FIELD_SELm_CMAX(u) BCM56800_A0_FP_PORT_FIELD_SELm_CMAX(u)
#define FP_PORT_FIELD_SELm_SIZE BCM56800_A0_FP_PORT_FIELD_SELm_SIZE
typedef BCM56800_A0_FP_PORT_FIELD_SELm_t FP_PORT_FIELD_SELm_t;
#define FP_PORT_FIELD_SELm_CLR BCM56800_A0_FP_PORT_FIELD_SELm_CLR
#define FP_PORT_FIELD_SELm_SET BCM56800_A0_FP_PORT_FIELD_SELm_SET
#define FP_PORT_FIELD_SELm_GET BCM56800_A0_FP_PORT_FIELD_SELm_GET
#define FP_PORT_FIELD_SELm_SLICE0_F1f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F1f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F2f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F2f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE0_F3f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE0_F3f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE0_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F1f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F1f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F2f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F2f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE1_F3f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE1_F3f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE1_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F1f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F1f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F2f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F2f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE2_F3f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE2_F3f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE2_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F1f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F1f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F2f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F2f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE3_F3f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE3_F3f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE3_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F1f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F1f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F2f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F2f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE4_F3f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE4_F3f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE4_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F1f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F1f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F2f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F2f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE5_F3f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE5_F3f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE5_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F1f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F1f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F2f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F2f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE6_F3f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE6_F3f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE6_F3f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F1f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F1f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F1f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F2f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F2f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F2f_SET
#define FP_PORT_FIELD_SELm_SLICE7_F3f_GET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_GET
#define FP_PORT_FIELD_SELm_SLICE7_F3f_SET BCM56800_A0_FP_PORT_FIELD_SELm_SLICE7_F3f_SET
#define READ_FP_PORT_FIELD_SELm BCM56800_A0_READ_FP_PORT_FIELD_SELm
#define WRITE_FP_PORT_FIELD_SELm BCM56800_A0_WRITE_FP_PORT_FIELD_SELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_PORT_FIELD_SELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_RAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     FP_RAM_CONTROL, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     POLICYTABLE_TM_0 Policy Table RAM TM debug bits for slice 0
 *     POLICYTABLE_TM_1 Policy Table RAM TM debug bits for slice 1
 *     POLICYTABLE_TM_2 Policy Table RAM TM debug bits for slice 2
 *     POLICYTABLE_TM_3 Policy Table RAM TM debug bits for slice 3
 *     POLICYTABLE_TM_4 Policy Table RAM TM debug bits for slice 4
 *     POLICYTABLE_TM_5 Policy Table RAM TM debug bits for slice 5
 *     POLICYTABLE_TM_6 Policy Table RAM TM debug bits for slice 6
 *     POLICYTABLE_TM_7 Policy Table RAM TM debug bits for slice 7
 *
 ******************************************************************************/
#define BCM56800_A0_FP_RAM_DBGCTRLr 0x0c180c1d

#define BCM56800_A0_FP_RAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program FP_RAM_DBGCTRL.
 *
 */
typedef union BCM56800_A0_FP_RAM_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t fp_ram_dbgctrl[1];
	uint32_t _fp_ram_dbgctrl;
} BCM56800_A0_FP_RAM_DBGCTRLr_t;

#define BCM56800_A0_FP_RAM_DBGCTRLr_CLR(r) (r).fp_ram_dbgctrl[0] = 0
#define BCM56800_A0_FP_RAM_DBGCTRLr_SET(r,d) (r).fp_ram_dbgctrl[0] = d
#define BCM56800_A0_FP_RAM_DBGCTRLr_GET(r) (r).fp_ram_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_0f_GET(r) (((r).fp_ram_dbgctrl[0]) & 0xf)
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_0f_SET(r,f) (r).fp_ram_dbgctrl[0]=(((r).fp_ram_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_1f_GET(r) ((((r).fp_ram_dbgctrl[0]) >> 4) & 0xf)
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_1f_SET(r,f) (r).fp_ram_dbgctrl[0]=(((r).fp_ram_dbgctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_2f_GET(r) ((((r).fp_ram_dbgctrl[0]) >> 8) & 0xf)
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_2f_SET(r,f) (r).fp_ram_dbgctrl[0]=(((r).fp_ram_dbgctrl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_3f_GET(r) ((((r).fp_ram_dbgctrl[0]) >> 12) & 0xf)
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_3f_SET(r,f) (r).fp_ram_dbgctrl[0]=(((r).fp_ram_dbgctrl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_4f_GET(r) ((((r).fp_ram_dbgctrl[0]) >> 16) & 0xf)
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_4f_SET(r,f) (r).fp_ram_dbgctrl[0]=(((r).fp_ram_dbgctrl[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_5f_GET(r) ((((r).fp_ram_dbgctrl[0]) >> 20) & 0xf)
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_5f_SET(r,f) (r).fp_ram_dbgctrl[0]=(((r).fp_ram_dbgctrl[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_6f_GET(r) ((((r).fp_ram_dbgctrl[0]) >> 24) & 0xf)
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_6f_SET(r,f) (r).fp_ram_dbgctrl[0]=(((r).fp_ram_dbgctrl[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_7f_GET(r) ((((r).fp_ram_dbgctrl[0]) >> 28) & 0xf)
#define BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_7f_SET(r,f) (r).fp_ram_dbgctrl[0]=(((r).fp_ram_dbgctrl[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access FP_RAM_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_FP_RAM_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_RAM_DBGCTRLr,(r._fp_ram_dbgctrl))
#define BCM56800_A0_WRITE_FP_RAM_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_RAM_DBGCTRLr,&(r._fp_ram_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_RAM_DBGCTRLr BCM56800_A0_FP_RAM_DBGCTRLr
#define FP_RAM_DBGCTRLr_SIZE BCM56800_A0_FP_RAM_DBGCTRLr_SIZE
typedef BCM56800_A0_FP_RAM_DBGCTRLr_t FP_RAM_DBGCTRLr_t;
#define FP_RAM_DBGCTRLr_CLR BCM56800_A0_FP_RAM_DBGCTRLr_CLR
#define FP_RAM_DBGCTRLr_SET BCM56800_A0_FP_RAM_DBGCTRLr_SET
#define FP_RAM_DBGCTRLr_GET BCM56800_A0_FP_RAM_DBGCTRLr_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_0f_GET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_0f_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_0f_SET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_0f_SET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_1f_GET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_1f_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_1f_SET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_1f_SET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_2f_GET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_2f_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_2f_SET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_2f_SET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_3f_GET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_3f_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_3f_SET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_3f_SET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_4f_GET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_4f_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_4f_SET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_4f_SET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_5f_GET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_5f_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_5f_SET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_5f_SET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_6f_GET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_6f_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_6f_SET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_6f_SET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_7f_GET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_7f_GET
#define FP_RAM_DBGCTRLr_POLICYTABLE_TM_7f_SET BCM56800_A0_FP_RAM_DBGCTRLr_POLICYTABLE_TM_7f_SET
#define READ_FP_RAM_DBGCTRLr BCM56800_A0_READ_FP_RAM_DBGCTRLr
#define WRITE_FP_RAM_DBGCTRLr BCM56800_A0_WRITE_FP_RAM_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_RAM_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_RANGE_CHECK
 * BLOCKS:   IPIPE
 * DESC:     RANGE CHECK VALUES FOR FP, FeatureSpecific-FP
 * SIZE:     34
 * FIELDS:
 *     LOWER_BOUNDS     Lower bounds of range to be checked.
 *     UPPER_BOUNDS     Upper bounds of range to be checked.
 *     ENABLE           Enable range check
 *     SOURCE_DESTINATION_SELECT Selects whether the Source or Destination Port is range checked.
 *
 ******************************************************************************/
#define BCM56800_A0_FP_RANGE_CHECKm 0x0c160000

#define BCM56800_A0_FP_RANGE_CHECKm_MIN 0
#define BCM56800_A0_FP_RANGE_CHECKm_MAX 15
#define BCM56800_A0_FP_RANGE_CHECKm_CMAX(u) 15
#define BCM56800_A0_FP_RANGE_CHECKm_SIZE 5

/*
 * This structure should be used to declare and program FP_RANGE_CHECK.
 *
 */
typedef union BCM56800_A0_FP_RANGE_CHECKm_s {
	uint32_t v[2];
	uint32_t fp_range_check[2];
	uint32_t _fp_range_check;
} BCM56800_A0_FP_RANGE_CHECKm_t;

#define BCM56800_A0_FP_RANGE_CHECKm_CLR(r) CDK_MEMSET(&((r)._fp_range_check), 0, sizeof(BCM56800_A0_FP_RANGE_CHECKm_t))
#define BCM56800_A0_FP_RANGE_CHECKm_SET(r,i,d) (r).fp_range_check[i] = d
#define BCM56800_A0_FP_RANGE_CHECKm_GET(r,i) (r).fp_range_check[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_GET(r) (((r).fp_range_check[0]) & 0xffff)
#define BCM56800_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_SET(r,f) (r).fp_range_check[0]=(((r).fp_range_check[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_GET(r) ((((r).fp_range_check[0]) >> 16) & 0xffff)
#define BCM56800_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_SET(r,f) (r).fp_range_check[0]=(((r).fp_range_check[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define BCM56800_A0_FP_RANGE_CHECKm_ENABLEf_GET(r) (((r).fp_range_check[1]) & 0x1)
#define BCM56800_A0_FP_RANGE_CHECKm_ENABLEf_SET(r,f) (r).fp_range_check[1]=(((r).fp_range_check[1] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET(r) ((((r).fp_range_check[1]) >> 1) & 0x1)
#define BCM56800_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET(r,f) (r).fp_range_check[1]=(((r).fp_range_check[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access FP_RANGE_CHECK.
 *
 */
#define BCM56800_A0_READ_FP_RANGE_CHECKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_RANGE_CHECKm,i,(m._fp_range_check),2)
#define BCM56800_A0_WRITE_FP_RANGE_CHECKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_RANGE_CHECKm,i,&(m._fp_range_check),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_RANGE_CHECKm BCM56800_A0_FP_RANGE_CHECKm
#define FP_RANGE_CHECKm_MIN BCM56800_A0_FP_RANGE_CHECKm_MIN
#define FP_RANGE_CHECKm_MAX BCM56800_A0_FP_RANGE_CHECKm_MAX
#define FP_RANGE_CHECKm_CMAX(u) BCM56800_A0_FP_RANGE_CHECKm_CMAX(u)
#define FP_RANGE_CHECKm_SIZE BCM56800_A0_FP_RANGE_CHECKm_SIZE
typedef BCM56800_A0_FP_RANGE_CHECKm_t FP_RANGE_CHECKm_t;
#define FP_RANGE_CHECKm_CLR BCM56800_A0_FP_RANGE_CHECKm_CLR
#define FP_RANGE_CHECKm_SET BCM56800_A0_FP_RANGE_CHECKm_SET
#define FP_RANGE_CHECKm_GET BCM56800_A0_FP_RANGE_CHECKm_GET
#define FP_RANGE_CHECKm_LOWER_BOUNDSf_GET BCM56800_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_GET
#define FP_RANGE_CHECKm_LOWER_BOUNDSf_SET BCM56800_A0_FP_RANGE_CHECKm_LOWER_BOUNDSf_SET
#define FP_RANGE_CHECKm_UPPER_BOUNDSf_GET BCM56800_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_GET
#define FP_RANGE_CHECKm_UPPER_BOUNDSf_SET BCM56800_A0_FP_RANGE_CHECKm_UPPER_BOUNDSf_SET
#define FP_RANGE_CHECKm_ENABLEf_GET BCM56800_A0_FP_RANGE_CHECKm_ENABLEf_GET
#define FP_RANGE_CHECKm_ENABLEf_SET BCM56800_A0_FP_RANGE_CHECKm_ENABLEf_SET
#define FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET BCM56800_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_GET
#define FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET BCM56800_A0_FP_RANGE_CHECKm_SOURCE_DESTINATION_SELECTf_SET
#define READ_FP_RANGE_CHECKm BCM56800_A0_READ_FP_RANGE_CHECKm
#define WRITE_FP_RANGE_CHECKm BCM56800_A0_WRITE_FP_RANGE_CHECKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_RANGE_CHECKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_SLICE_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     FP_SLICE_CONFIG, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     SLICE_0_MODE     CONFIG FOR SLICE 0: 00=Single Wide 01=Double Wide (with SLICE 1) 10=Triple Wide (with SLICES 1 & 2)  11=N/A
 *     SLICE_1_MODE     CONFIG FOR SLICE 1: 00=Single Wide 01=Double Wide (with SLICE 0) 10=Triple Wide ( with SLICES 0 & 2 ) 11=N/A
 *     SLICE_2_MODE     CONFIG FOR SLICE 2: 00=Single Wide 01=Double Wide (with SLICE 3) 10=Triple Wide ( with SLICES 0 & 1 ) 11=N/A
 *     SLICE_3_MODE     CONFIG FOR SLICE 3: 0=Single Wide 1=Double Wide (with SLICE 2) 
 *     SLICE_4_MODE     CONFIG FOR SLICE 4: 00=Single Wide 01=Double Wide (with SLICE 5) 10=Triple Wide ( with SLICES 5 & 6 ) 11=N/A
 *     SLICE_5_MODE     CONFIG FOR SLICE 5: 00=Single Wide 01=Double Wide (with SLICE 4) 10=Triple Wide ( with SLICES 4 & 6 ) 11=N/A
 *     SLICE_6_MODE     CONFIG FOR SLICE 6: 00=Single Wide 01=Double Wide (with SLICE 7) 10=Triple Wide ( with SLICES 4 & 5 ) 11=N/A
 *     SLICE_7_MODE     CONFIG FOR SLICE 7: 0=Single Wide 1=Double Wide (with SLICE 6) 
 *
 ******************************************************************************/
#define BCM56800_A0_FP_SLICE_CONFIGr 0x0c18061e

#define BCM56800_A0_FP_SLICE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_CONFIG.
 *
 */
typedef union BCM56800_A0_FP_SLICE_CONFIGr_s {
	uint32_t v[1];
	uint32_t fp_slice_config[1];
	uint32_t _fp_slice_config;
} BCM56800_A0_FP_SLICE_CONFIGr_t;

#define BCM56800_A0_FP_SLICE_CONFIGr_CLR(r) (r).fp_slice_config[0] = 0
#define BCM56800_A0_FP_SLICE_CONFIGr_SET(r,d) (r).fp_slice_config[0] = d
#define BCM56800_A0_FP_SLICE_CONFIGr_GET(r) (r).fp_slice_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_GET(r) (((r).fp_slice_config[0]) & 0x3)
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 2) & 0x3)
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 4) & 0x3)
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 6) & 0x1)
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_4_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 7) & 0x3)
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_4_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_5_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 9) & 0x3)
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_5_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_6_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 11) & 0x3)
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_6_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_7_MODEf_GET(r) ((((r).fp_slice_config[0]) >> 13) & 0x1)
#define BCM56800_A0_FP_SLICE_CONFIGr_SLICE_7_MODEf_SET(r,f) (r).fp_slice_config[0]=(((r).fp_slice_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access FP_SLICE_CONFIG.
 *
 */
#define BCM56800_A0_READ_FP_SLICE_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_SLICE_CONFIGr,(r._fp_slice_config))
#define BCM56800_A0_WRITE_FP_SLICE_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_SLICE_CONFIGr,&(r._fp_slice_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_CONFIGr BCM56800_A0_FP_SLICE_CONFIGr
#define FP_SLICE_CONFIGr_SIZE BCM56800_A0_FP_SLICE_CONFIGr_SIZE
typedef BCM56800_A0_FP_SLICE_CONFIGr_t FP_SLICE_CONFIGr_t;
#define FP_SLICE_CONFIGr_CLR BCM56800_A0_FP_SLICE_CONFIGr_CLR
#define FP_SLICE_CONFIGr_SET BCM56800_A0_FP_SLICE_CONFIGr_SET
#define FP_SLICE_CONFIGr_GET BCM56800_A0_FP_SLICE_CONFIGr_GET
#define FP_SLICE_CONFIGr_SLICE_0_MODEf_GET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_0_MODEf_SET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_0_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_1_MODEf_GET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_1_MODEf_SET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_1_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_2_MODEf_GET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_2_MODEf_SET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_2_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_3_MODEf_GET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_3_MODEf_SET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_3_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_4_MODEf_GET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_4_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_4_MODEf_SET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_4_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_5_MODEf_GET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_5_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_5_MODEf_SET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_5_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_6_MODEf_GET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_6_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_6_MODEf_SET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_6_MODEf_SET
#define FP_SLICE_CONFIGr_SLICE_7_MODEf_GET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_7_MODEf_GET
#define FP_SLICE_CONFIGr_SLICE_7_MODEf_SET BCM56800_A0_FP_SLICE_CONFIGr_SLICE_7_MODEf_SET
#define READ_FP_SLICE_CONFIGr BCM56800_A0_READ_FP_SLICE_CONFIGr
#define WRITE_FP_SLICE_CONFIGr BCM56800_A0_WRITE_FP_SLICE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_SLICE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FP_SLICE_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     FP_SLICE_ENABLE, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     FP_SLICE_ENABLE_SLICE_0 FP_SLICE_ENABLE FOR FP SLICE 0
 *     FP_SLICE_ENABLE_SLICE_1 FP_SLICE_ENABLE FOR FP SLICE 1
 *     FP_SLICE_ENABLE_SLICE_2 FP_SLICE_ENABLE FOR FP SLICE 2
 *     FP_SLICE_ENABLE_SLICE_3 FP_SLICE_ENABLE FOR FP SLICE 3
 *     FP_SLICE_ENABLE_SLICE_4 FP_SLICE_ENABLE FOR FP SLICE 4
 *     FP_SLICE_ENABLE_SLICE_5 FP_SLICE_ENABLE FOR FP SLICE 5
 *     FP_SLICE_ENABLE_SLICE_6 FP_SLICE_ENABLE FOR FP SLICE 6
 *     FP_SLICE_ENABLE_SLICE_7 FP_SLICE_ENABLE FOR FP SLICE 7
 *     FP_LOOKUP_ENABLE_SLICE_0 LOOKUP ENABLE FOR FP SLICE 0
 *     FP_LOOKUP_ENABLE_SLICE_1 LOOKUP ENABLE FOR FP SLICE 1
 *     FP_LOOKUP_ENABLE_SLICE_2 LOOKUP ENABLE FOR FP SLICE 2
 *     FP_LOOKUP_ENABLE_SLICE_3 LOOKUP ENABLE FOR FP SLICE 3
 *     FP_LOOKUP_ENABLE_SLICE_4 LOOKUP ENABLE FOR FP SLICE 4
 *     FP_LOOKUP_ENABLE_SLICE_5 LOOKUP ENABLE FOR FP SLICE 5
 *     FP_LOOKUP_ENABLE_SLICE_6 LOOKUP ENABLE FOR FP SLICE 6
 *     FP_LOOKUP_ENABLE_SLICE_7 LOOKUP ENABLE FOR FP SLICE 7
 *
 ******************************************************************************/
#define BCM56800_A0_FP_SLICE_ENABLEr 0x0c18060b

#define BCM56800_A0_FP_SLICE_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program FP_SLICE_ENABLE.
 *
 */
typedef union BCM56800_A0_FP_SLICE_ENABLEr_s {
	uint32_t v[1];
	uint32_t fp_slice_enable[1];
	uint32_t _fp_slice_enable;
} BCM56800_A0_FP_SLICE_ENABLEr_t;

#define BCM56800_A0_FP_SLICE_ENABLEr_CLR(r) (r).fp_slice_enable[0] = 0
#define BCM56800_A0_FP_SLICE_ENABLEr_SET(r,d) (r).fp_slice_enable[0] = d
#define BCM56800_A0_FP_SLICE_ENABLEr_GET(r) (r).fp_slice_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET(r) (((r).fp_slice_enable[0]) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 1) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 2) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 3) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_GET(r) ((((r).fp_slice_enable[0]) >> 4) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_GET(r) ((((r).fp_slice_enable[0]) >> 5) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_GET(r) ((((r).fp_slice_enable[0]) >> 6) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_GET(r) ((((r).fp_slice_enable[0]) >> 7) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET(r) ((((r).fp_slice_enable[0]) >> 8) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET(r) ((((r).fp_slice_enable[0]) >> 9) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET(r) ((((r).fp_slice_enable[0]) >> 10) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET(r) ((((r).fp_slice_enable[0]) >> 11) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_GET(r) ((((r).fp_slice_enable[0]) >> 12) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_GET(r) ((((r).fp_slice_enable[0]) >> 13) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_GET(r) ((((r).fp_slice_enable[0]) >> 14) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_GET(r) ((((r).fp_slice_enable[0]) >> 15) & 0x1)
#define BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_SET(r,f) (r).fp_slice_enable[0]=(((r).fp_slice_enable[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_SLICE_ENABLE.
 *
 */
#define BCM56800_A0_READ_FP_SLICE_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FP_SLICE_ENABLEr,(r._fp_slice_enable))
#define BCM56800_A0_WRITE_FP_SLICE_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FP_SLICE_ENABLEr,&(r._fp_slice_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_SLICE_ENABLEr BCM56800_A0_FP_SLICE_ENABLEr
#define FP_SLICE_ENABLEr_SIZE BCM56800_A0_FP_SLICE_ENABLEr_SIZE
typedef BCM56800_A0_FP_SLICE_ENABLEr_t FP_SLICE_ENABLEr_t;
#define FP_SLICE_ENABLEr_CLR BCM56800_A0_FP_SLICE_ENABLEr_CLR
#define FP_SLICE_ENABLEr_SET BCM56800_A0_FP_SLICE_ENABLEr_SET
#define FP_SLICE_ENABLEr_GET BCM56800_A0_FP_SLICE_ENABLEr_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_0f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_1f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_2f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_3f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_4f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_5f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_6f_SET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_GET
#define FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_SLICE_ENABLE_SLICE_7f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_0f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_1f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_2f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_3f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_4f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_5f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_6f_SET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_GET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_GET
#define FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_SET BCM56800_A0_FP_SLICE_ENABLEr_FP_LOOKUP_ENABLE_SLICE_7f_SET
#define READ_FP_SLICE_ENABLEr BCM56800_A0_READ_FP_SLICE_ENABLEr
#define WRITE_FP_SLICE_ENABLEr BCM56800_A0_WRITE_FP_SLICE_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_SLICE_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_TCAM
 * BLOCKS:   IPIPE
 * DESC:     TCAM FOR FP, FeatureSpecific-FP
 * SIZE:     374
 * FIELDS:
 *     VALID            VALID BIT
 *     PKT_TYPE         Indicates if the packet is a HIGIG (1) or non HIGIG (0) packet
 *     F4               F4 field
 *     IPBM_SEL         Used to indicate the Input Port Bitmap (IPBM) is applied to the TCAM
 *     F3               F3 field
 *     F2               F2 field
 *     F1               F1 field
 *     PKT_TYPE_MASK    PKT TYPE MASK
 *     F4_MASK          F4 field MASK
 *     IPBM_SEL_MASK    Used to indicate the Input Port Bitmap (IPBM) is applied to the TCAM MASK
 *     F3_MASK          F3 field MASK
 *     F2_MASK          F2 field MASK
 *     F1_MASK          F1 field MASK
 *     SOURCE_PORT_NUMBER SOURCE_PORT_NUMBER
 *     SOURCE_PORT_NUMBER_MASK SOURCE_PORT_NUMBER MASK
 *
 ******************************************************************************/
#define BCM56800_A0_FP_TCAMm 0x0c162000

#define BCM56800_A0_FP_TCAMm_MIN 0
#define BCM56800_A0_FP_TCAMm_MAX 1023
#define BCM56800_A0_FP_TCAMm_CMAX(u) 1023
#define BCM56800_A0_FP_TCAMm_SIZE 47

/*
 * This structure should be used to declare and program FP_TCAM.
 *
 */
typedef union BCM56800_A0_FP_TCAMm_s {
	uint32_t v[12];
	uint32_t fp_tcam[12];
	uint32_t _fp_tcam;
} BCM56800_A0_FP_TCAMm_t;

#define BCM56800_A0_FP_TCAMm_CLR(r) CDK_MEMSET(&((r)._fp_tcam), 0, sizeof(BCM56800_A0_FP_TCAMm_t))
#define BCM56800_A0_FP_TCAMm_SET(r,i,d) (r).fp_tcam[i] = d
#define BCM56800_A0_FP_TCAMm_GET(r,i) (r).fp_tcam[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_TCAMm_VALIDf_GET(r) (((r).fp_tcam[0]) & 0x3)
#define BCM56800_A0_FP_TCAMm_VALIDf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_FP_TCAMm_PKT_TYPEf_GET(r) ((((r).fp_tcam[0]) >> 2) & 0x1)
#define BCM56800_A0_FP_TCAMm_PKT_TYPEf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_FP_TCAMm_F4f_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x7f)
#define BCM56800_A0_FP_TCAMm_F4f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56800_A0_FP_TCAMm_IPBM_SELf_GET(r) ((((r).fp_tcam[0]) >> 10) & 0x1)
#define BCM56800_A0_FP_TCAMm_IPBM_SELf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_FP_TCAMm_F3f_GET(r) ((((r).fp_tcam[0]) >> 11) & 0x1ffff)
#define BCM56800_A0_FP_TCAMm_F3f_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x1ffff << 11)) | ((((uint32_t)f) & 0x1ffff) << 11))
#define BCM56800_A0_FP_TCAMm_F2f_GET(r,a) cdk_field_get((r).fp_tcam,28,155,a)
#define BCM56800_A0_FP_TCAMm_F2f_SET(r,a) cdk_field_set((r).fp_tcam,28,155,a)
#define BCM56800_A0_FP_TCAMm_F1f_GET(r) cdk_field32_get((r).fp_tcam,156,187)
#define BCM56800_A0_FP_TCAMm_F1f_SET(r,f) cdk_field32_set((r).fp_tcam,156,187,f)
#define BCM56800_A0_FP_TCAMm_PKT_TYPE_MASKf_GET(r) ((((r).fp_tcam[5]) >> 28) & 0x1)
#define BCM56800_A0_FP_TCAMm_PKT_TYPE_MASKf_SET(r,f) (r).fp_tcam[5]=(((r).fp_tcam[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_FP_TCAMm_F4_MASKf_GET(r) cdk_field32_get((r).fp_tcam,189,195)
#define BCM56800_A0_FP_TCAMm_F4_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,189,195,f)
#define BCM56800_A0_FP_TCAMm_IPBM_SEL_MASKf_GET(r) ((((r).fp_tcam[6]) >> 4) & 0x1)
#define BCM56800_A0_FP_TCAMm_IPBM_SEL_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_FP_TCAMm_F3_MASKf_GET(r) ((((r).fp_tcam[6]) >> 5) & 0x1ffff)
#define BCM56800_A0_FP_TCAMm_F3_MASKf_SET(r,f) (r).fp_tcam[6]=(((r).fp_tcam[6] & ~((uint32_t)0x1ffff << 5)) | ((((uint32_t)f) & 0x1ffff) << 5))
#define BCM56800_A0_FP_TCAMm_F2_MASKf_GET(r,a) cdk_field_get((r).fp_tcam,214,341,a)
#define BCM56800_A0_FP_TCAMm_F2_MASKf_SET(r,a) cdk_field_set((r).fp_tcam,214,341,a)
#define BCM56800_A0_FP_TCAMm_F1_MASKf_GET(r) cdk_field32_get((r).fp_tcam,342,373)
#define BCM56800_A0_FP_TCAMm_F1_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,342,373,f)
#define BCM56800_A0_FP_TCAMm_SOURCE_PORT_NUMBERf_GET(r) ((((r).fp_tcam[0]) >> 3) & 0x7f)
#define BCM56800_A0_FP_TCAMm_SOURCE_PORT_NUMBERf_SET(r,f) (r).fp_tcam[0]=(((r).fp_tcam[0] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56800_A0_FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_GET(r) cdk_field32_get((r).fp_tcam,189,195)
#define BCM56800_A0_FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam,189,195,f)

/*
 * These macros can be used to access FP_TCAM.
 *
 */
#define BCM56800_A0_READ_FP_TCAMm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_TCAMm,i,(m._fp_tcam),12)
#define BCM56800_A0_WRITE_FP_TCAMm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_TCAMm,i,&(m._fp_tcam),12)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_TCAMm BCM56800_A0_FP_TCAMm
#define FP_TCAMm_MIN BCM56800_A0_FP_TCAMm_MIN
#define FP_TCAMm_MAX BCM56800_A0_FP_TCAMm_MAX
#define FP_TCAMm_CMAX(u) BCM56800_A0_FP_TCAMm_CMAX(u)
#define FP_TCAMm_SIZE BCM56800_A0_FP_TCAMm_SIZE
typedef BCM56800_A0_FP_TCAMm_t FP_TCAMm_t;
#define FP_TCAMm_CLR BCM56800_A0_FP_TCAMm_CLR
#define FP_TCAMm_SET BCM56800_A0_FP_TCAMm_SET
#define FP_TCAMm_GET BCM56800_A0_FP_TCAMm_GET
#define FP_TCAMm_VALIDf_GET BCM56800_A0_FP_TCAMm_VALIDf_GET
#define FP_TCAMm_VALIDf_SET BCM56800_A0_FP_TCAMm_VALIDf_SET
#define FP_TCAMm_PKT_TYPEf_GET BCM56800_A0_FP_TCAMm_PKT_TYPEf_GET
#define FP_TCAMm_PKT_TYPEf_SET BCM56800_A0_FP_TCAMm_PKT_TYPEf_SET
#define FP_TCAMm_F4f_GET BCM56800_A0_FP_TCAMm_F4f_GET
#define FP_TCAMm_F4f_SET BCM56800_A0_FP_TCAMm_F4f_SET
#define FP_TCAMm_IPBM_SELf_GET BCM56800_A0_FP_TCAMm_IPBM_SELf_GET
#define FP_TCAMm_IPBM_SELf_SET BCM56800_A0_FP_TCAMm_IPBM_SELf_SET
#define FP_TCAMm_F3f_GET BCM56800_A0_FP_TCAMm_F3f_GET
#define FP_TCAMm_F3f_SET BCM56800_A0_FP_TCAMm_F3f_SET
#define FP_TCAMm_F2f_GET BCM56800_A0_FP_TCAMm_F2f_GET
#define FP_TCAMm_F2f_SET BCM56800_A0_FP_TCAMm_F2f_SET
#define FP_TCAMm_F1f_GET BCM56800_A0_FP_TCAMm_F1f_GET
#define FP_TCAMm_F1f_SET BCM56800_A0_FP_TCAMm_F1f_SET
#define FP_TCAMm_PKT_TYPE_MASKf_GET BCM56800_A0_FP_TCAMm_PKT_TYPE_MASKf_GET
#define FP_TCAMm_PKT_TYPE_MASKf_SET BCM56800_A0_FP_TCAMm_PKT_TYPE_MASKf_SET
#define FP_TCAMm_F4_MASKf_GET BCM56800_A0_FP_TCAMm_F4_MASKf_GET
#define FP_TCAMm_F4_MASKf_SET BCM56800_A0_FP_TCAMm_F4_MASKf_SET
#define FP_TCAMm_IPBM_SEL_MASKf_GET BCM56800_A0_FP_TCAMm_IPBM_SEL_MASKf_GET
#define FP_TCAMm_IPBM_SEL_MASKf_SET BCM56800_A0_FP_TCAMm_IPBM_SEL_MASKf_SET
#define FP_TCAMm_F3_MASKf_GET BCM56800_A0_FP_TCAMm_F3_MASKf_GET
#define FP_TCAMm_F3_MASKf_SET BCM56800_A0_FP_TCAMm_F3_MASKf_SET
#define FP_TCAMm_F2_MASKf_GET BCM56800_A0_FP_TCAMm_F2_MASKf_GET
#define FP_TCAMm_F2_MASKf_SET BCM56800_A0_FP_TCAMm_F2_MASKf_SET
#define FP_TCAMm_F1_MASKf_GET BCM56800_A0_FP_TCAMm_F1_MASKf_GET
#define FP_TCAMm_F1_MASKf_SET BCM56800_A0_FP_TCAMm_F1_MASKf_SET
#define FP_TCAMm_SOURCE_PORT_NUMBERf_GET BCM56800_A0_FP_TCAMm_SOURCE_PORT_NUMBERf_GET
#define FP_TCAMm_SOURCE_PORT_NUMBERf_SET BCM56800_A0_FP_TCAMm_SOURCE_PORT_NUMBERf_SET
#define FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_GET BCM56800_A0_FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_GET
#define FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_SET BCM56800_A0_FP_TCAMm_SOURCE_PORT_NUMBER_MASKf_SET
#define READ_FP_TCAMm BCM56800_A0_READ_FP_TCAMm
#define WRITE_FP_TCAMm BCM56800_A0_WRITE_FP_TCAMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_TCAMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_TCAM_PLUS_POLICY
 * BLOCKS:   IPIPE
 * DESC:     TCAM AND POLICY TABLE VIEW FOR FP, FeatureSpecific-FP
 * SIZE:     509
 * FIELDS:
 *     VALID            VALID BIT
 *     PKT_TYPE         Indicates if the packet is a HIGIG (1) or non HIGIG (0) packet
 *     F4               F4 field
 *     IPBM_SEL         Used to indicate the Input Port Bitmap (IPBM) is applied to the TCAM
 *     F3               F3 field
 *     F2               F2 field
 *     F1               F1 field
 *     PKT_TYPE_MASK    PKT TYPE MASK
 *     F4_MASK          F4 field MASK
 *     IPBM_SEL_MASK    Used to indicate the Input Port Bitmap (IPBM) is applied to the TCAM MASK
 *     F3_MASK          F3 field MASK
 *     F2_MASK          F2 field MASK
 *     F1_MASK          F1 field MASK
 *     EM_MTP_INDEX     EM_MTP_INDEX
 *     IM_MTP_INDEX     IM_MTP_INDEX
 *     MTP_INDEX_SPARE  MTP_INDEX_SPARE
 *     CHAIN_INDEX      CHAIN_INDEX
 *     CHAIN_VALID      CHAIN_VALID
 *     ECMP_PTR         ECMP_PTR
 *     ECMP_COUNT       ECMP_COUNT
 *     ECMP             ECMP
 *     DO_NOT_CHANGE_TTL DO NOT CHANGE TTL for L3 sourted pkts
 *     YP_DSCP          YP_DSCP
 *     RP_DSCP          RP_DSCP
 *     NEWDSCP_TOS      NEWDSCP_TOS
 *     NEWPRI           NEWPRI
 *     METER_PAIR_MODE  METER_PAIR_MODE
 *     METER_TEST_EVEN  METER_TEST_EVEN
 *     METER_TEST_ODD   METER_TEST_ODD
 *     METER_UPDATE_EVEN METER_UPDATE_EVEN
 *     METER_UPDATE_ODD METER_UPDATE_ODD
 *     METER_INDEX_EVEN METER_INDEX_EVEN
 *     METER_INDEX_ODD  METER_INDEX_ODD
 *     COUNTER_MODE     COUNTER_MODE
 *     COUNTER_INDEX    COUNTER_INDEX
 *     YP_CHANGE_DSCP   YP_CHANGE_DSCP
 *     YP_COPY_TO_CPU   YP_COPY_TO_CPU
 *     YP_DROP_PRECEDENCE YP_DROP_PRECEDENCE
 *     YP_DROP          YP_DROP
 *     RP_CHANGE_DSCP   RP_CHANGE_DSCP
 *     RP_COPY_TO_CPU   RP_COPY_TO_CPU
 *     RP_DROP_PRECEDENCE RP_DROP_PRECEDENCE
 *     RP_DROP          RP_DROP
 *     DROP_PRECEDENCE  DROP_PRECEDENCE
 *     L3SW_CHANGE_MACDA_OR_VLAN L3SW_CHANGE_MACDA_OR_VLAN
 *     MIRROR           MIRROR
 *     MIRROR_OVERRIDE  CONTROLS OVERRIDING MIRROR PROCESSING IN SW2 STAGE
 *     DROP             DROP
 *     CHAIN            CHAIN
 *     PACKET_REDIRECTION PACKET_REDIRECTION
 *     COPY_TO_CPU      COPY_TO_CPU
 *     CHANGE_DSCP_TOS  CHANGE_DSCP_TOS
 *     CHANGE_PRIORITY  CHANGE_PRIORITY
 *     ECN_CNG          CONTROL WHETHER DROP PRECEDENCE SETS ECN OR CNG BITS
 *     GREEN_TO_PID     GREEN_TO_PID CONTROLS WHETHER PACKET_REDIRECTION and L3SW_CHANGE_MACDA_OR_VLAN  are Green (0) or Color Independent (1) actions
 *     SOURCE_PORT_NUMBER SOURCE_PORT_NUMBER
 *     SOURCE_PORT_NUMBER_MASK SOURCE_PORT_NUMBER MASK
 *     REDIRECTION      REDIRECTION
 *     NEXT_HOP_INDEX   NEXT_HOP_INDEX
 *     CLASSIFICATION_TAG CLASSIFICATION_TAG
 *     MATCHED_RULE     MATCHED_RULE
 *
 ******************************************************************************/
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm 0x0c164000

#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIN 0
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MAX 1023
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CMAX(u) 1023
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_SIZE 64

/*
 * This structure should be used to declare and program FP_TCAM_PLUS_POLICY.
 *
 */
typedef union BCM56800_A0_FP_TCAM_PLUS_POLICYm_s {
	uint32_t v[16];
	uint32_t fp_tcam_plus_policy[16];
	uint32_t _fp_tcam_plus_policy;
} BCM56800_A0_FP_TCAM_PLUS_POLICYm_t;

#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CLR(r) CDK_MEMSET(&((r)._fp_tcam_plus_policy), 0, sizeof(BCM56800_A0_FP_TCAM_PLUS_POLICYm_t))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_SET(r,i,d) (r).fp_tcam_plus_policy[i] = d
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_GET(r,i) (r).fp_tcam_plus_policy[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_VALIDf_GET(r) (((r).fp_tcam_plus_policy[0]) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_VALIDf_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPEf_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 2) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPEf_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F4f_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 3) & 0x7f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F4f_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_IPBM_SELf_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 10) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_IPBM_SELf_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F3f_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 11) & 0x1ffff)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F3f_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x1ffff << 11)) | ((((uint32_t)f) & 0x1ffff) << 11))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F2f_GET(r,a) cdk_field_get((r).fp_tcam_plus_policy,28,155,a)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F2f_SET(r,a) cdk_field_set((r).fp_tcam_plus_policy,28,155,a)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F1f_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,156,187)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F1f_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,156,187,f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_GET(r) ((((r).fp_tcam_plus_policy[5]) >> 28) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_SET(r,f) (r).fp_tcam_plus_policy[5]=(((r).fp_tcam_plus_policy[5] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F4_MASKf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,189,195)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F4_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,189,195,f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_GET(r) ((((r).fp_tcam_plus_policy[6]) >> 4) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_SET(r,f) (r).fp_tcam_plus_policy[6]=(((r).fp_tcam_plus_policy[6] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F3_MASKf_GET(r) ((((r).fp_tcam_plus_policy[6]) >> 5) & 0x1ffff)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F3_MASKf_SET(r,f) (r).fp_tcam_plus_policy[6]=(((r).fp_tcam_plus_policy[6] & ~((uint32_t)0x1ffff << 5)) | ((((uint32_t)f) & 0x1ffff) << 5))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F2_MASKf_GET(r,a) cdk_field_get((r).fp_tcam_plus_policy,214,341,a)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F2_MASKf_SET(r,a) cdk_field_set((r).fp_tcam_plus_policy,214,341,a)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F1_MASKf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,342,373)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_F1_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,342,373,f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[11]) >> 22) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[11]=(((r).fp_tcam_plus_policy[11] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[11]) >> 24) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[11]=(((r).fp_tcam_plus_policy[11] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_GET(r) ((((r).fp_tcam_plus_policy[11]) >> 26) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_SET(r,f) (r).fp_tcam_plus_policy[11]=(((r).fp_tcam_plus_policy[11] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[12]) >> 8) & 0x7f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[12]=(((r).fp_tcam_plus_policy[12] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_GET(r) ((((r).fp_tcam_plus_policy[12]) >> 15) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_SET(r,f) (r).fp_tcam_plus_policy[12]=(((r).fp_tcam_plus_policy[12] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMP_PTRf_GET(r) ((((r).fp_tcam_plus_policy[12]) >> 16) & 0x7ff)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMP_PTRf_SET(r,f) (r).fp_tcam_plus_policy[12]=(((r).fp_tcam_plus_policy[12] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_GET(r) ((((r).fp_tcam_plus_policy[12]) >> 27) & 0x1f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_SET(r,f) (r).fp_tcam_plus_policy[12]=(((r).fp_tcam_plus_policy[12] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMPf_GET(r) (((r).fp_tcam_plus_policy[13]) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMPf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_DO_NOT_CHANGE_TTLf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 2) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_DO_NOT_CHANGE_TTLf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DSCPf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 3) & 0x3f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DSCPf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DSCPf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 9) & 0x3f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DSCPf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 15) & 0x3f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x3f << 15)) | ((((uint32_t)f) & 0x3f) << 15))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEWPRIf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 21) & 0xf)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEWPRIf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0xf << 21)) | ((((uint32_t)f) & 0xf) << 21))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 25) & 0x7)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 28) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 29) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 30) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_GET(r) ((((r).fp_tcam_plus_policy[13]) >> 31) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_SET(r,f) (r).fp_tcam_plus_policy[13]=(((r).fp_tcam_plus_policy[13] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_GET(r) (((r).fp_tcam_plus_policy[14]) & 0x3f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 6) & 0x3f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 12) & 0xf)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 16) & 0x3f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3f << 16)) | ((((uint32_t)f) & 0x3f) << 16))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 22) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 23) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3 << 23)) | ((((uint32_t)f) & 0x3) << 23))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 25) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3 << 25)) | ((((uint32_t)f) & 0x3) << 25))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DROPf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 27) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DROPf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3 << 27)) | ((((uint32_t)f) & 0x3) << 27))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 29) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_GET(r) ((((r).fp_tcam_plus_policy[14]) >> 30) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_SET(r,f) (r).fp_tcam_plus_policy[14]=(((r).fp_tcam_plus_policy[14] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_GET(r) (((r).fp_tcam_plus_policy[15]) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DROPf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 2) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DROPf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 4) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 6) & 0x7)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIRRORf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 9) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIRRORf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIRROR_OVERRIDEf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 11) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIRROR_OVERRIDEf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_DROPf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 12) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_DROPf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAINf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 14) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAINf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 15) & 0x7)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 18) & 0x3)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 20) & 0x7)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x7 << 20)) | ((((uint32_t)f) & 0x7) << 20))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 23) & 0xf)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0xf << 23)) | ((((uint32_t)f) & 0xf) << 23))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECN_CNGf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 27) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECN_CNGf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_GREEN_TO_PIDf_GET(r) ((((r).fp_tcam_plus_policy[15]) >> 28) & 0x1)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_GREEN_TO_PIDf_SET(r,f) (r).fp_tcam_plus_policy[15]=(((r).fp_tcam_plus_policy[15] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_GET(r) ((((r).fp_tcam_plus_policy[0]) >> 3) & 0x7f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_SET(r,f) (r).fp_tcam_plus_policy[0]=(((r).fp_tcam_plus_policy[0] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,189,195)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,189,195,f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_REDIRECTIONf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,379,399)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_REDIRECTIONf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,379,399,f)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_GET(r) ((((r).fp_tcam_plus_policy[12]) >> 16) & 0x1fff)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_SET(r,f) (r).fp_tcam_plus_policy[12]=(((r).fp_tcam_plus_policy[12] & ~((uint32_t)0x1fff << 16)) | ((((uint32_t)f) & 0x1fff) << 16))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_GET(r) ((((r).fp_tcam_plus_policy[12]) >> 16) & 0x7ff)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_SET(r,f) (r).fp_tcam_plus_policy[12]=(((r).fp_tcam_plus_policy[12] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_GET(r) cdk_field32_get((r).fp_tcam_plus_policy,411,418)
#define BCM56800_A0_FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_SET(r,f) cdk_field32_set((r).fp_tcam_plus_policy,411,418,f)

/*
 * These macros can be used to access FP_TCAM_PLUS_POLICY.
 *
 */
#define BCM56800_A0_READ_FP_TCAM_PLUS_POLICYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_TCAM_PLUS_POLICYm,i,(m._fp_tcam_plus_policy),16)
#define BCM56800_A0_WRITE_FP_TCAM_PLUS_POLICYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_TCAM_PLUS_POLICYm,i,&(m._fp_tcam_plus_policy),16)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_TCAM_PLUS_POLICYm BCM56800_A0_FP_TCAM_PLUS_POLICYm
#define FP_TCAM_PLUS_POLICYm_MIN BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIN
#define FP_TCAM_PLUS_POLICYm_MAX BCM56800_A0_FP_TCAM_PLUS_POLICYm_MAX
#define FP_TCAM_PLUS_POLICYm_CMAX(u) BCM56800_A0_FP_TCAM_PLUS_POLICYm_CMAX(u)
#define FP_TCAM_PLUS_POLICYm_SIZE BCM56800_A0_FP_TCAM_PLUS_POLICYm_SIZE
typedef BCM56800_A0_FP_TCAM_PLUS_POLICYm_t FP_TCAM_PLUS_POLICYm_t;
#define FP_TCAM_PLUS_POLICYm_CLR BCM56800_A0_FP_TCAM_PLUS_POLICYm_CLR
#define FP_TCAM_PLUS_POLICYm_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_SET
#define FP_TCAM_PLUS_POLICYm_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_GET
#define FP_TCAM_PLUS_POLICYm_VALIDf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_VALIDf_GET
#define FP_TCAM_PLUS_POLICYm_VALIDf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_VALIDf_SET
#define FP_TCAM_PLUS_POLICYm_PKT_TYPEf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPEf_GET
#define FP_TCAM_PLUS_POLICYm_PKT_TYPEf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPEf_SET
#define FP_TCAM_PLUS_POLICYm_F4f_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F4f_GET
#define FP_TCAM_PLUS_POLICYm_F4f_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F4f_SET
#define FP_TCAM_PLUS_POLICYm_IPBM_SELf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_IPBM_SELf_GET
#define FP_TCAM_PLUS_POLICYm_IPBM_SELf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_IPBM_SELf_SET
#define FP_TCAM_PLUS_POLICYm_F3f_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F3f_GET
#define FP_TCAM_PLUS_POLICYm_F3f_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F3f_SET
#define FP_TCAM_PLUS_POLICYm_F2f_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F2f_GET
#define FP_TCAM_PLUS_POLICYm_F2f_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F2f_SET
#define FP_TCAM_PLUS_POLICYm_F1f_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F1f_GET
#define FP_TCAM_PLUS_POLICYm_F1f_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F1f_SET
#define FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_PKT_TYPE_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_F4_MASKf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F4_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_F4_MASKf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F4_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_IPBM_SEL_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_F3_MASKf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F3_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_F3_MASKf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F3_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_F2_MASKf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F2_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_F2_MASKf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F2_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_F1_MASKf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F1_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_F1_MASKf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_F1_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_EM_MTP_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_IM_MTP_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_GET
#define FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_MTP_INDEX_SPAREf_SET
#define FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAIN_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_GET
#define FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAIN_VALIDf_SET
#define FP_TCAM_PLUS_POLICYm_ECMP_PTRf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMP_PTRf_GET
#define FP_TCAM_PLUS_POLICYm_ECMP_PTRf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMP_PTRf_SET
#define FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_GET
#define FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMP_COUNTf_SET
#define FP_TCAM_PLUS_POLICYm_ECMPf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMPf_GET
#define FP_TCAM_PLUS_POLICYm_ECMPf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECMPf_SET
#define FP_TCAM_PLUS_POLICYm_DO_NOT_CHANGE_TTLf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_DO_NOT_CHANGE_TTLf_GET
#define FP_TCAM_PLUS_POLICYm_DO_NOT_CHANGE_TTLf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_DO_NOT_CHANGE_TTLf_SET
#define FP_TCAM_PLUS_POLICYm_YP_DSCPf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DSCPf_GET
#define FP_TCAM_PLUS_POLICYm_YP_DSCPf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DSCPf_SET
#define FP_TCAM_PLUS_POLICYm_RP_DSCPf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DSCPf_GET
#define FP_TCAM_PLUS_POLICYm_RP_DSCPf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DSCPf_SET
#define FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_GET
#define FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEWDSCP_TOSf_SET
#define FP_TCAM_PLUS_POLICYm_NEWPRIf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEWPRIf_GET
#define FP_TCAM_PLUS_POLICYm_NEWPRIf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEWPRIf_SET
#define FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_GET
#define FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_PAIR_MODEf_SET
#define FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_GET
#define FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_EVENf_SET
#define FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_GET
#define FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_TEST_ODDf_SET
#define FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_GET
#define FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_EVENf_SET
#define FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_GET
#define FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_UPDATE_ODDf_SET
#define FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_GET
#define FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_EVENf_SET
#define FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_GET
#define FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_METER_INDEX_ODDf_SET
#define FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_GET
#define FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_COUNTER_MODEf_SET
#define FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_COUNTER_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_GET
#define FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_CHANGE_DSCPf_SET
#define FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_GET
#define FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_COPY_TO_CPUf_SET
#define FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_GET
#define FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DROP_PRECEDENCEf_SET
#define FP_TCAM_PLUS_POLICYm_YP_DROPf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DROPf_GET
#define FP_TCAM_PLUS_POLICYm_YP_DROPf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_YP_DROPf_SET
#define FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_GET
#define FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_CHANGE_DSCPf_SET
#define FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_GET
#define FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_COPY_TO_CPUf_SET
#define FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_GET
#define FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DROP_PRECEDENCEf_SET
#define FP_TCAM_PLUS_POLICYm_RP_DROPf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DROPf_GET
#define FP_TCAM_PLUS_POLICYm_RP_DROPf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_RP_DROPf_SET
#define FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_GET
#define FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_DROP_PRECEDENCEf_SET
#define FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_GET
#define FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_L3SW_CHANGE_MACDA_OR_VLANf_SET
#define FP_TCAM_PLUS_POLICYm_MIRRORf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIRRORf_GET
#define FP_TCAM_PLUS_POLICYm_MIRRORf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIRRORf_SET
#define FP_TCAM_PLUS_POLICYm_MIRROR_OVERRIDEf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIRROR_OVERRIDEf_GET
#define FP_TCAM_PLUS_POLICYm_MIRROR_OVERRIDEf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_MIRROR_OVERRIDEf_SET
#define FP_TCAM_PLUS_POLICYm_DROPf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_DROPf_GET
#define FP_TCAM_PLUS_POLICYm_DROPf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_DROPf_SET
#define FP_TCAM_PLUS_POLICYm_CHAINf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAINf_GET
#define FP_TCAM_PLUS_POLICYm_CHAINf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHAINf_SET
#define FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_GET
#define FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_PACKET_REDIRECTIONf_SET
#define FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_GET
#define FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_COPY_TO_CPUf_SET
#define FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_GET
#define FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHANGE_DSCP_TOSf_SET
#define FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_GET
#define FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CHANGE_PRIORITYf_SET
#define FP_TCAM_PLUS_POLICYm_ECN_CNGf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECN_CNGf_GET
#define FP_TCAM_PLUS_POLICYm_ECN_CNGf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_ECN_CNGf_SET
#define FP_TCAM_PLUS_POLICYm_GREEN_TO_PIDf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_GREEN_TO_PIDf_GET
#define FP_TCAM_PLUS_POLICYm_GREEN_TO_PIDf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_GREEN_TO_PIDf_SET
#define FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_GET
#define FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBERf_SET
#define FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_GET
#define FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_SOURCE_PORT_NUMBER_MASKf_SET
#define FP_TCAM_PLUS_POLICYm_REDIRECTIONf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_REDIRECTIONf_GET
#define FP_TCAM_PLUS_POLICYm_REDIRECTIONf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_REDIRECTIONf_SET
#define FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_GET
#define FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_NEXT_HOP_INDEXf_SET
#define FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_GET
#define FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_CLASSIFICATION_TAGf_SET
#define FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_GET BCM56800_A0_FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_GET
#define FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_SET BCM56800_A0_FP_TCAM_PLUS_POLICYm_MATCHED_RULEf_SET
#define READ_FP_TCAM_PLUS_POLICYm BCM56800_A0_READ_FP_TCAM_PLUS_POLICYm
#define WRITE_FP_TCAM_PLUS_POLICYm BCM56800_A0_WRITE_FP_TCAM_PLUS_POLICYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_TCAM_PLUS_POLICYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  FP_UDF_OFFSET
 * BLOCKS:   IPIPE
 * DESC:     FP UDF offset table, FeatureSpecific-FP
 * SIZE:     48
 * FIELDS:
 *     UDF1_OFFSET0     Offset value for UDF1.0
 *     UDF1_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET1     Offset value for UDF1.1
 *     UDF1_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET2     Offset value for UDF1.2
 *     UDF1_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF1_OFFSET3     Offset value for UDF1.3
 *     UDF1_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET0     Offset value for UDF2.0
 *     UDF2_ADD_IPV4_OPTIONS0 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET1     Offset value for UDF2.1
 *     UDF2_ADD_IPV4_OPTIONS1 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET2     Offset value for UDF2.2
 *     UDF2_ADD_IPV4_OPTIONS2 Control bit to enable adding the IPv4 header option length
 *     UDF2_OFFSET3     Offset value for UDF2.3
 *     UDF2_ADD_IPV4_OPTIONS3 Control bit to enable adding the IPv4 header option length
 *
 ******************************************************************************/
#define BCM56800_A0_FP_UDF_OFFSETm 0x02162000

#define BCM56800_A0_FP_UDF_OFFSETm_MIN 0
#define BCM56800_A0_FP_UDF_OFFSETm_MAX 95
#define BCM56800_A0_FP_UDF_OFFSETm_CMAX(u) 95
#define BCM56800_A0_FP_UDF_OFFSETm_SIZE 6

/*
 * This structure should be used to declare and program FP_UDF_OFFSET.
 *
 */
typedef union BCM56800_A0_FP_UDF_OFFSETm_s {
	uint32_t v[2];
	uint32_t fp_udf_offset[2];
	uint32_t _fp_udf_offset;
} BCM56800_A0_FP_UDF_OFFSETm_t;

#define BCM56800_A0_FP_UDF_OFFSETm_CLR(r) CDK_MEMSET(&((r)._fp_udf_offset), 0, sizeof(BCM56800_A0_FP_UDF_OFFSETm_t))
#define BCM56800_A0_FP_UDF_OFFSETm_SET(r,i,d) (r).fp_udf_offset[i] = d
#define BCM56800_A0_FP_UDF_OFFSETm_GET(r,i) (r).fp_udf_offset[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_GET(r) (((r).fp_udf_offset[0]) & 0x1f)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 5) & 0x1)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_GET(r) ((((r).fp_udf_offset[0]) >> 6) & 0x1f)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[0]) >> 11) & 0x1)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_GET(r) ((((r).fp_udf_offset[0]) >> 12) & 0x1f)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[0]) >> 17) & 0x1)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_GET(r) ((((r).fp_udf_offset[0]) >> 18) & 0x1f)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[0]) >> 23) & 0x1)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_GET(r) ((((r).fp_udf_offset[0]) >> 24) & 0x1f)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET(r) ((((r).fp_udf_offset[0]) >> 29) & 0x1)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET(r,f) (r).fp_udf_offset[0]=(((r).fp_udf_offset[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_GET(r) cdk_field32_get((r).fp_udf_offset,30,34)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_SET(r,f) cdk_field32_set((r).fp_udf_offset,30,34,f)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET(r) ((((r).fp_udf_offset[1]) >> 3) & 0x1)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_GET(r) ((((r).fp_udf_offset[1]) >> 4) & 0x1f)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET(r) ((((r).fp_udf_offset[1]) >> 9) & 0x1)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_GET(r) ((((r).fp_udf_offset[1]) >> 10) & 0x1f)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET(r) ((((r).fp_udf_offset[1]) >> 15) & 0x1)
#define BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET(r,f) (r).fp_udf_offset[1]=(((r).fp_udf_offset[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FP_UDF_OFFSET.
 *
 */
#define BCM56800_A0_READ_FP_UDF_OFFSETm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_FP_UDF_OFFSETm,i,(m._fp_udf_offset),2)
#define BCM56800_A0_WRITE_FP_UDF_OFFSETm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_FP_UDF_OFFSETm,i,&(m._fp_udf_offset),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FP_UDF_OFFSETm BCM56800_A0_FP_UDF_OFFSETm
#define FP_UDF_OFFSETm_MIN BCM56800_A0_FP_UDF_OFFSETm_MIN
#define FP_UDF_OFFSETm_MAX BCM56800_A0_FP_UDF_OFFSETm_MAX
#define FP_UDF_OFFSETm_CMAX(u) BCM56800_A0_FP_UDF_OFFSETm_CMAX(u)
#define FP_UDF_OFFSETm_SIZE BCM56800_A0_FP_UDF_OFFSETm_SIZE
typedef BCM56800_A0_FP_UDF_OFFSETm_t FP_UDF_OFFSETm_t;
#define FP_UDF_OFFSETm_CLR BCM56800_A0_FP_UDF_OFFSETm_CLR
#define FP_UDF_OFFSETm_SET BCM56800_A0_FP_UDF_OFFSETm_SET
#define FP_UDF_OFFSETm_GET BCM56800_A0_FP_UDF_OFFSETm_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET0f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET0f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS0f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET1f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET1f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS1f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET2f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET2f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS2f_SET
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_GET
#define FP_UDF_OFFSETm_UDF1_OFFSET3f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF1_OFFSET3f_SET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_GET
#define FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF1_ADD_IPV4_OPTIONS3f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET0f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET0f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS0f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET1f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET1f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS1f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET2f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET2f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS2f_SET
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_GET
#define FP_UDF_OFFSETm_UDF2_OFFSET3f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF2_OFFSET3f_SET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_GET
#define FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET BCM56800_A0_FP_UDF_OFFSETm_UDF2_ADD_IPV4_OPTIONS3f_SET
#define READ_FP_UDF_OFFSETm BCM56800_A0_READ_FP_UDF_OFFSETm
#define WRITE_FP_UDF_OFFSETm BCM56800_A0_WRITE_FP_UDF_OFFSETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FP_UDF_OFFSETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FUSE_REGS_FP_TCAM0
 * BLOCKS:   IPIPE
 * DESC:     FUSE_REGS_FP_TCAM0, FeatureSpecific-FP
 * SIZE:     32
 * FIELDS:
 *     S_RF_BITS        S_rf bits for debug of fuse_regs flops
 *
 ******************************************************************************/
#define BCM56800_A0_FUSE_REGS_FP_TCAM0r 0x0c180220

#define BCM56800_A0_FUSE_REGS_FP_TCAM0r_SIZE 4

/*
 * This structure should be used to declare and program FUSE_REGS_FP_TCAM0.
 *
 */
typedef union BCM56800_A0_FUSE_REGS_FP_TCAM0r_s {
	uint32_t v[1];
	uint32_t fuse_regs_fp_tcam0[1];
	uint32_t _fuse_regs_fp_tcam0;
} BCM56800_A0_FUSE_REGS_FP_TCAM0r_t;

#define BCM56800_A0_FUSE_REGS_FP_TCAM0r_CLR(r) (r).fuse_regs_fp_tcam0[0] = 0
#define BCM56800_A0_FUSE_REGS_FP_TCAM0r_SET(r,d) (r).fuse_regs_fp_tcam0[0] = d
#define BCM56800_A0_FUSE_REGS_FP_TCAM0r_GET(r) (r).fuse_regs_fp_tcam0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FUSE_REGS_FP_TCAM0r_S_RF_BITSf_GET(r) (((r).fuse_regs_fp_tcam0[0]) & 0xff)
#define BCM56800_A0_FUSE_REGS_FP_TCAM0r_S_RF_BITSf_SET(r,f) (r).fuse_regs_fp_tcam0[0]=(((r).fuse_regs_fp_tcam0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access FUSE_REGS_FP_TCAM0.
 *
 */
#define BCM56800_A0_READ_FUSE_REGS_FP_TCAM0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FUSE_REGS_FP_TCAM0r,(r._fuse_regs_fp_tcam0))
#define BCM56800_A0_WRITE_FUSE_REGS_FP_TCAM0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FUSE_REGS_FP_TCAM0r,&(r._fuse_regs_fp_tcam0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FUSE_REGS_FP_TCAM0r BCM56800_A0_FUSE_REGS_FP_TCAM0r
#define FUSE_REGS_FP_TCAM0r_SIZE BCM56800_A0_FUSE_REGS_FP_TCAM0r_SIZE
typedef BCM56800_A0_FUSE_REGS_FP_TCAM0r_t FUSE_REGS_FP_TCAM0r_t;
#define FUSE_REGS_FP_TCAM0r_CLR BCM56800_A0_FUSE_REGS_FP_TCAM0r_CLR
#define FUSE_REGS_FP_TCAM0r_SET BCM56800_A0_FUSE_REGS_FP_TCAM0r_SET
#define FUSE_REGS_FP_TCAM0r_GET BCM56800_A0_FUSE_REGS_FP_TCAM0r_GET
#define FUSE_REGS_FP_TCAM0r_S_RF_BITSf_GET BCM56800_A0_FUSE_REGS_FP_TCAM0r_S_RF_BITSf_GET
#define FUSE_REGS_FP_TCAM0r_S_RF_BITSf_SET BCM56800_A0_FUSE_REGS_FP_TCAM0r_S_RF_BITSf_SET
#define READ_FUSE_REGS_FP_TCAM0r BCM56800_A0_READ_FUSE_REGS_FP_TCAM0r
#define WRITE_FUSE_REGS_FP_TCAM0r BCM56800_A0_WRITE_FUSE_REGS_FP_TCAM0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FUSE_REGS_FP_TCAM0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FUSE_REGS_ING_L3_NEXT_HOP_0
 * BLOCKS:   IPIPE
 * DESC:     FUSE_REGS_ING_L3_NEXT_HOP_0
 * SIZE:     32
 * FIELDS:
 *     S_RF_BITS        s_rf fuse bits
 *
 ******************************************************************************/
#define BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r 0x0d180204

#define BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_SIZE 4

/*
 * This structure should be used to declare and program FUSE_REGS_ING_L3_NEXT_HOP_0.
 *
 */
typedef union BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_s {
	uint32_t v[1];
	uint32_t fuse_regs_ing_l3_next_hop_0[1];
	uint32_t _fuse_regs_ing_l3_next_hop_0;
} BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_t;

#define BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_CLR(r) (r).fuse_regs_ing_l3_next_hop_0[0] = 0
#define BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_SET(r,d) (r).fuse_regs_ing_l3_next_hop_0[0] = d
#define BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_GET(r) (r).fuse_regs_ing_l3_next_hop_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_S_RF_BITSf_GET(r) (((r).fuse_regs_ing_l3_next_hop_0[0]) & 0xffff)
#define BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_S_RF_BITSf_SET(r,f) (r).fuse_regs_ing_l3_next_hop_0[0]=(((r).fuse_regs_ing_l3_next_hop_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FUSE_REGS_ING_L3_NEXT_HOP_0.
 *
 */
#define BCM56800_A0_READ_FUSE_REGS_ING_L3_NEXT_HOP_0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r,(r._fuse_regs_ing_l3_next_hop_0))
#define BCM56800_A0_WRITE_FUSE_REGS_ING_L3_NEXT_HOP_0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r,&(r._fuse_regs_ing_l3_next_hop_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FUSE_REGS_ING_L3_NEXT_HOP_0r BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r
#define FUSE_REGS_ING_L3_NEXT_HOP_0r_SIZE BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_SIZE
typedef BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_t FUSE_REGS_ING_L3_NEXT_HOP_0r_t;
#define FUSE_REGS_ING_L3_NEXT_HOP_0r_CLR BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_CLR
#define FUSE_REGS_ING_L3_NEXT_HOP_0r_SET BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_SET
#define FUSE_REGS_ING_L3_NEXT_HOP_0r_GET BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_GET
#define FUSE_REGS_ING_L3_NEXT_HOP_0r_S_RF_BITSf_GET BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_S_RF_BITSf_GET
#define FUSE_REGS_ING_L3_NEXT_HOP_0r_S_RF_BITSf_SET BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r_S_RF_BITSf_SET
#define READ_FUSE_REGS_ING_L3_NEXT_HOP_0r BCM56800_A0_READ_FUSE_REGS_ING_L3_NEXT_HOP_0r
#define WRITE_FUSE_REGS_ING_L3_NEXT_HOP_0r BCM56800_A0_WRITE_FUSE_REGS_ING_L3_NEXT_HOP_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FUSE_REGS_ING_L3_NEXT_HOP_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FUSE_REGS_L2_ENTRY_0
 * BLOCKS:   IPIPE
 * DESC:     FUSE_REGS_L2_ENTRY_0, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     LWR_S_RF_BITS    These are the lwr s_rf bits for the L2_ENTRY_RAM0 memory.
 *
 ******************************************************************************/
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_0r 0x06180213

#define BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_SIZE 4

/*
 * This structure should be used to declare and program FUSE_REGS_L2_ENTRY_0.
 *
 */
typedef union BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_s {
	uint32_t v[1];
	uint32_t fuse_regs_l2_entry_0[1];
	uint32_t _fuse_regs_l2_entry_0;
} BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_t;

#define BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_CLR(r) (r).fuse_regs_l2_entry_0[0] = 0
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_SET(r,d) (r).fuse_regs_l2_entry_0[0] = d
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_GET(r) (r).fuse_regs_l2_entry_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_LWR_S_RF_BITSf_GET(r) ((r).fuse_regs_l2_entry_0[0])
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_LWR_S_RF_BITSf_SET(r,f) (r).fuse_regs_l2_entry_0[0]=((uint32_t)f)

/*
 * These macros can be used to access FUSE_REGS_L2_ENTRY_0.
 *
 */
#define BCM56800_A0_READ_FUSE_REGS_L2_ENTRY_0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FUSE_REGS_L2_ENTRY_0r,(r._fuse_regs_l2_entry_0))
#define BCM56800_A0_WRITE_FUSE_REGS_L2_ENTRY_0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FUSE_REGS_L2_ENTRY_0r,&(r._fuse_regs_l2_entry_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FUSE_REGS_L2_ENTRY_0r BCM56800_A0_FUSE_REGS_L2_ENTRY_0r
#define FUSE_REGS_L2_ENTRY_0r_SIZE BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_SIZE
typedef BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_t FUSE_REGS_L2_ENTRY_0r_t;
#define FUSE_REGS_L2_ENTRY_0r_CLR BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_CLR
#define FUSE_REGS_L2_ENTRY_0r_SET BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_SET
#define FUSE_REGS_L2_ENTRY_0r_GET BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_GET
#define FUSE_REGS_L2_ENTRY_0r_LWR_S_RF_BITSf_GET BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_LWR_S_RF_BITSf_GET
#define FUSE_REGS_L2_ENTRY_0r_LWR_S_RF_BITSf_SET BCM56800_A0_FUSE_REGS_L2_ENTRY_0r_LWR_S_RF_BITSf_SET
#define READ_FUSE_REGS_L2_ENTRY_0r BCM56800_A0_READ_FUSE_REGS_L2_ENTRY_0r
#define WRITE_FUSE_REGS_L2_ENTRY_0r BCM56800_A0_WRITE_FUSE_REGS_L2_ENTRY_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FUSE_REGS_L2_ENTRY_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FUSE_REGS_L2_ENTRY_1
 * BLOCKS:   IPIPE
 * DESC:     FUSE_REGS_L2_ENTRY_1, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     UPR_S_RF_BITS    These are the upr s_rf bits for the L2_ENTRY_RAM0 memory.
 *
 ******************************************************************************/
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_1r 0x06180214

#define BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_SIZE 4

/*
 * This structure should be used to declare and program FUSE_REGS_L2_ENTRY_1.
 *
 */
typedef union BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_s {
	uint32_t v[1];
	uint32_t fuse_regs_l2_entry_1[1];
	uint32_t _fuse_regs_l2_entry_1;
} BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_t;

#define BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_CLR(r) (r).fuse_regs_l2_entry_1[0] = 0
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_SET(r,d) (r).fuse_regs_l2_entry_1[0] = d
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_GET(r) (r).fuse_regs_l2_entry_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_UPR_S_RF_BITSf_GET(r) (((r).fuse_regs_l2_entry_1[0]) & 0xffffff)
#define BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_UPR_S_RF_BITSf_SET(r,f) (r).fuse_regs_l2_entry_1[0]=(((r).fuse_regs_l2_entry_1[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))

/*
 * These macros can be used to access FUSE_REGS_L2_ENTRY_1.
 *
 */
#define BCM56800_A0_READ_FUSE_REGS_L2_ENTRY_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FUSE_REGS_L2_ENTRY_1r,(r._fuse_regs_l2_entry_1))
#define BCM56800_A0_WRITE_FUSE_REGS_L2_ENTRY_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FUSE_REGS_L2_ENTRY_1r,&(r._fuse_regs_l2_entry_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FUSE_REGS_L2_ENTRY_1r BCM56800_A0_FUSE_REGS_L2_ENTRY_1r
#define FUSE_REGS_L2_ENTRY_1r_SIZE BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_SIZE
typedef BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_t FUSE_REGS_L2_ENTRY_1r_t;
#define FUSE_REGS_L2_ENTRY_1r_CLR BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_CLR
#define FUSE_REGS_L2_ENTRY_1r_SET BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_SET
#define FUSE_REGS_L2_ENTRY_1r_GET BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_GET
#define FUSE_REGS_L2_ENTRY_1r_UPR_S_RF_BITSf_GET BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_UPR_S_RF_BITSf_GET
#define FUSE_REGS_L2_ENTRY_1r_UPR_S_RF_BITSf_SET BCM56800_A0_FUSE_REGS_L2_ENTRY_1r_UPR_S_RF_BITSf_SET
#define READ_FUSE_REGS_L2_ENTRY_1r BCM56800_A0_READ_FUSE_REGS_L2_ENTRY_1r
#define WRITE_FUSE_REGS_L2_ENTRY_1r BCM56800_A0_WRITE_FUSE_REGS_L2_ENTRY_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FUSE_REGS_L2_ENTRY_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  FUSE_REGS_VLAN_MAC_0
 * BLOCKS:   IPIPE
 * DESC:     FUSE_REGS_VLAN_MAC_0, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S_RF_BITS        s_rf fuse bits
 *
 ******************************************************************************/
#define BCM56800_A0_FUSE_REGS_VLAN_MAC_0r 0x04180c14

#define BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_SIZE 4

/*
 * This structure should be used to declare and program FUSE_REGS_VLAN_MAC_0.
 *
 */
typedef union BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_s {
	uint32_t v[1];
	uint32_t fuse_regs_vlan_mac_0[1];
	uint32_t _fuse_regs_vlan_mac_0;
} BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_t;

#define BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_CLR(r) (r).fuse_regs_vlan_mac_0[0] = 0
#define BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_SET(r,d) (r).fuse_regs_vlan_mac_0[0] = d
#define BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_GET(r) (r).fuse_regs_vlan_mac_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_S_RF_BITSf_GET(r) (((r).fuse_regs_vlan_mac_0[0]) & 0xfff)
#define BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_S_RF_BITSf_SET(r,f) (r).fuse_regs_vlan_mac_0[0]=(((r).fuse_regs_vlan_mac_0[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access FUSE_REGS_VLAN_MAC_0.
 *
 */
#define BCM56800_A0_READ_FUSE_REGS_VLAN_MAC_0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_FUSE_REGS_VLAN_MAC_0r,(r._fuse_regs_vlan_mac_0))
#define BCM56800_A0_WRITE_FUSE_REGS_VLAN_MAC_0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_FUSE_REGS_VLAN_MAC_0r,&(r._fuse_regs_vlan_mac_0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FUSE_REGS_VLAN_MAC_0r BCM56800_A0_FUSE_REGS_VLAN_MAC_0r
#define FUSE_REGS_VLAN_MAC_0r_SIZE BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_SIZE
typedef BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_t FUSE_REGS_VLAN_MAC_0r_t;
#define FUSE_REGS_VLAN_MAC_0r_CLR BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_CLR
#define FUSE_REGS_VLAN_MAC_0r_SET BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_SET
#define FUSE_REGS_VLAN_MAC_0r_GET BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_GET
#define FUSE_REGS_VLAN_MAC_0r_S_RF_BITSf_GET BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_S_RF_BITSf_GET
#define FUSE_REGS_VLAN_MAC_0r_S_RF_BITSf_SET BCM56800_A0_FUSE_REGS_VLAN_MAC_0r_S_RF_BITSf_SET
#define READ_FUSE_REGS_VLAN_MAC_0r BCM56800_A0_READ_FUSE_REGS_VLAN_MAC_0r
#define WRITE_FUSE_REGS_VLAN_MAC_0r BCM56800_A0_WRITE_FUSE_REGS_VLAN_MAC_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_FUSE_REGS_VLAN_MAC_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GE_EGR_PKT_DROP_CTL
 * BLOCKS:   GXPORT
 * DESC:     Flush enable control for each egress port of GPORT
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Flush enable bit to drop the packets within GPORT for each GE port
 *
 ******************************************************************************/
#define BCM56800_A0_GE_EGR_PKT_DROP_CTLr 0x00f00301

#define BCM56800_A0_GE_EGR_PKT_DROP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GE_EGR_PKT_DROP_CTL.
 *
 */
typedef union BCM56800_A0_GE_EGR_PKT_DROP_CTLr_s {
	uint32_t v[1];
	uint32_t ge_egr_pkt_drop_ctl[1];
	uint32_t _ge_egr_pkt_drop_ctl;
} BCM56800_A0_GE_EGR_PKT_DROP_CTLr_t;

#define BCM56800_A0_GE_EGR_PKT_DROP_CTLr_CLR(r) (r).ge_egr_pkt_drop_ctl[0] = 0
#define BCM56800_A0_GE_EGR_PKT_DROP_CTLr_SET(r,d) (r).ge_egr_pkt_drop_ctl[0] = d
#define BCM56800_A0_GE_EGR_PKT_DROP_CTLr_GET(r) (r).ge_egr_pkt_drop_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_GET(r) (((r).ge_egr_pkt_drop_ctl[0]) & 0x1)
#define BCM56800_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_SET(r,f) (r).ge_egr_pkt_drop_ctl[0]=(((r).ge_egr_pkt_drop_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE_EGR_PKT_DROP_CTL.
 *
 */
#define BCM56800_A0_READ_GE_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GE_EGR_PKT_DROP_CTLr,(r._ge_egr_pkt_drop_ctl))
#define BCM56800_A0_WRITE_GE_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GE_EGR_PKT_DROP_CTLr,&(r._ge_egr_pkt_drop_ctl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_EGR_PKT_DROP_CTLr BCM56800_A0_GE_EGR_PKT_DROP_CTLr
#define GE_EGR_PKT_DROP_CTLr_SIZE BCM56800_A0_GE_EGR_PKT_DROP_CTLr_SIZE
typedef BCM56800_A0_GE_EGR_PKT_DROP_CTLr_t GE_EGR_PKT_DROP_CTLr_t;
#define GE_EGR_PKT_DROP_CTLr_CLR BCM56800_A0_GE_EGR_PKT_DROP_CTLr_CLR
#define GE_EGR_PKT_DROP_CTLr_SET BCM56800_A0_GE_EGR_PKT_DROP_CTLr_SET
#define GE_EGR_PKT_DROP_CTLr_GET BCM56800_A0_GE_EGR_PKT_DROP_CTLr_GET
#define GE_EGR_PKT_DROP_CTLr_FLUSHf_GET BCM56800_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_GET
#define GE_EGR_PKT_DROP_CTLr_FLUSHf_SET BCM56800_A0_GE_EGR_PKT_DROP_CTLr_FLUSHf_SET
#define READ_GE_EGR_PKT_DROP_CTLr BCM56800_A0_READ_GE_EGR_PKT_DROP_CTLr
#define WRITE_GE_EGR_PKT_DROP_CTLr BCM56800_A0_WRITE_GE_EGR_PKT_DROP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GE_EGR_PKT_DROP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GE_GBODE_CELL_CNT
 * BLOCKS:   GXPORT
 * DESC:     GBODE cell count register for GE 
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in GBODE tx fifo.
 *
 ******************************************************************************/
#define BCM56800_A0_GE_GBODE_CELL_CNTr 0x00f00a05

#define BCM56800_A0_GE_GBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE_GBODE_CELL_CNT.
 *
 */
typedef union BCM56800_A0_GE_GBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t ge_gbode_cell_cnt[1];
	uint32_t _ge_gbode_cell_cnt;
} BCM56800_A0_GE_GBODE_CELL_CNTr_t;

#define BCM56800_A0_GE_GBODE_CELL_CNTr_CLR(r) (r).ge_gbode_cell_cnt[0] = 0
#define BCM56800_A0_GE_GBODE_CELL_CNTr_SET(r,d) (r).ge_gbode_cell_cnt[0] = d
#define BCM56800_A0_GE_GBODE_CELL_CNTr_GET(r) (r).ge_gbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GE_GBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).ge_gbode_cell_cnt[0]) & 0xf)
#define BCM56800_A0_GE_GBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).ge_gbode_cell_cnt[0]=(((r).ge_gbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE_GBODE_CELL_CNT.
 *
 */
#define BCM56800_A0_READ_GE_GBODE_CELL_CNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GE_GBODE_CELL_CNTr,(r._ge_gbode_cell_cnt))
#define BCM56800_A0_WRITE_GE_GBODE_CELL_CNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GE_GBODE_CELL_CNTr,&(r._ge_gbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_GBODE_CELL_CNTr BCM56800_A0_GE_GBODE_CELL_CNTr
#define GE_GBODE_CELL_CNTr_SIZE BCM56800_A0_GE_GBODE_CELL_CNTr_SIZE
typedef BCM56800_A0_GE_GBODE_CELL_CNTr_t GE_GBODE_CELL_CNTr_t;
#define GE_GBODE_CELL_CNTr_CLR BCM56800_A0_GE_GBODE_CELL_CNTr_CLR
#define GE_GBODE_CELL_CNTr_SET BCM56800_A0_GE_GBODE_CELL_CNTr_SET
#define GE_GBODE_CELL_CNTr_GET BCM56800_A0_GE_GBODE_CELL_CNTr_GET
#define GE_GBODE_CELL_CNTr_CELL_CNTf_GET BCM56800_A0_GE_GBODE_CELL_CNTr_CELL_CNTf_GET
#define GE_GBODE_CELL_CNTr_CELL_CNTf_SET BCM56800_A0_GE_GBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_GE_GBODE_CELL_CNTr BCM56800_A0_READ_GE_GBODE_CELL_CNTr
#define WRITE_GE_GBODE_CELL_CNTr BCM56800_A0_WRITE_GE_GBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GE_GBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GE_GBODE_CELL_REQ_CNT
 * BLOCKS:   GXPORT
 * DESC:     GBODE cell request count register for GE 
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell request made to Egress Pipeline, MAX is 4 in FB mode. In Felix mode, MAX is 8.
 *
 ******************************************************************************/
#define BCM56800_A0_GE_GBODE_CELL_REQ_CNTr 0x00f00a06

#define BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program GE_GBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t ge_gbode_cell_req_cnt[1];
	uint32_t _ge_gbode_cell_req_cnt;
} BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_t;

#define BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_CLR(r) (r).ge_gbode_cell_req_cnt[0] = 0
#define BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_SET(r,d) (r).ge_gbode_cell_req_cnt[0] = d
#define BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_GET(r) (r).ge_gbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).ge_gbode_cell_req_cnt[0]) & 0xf)
#define BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).ge_gbode_cell_req_cnt[0]=(((r).ge_gbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access GE_GBODE_CELL_REQ_CNT.
 *
 */
#define BCM56800_A0_READ_GE_GBODE_CELL_REQ_CNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GE_GBODE_CELL_REQ_CNTr,(r._ge_gbode_cell_req_cnt))
#define BCM56800_A0_WRITE_GE_GBODE_CELL_REQ_CNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GE_GBODE_CELL_REQ_CNTr,&(r._ge_gbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_GBODE_CELL_REQ_CNTr BCM56800_A0_GE_GBODE_CELL_REQ_CNTr
#define GE_GBODE_CELL_REQ_CNTr_SIZE BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_SIZE
typedef BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_t GE_GBODE_CELL_REQ_CNTr_t;
#define GE_GBODE_CELL_REQ_CNTr_CLR BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_CLR
#define GE_GBODE_CELL_REQ_CNTr_SET BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_SET
#define GE_GBODE_CELL_REQ_CNTr_GET BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_GET
#define GE_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define GE_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56800_A0_GE_GBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_GE_GBODE_CELL_REQ_CNTr BCM56800_A0_READ_GE_GBODE_CELL_REQ_CNTr
#define WRITE_GE_GBODE_CELL_REQ_CNTr BCM56800_A0_WRITE_GE_GBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GE_GBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GE_GBOD_OVRFLW
 * BLOCKS:   GXPORT
 * DESC:     GBOD RX fifo overflow for GE 
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           GBOD RX fifo overflow flag.
 *
 ******************************************************************************/
#define BCM56800_A0_GE_GBOD_OVRFLWr 0x00f00a04

#define BCM56800_A0_GE_GBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program GE_GBOD_OVRFLW.
 *
 */
typedef union BCM56800_A0_GE_GBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t ge_gbod_ovrflw[1];
	uint32_t _ge_gbod_ovrflw;
} BCM56800_A0_GE_GBOD_OVRFLWr_t;

#define BCM56800_A0_GE_GBOD_OVRFLWr_CLR(r) (r).ge_gbod_ovrflw[0] = 0
#define BCM56800_A0_GE_GBOD_OVRFLWr_SET(r,d) (r).ge_gbod_ovrflw[0] = d
#define BCM56800_A0_GE_GBOD_OVRFLWr_GET(r) (r).ge_gbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GE_GBOD_OVRFLWr_OVRFLWf_GET(r) (((r).ge_gbod_ovrflw[0]) & 0x1)
#define BCM56800_A0_GE_GBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).ge_gbod_ovrflw[0]=(((r).ge_gbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GE_GBOD_OVRFLW.
 *
 */
#define BCM56800_A0_READ_GE_GBOD_OVRFLWr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GE_GBOD_OVRFLWr,(r._ge_gbod_ovrflw))
#define BCM56800_A0_WRITE_GE_GBOD_OVRFLWr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GE_GBOD_OVRFLWr,&(r._ge_gbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_GBOD_OVRFLWr BCM56800_A0_GE_GBOD_OVRFLWr
#define GE_GBOD_OVRFLWr_SIZE BCM56800_A0_GE_GBOD_OVRFLWr_SIZE
typedef BCM56800_A0_GE_GBOD_OVRFLWr_t GE_GBOD_OVRFLWr_t;
#define GE_GBOD_OVRFLWr_CLR BCM56800_A0_GE_GBOD_OVRFLWr_CLR
#define GE_GBOD_OVRFLWr_SET BCM56800_A0_GE_GBOD_OVRFLWr_SET
#define GE_GBOD_OVRFLWr_GET BCM56800_A0_GE_GBOD_OVRFLWr_GET
#define GE_GBOD_OVRFLWr_OVRFLWf_GET BCM56800_A0_GE_GBOD_OVRFLWr_OVRFLWf_GET
#define GE_GBOD_OVRFLWr_OVRFLWf_SET BCM56800_A0_GE_GBOD_OVRFLWr_OVRFLWf_SET
#define READ_GE_GBOD_OVRFLWr BCM56800_A0_READ_GE_GBOD_OVRFLWr
#define WRITE_GE_GBOD_OVRFLWr BCM56800_A0_WRITE_GE_GBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GE_GBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GE_PORT_CONFIG
 * BLOCKS:   GXPORT
 * DESC:     GE port configuration
 * SIZE:     32
 * FIELDS:
 *     JAM_EN           Enable Jamming
 *     SPEED_SELECT     00=Gig, 01=100Mbps, 10=10Mbps, 11=N/A
 *     MAC_CRS_SEL      When set, connect the carrier sense (CRS) from external PHY. Default is from internal Serdes output.
 *     SGN_DET_SEL      When set, connect signal detect from external Fiber module.
 *     CLK_OUT_EN       When set, enable the clock output to SERDES.
 *
 ******************************************************************************/
#define BCM56800_A0_GE_PORT_CONFIGr 0x00f00300

#define BCM56800_A0_GE_PORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GE_PORT_CONFIG.
 *
 */
typedef union BCM56800_A0_GE_PORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t ge_port_config[1];
	uint32_t _ge_port_config;
} BCM56800_A0_GE_PORT_CONFIGr_t;

#define BCM56800_A0_GE_PORT_CONFIGr_CLR(r) (r).ge_port_config[0] = 0
#define BCM56800_A0_GE_PORT_CONFIGr_SET(r,d) (r).ge_port_config[0] = d
#define BCM56800_A0_GE_PORT_CONFIGr_GET(r) (r).ge_port_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GE_PORT_CONFIGr_JAM_ENf_GET(r) (((r).ge_port_config[0]) & 0x1)
#define BCM56800_A0_GE_PORT_CONFIGr_JAM_ENf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_GE_PORT_CONFIGr_SPEED_SELECTf_GET(r) ((((r).ge_port_config[0]) >> 1) & 0x3)
#define BCM56800_A0_GE_PORT_CONFIGr_SPEED_SELECTf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56800_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_GET(r) ((((r).ge_port_config[0]) >> 3) & 0x1)
#define BCM56800_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_GE_PORT_CONFIGr_SGN_DET_SELf_GET(r) ((((r).ge_port_config[0]) >> 4) & 0x1)
#define BCM56800_A0_GE_PORT_CONFIGr_SGN_DET_SELf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_GET(r) ((((r).ge_port_config[0]) >> 5) & 0x1)
#define BCM56800_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_SET(r,f) (r).ge_port_config[0]=(((r).ge_port_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access GE_PORT_CONFIG.
 *
 */
#define BCM56800_A0_READ_GE_PORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GE_PORT_CONFIGr,(r._ge_port_config))
#define BCM56800_A0_WRITE_GE_PORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GE_PORT_CONFIGr,&(r._ge_port_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GE_PORT_CONFIGr BCM56800_A0_GE_PORT_CONFIGr
#define GE_PORT_CONFIGr_SIZE BCM56800_A0_GE_PORT_CONFIGr_SIZE
typedef BCM56800_A0_GE_PORT_CONFIGr_t GE_PORT_CONFIGr_t;
#define GE_PORT_CONFIGr_CLR BCM56800_A0_GE_PORT_CONFIGr_CLR
#define GE_PORT_CONFIGr_SET BCM56800_A0_GE_PORT_CONFIGr_SET
#define GE_PORT_CONFIGr_GET BCM56800_A0_GE_PORT_CONFIGr_GET
#define GE_PORT_CONFIGr_JAM_ENf_GET BCM56800_A0_GE_PORT_CONFIGr_JAM_ENf_GET
#define GE_PORT_CONFIGr_JAM_ENf_SET BCM56800_A0_GE_PORT_CONFIGr_JAM_ENf_SET
#define GE_PORT_CONFIGr_SPEED_SELECTf_GET BCM56800_A0_GE_PORT_CONFIGr_SPEED_SELECTf_GET
#define GE_PORT_CONFIGr_SPEED_SELECTf_SET BCM56800_A0_GE_PORT_CONFIGr_SPEED_SELECTf_SET
#define GE_PORT_CONFIGr_MAC_CRS_SELf_GET BCM56800_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_GET
#define GE_PORT_CONFIGr_MAC_CRS_SELf_SET BCM56800_A0_GE_PORT_CONFIGr_MAC_CRS_SELf_SET
#define GE_PORT_CONFIGr_SGN_DET_SELf_GET BCM56800_A0_GE_PORT_CONFIGr_SGN_DET_SELf_GET
#define GE_PORT_CONFIGr_SGN_DET_SELf_SET BCM56800_A0_GE_PORT_CONFIGr_SGN_DET_SELf_SET
#define GE_PORT_CONFIGr_CLK_OUT_ENf_GET BCM56800_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_GET
#define GE_PORT_CONFIGr_CLK_OUT_ENf_SET BCM56800_A0_GE_PORT_CONFIGr_CLK_OUT_ENf_SET
#define READ_GE_PORT_CONFIGr BCM56800_A0_READ_GE_PORT_CONFIGr
#define WRITE_GE_PORT_CONFIGr BCM56800_A0_WRITE_GE_PORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GE_PORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GLOBAL_HDRM_COUNT
 * BLOCKS:   MMU
 * DESC:     GLOBAL_HDRM_COUNT
 * SIZE:     32
 * FIELDS:
 *     GLOBAL_HDRM_COUNT It represents the total number of "global headroom" cells in use by all input ports. It is used to calculate the  number of global headroom cells available.
 *
 ******************************************************************************/
#define BCM56800_A0_GLOBAL_HDRM_COUNTr 0x02d80042

#define BCM56800_A0_GLOBAL_HDRM_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program GLOBAL_HDRM_COUNT.
 *
 */
typedef union BCM56800_A0_GLOBAL_HDRM_COUNTr_s {
	uint32_t v[1];
	uint32_t global_hdrm_count[1];
	uint32_t _global_hdrm_count;
} BCM56800_A0_GLOBAL_HDRM_COUNTr_t;

#define BCM56800_A0_GLOBAL_HDRM_COUNTr_CLR(r) (r).global_hdrm_count[0] = 0
#define BCM56800_A0_GLOBAL_HDRM_COUNTr_SET(r,d) (r).global_hdrm_count[0] = d
#define BCM56800_A0_GLOBAL_HDRM_COUNTr_GET(r) (r).global_hdrm_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GLOBAL_HDRM_COUNTr_GLOBAL_HDRM_COUNTf_GET(r) (((r).global_hdrm_count[0]) & 0x3fff)
#define BCM56800_A0_GLOBAL_HDRM_COUNTr_GLOBAL_HDRM_COUNTf_SET(r,f) (r).global_hdrm_count[0]=(((r).global_hdrm_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access GLOBAL_HDRM_COUNT.
 *
 */
#define BCM56800_A0_READ_GLOBAL_HDRM_COUNTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_GLOBAL_HDRM_COUNTr,(r._global_hdrm_count))
#define BCM56800_A0_WRITE_GLOBAL_HDRM_COUNTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_GLOBAL_HDRM_COUNTr,&(r._global_hdrm_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GLOBAL_HDRM_COUNTr BCM56800_A0_GLOBAL_HDRM_COUNTr
#define GLOBAL_HDRM_COUNTr_SIZE BCM56800_A0_GLOBAL_HDRM_COUNTr_SIZE
typedef BCM56800_A0_GLOBAL_HDRM_COUNTr_t GLOBAL_HDRM_COUNTr_t;
#define GLOBAL_HDRM_COUNTr_CLR BCM56800_A0_GLOBAL_HDRM_COUNTr_CLR
#define GLOBAL_HDRM_COUNTr_SET BCM56800_A0_GLOBAL_HDRM_COUNTr_SET
#define GLOBAL_HDRM_COUNTr_GET BCM56800_A0_GLOBAL_HDRM_COUNTr_GET
#define GLOBAL_HDRM_COUNTr_GLOBAL_HDRM_COUNTf_GET BCM56800_A0_GLOBAL_HDRM_COUNTr_GLOBAL_HDRM_COUNTf_GET
#define GLOBAL_HDRM_COUNTr_GLOBAL_HDRM_COUNTf_SET BCM56800_A0_GLOBAL_HDRM_COUNTr_GLOBAL_HDRM_COUNTf_SET
#define READ_GLOBAL_HDRM_COUNTr BCM56800_A0_READ_GLOBAL_HDRM_COUNTr
#define WRITE_GLOBAL_HDRM_COUNTr BCM56800_A0_WRITE_GLOBAL_HDRM_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GLOBAL_HDRM_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GLOBAL_HDRM_LIMIT
 * BLOCKS:   MMU
 * DESC:     GLOBAL_HDRM_LIMIT
 * SIZE:     32
 * FIELDS:
 *     GLOBAL_HDRM_LIMIT This is programmed with the number of cells the user wishes to set aside for any PG to use to possibly complete a partial received packet instead of discarding the tail of the packet and causing a fragment to be left in the data buffer.
 *
 ******************************************************************************/
#define BCM56800_A0_GLOBAL_HDRM_LIMITr 0x02d80001

#define BCM56800_A0_GLOBAL_HDRM_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program GLOBAL_HDRM_LIMIT.
 *
 */
typedef union BCM56800_A0_GLOBAL_HDRM_LIMITr_s {
	uint32_t v[1];
	uint32_t global_hdrm_limit[1];
	uint32_t _global_hdrm_limit;
} BCM56800_A0_GLOBAL_HDRM_LIMITr_t;

#define BCM56800_A0_GLOBAL_HDRM_LIMITr_CLR(r) (r).global_hdrm_limit[0] = 0
#define BCM56800_A0_GLOBAL_HDRM_LIMITr_SET(r,d) (r).global_hdrm_limit[0] = d
#define BCM56800_A0_GLOBAL_HDRM_LIMITr_GET(r) (r).global_hdrm_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GLOBAL_HDRM_LIMITr_GLOBAL_HDRM_LIMITf_GET(r) (((r).global_hdrm_limit[0]) & 0x3fff)
#define BCM56800_A0_GLOBAL_HDRM_LIMITr_GLOBAL_HDRM_LIMITf_SET(r,f) (r).global_hdrm_limit[0]=(((r).global_hdrm_limit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access GLOBAL_HDRM_LIMIT.
 *
 */
#define BCM56800_A0_READ_GLOBAL_HDRM_LIMITr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_GLOBAL_HDRM_LIMITr,(r._global_hdrm_limit))
#define BCM56800_A0_WRITE_GLOBAL_HDRM_LIMITr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_GLOBAL_HDRM_LIMITr,&(r._global_hdrm_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GLOBAL_HDRM_LIMITr BCM56800_A0_GLOBAL_HDRM_LIMITr
#define GLOBAL_HDRM_LIMITr_SIZE BCM56800_A0_GLOBAL_HDRM_LIMITr_SIZE
typedef BCM56800_A0_GLOBAL_HDRM_LIMITr_t GLOBAL_HDRM_LIMITr_t;
#define GLOBAL_HDRM_LIMITr_CLR BCM56800_A0_GLOBAL_HDRM_LIMITr_CLR
#define GLOBAL_HDRM_LIMITr_SET BCM56800_A0_GLOBAL_HDRM_LIMITr_SET
#define GLOBAL_HDRM_LIMITr_GET BCM56800_A0_GLOBAL_HDRM_LIMITr_GET
#define GLOBAL_HDRM_LIMITr_GLOBAL_HDRM_LIMITf_GET BCM56800_A0_GLOBAL_HDRM_LIMITr_GLOBAL_HDRM_LIMITf_GET
#define GLOBAL_HDRM_LIMITr_GLOBAL_HDRM_LIMITf_SET BCM56800_A0_GLOBAL_HDRM_LIMITr_GLOBAL_HDRM_LIMITf_SET
#define READ_GLOBAL_HDRM_LIMITr BCM56800_A0_READ_GLOBAL_HDRM_LIMITr
#define WRITE_GLOBAL_HDRM_LIMITr BCM56800_A0_WRITE_GLOBAL_HDRM_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GLOBAL_HDRM_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GMACC0
 * BLOCKS:   GXPORT
 * DESC:     GIG Port Control Reg 0
 * SIZE:     32
 * FIELDS:
 *     TMDS             Test mode select
 *     L32B             Loopback 32B Data
 *     L10B             Loopback 10B Symbols
 *     SRST             Soft Reset
 *
 ******************************************************************************/
#define BCM56800_A0_GMACC0r 0x00f00100

#define BCM56800_A0_GMACC0r_SIZE 4

/*
 * This structure should be used to declare and program GMACC0.
 *
 */
typedef union BCM56800_A0_GMACC0r_s {
	uint32_t v[1];
	uint32_t gmacc0[1];
	uint32_t _gmacc0;
} BCM56800_A0_GMACC0r_t;

#define BCM56800_A0_GMACC0r_CLR(r) (r).gmacc0[0] = 0
#define BCM56800_A0_GMACC0r_SET(r,d) (r).gmacc0[0] = d
#define BCM56800_A0_GMACC0r_GET(r) (r).gmacc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GMACC0r_TMDSf_GET(r) (((r).gmacc0[0]) & 0xff)
#define BCM56800_A0_GMACC0r_TMDSf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_GMACC0r_L32Bf_GET(r) ((((r).gmacc0[0]) >> 8) & 0x1)
#define BCM56800_A0_GMACC0r_L32Bf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_GMACC0r_L10Bf_GET(r) ((((r).gmacc0[0]) >> 9) & 0x1)
#define BCM56800_A0_GMACC0r_L10Bf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_GMACC0r_SRSTf_GET(r) ((((r).gmacc0[0]) >> 31) & 0x1)
#define BCM56800_A0_GMACC0r_SRSTf_SET(r,f) (r).gmacc0[0]=(((r).gmacc0[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access GMACC0.
 *
 */
#define BCM56800_A0_READ_GMACC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GMACC0r,(r._gmacc0))
#define BCM56800_A0_WRITE_GMACC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GMACC0r,&(r._gmacc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC0r BCM56800_A0_GMACC0r
#define GMACC0r_SIZE BCM56800_A0_GMACC0r_SIZE
typedef BCM56800_A0_GMACC0r_t GMACC0r_t;
#define GMACC0r_CLR BCM56800_A0_GMACC0r_CLR
#define GMACC0r_SET BCM56800_A0_GMACC0r_SET
#define GMACC0r_GET BCM56800_A0_GMACC0r_GET
#define GMACC0r_TMDSf_GET BCM56800_A0_GMACC0r_TMDSf_GET
#define GMACC0r_TMDSf_SET BCM56800_A0_GMACC0r_TMDSf_SET
#define GMACC0r_L32Bf_GET BCM56800_A0_GMACC0r_L32Bf_GET
#define GMACC0r_L32Bf_SET BCM56800_A0_GMACC0r_L32Bf_SET
#define GMACC0r_L10Bf_GET BCM56800_A0_GMACC0r_L10Bf_GET
#define GMACC0r_L10Bf_SET BCM56800_A0_GMACC0r_L10Bf_SET
#define GMACC0r_SRSTf_GET BCM56800_A0_GMACC0r_SRSTf_GET
#define GMACC0r_SRSTf_SET BCM56800_A0_GMACC0r_SRSTf_SET
#define READ_GMACC0r BCM56800_A0_READ_GMACC0r
#define WRITE_GMACC0r BCM56800_A0_WRITE_GMACC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GMACC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GMACC1
 * BLOCKS:   GXPORT
 * DESC:     GIG Port Control Reg 1
 * SIZE:     32
 * FIELDS:
 *     FULLD            Full-Duplex (Tied to 1)
 *     PADEN            Pad Enable
 *     VLPAD            VLAN Pad
 *     ADPAD            Auto Detect Pad
 *     CRCEN            CRC Enable
 *     FLCHK            Frame Length Check
 *     HUGEN            Huge Frame Enable
 *     JUMBO            JUMBO Frame Enable
 *     PUREP            Pure Preamble
 *     FCTX             Flow Control: Transmit Capable
 *     FCRX             Flow Control: Receive Capable
 *     PARF             Pass All Receive Frames
 *     LONGP            Accept Preambles over 11 bytes
 *     MIFG             Minimum IFG
 *     GLVR             Gulliver
 *     DCRC12           Delayed CRC = 12 bytes
 *     RXEN0            Receive Enable
 *     TXEN0            Transmit Enable
 *
 ******************************************************************************/
#define BCM56800_A0_GMACC1r 0x00f00101

#define BCM56800_A0_GMACC1r_SIZE 4

/*
 * This structure should be used to declare and program GMACC1.
 *
 */
typedef union BCM56800_A0_GMACC1r_s {
	uint32_t v[1];
	uint32_t gmacc1[1];
	uint32_t _gmacc1;
} BCM56800_A0_GMACC1r_t;

#define BCM56800_A0_GMACC1r_CLR(r) (r).gmacc1[0] = 0
#define BCM56800_A0_GMACC1r_SET(r,d) (r).gmacc1[0] = d
#define BCM56800_A0_GMACC1r_GET(r) (r).gmacc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GMACC1r_FULLDf_GET(r) (((r).gmacc1[0]) & 0x1)
#define BCM56800_A0_GMACC1r_FULLDf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_GMACC1r_PADENf_GET(r) ((((r).gmacc1[0]) >> 1) & 0x1)
#define BCM56800_A0_GMACC1r_PADENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_GMACC1r_VLPADf_GET(r) ((((r).gmacc1[0]) >> 2) & 0x1)
#define BCM56800_A0_GMACC1r_VLPADf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_GMACC1r_ADPADf_GET(r) ((((r).gmacc1[0]) >> 3) & 0x1)
#define BCM56800_A0_GMACC1r_ADPADf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_GMACC1r_CRCENf_GET(r) ((((r).gmacc1[0]) >> 4) & 0x1)
#define BCM56800_A0_GMACC1r_CRCENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_GMACC1r_FLCHKf_GET(r) ((((r).gmacc1[0]) >> 5) & 0x1)
#define BCM56800_A0_GMACC1r_FLCHKf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_GMACC1r_HUGENf_GET(r) ((((r).gmacc1[0]) >> 6) & 0x1)
#define BCM56800_A0_GMACC1r_HUGENf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_GMACC1r_JUMBOf_GET(r) ((((r).gmacc1[0]) >> 7) & 0x1)
#define BCM56800_A0_GMACC1r_JUMBOf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_GMACC1r_PUREPf_GET(r) ((((r).gmacc1[0]) >> 8) & 0x1)
#define BCM56800_A0_GMACC1r_PUREPf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_GMACC1r_FCTXf_GET(r) ((((r).gmacc1[0]) >> 9) & 0x1)
#define BCM56800_A0_GMACC1r_FCTXf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_GMACC1r_FCRXf_GET(r) ((((r).gmacc1[0]) >> 10) & 0x1)
#define BCM56800_A0_GMACC1r_FCRXf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_GMACC1r_PARFf_GET(r) ((((r).gmacc1[0]) >> 11) & 0x1)
#define BCM56800_A0_GMACC1r_PARFf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_GMACC1r_LONGPf_GET(r) ((((r).gmacc1[0]) >> 12) & 0x1)
#define BCM56800_A0_GMACC1r_LONGPf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_GMACC1r_MIFGf_GET(r) ((((r).gmacc1[0]) >> 16) & 0x7)
#define BCM56800_A0_GMACC1r_MIFGf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM56800_A0_GMACC1r_GLVRf_GET(r) ((((r).gmacc1[0]) >> 19) & 0x1)
#define BCM56800_A0_GMACC1r_GLVRf_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_GMACC1r_DCRC12f_GET(r) ((((r).gmacc1[0]) >> 22) & 0x3)
#define BCM56800_A0_GMACC1r_DCRC12f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56800_A0_GMACC1r_RXEN0f_GET(r) ((((r).gmacc1[0]) >> 28) & 0x1)
#define BCM56800_A0_GMACC1r_RXEN0f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_GMACC1r_TXEN0f_GET(r) ((((r).gmacc1[0]) >> 30) & 0x1)
#define BCM56800_A0_GMACC1r_TXEN0f_SET(r,f) (r).gmacc1[0]=(((r).gmacc1[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))

/*
 * These macros can be used to access GMACC1.
 *
 */
#define BCM56800_A0_READ_GMACC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GMACC1r,(r._gmacc1))
#define BCM56800_A0_WRITE_GMACC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GMACC1r,&(r._gmacc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC1r BCM56800_A0_GMACC1r
#define GMACC1r_SIZE BCM56800_A0_GMACC1r_SIZE
typedef BCM56800_A0_GMACC1r_t GMACC1r_t;
#define GMACC1r_CLR BCM56800_A0_GMACC1r_CLR
#define GMACC1r_SET BCM56800_A0_GMACC1r_SET
#define GMACC1r_GET BCM56800_A0_GMACC1r_GET
#define GMACC1r_FULLDf_GET BCM56800_A0_GMACC1r_FULLDf_GET
#define GMACC1r_FULLDf_SET BCM56800_A0_GMACC1r_FULLDf_SET
#define GMACC1r_PADENf_GET BCM56800_A0_GMACC1r_PADENf_GET
#define GMACC1r_PADENf_SET BCM56800_A0_GMACC1r_PADENf_SET
#define GMACC1r_VLPADf_GET BCM56800_A0_GMACC1r_VLPADf_GET
#define GMACC1r_VLPADf_SET BCM56800_A0_GMACC1r_VLPADf_SET
#define GMACC1r_ADPADf_GET BCM56800_A0_GMACC1r_ADPADf_GET
#define GMACC1r_ADPADf_SET BCM56800_A0_GMACC1r_ADPADf_SET
#define GMACC1r_CRCENf_GET BCM56800_A0_GMACC1r_CRCENf_GET
#define GMACC1r_CRCENf_SET BCM56800_A0_GMACC1r_CRCENf_SET
#define GMACC1r_FLCHKf_GET BCM56800_A0_GMACC1r_FLCHKf_GET
#define GMACC1r_FLCHKf_SET BCM56800_A0_GMACC1r_FLCHKf_SET
#define GMACC1r_HUGENf_GET BCM56800_A0_GMACC1r_HUGENf_GET
#define GMACC1r_HUGENf_SET BCM56800_A0_GMACC1r_HUGENf_SET
#define GMACC1r_JUMBOf_GET BCM56800_A0_GMACC1r_JUMBOf_GET
#define GMACC1r_JUMBOf_SET BCM56800_A0_GMACC1r_JUMBOf_SET
#define GMACC1r_PUREPf_GET BCM56800_A0_GMACC1r_PUREPf_GET
#define GMACC1r_PUREPf_SET BCM56800_A0_GMACC1r_PUREPf_SET
#define GMACC1r_FCTXf_GET BCM56800_A0_GMACC1r_FCTXf_GET
#define GMACC1r_FCTXf_SET BCM56800_A0_GMACC1r_FCTXf_SET
#define GMACC1r_FCRXf_GET BCM56800_A0_GMACC1r_FCRXf_GET
#define GMACC1r_FCRXf_SET BCM56800_A0_GMACC1r_FCRXf_SET
#define GMACC1r_PARFf_GET BCM56800_A0_GMACC1r_PARFf_GET
#define GMACC1r_PARFf_SET BCM56800_A0_GMACC1r_PARFf_SET
#define GMACC1r_LONGPf_GET BCM56800_A0_GMACC1r_LONGPf_GET
#define GMACC1r_LONGPf_SET BCM56800_A0_GMACC1r_LONGPf_SET
#define GMACC1r_MIFGf_GET BCM56800_A0_GMACC1r_MIFGf_GET
#define GMACC1r_MIFGf_SET BCM56800_A0_GMACC1r_MIFGf_SET
#define GMACC1r_GLVRf_GET BCM56800_A0_GMACC1r_GLVRf_GET
#define GMACC1r_GLVRf_SET BCM56800_A0_GMACC1r_GLVRf_SET
#define GMACC1r_DCRC12f_GET BCM56800_A0_GMACC1r_DCRC12f_GET
#define GMACC1r_DCRC12f_SET BCM56800_A0_GMACC1r_DCRC12f_SET
#define GMACC1r_RXEN0f_GET BCM56800_A0_GMACC1r_RXEN0f_GET
#define GMACC1r_RXEN0f_SET BCM56800_A0_GMACC1r_RXEN0f_SET
#define GMACC1r_TXEN0f_GET BCM56800_A0_GMACC1r_TXEN0f_GET
#define GMACC1r_TXEN0f_SET BCM56800_A0_GMACC1r_TXEN0f_SET
#define READ_GMACC1r BCM56800_A0_READ_GMACC1r
#define WRITE_GMACC1r BCM56800_A0_WRITE_GMACC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GMACC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GMACC2
 * BLOCKS:   GXPORT
 * DESC:     GIG Port Control Reg 2
 * SIZE:     32
 * FIELDS:
 *     IPGT             Back-to-Back Transmit IPG
 *
 ******************************************************************************/
#define BCM56800_A0_GMACC2r 0x00f00102

#define BCM56800_A0_GMACC2r_SIZE 4

/*
 * This structure should be used to declare and program GMACC2.
 *
 */
typedef union BCM56800_A0_GMACC2r_s {
	uint32_t v[1];
	uint32_t gmacc2[1];
	uint32_t _gmacc2;
} BCM56800_A0_GMACC2r_t;

#define BCM56800_A0_GMACC2r_CLR(r) (r).gmacc2[0] = 0
#define BCM56800_A0_GMACC2r_SET(r,d) (r).gmacc2[0] = d
#define BCM56800_A0_GMACC2r_GET(r) (r).gmacc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GMACC2r_IPGTf_GET(r) (((r).gmacc2[0]) & 0x3f)
#define BCM56800_A0_GMACC2r_IPGTf_SET(r,f) (r).gmacc2[0]=(((r).gmacc2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))

/*
 * These macros can be used to access GMACC2.
 *
 */
#define BCM56800_A0_READ_GMACC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GMACC2r,(r._gmacc2))
#define BCM56800_A0_WRITE_GMACC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GMACC2r,&(r._gmacc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMACC2r BCM56800_A0_GMACC2r
#define GMACC2r_SIZE BCM56800_A0_GMACC2r_SIZE
typedef BCM56800_A0_GMACC2r_t GMACC2r_t;
#define GMACC2r_CLR BCM56800_A0_GMACC2r_CLR
#define GMACC2r_SET BCM56800_A0_GMACC2r_SET
#define GMACC2r_GET BCM56800_A0_GMACC2r_GET
#define GMACC2r_IPGTf_GET BCM56800_A0_GMACC2r_IPGTf_GET
#define GMACC2r_IPGTf_SET BCM56800_A0_GMACC2r_IPGTf_SET
#define READ_GMACC2r BCM56800_A0_READ_GMACC2r
#define WRITE_GMACC2r BCM56800_A0_WRITE_GMACC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GMACC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GPCSC
 * BLOCKS:   GXPORT
 * DESC:     Jitter Reg
 * SIZE:     32
 * FIELDS:
 *     EWRAP            Loopback SERDES
 *     RCSEL            Clock select for Receive. 0=TBI(8b10b), 1=GMII
 *
 ******************************************************************************/
#define BCM56800_A0_GPCSCr 0x00f00103

#define BCM56800_A0_GPCSCr_SIZE 4

/*
 * This structure should be used to declare and program GPCSC.
 *
 */
typedef union BCM56800_A0_GPCSCr_s {
	uint32_t v[1];
	uint32_t gpcsc[1];
	uint32_t _gpcsc;
} BCM56800_A0_GPCSCr_t;

#define BCM56800_A0_GPCSCr_CLR(r) (r).gpcsc[0] = 0
#define BCM56800_A0_GPCSCr_SET(r,d) (r).gpcsc[0] = d
#define BCM56800_A0_GPCSCr_GET(r) (r).gpcsc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GPCSCr_EWRAPf_GET(r) ((((r).gpcsc[0]) >> 1) & 0x1)
#define BCM56800_A0_GPCSCr_EWRAPf_SET(r,f) (r).gpcsc[0]=(((r).gpcsc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_GPCSCr_RCSELf_GET(r) ((((r).gpcsc[0]) >> 2) & 0x1)
#define BCM56800_A0_GPCSCr_RCSELf_SET(r,f) (r).gpcsc[0]=(((r).gpcsc[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access GPCSC.
 *
 */
#define BCM56800_A0_READ_GPCSCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GPCSCr,(r._gpcsc))
#define BCM56800_A0_WRITE_GPCSCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GPCSCr,&(r._gpcsc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPCSCr BCM56800_A0_GPCSCr
#define GPCSCr_SIZE BCM56800_A0_GPCSCr_SIZE
typedef BCM56800_A0_GPCSCr_t GPCSCr_t;
#define GPCSCr_CLR BCM56800_A0_GPCSCr_CLR
#define GPCSCr_SET BCM56800_A0_GPCSCr_SET
#define GPCSCr_GET BCM56800_A0_GPCSCr_GET
#define GPCSCr_EWRAPf_GET BCM56800_A0_GPCSCr_EWRAPf_GET
#define GPCSCr_EWRAPf_SET BCM56800_A0_GPCSCr_EWRAPf_SET
#define GPCSCr_RCSELf_GET BCM56800_A0_GPCSCr_RCSELf_GET
#define GPCSCr_RCSELf_SET BCM56800_A0_GPCSCr_RCSELf_SET
#define READ_GPCSCr BCM56800_A0_READ_GPCSCr
#define WRITE_GPCSCr BCM56800_A0_WRITE_GPCSCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GPCSCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GPORT_CNTMAXSIZE
 * BLOCKS:   GXPORT
 * DESC:     GPORT CNTMAXSIZE register
 * SIZE:     32
 * FIELDS:
 *     CNTMAXSIZE       The max packet size that is used in statistic counter update. Default to 1518.
 *
 ******************************************************************************/
#define BCM56800_A0_GPORT_CNTMAXSIZEr 0x00f00a03

#define BCM56800_A0_GPORT_CNTMAXSIZEr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CNTMAXSIZE.
 *
 */
typedef union BCM56800_A0_GPORT_CNTMAXSIZEr_s {
	uint32_t v[1];
	uint32_t gport_cntmaxsize[1];
	uint32_t _gport_cntmaxsize;
} BCM56800_A0_GPORT_CNTMAXSIZEr_t;

#define BCM56800_A0_GPORT_CNTMAXSIZEr_CLR(r) (r).gport_cntmaxsize[0] = 0
#define BCM56800_A0_GPORT_CNTMAXSIZEr_SET(r,d) (r).gport_cntmaxsize[0] = d
#define BCM56800_A0_GPORT_CNTMAXSIZEr_GET(r) (r).gport_cntmaxsize[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET(r) (((r).gport_cntmaxsize[0]) & 0x3fff)
#define BCM56800_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET(r,f) (r).gport_cntmaxsize[0]=(((r).gport_cntmaxsize[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access GPORT_CNTMAXSIZE.
 *
 */
#define BCM56800_A0_READ_GPORT_CNTMAXSIZEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GPORT_CNTMAXSIZEr,(r._gport_cntmaxsize))
#define BCM56800_A0_WRITE_GPORT_CNTMAXSIZEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GPORT_CNTMAXSIZEr,&(r._gport_cntmaxsize))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_CNTMAXSIZEr BCM56800_A0_GPORT_CNTMAXSIZEr
#define GPORT_CNTMAXSIZEr_SIZE BCM56800_A0_GPORT_CNTMAXSIZEr_SIZE
typedef BCM56800_A0_GPORT_CNTMAXSIZEr_t GPORT_CNTMAXSIZEr_t;
#define GPORT_CNTMAXSIZEr_CLR BCM56800_A0_GPORT_CNTMAXSIZEr_CLR
#define GPORT_CNTMAXSIZEr_SET BCM56800_A0_GPORT_CNTMAXSIZEr_SET
#define GPORT_CNTMAXSIZEr_GET BCM56800_A0_GPORT_CNTMAXSIZEr_GET
#define GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET BCM56800_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_GET
#define GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET BCM56800_A0_GPORT_CNTMAXSIZEr_CNTMAXSIZEf_SET
#define READ_GPORT_CNTMAXSIZEr BCM56800_A0_READ_GPORT_CNTMAXSIZEr
#define WRITE_GPORT_CNTMAXSIZEr BCM56800_A0_WRITE_GPORT_CNTMAXSIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GPORT_CNTMAXSIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GPORT_CONFIG
 * BLOCKS:   GXPORT
 * DESC:     GPORT configuration Register
 * SIZE:     32
 * FIELDS:
 *     GPORT_EN         Enable GPORT.
 *     CLR_CNT          Clear all 12 GE port statistic Counters.
 *     TRIMAC_RESET     Software control TriMAC reset (active High)
 *
 ******************************************************************************/
#define BCM56800_A0_GPORT_CONFIGr 0x00f00a00

#define BCM56800_A0_GPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_CONFIG.
 *
 */
typedef union BCM56800_A0_GPORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t gport_config[1];
	uint32_t _gport_config;
} BCM56800_A0_GPORT_CONFIGr_t;

#define BCM56800_A0_GPORT_CONFIGr_CLR(r) (r).gport_config[0] = 0
#define BCM56800_A0_GPORT_CONFIGr_SET(r,d) (r).gport_config[0] = d
#define BCM56800_A0_GPORT_CONFIGr_GET(r) (r).gport_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GPORT_CONFIGr_GPORT_ENf_GET(r) (((r).gport_config[0]) & 0x1)
#define BCM56800_A0_GPORT_CONFIGr_GPORT_ENf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_GPORT_CONFIGr_CLR_CNTf_GET(r) ((((r).gport_config[0]) >> 1) & 0x1)
#define BCM56800_A0_GPORT_CONFIGr_CLR_CNTf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_GPORT_CONFIGr_TRIMAC_RESETf_GET(r) ((((r).gport_config[0]) >> 2) & 0x1)
#define BCM56800_A0_GPORT_CONFIGr_TRIMAC_RESETf_SET(r,f) (r).gport_config[0]=(((r).gport_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access GPORT_CONFIG.
 *
 */
#define BCM56800_A0_READ_GPORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GPORT_CONFIGr,(r._gport_config))
#define BCM56800_A0_WRITE_GPORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GPORT_CONFIGr,&(r._gport_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_CONFIGr BCM56800_A0_GPORT_CONFIGr
#define GPORT_CONFIGr_SIZE BCM56800_A0_GPORT_CONFIGr_SIZE
typedef BCM56800_A0_GPORT_CONFIGr_t GPORT_CONFIGr_t;
#define GPORT_CONFIGr_CLR BCM56800_A0_GPORT_CONFIGr_CLR
#define GPORT_CONFIGr_SET BCM56800_A0_GPORT_CONFIGr_SET
#define GPORT_CONFIGr_GET BCM56800_A0_GPORT_CONFIGr_GET
#define GPORT_CONFIGr_GPORT_ENf_GET BCM56800_A0_GPORT_CONFIGr_GPORT_ENf_GET
#define GPORT_CONFIGr_GPORT_ENf_SET BCM56800_A0_GPORT_CONFIGr_GPORT_ENf_SET
#define GPORT_CONFIGr_CLR_CNTf_GET BCM56800_A0_GPORT_CONFIGr_CLR_CNTf_GET
#define GPORT_CONFIGr_CLR_CNTf_SET BCM56800_A0_GPORT_CONFIGr_CLR_CNTf_SET
#define GPORT_CONFIGr_TRIMAC_RESETf_GET BCM56800_A0_GPORT_CONFIGr_TRIMAC_RESETf_GET
#define GPORT_CONFIGr_TRIMAC_RESETf_SET BCM56800_A0_GPORT_CONFIGr_TRIMAC_RESETf_SET
#define READ_GPORT_CONFIGr BCM56800_A0_READ_GPORT_CONFIGr
#define WRITE_GPORT_CONFIGr BCM56800_A0_WRITE_GPORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GPORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GPORT_RSV_MASK
 * BLOCKS:   GXPORT
 * DESC:     GPORT RSV MASK register, used to purge packet data received from the MACs
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV bits cause packets to be purged
 *
 ******************************************************************************/
#define BCM56800_A0_GPORT_RSV_MASKr 0x00f00a01

#define BCM56800_A0_GPORT_RSV_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_RSV_MASK.
 *
 */
typedef union BCM56800_A0_GPORT_RSV_MASKr_s {
	uint32_t v[1];
	uint32_t gport_rsv_mask[1];
	uint32_t _gport_rsv_mask;
} BCM56800_A0_GPORT_RSV_MASKr_t;

#define BCM56800_A0_GPORT_RSV_MASKr_CLR(r) (r).gport_rsv_mask[0] = 0
#define BCM56800_A0_GPORT_RSV_MASKr_SET(r,d) (r).gport_rsv_mask[0] = d
#define BCM56800_A0_GPORT_RSV_MASKr_GET(r) (r).gport_rsv_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GPORT_RSV_MASKr_MASKf_GET(r) ((((r).gport_rsv_mask[0]) >> 16) & 0x7fff)
#define BCM56800_A0_GPORT_RSV_MASKr_MASKf_SET(r,f) (r).gport_rsv_mask[0]=(((r).gport_rsv_mask[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))

/*
 * These macros can be used to access GPORT_RSV_MASK.
 *
 */
#define BCM56800_A0_READ_GPORT_RSV_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GPORT_RSV_MASKr,(r._gport_rsv_mask))
#define BCM56800_A0_WRITE_GPORT_RSV_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GPORT_RSV_MASKr,&(r._gport_rsv_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_RSV_MASKr BCM56800_A0_GPORT_RSV_MASKr
#define GPORT_RSV_MASKr_SIZE BCM56800_A0_GPORT_RSV_MASKr_SIZE
typedef BCM56800_A0_GPORT_RSV_MASKr_t GPORT_RSV_MASKr_t;
#define GPORT_RSV_MASKr_CLR BCM56800_A0_GPORT_RSV_MASKr_CLR
#define GPORT_RSV_MASKr_SET BCM56800_A0_GPORT_RSV_MASKr_SET
#define GPORT_RSV_MASKr_GET BCM56800_A0_GPORT_RSV_MASKr_GET
#define GPORT_RSV_MASKr_MASKf_GET BCM56800_A0_GPORT_RSV_MASKr_MASKf_GET
#define GPORT_RSV_MASKr_MASKf_SET BCM56800_A0_GPORT_RSV_MASKr_MASKf_SET
#define READ_GPORT_RSV_MASKr BCM56800_A0_READ_GPORT_RSV_MASKr
#define WRITE_GPORT_RSV_MASKr BCM56800_A0_WRITE_GPORT_RSV_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GPORT_RSV_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GPORT_STAT_UPDATE_MASK
 * BLOCKS:   GXPORT
 * DESC:     GPORT STAT_UPDATE MASK register, used to control the statistic counter update in the Ingress
 * SIZE:     32
 * FIELDS:
 *     MASK             Control which RSV event should have the statistic counter updated in the Ingress.
 *
 ******************************************************************************/
#define BCM56800_A0_GPORT_STAT_UPDATE_MASKr 0x00f00a02

#define BCM56800_A0_GPORT_STAT_UPDATE_MASKr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_STAT_UPDATE_MASK.
 *
 */
typedef union BCM56800_A0_GPORT_STAT_UPDATE_MASKr_s {
	uint32_t v[1];
	uint32_t gport_stat_update_mask[1];
	uint32_t _gport_stat_update_mask;
} BCM56800_A0_GPORT_STAT_UPDATE_MASKr_t;

#define BCM56800_A0_GPORT_STAT_UPDATE_MASKr_CLR(r) (r).gport_stat_update_mask[0] = 0
#define BCM56800_A0_GPORT_STAT_UPDATE_MASKr_SET(r,d) (r).gport_stat_update_mask[0] = d
#define BCM56800_A0_GPORT_STAT_UPDATE_MASKr_GET(r) (r).gport_stat_update_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GPORT_STAT_UPDATE_MASKr_MASKf_GET(r) ((((r).gport_stat_update_mask[0]) >> 16) & 0x7fff)
#define BCM56800_A0_GPORT_STAT_UPDATE_MASKr_MASKf_SET(r,f) (r).gport_stat_update_mask[0]=(((r).gport_stat_update_mask[0] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))

/*
 * These macros can be used to access GPORT_STAT_UPDATE_MASK.
 *
 */
#define BCM56800_A0_READ_GPORT_STAT_UPDATE_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GPORT_STAT_UPDATE_MASKr,(r._gport_stat_update_mask))
#define BCM56800_A0_WRITE_GPORT_STAT_UPDATE_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GPORT_STAT_UPDATE_MASKr,&(r._gport_stat_update_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_STAT_UPDATE_MASKr BCM56800_A0_GPORT_STAT_UPDATE_MASKr
#define GPORT_STAT_UPDATE_MASKr_SIZE BCM56800_A0_GPORT_STAT_UPDATE_MASKr_SIZE
typedef BCM56800_A0_GPORT_STAT_UPDATE_MASKr_t GPORT_STAT_UPDATE_MASKr_t;
#define GPORT_STAT_UPDATE_MASKr_CLR BCM56800_A0_GPORT_STAT_UPDATE_MASKr_CLR
#define GPORT_STAT_UPDATE_MASKr_SET BCM56800_A0_GPORT_STAT_UPDATE_MASKr_SET
#define GPORT_STAT_UPDATE_MASKr_GET BCM56800_A0_GPORT_STAT_UPDATE_MASKr_GET
#define GPORT_STAT_UPDATE_MASKr_MASKf_GET BCM56800_A0_GPORT_STAT_UPDATE_MASKr_MASKf_GET
#define GPORT_STAT_UPDATE_MASKr_MASKf_SET BCM56800_A0_GPORT_STAT_UPDATE_MASKr_MASKf_SET
#define READ_GPORT_STAT_UPDATE_MASKr BCM56800_A0_READ_GPORT_STAT_UPDATE_MASKr
#define WRITE_GPORT_STAT_UPDATE_MASKr BCM56800_A0_WRITE_GPORT_STAT_UPDATE_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GPORT_STAT_UPDATE_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GPORT_TPID
 * BLOCKS:   GXPORT
 * DESC:     GPORT VLAN Tag Protocol ID
 * SIZE:     32
 * FIELDS:
 *     TPID             Used in TriMAC to detect VLAN tagged packets.
 *
 ******************************************************************************/
#define BCM56800_A0_GPORT_TPIDr 0x00f00a07

#define BCM56800_A0_GPORT_TPIDr_SIZE 4

/*
 * This structure should be used to declare and program GPORT_TPID.
 *
 */
typedef union BCM56800_A0_GPORT_TPIDr_s {
	uint32_t v[1];
	uint32_t gport_tpid[1];
	uint32_t _gport_tpid;
} BCM56800_A0_GPORT_TPIDr_t;

#define BCM56800_A0_GPORT_TPIDr_CLR(r) (r).gport_tpid[0] = 0
#define BCM56800_A0_GPORT_TPIDr_SET(r,d) (r).gport_tpid[0] = d
#define BCM56800_A0_GPORT_TPIDr_GET(r) (r).gport_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GPORT_TPIDr_TPIDf_GET(r) (((r).gport_tpid[0]) & 0xffff)
#define BCM56800_A0_GPORT_TPIDr_TPIDf_SET(r,f) (r).gport_tpid[0]=(((r).gport_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access GPORT_TPID.
 *
 */
#define BCM56800_A0_READ_GPORT_TPIDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GPORT_TPIDr,(r._gport_tpid))
#define BCM56800_A0_WRITE_GPORT_TPIDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GPORT_TPIDr,&(r._gport_tpid))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GPORT_TPIDr BCM56800_A0_GPORT_TPIDr
#define GPORT_TPIDr_SIZE BCM56800_A0_GPORT_TPIDr_SIZE
typedef BCM56800_A0_GPORT_TPIDr_t GPORT_TPIDr_t;
#define GPORT_TPIDr_CLR BCM56800_A0_GPORT_TPIDr_CLR
#define GPORT_TPIDr_SET BCM56800_A0_GPORT_TPIDr_SET
#define GPORT_TPIDr_GET BCM56800_A0_GPORT_TPIDr_GET
#define GPORT_TPIDr_TPIDf_GET BCM56800_A0_GPORT_TPIDr_TPIDf_GET
#define GPORT_TPIDr_TPIDf_SET BCM56800_A0_GPORT_TPIDr_TPIDf_SET
#define READ_GPORT_TPIDr BCM56800_A0_READ_GPORT_TPIDr
#define WRITE_GPORT_TPIDr BCM56800_A0_WRITE_GPORT_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GPORT_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR1023
 * BLOCKS:   GXPORT
 * DESC:     Receive 512 to 1023 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR1023r 0x00f0004b

#define BCM56800_A0_GR1023r_SIZE 4

/*
 * This structure should be used to declare and program GR1023.
 *
 */
typedef union BCM56800_A0_GR1023r_s {
	uint32_t v[1];
	uint32_t gr1023[1];
	uint32_t _gr1023;
} BCM56800_A0_GR1023r_t;

#define BCM56800_A0_GR1023r_CLR(r) (r).gr1023[0] = 0
#define BCM56800_A0_GR1023r_SET(r,d) (r).gr1023[0] = d
#define BCM56800_A0_GR1023r_GET(r) (r).gr1023[0]


/*
 * These macros can be used to access GR1023.
 *
 */
#define BCM56800_A0_READ_GR1023r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR1023r,(r._gr1023))
#define BCM56800_A0_WRITE_GR1023r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR1023r,&(r._gr1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR1023r BCM56800_A0_GR1023r
#define GR1023r_SIZE BCM56800_A0_GR1023r_SIZE
typedef BCM56800_A0_GR1023r_t GR1023r_t;
#define GR1023r_CLR BCM56800_A0_GR1023r_CLR
#define GR1023r_SET BCM56800_A0_GR1023r_SET
#define GR1023r_GET BCM56800_A0_GR1023r_GET
#define READ_GR1023r BCM56800_A0_READ_GR1023r
#define WRITE_GR1023r BCM56800_A0_WRITE_GR1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR127
 * BLOCKS:   GXPORT
 * DESC:     Receive 65 to 127 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR127r 0x00f00048

#define BCM56800_A0_GR127r_SIZE 4

/*
 * This structure should be used to declare and program GR127.
 *
 */
typedef union BCM56800_A0_GR127r_s {
	uint32_t v[1];
	uint32_t gr127[1];
	uint32_t _gr127;
} BCM56800_A0_GR127r_t;

#define BCM56800_A0_GR127r_CLR(r) (r).gr127[0] = 0
#define BCM56800_A0_GR127r_SET(r,d) (r).gr127[0] = d
#define BCM56800_A0_GR127r_GET(r) (r).gr127[0]


/*
 * These macros can be used to access GR127.
 *
 */
#define BCM56800_A0_READ_GR127r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR127r,(r._gr127))
#define BCM56800_A0_WRITE_GR127r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR127r,&(r._gr127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR127r BCM56800_A0_GR127r
#define GR127r_SIZE BCM56800_A0_GR127r_SIZE
typedef BCM56800_A0_GR127r_t GR127r_t;
#define GR127r_CLR BCM56800_A0_GR127r_CLR
#define GR127r_SET BCM56800_A0_GR127r_SET
#define GR127r_GET BCM56800_A0_GR127r_GET
#define READ_GR127r BCM56800_A0_READ_GR127r
#define WRITE_GR127r BCM56800_A0_WRITE_GR127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR1518
 * BLOCKS:   GXPORT
 * DESC:     Receive 1024 to 1518 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR1518r 0x00f0004c

#define BCM56800_A0_GR1518r_SIZE 4

/*
 * This structure should be used to declare and program GR1518.
 *
 */
typedef union BCM56800_A0_GR1518r_s {
	uint32_t v[1];
	uint32_t gr1518[1];
	uint32_t _gr1518;
} BCM56800_A0_GR1518r_t;

#define BCM56800_A0_GR1518r_CLR(r) (r).gr1518[0] = 0
#define BCM56800_A0_GR1518r_SET(r,d) (r).gr1518[0] = d
#define BCM56800_A0_GR1518r_GET(r) (r).gr1518[0]


/*
 * These macros can be used to access GR1518.
 *
 */
#define BCM56800_A0_READ_GR1518r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR1518r,(r._gr1518))
#define BCM56800_A0_WRITE_GR1518r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR1518r,&(r._gr1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR1518r BCM56800_A0_GR1518r
#define GR1518r_SIZE BCM56800_A0_GR1518r_SIZE
typedef BCM56800_A0_GR1518r_t GR1518r_t;
#define GR1518r_CLR BCM56800_A0_GR1518r_CLR
#define GR1518r_SET BCM56800_A0_GR1518r_SET
#define GR1518r_GET BCM56800_A0_GR1518r_GET
#define READ_GR1518r BCM56800_A0_READ_GR1518r
#define WRITE_GR1518r BCM56800_A0_WRITE_GR1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR2047
 * BLOCKS:   GXPORT
 * DESC:     Receive 1519 to 2047 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR2047r 0x00f0004e

#define BCM56800_A0_GR2047r_SIZE 4

/*
 * This structure should be used to declare and program GR2047.
 *
 */
typedef union BCM56800_A0_GR2047r_s {
	uint32_t v[1];
	uint32_t gr2047[1];
	uint32_t _gr2047;
} BCM56800_A0_GR2047r_t;

#define BCM56800_A0_GR2047r_CLR(r) (r).gr2047[0] = 0
#define BCM56800_A0_GR2047r_SET(r,d) (r).gr2047[0] = d
#define BCM56800_A0_GR2047r_GET(r) (r).gr2047[0]


/*
 * These macros can be used to access GR2047.
 *
 */
#define BCM56800_A0_READ_GR2047r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR2047r,(r._gr2047))
#define BCM56800_A0_WRITE_GR2047r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR2047r,&(r._gr2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR2047r BCM56800_A0_GR2047r
#define GR2047r_SIZE BCM56800_A0_GR2047r_SIZE
typedef BCM56800_A0_GR2047r_t GR2047r_t;
#define GR2047r_CLR BCM56800_A0_GR2047r_CLR
#define GR2047r_SET BCM56800_A0_GR2047r_SET
#define GR2047r_GET BCM56800_A0_GR2047r_GET
#define READ_GR2047r BCM56800_A0_READ_GR2047r
#define WRITE_GR2047r BCM56800_A0_WRITE_GR2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR255
 * BLOCKS:   GXPORT
 * DESC:     Receive 128 to 255 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR255r 0x00f00049

#define BCM56800_A0_GR255r_SIZE 4

/*
 * This structure should be used to declare and program GR255.
 *
 */
typedef union BCM56800_A0_GR255r_s {
	uint32_t v[1];
	uint32_t gr255[1];
	uint32_t _gr255;
} BCM56800_A0_GR255r_t;

#define BCM56800_A0_GR255r_CLR(r) (r).gr255[0] = 0
#define BCM56800_A0_GR255r_SET(r,d) (r).gr255[0] = d
#define BCM56800_A0_GR255r_GET(r) (r).gr255[0]


/*
 * These macros can be used to access GR255.
 *
 */
#define BCM56800_A0_READ_GR255r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR255r,(r._gr255))
#define BCM56800_A0_WRITE_GR255r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR255r,&(r._gr255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR255r BCM56800_A0_GR255r
#define GR255r_SIZE BCM56800_A0_GR255r_SIZE
typedef BCM56800_A0_GR255r_t GR255r_t;
#define GR255r_CLR BCM56800_A0_GR255r_CLR
#define GR255r_SET BCM56800_A0_GR255r_SET
#define GR255r_GET BCM56800_A0_GR255r_GET
#define READ_GR255r BCM56800_A0_READ_GR255r
#define WRITE_GR255r BCM56800_A0_WRITE_GR255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR4095
 * BLOCKS:   GXPORT
 * DESC:     Receive 2048 to 4095 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR4095r 0x00f0004f

#define BCM56800_A0_GR4095r_SIZE 4

/*
 * This structure should be used to declare and program GR4095.
 *
 */
typedef union BCM56800_A0_GR4095r_s {
	uint32_t v[1];
	uint32_t gr4095[1];
	uint32_t _gr4095;
} BCM56800_A0_GR4095r_t;

#define BCM56800_A0_GR4095r_CLR(r) (r).gr4095[0] = 0
#define BCM56800_A0_GR4095r_SET(r,d) (r).gr4095[0] = d
#define BCM56800_A0_GR4095r_GET(r) (r).gr4095[0]


/*
 * These macros can be used to access GR4095.
 *
 */
#define BCM56800_A0_READ_GR4095r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR4095r,(r._gr4095))
#define BCM56800_A0_WRITE_GR4095r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR4095r,&(r._gr4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR4095r BCM56800_A0_GR4095r
#define GR4095r_SIZE BCM56800_A0_GR4095r_SIZE
typedef BCM56800_A0_GR4095r_t GR4095r_t;
#define GR4095r_CLR BCM56800_A0_GR4095r_CLR
#define GR4095r_SET BCM56800_A0_GR4095r_SET
#define GR4095r_GET BCM56800_A0_GR4095r_GET
#define READ_GR4095r BCM56800_A0_READ_GR4095r
#define WRITE_GR4095r BCM56800_A0_WRITE_GR4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR511
 * BLOCKS:   GXPORT
 * DESC:     Receive 256 to 511 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR511r 0x00f0004a

#define BCM56800_A0_GR511r_SIZE 4

/*
 * This structure should be used to declare and program GR511.
 *
 */
typedef union BCM56800_A0_GR511r_s {
	uint32_t v[1];
	uint32_t gr511[1];
	uint32_t _gr511;
} BCM56800_A0_GR511r_t;

#define BCM56800_A0_GR511r_CLR(r) (r).gr511[0] = 0
#define BCM56800_A0_GR511r_SET(r,d) (r).gr511[0] = d
#define BCM56800_A0_GR511r_GET(r) (r).gr511[0]


/*
 * These macros can be used to access GR511.
 *
 */
#define BCM56800_A0_READ_GR511r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR511r,(r._gr511))
#define BCM56800_A0_WRITE_GR511r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR511r,&(r._gr511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR511r BCM56800_A0_GR511r
#define GR511r_SIZE BCM56800_A0_GR511r_SIZE
typedef BCM56800_A0_GR511r_t GR511r_t;
#define GR511r_CLR BCM56800_A0_GR511r_CLR
#define GR511r_SET BCM56800_A0_GR511r_SET
#define GR511r_GET BCM56800_A0_GR511r_GET
#define READ_GR511r BCM56800_A0_READ_GR511r
#define WRITE_GR511r BCM56800_A0_WRITE_GR511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR64
 * BLOCKS:   GXPORT
 * DESC:     Receive 64 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR64r 0x00f00047

#define BCM56800_A0_GR64r_SIZE 4

/*
 * This structure should be used to declare and program GR64.
 *
 */
typedef union BCM56800_A0_GR64r_s {
	uint32_t v[1];
	uint32_t gr64[1];
	uint32_t _gr64;
} BCM56800_A0_GR64r_t;

#define BCM56800_A0_GR64r_CLR(r) (r).gr64[0] = 0
#define BCM56800_A0_GR64r_SET(r,d) (r).gr64[0] = d
#define BCM56800_A0_GR64r_GET(r) (r).gr64[0]


/*
 * These macros can be used to access GR64.
 *
 */
#define BCM56800_A0_READ_GR64r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR64r,(r._gr64))
#define BCM56800_A0_WRITE_GR64r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR64r,&(r._gr64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR64r BCM56800_A0_GR64r
#define GR64r_SIZE BCM56800_A0_GR64r_SIZE
typedef BCM56800_A0_GR64r_t GR64r_t;
#define GR64r_CLR BCM56800_A0_GR64r_CLR
#define GR64r_SET BCM56800_A0_GR64r_SET
#define GR64r_GET BCM56800_A0_GR64r_GET
#define READ_GR64r BCM56800_A0_READ_GR64r
#define WRITE_GR64r BCM56800_A0_WRITE_GR64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GR9216
 * BLOCKS:   GXPORT
 * DESC:     Receive 4096 to 9216 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GR9216r 0x00f00050

#define BCM56800_A0_GR9216r_SIZE 4

/*
 * This structure should be used to declare and program GR9216.
 *
 */
typedef union BCM56800_A0_GR9216r_s {
	uint32_t v[1];
	uint32_t gr9216[1];
	uint32_t _gr9216;
} BCM56800_A0_GR9216r_t;

#define BCM56800_A0_GR9216r_CLR(r) (r).gr9216[0] = 0
#define BCM56800_A0_GR9216r_SET(r,d) (r).gr9216[0] = d
#define BCM56800_A0_GR9216r_GET(r) (r).gr9216[0]


/*
 * These macros can be used to access GR9216.
 *
 */
#define BCM56800_A0_READ_GR9216r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GR9216r,(r._gr9216))
#define BCM56800_A0_WRITE_GR9216r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GR9216r,&(r._gr9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GR9216r BCM56800_A0_GR9216r
#define GR9216r_SIZE BCM56800_A0_GR9216r_SIZE
typedef BCM56800_A0_GR9216r_t GR9216r_t;
#define GR9216r_CLR BCM56800_A0_GR9216r_CLR
#define GR9216r_SET BCM56800_A0_GR9216r_SET
#define GR9216r_GET BCM56800_A0_GR9216r_GET
#define READ_GR9216r BCM56800_A0_READ_GR9216r
#define WRITE_GR9216r BCM56800_A0_WRITE_GR9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GR9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRALN
 * BLOCKS:   GXPORT
 * DESC:     Receive Alignment Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRALNr 0x00f00059

#define BCM56800_A0_GRALNr_SIZE 4

/*
 * This structure should be used to declare and program GRALN.
 *
 */
typedef union BCM56800_A0_GRALNr_s {
	uint32_t v[1];
	uint32_t graln[1];
	uint32_t _graln;
} BCM56800_A0_GRALNr_t;

#define BCM56800_A0_GRALNr_CLR(r) (r).graln[0] = 0
#define BCM56800_A0_GRALNr_SET(r,d) (r).graln[0] = d
#define BCM56800_A0_GRALNr_GET(r) (r).graln[0]


/*
 * These macros can be used to access GRALN.
 *
 */
#define BCM56800_A0_READ_GRALNr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRALNr,(r._graln))
#define BCM56800_A0_WRITE_GRALNr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRALNr,&(r._graln))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRALNr BCM56800_A0_GRALNr
#define GRALNr_SIZE BCM56800_A0_GRALNr_SIZE
typedef BCM56800_A0_GRALNr_t GRALNr_t;
#define GRALNr_CLR BCM56800_A0_GRALNr_CLR
#define GRALNr_SET BCM56800_A0_GRALNr_SET
#define GRALNr_GET BCM56800_A0_GRALNr_GET
#define READ_GRALNr BCM56800_A0_READ_GRALNr
#define WRITE_GRALNr BCM56800_A0_WRITE_GRALNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRALNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRBCA
 * BLOCKS:   GXPORT
 * DESC:     Receive Broadcast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRBCAr 0x00f00054

#define BCM56800_A0_GRBCAr_SIZE 4

/*
 * This structure should be used to declare and program GRBCA.
 *
 */
typedef union BCM56800_A0_GRBCAr_s {
	uint32_t v[1];
	uint32_t grbca[1];
	uint32_t _grbca;
} BCM56800_A0_GRBCAr_t;

#define BCM56800_A0_GRBCAr_CLR(r) (r).grbca[0] = 0
#define BCM56800_A0_GRBCAr_SET(r,d) (r).grbca[0] = d
#define BCM56800_A0_GRBCAr_GET(r) (r).grbca[0]


/*
 * These macros can be used to access GRBCA.
 *
 */
#define BCM56800_A0_READ_GRBCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRBCAr,(r._grbca))
#define BCM56800_A0_WRITE_GRBCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRBCAr,&(r._grbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRBCAr BCM56800_A0_GRBCAr
#define GRBCAr_SIZE BCM56800_A0_GRBCAr_SIZE
typedef BCM56800_A0_GRBCAr_t GRBCAr_t;
#define GRBCAr_CLR BCM56800_A0_GRBCAr_CLR
#define GRBCAr_SET BCM56800_A0_GRBCAr_SET
#define GRBCAr_GET BCM56800_A0_GRBCAr_GET
#define READ_GRBCAr BCM56800_A0_READ_GRBCAr
#define WRITE_GRBCAr BCM56800_A0_WRITE_GRBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRBYT
 * BLOCKS:   GXPORT
 * DESC:     Receive Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRBYTr 0x00f00052

#define BCM56800_A0_GRBYTr_SIZE 4

/*
 * This structure should be used to declare and program GRBYT.
 *
 */
typedef union BCM56800_A0_GRBYTr_s {
	uint32_t v[1];
	uint32_t grbyt[1];
	uint32_t _grbyt;
} BCM56800_A0_GRBYTr_t;

#define BCM56800_A0_GRBYTr_CLR(r) (r).grbyt[0] = 0
#define BCM56800_A0_GRBYTr_SET(r,d) (r).grbyt[0] = d
#define BCM56800_A0_GRBYTr_GET(r) (r).grbyt[0]


/*
 * These macros can be used to access GRBYT.
 *
 */
#define BCM56800_A0_READ_GRBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRBYTr,(r._grbyt))
#define BCM56800_A0_WRITE_GRBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRBYTr,&(r._grbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRBYTr BCM56800_A0_GRBYTr
#define GRBYTr_SIZE BCM56800_A0_GRBYTr_SIZE
typedef BCM56800_A0_GRBYTr_t GRBYTr_t;
#define GRBYTr_CLR BCM56800_A0_GRBYTr_CLR
#define GRBYTr_SET BCM56800_A0_GRBYTr_SET
#define GRBYTr_GET BCM56800_A0_GRBYTr_GET
#define READ_GRBYTr BCM56800_A0_READ_GRBYTr
#define WRITE_GRBYTr BCM56800_A0_WRITE_GRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRCDE
 * BLOCKS:   GXPORT
 * DESC:     Receive Code Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRCDEr 0x00f0005b

#define BCM56800_A0_GRCDEr_SIZE 4

/*
 * This structure should be used to declare and program GRCDE.
 *
 */
typedef union BCM56800_A0_GRCDEr_s {
	uint32_t v[1];
	uint32_t grcde[1];
	uint32_t _grcde;
} BCM56800_A0_GRCDEr_t;

#define BCM56800_A0_GRCDEr_CLR(r) (r).grcde[0] = 0
#define BCM56800_A0_GRCDEr_SET(r,d) (r).grcde[0] = d
#define BCM56800_A0_GRCDEr_GET(r) (r).grcde[0]


/*
 * These macros can be used to access GRCDE.
 *
 */
#define BCM56800_A0_READ_GRCDEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRCDEr,(r._grcde))
#define BCM56800_A0_WRITE_GRCDEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRCDEr,&(r._grcde))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRCDEr BCM56800_A0_GRCDEr
#define GRCDEr_SIZE BCM56800_A0_GRCDEr_SIZE
typedef BCM56800_A0_GRCDEr_t GRCDEr_t;
#define GRCDEr_CLR BCM56800_A0_GRCDEr_CLR
#define GRCDEr_SET BCM56800_A0_GRCDEr_SET
#define GRCDEr_GET BCM56800_A0_GRCDEr_GET
#define READ_GRCDEr BCM56800_A0_READ_GRCDEr
#define WRITE_GRCDEr BCM56800_A0_WRITE_GRCDEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRCDEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRFCR
 * BLOCKS:   GXPORT
 * DESC:     Receive False Carrier Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRFCRr 0x00f0005c

#define BCM56800_A0_GRFCRr_SIZE 4

/*
 * This structure should be used to declare and program GRFCR.
 *
 */
typedef union BCM56800_A0_GRFCRr_s {
	uint32_t v[1];
	uint32_t grfcr[1];
	uint32_t _grfcr;
} BCM56800_A0_GRFCRr_t;

#define BCM56800_A0_GRFCRr_CLR(r) (r).grfcr[0] = 0
#define BCM56800_A0_GRFCRr_SET(r,d) (r).grfcr[0] = d
#define BCM56800_A0_GRFCRr_GET(r) (r).grfcr[0]


/*
 * These macros can be used to access GRFCR.
 *
 */
#define BCM56800_A0_READ_GRFCRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRFCRr,(r._grfcr))
#define BCM56800_A0_WRITE_GRFCRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRFCRr,&(r._grfcr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFCRr BCM56800_A0_GRFCRr
#define GRFCRr_SIZE BCM56800_A0_GRFCRr_SIZE
typedef BCM56800_A0_GRFCRr_t GRFCRr_t;
#define GRFCRr_CLR BCM56800_A0_GRFCRr_CLR
#define GRFCRr_SET BCM56800_A0_GRFCRr_SET
#define GRFCRr_GET BCM56800_A0_GRFCRr_GET
#define READ_GRFCRr BCM56800_A0_READ_GRFCRr
#define WRITE_GRFCRr BCM56800_A0_WRITE_GRFCRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRFCRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRFCS
 * BLOCKS:   GXPORT
 * DESC:     Receive FCS Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRFCSr 0x00f00055

#define BCM56800_A0_GRFCSr_SIZE 4

/*
 * This structure should be used to declare and program GRFCS.
 *
 */
typedef union BCM56800_A0_GRFCSr_s {
	uint32_t v[1];
	uint32_t grfcs[1];
	uint32_t _grfcs;
} BCM56800_A0_GRFCSr_t;

#define BCM56800_A0_GRFCSr_CLR(r) (r).grfcs[0] = 0
#define BCM56800_A0_GRFCSr_SET(r,d) (r).grfcs[0] = d
#define BCM56800_A0_GRFCSr_GET(r) (r).grfcs[0]


/*
 * These macros can be used to access GRFCS.
 *
 */
#define BCM56800_A0_READ_GRFCSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRFCSr,(r._grfcs))
#define BCM56800_A0_WRITE_GRFCSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRFCSr,&(r._grfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFCSr BCM56800_A0_GRFCSr
#define GRFCSr_SIZE BCM56800_A0_GRFCSr_SIZE
typedef BCM56800_A0_GRFCSr_t GRFCSr_t;
#define GRFCSr_CLR BCM56800_A0_GRFCSr_CLR
#define GRFCSr_SET BCM56800_A0_GRFCSr_SET
#define GRFCSr_GET BCM56800_A0_GRFCSr_GET
#define READ_GRFCSr BCM56800_A0_READ_GRFCSr
#define WRITE_GRFCSr BCM56800_A0_WRITE_GRFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRFLR
 * BLOCKS:   GXPORT
 * DESC:     Receive Length Out of Range Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRFLRr 0x00f0005a

#define BCM56800_A0_GRFLRr_SIZE 4

/*
 * This structure should be used to declare and program GRFLR.
 *
 */
typedef union BCM56800_A0_GRFLRr_s {
	uint32_t v[1];
	uint32_t grflr[1];
	uint32_t _grflr;
} BCM56800_A0_GRFLRr_t;

#define BCM56800_A0_GRFLRr_CLR(r) (r).grflr[0] = 0
#define BCM56800_A0_GRFLRr_SET(r,d) (r).grflr[0] = d
#define BCM56800_A0_GRFLRr_GET(r) (r).grflr[0]


/*
 * These macros can be used to access GRFLR.
 *
 */
#define BCM56800_A0_READ_GRFLRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRFLRr,(r._grflr))
#define BCM56800_A0_WRITE_GRFLRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRFLRr,&(r._grflr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFLRr BCM56800_A0_GRFLRr
#define GRFLRr_SIZE BCM56800_A0_GRFLRr_SIZE
typedef BCM56800_A0_GRFLRr_t GRFLRr_t;
#define GRFLRr_CLR BCM56800_A0_GRFLRr_CLR
#define GRFLRr_SET BCM56800_A0_GRFLRr_SET
#define GRFLRr_GET BCM56800_A0_GRFLRr_GET
#define READ_GRFLRr BCM56800_A0_READ_GRFLRr
#define WRITE_GRFLRr BCM56800_A0_WRITE_GRFLRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRFLRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRFRG
 * BLOCKS:   GXPORT
 * DESC:     Receive Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRFRGr 0x00f00062

#define BCM56800_A0_GRFRGr_SIZE 4

/*
 * This structure should be used to declare and program GRFRG.
 *
 */
typedef union BCM56800_A0_GRFRGr_s {
	uint32_t v[1];
	uint32_t grfrg[1];
	uint32_t _grfrg;
} BCM56800_A0_GRFRGr_t;

#define BCM56800_A0_GRFRGr_CLR(r) (r).grfrg[0] = 0
#define BCM56800_A0_GRFRGr_SET(r,d) (r).grfrg[0] = d
#define BCM56800_A0_GRFRGr_GET(r) (r).grfrg[0]


/*
 * These macros can be used to access GRFRG.
 *
 */
#define BCM56800_A0_READ_GRFRGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRFRGr,(r._grfrg))
#define BCM56800_A0_WRITE_GRFRGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRFRGr,&(r._grfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRFRGr BCM56800_A0_GRFRGr
#define GRFRGr_SIZE BCM56800_A0_GRFRGr_SIZE
typedef BCM56800_A0_GRFRGr_t GRFRGr_t;
#define GRFRGr_CLR BCM56800_A0_GRFRGr_CLR
#define GRFRGr_SET BCM56800_A0_GRFRGr_SET
#define GRFRGr_GET BCM56800_A0_GRFRGr_GET
#define READ_GRFRGr BCM56800_A0_READ_GRFRGr
#define WRITE_GRFRGr BCM56800_A0_WRITE_GRFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRJBR
 * BLOCKS:   GXPORT
 * DESC:     Receive Jabber Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRJBRr 0x00f0005e

#define BCM56800_A0_GRJBRr_SIZE 4

/*
 * This structure should be used to declare and program GRJBR.
 *
 */
typedef union BCM56800_A0_GRJBRr_s {
	uint32_t v[1];
	uint32_t grjbr[1];
	uint32_t _grjbr;
} BCM56800_A0_GRJBRr_t;

#define BCM56800_A0_GRJBRr_CLR(r) (r).grjbr[0] = 0
#define BCM56800_A0_GRJBRr_SET(r,d) (r).grjbr[0] = d
#define BCM56800_A0_GRJBRr_GET(r) (r).grjbr[0]


/*
 * These macros can be used to access GRJBR.
 *
 */
#define BCM56800_A0_READ_GRJBRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRJBRr,(r._grjbr))
#define BCM56800_A0_WRITE_GRJBRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRJBRr,&(r._grjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRJBRr BCM56800_A0_GRJBRr
#define GRJBRr_SIZE BCM56800_A0_GRJBRr_SIZE
typedef BCM56800_A0_GRJBRr_t GRJBRr_t;
#define GRJBRr_CLR BCM56800_A0_GRJBRr_CLR
#define GRJBRr_SET BCM56800_A0_GRJBRr_SET
#define GRJBRr_GET BCM56800_A0_GRJBRr_GET
#define READ_GRJBRr BCM56800_A0_READ_GRJBRr
#define WRITE_GRJBRr BCM56800_A0_WRITE_GRJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRMCA
 * BLOCKS:   GXPORT
 * DESC:     Receive Multicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRMCAr 0x00f00053

#define BCM56800_A0_GRMCAr_SIZE 4

/*
 * This structure should be used to declare and program GRMCA.
 *
 */
typedef union BCM56800_A0_GRMCAr_s {
	uint32_t v[1];
	uint32_t grmca[1];
	uint32_t _grmca;
} BCM56800_A0_GRMCAr_t;

#define BCM56800_A0_GRMCAr_CLR(r) (r).grmca[0] = 0
#define BCM56800_A0_GRMCAr_SET(r,d) (r).grmca[0] = d
#define BCM56800_A0_GRMCAr_GET(r) (r).grmca[0]


/*
 * These macros can be used to access GRMCA.
 *
 */
#define BCM56800_A0_READ_GRMCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRMCAr,(r._grmca))
#define BCM56800_A0_WRITE_GRMCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRMCAr,&(r._grmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMCAr BCM56800_A0_GRMCAr
#define GRMCAr_SIZE BCM56800_A0_GRMCAr_SIZE
typedef BCM56800_A0_GRMCAr_t GRMCAr_t;
#define GRMCAr_CLR BCM56800_A0_GRMCAr_CLR
#define GRMCAr_SET BCM56800_A0_GRMCAr_SET
#define GRMCAr_GET BCM56800_A0_GRMCAr_GET
#define READ_GRMCAr BCM56800_A0_READ_GRMCAr
#define WRITE_GRMCAr BCM56800_A0_WRITE_GRMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRMGV
 * BLOCKS:   GXPORT
 * DESC:     Receive 1519 to 1522 Byte Good VLAN Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRMGVr 0x00f0004d

#define BCM56800_A0_GRMGVr_SIZE 4

/*
 * This structure should be used to declare and program GRMGV.
 *
 */
typedef union BCM56800_A0_GRMGVr_s {
	uint32_t v[1];
	uint32_t grmgv[1];
	uint32_t _grmgv;
} BCM56800_A0_GRMGVr_t;

#define BCM56800_A0_GRMGVr_CLR(r) (r).grmgv[0] = 0
#define BCM56800_A0_GRMGVr_SET(r,d) (r).grmgv[0] = d
#define BCM56800_A0_GRMGVr_GET(r) (r).grmgv[0]


/*
 * These macros can be used to access GRMGV.
 *
 */
#define BCM56800_A0_READ_GRMGVr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRMGVr,(r._grmgv))
#define BCM56800_A0_WRITE_GRMGVr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRMGVr,&(r._grmgv))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMGVr BCM56800_A0_GRMGVr
#define GRMGVr_SIZE BCM56800_A0_GRMGVr_SIZE
typedef BCM56800_A0_GRMGVr_t GRMGVr_t;
#define GRMGVr_CLR BCM56800_A0_GRMGVr_CLR
#define GRMGVr_SET BCM56800_A0_GRMGVr_SET
#define GRMGVr_GET BCM56800_A0_GRMGVr_GET
#define READ_GRMGVr BCM56800_A0_READ_GRMGVr
#define WRITE_GRMGVr BCM56800_A0_WRITE_GRMGVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRMGVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRMTUE
 * BLOCKS:   GXPORT
 * DESC:     Receive MTU Check Error Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRMTUEr 0x00f0005f

#define BCM56800_A0_GRMTUEr_SIZE 4

/*
 * This structure should be used to declare and program GRMTUE.
 *
 */
typedef union BCM56800_A0_GRMTUEr_s {
	uint32_t v[1];
	uint32_t grmtue[1];
	uint32_t _grmtue;
} BCM56800_A0_GRMTUEr_t;

#define BCM56800_A0_GRMTUEr_CLR(r) (r).grmtue[0] = 0
#define BCM56800_A0_GRMTUEr_SET(r,d) (r).grmtue[0] = d
#define BCM56800_A0_GRMTUEr_GET(r) (r).grmtue[0]


/*
 * These macros can be used to access GRMTUE.
 *
 */
#define BCM56800_A0_READ_GRMTUEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRMTUEr,(r._grmtue))
#define BCM56800_A0_WRITE_GRMTUEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRMTUEr,&(r._grmtue))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRMTUEr BCM56800_A0_GRMTUEr
#define GRMTUEr_SIZE BCM56800_A0_GRMTUEr_SIZE
typedef BCM56800_A0_GRMTUEr_t GRMTUEr_t;
#define GRMTUEr_CLR BCM56800_A0_GRMTUEr_CLR
#define GRMTUEr_SET BCM56800_A0_GRMTUEr_SET
#define GRMTUEr_GET BCM56800_A0_GRMTUEr_GET
#define READ_GRMTUEr BCM56800_A0_READ_GRMTUEr
#define WRITE_GRMTUEr BCM56800_A0_WRITE_GRMTUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRMTUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GROVR
 * BLOCKS:   GXPORT
 * DESC:     Receive Oversized Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GROVRr 0x00f0005d

#define BCM56800_A0_GROVRr_SIZE 4

/*
 * This structure should be used to declare and program GROVR.
 *
 */
typedef union BCM56800_A0_GROVRr_s {
	uint32_t v[1];
	uint32_t grovr[1];
	uint32_t _grovr;
} BCM56800_A0_GROVRr_t;

#define BCM56800_A0_GROVRr_CLR(r) (r).grovr[0] = 0
#define BCM56800_A0_GROVRr_SET(r,d) (r).grovr[0] = d
#define BCM56800_A0_GROVRr_GET(r) (r).grovr[0]


/*
 * These macros can be used to access GROVR.
 *
 */
#define BCM56800_A0_READ_GROVRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GROVRr,(r._grovr))
#define BCM56800_A0_WRITE_GROVRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GROVRr,&(r._grovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GROVRr BCM56800_A0_GROVRr
#define GROVRr_SIZE BCM56800_A0_GROVRr_SIZE
typedef BCM56800_A0_GROVRr_t GROVRr_t;
#define GROVRr_CLR BCM56800_A0_GROVRr_CLR
#define GROVRr_SET BCM56800_A0_GROVRr_SET
#define GROVRr_GET BCM56800_A0_GROVRr_GET
#define READ_GROVRr BCM56800_A0_READ_GROVRr
#define WRITE_GROVRr BCM56800_A0_WRITE_GROVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GROVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRPKT
 * BLOCKS:   GXPORT
 * DESC:     Receive frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRPKTr 0x00f00051

#define BCM56800_A0_GRPKTr_SIZE 4

/*
 * This structure should be used to declare and program GRPKT.
 *
 */
typedef union BCM56800_A0_GRPKTr_s {
	uint32_t v[1];
	uint32_t grpkt[1];
	uint32_t _grpkt;
} BCM56800_A0_GRPKTr_t;

#define BCM56800_A0_GRPKTr_CLR(r) (r).grpkt[0] = 0
#define BCM56800_A0_GRPKTr_SET(r,d) (r).grpkt[0] = d
#define BCM56800_A0_GRPKTr_GET(r) (r).grpkt[0]


/*
 * These macros can be used to access GRPKT.
 *
 */
#define BCM56800_A0_READ_GRPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRPKTr,(r._grpkt))
#define BCM56800_A0_WRITE_GRPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRPKTr,&(r._grpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPKTr BCM56800_A0_GRPKTr
#define GRPKTr_SIZE BCM56800_A0_GRPKTr_SIZE
typedef BCM56800_A0_GRPKTr_t GRPKTr_t;
#define GRPKTr_CLR BCM56800_A0_GRPKTr_CLR
#define GRPKTr_SET BCM56800_A0_GRPKTr_SET
#define GRPKTr_GET BCM56800_A0_GRPKTr_GET
#define READ_GRPKTr BCM56800_A0_READ_GRPKTr
#define WRITE_GRPKTr BCM56800_A0_WRITE_GRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRUND
 * BLOCKS:   GXPORT
 * DESC:     Receive Undersize Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRUNDr 0x00f00061

#define BCM56800_A0_GRUNDr_SIZE 4

/*
 * This structure should be used to declare and program GRUND.
 *
 */
typedef union BCM56800_A0_GRUNDr_s {
	uint32_t v[1];
	uint32_t grund[1];
	uint32_t _grund;
} BCM56800_A0_GRUNDr_t;

#define BCM56800_A0_GRUNDr_CLR(r) (r).grund[0] = 0
#define BCM56800_A0_GRUNDr_SET(r,d) (r).grund[0] = d
#define BCM56800_A0_GRUNDr_GET(r) (r).grund[0]


/*
 * These macros can be used to access GRUND.
 *
 */
#define BCM56800_A0_READ_GRUNDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRUNDr,(r._grund))
#define BCM56800_A0_WRITE_GRUNDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRUNDr,&(r._grund))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRUNDr BCM56800_A0_GRUNDr
#define GRUNDr_SIZE BCM56800_A0_GRUNDr_SIZE
typedef BCM56800_A0_GRUNDr_t GRUNDr_t;
#define GRUNDr_CLR BCM56800_A0_GRUNDr_CLR
#define GRUNDr_SET BCM56800_A0_GRUNDr_SET
#define GRUNDr_GET BCM56800_A0_GRUNDr_GET
#define READ_GRUNDr BCM56800_A0_READ_GRUNDr
#define WRITE_GRUNDr BCM56800_A0_WRITE_GRUNDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRUNDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRXCF
 * BLOCKS:   GXPORT
 * DESC:     Receive Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRXCFr 0x00f00056

#define BCM56800_A0_GRXCFr_SIZE 4

/*
 * This structure should be used to declare and program GRXCF.
 *
 */
typedef union BCM56800_A0_GRXCFr_s {
	uint32_t v[1];
	uint32_t grxcf[1];
	uint32_t _grxcf;
} BCM56800_A0_GRXCFr_t;

#define BCM56800_A0_GRXCFr_CLR(r) (r).grxcf[0] = 0
#define BCM56800_A0_GRXCFr_SET(r,d) (r).grxcf[0] = d
#define BCM56800_A0_GRXCFr_GET(r) (r).grxcf[0]


/*
 * These macros can be used to access GRXCF.
 *
 */
#define BCM56800_A0_READ_GRXCFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRXCFr,(r._grxcf))
#define BCM56800_A0_WRITE_GRXCFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRXCFr,&(r._grxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXCFr BCM56800_A0_GRXCFr
#define GRXCFr_SIZE BCM56800_A0_GRXCFr_SIZE
typedef BCM56800_A0_GRXCFr_t GRXCFr_t;
#define GRXCFr_CLR BCM56800_A0_GRXCFr_CLR
#define GRXCFr_SET BCM56800_A0_GRXCFr_SET
#define GRXCFr_GET BCM56800_A0_GRXCFr_GET
#define READ_GRXCFr BCM56800_A0_READ_GRXCFr
#define WRITE_GRXCFr BCM56800_A0_WRITE_GRXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRXPF
 * BLOCKS:   GXPORT
 * DESC:     Receive Pause Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRXPFr 0x00f00057

#define BCM56800_A0_GRXPFr_SIZE 4

/*
 * This structure should be used to declare and program GRXPF.
 *
 */
typedef union BCM56800_A0_GRXPFr_s {
	uint32_t v[1];
	uint32_t grxpf[1];
	uint32_t _grxpf;
} BCM56800_A0_GRXPFr_t;

#define BCM56800_A0_GRXPFr_CLR(r) (r).grxpf[0] = 0
#define BCM56800_A0_GRXPFr_SET(r,d) (r).grxpf[0] = d
#define BCM56800_A0_GRXPFr_GET(r) (r).grxpf[0]


/*
 * These macros can be used to access GRXPF.
 *
 */
#define BCM56800_A0_READ_GRXPFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRXPFr,(r._grxpf))
#define BCM56800_A0_WRITE_GRXPFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRXPFr,&(r._grxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXPFr BCM56800_A0_GRXPFr
#define GRXPFr_SIZE BCM56800_A0_GRXPFr_SIZE
typedef BCM56800_A0_GRXPFr_t GRXPFr_t;
#define GRXPFr_CLR BCM56800_A0_GRXPFr_CLR
#define GRXPFr_SET BCM56800_A0_GRXPFr_SET
#define GRXPFr_GET BCM56800_A0_GRXPFr_GET
#define READ_GRXPFr BCM56800_A0_READ_GRXPFr
#define WRITE_GRXPFr BCM56800_A0_WRITE_GRXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GRXUO
 * BLOCKS:   GXPORT
 * DESC:     Receive Unsupported Opcode Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GRXUOr 0x00f00058

#define BCM56800_A0_GRXUOr_SIZE 4

/*
 * This structure should be used to declare and program GRXUO.
 *
 */
typedef union BCM56800_A0_GRXUOr_s {
	uint32_t v[1];
	uint32_t grxuo[1];
	uint32_t _grxuo;
} BCM56800_A0_GRXUOr_t;

#define BCM56800_A0_GRXUOr_CLR(r) (r).grxuo[0] = 0
#define BCM56800_A0_GRXUOr_SET(r,d) (r).grxuo[0] = d
#define BCM56800_A0_GRXUOr_GET(r) (r).grxuo[0]


/*
 * These macros can be used to access GRXUO.
 *
 */
#define BCM56800_A0_READ_GRXUOr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GRXUOr,(r._grxuo))
#define BCM56800_A0_WRITE_GRXUOr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GRXUOr,&(r._grxuo))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRXUOr BCM56800_A0_GRXUOr
#define GRXUOr_SIZE BCM56800_A0_GRXUOr_SIZE
typedef BCM56800_A0_GRXUOr_t GRXUOr_t;
#define GRXUOr_CLR BCM56800_A0_GRXUOr_CLR
#define GRXUOr_SET BCM56800_A0_GRXUOr_SET
#define GRXUOr_GET BCM56800_A0_GRXUOr_GET
#define READ_GRXUOr BCM56800_A0_READ_GRXUOr
#define WRITE_GRXUOr BCM56800_A0_WRITE_GRXUOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GRXUOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GSA0
 * BLOCKS:   GXPORT
 * DESC:     Station Address 31:0
 * SIZE:     32
 * FIELDS:
 *     STAD1            STAD bits 47:16
 *
 ******************************************************************************/
#define BCM56800_A0_GSA0r 0x00f00104

#define BCM56800_A0_GSA0r_SIZE 4

/*
 * This structure should be used to declare and program GSA0.
 *
 */
typedef union BCM56800_A0_GSA0r_s {
	uint32_t v[1];
	uint32_t gsa0[1];
	uint32_t _gsa0;
} BCM56800_A0_GSA0r_t;

#define BCM56800_A0_GSA0r_CLR(r) (r).gsa0[0] = 0
#define BCM56800_A0_GSA0r_SET(r,d) (r).gsa0[0] = d
#define BCM56800_A0_GSA0r_GET(r) (r).gsa0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GSA0r_STAD1f_GET(r) ((r).gsa0[0])
#define BCM56800_A0_GSA0r_STAD1f_SET(r,f) (r).gsa0[0]=((uint32_t)f)

/*
 * These macros can be used to access GSA0.
 *
 */
#define BCM56800_A0_READ_GSA0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GSA0r,(r._gsa0))
#define BCM56800_A0_WRITE_GSA0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GSA0r,&(r._gsa0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSA0r BCM56800_A0_GSA0r
#define GSA0r_SIZE BCM56800_A0_GSA0r_SIZE
typedef BCM56800_A0_GSA0r_t GSA0r_t;
#define GSA0r_CLR BCM56800_A0_GSA0r_CLR
#define GSA0r_SET BCM56800_A0_GSA0r_SET
#define GSA0r_GET BCM56800_A0_GSA0r_GET
#define GSA0r_STAD1f_GET BCM56800_A0_GSA0r_STAD1f_GET
#define GSA0r_STAD1f_SET BCM56800_A0_GSA0r_STAD1f_SET
#define READ_GSA0r BCM56800_A0_READ_GSA0r
#define WRITE_GSA0r BCM56800_A0_WRITE_GSA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GSA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GSA1
 * BLOCKS:   GXPORT
 * DESC:     Station Address 47:32
 * SIZE:     32
 * FIELDS:
 *     STAD2            STAD bits 15:0
 *
 ******************************************************************************/
#define BCM56800_A0_GSA1r 0x00f00105

#define BCM56800_A0_GSA1r_SIZE 4

/*
 * This structure should be used to declare and program GSA1.
 *
 */
typedef union BCM56800_A0_GSA1r_s {
	uint32_t v[1];
	uint32_t gsa1[1];
	uint32_t _gsa1;
} BCM56800_A0_GSA1r_t;

#define BCM56800_A0_GSA1r_CLR(r) (r).gsa1[0] = 0
#define BCM56800_A0_GSA1r_SET(r,d) (r).gsa1[0] = d
#define BCM56800_A0_GSA1r_GET(r) (r).gsa1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GSA1r_STAD2f_GET(r) ((((r).gsa1[0]) >> 16) & 0xffff)
#define BCM56800_A0_GSA1r_STAD2f_SET(r,f) (r).gsa1[0]=(((r).gsa1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access GSA1.
 *
 */
#define BCM56800_A0_READ_GSA1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GSA1r,(r._gsa1))
#define BCM56800_A0_WRITE_GSA1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GSA1r,&(r._gsa1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GSA1r BCM56800_A0_GSA1r
#define GSA1r_SIZE BCM56800_A0_GSA1r_SIZE
typedef BCM56800_A0_GSA1r_t GSA1r_t;
#define GSA1r_CLR BCM56800_A0_GSA1r_CLR
#define GSA1r_SET BCM56800_A0_GSA1r_SET
#define GSA1r_GET BCM56800_A0_GSA1r_GET
#define GSA1r_STAD2f_GET BCM56800_A0_GSA1r_STAD2f_GET
#define GSA1r_STAD2f_SET BCM56800_A0_GSA1r_STAD2f_SET
#define READ_GSA1r BCM56800_A0_READ_GSA1r
#define WRITE_GSA1r BCM56800_A0_WRITE_GSA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GSA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT1023
 * BLOCKS:   GXPORT
 * DESC:     Transmit 512 to 1023 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT1023r 0x00f00068

#define BCM56800_A0_GT1023r_SIZE 4

/*
 * This structure should be used to declare and program GT1023.
 *
 */
typedef union BCM56800_A0_GT1023r_s {
	uint32_t v[1];
	uint32_t gt1023[1];
	uint32_t _gt1023;
} BCM56800_A0_GT1023r_t;

#define BCM56800_A0_GT1023r_CLR(r) (r).gt1023[0] = 0
#define BCM56800_A0_GT1023r_SET(r,d) (r).gt1023[0] = d
#define BCM56800_A0_GT1023r_GET(r) (r).gt1023[0]


/*
 * These macros can be used to access GT1023.
 *
 */
#define BCM56800_A0_READ_GT1023r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT1023r,(r._gt1023))
#define BCM56800_A0_WRITE_GT1023r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT1023r,&(r._gt1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT1023r BCM56800_A0_GT1023r
#define GT1023r_SIZE BCM56800_A0_GT1023r_SIZE
typedef BCM56800_A0_GT1023r_t GT1023r_t;
#define GT1023r_CLR BCM56800_A0_GT1023r_CLR
#define GT1023r_SET BCM56800_A0_GT1023r_SET
#define GT1023r_GET BCM56800_A0_GT1023r_GET
#define READ_GT1023r BCM56800_A0_READ_GT1023r
#define WRITE_GT1023r BCM56800_A0_WRITE_GT1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT127
 * BLOCKS:   GXPORT
 * DESC:     Transmit 65 to 127 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT127r 0x00f00065

#define BCM56800_A0_GT127r_SIZE 4

/*
 * This structure should be used to declare and program GT127.
 *
 */
typedef union BCM56800_A0_GT127r_s {
	uint32_t v[1];
	uint32_t gt127[1];
	uint32_t _gt127;
} BCM56800_A0_GT127r_t;

#define BCM56800_A0_GT127r_CLR(r) (r).gt127[0] = 0
#define BCM56800_A0_GT127r_SET(r,d) (r).gt127[0] = d
#define BCM56800_A0_GT127r_GET(r) (r).gt127[0]


/*
 * These macros can be used to access GT127.
 *
 */
#define BCM56800_A0_READ_GT127r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT127r,(r._gt127))
#define BCM56800_A0_WRITE_GT127r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT127r,&(r._gt127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT127r BCM56800_A0_GT127r
#define GT127r_SIZE BCM56800_A0_GT127r_SIZE
typedef BCM56800_A0_GT127r_t GT127r_t;
#define GT127r_CLR BCM56800_A0_GT127r_CLR
#define GT127r_SET BCM56800_A0_GT127r_SET
#define GT127r_GET BCM56800_A0_GT127r_GET
#define READ_GT127r BCM56800_A0_READ_GT127r
#define WRITE_GT127r BCM56800_A0_WRITE_GT127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT1518
 * BLOCKS:   GXPORT
 * DESC:     Transmit 1024 to 1518 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT1518r 0x00f00069

#define BCM56800_A0_GT1518r_SIZE 4

/*
 * This structure should be used to declare and program GT1518.
 *
 */
typedef union BCM56800_A0_GT1518r_s {
	uint32_t v[1];
	uint32_t gt1518[1];
	uint32_t _gt1518;
} BCM56800_A0_GT1518r_t;

#define BCM56800_A0_GT1518r_CLR(r) (r).gt1518[0] = 0
#define BCM56800_A0_GT1518r_SET(r,d) (r).gt1518[0] = d
#define BCM56800_A0_GT1518r_GET(r) (r).gt1518[0]


/*
 * These macros can be used to access GT1518.
 *
 */
#define BCM56800_A0_READ_GT1518r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT1518r,(r._gt1518))
#define BCM56800_A0_WRITE_GT1518r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT1518r,&(r._gt1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT1518r BCM56800_A0_GT1518r
#define GT1518r_SIZE BCM56800_A0_GT1518r_SIZE
typedef BCM56800_A0_GT1518r_t GT1518r_t;
#define GT1518r_CLR BCM56800_A0_GT1518r_CLR
#define GT1518r_SET BCM56800_A0_GT1518r_SET
#define GT1518r_GET BCM56800_A0_GT1518r_GET
#define READ_GT1518r BCM56800_A0_READ_GT1518r
#define WRITE_GT1518r BCM56800_A0_WRITE_GT1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT2047
 * BLOCKS:   GXPORT
 * DESC:     Transmit 1519 to 2047 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT2047r 0x00f0006b

#define BCM56800_A0_GT2047r_SIZE 4

/*
 * This structure should be used to declare and program GT2047.
 *
 */
typedef union BCM56800_A0_GT2047r_s {
	uint32_t v[1];
	uint32_t gt2047[1];
	uint32_t _gt2047;
} BCM56800_A0_GT2047r_t;

#define BCM56800_A0_GT2047r_CLR(r) (r).gt2047[0] = 0
#define BCM56800_A0_GT2047r_SET(r,d) (r).gt2047[0] = d
#define BCM56800_A0_GT2047r_GET(r) (r).gt2047[0]


/*
 * These macros can be used to access GT2047.
 *
 */
#define BCM56800_A0_READ_GT2047r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT2047r,(r._gt2047))
#define BCM56800_A0_WRITE_GT2047r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT2047r,&(r._gt2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT2047r BCM56800_A0_GT2047r
#define GT2047r_SIZE BCM56800_A0_GT2047r_SIZE
typedef BCM56800_A0_GT2047r_t GT2047r_t;
#define GT2047r_CLR BCM56800_A0_GT2047r_CLR
#define GT2047r_SET BCM56800_A0_GT2047r_SET
#define GT2047r_GET BCM56800_A0_GT2047r_GET
#define READ_GT2047r BCM56800_A0_READ_GT2047r
#define WRITE_GT2047r BCM56800_A0_WRITE_GT2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT255
 * BLOCKS:   GXPORT
 * DESC:     Transmit 128 to 255 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT255r 0x00f00066

#define BCM56800_A0_GT255r_SIZE 4

/*
 * This structure should be used to declare and program GT255.
 *
 */
typedef union BCM56800_A0_GT255r_s {
	uint32_t v[1];
	uint32_t gt255[1];
	uint32_t _gt255;
} BCM56800_A0_GT255r_t;

#define BCM56800_A0_GT255r_CLR(r) (r).gt255[0] = 0
#define BCM56800_A0_GT255r_SET(r,d) (r).gt255[0] = d
#define BCM56800_A0_GT255r_GET(r) (r).gt255[0]


/*
 * These macros can be used to access GT255.
 *
 */
#define BCM56800_A0_READ_GT255r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT255r,(r._gt255))
#define BCM56800_A0_WRITE_GT255r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT255r,&(r._gt255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT255r BCM56800_A0_GT255r
#define GT255r_SIZE BCM56800_A0_GT255r_SIZE
typedef BCM56800_A0_GT255r_t GT255r_t;
#define GT255r_CLR BCM56800_A0_GT255r_CLR
#define GT255r_SET BCM56800_A0_GT255r_SET
#define GT255r_GET BCM56800_A0_GT255r_GET
#define READ_GT255r BCM56800_A0_READ_GT255r
#define WRITE_GT255r BCM56800_A0_WRITE_GT255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT4095
 * BLOCKS:   GXPORT
 * DESC:     Transmit 2048 to 4095 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT4095r 0x00f0006c

#define BCM56800_A0_GT4095r_SIZE 4

/*
 * This structure should be used to declare and program GT4095.
 *
 */
typedef union BCM56800_A0_GT4095r_s {
	uint32_t v[1];
	uint32_t gt4095[1];
	uint32_t _gt4095;
} BCM56800_A0_GT4095r_t;

#define BCM56800_A0_GT4095r_CLR(r) (r).gt4095[0] = 0
#define BCM56800_A0_GT4095r_SET(r,d) (r).gt4095[0] = d
#define BCM56800_A0_GT4095r_GET(r) (r).gt4095[0]


/*
 * These macros can be used to access GT4095.
 *
 */
#define BCM56800_A0_READ_GT4095r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT4095r,(r._gt4095))
#define BCM56800_A0_WRITE_GT4095r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT4095r,&(r._gt4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT4095r BCM56800_A0_GT4095r
#define GT4095r_SIZE BCM56800_A0_GT4095r_SIZE
typedef BCM56800_A0_GT4095r_t GT4095r_t;
#define GT4095r_CLR BCM56800_A0_GT4095r_CLR
#define GT4095r_SET BCM56800_A0_GT4095r_SET
#define GT4095r_GET BCM56800_A0_GT4095r_GET
#define READ_GT4095r BCM56800_A0_READ_GT4095r
#define WRITE_GT4095r BCM56800_A0_WRITE_GT4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT511
 * BLOCKS:   GXPORT
 * DESC:     Transmit 256 to 511 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT511r 0x00f00067

#define BCM56800_A0_GT511r_SIZE 4

/*
 * This structure should be used to declare and program GT511.
 *
 */
typedef union BCM56800_A0_GT511r_s {
	uint32_t v[1];
	uint32_t gt511[1];
	uint32_t _gt511;
} BCM56800_A0_GT511r_t;

#define BCM56800_A0_GT511r_CLR(r) (r).gt511[0] = 0
#define BCM56800_A0_GT511r_SET(r,d) (r).gt511[0] = d
#define BCM56800_A0_GT511r_GET(r) (r).gt511[0]


/*
 * These macros can be used to access GT511.
 *
 */
#define BCM56800_A0_READ_GT511r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT511r,(r._gt511))
#define BCM56800_A0_WRITE_GT511r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT511r,&(r._gt511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT511r BCM56800_A0_GT511r
#define GT511r_SIZE BCM56800_A0_GT511r_SIZE
typedef BCM56800_A0_GT511r_t GT511r_t;
#define GT511r_CLR BCM56800_A0_GT511r_CLR
#define GT511r_SET BCM56800_A0_GT511r_SET
#define GT511r_GET BCM56800_A0_GT511r_GET
#define READ_GT511r BCM56800_A0_READ_GT511r
#define WRITE_GT511r BCM56800_A0_WRITE_GT511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT64
 * BLOCKS:   GXPORT
 * DESC:     Transmit 64 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT64r 0x00f00064

#define BCM56800_A0_GT64r_SIZE 4

/*
 * This structure should be used to declare and program GT64.
 *
 */
typedef union BCM56800_A0_GT64r_s {
	uint32_t v[1];
	uint32_t gt64[1];
	uint32_t _gt64;
} BCM56800_A0_GT64r_t;

#define BCM56800_A0_GT64r_CLR(r) (r).gt64[0] = 0
#define BCM56800_A0_GT64r_SET(r,d) (r).gt64[0] = d
#define BCM56800_A0_GT64r_GET(r) (r).gt64[0]


/*
 * These macros can be used to access GT64.
 *
 */
#define BCM56800_A0_READ_GT64r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT64r,(r._gt64))
#define BCM56800_A0_WRITE_GT64r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT64r,&(r._gt64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT64r BCM56800_A0_GT64r
#define GT64r_SIZE BCM56800_A0_GT64r_SIZE
typedef BCM56800_A0_GT64r_t GT64r_t;
#define GT64r_CLR BCM56800_A0_GT64r_CLR
#define GT64r_SET BCM56800_A0_GT64r_SET
#define GT64r_GET BCM56800_A0_GT64r_GET
#define READ_GT64r BCM56800_A0_READ_GT64r
#define WRITE_GT64r BCM56800_A0_WRITE_GT64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GT9216
 * BLOCKS:   GXPORT
 * DESC:     Transmit 4096 to 9216 Byte Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GT9216r 0x00f0006d

#define BCM56800_A0_GT9216r_SIZE 4

/*
 * This structure should be used to declare and program GT9216.
 *
 */
typedef union BCM56800_A0_GT9216r_s {
	uint32_t v[1];
	uint32_t gt9216[1];
	uint32_t _gt9216;
} BCM56800_A0_GT9216r_t;

#define BCM56800_A0_GT9216r_CLR(r) (r).gt9216[0] = 0
#define BCM56800_A0_GT9216r_SET(r,d) (r).gt9216[0] = d
#define BCM56800_A0_GT9216r_GET(r) (r).gt9216[0]


/*
 * These macros can be used to access GT9216.
 *
 */
#define BCM56800_A0_READ_GT9216r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GT9216r,(r._gt9216))
#define BCM56800_A0_WRITE_GT9216r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GT9216r,&(r._gt9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GT9216r BCM56800_A0_GT9216r
#define GT9216r_SIZE BCM56800_A0_GT9216r_SIZE
typedef BCM56800_A0_GT9216r_t GT9216r_t;
#define GT9216r_CLR BCM56800_A0_GT9216r_CLR
#define GT9216r_SET BCM56800_A0_GT9216r_SET
#define GT9216r_GET BCM56800_A0_GT9216r_GET
#define READ_GT9216r BCM56800_A0_READ_GT9216r
#define WRITE_GT9216r BCM56800_A0_WRITE_GT9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GT9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTBCA
 * BLOCKS:   GXPORT
 * DESC:     Transmit Broadcast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTBCAr 0x00f00070

#define BCM56800_A0_GTBCAr_SIZE 4

/*
 * This structure should be used to declare and program GTBCA.
 *
 */
typedef union BCM56800_A0_GTBCAr_s {
	uint32_t v[1];
	uint32_t gtbca[1];
	uint32_t _gtbca;
} BCM56800_A0_GTBCAr_t;

#define BCM56800_A0_GTBCAr_CLR(r) (r).gtbca[0] = 0
#define BCM56800_A0_GTBCAr_SET(r,d) (r).gtbca[0] = d
#define BCM56800_A0_GTBCAr_GET(r) (r).gtbca[0]


/*
 * These macros can be used to access GTBCA.
 *
 */
#define BCM56800_A0_READ_GTBCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTBCAr,(r._gtbca))
#define BCM56800_A0_WRITE_GTBCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTBCAr,&(r._gtbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTBCAr BCM56800_A0_GTBCAr
#define GTBCAr_SIZE BCM56800_A0_GTBCAr_SIZE
typedef BCM56800_A0_GTBCAr_t GTBCAr_t;
#define GTBCAr_CLR BCM56800_A0_GTBCAr_CLR
#define GTBCAr_SET BCM56800_A0_GTBCAr_SET
#define GTBCAr_GET BCM56800_A0_GTBCAr_GET
#define READ_GTBCAr BCM56800_A0_READ_GTBCAr
#define WRITE_GTBCAr BCM56800_A0_WRITE_GTBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTBYT
 * BLOCKS:   GXPORT
 * DESC:     Transmit Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTBYTr 0x00f0007e

#define BCM56800_A0_GTBYTr_SIZE 4

/*
 * This structure should be used to declare and program GTBYT.
 *
 */
typedef union BCM56800_A0_GTBYTr_s {
	uint32_t v[1];
	uint32_t gtbyt[1];
	uint32_t _gtbyt;
} BCM56800_A0_GTBYTr_t;

#define BCM56800_A0_GTBYTr_CLR(r) (r).gtbyt[0] = 0
#define BCM56800_A0_GTBYTr_SET(r,d) (r).gtbyt[0] = d
#define BCM56800_A0_GTBYTr_GET(r) (r).gtbyt[0]


/*
 * These macros can be used to access GTBYT.
 *
 */
#define BCM56800_A0_READ_GTBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTBYTr,(r._gtbyt))
#define BCM56800_A0_WRITE_GTBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTBYTr,&(r._gtbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTBYTr BCM56800_A0_GTBYTr
#define GTBYTr_SIZE BCM56800_A0_GTBYTr_SIZE
typedef BCM56800_A0_GTBYTr_t GTBYTr_t;
#define GTBYTr_CLR BCM56800_A0_GTBYTr_CLR
#define GTBYTr_SET BCM56800_A0_GTBYTr_SET
#define GTBYTr_GET BCM56800_A0_GTBYTr_GET
#define READ_GTBYTr BCM56800_A0_READ_GTBYTr
#define WRITE_GTBYTr BCM56800_A0_WRITE_GTBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTDFR
 * BLOCKS:   GXPORT
 * DESC:     Transmit Single Deferral Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTDFRr 0x00f00076

#define BCM56800_A0_GTDFRr_SIZE 4

/*
 * This structure should be used to declare and program GTDFR.
 *
 */
typedef union BCM56800_A0_GTDFRr_s {
	uint32_t v[1];
	uint32_t gtdfr[1];
	uint32_t _gtdfr;
} BCM56800_A0_GTDFRr_t;

#define BCM56800_A0_GTDFRr_CLR(r) (r).gtdfr[0] = 0
#define BCM56800_A0_GTDFRr_SET(r,d) (r).gtdfr[0] = d
#define BCM56800_A0_GTDFRr_GET(r) (r).gtdfr[0]


/*
 * These macros can be used to access GTDFR.
 *
 */
#define BCM56800_A0_READ_GTDFRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTDFRr,(r._gtdfr))
#define BCM56800_A0_WRITE_GTDFRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTDFRr,&(r._gtdfr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTDFRr BCM56800_A0_GTDFRr
#define GTDFRr_SIZE BCM56800_A0_GTDFRr_SIZE
typedef BCM56800_A0_GTDFRr_t GTDFRr_t;
#define GTDFRr_CLR BCM56800_A0_GTDFRr_CLR
#define GTDFRr_SET BCM56800_A0_GTDFRr_SET
#define GTDFRr_GET BCM56800_A0_GTDFRr_GET
#define READ_GTDFRr BCM56800_A0_READ_GTDFRr
#define WRITE_GTDFRr BCM56800_A0_WRITE_GTDFRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTDFRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTEDF
 * BLOCKS:   GXPORT
 * DESC:     Transmit Multiple Deferral Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTEDFr 0x00f00077

#define BCM56800_A0_GTEDFr_SIZE 4

/*
 * This structure should be used to declare and program GTEDF.
 *
 */
typedef union BCM56800_A0_GTEDFr_s {
	uint32_t v[1];
	uint32_t gtedf[1];
	uint32_t _gtedf;
} BCM56800_A0_GTEDFr_t;

#define BCM56800_A0_GTEDFr_CLR(r) (r).gtedf[0] = 0
#define BCM56800_A0_GTEDFr_SET(r,d) (r).gtedf[0] = d
#define BCM56800_A0_GTEDFr_GET(r) (r).gtedf[0]


/*
 * These macros can be used to access GTEDF.
 *
 */
#define BCM56800_A0_READ_GTEDFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTEDFr,(r._gtedf))
#define BCM56800_A0_WRITE_GTEDFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTEDFr,&(r._gtedf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTEDFr BCM56800_A0_GTEDFr
#define GTEDFr_SIZE BCM56800_A0_GTEDFr_SIZE
typedef BCM56800_A0_GTEDFr_t GTEDFr_t;
#define GTEDFr_CLR BCM56800_A0_GTEDFr_CLR
#define GTEDFr_SET BCM56800_A0_GTEDFr_SET
#define GTEDFr_GET BCM56800_A0_GTEDFr_GET
#define READ_GTEDFr BCM56800_A0_READ_GTEDFr
#define WRITE_GTEDFr BCM56800_A0_WRITE_GTEDFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTEDFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTFCS
 * BLOCKS:   GXPORT
 * DESC:     Transmit FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTFCSr 0x00f00073

#define BCM56800_A0_GTFCSr_SIZE 4

/*
 * This structure should be used to declare and program GTFCS.
 *
 */
typedef union BCM56800_A0_GTFCSr_s {
	uint32_t v[1];
	uint32_t gtfcs[1];
	uint32_t _gtfcs;
} BCM56800_A0_GTFCSr_t;

#define BCM56800_A0_GTFCSr_CLR(r) (r).gtfcs[0] = 0
#define BCM56800_A0_GTFCSr_SET(r,d) (r).gtfcs[0] = d
#define BCM56800_A0_GTFCSr_GET(r) (r).gtfcs[0]


/*
 * These macros can be used to access GTFCS.
 *
 */
#define BCM56800_A0_READ_GTFCSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTFCSr,(r._gtfcs))
#define BCM56800_A0_WRITE_GTFCSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTFCSr,&(r._gtfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTFCSr BCM56800_A0_GTFCSr
#define GTFCSr_SIZE BCM56800_A0_GTFCSr_SIZE
typedef BCM56800_A0_GTFCSr_t GTFCSr_t;
#define GTFCSr_CLR BCM56800_A0_GTFCSr_CLR
#define GTFCSr_SET BCM56800_A0_GTFCSr_SET
#define GTFCSr_GET BCM56800_A0_GTFCSr_GET
#define READ_GTFCSr BCM56800_A0_READ_GTFCSr
#define WRITE_GTFCSr BCM56800_A0_WRITE_GTFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTFRG
 * BLOCKS:   GXPORT
 * DESC:     Transmit Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTFRGr 0x00f0007c

#define BCM56800_A0_GTFRGr_SIZE 4

/*
 * This structure should be used to declare and program GTFRG.
 *
 */
typedef union BCM56800_A0_GTFRGr_s {
	uint32_t v[1];
	uint32_t gtfrg[1];
	uint32_t _gtfrg;
} BCM56800_A0_GTFRGr_t;

#define BCM56800_A0_GTFRGr_CLR(r) (r).gtfrg[0] = 0
#define BCM56800_A0_GTFRGr_SET(r,d) (r).gtfrg[0] = d
#define BCM56800_A0_GTFRGr_GET(r) (r).gtfrg[0]


/*
 * These macros can be used to access GTFRG.
 *
 */
#define BCM56800_A0_READ_GTFRGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTFRGr,(r._gtfrg))
#define BCM56800_A0_WRITE_GTFRGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTFRGr,&(r._gtfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTFRGr BCM56800_A0_GTFRGr
#define GTFRGr_SIZE BCM56800_A0_GTFRGr_SIZE
typedef BCM56800_A0_GTFRGr_t GTFRGr_t;
#define GTFRGr_CLR BCM56800_A0_GTFRGr_CLR
#define GTFRGr_SET BCM56800_A0_GTFRGr_SET
#define GTFRGr_GET BCM56800_A0_GTFRGr_GET
#define READ_GTFRGr BCM56800_A0_READ_GTFRGr
#define WRITE_GTFRGr BCM56800_A0_WRITE_GTFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTJBR
 * BLOCKS:   GXPORT
 * DESC:     Transmit Jabber Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTJBRr 0x00f00072

#define BCM56800_A0_GTJBRr_SIZE 4

/*
 * This structure should be used to declare and program GTJBR.
 *
 */
typedef union BCM56800_A0_GTJBRr_s {
	uint32_t v[1];
	uint32_t gtjbr[1];
	uint32_t _gtjbr;
} BCM56800_A0_GTJBRr_t;

#define BCM56800_A0_GTJBRr_CLR(r) (r).gtjbr[0] = 0
#define BCM56800_A0_GTJBRr_SET(r,d) (r).gtjbr[0] = d
#define BCM56800_A0_GTJBRr_GET(r) (r).gtjbr[0]


/*
 * These macros can be used to access GTJBR.
 *
 */
#define BCM56800_A0_READ_GTJBRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTJBRr,(r._gtjbr))
#define BCM56800_A0_WRITE_GTJBRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTJBRr,&(r._gtjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTJBRr BCM56800_A0_GTJBRr
#define GTJBRr_SIZE BCM56800_A0_GTJBRr_SIZE
typedef BCM56800_A0_GTJBRr_t GTJBRr_t;
#define GTJBRr_CLR BCM56800_A0_GTJBRr_CLR
#define GTJBRr_SET BCM56800_A0_GTJBRr_SET
#define GTJBRr_GET BCM56800_A0_GTJBRr_GET
#define READ_GTJBRr BCM56800_A0_READ_GTJBRr
#define WRITE_GTJBRr BCM56800_A0_WRITE_GTJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTLCL
 * BLOCKS:   GXPORT
 * DESC:     Transmit Late Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTLCLr 0x00f0007a

#define BCM56800_A0_GTLCLr_SIZE 4

/*
 * This structure should be used to declare and program GTLCL.
 *
 */
typedef union BCM56800_A0_GTLCLr_s {
	uint32_t v[1];
	uint32_t gtlcl[1];
	uint32_t _gtlcl;
} BCM56800_A0_GTLCLr_t;

#define BCM56800_A0_GTLCLr_CLR(r) (r).gtlcl[0] = 0
#define BCM56800_A0_GTLCLr_SET(r,d) (r).gtlcl[0] = d
#define BCM56800_A0_GTLCLr_GET(r) (r).gtlcl[0]


/*
 * These macros can be used to access GTLCL.
 *
 */
#define BCM56800_A0_READ_GTLCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTLCLr,(r._gtlcl))
#define BCM56800_A0_WRITE_GTLCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTLCLr,&(r._gtlcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTLCLr BCM56800_A0_GTLCLr
#define GTLCLr_SIZE BCM56800_A0_GTLCLr_SIZE
typedef BCM56800_A0_GTLCLr_t GTLCLr_t;
#define GTLCLr_CLR BCM56800_A0_GTLCLr_CLR
#define GTLCLr_SET BCM56800_A0_GTLCLr_SET
#define GTLCLr_GET BCM56800_A0_GTLCLr_GET
#define READ_GTLCLr BCM56800_A0_READ_GTLCLr
#define WRITE_GTLCLr BCM56800_A0_WRITE_GTLCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTLCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTMCA
 * BLOCKS:   GXPORT
 * DESC:     Transmit Multicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTMCAr 0x00f0006f

#define BCM56800_A0_GTMCAr_SIZE 4

/*
 * This structure should be used to declare and program GTMCA.
 *
 */
typedef union BCM56800_A0_GTMCAr_s {
	uint32_t v[1];
	uint32_t gtmca[1];
	uint32_t _gtmca;
} BCM56800_A0_GTMCAr_t;

#define BCM56800_A0_GTMCAr_CLR(r) (r).gtmca[0] = 0
#define BCM56800_A0_GTMCAr_SET(r,d) (r).gtmca[0] = d
#define BCM56800_A0_GTMCAr_GET(r) (r).gtmca[0]


/*
 * These macros can be used to access GTMCA.
 *
 */
#define BCM56800_A0_READ_GTMCAr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTMCAr,(r._gtmca))
#define BCM56800_A0_WRITE_GTMCAr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTMCAr,&(r._gtmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMCAr BCM56800_A0_GTMCAr
#define GTMCAr_SIZE BCM56800_A0_GTMCAr_SIZE
typedef BCM56800_A0_GTMCAr_t GTMCAr_t;
#define GTMCAr_CLR BCM56800_A0_GTMCAr_CLR
#define GTMCAr_SET BCM56800_A0_GTMCAr_SET
#define GTMCAr_GET BCM56800_A0_GTMCAr_GET
#define READ_GTMCAr BCM56800_A0_READ_GTMCAr
#define WRITE_GTMCAr BCM56800_A0_WRITE_GTMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTMCL
 * BLOCKS:   GXPORT
 * DESC:     Transmit Multiple Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTMCLr 0x00f00079

#define BCM56800_A0_GTMCLr_SIZE 4

/*
 * This structure should be used to declare and program GTMCL.
 *
 */
typedef union BCM56800_A0_GTMCLr_s {
	uint32_t v[1];
	uint32_t gtmcl[1];
	uint32_t _gtmcl;
} BCM56800_A0_GTMCLr_t;

#define BCM56800_A0_GTMCLr_CLR(r) (r).gtmcl[0] = 0
#define BCM56800_A0_GTMCLr_SET(r,d) (r).gtmcl[0] = d
#define BCM56800_A0_GTMCLr_GET(r) (r).gtmcl[0]


/*
 * These macros can be used to access GTMCL.
 *
 */
#define BCM56800_A0_READ_GTMCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTMCLr,(r._gtmcl))
#define BCM56800_A0_WRITE_GTMCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTMCLr,&(r._gtmcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMCLr BCM56800_A0_GTMCLr
#define GTMCLr_SIZE BCM56800_A0_GTMCLr_SIZE
typedef BCM56800_A0_GTMCLr_t GTMCLr_t;
#define GTMCLr_CLR BCM56800_A0_GTMCLr_CLR
#define GTMCLr_SET BCM56800_A0_GTMCLr_SET
#define GTMCLr_GET BCM56800_A0_GTMCLr_GET
#define READ_GTMCLr BCM56800_A0_READ_GTMCLr
#define WRITE_GTMCLr BCM56800_A0_WRITE_GTMCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTMCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTMGV
 * BLOCKS:   GXPORT
 * DESC:     Transmit 1519 to 1522 Byte Good VLAN Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTMGVr 0x00f0006a

#define BCM56800_A0_GTMGVr_SIZE 4

/*
 * This structure should be used to declare and program GTMGV.
 *
 */
typedef union BCM56800_A0_GTMGVr_s {
	uint32_t v[1];
	uint32_t gtmgv[1];
	uint32_t _gtmgv;
} BCM56800_A0_GTMGVr_t;

#define BCM56800_A0_GTMGVr_CLR(r) (r).gtmgv[0] = 0
#define BCM56800_A0_GTMGVr_SET(r,d) (r).gtmgv[0] = d
#define BCM56800_A0_GTMGVr_GET(r) (r).gtmgv[0]


/*
 * These macros can be used to access GTMGV.
 *
 */
#define BCM56800_A0_READ_GTMGVr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTMGVr,(r._gtmgv))
#define BCM56800_A0_WRITE_GTMGVr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTMGVr,&(r._gtmgv))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTMGVr BCM56800_A0_GTMGVr
#define GTMGVr_SIZE BCM56800_A0_GTMGVr_SIZE
typedef BCM56800_A0_GTMGVr_t GTMGVr_t;
#define GTMGVr_CLR BCM56800_A0_GTMGVr_CLR
#define GTMGVr_SET BCM56800_A0_GTMGVr_SET
#define GTMGVr_GET BCM56800_A0_GTMGVr_GET
#define READ_GTMGVr BCM56800_A0_READ_GTMGVr
#define WRITE_GTMGVr BCM56800_A0_WRITE_GTMGVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTMGVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTNCL
 * BLOCKS:   GXPORT
 * DESC:     Transmit Total Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTNCLr 0x00f0007d

#define BCM56800_A0_GTNCLr_SIZE 4

/*
 * This structure should be used to declare and program GTNCL.
 *
 */
typedef union BCM56800_A0_GTNCLr_s {
	uint32_t v[1];
	uint32_t gtncl[1];
	uint32_t _gtncl;
} BCM56800_A0_GTNCLr_t;

#define BCM56800_A0_GTNCLr_CLR(r) (r).gtncl[0] = 0
#define BCM56800_A0_GTNCLr_SET(r,d) (r).gtncl[0] = d
#define BCM56800_A0_GTNCLr_GET(r) (r).gtncl[0]


/*
 * These macros can be used to access GTNCL.
 *
 */
#define BCM56800_A0_READ_GTNCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTNCLr,(r._gtncl))
#define BCM56800_A0_WRITE_GTNCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTNCLr,&(r._gtncl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTNCLr BCM56800_A0_GTNCLr
#define GTNCLr_SIZE BCM56800_A0_GTNCLr_SIZE
typedef BCM56800_A0_GTNCLr_t GTNCLr_t;
#define GTNCLr_CLR BCM56800_A0_GTNCLr_CLR
#define GTNCLr_SET BCM56800_A0_GTNCLr_SET
#define GTNCLr_GET BCM56800_A0_GTNCLr_GET
#define READ_GTNCLr BCM56800_A0_READ_GTNCLr
#define WRITE_GTNCLr BCM56800_A0_WRITE_GTNCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTNCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTOVR
 * BLOCKS:   GXPORT
 * DESC:     Transmit Oversize Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTOVRr 0x00f00075

#define BCM56800_A0_GTOVRr_SIZE 4

/*
 * This structure should be used to declare and program GTOVR.
 *
 */
typedef union BCM56800_A0_GTOVRr_s {
	uint32_t v[1];
	uint32_t gtovr[1];
	uint32_t _gtovr;
} BCM56800_A0_GTOVRr_t;

#define BCM56800_A0_GTOVRr_CLR(r) (r).gtovr[0] = 0
#define BCM56800_A0_GTOVRr_SET(r,d) (r).gtovr[0] = d
#define BCM56800_A0_GTOVRr_GET(r) (r).gtovr[0]


/*
 * These macros can be used to access GTOVR.
 *
 */
#define BCM56800_A0_READ_GTOVRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTOVRr,(r._gtovr))
#define BCM56800_A0_WRITE_GTOVRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTOVRr,&(r._gtovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTOVRr BCM56800_A0_GTOVRr
#define GTOVRr_SIZE BCM56800_A0_GTOVRr_SIZE
typedef BCM56800_A0_GTOVRr_t GTOVRr_t;
#define GTOVRr_CLR BCM56800_A0_GTOVRr_CLR
#define GTOVRr_SET BCM56800_A0_GTOVRr_SET
#define GTOVRr_GET BCM56800_A0_GTOVRr_GET
#define READ_GTOVRr BCM56800_A0_READ_GTOVRr
#define WRITE_GTOVRr BCM56800_A0_WRITE_GTOVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTOVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTPKT
 * BLOCKS:   GXPORT
 * DESC:     Transmit frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTPKTr 0x00f0006e

#define BCM56800_A0_GTPKTr_SIZE 4

/*
 * This structure should be used to declare and program GTPKT.
 *
 */
typedef union BCM56800_A0_GTPKTr_s {
	uint32_t v[1];
	uint32_t gtpkt[1];
	uint32_t _gtpkt;
} BCM56800_A0_GTPKTr_t;

#define BCM56800_A0_GTPKTr_CLR(r) (r).gtpkt[0] = 0
#define BCM56800_A0_GTPKTr_SET(r,d) (r).gtpkt[0] = d
#define BCM56800_A0_GTPKTr_GET(r) (r).gtpkt[0]


/*
 * These macros can be used to access GTPKT.
 *
 */
#define BCM56800_A0_READ_GTPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTPKTr,(r._gtpkt))
#define BCM56800_A0_WRITE_GTPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTPKTr,&(r._gtpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTPKTr BCM56800_A0_GTPKTr
#define GTPKTr_SIZE BCM56800_A0_GTPKTr_SIZE
typedef BCM56800_A0_GTPKTr_t GTPKTr_t;
#define GTPKTr_CLR BCM56800_A0_GTPKTr_CLR
#define GTPKTr_SET BCM56800_A0_GTPKTr_SET
#define GTPKTr_GET BCM56800_A0_GTPKTr_GET
#define READ_GTPKTr BCM56800_A0_READ_GTPKTr
#define WRITE_GTPKTr BCM56800_A0_WRITE_GTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTSCL
 * BLOCKS:   GXPORT
 * DESC:     Transmit Single Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTSCLr 0x00f00078

#define BCM56800_A0_GTSCLr_SIZE 4

/*
 * This structure should be used to declare and program GTSCL.
 *
 */
typedef union BCM56800_A0_GTSCLr_s {
	uint32_t v[1];
	uint32_t gtscl[1];
	uint32_t _gtscl;
} BCM56800_A0_GTSCLr_t;

#define BCM56800_A0_GTSCLr_CLR(r) (r).gtscl[0] = 0
#define BCM56800_A0_GTSCLr_SET(r,d) (r).gtscl[0] = d
#define BCM56800_A0_GTSCLr_GET(r) (r).gtscl[0]


/*
 * These macros can be used to access GTSCL.
 *
 */
#define BCM56800_A0_READ_GTSCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTSCLr,(r._gtscl))
#define BCM56800_A0_WRITE_GTSCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTSCLr,&(r._gtscl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTSCLr BCM56800_A0_GTSCLr
#define GTSCLr_SIZE BCM56800_A0_GTSCLr_SIZE
typedef BCM56800_A0_GTSCLr_t GTSCLr_t;
#define GTSCLr_CLR BCM56800_A0_GTSCLr_CLR
#define GTSCLr_SET BCM56800_A0_GTSCLr_SET
#define GTSCLr_GET BCM56800_A0_GTSCLr_GET
#define READ_GTSCLr BCM56800_A0_READ_GTSCLr
#define WRITE_GTSCLr BCM56800_A0_WRITE_GTSCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTSCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTXCF
 * BLOCKS:   GXPORT
 * DESC:     Transmit Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTXCFr 0x00f00074

#define BCM56800_A0_GTXCFr_SIZE 4

/*
 * This structure should be used to declare and program GTXCF.
 *
 */
typedef union BCM56800_A0_GTXCFr_s {
	uint32_t v[1];
	uint32_t gtxcf[1];
	uint32_t _gtxcf;
} BCM56800_A0_GTXCFr_t;

#define BCM56800_A0_GTXCFr_CLR(r) (r).gtxcf[0] = 0
#define BCM56800_A0_GTXCFr_SET(r,d) (r).gtxcf[0] = d
#define BCM56800_A0_GTXCFr_GET(r) (r).gtxcf[0]


/*
 * These macros can be used to access GTXCF.
 *
 */
#define BCM56800_A0_READ_GTXCFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTXCFr,(r._gtxcf))
#define BCM56800_A0_WRITE_GTXCFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTXCFr,&(r._gtxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXCFr BCM56800_A0_GTXCFr
#define GTXCFr_SIZE BCM56800_A0_GTXCFr_SIZE
typedef BCM56800_A0_GTXCFr_t GTXCFr_t;
#define GTXCFr_CLR BCM56800_A0_GTXCFr_CLR
#define GTXCFr_SET BCM56800_A0_GTXCFr_SET
#define GTXCFr_GET BCM56800_A0_GTXCFr_GET
#define READ_GTXCFr BCM56800_A0_READ_GTXCFr
#define WRITE_GTXCFr BCM56800_A0_WRITE_GTXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTXCL
 * BLOCKS:   GXPORT
 * DESC:     Transmit Excessive Collision Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTXCLr 0x00f0007b

#define BCM56800_A0_GTXCLr_SIZE 4

/*
 * This structure should be used to declare and program GTXCL.
 *
 */
typedef union BCM56800_A0_GTXCLr_s {
	uint32_t v[1];
	uint32_t gtxcl[1];
	uint32_t _gtxcl;
} BCM56800_A0_GTXCLr_t;

#define BCM56800_A0_GTXCLr_CLR(r) (r).gtxcl[0] = 0
#define BCM56800_A0_GTXCLr_SET(r,d) (r).gtxcl[0] = d
#define BCM56800_A0_GTXCLr_GET(r) (r).gtxcl[0]


/*
 * These macros can be used to access GTXCL.
 *
 */
#define BCM56800_A0_READ_GTXCLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTXCLr,(r._gtxcl))
#define BCM56800_A0_WRITE_GTXCLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTXCLr,&(r._gtxcl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXCLr BCM56800_A0_GTXCLr
#define GTXCLr_SIZE BCM56800_A0_GTXCLr_SIZE
typedef BCM56800_A0_GTXCLr_t GTXCLr_t;
#define GTXCLr_CLR BCM56800_A0_GTXCLr_CLR
#define GTXCLr_SET BCM56800_A0_GTXCLr_SET
#define GTXCLr_GET BCM56800_A0_GTXCLr_GET
#define READ_GTXCLr BCM56800_A0_READ_GTXCLr
#define WRITE_GTXCLr BCM56800_A0_WRITE_GTXCLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTXCLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GTXPF
 * BLOCKS:   GXPORT
 * DESC:     Transmit Pause Control Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_GTXPFr 0x00f00071

#define BCM56800_A0_GTXPFr_SIZE 4

/*
 * This structure should be used to declare and program GTXPF.
 *
 */
typedef union BCM56800_A0_GTXPFr_s {
	uint32_t v[1];
	uint32_t gtxpf[1];
	uint32_t _gtxpf;
} BCM56800_A0_GTXPFr_t;

#define BCM56800_A0_GTXPFr_CLR(r) (r).gtxpf[0] = 0
#define BCM56800_A0_GTXPFr_SET(r,d) (r).gtxpf[0] = d
#define BCM56800_A0_GTXPFr_GET(r) (r).gtxpf[0]


/*
 * These macros can be used to access GTXPF.
 *
 */
#define BCM56800_A0_READ_GTXPFr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GTXPFr,(r._gtxpf))
#define BCM56800_A0_WRITE_GTXPFr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GTXPFr,&(r._gtxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GTXPFr BCM56800_A0_GTXPFr
#define GTXPFr_SIZE BCM56800_A0_GTXPFr_SIZE
typedef BCM56800_A0_GTXPFr_t GTXPFr_t;
#define GTXPFr_CLR BCM56800_A0_GTXPFr_CLR
#define GTXPFr_SET BCM56800_A0_GTXPFr_SET
#define GTXPFr_GET BCM56800_A0_GTXPFr_GET
#define READ_GTXPFr BCM56800_A0_READ_GTXPFr
#define WRITE_GTXPFr BCM56800_A0_WRITE_GTXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GTXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GXPORT_LAG_FAILOVER_CONFIG
 * BLOCKS:   GXPORT
 * DESC:     GXPORT LAG Failover Loopback Config
 * SIZE:     32
 * FIELDS:
 *     LINK_STATUS_UP   Software controlled Link up Status.
 *     LAG_FAILOVER_EN  Enable LAG Failover Loopback.
 *     REMOVE_FAILOVER_LPBK Remove GXport from Loopback.
 *
 ******************************************************************************/
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr 0x00f00a08

#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program GXPORT_LAG_FAILOVER_CONFIG.
 *
 */
typedef union BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_s {
	uint32_t v[1];
	uint32_t gxport_lag_failover_config[1];
	uint32_t _gxport_lag_failover_config;
} BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_t;

#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_CLR(r) (r).gxport_lag_failover_config[0] = 0
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_SET(r,d) (r).gxport_lag_failover_config[0] = d
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_GET(r) (r).gxport_lag_failover_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_GET(r) (((r).gxport_lag_failover_config[0]) & 0x1)
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_SET(r,f) (r).gxport_lag_failover_config[0]=(((r).gxport_lag_failover_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_LAG_FAILOVER_ENf_GET(r) ((((r).gxport_lag_failover_config[0]) >> 1) & 0x1)
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_LAG_FAILOVER_ENf_SET(r,f) (r).gxport_lag_failover_config[0]=(((r).gxport_lag_failover_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_REMOVE_FAILOVER_LPBKf_GET(r) ((((r).gxport_lag_failover_config[0]) >> 2) & 0x1)
#define BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_REMOVE_FAILOVER_LPBKf_SET(r,f) (r).gxport_lag_failover_config[0]=(((r).gxport_lag_failover_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access GXPORT_LAG_FAILOVER_CONFIG.
 *
 */
#define BCM56800_A0_READ_GXPORT_LAG_FAILOVER_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr,(r._gxport_lag_failover_config))
#define BCM56800_A0_WRITE_GXPORT_LAG_FAILOVER_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr,&(r._gxport_lag_failover_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GXPORT_LAG_FAILOVER_CONFIGr BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr
#define GXPORT_LAG_FAILOVER_CONFIGr_SIZE BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_SIZE
typedef BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_t GXPORT_LAG_FAILOVER_CONFIGr_t;
#define GXPORT_LAG_FAILOVER_CONFIGr_CLR BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_CLR
#define GXPORT_LAG_FAILOVER_CONFIGr_SET BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_SET
#define GXPORT_LAG_FAILOVER_CONFIGr_GET BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_GET
#define GXPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_GET BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_GET
#define GXPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_SET BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_LINK_STATUS_UPf_SET
#define GXPORT_LAG_FAILOVER_CONFIGr_LAG_FAILOVER_ENf_GET BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_LAG_FAILOVER_ENf_GET
#define GXPORT_LAG_FAILOVER_CONFIGr_LAG_FAILOVER_ENf_SET BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_LAG_FAILOVER_ENf_SET
#define GXPORT_LAG_FAILOVER_CONFIGr_REMOVE_FAILOVER_LPBKf_GET BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_REMOVE_FAILOVER_LPBKf_GET
#define GXPORT_LAG_FAILOVER_CONFIGr_REMOVE_FAILOVER_LPBKf_SET BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr_REMOVE_FAILOVER_LPBKf_SET
#define READ_GXPORT_LAG_FAILOVER_CONFIGr BCM56800_A0_READ_GXPORT_LAG_FAILOVER_CONFIGr
#define WRITE_GXPORT_LAG_FAILOVER_CONFIGr BCM56800_A0_WRITE_GXPORT_LAG_FAILOVER_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GXPORT_LAG_FAILOVER_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  GXPORT_LAG_FAILOVER_STATUS
 * BLOCKS:   GXPORT
 * DESC:     GXPORT LAG Failover Loopback Status
 * SIZE:     32
 * FIELDS:
 *     LAG_FAILOVER_LOOPBACK GXPort in Loopback Mode.
 *
 ******************************************************************************/
#define BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr 0x00f00a09

#define BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program GXPORT_LAG_FAILOVER_STATUS.
 *
 */
typedef union BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_s {
	uint32_t v[1];
	uint32_t gxport_lag_failover_status[1];
	uint32_t _gxport_lag_failover_status;
} BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_t;

#define BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_CLR(r) (r).gxport_lag_failover_status[0] = 0
#define BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_SET(r,d) (r).gxport_lag_failover_status[0] = d
#define BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_GET(r) (r).gxport_lag_failover_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_GET(r) (((r).gxport_lag_failover_status[0]) & 0x1)
#define BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_SET(r,f) (r).gxport_lag_failover_status[0]=(((r).gxport_lag_failover_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access GXPORT_LAG_FAILOVER_STATUS.
 *
 */
#define BCM56800_A0_READ_GXPORT_LAG_FAILOVER_STATUSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr,(r._gxport_lag_failover_status))
#define BCM56800_A0_WRITE_GXPORT_LAG_FAILOVER_STATUSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr,&(r._gxport_lag_failover_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GXPORT_LAG_FAILOVER_STATUSr BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr
#define GXPORT_LAG_FAILOVER_STATUSr_SIZE BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_SIZE
typedef BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_t GXPORT_LAG_FAILOVER_STATUSr_t;
#define GXPORT_LAG_FAILOVER_STATUSr_CLR BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_CLR
#define GXPORT_LAG_FAILOVER_STATUSr_SET BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_SET
#define GXPORT_LAG_FAILOVER_STATUSr_GET BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_GET
#define GXPORT_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_GET BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_GET
#define GXPORT_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_SET BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr_LAG_FAILOVER_LOOPBACKf_SET
#define READ_GXPORT_LAG_FAILOVER_STATUSr BCM56800_A0_READ_GXPORT_LAG_FAILOVER_STATUSr
#define WRITE_GXPORT_LAG_FAILOVER_STATUSr BCM56800_A0_WRITE_GXPORT_LAG_FAILOVER_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_GXPORT_LAG_FAILOVER_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Hash Control Register
 * SIZE:     32
 * FIELDS:
 *     NON_UC_TRUNK_HASH_MOD_PORT_ENABLE Enables factoring modid/port into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_SRC_ENABLE Enables factoring source MAC or source IP into non-unicast trunk block mask hashing
 *     NON_UC_TRUNK_HASH_DST_ENABLE Enables factoring dest MAC or dest IP into non-unicast trunk block mask hashing
 *     UC_TRUNK_HASH_USE_SRC_PORT Use src port in unicast trunk hash
 *     ECMP_HASH_UDF    ECMP hash offset
 *     ECMP_HASH_USE_DIP Use DIP for ECMP hashing
 *     ECMP_HASH_SEL    Selects ECMP hashing algorithm
 *     L2_AND_VLAN_MAC_HASH_SELECT Selects hashing algorithm used for L2 table lookups
 *     L3_HASH_SELECT   Selects hashing algorithm used for L3 table lookups
 *     ENABLE_DRACO1_5_HASH Enable using Draco 1.5 hashing for unicast trunking
 *     USE_TCP_UDP_PORTS Use TCP/UDP ports for ECMP/unicast trunk hashing
 *     ECMP_HASH_USE_RTAG7 Use RTAG7 hash for ECMP hashing
 *     NON_UC_TRUNK_HASH_USE_RTAG7 Use RTAG7 hash for non unicast trunk hashing
 *
 ******************************************************************************/
#define BCM56800_A0_HASH_CONTROLr 0x01180604

#define BCM56800_A0_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program HASH_CONTROL.
 *
 */
typedef union BCM56800_A0_HASH_CONTROLr_s {
	uint32_t v[1];
	uint32_t hash_control[1];
	uint32_t _hash_control;
} BCM56800_A0_HASH_CONTROLr_t;

#define BCM56800_A0_HASH_CONTROLr_CLR(r) (r).hash_control[0] = 0
#define BCM56800_A0_HASH_CONTROLr_SET(r,d) (r).hash_control[0] = d
#define BCM56800_A0_HASH_CONTROLr_GET(r) (r).hash_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET(r) (((r).hash_control[0]) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET(r) ((((r).hash_control[0]) >> 1) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET(r) ((((r).hash_control[0]) >> 2) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET(r) ((((r).hash_control[0]) >> 3) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_HASH_CONTROLr_ECMP_HASH_UDFf_GET(r) ((((r).hash_control[0]) >> 4) & 0xff)
#define BCM56800_A0_HASH_CONTROLr_ECMP_HASH_UDFf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4))
#define BCM56800_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET(r) ((((r).hash_control[0]) >> 12) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_HASH_CONTROLr_ECMP_HASH_SELf_GET(r) ((((r).hash_control[0]) >> 13) & 0x3)
#define BCM56800_A0_HASH_CONTROLr_ECMP_HASH_SELf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM56800_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 15) & 0x7)
#define BCM56800_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56800_A0_HASH_CONTROLr_L3_HASH_SELECTf_GET(r) ((((r).hash_control[0]) >> 18) & 0x7)
#define BCM56800_A0_HASH_CONTROLr_L3_HASH_SELECTf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56800_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET(r) ((((r).hash_control[0]) >> 21) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET(r) ((((r).hash_control[0]) >> 22) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_HASH_CONTROLr_ECMP_HASH_USE_RTAG7f_GET(r) ((((r).hash_control[0]) >> 23) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_ECMP_HASH_USE_RTAG7f_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_USE_RTAG7f_GET(r) ((((r).hash_control[0]) >> 24) & 0x1)
#define BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_USE_RTAG7f_SET(r,f) (r).hash_control[0]=(((r).hash_control[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access HASH_CONTROL.
 *
 */
#define BCM56800_A0_READ_HASH_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HASH_CONTROLr,(r._hash_control))
#define BCM56800_A0_WRITE_HASH_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HASH_CONTROLr,&(r._hash_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HASH_CONTROLr BCM56800_A0_HASH_CONTROLr
#define HASH_CONTROLr_SIZE BCM56800_A0_HASH_CONTROLr_SIZE
typedef BCM56800_A0_HASH_CONTROLr_t HASH_CONTROLr_t;
#define HASH_CONTROLr_CLR BCM56800_A0_HASH_CONTROLr_CLR
#define HASH_CONTROLr_SET BCM56800_A0_HASH_CONTROLr_SET
#define HASH_CONTROLr_GET BCM56800_A0_HASH_CONTROLr_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_MOD_PORT_ENABLEf_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_SRC_ENABLEf_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_DST_ENABLEf_SET
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET BCM56800_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_GET
#define HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET BCM56800_A0_HASH_CONTROLr_UC_TRUNK_HASH_USE_SRC_PORTf_SET
#define HASH_CONTROLr_ECMP_HASH_UDFf_GET BCM56800_A0_HASH_CONTROLr_ECMP_HASH_UDFf_GET
#define HASH_CONTROLr_ECMP_HASH_UDFf_SET BCM56800_A0_HASH_CONTROLr_ECMP_HASH_UDFf_SET
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET BCM56800_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_GET
#define HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET BCM56800_A0_HASH_CONTROLr_ECMP_HASH_USE_DIPf_SET
#define HASH_CONTROLr_ECMP_HASH_SELf_GET BCM56800_A0_HASH_CONTROLr_ECMP_HASH_SELf_GET
#define HASH_CONTROLr_ECMP_HASH_SELf_SET BCM56800_A0_HASH_CONTROLr_ECMP_HASH_SELf_SET
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET BCM56800_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_GET
#define HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET BCM56800_A0_HASH_CONTROLr_L2_AND_VLAN_MAC_HASH_SELECTf_SET
#define HASH_CONTROLr_L3_HASH_SELECTf_GET BCM56800_A0_HASH_CONTROLr_L3_HASH_SELECTf_GET
#define HASH_CONTROLr_L3_HASH_SELECTf_SET BCM56800_A0_HASH_CONTROLr_L3_HASH_SELECTf_SET
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET BCM56800_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_GET
#define HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET BCM56800_A0_HASH_CONTROLr_ENABLE_DRACO1_5_HASHf_SET
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET BCM56800_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_GET
#define HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET BCM56800_A0_HASH_CONTROLr_USE_TCP_UDP_PORTSf_SET
#define HASH_CONTROLr_ECMP_HASH_USE_RTAG7f_GET BCM56800_A0_HASH_CONTROLr_ECMP_HASH_USE_RTAG7f_GET
#define HASH_CONTROLr_ECMP_HASH_USE_RTAG7f_SET BCM56800_A0_HASH_CONTROLr_ECMP_HASH_USE_RTAG7f_SET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_USE_RTAG7f_GET BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_USE_RTAG7f_GET
#define HASH_CONTROLr_NON_UC_TRUNK_HASH_USE_RTAG7f_SET BCM56800_A0_HASH_CONTROLr_NON_UC_TRUNK_HASH_USE_RTAG7f_SET
#define READ_HASH_CONTROLr BCM56800_A0_READ_HASH_CONTROLr
#define WRITE_HASH_CONTROLr BCM56800_A0_WRITE_HASH_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HASH_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HG_TRUNK_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     HiGig Trunk [0-7] Membership Bitmap
 * SIZE:     32
 * FIELDS:
 *     HIGIG_TRUNK_BITMAP Port is member of higig trunk if set in bitmap
 *
 ******************************************************************************/
#define BCM56800_A0_HG_TRUNK_BITMAPr 0x0e180628

#define BCM56800_A0_HG_TRUNK_BITMAPr_SIZE 4

/*
 * This structure should be used to declare and program HG_TRUNK_BITMAP.
 *
 */
typedef union BCM56800_A0_HG_TRUNK_BITMAPr_s {
	uint32_t v[1];
	uint32_t hg_trunk_bitmap[1];
	uint32_t _hg_trunk_bitmap;
} BCM56800_A0_HG_TRUNK_BITMAPr_t;

#define BCM56800_A0_HG_TRUNK_BITMAPr_CLR(r) (r).hg_trunk_bitmap[0] = 0
#define BCM56800_A0_HG_TRUNK_BITMAPr_SET(r,d) (r).hg_trunk_bitmap[0] = d
#define BCM56800_A0_HG_TRUNK_BITMAPr_GET(r) (r).hg_trunk_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HG_TRUNK_BITMAPr_HIGIG_TRUNK_BITMAPf_GET(r) (((r).hg_trunk_bitmap[0]) & 0x1fffff)
#define BCM56800_A0_HG_TRUNK_BITMAPr_HIGIG_TRUNK_BITMAPf_SET(r,f) (r).hg_trunk_bitmap[0]=(((r).hg_trunk_bitmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access HG_TRUNK_BITMAP.
 *
 */
#define BCM56800_A0_READ_HG_TRUNK_BITMAPr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_HG_TRUNK_BITMAPr+(i),(r._hg_trunk_bitmap))
#define BCM56800_A0_WRITE_HG_TRUNK_BITMAPr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_HG_TRUNK_BITMAPr+(i),&(r._hg_trunk_bitmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HG_TRUNK_BITMAPr BCM56800_A0_HG_TRUNK_BITMAPr
#define HG_TRUNK_BITMAPr_SIZE BCM56800_A0_HG_TRUNK_BITMAPr_SIZE
typedef BCM56800_A0_HG_TRUNK_BITMAPr_t HG_TRUNK_BITMAPr_t;
#define HG_TRUNK_BITMAPr_CLR BCM56800_A0_HG_TRUNK_BITMAPr_CLR
#define HG_TRUNK_BITMAPr_SET BCM56800_A0_HG_TRUNK_BITMAPr_SET
#define HG_TRUNK_BITMAPr_GET BCM56800_A0_HG_TRUNK_BITMAPr_GET
#define HG_TRUNK_BITMAPr_HIGIG_TRUNK_BITMAPf_GET BCM56800_A0_HG_TRUNK_BITMAPr_HIGIG_TRUNK_BITMAPf_GET
#define HG_TRUNK_BITMAPr_HIGIG_TRUNK_BITMAPf_SET BCM56800_A0_HG_TRUNK_BITMAPr_HIGIG_TRUNK_BITMAPf_SET
#define READ_HG_TRUNK_BITMAPr BCM56800_A0_READ_HG_TRUNK_BITMAPr
#define WRITE_HG_TRUNK_BITMAPr BCM56800_A0_WRITE_HG_TRUNK_BITMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HG_TRUNK_BITMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HG_TRUNK_FAILOVER_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     HiGig Trunk Failover Enable Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           HiGig ports on which failover is enabled, 1=enabled, 0=not enabled.
 *
 ******************************************************************************/
#define BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr 0x0e180638

#define BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program HG_TRUNK_FAILOVER_ENABLE.
 *
 */
typedef union BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_s {
	uint32_t v[1];
	uint32_t hg_trunk_failover_enable[1];
	uint32_t _hg_trunk_failover_enable;
} BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_t;

#define BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_CLR(r) (r).hg_trunk_failover_enable[0] = 0
#define BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_SET(r,d) (r).hg_trunk_failover_enable[0] = d
#define BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_GET(r) (r).hg_trunk_failover_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_BITMAPf_GET(r) (((r).hg_trunk_failover_enable[0]) & 0x1fffff)
#define BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_BITMAPf_SET(r,f) (r).hg_trunk_failover_enable[0]=(((r).hg_trunk_failover_enable[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access HG_TRUNK_FAILOVER_ENABLE.
 *
 */
#define BCM56800_A0_READ_HG_TRUNK_FAILOVER_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr,(r._hg_trunk_failover_enable))
#define BCM56800_A0_WRITE_HG_TRUNK_FAILOVER_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr,&(r._hg_trunk_failover_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HG_TRUNK_FAILOVER_ENABLEr BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr
#define HG_TRUNK_FAILOVER_ENABLEr_SIZE BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_SIZE
typedef BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_t HG_TRUNK_FAILOVER_ENABLEr_t;
#define HG_TRUNK_FAILOVER_ENABLEr_CLR BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_CLR
#define HG_TRUNK_FAILOVER_ENABLEr_SET BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_SET
#define HG_TRUNK_FAILOVER_ENABLEr_GET BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_GET
#define HG_TRUNK_FAILOVER_ENABLEr_BITMAPf_GET BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_BITMAPf_GET
#define HG_TRUNK_FAILOVER_ENABLEr_BITMAPf_SET BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr_BITMAPf_SET
#define READ_HG_TRUNK_FAILOVER_ENABLEr BCM56800_A0_READ_HG_TRUNK_FAILOVER_ENABLEr
#define WRITE_HG_TRUNK_FAILOVER_ENABLEr BCM56800_A0_WRITE_HG_TRUNK_FAILOVER_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HG_TRUNK_FAILOVER_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  HG_TRUNK_FAILOVER_SET
 * BLOCKS:   IPIPE
 * DESC:     Higig Trunk Failover Set Table
 * SIZE:     46
 * FIELDS:
 *     PORT0            failover port 0
 *     PORT1            failover port 1
 *     PORT2            failover port 2
 *     PORT3            failover port 3
 *     PORT4            failover port 4
 *     PORT5            failover port 5
 *     PORT6            failover port 6
 *     PORT7            failover port 7
 *     RTAG             Supported RTAG values
 *     FAILOVER_SET_SIZE Higig failover set size. If set to 0, size=1. If set to 1, size=2, and so on.
 *
 ******************************************************************************/
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm 0x0e12d000

#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_MIN 0
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_MAX 19
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_CMAX(u) 19
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_SIZE 6

/*
 * This structure should be used to declare and program HG_TRUNK_FAILOVER_SET.
 *
 */
typedef union BCM56800_A0_HG_TRUNK_FAILOVER_SETm_s {
	uint32_t v[2];
	uint32_t hg_trunk_failover_set[2];
	uint32_t _hg_trunk_failover_set;
} BCM56800_A0_HG_TRUNK_FAILOVER_SETm_t;

#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_CLR(r) CDK_MEMSET(&((r)._hg_trunk_failover_set), 0, sizeof(BCM56800_A0_HG_TRUNK_FAILOVER_SETm_t))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_SET(r,i,d) (r).hg_trunk_failover_set[i] = d
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_GET(r,i) (r).hg_trunk_failover_set[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT0f_GET(r) (((r).hg_trunk_failover_set[0]) & 0x1f)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT0f_SET(r,f) (r).hg_trunk_failover_set[0]=(((r).hg_trunk_failover_set[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT1f_GET(r) ((((r).hg_trunk_failover_set[0]) >> 5) & 0x1f)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT1f_SET(r,f) (r).hg_trunk_failover_set[0]=(((r).hg_trunk_failover_set[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT2f_GET(r) ((((r).hg_trunk_failover_set[0]) >> 10) & 0x1f)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT2f_SET(r,f) (r).hg_trunk_failover_set[0]=(((r).hg_trunk_failover_set[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT3f_GET(r) ((((r).hg_trunk_failover_set[0]) >> 15) & 0x1f)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT3f_SET(r,f) (r).hg_trunk_failover_set[0]=(((r).hg_trunk_failover_set[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT4f_GET(r) ((((r).hg_trunk_failover_set[0]) >> 20) & 0x1f)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT4f_SET(r,f) (r).hg_trunk_failover_set[0]=(((r).hg_trunk_failover_set[0] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT5f_GET(r) ((((r).hg_trunk_failover_set[0]) >> 25) & 0x1f)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT5f_SET(r,f) (r).hg_trunk_failover_set[0]=(((r).hg_trunk_failover_set[0] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT6f_GET(r) cdk_field32_get((r).hg_trunk_failover_set,30,34)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT6f_SET(r,f) cdk_field32_set((r).hg_trunk_failover_set,30,34,f)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT7f_GET(r) ((((r).hg_trunk_failover_set[1]) >> 3) & 0x1f)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT7f_SET(r,f) (r).hg_trunk_failover_set[1]=(((r).hg_trunk_failover_set[1] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_RTAGf_GET(r) ((((r).hg_trunk_failover_set[1]) >> 8) & 0x7)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_RTAGf_SET(r,f) (r).hg_trunk_failover_set[1]=(((r).hg_trunk_failover_set[1] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_FAILOVER_SET_SIZEf_GET(r) ((((r).hg_trunk_failover_set[1]) >> 11) & 0x7)
#define BCM56800_A0_HG_TRUNK_FAILOVER_SETm_FAILOVER_SET_SIZEf_SET(r,f) (r).hg_trunk_failover_set[1]=(((r).hg_trunk_failover_set[1] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))

/*
 * These macros can be used to access HG_TRUNK_FAILOVER_SET.
 *
 */
#define BCM56800_A0_READ_HG_TRUNK_FAILOVER_SETm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_HG_TRUNK_FAILOVER_SETm,i,(m._hg_trunk_failover_set),2)
#define BCM56800_A0_WRITE_HG_TRUNK_FAILOVER_SETm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_HG_TRUNK_FAILOVER_SETm,i,&(m._hg_trunk_failover_set),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HG_TRUNK_FAILOVER_SETm BCM56800_A0_HG_TRUNK_FAILOVER_SETm
#define HG_TRUNK_FAILOVER_SETm_MIN BCM56800_A0_HG_TRUNK_FAILOVER_SETm_MIN
#define HG_TRUNK_FAILOVER_SETm_MAX BCM56800_A0_HG_TRUNK_FAILOVER_SETm_MAX
#define HG_TRUNK_FAILOVER_SETm_CMAX(u) BCM56800_A0_HG_TRUNK_FAILOVER_SETm_CMAX(u)
#define HG_TRUNK_FAILOVER_SETm_SIZE BCM56800_A0_HG_TRUNK_FAILOVER_SETm_SIZE
typedef BCM56800_A0_HG_TRUNK_FAILOVER_SETm_t HG_TRUNK_FAILOVER_SETm_t;
#define HG_TRUNK_FAILOVER_SETm_CLR BCM56800_A0_HG_TRUNK_FAILOVER_SETm_CLR
#define HG_TRUNK_FAILOVER_SETm_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_SET
#define HG_TRUNK_FAILOVER_SETm_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_GET
#define HG_TRUNK_FAILOVER_SETm_PORT0f_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT0f_GET
#define HG_TRUNK_FAILOVER_SETm_PORT0f_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT0f_SET
#define HG_TRUNK_FAILOVER_SETm_PORT1f_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT1f_GET
#define HG_TRUNK_FAILOVER_SETm_PORT1f_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT1f_SET
#define HG_TRUNK_FAILOVER_SETm_PORT2f_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT2f_GET
#define HG_TRUNK_FAILOVER_SETm_PORT2f_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT2f_SET
#define HG_TRUNK_FAILOVER_SETm_PORT3f_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT3f_GET
#define HG_TRUNK_FAILOVER_SETm_PORT3f_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT3f_SET
#define HG_TRUNK_FAILOVER_SETm_PORT4f_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT4f_GET
#define HG_TRUNK_FAILOVER_SETm_PORT4f_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT4f_SET
#define HG_TRUNK_FAILOVER_SETm_PORT5f_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT5f_GET
#define HG_TRUNK_FAILOVER_SETm_PORT5f_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT5f_SET
#define HG_TRUNK_FAILOVER_SETm_PORT6f_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT6f_GET
#define HG_TRUNK_FAILOVER_SETm_PORT6f_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT6f_SET
#define HG_TRUNK_FAILOVER_SETm_PORT7f_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT7f_GET
#define HG_TRUNK_FAILOVER_SETm_PORT7f_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_PORT7f_SET
#define HG_TRUNK_FAILOVER_SETm_RTAGf_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_RTAGf_GET
#define HG_TRUNK_FAILOVER_SETm_RTAGf_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_RTAGf_SET
#define HG_TRUNK_FAILOVER_SETm_FAILOVER_SET_SIZEf_GET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_FAILOVER_SET_SIZEf_GET
#define HG_TRUNK_FAILOVER_SETm_FAILOVER_SET_SIZEf_SET BCM56800_A0_HG_TRUNK_FAILOVER_SETm_FAILOVER_SET_SIZEf_SET
#define READ_HG_TRUNK_FAILOVER_SETm BCM56800_A0_READ_HG_TRUNK_FAILOVER_SETm
#define WRITE_HG_TRUNK_FAILOVER_SETm BCM56800_A0_WRITE_HG_TRUNK_FAILOVER_SETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HG_TRUNK_FAILOVER_SETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HG_TRUNK_GROUP
 * BLOCKS:   IPIPE
 * DESC:     HiGig Trunk [0-7] membership by port number and RTAG
 * SIZE:     64
 * FIELDS:
 *     HIGIG_TRUNK_RTAG Same encoding as TRUNK_GROUP.RTAG
 *     HIGIG_TRUNK_PORT0 1st port member of this trunk
 *     HIGIG_TRUNK_PORT1 2nd port member of this trunk
 *     HIGIG_TRUNK_PORT2 3rd port member of this trunk
 *     HIGIG_TRUNK_PORT3 4th port member of this trunk
 *     HIGIG_TRUNK_PORT4 5th port member of this trunk
 *     HGTG_RESERVED    reserved field
 *     HIGIG_TRUNK_PORT5 6th port member of this trunk
 *     HIGIG_TRUNK_PORT6 7th port member of this trunk
 *     HIGIG_TRUNK_PORT7 8th port member of this trunk
 *     HIGIG_TRUNK_SIZE Higig trunk group size. If set to 0, size=1. If set to 1, size=2, and so on.
 *
 ******************************************************************************/
#define BCM56800_A0_HG_TRUNK_GROUPr 0x0e180630

#define BCM56800_A0_HG_TRUNK_GROUPr_SIZE 8

/*
 * This structure should be used to declare and program HG_TRUNK_GROUP.
 *
 */
typedef union BCM56800_A0_HG_TRUNK_GROUPr_s {
	uint32_t v[2];
	uint32_t hg_trunk_group[2];
	uint32_t _hg_trunk_group;
} BCM56800_A0_HG_TRUNK_GROUPr_t;

#define BCM56800_A0_HG_TRUNK_GROUPr_CLR(r) CDK_MEMSET(&((r)._hg_trunk_group), 0, sizeof(BCM56800_A0_HG_TRUNK_GROUPr_t))
#define BCM56800_A0_HG_TRUNK_GROUPr_SET(r,i,d) (r).hg_trunk_group[i] = d
#define BCM56800_A0_HG_TRUNK_GROUPr_GET(r,i) (r).hg_trunk_group[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_RTAGf_GET(r) (((r).hg_trunk_group[0]) & 0x7)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_RTAGf_SET(r,f) (r).hg_trunk_group[0]=(((r).hg_trunk_group[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT0f_GET(r) ((((r).hg_trunk_group[0]) >> 3) & 0x1f)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT0f_SET(r,f) (r).hg_trunk_group[0]=(((r).hg_trunk_group[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT1f_GET(r) ((((r).hg_trunk_group[0]) >> 8) & 0x1f)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT1f_SET(r,f) (r).hg_trunk_group[0]=(((r).hg_trunk_group[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT2f_GET(r) ((((r).hg_trunk_group[0]) >> 13) & 0x1f)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT2f_SET(r,f) (r).hg_trunk_group[0]=(((r).hg_trunk_group[0] & ~((uint32_t)0x1f << 13)) | ((((uint32_t)f) & 0x1f) << 13))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT3f_GET(r) ((((r).hg_trunk_group[0]) >> 18) & 0x1f)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT3f_SET(r,f) (r).hg_trunk_group[0]=(((r).hg_trunk_group[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT4f_GET(r) ((((r).hg_trunk_group[0]) >> 23) & 0x1f)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT4f_SET(r,f) (r).hg_trunk_group[0]=(((r).hg_trunk_group[0] & ~((uint32_t)0x1f << 23)) | ((((uint32_t)f) & 0x1f) << 23))
#define BCM56800_A0_HG_TRUNK_GROUPr_HGTG_RESERVEDf_GET(r) ((((r).hg_trunk_group[0]) >> 28) & 0xf)
#define BCM56800_A0_HG_TRUNK_GROUPr_HGTG_RESERVEDf_SET(r,f) (r).hg_trunk_group[0]=(((r).hg_trunk_group[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT5f_GET(r) (((r).hg_trunk_group[1]) & 0x1f)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT5f_SET(r,f) (r).hg_trunk_group[1]=(((r).hg_trunk_group[1] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT6f_GET(r) ((((r).hg_trunk_group[1]) >> 5) & 0x1f)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT6f_SET(r,f) (r).hg_trunk_group[1]=(((r).hg_trunk_group[1] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT7f_GET(r) ((((r).hg_trunk_group[1]) >> 10) & 0x1f)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT7f_SET(r,f) (r).hg_trunk_group[1]=(((r).hg_trunk_group[1] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_SIZEf_GET(r) ((((r).hg_trunk_group[1]) >> 15) & 0x7)
#define BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_SIZEf_SET(r,f) (r).hg_trunk_group[1]=(((r).hg_trunk_group[1] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))

/*
 * These macros can be used to access HG_TRUNK_GROUP.
 *
 */
#define BCM56800_A0_READ_HG_TRUNK_GROUPr(u,i,r) cdk_xgs_reg64_read(u,BCM56800_A0_HG_TRUNK_GROUPr+(i),(r._hg_trunk_group))
#define BCM56800_A0_WRITE_HG_TRUNK_GROUPr(u,i,r) cdk_xgs_reg64_write(u,BCM56800_A0_HG_TRUNK_GROUPr+(i),&(r._hg_trunk_group))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HG_TRUNK_GROUPr BCM56800_A0_HG_TRUNK_GROUPr
#define HG_TRUNK_GROUPr_SIZE BCM56800_A0_HG_TRUNK_GROUPr_SIZE
typedef BCM56800_A0_HG_TRUNK_GROUPr_t HG_TRUNK_GROUPr_t;
#define HG_TRUNK_GROUPr_CLR BCM56800_A0_HG_TRUNK_GROUPr_CLR
#define HG_TRUNK_GROUPr_SET BCM56800_A0_HG_TRUNK_GROUPr_SET
#define HG_TRUNK_GROUPr_GET BCM56800_A0_HG_TRUNK_GROUPr_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_RTAGf_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_RTAGf_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_RTAGf_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_RTAGf_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT0f_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT0f_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT0f_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT0f_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT1f_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT1f_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT1f_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT1f_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT2f_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT2f_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT2f_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT2f_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT3f_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT3f_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT3f_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT3f_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT4f_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT4f_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT4f_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT4f_SET
#define HG_TRUNK_GROUPr_HGTG_RESERVEDf_GET BCM56800_A0_HG_TRUNK_GROUPr_HGTG_RESERVEDf_GET
#define HG_TRUNK_GROUPr_HGTG_RESERVEDf_SET BCM56800_A0_HG_TRUNK_GROUPr_HGTG_RESERVEDf_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT5f_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT5f_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT5f_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT5f_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT6f_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT6f_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT6f_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT6f_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT7f_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT7f_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT7f_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_PORT7f_SET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_SIZEf_GET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_SIZEf_GET
#define HG_TRUNK_GROUPr_HIGIG_TRUNK_SIZEf_SET BCM56800_A0_HG_TRUNK_GROUPr_HIGIG_TRUNK_SIZEf_SET
#define READ_HG_TRUNK_GROUPr BCM56800_A0_READ_HG_TRUNK_GROUPr
#define WRITE_HG_TRUNK_GROUPr BCM56800_A0_WRITE_HG_TRUNK_GROUPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HG_TRUNK_GROUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HIGIG_TRUNK_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     HiGig Trunk Control Register
 * SIZE:     32
 * FIELDS:
 *     ACTIVE_PORT_BITMAP HiGig ports on which active traffic needs to go out
 *
 ******************************************************************************/
#define BCM56800_A0_HIGIG_TRUNK_CONTROLr 0x0e180613

#define BCM56800_A0_HIGIG_TRUNK_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program HIGIG_TRUNK_CONTROL.
 *
 */
typedef union BCM56800_A0_HIGIG_TRUNK_CONTROLr_s {
	uint32_t v[1];
	uint32_t higig_trunk_control[1];
	uint32_t _higig_trunk_control;
} BCM56800_A0_HIGIG_TRUNK_CONTROLr_t;

#define BCM56800_A0_HIGIG_TRUNK_CONTROLr_CLR(r) (r).higig_trunk_control[0] = 0
#define BCM56800_A0_HIGIG_TRUNK_CONTROLr_SET(r,d) (r).higig_trunk_control[0] = d
#define BCM56800_A0_HIGIG_TRUNK_CONTROLr_GET(r) (r).higig_trunk_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_GET(r) (((r).higig_trunk_control[0]) & 0x1fffff)
#define BCM56800_A0_HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_SET(r,f) (r).higig_trunk_control[0]=(((r).higig_trunk_control[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access HIGIG_TRUNK_CONTROL.
 *
 */
#define BCM56800_A0_READ_HIGIG_TRUNK_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HIGIG_TRUNK_CONTROLr,(r._higig_trunk_control))
#define BCM56800_A0_WRITE_HIGIG_TRUNK_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HIGIG_TRUNK_CONTROLr,&(r._higig_trunk_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HIGIG_TRUNK_CONTROLr BCM56800_A0_HIGIG_TRUNK_CONTROLr
#define HIGIG_TRUNK_CONTROLr_SIZE BCM56800_A0_HIGIG_TRUNK_CONTROLr_SIZE
typedef BCM56800_A0_HIGIG_TRUNK_CONTROLr_t HIGIG_TRUNK_CONTROLr_t;
#define HIGIG_TRUNK_CONTROLr_CLR BCM56800_A0_HIGIG_TRUNK_CONTROLr_CLR
#define HIGIG_TRUNK_CONTROLr_SET BCM56800_A0_HIGIG_TRUNK_CONTROLr_SET
#define HIGIG_TRUNK_CONTROLr_GET BCM56800_A0_HIGIG_TRUNK_CONTROLr_GET
#define HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_GET BCM56800_A0_HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_GET
#define HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_SET BCM56800_A0_HIGIG_TRUNK_CONTROLr_ACTIVE_PORT_BITMAPf_SET
#define READ_HIGIG_TRUNK_CONTROLr BCM56800_A0_READ_HIGIG_TRUNK_CONTROLr
#define WRITE_HIGIG_TRUNK_CONTROLr BCM56800_A0_WRITE_HIGIG_TRUNK_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HIGIG_TRUNK_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD
 * BLOCKS:   IPIPE
 * DESC:     Egress per port HOL Drop Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_HOLDr 0x0e100c1c

#define BCM56800_A0_HOLDr_SIZE 4

/*
 * This structure should be used to declare and program HOLD.
 *
 */
typedef union BCM56800_A0_HOLDr_s {
	uint32_t v[1];
	uint32_t hold[1];
	uint32_t _hold;
} BCM56800_A0_HOLDr_t;

#define BCM56800_A0_HOLDr_CLR(r) (r).hold[0] = 0
#define BCM56800_A0_HOLDr_SET(r,d) (r).hold[0] = d
#define BCM56800_A0_HOLDr_GET(r) (r).hold[0]


/*
 * These macros can be used to access HOLD.
 *
 */
#define BCM56800_A0_READ_HOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_HOLDr,(r._hold))
#define BCM56800_A0_WRITE_HOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_HOLDr,&(r._hold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLDr BCM56800_A0_HOLDr
#define HOLDr_SIZE BCM56800_A0_HOLDr_SIZE
typedef BCM56800_A0_HOLDr_t HOLDr_t;
#define HOLDr_CLR BCM56800_A0_HOLDr_CLR
#define HOLDr_SET BCM56800_A0_HOLDr_SET
#define HOLDr_GET BCM56800_A0_HOLDr_GET
#define READ_HOLDr BCM56800_A0_READ_HOLDr
#define WRITE_HOLDr BCM56800_A0_WRITE_HOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS0
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS0 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS0r 0x0e180c00

#define BCM56800_A0_HOLD_COS0r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS0.
 *
 */
typedef union BCM56800_A0_HOLD_COS0r_s {
	uint32_t v[1];
	uint32_t hold_cos0[1];
	uint32_t _hold_cos0;
} BCM56800_A0_HOLD_COS0r_t;

#define BCM56800_A0_HOLD_COS0r_CLR(r) (r).hold_cos0[0] = 0
#define BCM56800_A0_HOLD_COS0r_SET(r,d) (r).hold_cos0[0] = d
#define BCM56800_A0_HOLD_COS0r_GET(r) (r).hold_cos0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS0r_COUNTf_GET(r) (((r).hold_cos0[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS0r_COUNTf_SET(r,f) (r).hold_cos0[0]=(((r).hold_cos0[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS0.
 *
 */
#define BCM56800_A0_READ_HOLD_COS0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS0r,(r._hold_cos0))
#define BCM56800_A0_WRITE_HOLD_COS0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS0r,&(r._hold_cos0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS0r BCM56800_A0_HOLD_COS0r
#define HOLD_COS0r_SIZE BCM56800_A0_HOLD_COS0r_SIZE
typedef BCM56800_A0_HOLD_COS0r_t HOLD_COS0r_t;
#define HOLD_COS0r_CLR BCM56800_A0_HOLD_COS0r_CLR
#define HOLD_COS0r_SET BCM56800_A0_HOLD_COS0r_SET
#define HOLD_COS0r_GET BCM56800_A0_HOLD_COS0r_GET
#define HOLD_COS0r_COUNTf_GET BCM56800_A0_HOLD_COS0r_COUNTf_GET
#define HOLD_COS0r_COUNTf_SET BCM56800_A0_HOLD_COS0r_COUNTf_SET
#define READ_HOLD_COS0r BCM56800_A0_READ_HOLD_COS0r
#define WRITE_HOLD_COS0r BCM56800_A0_WRITE_HOLD_COS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS0_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS0 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS0_Xr 0x0e180200

#define BCM56800_A0_HOLD_COS0_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS0_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS0_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos0_x[1];
	uint32_t _hold_cos0_x;
} BCM56800_A0_HOLD_COS0_Xr_t;

#define BCM56800_A0_HOLD_COS0_Xr_CLR(r) (r).hold_cos0_x[0] = 0
#define BCM56800_A0_HOLD_COS0_Xr_SET(r,d) (r).hold_cos0_x[0] = d
#define BCM56800_A0_HOLD_COS0_Xr_GET(r) (r).hold_cos0_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS0_Xr_COUNTf_GET(r) (((r).hold_cos0_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS0_Xr_COUNTf_SET(r,f) (r).hold_cos0_x[0]=(((r).hold_cos0_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS0_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS0_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS0_Xr,(r._hold_cos0_x))
#define BCM56800_A0_WRITE_HOLD_COS0_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS0_Xr,&(r._hold_cos0_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS0_Xr BCM56800_A0_HOLD_COS0_Xr
#define HOLD_COS0_Xr_SIZE BCM56800_A0_HOLD_COS0_Xr_SIZE
typedef BCM56800_A0_HOLD_COS0_Xr_t HOLD_COS0_Xr_t;
#define HOLD_COS0_Xr_CLR BCM56800_A0_HOLD_COS0_Xr_CLR
#define HOLD_COS0_Xr_SET BCM56800_A0_HOLD_COS0_Xr_SET
#define HOLD_COS0_Xr_GET BCM56800_A0_HOLD_COS0_Xr_GET
#define HOLD_COS0_Xr_COUNTf_GET BCM56800_A0_HOLD_COS0_Xr_COUNTf_GET
#define HOLD_COS0_Xr_COUNTf_SET BCM56800_A0_HOLD_COS0_Xr_COUNTf_SET
#define READ_HOLD_COS0_Xr BCM56800_A0_READ_HOLD_COS0_Xr
#define WRITE_HOLD_COS0_Xr BCM56800_A0_WRITE_HOLD_COS0_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS0_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS0_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS0 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS0_Yr 0x0e180400

#define BCM56800_A0_HOLD_COS0_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS0_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS0_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos0_y[1];
	uint32_t _hold_cos0_y;
} BCM56800_A0_HOLD_COS0_Yr_t;

#define BCM56800_A0_HOLD_COS0_Yr_CLR(r) (r).hold_cos0_y[0] = 0
#define BCM56800_A0_HOLD_COS0_Yr_SET(r,d) (r).hold_cos0_y[0] = d
#define BCM56800_A0_HOLD_COS0_Yr_GET(r) (r).hold_cos0_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS0_Yr_COUNTf_GET(r) (((r).hold_cos0_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS0_Yr_COUNTf_SET(r,f) (r).hold_cos0_y[0]=(((r).hold_cos0_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS0_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS0_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS0_Yr,(r._hold_cos0_y))
#define BCM56800_A0_WRITE_HOLD_COS0_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS0_Yr,&(r._hold_cos0_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS0_Yr BCM56800_A0_HOLD_COS0_Yr
#define HOLD_COS0_Yr_SIZE BCM56800_A0_HOLD_COS0_Yr_SIZE
typedef BCM56800_A0_HOLD_COS0_Yr_t HOLD_COS0_Yr_t;
#define HOLD_COS0_Yr_CLR BCM56800_A0_HOLD_COS0_Yr_CLR
#define HOLD_COS0_Yr_SET BCM56800_A0_HOLD_COS0_Yr_SET
#define HOLD_COS0_Yr_GET BCM56800_A0_HOLD_COS0_Yr_GET
#define HOLD_COS0_Yr_COUNTf_GET BCM56800_A0_HOLD_COS0_Yr_COUNTf_GET
#define HOLD_COS0_Yr_COUNTf_SET BCM56800_A0_HOLD_COS0_Yr_COUNTf_SET
#define READ_HOLD_COS0_Yr BCM56800_A0_READ_HOLD_COS0_Yr
#define WRITE_HOLD_COS0_Yr BCM56800_A0_WRITE_HOLD_COS0_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS0_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS1
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS1 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS1r 0x0e180c01

#define BCM56800_A0_HOLD_COS1r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS1.
 *
 */
typedef union BCM56800_A0_HOLD_COS1r_s {
	uint32_t v[1];
	uint32_t hold_cos1[1];
	uint32_t _hold_cos1;
} BCM56800_A0_HOLD_COS1r_t;

#define BCM56800_A0_HOLD_COS1r_CLR(r) (r).hold_cos1[0] = 0
#define BCM56800_A0_HOLD_COS1r_SET(r,d) (r).hold_cos1[0] = d
#define BCM56800_A0_HOLD_COS1r_GET(r) (r).hold_cos1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS1r_COUNTf_GET(r) (((r).hold_cos1[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS1r_COUNTf_SET(r,f) (r).hold_cos1[0]=(((r).hold_cos1[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS1.
 *
 */
#define BCM56800_A0_READ_HOLD_COS1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS1r,(r._hold_cos1))
#define BCM56800_A0_WRITE_HOLD_COS1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS1r,&(r._hold_cos1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS1r BCM56800_A0_HOLD_COS1r
#define HOLD_COS1r_SIZE BCM56800_A0_HOLD_COS1r_SIZE
typedef BCM56800_A0_HOLD_COS1r_t HOLD_COS1r_t;
#define HOLD_COS1r_CLR BCM56800_A0_HOLD_COS1r_CLR
#define HOLD_COS1r_SET BCM56800_A0_HOLD_COS1r_SET
#define HOLD_COS1r_GET BCM56800_A0_HOLD_COS1r_GET
#define HOLD_COS1r_COUNTf_GET BCM56800_A0_HOLD_COS1r_COUNTf_GET
#define HOLD_COS1r_COUNTf_SET BCM56800_A0_HOLD_COS1r_COUNTf_SET
#define READ_HOLD_COS1r BCM56800_A0_READ_HOLD_COS1r
#define WRITE_HOLD_COS1r BCM56800_A0_WRITE_HOLD_COS1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS1_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS1 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS1_Xr 0x0e180201

#define BCM56800_A0_HOLD_COS1_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS1_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS1_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos1_x[1];
	uint32_t _hold_cos1_x;
} BCM56800_A0_HOLD_COS1_Xr_t;

#define BCM56800_A0_HOLD_COS1_Xr_CLR(r) (r).hold_cos1_x[0] = 0
#define BCM56800_A0_HOLD_COS1_Xr_SET(r,d) (r).hold_cos1_x[0] = d
#define BCM56800_A0_HOLD_COS1_Xr_GET(r) (r).hold_cos1_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS1_Xr_COUNTf_GET(r) (((r).hold_cos1_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS1_Xr_COUNTf_SET(r,f) (r).hold_cos1_x[0]=(((r).hold_cos1_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS1_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS1_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS1_Xr,(r._hold_cos1_x))
#define BCM56800_A0_WRITE_HOLD_COS1_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS1_Xr,&(r._hold_cos1_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS1_Xr BCM56800_A0_HOLD_COS1_Xr
#define HOLD_COS1_Xr_SIZE BCM56800_A0_HOLD_COS1_Xr_SIZE
typedef BCM56800_A0_HOLD_COS1_Xr_t HOLD_COS1_Xr_t;
#define HOLD_COS1_Xr_CLR BCM56800_A0_HOLD_COS1_Xr_CLR
#define HOLD_COS1_Xr_SET BCM56800_A0_HOLD_COS1_Xr_SET
#define HOLD_COS1_Xr_GET BCM56800_A0_HOLD_COS1_Xr_GET
#define HOLD_COS1_Xr_COUNTf_GET BCM56800_A0_HOLD_COS1_Xr_COUNTf_GET
#define HOLD_COS1_Xr_COUNTf_SET BCM56800_A0_HOLD_COS1_Xr_COUNTf_SET
#define READ_HOLD_COS1_Xr BCM56800_A0_READ_HOLD_COS1_Xr
#define WRITE_HOLD_COS1_Xr BCM56800_A0_WRITE_HOLD_COS1_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS1_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS1_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS1 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS1_Yr 0x0e180401

#define BCM56800_A0_HOLD_COS1_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS1_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS1_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos1_y[1];
	uint32_t _hold_cos1_y;
} BCM56800_A0_HOLD_COS1_Yr_t;

#define BCM56800_A0_HOLD_COS1_Yr_CLR(r) (r).hold_cos1_y[0] = 0
#define BCM56800_A0_HOLD_COS1_Yr_SET(r,d) (r).hold_cos1_y[0] = d
#define BCM56800_A0_HOLD_COS1_Yr_GET(r) (r).hold_cos1_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS1_Yr_COUNTf_GET(r) (((r).hold_cos1_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS1_Yr_COUNTf_SET(r,f) (r).hold_cos1_y[0]=(((r).hold_cos1_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS1_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS1_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS1_Yr,(r._hold_cos1_y))
#define BCM56800_A0_WRITE_HOLD_COS1_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS1_Yr,&(r._hold_cos1_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS1_Yr BCM56800_A0_HOLD_COS1_Yr
#define HOLD_COS1_Yr_SIZE BCM56800_A0_HOLD_COS1_Yr_SIZE
typedef BCM56800_A0_HOLD_COS1_Yr_t HOLD_COS1_Yr_t;
#define HOLD_COS1_Yr_CLR BCM56800_A0_HOLD_COS1_Yr_CLR
#define HOLD_COS1_Yr_SET BCM56800_A0_HOLD_COS1_Yr_SET
#define HOLD_COS1_Yr_GET BCM56800_A0_HOLD_COS1_Yr_GET
#define HOLD_COS1_Yr_COUNTf_GET BCM56800_A0_HOLD_COS1_Yr_COUNTf_GET
#define HOLD_COS1_Yr_COUNTf_SET BCM56800_A0_HOLD_COS1_Yr_COUNTf_SET
#define READ_HOLD_COS1_Yr BCM56800_A0_READ_HOLD_COS1_Yr
#define WRITE_HOLD_COS1_Yr BCM56800_A0_WRITE_HOLD_COS1_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS1_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS2
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS2 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS2r 0x0e180c02

#define BCM56800_A0_HOLD_COS2r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS2.
 *
 */
typedef union BCM56800_A0_HOLD_COS2r_s {
	uint32_t v[1];
	uint32_t hold_cos2[1];
	uint32_t _hold_cos2;
} BCM56800_A0_HOLD_COS2r_t;

#define BCM56800_A0_HOLD_COS2r_CLR(r) (r).hold_cos2[0] = 0
#define BCM56800_A0_HOLD_COS2r_SET(r,d) (r).hold_cos2[0] = d
#define BCM56800_A0_HOLD_COS2r_GET(r) (r).hold_cos2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS2r_COUNTf_GET(r) (((r).hold_cos2[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS2r_COUNTf_SET(r,f) (r).hold_cos2[0]=(((r).hold_cos2[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS2.
 *
 */
#define BCM56800_A0_READ_HOLD_COS2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS2r,(r._hold_cos2))
#define BCM56800_A0_WRITE_HOLD_COS2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS2r,&(r._hold_cos2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS2r BCM56800_A0_HOLD_COS2r
#define HOLD_COS2r_SIZE BCM56800_A0_HOLD_COS2r_SIZE
typedef BCM56800_A0_HOLD_COS2r_t HOLD_COS2r_t;
#define HOLD_COS2r_CLR BCM56800_A0_HOLD_COS2r_CLR
#define HOLD_COS2r_SET BCM56800_A0_HOLD_COS2r_SET
#define HOLD_COS2r_GET BCM56800_A0_HOLD_COS2r_GET
#define HOLD_COS2r_COUNTf_GET BCM56800_A0_HOLD_COS2r_COUNTf_GET
#define HOLD_COS2r_COUNTf_SET BCM56800_A0_HOLD_COS2r_COUNTf_SET
#define READ_HOLD_COS2r BCM56800_A0_READ_HOLD_COS2r
#define WRITE_HOLD_COS2r BCM56800_A0_WRITE_HOLD_COS2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS2_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS2 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS2_Xr 0x0e180202

#define BCM56800_A0_HOLD_COS2_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS2_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS2_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos2_x[1];
	uint32_t _hold_cos2_x;
} BCM56800_A0_HOLD_COS2_Xr_t;

#define BCM56800_A0_HOLD_COS2_Xr_CLR(r) (r).hold_cos2_x[0] = 0
#define BCM56800_A0_HOLD_COS2_Xr_SET(r,d) (r).hold_cos2_x[0] = d
#define BCM56800_A0_HOLD_COS2_Xr_GET(r) (r).hold_cos2_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS2_Xr_COUNTf_GET(r) (((r).hold_cos2_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS2_Xr_COUNTf_SET(r,f) (r).hold_cos2_x[0]=(((r).hold_cos2_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS2_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS2_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS2_Xr,(r._hold_cos2_x))
#define BCM56800_A0_WRITE_HOLD_COS2_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS2_Xr,&(r._hold_cos2_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS2_Xr BCM56800_A0_HOLD_COS2_Xr
#define HOLD_COS2_Xr_SIZE BCM56800_A0_HOLD_COS2_Xr_SIZE
typedef BCM56800_A0_HOLD_COS2_Xr_t HOLD_COS2_Xr_t;
#define HOLD_COS2_Xr_CLR BCM56800_A0_HOLD_COS2_Xr_CLR
#define HOLD_COS2_Xr_SET BCM56800_A0_HOLD_COS2_Xr_SET
#define HOLD_COS2_Xr_GET BCM56800_A0_HOLD_COS2_Xr_GET
#define HOLD_COS2_Xr_COUNTf_GET BCM56800_A0_HOLD_COS2_Xr_COUNTf_GET
#define HOLD_COS2_Xr_COUNTf_SET BCM56800_A0_HOLD_COS2_Xr_COUNTf_SET
#define READ_HOLD_COS2_Xr BCM56800_A0_READ_HOLD_COS2_Xr
#define WRITE_HOLD_COS2_Xr BCM56800_A0_WRITE_HOLD_COS2_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS2_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS2_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS2 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS2_Yr 0x0e180402

#define BCM56800_A0_HOLD_COS2_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS2_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS2_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos2_y[1];
	uint32_t _hold_cos2_y;
} BCM56800_A0_HOLD_COS2_Yr_t;

#define BCM56800_A0_HOLD_COS2_Yr_CLR(r) (r).hold_cos2_y[0] = 0
#define BCM56800_A0_HOLD_COS2_Yr_SET(r,d) (r).hold_cos2_y[0] = d
#define BCM56800_A0_HOLD_COS2_Yr_GET(r) (r).hold_cos2_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS2_Yr_COUNTf_GET(r) (((r).hold_cos2_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS2_Yr_COUNTf_SET(r,f) (r).hold_cos2_y[0]=(((r).hold_cos2_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS2_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS2_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS2_Yr,(r._hold_cos2_y))
#define BCM56800_A0_WRITE_HOLD_COS2_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS2_Yr,&(r._hold_cos2_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS2_Yr BCM56800_A0_HOLD_COS2_Yr
#define HOLD_COS2_Yr_SIZE BCM56800_A0_HOLD_COS2_Yr_SIZE
typedef BCM56800_A0_HOLD_COS2_Yr_t HOLD_COS2_Yr_t;
#define HOLD_COS2_Yr_CLR BCM56800_A0_HOLD_COS2_Yr_CLR
#define HOLD_COS2_Yr_SET BCM56800_A0_HOLD_COS2_Yr_SET
#define HOLD_COS2_Yr_GET BCM56800_A0_HOLD_COS2_Yr_GET
#define HOLD_COS2_Yr_COUNTf_GET BCM56800_A0_HOLD_COS2_Yr_COUNTf_GET
#define HOLD_COS2_Yr_COUNTf_SET BCM56800_A0_HOLD_COS2_Yr_COUNTf_SET
#define READ_HOLD_COS2_Yr BCM56800_A0_READ_HOLD_COS2_Yr
#define WRITE_HOLD_COS2_Yr BCM56800_A0_WRITE_HOLD_COS2_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS2_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS3
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS3 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS3r 0x0e180c03

#define BCM56800_A0_HOLD_COS3r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS3.
 *
 */
typedef union BCM56800_A0_HOLD_COS3r_s {
	uint32_t v[1];
	uint32_t hold_cos3[1];
	uint32_t _hold_cos3;
} BCM56800_A0_HOLD_COS3r_t;

#define BCM56800_A0_HOLD_COS3r_CLR(r) (r).hold_cos3[0] = 0
#define BCM56800_A0_HOLD_COS3r_SET(r,d) (r).hold_cos3[0] = d
#define BCM56800_A0_HOLD_COS3r_GET(r) (r).hold_cos3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS3r_COUNTf_GET(r) (((r).hold_cos3[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS3r_COUNTf_SET(r,f) (r).hold_cos3[0]=(((r).hold_cos3[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS3.
 *
 */
#define BCM56800_A0_READ_HOLD_COS3r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS3r,(r._hold_cos3))
#define BCM56800_A0_WRITE_HOLD_COS3r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS3r,&(r._hold_cos3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS3r BCM56800_A0_HOLD_COS3r
#define HOLD_COS3r_SIZE BCM56800_A0_HOLD_COS3r_SIZE
typedef BCM56800_A0_HOLD_COS3r_t HOLD_COS3r_t;
#define HOLD_COS3r_CLR BCM56800_A0_HOLD_COS3r_CLR
#define HOLD_COS3r_SET BCM56800_A0_HOLD_COS3r_SET
#define HOLD_COS3r_GET BCM56800_A0_HOLD_COS3r_GET
#define HOLD_COS3r_COUNTf_GET BCM56800_A0_HOLD_COS3r_COUNTf_GET
#define HOLD_COS3r_COUNTf_SET BCM56800_A0_HOLD_COS3r_COUNTf_SET
#define READ_HOLD_COS3r BCM56800_A0_READ_HOLD_COS3r
#define WRITE_HOLD_COS3r BCM56800_A0_WRITE_HOLD_COS3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS3_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS3 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS3_Xr 0x0e180203

#define BCM56800_A0_HOLD_COS3_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS3_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS3_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos3_x[1];
	uint32_t _hold_cos3_x;
} BCM56800_A0_HOLD_COS3_Xr_t;

#define BCM56800_A0_HOLD_COS3_Xr_CLR(r) (r).hold_cos3_x[0] = 0
#define BCM56800_A0_HOLD_COS3_Xr_SET(r,d) (r).hold_cos3_x[0] = d
#define BCM56800_A0_HOLD_COS3_Xr_GET(r) (r).hold_cos3_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS3_Xr_COUNTf_GET(r) (((r).hold_cos3_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS3_Xr_COUNTf_SET(r,f) (r).hold_cos3_x[0]=(((r).hold_cos3_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS3_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS3_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS3_Xr,(r._hold_cos3_x))
#define BCM56800_A0_WRITE_HOLD_COS3_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS3_Xr,&(r._hold_cos3_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS3_Xr BCM56800_A0_HOLD_COS3_Xr
#define HOLD_COS3_Xr_SIZE BCM56800_A0_HOLD_COS3_Xr_SIZE
typedef BCM56800_A0_HOLD_COS3_Xr_t HOLD_COS3_Xr_t;
#define HOLD_COS3_Xr_CLR BCM56800_A0_HOLD_COS3_Xr_CLR
#define HOLD_COS3_Xr_SET BCM56800_A0_HOLD_COS3_Xr_SET
#define HOLD_COS3_Xr_GET BCM56800_A0_HOLD_COS3_Xr_GET
#define HOLD_COS3_Xr_COUNTf_GET BCM56800_A0_HOLD_COS3_Xr_COUNTf_GET
#define HOLD_COS3_Xr_COUNTf_SET BCM56800_A0_HOLD_COS3_Xr_COUNTf_SET
#define READ_HOLD_COS3_Xr BCM56800_A0_READ_HOLD_COS3_Xr
#define WRITE_HOLD_COS3_Xr BCM56800_A0_WRITE_HOLD_COS3_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS3_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS3_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS3 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS3_Yr 0x0e180403

#define BCM56800_A0_HOLD_COS3_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS3_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS3_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos3_y[1];
	uint32_t _hold_cos3_y;
} BCM56800_A0_HOLD_COS3_Yr_t;

#define BCM56800_A0_HOLD_COS3_Yr_CLR(r) (r).hold_cos3_y[0] = 0
#define BCM56800_A0_HOLD_COS3_Yr_SET(r,d) (r).hold_cos3_y[0] = d
#define BCM56800_A0_HOLD_COS3_Yr_GET(r) (r).hold_cos3_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS3_Yr_COUNTf_GET(r) (((r).hold_cos3_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS3_Yr_COUNTf_SET(r,f) (r).hold_cos3_y[0]=(((r).hold_cos3_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS3_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS3_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS3_Yr,(r._hold_cos3_y))
#define BCM56800_A0_WRITE_HOLD_COS3_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS3_Yr,&(r._hold_cos3_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS3_Yr BCM56800_A0_HOLD_COS3_Yr
#define HOLD_COS3_Yr_SIZE BCM56800_A0_HOLD_COS3_Yr_SIZE
typedef BCM56800_A0_HOLD_COS3_Yr_t HOLD_COS3_Yr_t;
#define HOLD_COS3_Yr_CLR BCM56800_A0_HOLD_COS3_Yr_CLR
#define HOLD_COS3_Yr_SET BCM56800_A0_HOLD_COS3_Yr_SET
#define HOLD_COS3_Yr_GET BCM56800_A0_HOLD_COS3_Yr_GET
#define HOLD_COS3_Yr_COUNTf_GET BCM56800_A0_HOLD_COS3_Yr_COUNTf_GET
#define HOLD_COS3_Yr_COUNTf_SET BCM56800_A0_HOLD_COS3_Yr_COUNTf_SET
#define READ_HOLD_COS3_Yr BCM56800_A0_READ_HOLD_COS3_Yr
#define WRITE_HOLD_COS3_Yr BCM56800_A0_WRITE_HOLD_COS3_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS3_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS4
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS4 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS4r 0x0e180c04

#define BCM56800_A0_HOLD_COS4r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS4.
 *
 */
typedef union BCM56800_A0_HOLD_COS4r_s {
	uint32_t v[1];
	uint32_t hold_cos4[1];
	uint32_t _hold_cos4;
} BCM56800_A0_HOLD_COS4r_t;

#define BCM56800_A0_HOLD_COS4r_CLR(r) (r).hold_cos4[0] = 0
#define BCM56800_A0_HOLD_COS4r_SET(r,d) (r).hold_cos4[0] = d
#define BCM56800_A0_HOLD_COS4r_GET(r) (r).hold_cos4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS4r_COUNTf_GET(r) (((r).hold_cos4[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS4r_COUNTf_SET(r,f) (r).hold_cos4[0]=(((r).hold_cos4[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS4.
 *
 */
#define BCM56800_A0_READ_HOLD_COS4r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS4r,(r._hold_cos4))
#define BCM56800_A0_WRITE_HOLD_COS4r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS4r,&(r._hold_cos4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS4r BCM56800_A0_HOLD_COS4r
#define HOLD_COS4r_SIZE BCM56800_A0_HOLD_COS4r_SIZE
typedef BCM56800_A0_HOLD_COS4r_t HOLD_COS4r_t;
#define HOLD_COS4r_CLR BCM56800_A0_HOLD_COS4r_CLR
#define HOLD_COS4r_SET BCM56800_A0_HOLD_COS4r_SET
#define HOLD_COS4r_GET BCM56800_A0_HOLD_COS4r_GET
#define HOLD_COS4r_COUNTf_GET BCM56800_A0_HOLD_COS4r_COUNTf_GET
#define HOLD_COS4r_COUNTf_SET BCM56800_A0_HOLD_COS4r_COUNTf_SET
#define READ_HOLD_COS4r BCM56800_A0_READ_HOLD_COS4r
#define WRITE_HOLD_COS4r BCM56800_A0_WRITE_HOLD_COS4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS4_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS4 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS4_Xr 0x0e180204

#define BCM56800_A0_HOLD_COS4_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS4_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS4_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos4_x[1];
	uint32_t _hold_cos4_x;
} BCM56800_A0_HOLD_COS4_Xr_t;

#define BCM56800_A0_HOLD_COS4_Xr_CLR(r) (r).hold_cos4_x[0] = 0
#define BCM56800_A0_HOLD_COS4_Xr_SET(r,d) (r).hold_cos4_x[0] = d
#define BCM56800_A0_HOLD_COS4_Xr_GET(r) (r).hold_cos4_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS4_Xr_COUNTf_GET(r) (((r).hold_cos4_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS4_Xr_COUNTf_SET(r,f) (r).hold_cos4_x[0]=(((r).hold_cos4_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS4_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS4_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS4_Xr,(r._hold_cos4_x))
#define BCM56800_A0_WRITE_HOLD_COS4_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS4_Xr,&(r._hold_cos4_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS4_Xr BCM56800_A0_HOLD_COS4_Xr
#define HOLD_COS4_Xr_SIZE BCM56800_A0_HOLD_COS4_Xr_SIZE
typedef BCM56800_A0_HOLD_COS4_Xr_t HOLD_COS4_Xr_t;
#define HOLD_COS4_Xr_CLR BCM56800_A0_HOLD_COS4_Xr_CLR
#define HOLD_COS4_Xr_SET BCM56800_A0_HOLD_COS4_Xr_SET
#define HOLD_COS4_Xr_GET BCM56800_A0_HOLD_COS4_Xr_GET
#define HOLD_COS4_Xr_COUNTf_GET BCM56800_A0_HOLD_COS4_Xr_COUNTf_GET
#define HOLD_COS4_Xr_COUNTf_SET BCM56800_A0_HOLD_COS4_Xr_COUNTf_SET
#define READ_HOLD_COS4_Xr BCM56800_A0_READ_HOLD_COS4_Xr
#define WRITE_HOLD_COS4_Xr BCM56800_A0_WRITE_HOLD_COS4_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS4_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS4_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS4 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS4_Yr 0x0e180404

#define BCM56800_A0_HOLD_COS4_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS4_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS4_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos4_y[1];
	uint32_t _hold_cos4_y;
} BCM56800_A0_HOLD_COS4_Yr_t;

#define BCM56800_A0_HOLD_COS4_Yr_CLR(r) (r).hold_cos4_y[0] = 0
#define BCM56800_A0_HOLD_COS4_Yr_SET(r,d) (r).hold_cos4_y[0] = d
#define BCM56800_A0_HOLD_COS4_Yr_GET(r) (r).hold_cos4_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS4_Yr_COUNTf_GET(r) (((r).hold_cos4_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS4_Yr_COUNTf_SET(r,f) (r).hold_cos4_y[0]=(((r).hold_cos4_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS4_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS4_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS4_Yr,(r._hold_cos4_y))
#define BCM56800_A0_WRITE_HOLD_COS4_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS4_Yr,&(r._hold_cos4_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS4_Yr BCM56800_A0_HOLD_COS4_Yr
#define HOLD_COS4_Yr_SIZE BCM56800_A0_HOLD_COS4_Yr_SIZE
typedef BCM56800_A0_HOLD_COS4_Yr_t HOLD_COS4_Yr_t;
#define HOLD_COS4_Yr_CLR BCM56800_A0_HOLD_COS4_Yr_CLR
#define HOLD_COS4_Yr_SET BCM56800_A0_HOLD_COS4_Yr_SET
#define HOLD_COS4_Yr_GET BCM56800_A0_HOLD_COS4_Yr_GET
#define HOLD_COS4_Yr_COUNTf_GET BCM56800_A0_HOLD_COS4_Yr_COUNTf_GET
#define HOLD_COS4_Yr_COUNTf_SET BCM56800_A0_HOLD_COS4_Yr_COUNTf_SET
#define READ_HOLD_COS4_Yr BCM56800_A0_READ_HOLD_COS4_Yr
#define WRITE_HOLD_COS4_Yr BCM56800_A0_WRITE_HOLD_COS4_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS4_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS5
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS5 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS5r 0x0e180c05

#define BCM56800_A0_HOLD_COS5r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS5.
 *
 */
typedef union BCM56800_A0_HOLD_COS5r_s {
	uint32_t v[1];
	uint32_t hold_cos5[1];
	uint32_t _hold_cos5;
} BCM56800_A0_HOLD_COS5r_t;

#define BCM56800_A0_HOLD_COS5r_CLR(r) (r).hold_cos5[0] = 0
#define BCM56800_A0_HOLD_COS5r_SET(r,d) (r).hold_cos5[0] = d
#define BCM56800_A0_HOLD_COS5r_GET(r) (r).hold_cos5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS5r_COUNTf_GET(r) (((r).hold_cos5[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS5r_COUNTf_SET(r,f) (r).hold_cos5[0]=(((r).hold_cos5[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS5.
 *
 */
#define BCM56800_A0_READ_HOLD_COS5r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS5r,(r._hold_cos5))
#define BCM56800_A0_WRITE_HOLD_COS5r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS5r,&(r._hold_cos5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS5r BCM56800_A0_HOLD_COS5r
#define HOLD_COS5r_SIZE BCM56800_A0_HOLD_COS5r_SIZE
typedef BCM56800_A0_HOLD_COS5r_t HOLD_COS5r_t;
#define HOLD_COS5r_CLR BCM56800_A0_HOLD_COS5r_CLR
#define HOLD_COS5r_SET BCM56800_A0_HOLD_COS5r_SET
#define HOLD_COS5r_GET BCM56800_A0_HOLD_COS5r_GET
#define HOLD_COS5r_COUNTf_GET BCM56800_A0_HOLD_COS5r_COUNTf_GET
#define HOLD_COS5r_COUNTf_SET BCM56800_A0_HOLD_COS5r_COUNTf_SET
#define READ_HOLD_COS5r BCM56800_A0_READ_HOLD_COS5r
#define WRITE_HOLD_COS5r BCM56800_A0_WRITE_HOLD_COS5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS5_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS5 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS5_Xr 0x0e180205

#define BCM56800_A0_HOLD_COS5_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS5_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS5_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos5_x[1];
	uint32_t _hold_cos5_x;
} BCM56800_A0_HOLD_COS5_Xr_t;

#define BCM56800_A0_HOLD_COS5_Xr_CLR(r) (r).hold_cos5_x[0] = 0
#define BCM56800_A0_HOLD_COS5_Xr_SET(r,d) (r).hold_cos5_x[0] = d
#define BCM56800_A0_HOLD_COS5_Xr_GET(r) (r).hold_cos5_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS5_Xr_COUNTf_GET(r) (((r).hold_cos5_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS5_Xr_COUNTf_SET(r,f) (r).hold_cos5_x[0]=(((r).hold_cos5_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS5_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS5_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS5_Xr,(r._hold_cos5_x))
#define BCM56800_A0_WRITE_HOLD_COS5_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS5_Xr,&(r._hold_cos5_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS5_Xr BCM56800_A0_HOLD_COS5_Xr
#define HOLD_COS5_Xr_SIZE BCM56800_A0_HOLD_COS5_Xr_SIZE
typedef BCM56800_A0_HOLD_COS5_Xr_t HOLD_COS5_Xr_t;
#define HOLD_COS5_Xr_CLR BCM56800_A0_HOLD_COS5_Xr_CLR
#define HOLD_COS5_Xr_SET BCM56800_A0_HOLD_COS5_Xr_SET
#define HOLD_COS5_Xr_GET BCM56800_A0_HOLD_COS5_Xr_GET
#define HOLD_COS5_Xr_COUNTf_GET BCM56800_A0_HOLD_COS5_Xr_COUNTf_GET
#define HOLD_COS5_Xr_COUNTf_SET BCM56800_A0_HOLD_COS5_Xr_COUNTf_SET
#define READ_HOLD_COS5_Xr BCM56800_A0_READ_HOLD_COS5_Xr
#define WRITE_HOLD_COS5_Xr BCM56800_A0_WRITE_HOLD_COS5_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS5_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS5_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS5 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS5_Yr 0x0e180405

#define BCM56800_A0_HOLD_COS5_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS5_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS5_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos5_y[1];
	uint32_t _hold_cos5_y;
} BCM56800_A0_HOLD_COS5_Yr_t;

#define BCM56800_A0_HOLD_COS5_Yr_CLR(r) (r).hold_cos5_y[0] = 0
#define BCM56800_A0_HOLD_COS5_Yr_SET(r,d) (r).hold_cos5_y[0] = d
#define BCM56800_A0_HOLD_COS5_Yr_GET(r) (r).hold_cos5_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS5_Yr_COUNTf_GET(r) (((r).hold_cos5_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS5_Yr_COUNTf_SET(r,f) (r).hold_cos5_y[0]=(((r).hold_cos5_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS5_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS5_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS5_Yr,(r._hold_cos5_y))
#define BCM56800_A0_WRITE_HOLD_COS5_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS5_Yr,&(r._hold_cos5_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS5_Yr BCM56800_A0_HOLD_COS5_Yr
#define HOLD_COS5_Yr_SIZE BCM56800_A0_HOLD_COS5_Yr_SIZE
typedef BCM56800_A0_HOLD_COS5_Yr_t HOLD_COS5_Yr_t;
#define HOLD_COS5_Yr_CLR BCM56800_A0_HOLD_COS5_Yr_CLR
#define HOLD_COS5_Yr_SET BCM56800_A0_HOLD_COS5_Yr_SET
#define HOLD_COS5_Yr_GET BCM56800_A0_HOLD_COS5_Yr_GET
#define HOLD_COS5_Yr_COUNTf_GET BCM56800_A0_HOLD_COS5_Yr_COUNTf_GET
#define HOLD_COS5_Yr_COUNTf_SET BCM56800_A0_HOLD_COS5_Yr_COUNTf_SET
#define READ_HOLD_COS5_Yr BCM56800_A0_READ_HOLD_COS5_Yr
#define WRITE_HOLD_COS5_Yr BCM56800_A0_WRITE_HOLD_COS5_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS5_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS6
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS6 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS6r 0x0e180c06

#define BCM56800_A0_HOLD_COS6r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS6.
 *
 */
typedef union BCM56800_A0_HOLD_COS6r_s {
	uint32_t v[1];
	uint32_t hold_cos6[1];
	uint32_t _hold_cos6;
} BCM56800_A0_HOLD_COS6r_t;

#define BCM56800_A0_HOLD_COS6r_CLR(r) (r).hold_cos6[0] = 0
#define BCM56800_A0_HOLD_COS6r_SET(r,d) (r).hold_cos6[0] = d
#define BCM56800_A0_HOLD_COS6r_GET(r) (r).hold_cos6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS6r_COUNTf_GET(r) (((r).hold_cos6[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS6r_COUNTf_SET(r,f) (r).hold_cos6[0]=(((r).hold_cos6[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS6.
 *
 */
#define BCM56800_A0_READ_HOLD_COS6r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS6r,(r._hold_cos6))
#define BCM56800_A0_WRITE_HOLD_COS6r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS6r,&(r._hold_cos6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS6r BCM56800_A0_HOLD_COS6r
#define HOLD_COS6r_SIZE BCM56800_A0_HOLD_COS6r_SIZE
typedef BCM56800_A0_HOLD_COS6r_t HOLD_COS6r_t;
#define HOLD_COS6r_CLR BCM56800_A0_HOLD_COS6r_CLR
#define HOLD_COS6r_SET BCM56800_A0_HOLD_COS6r_SET
#define HOLD_COS6r_GET BCM56800_A0_HOLD_COS6r_GET
#define HOLD_COS6r_COUNTf_GET BCM56800_A0_HOLD_COS6r_COUNTf_GET
#define HOLD_COS6r_COUNTf_SET BCM56800_A0_HOLD_COS6r_COUNTf_SET
#define READ_HOLD_COS6r BCM56800_A0_READ_HOLD_COS6r
#define WRITE_HOLD_COS6r BCM56800_A0_WRITE_HOLD_COS6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS6_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS6 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS6_Xr 0x0e180206

#define BCM56800_A0_HOLD_COS6_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS6_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS6_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos6_x[1];
	uint32_t _hold_cos6_x;
} BCM56800_A0_HOLD_COS6_Xr_t;

#define BCM56800_A0_HOLD_COS6_Xr_CLR(r) (r).hold_cos6_x[0] = 0
#define BCM56800_A0_HOLD_COS6_Xr_SET(r,d) (r).hold_cos6_x[0] = d
#define BCM56800_A0_HOLD_COS6_Xr_GET(r) (r).hold_cos6_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS6_Xr_COUNTf_GET(r) (((r).hold_cos6_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS6_Xr_COUNTf_SET(r,f) (r).hold_cos6_x[0]=(((r).hold_cos6_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS6_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS6_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS6_Xr,(r._hold_cos6_x))
#define BCM56800_A0_WRITE_HOLD_COS6_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS6_Xr,&(r._hold_cos6_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS6_Xr BCM56800_A0_HOLD_COS6_Xr
#define HOLD_COS6_Xr_SIZE BCM56800_A0_HOLD_COS6_Xr_SIZE
typedef BCM56800_A0_HOLD_COS6_Xr_t HOLD_COS6_Xr_t;
#define HOLD_COS6_Xr_CLR BCM56800_A0_HOLD_COS6_Xr_CLR
#define HOLD_COS6_Xr_SET BCM56800_A0_HOLD_COS6_Xr_SET
#define HOLD_COS6_Xr_GET BCM56800_A0_HOLD_COS6_Xr_GET
#define HOLD_COS6_Xr_COUNTf_GET BCM56800_A0_HOLD_COS6_Xr_COUNTf_GET
#define HOLD_COS6_Xr_COUNTf_SET BCM56800_A0_HOLD_COS6_Xr_COUNTf_SET
#define READ_HOLD_COS6_Xr BCM56800_A0_READ_HOLD_COS6_Xr
#define WRITE_HOLD_COS6_Xr BCM56800_A0_WRITE_HOLD_COS6_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS6_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS6_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS6 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS6_Yr 0x0e180406

#define BCM56800_A0_HOLD_COS6_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS6_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS6_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos6_y[1];
	uint32_t _hold_cos6_y;
} BCM56800_A0_HOLD_COS6_Yr_t;

#define BCM56800_A0_HOLD_COS6_Yr_CLR(r) (r).hold_cos6_y[0] = 0
#define BCM56800_A0_HOLD_COS6_Yr_SET(r,d) (r).hold_cos6_y[0] = d
#define BCM56800_A0_HOLD_COS6_Yr_GET(r) (r).hold_cos6_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS6_Yr_COUNTf_GET(r) (((r).hold_cos6_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS6_Yr_COUNTf_SET(r,f) (r).hold_cos6_y[0]=(((r).hold_cos6_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS6_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS6_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS6_Yr,(r._hold_cos6_y))
#define BCM56800_A0_WRITE_HOLD_COS6_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS6_Yr,&(r._hold_cos6_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS6_Yr BCM56800_A0_HOLD_COS6_Yr
#define HOLD_COS6_Yr_SIZE BCM56800_A0_HOLD_COS6_Yr_SIZE
typedef BCM56800_A0_HOLD_COS6_Yr_t HOLD_COS6_Yr_t;
#define HOLD_COS6_Yr_CLR BCM56800_A0_HOLD_COS6_Yr_CLR
#define HOLD_COS6_Yr_SET BCM56800_A0_HOLD_COS6_Yr_SET
#define HOLD_COS6_Yr_GET BCM56800_A0_HOLD_COS6_Yr_GET
#define HOLD_COS6_Yr_COUNTf_GET BCM56800_A0_HOLD_COS6_Yr_COUNTf_GET
#define HOLD_COS6_Yr_COUNTf_SET BCM56800_A0_HOLD_COS6_Yr_COUNTf_SET
#define READ_HOLD_COS6_Yr BCM56800_A0_READ_HOLD_COS6_Yr
#define WRITE_HOLD_COS6_Yr BCM56800_A0_WRITE_HOLD_COS6_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS6_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS7
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS7 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS7r 0x0e180c07

#define BCM56800_A0_HOLD_COS7r_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS7.
 *
 */
typedef union BCM56800_A0_HOLD_COS7r_s {
	uint32_t v[1];
	uint32_t hold_cos7[1];
	uint32_t _hold_cos7;
} BCM56800_A0_HOLD_COS7r_t;

#define BCM56800_A0_HOLD_COS7r_CLR(r) (r).hold_cos7[0] = 0
#define BCM56800_A0_HOLD_COS7r_SET(r,d) (r).hold_cos7[0] = d
#define BCM56800_A0_HOLD_COS7r_GET(r) (r).hold_cos7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS7r_COUNTf_GET(r) (((r).hold_cos7[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS7r_COUNTf_SET(r,f) (r).hold_cos7[0]=(((r).hold_cos7[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS7.
 *
 */
#define BCM56800_A0_READ_HOLD_COS7r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS7r,(r._hold_cos7))
#define BCM56800_A0_WRITE_HOLD_COS7r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS7r,&(r._hold_cos7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS7r BCM56800_A0_HOLD_COS7r
#define HOLD_COS7r_SIZE BCM56800_A0_HOLD_COS7r_SIZE
typedef BCM56800_A0_HOLD_COS7r_t HOLD_COS7r_t;
#define HOLD_COS7r_CLR BCM56800_A0_HOLD_COS7r_CLR
#define HOLD_COS7r_SET BCM56800_A0_HOLD_COS7r_SET
#define HOLD_COS7r_GET BCM56800_A0_HOLD_COS7r_GET
#define HOLD_COS7r_COUNTf_GET BCM56800_A0_HOLD_COS7r_COUNTf_GET
#define HOLD_COS7r_COUNTf_SET BCM56800_A0_HOLD_COS7r_COUNTf_SET
#define READ_HOLD_COS7r BCM56800_A0_READ_HOLD_COS7r
#define WRITE_HOLD_COS7r BCM56800_A0_WRITE_HOLD_COS7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS7_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS7 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS7_Xr 0x0e180207

#define BCM56800_A0_HOLD_COS7_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS7_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS7_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos7_x[1];
	uint32_t _hold_cos7_x;
} BCM56800_A0_HOLD_COS7_Xr_t;

#define BCM56800_A0_HOLD_COS7_Xr_CLR(r) (r).hold_cos7_x[0] = 0
#define BCM56800_A0_HOLD_COS7_Xr_SET(r,d) (r).hold_cos7_x[0] = d
#define BCM56800_A0_HOLD_COS7_Xr_GET(r) (r).hold_cos7_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS7_Xr_COUNTf_GET(r) (((r).hold_cos7_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS7_Xr_COUNTf_SET(r,f) (r).hold_cos7_x[0]=(((r).hold_cos7_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS7_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS7_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS7_Xr,(r._hold_cos7_x))
#define BCM56800_A0_WRITE_HOLD_COS7_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS7_Xr,&(r._hold_cos7_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS7_Xr BCM56800_A0_HOLD_COS7_Xr
#define HOLD_COS7_Xr_SIZE BCM56800_A0_HOLD_COS7_Xr_SIZE
typedef BCM56800_A0_HOLD_COS7_Xr_t HOLD_COS7_Xr_t;
#define HOLD_COS7_Xr_CLR BCM56800_A0_HOLD_COS7_Xr_CLR
#define HOLD_COS7_Xr_SET BCM56800_A0_HOLD_COS7_Xr_SET
#define HOLD_COS7_Xr_GET BCM56800_A0_HOLD_COS7_Xr_GET
#define HOLD_COS7_Xr_COUNTf_GET BCM56800_A0_HOLD_COS7_Xr_COUNTf_GET
#define HOLD_COS7_Xr_COUNTf_SET BCM56800_A0_HOLD_COS7_Xr_COUNTf_SET
#define READ_HOLD_COS7_Xr BCM56800_A0_READ_HOLD_COS7_Xr
#define WRITE_HOLD_COS7_Xr BCM56800_A0_WRITE_HOLD_COS7_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS7_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS7_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS7 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS7_Yr 0x0e180407

#define BCM56800_A0_HOLD_COS7_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS7_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS7_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos7_y[1];
	uint32_t _hold_cos7_y;
} BCM56800_A0_HOLD_COS7_Yr_t;

#define BCM56800_A0_HOLD_COS7_Yr_CLR(r) (r).hold_cos7_y[0] = 0
#define BCM56800_A0_HOLD_COS7_Yr_SET(r,d) (r).hold_cos7_y[0] = d
#define BCM56800_A0_HOLD_COS7_Yr_GET(r) (r).hold_cos7_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS7_Yr_COUNTf_GET(r) (((r).hold_cos7_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS7_Yr_COUNTf_SET(r,f) (r).hold_cos7_y[0]=(((r).hold_cos7_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS7_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS7_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS7_Yr,(r._hold_cos7_y))
#define BCM56800_A0_WRITE_HOLD_COS7_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS7_Yr,&(r._hold_cos7_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS7_Yr BCM56800_A0_HOLD_COS7_Yr
#define HOLD_COS7_Yr_SIZE BCM56800_A0_HOLD_COS7_Yr_SIZE
typedef BCM56800_A0_HOLD_COS7_Yr_t HOLD_COS7_Yr_t;
#define HOLD_COS7_Yr_CLR BCM56800_A0_HOLD_COS7_Yr_CLR
#define HOLD_COS7_Yr_SET BCM56800_A0_HOLD_COS7_Yr_SET
#define HOLD_COS7_Yr_GET BCM56800_A0_HOLD_COS7_Yr_GET
#define HOLD_COS7_Yr_COUNTf_GET BCM56800_A0_HOLD_COS7_Yr_COUNTf_GET
#define HOLD_COS7_Yr_COUNTf_SET BCM56800_A0_HOLD_COS7_Yr_COUNTf_SET
#define READ_HOLD_COS7_Yr BCM56800_A0_READ_HOLD_COS7_Yr
#define WRITE_HOLD_COS7_Yr BCM56800_A0_WRITE_HOLD_COS7_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS7_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS_PORT_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS Counter Port Select Register
 * SIZE:     32
 * FIELDS:
 *     PORT_NUM         Port number
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS_PORT_SELECTr 0x0e180622

#define BCM56800_A0_HOLD_COS_PORT_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_PORT_SELECT.
 *
 */
typedef union BCM56800_A0_HOLD_COS_PORT_SELECTr_s {
	uint32_t v[1];
	uint32_t hold_cos_port_select[1];
	uint32_t _hold_cos_port_select;
} BCM56800_A0_HOLD_COS_PORT_SELECTr_t;

#define BCM56800_A0_HOLD_COS_PORT_SELECTr_CLR(r) (r).hold_cos_port_select[0] = 0
#define BCM56800_A0_HOLD_COS_PORT_SELECTr_SET(r,d) (r).hold_cos_port_select[0] = d
#define BCM56800_A0_HOLD_COS_PORT_SELECTr_GET(r) (r).hold_cos_port_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_GET(r) (((r).hold_cos_port_select[0]) & 0x1f)
#define BCM56800_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_SET(r,f) (r).hold_cos_port_select[0]=(((r).hold_cos_port_select[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access HOLD_COS_PORT_SELECT.
 *
 */
#define BCM56800_A0_READ_HOLD_COS_PORT_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS_PORT_SELECTr,(r._hold_cos_port_select))
#define BCM56800_A0_WRITE_HOLD_COS_PORT_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS_PORT_SELECTr,&(r._hold_cos_port_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_PORT_SELECTr BCM56800_A0_HOLD_COS_PORT_SELECTr
#define HOLD_COS_PORT_SELECTr_SIZE BCM56800_A0_HOLD_COS_PORT_SELECTr_SIZE
typedef BCM56800_A0_HOLD_COS_PORT_SELECTr_t HOLD_COS_PORT_SELECTr_t;
#define HOLD_COS_PORT_SELECTr_CLR BCM56800_A0_HOLD_COS_PORT_SELECTr_CLR
#define HOLD_COS_PORT_SELECTr_SET BCM56800_A0_HOLD_COS_PORT_SELECTr_SET
#define HOLD_COS_PORT_SELECTr_GET BCM56800_A0_HOLD_COS_PORT_SELECTr_GET
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_GET BCM56800_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_GET
#define HOLD_COS_PORT_SELECTr_PORT_NUMf_SET BCM56800_A0_HOLD_COS_PORT_SELECTr_PORT_NUMf_SET
#define READ_HOLD_COS_PORT_SELECTr BCM56800_A0_READ_HOLD_COS_PORT_SELECTr
#define WRITE_HOLD_COS_PORT_SELECTr BCM56800_A0_WRITE_HOLD_COS_PORT_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS_PORT_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS_QM
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS QM Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS_QMr 0x0e180c09

#define BCM56800_A0_HOLD_COS_QMr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_QM.
 *
 */
typedef union BCM56800_A0_HOLD_COS_QMr_s {
	uint32_t v[1];
	uint32_t hold_cos_qm[1];
	uint32_t _hold_cos_qm;
} BCM56800_A0_HOLD_COS_QMr_t;

#define BCM56800_A0_HOLD_COS_QMr_CLR(r) (r).hold_cos_qm[0] = 0
#define BCM56800_A0_HOLD_COS_QMr_SET(r,d) (r).hold_cos_qm[0] = d
#define BCM56800_A0_HOLD_COS_QMr_GET(r) (r).hold_cos_qm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS_QMr_COUNTf_GET(r) (((r).hold_cos_qm[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS_QMr_COUNTf_SET(r,f) (r).hold_cos_qm[0]=(((r).hold_cos_qm[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS_QM.
 *
 */
#define BCM56800_A0_READ_HOLD_COS_QMr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS_QMr,(r._hold_cos_qm))
#define BCM56800_A0_WRITE_HOLD_COS_QMr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS_QMr,&(r._hold_cos_qm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_QMr BCM56800_A0_HOLD_COS_QMr
#define HOLD_COS_QMr_SIZE BCM56800_A0_HOLD_COS_QMr_SIZE
typedef BCM56800_A0_HOLD_COS_QMr_t HOLD_COS_QMr_t;
#define HOLD_COS_QMr_CLR BCM56800_A0_HOLD_COS_QMr_CLR
#define HOLD_COS_QMr_SET BCM56800_A0_HOLD_COS_QMr_SET
#define HOLD_COS_QMr_GET BCM56800_A0_HOLD_COS_QMr_GET
#define HOLD_COS_QMr_COUNTf_GET BCM56800_A0_HOLD_COS_QMr_COUNTf_GET
#define HOLD_COS_QMr_COUNTf_SET BCM56800_A0_HOLD_COS_QMr_COUNTf_SET
#define READ_HOLD_COS_QMr BCM56800_A0_READ_HOLD_COS_QMr
#define WRITE_HOLD_COS_QMr BCM56800_A0_WRITE_HOLD_COS_QMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS_QMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS_QM_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS QM Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS_QM_Xr 0x0e180209

#define BCM56800_A0_HOLD_COS_QM_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_QM_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS_QM_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos_qm_x[1];
	uint32_t _hold_cos_qm_x;
} BCM56800_A0_HOLD_COS_QM_Xr_t;

#define BCM56800_A0_HOLD_COS_QM_Xr_CLR(r) (r).hold_cos_qm_x[0] = 0
#define BCM56800_A0_HOLD_COS_QM_Xr_SET(r,d) (r).hold_cos_qm_x[0] = d
#define BCM56800_A0_HOLD_COS_QM_Xr_GET(r) (r).hold_cos_qm_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS_QM_Xr_COUNTf_GET(r) (((r).hold_cos_qm_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS_QM_Xr_COUNTf_SET(r,f) (r).hold_cos_qm_x[0]=(((r).hold_cos_qm_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS_QM_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS_QM_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS_QM_Xr,(r._hold_cos_qm_x))
#define BCM56800_A0_WRITE_HOLD_COS_QM_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS_QM_Xr,&(r._hold_cos_qm_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_QM_Xr BCM56800_A0_HOLD_COS_QM_Xr
#define HOLD_COS_QM_Xr_SIZE BCM56800_A0_HOLD_COS_QM_Xr_SIZE
typedef BCM56800_A0_HOLD_COS_QM_Xr_t HOLD_COS_QM_Xr_t;
#define HOLD_COS_QM_Xr_CLR BCM56800_A0_HOLD_COS_QM_Xr_CLR
#define HOLD_COS_QM_Xr_SET BCM56800_A0_HOLD_COS_QM_Xr_SET
#define HOLD_COS_QM_Xr_GET BCM56800_A0_HOLD_COS_QM_Xr_GET
#define HOLD_COS_QM_Xr_COUNTf_GET BCM56800_A0_HOLD_COS_QM_Xr_COUNTf_GET
#define HOLD_COS_QM_Xr_COUNTf_SET BCM56800_A0_HOLD_COS_QM_Xr_COUNTf_SET
#define READ_HOLD_COS_QM_Xr BCM56800_A0_READ_HOLD_COS_QM_Xr
#define WRITE_HOLD_COS_QM_Xr BCM56800_A0_WRITE_HOLD_COS_QM_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS_QM_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS_QM_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS QM Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS_QM_Yr 0x0e180409

#define BCM56800_A0_HOLD_COS_QM_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_QM_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS_QM_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos_qm_y[1];
	uint32_t _hold_cos_qm_y;
} BCM56800_A0_HOLD_COS_QM_Yr_t;

#define BCM56800_A0_HOLD_COS_QM_Yr_CLR(r) (r).hold_cos_qm_y[0] = 0
#define BCM56800_A0_HOLD_COS_QM_Yr_SET(r,d) (r).hold_cos_qm_y[0] = d
#define BCM56800_A0_HOLD_COS_QM_Yr_GET(r) (r).hold_cos_qm_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS_QM_Yr_COUNTf_GET(r) (((r).hold_cos_qm_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS_QM_Yr_COUNTf_SET(r,f) (r).hold_cos_qm_y[0]=(((r).hold_cos_qm_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS_QM_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS_QM_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS_QM_Yr,(r._hold_cos_qm_y))
#define BCM56800_A0_WRITE_HOLD_COS_QM_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS_QM_Yr,&(r._hold_cos_qm_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_QM_Yr BCM56800_A0_HOLD_COS_QM_Yr
#define HOLD_COS_QM_Yr_SIZE BCM56800_A0_HOLD_COS_QM_Yr_SIZE
typedef BCM56800_A0_HOLD_COS_QM_Yr_t HOLD_COS_QM_Yr_t;
#define HOLD_COS_QM_Yr_CLR BCM56800_A0_HOLD_COS_QM_Yr_CLR
#define HOLD_COS_QM_Yr_SET BCM56800_A0_HOLD_COS_QM_Yr_SET
#define HOLD_COS_QM_Yr_GET BCM56800_A0_HOLD_COS_QM_Yr_GET
#define HOLD_COS_QM_Yr_COUNTf_GET BCM56800_A0_HOLD_COS_QM_Yr_COUNTf_GET
#define HOLD_COS_QM_Yr_COUNTf_SET BCM56800_A0_HOLD_COS_QM_Yr_COUNTf_SET
#define READ_HOLD_COS_QM_Yr BCM56800_A0_READ_HOLD_COS_QM_Yr
#define WRITE_HOLD_COS_QM_Yr BCM56800_A0_WRITE_HOLD_COS_QM_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS_QM_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS_SC
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS SC Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS_SCr 0x0e180c08

#define BCM56800_A0_HOLD_COS_SCr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_SC.
 *
 */
typedef union BCM56800_A0_HOLD_COS_SCr_s {
	uint32_t v[1];
	uint32_t hold_cos_sc[1];
	uint32_t _hold_cos_sc;
} BCM56800_A0_HOLD_COS_SCr_t;

#define BCM56800_A0_HOLD_COS_SCr_CLR(r) (r).hold_cos_sc[0] = 0
#define BCM56800_A0_HOLD_COS_SCr_SET(r,d) (r).hold_cos_sc[0] = d
#define BCM56800_A0_HOLD_COS_SCr_GET(r) (r).hold_cos_sc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS_SCr_COUNTf_GET(r) (((r).hold_cos_sc[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS_SCr_COUNTf_SET(r,f) (r).hold_cos_sc[0]=(((r).hold_cos_sc[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS_SC.
 *
 */
#define BCM56800_A0_READ_HOLD_COS_SCr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS_SCr,(r._hold_cos_sc))
#define BCM56800_A0_WRITE_HOLD_COS_SCr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS_SCr,&(r._hold_cos_sc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_SCr BCM56800_A0_HOLD_COS_SCr
#define HOLD_COS_SCr_SIZE BCM56800_A0_HOLD_COS_SCr_SIZE
typedef BCM56800_A0_HOLD_COS_SCr_t HOLD_COS_SCr_t;
#define HOLD_COS_SCr_CLR BCM56800_A0_HOLD_COS_SCr_CLR
#define HOLD_COS_SCr_SET BCM56800_A0_HOLD_COS_SCr_SET
#define HOLD_COS_SCr_GET BCM56800_A0_HOLD_COS_SCr_GET
#define HOLD_COS_SCr_COUNTf_GET BCM56800_A0_HOLD_COS_SCr_COUNTf_GET
#define HOLD_COS_SCr_COUNTf_SET BCM56800_A0_HOLD_COS_SCr_COUNTf_SET
#define READ_HOLD_COS_SCr BCM56800_A0_READ_HOLD_COS_SCr
#define WRITE_HOLD_COS_SCr BCM56800_A0_WRITE_HOLD_COS_SCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS_SCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS_SC_X
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS SC Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS_SC_Xr 0x0e180208

#define BCM56800_A0_HOLD_COS_SC_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_SC_X.
 *
 */
typedef union BCM56800_A0_HOLD_COS_SC_Xr_s {
	uint32_t v[1];
	uint32_t hold_cos_sc_x[1];
	uint32_t _hold_cos_sc_x;
} BCM56800_A0_HOLD_COS_SC_Xr_t;

#define BCM56800_A0_HOLD_COS_SC_Xr_CLR(r) (r).hold_cos_sc_x[0] = 0
#define BCM56800_A0_HOLD_COS_SC_Xr_SET(r,d) (r).hold_cos_sc_x[0] = d
#define BCM56800_A0_HOLD_COS_SC_Xr_GET(r) (r).hold_cos_sc_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS_SC_Xr_COUNTf_GET(r) (((r).hold_cos_sc_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS_SC_Xr_COUNTf_SET(r,f) (r).hold_cos_sc_x[0]=(((r).hold_cos_sc_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS_SC_X.
 *
 */
#define BCM56800_A0_READ_HOLD_COS_SC_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS_SC_Xr,(r._hold_cos_sc_x))
#define BCM56800_A0_WRITE_HOLD_COS_SC_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS_SC_Xr,&(r._hold_cos_sc_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_SC_Xr BCM56800_A0_HOLD_COS_SC_Xr
#define HOLD_COS_SC_Xr_SIZE BCM56800_A0_HOLD_COS_SC_Xr_SIZE
typedef BCM56800_A0_HOLD_COS_SC_Xr_t HOLD_COS_SC_Xr_t;
#define HOLD_COS_SC_Xr_CLR BCM56800_A0_HOLD_COS_SC_Xr_CLR
#define HOLD_COS_SC_Xr_SET BCM56800_A0_HOLD_COS_SC_Xr_SET
#define HOLD_COS_SC_Xr_GET BCM56800_A0_HOLD_COS_SC_Xr_GET
#define HOLD_COS_SC_Xr_COUNTf_GET BCM56800_A0_HOLD_COS_SC_Xr_COUNTf_GET
#define HOLD_COS_SC_Xr_COUNTf_SET BCM56800_A0_HOLD_COS_SC_Xr_COUNTf_SET
#define READ_HOLD_COS_SC_Xr BCM56800_A0_READ_HOLD_COS_SC_Xr
#define WRITE_HOLD_COS_SC_Xr BCM56800_A0_WRITE_HOLD_COS_SC_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS_SC_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_COS_SC_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress HOL Drop COS SC Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port COS
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_COS_SC_Yr 0x0e180408

#define BCM56800_A0_HOLD_COS_SC_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_COS_SC_Y.
 *
 */
typedef union BCM56800_A0_HOLD_COS_SC_Yr_s {
	uint32_t v[1];
	uint32_t hold_cos_sc_y[1];
	uint32_t _hold_cos_sc_y;
} BCM56800_A0_HOLD_COS_SC_Yr_t;

#define BCM56800_A0_HOLD_COS_SC_Yr_CLR(r) (r).hold_cos_sc_y[0] = 0
#define BCM56800_A0_HOLD_COS_SC_Yr_SET(r,d) (r).hold_cos_sc_y[0] = d
#define BCM56800_A0_HOLD_COS_SC_Yr_GET(r) (r).hold_cos_sc_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_COS_SC_Yr_COUNTf_GET(r) (((r).hold_cos_sc_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_COS_SC_Yr_COUNTf_SET(r,f) (r).hold_cos_sc_y[0]=(((r).hold_cos_sc_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_COS_SC_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_COS_SC_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOLD_COS_SC_Yr,(r._hold_cos_sc_y))
#define BCM56800_A0_WRITE_HOLD_COS_SC_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOLD_COS_SC_Yr,&(r._hold_cos_sc_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_COS_SC_Yr BCM56800_A0_HOLD_COS_SC_Yr
#define HOLD_COS_SC_Yr_SIZE BCM56800_A0_HOLD_COS_SC_Yr_SIZE
typedef BCM56800_A0_HOLD_COS_SC_Yr_t HOLD_COS_SC_Yr_t;
#define HOLD_COS_SC_Yr_CLR BCM56800_A0_HOLD_COS_SC_Yr_CLR
#define HOLD_COS_SC_Yr_SET BCM56800_A0_HOLD_COS_SC_Yr_SET
#define HOLD_COS_SC_Yr_GET BCM56800_A0_HOLD_COS_SC_Yr_GET
#define HOLD_COS_SC_Yr_COUNTf_GET BCM56800_A0_HOLD_COS_SC_Yr_COUNTf_GET
#define HOLD_COS_SC_Yr_COUNTf_SET BCM56800_A0_HOLD_COS_SC_Yr_COUNTf_SET
#define READ_HOLD_COS_SC_Yr BCM56800_A0_READ_HOLD_COS_SC_Yr
#define WRITE_HOLD_COS_SC_Yr BCM56800_A0_WRITE_HOLD_COS_SC_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_COS_SC_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_X
 * BLOCKS:   IPIPE
 * DESC:     Egress per port HOL Drop Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_Xr 0x0e10021c

#define BCM56800_A0_HOLD_Xr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_X.
 *
 */
typedef union BCM56800_A0_HOLD_Xr_s {
	uint32_t v[1];
	uint32_t hold_x[1];
	uint32_t _hold_x;
} BCM56800_A0_HOLD_Xr_t;

#define BCM56800_A0_HOLD_Xr_CLR(r) (r).hold_x[0] = 0
#define BCM56800_A0_HOLD_Xr_SET(r,d) (r).hold_x[0] = d
#define BCM56800_A0_HOLD_Xr_GET(r) (r).hold_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_Xr_COUNTf_GET(r) (((r).hold_x[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_Xr_COUNTf_SET(r,f) (r).hold_x[0]=(((r).hold_x[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_X.
 *
 */
#define BCM56800_A0_READ_HOLD_Xr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_HOLD_Xr,(r._hold_x))
#define BCM56800_A0_WRITE_HOLD_Xr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_HOLD_Xr,&(r._hold_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_Xr BCM56800_A0_HOLD_Xr
#define HOLD_Xr_SIZE BCM56800_A0_HOLD_Xr_SIZE
typedef BCM56800_A0_HOLD_Xr_t HOLD_Xr_t;
#define HOLD_Xr_CLR BCM56800_A0_HOLD_Xr_CLR
#define HOLD_Xr_SET BCM56800_A0_HOLD_Xr_SET
#define HOLD_Xr_GET BCM56800_A0_HOLD_Xr_GET
#define HOLD_Xr_COUNTf_GET BCM56800_A0_HOLD_Xr_COUNTf_GET
#define HOLD_Xr_COUNTf_SET BCM56800_A0_HOLD_Xr_COUNTf_SET
#define READ_HOLD_Xr BCM56800_A0_READ_HOLD_Xr
#define WRITE_HOLD_Xr BCM56800_A0_WRITE_HOLD_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOLD_Y
 * BLOCKS:   IPIPE
 * DESC:     Egress per port HOL Drop Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each Packet drop due to Head Of Line blocking per egress port
 *
 ******************************************************************************/
#define BCM56800_A0_HOLD_Yr 0x0e10041c

#define BCM56800_A0_HOLD_Yr_SIZE 4

/*
 * This structure should be used to declare and program HOLD_Y.
 *
 */
typedef union BCM56800_A0_HOLD_Yr_s {
	uint32_t v[1];
	uint32_t hold_y[1];
	uint32_t _hold_y;
} BCM56800_A0_HOLD_Yr_t;

#define BCM56800_A0_HOLD_Yr_CLR(r) (r).hold_y[0] = 0
#define BCM56800_A0_HOLD_Yr_SET(r,d) (r).hold_y[0] = d
#define BCM56800_A0_HOLD_Yr_GET(r) (r).hold_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOLD_Yr_COUNTf_GET(r) (((r).hold_y[0]) & 0x3ffffff)
#define BCM56800_A0_HOLD_Yr_COUNTf_SET(r,f) (r).hold_y[0]=(((r).hold_y[0] & ~((uint32_t)0x3ffffff)) | (((uint32_t)f) & 0x3ffffff))

/*
 * These macros can be used to access HOLD_Y.
 *
 */
#define BCM56800_A0_READ_HOLD_Yr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_HOLD_Yr,(r._hold_y))
#define BCM56800_A0_WRITE_HOLD_Yr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_HOLD_Yr,&(r._hold_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOLD_Yr BCM56800_A0_HOLD_Yr
#define HOLD_Yr_SIZE BCM56800_A0_HOLD_Yr_SIZE
typedef BCM56800_A0_HOLD_Yr_t HOLD_Yr_t;
#define HOLD_Yr_CLR BCM56800_A0_HOLD_Yr_CLR
#define HOLD_Yr_SET BCM56800_A0_HOLD_Yr_SET
#define HOLD_Yr_GET BCM56800_A0_HOLD_Yr_GET
#define HOLD_Yr_COUNTf_GET BCM56800_A0_HOLD_Yr_COUNTf_GET
#define HOLD_Yr_COUNTf_SET BCM56800_A0_HOLD_Yr_COUNTf_SET
#define READ_HOLD_Yr BCM56800_A0_READ_HOLD_Yr
#define WRITE_HOLD_Yr BCM56800_A0_WRITE_HOLD_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOLD_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  HOL_STAT_BMAP
 * BLOCKS:   IPIPE
 * DESC:     HOL Status Register
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      HOL status port bitmap 
 *
 ******************************************************************************/
#define BCM56800_A0_HOL_STAT_BMAPr 0x0e180614

#define BCM56800_A0_HOL_STAT_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program HOL_STAT_BMAP.
 *
 */
typedef union BCM56800_A0_HOL_STAT_BMAPr_s {
	uint32_t v[1];
	uint32_t hol_stat_bmap[1];
	uint32_t _hol_stat_bmap;
} BCM56800_A0_HOL_STAT_BMAPr_t;

#define BCM56800_A0_HOL_STAT_BMAPr_CLR(r) (r).hol_stat_bmap[0] = 0
#define BCM56800_A0_HOL_STAT_BMAPr_SET(r,d) (r).hol_stat_bmap[0] = d
#define BCM56800_A0_HOL_STAT_BMAPr_GET(r) (r).hol_stat_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_HOL_STAT_BMAPr_PORT_BITMAPf_GET(r) (((r).hol_stat_bmap[0]) & 0x1fffff)
#define BCM56800_A0_HOL_STAT_BMAPr_PORT_BITMAPf_SET(r,f) (r).hol_stat_bmap[0]=(((r).hol_stat_bmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access HOL_STAT_BMAP.
 *
 */
#define BCM56800_A0_READ_HOL_STAT_BMAPr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_HOL_STAT_BMAPr+(i),(r._hol_stat_bmap))
#define BCM56800_A0_WRITE_HOL_STAT_BMAPr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_HOL_STAT_BMAPr+(i),&(r._hol_stat_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HOL_STAT_BMAPr BCM56800_A0_HOL_STAT_BMAPr
#define HOL_STAT_BMAPr_SIZE BCM56800_A0_HOL_STAT_BMAPr_SIZE
typedef BCM56800_A0_HOL_STAT_BMAPr_t HOL_STAT_BMAPr_t;
#define HOL_STAT_BMAPr_CLR BCM56800_A0_HOL_STAT_BMAPr_CLR
#define HOL_STAT_BMAPr_SET BCM56800_A0_HOL_STAT_BMAPr_SET
#define HOL_STAT_BMAPr_GET BCM56800_A0_HOL_STAT_BMAPr_GET
#define HOL_STAT_BMAPr_PORT_BITMAPf_GET BCM56800_A0_HOL_STAT_BMAPr_PORT_BITMAPf_GET
#define HOL_STAT_BMAPr_PORT_BITMAPf_SET BCM56800_A0_HOL_STAT_BMAPr_PORT_BITMAPf_SET
#define READ_HOL_STAT_BMAPr BCM56800_A0_READ_HOL_STAT_BMAPr
#define WRITE_HOL_STAT_BMAPr BCM56800_A0_WRITE_HOL_STAT_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_HOL_STAT_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IBCAST
 * BLOCKS:   IPIPE
 * DESC:     Receive HiGig Packet with Broadcast Opcode Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_IBCASTr 0x0e100013

#define BCM56800_A0_IBCASTr_SIZE 4

/*
 * This structure should be used to declare and program IBCAST.
 *
 */
typedef union BCM56800_A0_IBCASTr_s {
	uint32_t v[1];
	uint32_t ibcast[1];
	uint32_t _ibcast;
} BCM56800_A0_IBCASTr_t;

#define BCM56800_A0_IBCASTr_CLR(r) (r).ibcast[0] = 0
#define BCM56800_A0_IBCASTr_SET(r,d) (r).ibcast[0] = d
#define BCM56800_A0_IBCASTr_GET(r) (r).ibcast[0]


/*
 * These macros can be used to access IBCAST.
 *
 */
#define BCM56800_A0_READ_IBCASTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IBCASTr,(r._ibcast))
#define BCM56800_A0_WRITE_IBCASTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IBCASTr,&(r._ibcast))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBCASTr BCM56800_A0_IBCASTr
#define IBCASTr_SIZE BCM56800_A0_IBCASTr_SIZE
typedef BCM56800_A0_IBCASTr_t IBCASTr_t;
#define IBCASTr_CLR BCM56800_A0_IBCASTr_CLR
#define IBCASTr_SET BCM56800_A0_IBCASTr_SET
#define IBCASTr_GET BCM56800_A0_IBCASTr_GET
#define READ_IBCASTr BCM56800_A0_READ_IBCASTr
#define WRITE_IBCASTr BCM56800_A0_WRITE_IBCASTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IBCASTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IBCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Broadcast Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56800_A0_IBCAST_BLOCK_MASKr 0x0e100052

#define BCM56800_A0_IBCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IBCAST_BLOCK_MASK.
 *
 */
typedef union BCM56800_A0_IBCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t ibcast_block_mask[1];
	uint32_t _ibcast_block_mask;
} BCM56800_A0_IBCAST_BLOCK_MASKr_t;

#define BCM56800_A0_IBCAST_BLOCK_MASKr_CLR(r) (r).ibcast_block_mask[0] = 0
#define BCM56800_A0_IBCAST_BLOCK_MASKr_SET(r,d) (r).ibcast_block_mask[0] = d
#define BCM56800_A0_IBCAST_BLOCK_MASKr_GET(r) (r).ibcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).ibcast_block_mask[0]) & 0x1fffff)
#define BCM56800_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).ibcast_block_mask[0]=(((r).ibcast_block_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IBCAST_BLOCK_MASK.
 *
 */
#define BCM56800_A0_READ_IBCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IBCAST_BLOCK_MASKr,(r._ibcast_block_mask))
#define BCM56800_A0_WRITE_IBCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IBCAST_BLOCK_MASKr,&(r._ibcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IBCAST_BLOCK_MASKr BCM56800_A0_IBCAST_BLOCK_MASKr
#define IBCAST_BLOCK_MASKr_SIZE BCM56800_A0_IBCAST_BLOCK_MASKr_SIZE
typedef BCM56800_A0_IBCAST_BLOCK_MASKr_t IBCAST_BLOCK_MASKr_t;
#define IBCAST_BLOCK_MASKr_CLR BCM56800_A0_IBCAST_BLOCK_MASKr_CLR
#define IBCAST_BLOCK_MASKr_SET BCM56800_A0_IBCAST_BLOCK_MASKr_SET
#define IBCAST_BLOCK_MASKr_GET BCM56800_A0_IBCAST_BLOCK_MASKr_GET
#define IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56800_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56800_A0_IBCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IBCAST_BLOCK_MASKr BCM56800_A0_READ_IBCAST_BLOCK_MASKr
#define WRITE_IBCAST_BLOCK_MASKr BCM56800_A0_WRITE_IBCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IBCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ICONTROL_OPCODE_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Higig control packet's switching bitmap register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           HiGig CONTROL opcode redirection
 *
 ******************************************************************************/
#define BCM56800_A0_ICONTROL_OPCODE_BITMAPr 0x0b100008

#define BCM56800_A0_ICONTROL_OPCODE_BITMAPr_SIZE 4

/*
 * This structure should be used to declare and program ICONTROL_OPCODE_BITMAP.
 *
 */
typedef union BCM56800_A0_ICONTROL_OPCODE_BITMAPr_s {
	uint32_t v[1];
	uint32_t icontrol_opcode_bitmap[1];
	uint32_t _icontrol_opcode_bitmap;
} BCM56800_A0_ICONTROL_OPCODE_BITMAPr_t;

#define BCM56800_A0_ICONTROL_OPCODE_BITMAPr_CLR(r) (r).icontrol_opcode_bitmap[0] = 0
#define BCM56800_A0_ICONTROL_OPCODE_BITMAPr_SET(r,d) (r).icontrol_opcode_bitmap[0] = d
#define BCM56800_A0_ICONTROL_OPCODE_BITMAPr_GET(r) (r).icontrol_opcode_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_GET(r) (((r).icontrol_opcode_bitmap[0]) & 0x1fffff)
#define BCM56800_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_SET(r,f) (r).icontrol_opcode_bitmap[0]=(((r).icontrol_opcode_bitmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access ICONTROL_OPCODE_BITMAP.
 *
 */
#define BCM56800_A0_READ_ICONTROL_OPCODE_BITMAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ICONTROL_OPCODE_BITMAPr,(r._icontrol_opcode_bitmap))
#define BCM56800_A0_WRITE_ICONTROL_OPCODE_BITMAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ICONTROL_OPCODE_BITMAPr,&(r._icontrol_opcode_bitmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICONTROL_OPCODE_BITMAPr BCM56800_A0_ICONTROL_OPCODE_BITMAPr
#define ICONTROL_OPCODE_BITMAPr_SIZE BCM56800_A0_ICONTROL_OPCODE_BITMAPr_SIZE
typedef BCM56800_A0_ICONTROL_OPCODE_BITMAPr_t ICONTROL_OPCODE_BITMAPr_t;
#define ICONTROL_OPCODE_BITMAPr_CLR BCM56800_A0_ICONTROL_OPCODE_BITMAPr_CLR
#define ICONTROL_OPCODE_BITMAPr_SET BCM56800_A0_ICONTROL_OPCODE_BITMAPr_SET
#define ICONTROL_OPCODE_BITMAPr_GET BCM56800_A0_ICONTROL_OPCODE_BITMAPr_GET
#define ICONTROL_OPCODE_BITMAPr_BITMAPf_GET BCM56800_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_GET
#define ICONTROL_OPCODE_BITMAPr_BITMAPf_SET BCM56800_A0_ICONTROL_OPCODE_BITMAPr_BITMAPf_SET
#define READ_ICONTROL_OPCODE_BITMAPr BCM56800_A0_READ_ICONTROL_OPCODE_BITMAPr
#define WRITE_ICONTROL_OPCODE_BITMAPr BCM56800_A0_WRITE_ICONTROL_OPCODE_BITMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ICONTROL_OPCODE_BITMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ICOS_SEL
 * BLOCKS:   IPIPE
 * DESC:     COS Queue Mapping Register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     COS0             COS-0 Value
 *     COS1             COS-1 Value
 *     COS2             COS-2 Value
 *     COS3             COS-3 Value
 *     COS4             COS-4 Value
 *     COS5             COS-5 Value
 *     COS6             COS-6 Value
 *     COS7             COS-7 Value
 *
 ******************************************************************************/
#define BCM56800_A0_ICOS_SELr 0x0e100055

#define BCM56800_A0_ICOS_SELr_SIZE 4

/*
 * This structure should be used to declare and program ICOS_SEL.
 *
 */
typedef union BCM56800_A0_ICOS_SELr_s {
	uint32_t v[1];
	uint32_t icos_sel[1];
	uint32_t _icos_sel;
} BCM56800_A0_ICOS_SELr_t;

#define BCM56800_A0_ICOS_SELr_CLR(r) (r).icos_sel[0] = 0
#define BCM56800_A0_ICOS_SELr_SET(r,d) (r).icos_sel[0] = d
#define BCM56800_A0_ICOS_SELr_GET(r) (r).icos_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ICOS_SELr_COS0f_GET(r) (((r).icos_sel[0]) & 0xf)
#define BCM56800_A0_ICOS_SELr_COS0f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_ICOS_SELr_COS1f_GET(r) ((((r).icos_sel[0]) >> 4) & 0xf)
#define BCM56800_A0_ICOS_SELr_COS1f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_ICOS_SELr_COS2f_GET(r) ((((r).icos_sel[0]) >> 8) & 0xf)
#define BCM56800_A0_ICOS_SELr_COS2f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_ICOS_SELr_COS3f_GET(r) ((((r).icos_sel[0]) >> 12) & 0xf)
#define BCM56800_A0_ICOS_SELr_COS3f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_ICOS_SELr_COS4f_GET(r) ((((r).icos_sel[0]) >> 16) & 0xf)
#define BCM56800_A0_ICOS_SELr_COS4f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_ICOS_SELr_COS5f_GET(r) ((((r).icos_sel[0]) >> 20) & 0xf)
#define BCM56800_A0_ICOS_SELr_COS5f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_ICOS_SELr_COS6f_GET(r) ((((r).icos_sel[0]) >> 24) & 0xf)
#define BCM56800_A0_ICOS_SELr_COS6f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_ICOS_SELr_COS7f_GET(r) ((((r).icos_sel[0]) >> 28) & 0xf)
#define BCM56800_A0_ICOS_SELr_COS7f_SET(r,f) (r).icos_sel[0]=(((r).icos_sel[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ICOS_SEL.
 *
 */
#define BCM56800_A0_READ_ICOS_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ICOS_SELr,(r._icos_sel))
#define BCM56800_A0_WRITE_ICOS_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ICOS_SELr,&(r._icos_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICOS_SELr BCM56800_A0_ICOS_SELr
#define ICOS_SELr_SIZE BCM56800_A0_ICOS_SELr_SIZE
typedef BCM56800_A0_ICOS_SELr_t ICOS_SELr_t;
#define ICOS_SELr_CLR BCM56800_A0_ICOS_SELr_CLR
#define ICOS_SELr_SET BCM56800_A0_ICOS_SELr_SET
#define ICOS_SELr_GET BCM56800_A0_ICOS_SELr_GET
#define ICOS_SELr_COS0f_GET BCM56800_A0_ICOS_SELr_COS0f_GET
#define ICOS_SELr_COS0f_SET BCM56800_A0_ICOS_SELr_COS0f_SET
#define ICOS_SELr_COS1f_GET BCM56800_A0_ICOS_SELr_COS1f_GET
#define ICOS_SELr_COS1f_SET BCM56800_A0_ICOS_SELr_COS1f_SET
#define ICOS_SELr_COS2f_GET BCM56800_A0_ICOS_SELr_COS2f_GET
#define ICOS_SELr_COS2f_SET BCM56800_A0_ICOS_SELr_COS2f_SET
#define ICOS_SELr_COS3f_GET BCM56800_A0_ICOS_SELr_COS3f_GET
#define ICOS_SELr_COS3f_SET BCM56800_A0_ICOS_SELr_COS3f_SET
#define ICOS_SELr_COS4f_GET BCM56800_A0_ICOS_SELr_COS4f_GET
#define ICOS_SELr_COS4f_SET BCM56800_A0_ICOS_SELr_COS4f_SET
#define ICOS_SELr_COS5f_GET BCM56800_A0_ICOS_SELr_COS5f_GET
#define ICOS_SELr_COS5f_SET BCM56800_A0_ICOS_SELr_COS5f_SET
#define ICOS_SELr_COS6f_GET BCM56800_A0_ICOS_SELr_COS6f_GET
#define ICOS_SELr_COS6f_SET BCM56800_A0_ICOS_SELr_COS6f_SET
#define ICOS_SELr_COS7f_GET BCM56800_A0_ICOS_SELr_COS7f_GET
#define ICOS_SELr_COS7f_SET BCM56800_A0_ICOS_SELr_COS7f_SET
#define READ_ICOS_SELr BCM56800_A0_READ_ICOS_SELr
#define WRITE_ICOS_SELr BCM56800_A0_WRITE_ICOS_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ICOS_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ICOS_SEL_2
 * BLOCKS:   IPIPE
 * DESC:     COS Queue Mapping Register 2, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     COS8             COS-8 Value
 *     COS9             COS-9 Value
 *     COS10            COS-10 Value
 *     COS11            COS-11 Value
 *     COS12            COS-12 Value
 *     COS13            COS-13 Value
 *     COS14            COS-14 Value
 *     COS15            COS-15 Value
 *
 ******************************************************************************/
#define BCM56800_A0_ICOS_SEL_2r 0x0e100056

#define BCM56800_A0_ICOS_SEL_2r_SIZE 4

/*
 * This structure should be used to declare and program ICOS_SEL_2.
 *
 */
typedef union BCM56800_A0_ICOS_SEL_2r_s {
	uint32_t v[1];
	uint32_t icos_sel_2[1];
	uint32_t _icos_sel_2;
} BCM56800_A0_ICOS_SEL_2r_t;

#define BCM56800_A0_ICOS_SEL_2r_CLR(r) (r).icos_sel_2[0] = 0
#define BCM56800_A0_ICOS_SEL_2r_SET(r,d) (r).icos_sel_2[0] = d
#define BCM56800_A0_ICOS_SEL_2r_GET(r) (r).icos_sel_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ICOS_SEL_2r_COS8f_GET(r) (((r).icos_sel_2[0]) & 0xf)
#define BCM56800_A0_ICOS_SEL_2r_COS8f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_ICOS_SEL_2r_COS9f_GET(r) ((((r).icos_sel_2[0]) >> 4) & 0xf)
#define BCM56800_A0_ICOS_SEL_2r_COS9f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_ICOS_SEL_2r_COS10f_GET(r) ((((r).icos_sel_2[0]) >> 8) & 0xf)
#define BCM56800_A0_ICOS_SEL_2r_COS10f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_ICOS_SEL_2r_COS11f_GET(r) ((((r).icos_sel_2[0]) >> 12) & 0xf)
#define BCM56800_A0_ICOS_SEL_2r_COS11f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_ICOS_SEL_2r_COS12f_GET(r) ((((r).icos_sel_2[0]) >> 16) & 0xf)
#define BCM56800_A0_ICOS_SEL_2r_COS12f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_ICOS_SEL_2r_COS13f_GET(r) ((((r).icos_sel_2[0]) >> 20) & 0xf)
#define BCM56800_A0_ICOS_SEL_2r_COS13f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_ICOS_SEL_2r_COS14f_GET(r) ((((r).icos_sel_2[0]) >> 24) & 0xf)
#define BCM56800_A0_ICOS_SEL_2r_COS14f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_ICOS_SEL_2r_COS15f_GET(r) ((((r).icos_sel_2[0]) >> 28) & 0xf)
#define BCM56800_A0_ICOS_SEL_2r_COS15f_SET(r,f) (r).icos_sel_2[0]=(((r).icos_sel_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ICOS_SEL_2.
 *
 */
#define BCM56800_A0_READ_ICOS_SEL_2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ICOS_SEL_2r,(r._icos_sel_2))
#define BCM56800_A0_WRITE_ICOS_SEL_2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ICOS_SEL_2r,&(r._icos_sel_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICOS_SEL_2r BCM56800_A0_ICOS_SEL_2r
#define ICOS_SEL_2r_SIZE BCM56800_A0_ICOS_SEL_2r_SIZE
typedef BCM56800_A0_ICOS_SEL_2r_t ICOS_SEL_2r_t;
#define ICOS_SEL_2r_CLR BCM56800_A0_ICOS_SEL_2r_CLR
#define ICOS_SEL_2r_SET BCM56800_A0_ICOS_SEL_2r_SET
#define ICOS_SEL_2r_GET BCM56800_A0_ICOS_SEL_2r_GET
#define ICOS_SEL_2r_COS8f_GET BCM56800_A0_ICOS_SEL_2r_COS8f_GET
#define ICOS_SEL_2r_COS8f_SET BCM56800_A0_ICOS_SEL_2r_COS8f_SET
#define ICOS_SEL_2r_COS9f_GET BCM56800_A0_ICOS_SEL_2r_COS9f_GET
#define ICOS_SEL_2r_COS9f_SET BCM56800_A0_ICOS_SEL_2r_COS9f_SET
#define ICOS_SEL_2r_COS10f_GET BCM56800_A0_ICOS_SEL_2r_COS10f_GET
#define ICOS_SEL_2r_COS10f_SET BCM56800_A0_ICOS_SEL_2r_COS10f_SET
#define ICOS_SEL_2r_COS11f_GET BCM56800_A0_ICOS_SEL_2r_COS11f_GET
#define ICOS_SEL_2r_COS11f_SET BCM56800_A0_ICOS_SEL_2r_COS11f_SET
#define ICOS_SEL_2r_COS12f_GET BCM56800_A0_ICOS_SEL_2r_COS12f_GET
#define ICOS_SEL_2r_COS12f_SET BCM56800_A0_ICOS_SEL_2r_COS12f_SET
#define ICOS_SEL_2r_COS13f_GET BCM56800_A0_ICOS_SEL_2r_COS13f_GET
#define ICOS_SEL_2r_COS13f_SET BCM56800_A0_ICOS_SEL_2r_COS13f_SET
#define ICOS_SEL_2r_COS14f_GET BCM56800_A0_ICOS_SEL_2r_COS14f_GET
#define ICOS_SEL_2r_COS14f_SET BCM56800_A0_ICOS_SEL_2r_COS14f_SET
#define ICOS_SEL_2r_COS15f_GET BCM56800_A0_ICOS_SEL_2r_COS15f_GET
#define ICOS_SEL_2r_COS15f_SET BCM56800_A0_ICOS_SEL_2r_COS15f_SET
#define READ_ICOS_SEL_2r BCM56800_A0_READ_ICOS_SEL_2r
#define WRITE_ICOS_SEL_2r BCM56800_A0_WRITE_ICOS_SEL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ICOS_SEL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ICTRL
 * BLOCKS:   IPIPE
 * DESC:     Receive HiGig Packet with Control Opcode Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_ICTRLr 0x0e100012

#define BCM56800_A0_ICTRLr_SIZE 4

/*
 * This structure should be used to declare and program ICTRL.
 *
 */
typedef union BCM56800_A0_ICTRLr_s {
	uint32_t v[1];
	uint32_t ictrl[1];
	uint32_t _ictrl;
} BCM56800_A0_ICTRLr_t;

#define BCM56800_A0_ICTRLr_CLR(r) (r).ictrl[0] = 0
#define BCM56800_A0_ICTRLr_SET(r,d) (r).ictrl[0] = d
#define BCM56800_A0_ICTRLr_GET(r) (r).ictrl[0]


/*
 * These macros can be used to access ICTRL.
 *
 */
#define BCM56800_A0_READ_ICTRLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ICTRLr,(r._ictrl))
#define BCM56800_A0_WRITE_ICTRLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ICTRLr,&(r._ictrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ICTRLr BCM56800_A0_ICTRLr
#define ICTRLr_SIZE BCM56800_A0_ICTRLr_SIZE
typedef BCM56800_A0_ICTRLr_t ICTRLr_t;
#define ICTRLr_CLR BCM56800_A0_ICTRLr_CLR
#define ICTRLr_SET BCM56800_A0_ICTRLr_SET
#define ICTRLr_GET BCM56800_A0_ICTRLr_GET
#define READ_ICTRLr BCM56800_A0_READ_ICTRLr
#define WRITE_ICTRLr BCM56800_A0_WRITE_ICTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ICTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IE2E_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     End-to-End Control Register
 * SIZE:     32
 * FIELDS:
 *     HOL_TOCPU        End-to-End HOL messages are sent to the CPU
 *     IBP_TOCPU        End-to-End IBP messages are sent to the CPU
 *     HOL_ENABLE       End-to-End HOL messages are detected in Ingress Pipeline
 *     IBP_ENABLE       End-to-End IBP messages are detected in Ingress Pipeline
 *
 ******************************************************************************/
#define BCM56800_A0_IE2E_CONTROLr 0x01100005

#define BCM56800_A0_IE2E_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IE2E_CONTROL.
 *
 */
typedef union BCM56800_A0_IE2E_CONTROLr_s {
	uint32_t v[1];
	uint32_t ie2e_control[1];
	uint32_t _ie2e_control;
} BCM56800_A0_IE2E_CONTROLr_t;

#define BCM56800_A0_IE2E_CONTROLr_CLR(r) (r).ie2e_control[0] = 0
#define BCM56800_A0_IE2E_CONTROLr_SET(r,d) (r).ie2e_control[0] = d
#define BCM56800_A0_IE2E_CONTROLr_GET(r) (r).ie2e_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IE2E_CONTROLr_HOL_TOCPUf_GET(r) (((r).ie2e_control[0]) & 0x1)
#define BCM56800_A0_IE2E_CONTROLr_HOL_TOCPUf_SET(r,f) (r).ie2e_control[0]=(((r).ie2e_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_IE2E_CONTROLr_IBP_TOCPUf_GET(r) ((((r).ie2e_control[0]) >> 1) & 0x1)
#define BCM56800_A0_IE2E_CONTROLr_IBP_TOCPUf_SET(r,f) (r).ie2e_control[0]=(((r).ie2e_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_IE2E_CONTROLr_HOL_ENABLEf_GET(r) ((((r).ie2e_control[0]) >> 2) & 0x1)
#define BCM56800_A0_IE2E_CONTROLr_HOL_ENABLEf_SET(r,f) (r).ie2e_control[0]=(((r).ie2e_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_IE2E_CONTROLr_IBP_ENABLEf_GET(r) ((((r).ie2e_control[0]) >> 3) & 0x1)
#define BCM56800_A0_IE2E_CONTROLr_IBP_ENABLEf_SET(r,f) (r).ie2e_control[0]=(((r).ie2e_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access IE2E_CONTROL.
 *
 */
#define BCM56800_A0_READ_IE2E_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IE2E_CONTROLr,(r._ie2e_control))
#define BCM56800_A0_WRITE_IE2E_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IE2E_CONTROLr,&(r._ie2e_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IE2E_CONTROLr BCM56800_A0_IE2E_CONTROLr
#define IE2E_CONTROLr_SIZE BCM56800_A0_IE2E_CONTROLr_SIZE
typedef BCM56800_A0_IE2E_CONTROLr_t IE2E_CONTROLr_t;
#define IE2E_CONTROLr_CLR BCM56800_A0_IE2E_CONTROLr_CLR
#define IE2E_CONTROLr_SET BCM56800_A0_IE2E_CONTROLr_SET
#define IE2E_CONTROLr_GET BCM56800_A0_IE2E_CONTROLr_GET
#define IE2E_CONTROLr_HOL_TOCPUf_GET BCM56800_A0_IE2E_CONTROLr_HOL_TOCPUf_GET
#define IE2E_CONTROLr_HOL_TOCPUf_SET BCM56800_A0_IE2E_CONTROLr_HOL_TOCPUf_SET
#define IE2E_CONTROLr_IBP_TOCPUf_GET BCM56800_A0_IE2E_CONTROLr_IBP_TOCPUf_GET
#define IE2E_CONTROLr_IBP_TOCPUf_SET BCM56800_A0_IE2E_CONTROLr_IBP_TOCPUf_SET
#define IE2E_CONTROLr_HOL_ENABLEf_GET BCM56800_A0_IE2E_CONTROLr_HOL_ENABLEf_GET
#define IE2E_CONTROLr_HOL_ENABLEf_SET BCM56800_A0_IE2E_CONTROLr_HOL_ENABLEf_SET
#define IE2E_CONTROLr_IBP_ENABLEf_GET BCM56800_A0_IE2E_CONTROLr_IBP_ENABLEf_GET
#define IE2E_CONTROLr_IBP_ENABLEf_SET BCM56800_A0_IE2E_CONTROLr_IBP_ENABLEf_SET
#define READ_IE2E_CONTROLr BCM56800_A0_READ_IE2E_CONTROLr
#define WRITE_IE2E_CONTROLr BCM56800_A0_WRITE_IE2E_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IE2E_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IEGR_PORT
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for a Port. This is different for each GE, 10GE port. FeatureSpecific-Ethernet


 * SIZE:     32
 * FIELDS:
 *     PORT_TYPE        Specifies the type of the port. Bit[0] of PORT_TYPE field is HIGIG_BIT. If it is set, then the port is in Higig Mode.	0 = GE/10GE/CPU Port.	1 = HIGIG Port.Bit[1] of PORT_TYPE field is NNI_BIT. If it is set, then the port is NNI port, else UNI Port.	0 = UNI Port.	1 = NNI Port.
 *     EN_EFILTER       If this bit is set, the VLAN Membership check is done for the outgoing port.
 *     PRESERVE_CPU_TAG Preserve the tag of the packet destines to CPU.
 *     CFI              If CFI-CNG mapping is enabled for the chip, i.e. EGR_CONFIG.CFI_AS_CNG bit is set, then thisfield corresponds to the values of CNG coming from MMU. e.g. If MMU.CNG = 0, then Packet.CFI = CFI[0]     If MMU.CNG = 1, then Packet.CFI = CFI[1] and so on.
 *     EM_SRCMOD_CHANGE Set to change the src_modid for the egress mirrored pkts going out of the higig port.
 *     MY_MODID         Module ID of this chip.
 *     HIGIG2           Higig 2 thing.
 *     HIGIG_PACKET     This port is a higig port.
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port.
 *
 ******************************************************************************/
#define BCM56800_A0_IEGR_PORTr 0x01400603

#define BCM56800_A0_IEGR_PORTr_SIZE 4

/*
 * This structure should be used to declare and program IEGR_PORT.
 *
 */
typedef union BCM56800_A0_IEGR_PORTr_s {
	uint32_t v[1];
	uint32_t iegr_port[1];
	uint32_t _iegr_port;
} BCM56800_A0_IEGR_PORTr_t;

#define BCM56800_A0_IEGR_PORTr_CLR(r) (r).iegr_port[0] = 0
#define BCM56800_A0_IEGR_PORTr_SET(r,d) (r).iegr_port[0] = d
#define BCM56800_A0_IEGR_PORTr_GET(r) (r).iegr_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IEGR_PORTr_PORT_TYPEf_GET(r) (((r).iegr_port[0]) & 0x3)
#define BCM56800_A0_IEGR_PORTr_PORT_TYPEf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_IEGR_PORTr_EN_EFILTERf_GET(r) ((((r).iegr_port[0]) >> 2) & 0x1)
#define BCM56800_A0_IEGR_PORTr_EN_EFILTERf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_GET(r) ((((r).iegr_port[0]) >> 3) & 0x1)
#define BCM56800_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_IEGR_PORTr_CFIf_GET(r) ((((r).iegr_port[0]) >> 4) & 0xf)
#define BCM56800_A0_IEGR_PORTr_CFIf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_IEGR_PORTr_EM_SRCMOD_CHANGEf_GET(r) ((((r).iegr_port[0]) >> 8) & 0x1)
#define BCM56800_A0_IEGR_PORTr_EM_SRCMOD_CHANGEf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_IEGR_PORTr_MY_MODIDf_GET(r) ((((r).iegr_port[0]) >> 9) & 0x7f)
#define BCM56800_A0_IEGR_PORTr_MY_MODIDf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM56800_A0_IEGR_PORTr_HIGIG2f_GET(r) ((((r).iegr_port[0]) >> 16) & 0x1)
#define BCM56800_A0_IEGR_PORTr_HIGIG2f_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_IEGR_PORTr_HIGIG_PACKETf_GET(r) (((r).iegr_port[0]) & 0x1)
#define BCM56800_A0_IEGR_PORTr_HIGIG_PACKETf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_IEGR_PORTr_NNI_PORTf_GET(r) ((((r).iegr_port[0]) >> 1) & 0x1)
#define BCM56800_A0_IEGR_PORTr_NNI_PORTf_SET(r,f) (r).iegr_port[0]=(((r).iegr_port[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access IEGR_PORT.
 *
 */
#define BCM56800_A0_READ_IEGR_PORTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IEGR_PORTr,(r._iegr_port))
#define BCM56800_A0_WRITE_IEGR_PORTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IEGR_PORTr,&(r._iegr_port))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEGR_PORTr BCM56800_A0_IEGR_PORTr
#define IEGR_PORTr_SIZE BCM56800_A0_IEGR_PORTr_SIZE
typedef BCM56800_A0_IEGR_PORTr_t IEGR_PORTr_t;
#define IEGR_PORTr_CLR BCM56800_A0_IEGR_PORTr_CLR
#define IEGR_PORTr_SET BCM56800_A0_IEGR_PORTr_SET
#define IEGR_PORTr_GET BCM56800_A0_IEGR_PORTr_GET
#define IEGR_PORTr_PORT_TYPEf_GET BCM56800_A0_IEGR_PORTr_PORT_TYPEf_GET
#define IEGR_PORTr_PORT_TYPEf_SET BCM56800_A0_IEGR_PORTr_PORT_TYPEf_SET
#define IEGR_PORTr_EN_EFILTERf_GET BCM56800_A0_IEGR_PORTr_EN_EFILTERf_GET
#define IEGR_PORTr_EN_EFILTERf_SET BCM56800_A0_IEGR_PORTr_EN_EFILTERf_SET
#define IEGR_PORTr_PRESERVE_CPU_TAGf_GET BCM56800_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_GET
#define IEGR_PORTr_PRESERVE_CPU_TAGf_SET BCM56800_A0_IEGR_PORTr_PRESERVE_CPU_TAGf_SET
#define IEGR_PORTr_CFIf_GET BCM56800_A0_IEGR_PORTr_CFIf_GET
#define IEGR_PORTr_CFIf_SET BCM56800_A0_IEGR_PORTr_CFIf_SET
#define IEGR_PORTr_EM_SRCMOD_CHANGEf_GET BCM56800_A0_IEGR_PORTr_EM_SRCMOD_CHANGEf_GET
#define IEGR_PORTr_EM_SRCMOD_CHANGEf_SET BCM56800_A0_IEGR_PORTr_EM_SRCMOD_CHANGEf_SET
#define IEGR_PORTr_MY_MODIDf_GET BCM56800_A0_IEGR_PORTr_MY_MODIDf_GET
#define IEGR_PORTr_MY_MODIDf_SET BCM56800_A0_IEGR_PORTr_MY_MODIDf_SET
#define IEGR_PORTr_HIGIG2f_GET BCM56800_A0_IEGR_PORTr_HIGIG2f_GET
#define IEGR_PORTr_HIGIG2f_SET BCM56800_A0_IEGR_PORTr_HIGIG2f_SET
#define IEGR_PORTr_HIGIG_PACKETf_GET BCM56800_A0_IEGR_PORTr_HIGIG_PACKETf_GET
#define IEGR_PORTr_HIGIG_PACKETf_SET BCM56800_A0_IEGR_PORTr_HIGIG_PACKETf_SET
#define IEGR_PORTr_NNI_PORTf_GET BCM56800_A0_IEGR_PORTr_NNI_PORTf_GET
#define IEGR_PORTr_NNI_PORTf_SET BCM56800_A0_IEGR_PORTr_NNI_PORTf_SET
#define READ_IEGR_PORTr BCM56800_A0_READ_IEGR_PORTr
#define WRITE_IEGR_PORTr BCM56800_A0_WRITE_IEGR_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IEGR_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IEGR_PORT_L3UC_MODS
 * BLOCKS:   EPIPE
 * DESC:     Configuration Register for IPMC related modifications. FeatureSpecific-Ethernet


 * SIZE:     32
 * FIELDS:
 *     L3_UC_SA_DISABLE Disable the SA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_DA_DISABLE Disable the DA replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_TTL_DISABLE Disable the TTL decrement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *     L3_UC_VLAN_DISABLE Disable the outer VID replacement for L3UC packets coming from a particular port. This register is indexed in EP based on the src_port_num.
 *
 ******************************************************************************/
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr 0x01400608

#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_SIZE 4

/*
 * This structure should be used to declare and program IEGR_PORT_L3UC_MODS.
 *
 */
typedef union BCM56800_A0_IEGR_PORT_L3UC_MODSr_s {
	uint32_t v[1];
	uint32_t iegr_port_l3uc_mods[1];
	uint32_t _iegr_port_l3uc_mods;
} BCM56800_A0_IEGR_PORT_L3UC_MODSr_t;

#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_CLR(r) (r).iegr_port_l3uc_mods[0] = 0
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_SET(r,d) (r).iegr_port_l3uc_mods[0] = d
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_GET(r) (r).iegr_port_l3uc_mods[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET(r) (((r).iegr_port_l3uc_mods[0]) & 0x1)
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 1) & 0x1)
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 2) & 0x1)
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET(r) ((((r).iegr_port_l3uc_mods[0]) >> 3) & 0x1)
#define BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET(r,f) (r).iegr_port_l3uc_mods[0]=(((r).iegr_port_l3uc_mods[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access IEGR_PORT_L3UC_MODS.
 *
 */
#define BCM56800_A0_READ_IEGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IEGR_PORT_L3UC_MODSr,(r._iegr_port_l3uc_mods))
#define BCM56800_A0_WRITE_IEGR_PORT_L3UC_MODSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IEGR_PORT_L3UC_MODSr,&(r._iegr_port_l3uc_mods))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEGR_PORT_L3UC_MODSr BCM56800_A0_IEGR_PORT_L3UC_MODSr
#define IEGR_PORT_L3UC_MODSr_SIZE BCM56800_A0_IEGR_PORT_L3UC_MODSr_SIZE
typedef BCM56800_A0_IEGR_PORT_L3UC_MODSr_t IEGR_PORT_L3UC_MODSr_t;
#define IEGR_PORT_L3UC_MODSr_CLR BCM56800_A0_IEGR_PORT_L3UC_MODSr_CLR
#define IEGR_PORT_L3UC_MODSr_SET BCM56800_A0_IEGR_PORT_L3UC_MODSr_SET
#define IEGR_PORT_L3UC_MODSr_GET BCM56800_A0_IEGR_PORT_L3UC_MODSr_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_SA_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_DA_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_TTL_DISABLEf_SET
#define IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_GET
#define IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET BCM56800_A0_IEGR_PORT_L3UC_MODSr_L3_UC_VLAN_DISABLEf_SET
#define READ_IEGR_PORT_L3UC_MODSr BCM56800_A0_READ_IEGR_PORT_L3UC_MODSr
#define WRITE_IEGR_PORT_L3UC_MODSr BCM56800_A0_WRITE_IEGR_PORT_L3UC_MODSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IEGR_PORT_L3UC_MODSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IEMIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Egress mirror bitmap
 *
 ******************************************************************************/
#define BCM56800_A0_IEMIRROR_CONTROLr 0x0e100054

#define BCM56800_A0_IEMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IEMIRROR_CONTROL.
 *
 */
typedef union BCM56800_A0_IEMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t iemirror_control[1];
	uint32_t _iemirror_control;
} BCM56800_A0_IEMIRROR_CONTROLr_t;

#define BCM56800_A0_IEMIRROR_CONTROLr_CLR(r) (r).iemirror_control[0] = 0
#define BCM56800_A0_IEMIRROR_CONTROLr_SET(r,d) (r).iemirror_control[0] = d
#define BCM56800_A0_IEMIRROR_CONTROLr_GET(r) (r).iemirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IEMIRROR_CONTROLr_BITMAPf_GET(r) (((r).iemirror_control[0]) & 0x1fffff)
#define BCM56800_A0_IEMIRROR_CONTROLr_BITMAPf_SET(r,f) (r).iemirror_control[0]=(((r).iemirror_control[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IEMIRROR_CONTROL.
 *
 */
#define BCM56800_A0_READ_IEMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IEMIRROR_CONTROLr,(r._iemirror_control))
#define BCM56800_A0_WRITE_IEMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IEMIRROR_CONTROLr,&(r._iemirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IEMIRROR_CONTROLr BCM56800_A0_IEMIRROR_CONTROLr
#define IEMIRROR_CONTROLr_SIZE BCM56800_A0_IEMIRROR_CONTROLr_SIZE
typedef BCM56800_A0_IEMIRROR_CONTROLr_t IEMIRROR_CONTROLr_t;
#define IEMIRROR_CONTROLr_CLR BCM56800_A0_IEMIRROR_CONTROLr_CLR
#define IEMIRROR_CONTROLr_SET BCM56800_A0_IEMIRROR_CONTROLr_SET
#define IEMIRROR_CONTROLr_GET BCM56800_A0_IEMIRROR_CONTROLr_GET
#define IEMIRROR_CONTROLr_BITMAPf_GET BCM56800_A0_IEMIRROR_CONTROLr_BITMAPf_GET
#define IEMIRROR_CONTROLr_BITMAPf_SET BCM56800_A0_IEMIRROR_CONTROLr_BITMAPf_SET
#define READ_IEMIRROR_CONTROLr BCM56800_A0_READ_IEMIRROR_CONTROLr
#define WRITE_IEMIRROR_CONTROLr BCM56800_A0_WRITE_IEMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IEMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IING_EGRMSKBMAP
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of ports to be blocked 1=allow-through, 0=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *
 ******************************************************************************/
#define BCM56800_A0_IING_EGRMSKBMAPr 0x0e100057

#define BCM56800_A0_IING_EGRMSKBMAPr_SIZE 4

/*
 * This structure should be used to declare and program IING_EGRMSKBMAP.
 *
 */
typedef union BCM56800_A0_IING_EGRMSKBMAPr_s {
	uint32_t v[1];
	uint32_t iing_egrmskbmap[1];
	uint32_t _iing_egrmskbmap;
} BCM56800_A0_IING_EGRMSKBMAPr_t;

#define BCM56800_A0_IING_EGRMSKBMAPr_CLR(r) (r).iing_egrmskbmap[0] = 0
#define BCM56800_A0_IING_EGRMSKBMAPr_SET(r,d) (r).iing_egrmskbmap[0] = d
#define BCM56800_A0_IING_EGRMSKBMAPr_GET(r) (r).iing_egrmskbmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IING_EGRMSKBMAPr_BITMAPf_GET(r) (((r).iing_egrmskbmap[0]) & 0x1fffff)
#define BCM56800_A0_IING_EGRMSKBMAPr_BITMAPf_SET(r,f) (r).iing_egrmskbmap[0]=(((r).iing_egrmskbmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IING_EGRMSKBMAP.
 *
 */
#define BCM56800_A0_READ_IING_EGRMSKBMAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IING_EGRMSKBMAPr,(r._iing_egrmskbmap))
#define BCM56800_A0_WRITE_IING_EGRMSKBMAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IING_EGRMSKBMAPr,&(r._iing_egrmskbmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IING_EGRMSKBMAPr BCM56800_A0_IING_EGRMSKBMAPr
#define IING_EGRMSKBMAPr_SIZE BCM56800_A0_IING_EGRMSKBMAPr_SIZE
typedef BCM56800_A0_IING_EGRMSKBMAPr_t IING_EGRMSKBMAPr_t;
#define IING_EGRMSKBMAPr_CLR BCM56800_A0_IING_EGRMSKBMAPr_CLR
#define IING_EGRMSKBMAPr_SET BCM56800_A0_IING_EGRMSKBMAPr_SET
#define IING_EGRMSKBMAPr_GET BCM56800_A0_IING_EGRMSKBMAPr_GET
#define IING_EGRMSKBMAPr_BITMAPf_GET BCM56800_A0_IING_EGRMSKBMAPr_BITMAPf_GET
#define IING_EGRMSKBMAPr_BITMAPf_SET BCM56800_A0_IING_EGRMSKBMAPr_BITMAPf_SET
#define READ_IING_EGRMSKBMAPr BCM56800_A0_READ_IING_EGRMSKBMAPr
#define WRITE_IING_EGRMSKBMAPr BCM56800_A0_WRITE_IING_EGRMSKBMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IING_EGRMSKBMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IIPMC
 * BLOCKS:   IPIPE
 * DESC:     Receive HiGig Packet with IPMC Opcode Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_IIPMCr 0x0e100015

#define BCM56800_A0_IIPMCr_SIZE 4

/*
 * This structure should be used to declare and program IIPMC.
 *
 */
typedef union BCM56800_A0_IIPMCr_s {
	uint32_t v[1];
	uint32_t iipmc[1];
	uint32_t _iipmc;
} BCM56800_A0_IIPMCr_t;

#define BCM56800_A0_IIPMCr_CLR(r) (r).iipmc[0] = 0
#define BCM56800_A0_IIPMCr_SET(r,d) (r).iipmc[0] = d
#define BCM56800_A0_IIPMCr_GET(r) (r).iipmc[0]


/*
 * These macros can be used to access IIPMC.
 *
 */
#define BCM56800_A0_READ_IIPMCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IIPMCr,(r._iipmc))
#define BCM56800_A0_WRITE_IIPMCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IIPMCr,&(r._iipmc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IIPMCr BCM56800_A0_IIPMCr
#define IIPMCr_SIZE BCM56800_A0_IIPMCr_SIZE
typedef BCM56800_A0_IIPMCr_t IIPMCr_t;
#define IIPMCr_CLR BCM56800_A0_IIPMCr_CLR
#define IIPMCr_SET BCM56800_A0_IIPMCr_SET
#define IIPMCr_GET BCM56800_A0_IIPMCr_GET
#define READ_IIPMCr BCM56800_A0_READ_IIPMCr
#define WRITE_IIPMCr BCM56800_A0_WRITE_IIPMCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IIPMCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ILOCAL_SW_DISABLE_DEFAULT_PBM
 * BLOCKS:   IPIPE
 * DESC:     Local switching disable default port bitmap, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      If local switching is disabled, packets will be forwarded according to this field.
 *
 ******************************************************************************/
#define BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr 0x0e100058

#define BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE 4

/*
 * This structure should be used to declare and program ILOCAL_SW_DISABLE_DEFAULT_PBM.
 *
 */
typedef union BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_s {
	uint32_t v[1];
	uint32_t ilocal_sw_disable_default_pbm[1];
	uint32_t _ilocal_sw_disable_default_pbm;
} BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_t;

#define BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_CLR(r) (r).ilocal_sw_disable_default_pbm[0] = 0
#define BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_SET(r,d) (r).ilocal_sw_disable_default_pbm[0] = d
#define BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_GET(r) (r).ilocal_sw_disable_default_pbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET(r) (((r).ilocal_sw_disable_default_pbm[0]) & 0x1fffff)
#define BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET(r,f) (r).ilocal_sw_disable_default_pbm[0]=(((r).ilocal_sw_disable_default_pbm[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access ILOCAL_SW_DISABLE_DEFAULT_PBM.
 *
 */
#define BCM56800_A0_READ_ILOCAL_SW_DISABLE_DEFAULT_PBMr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr,(r._ilocal_sw_disable_default_pbm))
#define BCM56800_A0_WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBMr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr,&(r._ilocal_sw_disable_default_pbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ILOCAL_SW_DISABLE_DEFAULT_PBMr BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr
#define ILOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE
typedef BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_t ILOCAL_SW_DISABLE_DEFAULT_PBMr_t;
#define ILOCAL_SW_DISABLE_DEFAULT_PBMr_CLR BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_CLR
#define ILOCAL_SW_DISABLE_DEFAULT_PBMr_SET BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_SET
#define ILOCAL_SW_DISABLE_DEFAULT_PBMr_GET BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_GET
#define ILOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET
#define ILOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET
#define READ_ILOCAL_SW_DISABLE_DEFAULT_PBMr BCM56800_A0_READ_ILOCAL_SW_DISABLE_DEFAULT_PBMr
#define WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBMr BCM56800_A0_WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ILOCAL_SW_DISABLE_DEFAULT_PBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ILTOMC
 * BLOCKS:   IPIPE
 * DESC:     Receive HiGig Packet with L2MC Opcode Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_ILTOMCr 0x0e100014

#define BCM56800_A0_ILTOMCr_SIZE 4

/*
 * This structure should be used to declare and program ILTOMC.
 *
 */
typedef union BCM56800_A0_ILTOMCr_s {
	uint32_t v[1];
	uint32_t iltomc[1];
	uint32_t _iltomc;
} BCM56800_A0_ILTOMCr_t;

#define BCM56800_A0_ILTOMCr_CLR(r) (r).iltomc[0] = 0
#define BCM56800_A0_ILTOMCr_SET(r,d) (r).iltomc[0] = d
#define BCM56800_A0_ILTOMCr_GET(r) (r).iltomc[0]


/*
 * These macros can be used to access ILTOMC.
 *
 */
#define BCM56800_A0_READ_ILTOMCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ILTOMCr,(r._iltomc))
#define BCM56800_A0_WRITE_ILTOMCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ILTOMCr,&(r._iltomc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ILTOMCr BCM56800_A0_ILTOMCr
#define ILTOMCr_SIZE BCM56800_A0_ILTOMCr_SIZE
typedef BCM56800_A0_ILTOMCr_t ILTOMCr_t;
#define ILTOMCr_CLR BCM56800_A0_ILTOMCr_CLR
#define ILTOMCr_SET BCM56800_A0_ILTOMCr_SET
#define ILTOMCr_GET BCM56800_A0_ILTOMCr_GET
#define READ_ILTOMCr BCM56800_A0_READ_ILTOMCr
#define WRITE_ILTOMCr BCM56800_A0_WRITE_ILTOMCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ILTOMCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IMIRROR_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Alternate Bitmap/path to MTP for Mirroring, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BITMAP           HiGig port bitmap for Egress Mirror pkts.
 *
 ******************************************************************************/
#define BCM56800_A0_IMIRROR_BITMAPr 0x0e10005f

#define BCM56800_A0_IMIRROR_BITMAPr_SIZE 4

/*
 * This structure should be used to declare and program IMIRROR_BITMAP.
 *
 */
typedef union BCM56800_A0_IMIRROR_BITMAPr_s {
	uint32_t v[1];
	uint32_t imirror_bitmap[1];
	uint32_t _imirror_bitmap;
} BCM56800_A0_IMIRROR_BITMAPr_t;

#define BCM56800_A0_IMIRROR_BITMAPr_CLR(r) (r).imirror_bitmap[0] = 0
#define BCM56800_A0_IMIRROR_BITMAPr_SET(r,d) (r).imirror_bitmap[0] = d
#define BCM56800_A0_IMIRROR_BITMAPr_GET(r) (r).imirror_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IMIRROR_BITMAPr_BITMAPf_GET(r) (((r).imirror_bitmap[0]) & 0x1fffff)
#define BCM56800_A0_IMIRROR_BITMAPr_BITMAPf_SET(r,f) (r).imirror_bitmap[0]=(((r).imirror_bitmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IMIRROR_BITMAP.
 *
 */
#define BCM56800_A0_READ_IMIRROR_BITMAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IMIRROR_BITMAPr,(r._imirror_bitmap))
#define BCM56800_A0_WRITE_IMIRROR_BITMAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IMIRROR_BITMAPr,&(r._imirror_bitmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMIRROR_BITMAPr BCM56800_A0_IMIRROR_BITMAPr
#define IMIRROR_BITMAPr_SIZE BCM56800_A0_IMIRROR_BITMAPr_SIZE
typedef BCM56800_A0_IMIRROR_BITMAPr_t IMIRROR_BITMAPr_t;
#define IMIRROR_BITMAPr_CLR BCM56800_A0_IMIRROR_BITMAPr_CLR
#define IMIRROR_BITMAPr_SET BCM56800_A0_IMIRROR_BITMAPr_SET
#define IMIRROR_BITMAPr_GET BCM56800_A0_IMIRROR_BITMAPr_GET
#define IMIRROR_BITMAPr_BITMAPf_GET BCM56800_A0_IMIRROR_BITMAPr_BITMAPf_GET
#define IMIRROR_BITMAPr_BITMAPf_SET BCM56800_A0_IMIRROR_BITMAPr_BITMAPf_SET
#define READ_IMIRROR_BITMAPr BCM56800_A0_READ_IMIRROR_BITMAPr
#define WRITE_IMIRROR_BITMAPr BCM56800_A0_WRITE_IMIRROR_BITMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IMIRROR_BITMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IMIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Mirror control register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *     SRC_MODID_BLOCK_MIRROR_ONLY_PKT Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=1, MH.MD=0 ports
 *     SRC_MODID_BLOCK_MIRROR_COPY Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=0, MH.MD=0 ports
 *
 ******************************************************************************/
#define BCM56800_A0_IMIRROR_CONTROLr 0x0e100653

#define BCM56800_A0_IMIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program IMIRROR_CONTROL.
 *
 */
typedef union BCM56800_A0_IMIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t imirror_control[1];
	uint32_t _imirror_control;
} BCM56800_A0_IMIRROR_CONTROLr_t;

#define BCM56800_A0_IMIRROR_CONTROLr_CLR(r) (r).imirror_control[0] = 0
#define BCM56800_A0_IMIRROR_CONTROLr_SET(r,d) (r).imirror_control[0] = d
#define BCM56800_A0_IMIRROR_CONTROLr_GET(r) (r).imirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IMIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).imirror_control[0]) & 0x1)
#define BCM56800_A0_IMIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 1) & 0x3)
#define BCM56800_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56800_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 3) & 0x3)
#define BCM56800_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56800_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).imirror_control[0]) >> 5) & 0x3)
#define BCM56800_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56800_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET(r) ((((r).imirror_control[0]) >> 7) & 0x1)
#define BCM56800_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET(r) ((((r).imirror_control[0]) >> 8) & 0x1)
#define BCM56800_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET(r,f) (r).imirror_control[0]=(((r).imirror_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access IMIRROR_CONTROL.
 *
 */
#define BCM56800_A0_READ_IMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IMIRROR_CONTROLr,(r._imirror_control))
#define BCM56800_A0_WRITE_IMIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IMIRROR_CONTROLr,&(r._imirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMIRROR_CONTROLr BCM56800_A0_IMIRROR_CONTROLr
#define IMIRROR_CONTROLr_SIZE BCM56800_A0_IMIRROR_CONTROLr_SIZE
typedef BCM56800_A0_IMIRROR_CONTROLr_t IMIRROR_CONTROLr_t;
#define IMIRROR_CONTROLr_CLR BCM56800_A0_IMIRROR_CONTROLr_CLR
#define IMIRROR_CONTROLr_SET BCM56800_A0_IMIRROR_CONTROLr_SET
#define IMIRROR_CONTROLr_GET BCM56800_A0_IMIRROR_CONTROLr_GET
#define IMIRROR_CONTROLr_M_ENABLEf_GET BCM56800_A0_IMIRROR_CONTROLr_M_ENABLEf_GET
#define IMIRROR_CONTROLr_M_ENABLEf_SET BCM56800_A0_IMIRROR_CONTROLr_M_ENABLEf_SET
#define IMIRROR_CONTROLr_IM_MTP_INDEXf_GET BCM56800_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_IM_MTP_INDEXf_SET BCM56800_A0_IMIRROR_CONTROLr_IM_MTP_INDEXf_SET
#define IMIRROR_CONTROLr_EM_MTP_INDEXf_GET BCM56800_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_EM_MTP_INDEXf_SET BCM56800_A0_IMIRROR_CONTROLr_EM_MTP_INDEXf_SET
#define IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET BCM56800_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET
#define IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET BCM56800_A0_IMIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET
#define IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET BCM56800_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET
#define IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET BCM56800_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET
#define IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET BCM56800_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET
#define IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET BCM56800_A0_IMIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET
#define READ_IMIRROR_CONTROLr BCM56800_A0_READ_IMIRROR_CONTROLr
#define WRITE_IMIRROR_CONTROLr BCM56800_A0_WRITE_IMIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IMIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IMMU_FUSE_DEBUG0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     S_RF             fuse values
 *
 ******************************************************************************/
#define BCM56800_A0_IMMU_FUSE_DEBUG0r 0x0fd80015

#define BCM56800_A0_IMMU_FUSE_DEBUG0r_SIZE 4

/*
 * This structure should be used to declare and program IMMU_FUSE_DEBUG0.
 *
 */
typedef union BCM56800_A0_IMMU_FUSE_DEBUG0r_s {
	uint32_t v[1];
	uint32_t immu_fuse_debug0[1];
	uint32_t _immu_fuse_debug0;
} BCM56800_A0_IMMU_FUSE_DEBUG0r_t;

#define BCM56800_A0_IMMU_FUSE_DEBUG0r_CLR(r) (r).immu_fuse_debug0[0] = 0
#define BCM56800_A0_IMMU_FUSE_DEBUG0r_SET(r,d) (r).immu_fuse_debug0[0] = d
#define BCM56800_A0_IMMU_FUSE_DEBUG0r_GET(r) (r).immu_fuse_debug0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IMMU_FUSE_DEBUG0r_S_RFf_GET(r) ((r).immu_fuse_debug0[0])
#define BCM56800_A0_IMMU_FUSE_DEBUG0r_S_RFf_SET(r,f) (r).immu_fuse_debug0[0]=((uint32_t)f)

/*
 * These macros can be used to access IMMU_FUSE_DEBUG0.
 *
 */
#define BCM56800_A0_READ_IMMU_FUSE_DEBUG0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IMMU_FUSE_DEBUG0r,(r._immu_fuse_debug0))
#define BCM56800_A0_WRITE_IMMU_FUSE_DEBUG0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IMMU_FUSE_DEBUG0r,&(r._immu_fuse_debug0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMMU_FUSE_DEBUG0r BCM56800_A0_IMMU_FUSE_DEBUG0r
#define IMMU_FUSE_DEBUG0r_SIZE BCM56800_A0_IMMU_FUSE_DEBUG0r_SIZE
typedef BCM56800_A0_IMMU_FUSE_DEBUG0r_t IMMU_FUSE_DEBUG0r_t;
#define IMMU_FUSE_DEBUG0r_CLR BCM56800_A0_IMMU_FUSE_DEBUG0r_CLR
#define IMMU_FUSE_DEBUG0r_SET BCM56800_A0_IMMU_FUSE_DEBUG0r_SET
#define IMMU_FUSE_DEBUG0r_GET BCM56800_A0_IMMU_FUSE_DEBUG0r_GET
#define IMMU_FUSE_DEBUG0r_S_RFf_GET BCM56800_A0_IMMU_FUSE_DEBUG0r_S_RFf_GET
#define IMMU_FUSE_DEBUG0r_S_RFf_SET BCM56800_A0_IMMU_FUSE_DEBUG0r_S_RFf_SET
#define READ_IMMU_FUSE_DEBUG0r BCM56800_A0_READ_IMMU_FUSE_DEBUG0r
#define WRITE_IMMU_FUSE_DEBUG0r BCM56800_A0_WRITE_IMMU_FUSE_DEBUG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IMMU_FUSE_DEBUG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IMMU_FUSE_DEBUG1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     S_RF             fuse values
 *
 ******************************************************************************/
#define BCM56800_A0_IMMU_FUSE_DEBUG1r 0x0fd80016

#define BCM56800_A0_IMMU_FUSE_DEBUG1r_SIZE 4

/*
 * This structure should be used to declare and program IMMU_FUSE_DEBUG1.
 *
 */
typedef union BCM56800_A0_IMMU_FUSE_DEBUG1r_s {
	uint32_t v[1];
	uint32_t immu_fuse_debug1[1];
	uint32_t _immu_fuse_debug1;
} BCM56800_A0_IMMU_FUSE_DEBUG1r_t;

#define BCM56800_A0_IMMU_FUSE_DEBUG1r_CLR(r) (r).immu_fuse_debug1[0] = 0
#define BCM56800_A0_IMMU_FUSE_DEBUG1r_SET(r,d) (r).immu_fuse_debug1[0] = d
#define BCM56800_A0_IMMU_FUSE_DEBUG1r_GET(r) (r).immu_fuse_debug1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IMMU_FUSE_DEBUG1r_S_RFf_GET(r) ((r).immu_fuse_debug1[0])
#define BCM56800_A0_IMMU_FUSE_DEBUG1r_S_RFf_SET(r,f) (r).immu_fuse_debug1[0]=((uint32_t)f)

/*
 * These macros can be used to access IMMU_FUSE_DEBUG1.
 *
 */
#define BCM56800_A0_READ_IMMU_FUSE_DEBUG1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IMMU_FUSE_DEBUG1r,(r._immu_fuse_debug1))
#define BCM56800_A0_WRITE_IMMU_FUSE_DEBUG1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IMMU_FUSE_DEBUG1r,&(r._immu_fuse_debug1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMMU_FUSE_DEBUG1r BCM56800_A0_IMMU_FUSE_DEBUG1r
#define IMMU_FUSE_DEBUG1r_SIZE BCM56800_A0_IMMU_FUSE_DEBUG1r_SIZE
typedef BCM56800_A0_IMMU_FUSE_DEBUG1r_t IMMU_FUSE_DEBUG1r_t;
#define IMMU_FUSE_DEBUG1r_CLR BCM56800_A0_IMMU_FUSE_DEBUG1r_CLR
#define IMMU_FUSE_DEBUG1r_SET BCM56800_A0_IMMU_FUSE_DEBUG1r_SET
#define IMMU_FUSE_DEBUG1r_GET BCM56800_A0_IMMU_FUSE_DEBUG1r_GET
#define IMMU_FUSE_DEBUG1r_S_RFf_GET BCM56800_A0_IMMU_FUSE_DEBUG1r_S_RFf_GET
#define IMMU_FUSE_DEBUG1r_S_RFf_SET BCM56800_A0_IMMU_FUSE_DEBUG1r_S_RFf_SET
#define READ_IMMU_FUSE_DEBUG1r BCM56800_A0_READ_IMMU_FUSE_DEBUG1r
#define WRITE_IMMU_FUSE_DEBUG1r BCM56800_A0_WRITE_IMMU_FUSE_DEBUG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IMMU_FUSE_DEBUG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IMMU_FUSE_DEBUG2
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     S_RF             fuse values
 *
 ******************************************************************************/
#define BCM56800_A0_IMMU_FUSE_DEBUG2r 0x0fd80017

#define BCM56800_A0_IMMU_FUSE_DEBUG2r_SIZE 4

/*
 * This structure should be used to declare and program IMMU_FUSE_DEBUG2.
 *
 */
typedef union BCM56800_A0_IMMU_FUSE_DEBUG2r_s {
	uint32_t v[1];
	uint32_t immu_fuse_debug2[1];
	uint32_t _immu_fuse_debug2;
} BCM56800_A0_IMMU_FUSE_DEBUG2r_t;

#define BCM56800_A0_IMMU_FUSE_DEBUG2r_CLR(r) (r).immu_fuse_debug2[0] = 0
#define BCM56800_A0_IMMU_FUSE_DEBUG2r_SET(r,d) (r).immu_fuse_debug2[0] = d
#define BCM56800_A0_IMMU_FUSE_DEBUG2r_GET(r) (r).immu_fuse_debug2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IMMU_FUSE_DEBUG2r_S_RFf_GET(r) (((r).immu_fuse_debug2[0]) & 0xfffff)
#define BCM56800_A0_IMMU_FUSE_DEBUG2r_S_RFf_SET(r,f) (r).immu_fuse_debug2[0]=(((r).immu_fuse_debug2[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))

/*
 * These macros can be used to access IMMU_FUSE_DEBUG2.
 *
 */
#define BCM56800_A0_READ_IMMU_FUSE_DEBUG2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IMMU_FUSE_DEBUG2r,(r._immu_fuse_debug2))
#define BCM56800_A0_WRITE_IMMU_FUSE_DEBUG2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IMMU_FUSE_DEBUG2r,&(r._immu_fuse_debug2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMMU_FUSE_DEBUG2r BCM56800_A0_IMMU_FUSE_DEBUG2r
#define IMMU_FUSE_DEBUG2r_SIZE BCM56800_A0_IMMU_FUSE_DEBUG2r_SIZE
typedef BCM56800_A0_IMMU_FUSE_DEBUG2r_t IMMU_FUSE_DEBUG2r_t;
#define IMMU_FUSE_DEBUG2r_CLR BCM56800_A0_IMMU_FUSE_DEBUG2r_CLR
#define IMMU_FUSE_DEBUG2r_SET BCM56800_A0_IMMU_FUSE_DEBUG2r_SET
#define IMMU_FUSE_DEBUG2r_GET BCM56800_A0_IMMU_FUSE_DEBUG2r_GET
#define IMMU_FUSE_DEBUG2r_S_RFf_GET BCM56800_A0_IMMU_FUSE_DEBUG2r_S_RFf_GET
#define IMMU_FUSE_DEBUG2r_S_RFf_SET BCM56800_A0_IMMU_FUSE_DEBUG2r_S_RFf_SET
#define READ_IMMU_FUSE_DEBUG2r BCM56800_A0_READ_IMMU_FUSE_DEBUG2r
#define WRITE_IMMU_FUSE_DEBUG2r BCM56800_A0_WRITE_IMMU_FUSE_DEBUG2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IMMU_FUSE_DEBUG2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IMRP4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 routed multicast packets
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_IMRP4r 0x0e100003

#define BCM56800_A0_IMRP4r_SIZE 4

/*
 * This structure should be used to declare and program IMRP4.
 *
 */
typedef union BCM56800_A0_IMRP4r_s {
	uint32_t v[1];
	uint32_t imrp4[1];
	uint32_t _imrp4;
} BCM56800_A0_IMRP4r_t;

#define BCM56800_A0_IMRP4r_CLR(r) (r).imrp4[0] = 0
#define BCM56800_A0_IMRP4r_SET(r,d) (r).imrp4[0] = d
#define BCM56800_A0_IMRP4r_GET(r) (r).imrp4[0]


/*
 * These macros can be used to access IMRP4.
 *
 */
#define BCM56800_A0_READ_IMRP4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IMRP4r,(r._imrp4))
#define BCM56800_A0_WRITE_IMRP4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IMRP4r,&(r._imrp4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMRP4r BCM56800_A0_IMRP4r
#define IMRP4r_SIZE BCM56800_A0_IMRP4r_SIZE
typedef BCM56800_A0_IMRP4r_t IMRP4r_t;
#define IMRP4r_CLR BCM56800_A0_IMRP4r_CLR
#define IMRP4r_SET BCM56800_A0_IMRP4r_SET
#define IMRP4r_GET BCM56800_A0_IMRP4r_GET
#define READ_IMRP4r BCM56800_A0_READ_IMRP4r
#define WRITE_IMRP4r BCM56800_A0_WRITE_IMRP4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IMRP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IMRP6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 routed multicast packets
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_IMRP6r 0x0e100007

#define BCM56800_A0_IMRP6r_SIZE 4

/*
 * This structure should be used to declare and program IMRP6.
 *
 */
typedef union BCM56800_A0_IMRP6r_s {
	uint32_t v[1];
	uint32_t imrp6[1];
	uint32_t _imrp6;
} BCM56800_A0_IMRP6r_t;

#define BCM56800_A0_IMRP6r_CLR(r) (r).imrp6[0] = 0
#define BCM56800_A0_IMRP6r_SET(r,d) (r).imrp6[0] = d
#define BCM56800_A0_IMRP6r_GET(r) (r).imrp6[0]


/*
 * These macros can be used to access IMRP6.
 *
 */
#define BCM56800_A0_READ_IMRP6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IMRP6r,(r._imrp6))
#define BCM56800_A0_WRITE_IMRP6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IMRP6r,&(r._imrp6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMRP6r BCM56800_A0_IMRP6r
#define IMRP6r_SIZE BCM56800_A0_IMRP6r_SIZE
typedef BCM56800_A0_IMRP6r_t IMRP6r_t;
#define IMRP6r_CLR BCM56800_A0_IMRP6r_CLR
#define IMRP6r_SET BCM56800_A0_IMRP6r_SET
#define IMRP6r_GET BCM56800_A0_IMRP6r_GET
#define READ_IMRP6r BCM56800_A0_READ_IMRP6r
#define WRITE_IMRP6r BCM56800_A0_WRITE_IMRP6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IMRP6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  IM_MTP_INDEX
 * BLOCKS:   IPIPE
 * DESC:     Ingress Mirror to Port Table
 * SIZE:     13
 * FIELDS:
 *     PORT_TGID        Mirror to port port/TGID
 *     MODULE_ID        Mirror to port module ID
 *
 ******************************************************************************/
#define BCM56800_A0_IM_MTP_INDEXm 0x0e168000

#define BCM56800_A0_IM_MTP_INDEXm_MIN 0
#define BCM56800_A0_IM_MTP_INDEXm_MAX 3
#define BCM56800_A0_IM_MTP_INDEXm_CMAX(u) 3
#define BCM56800_A0_IM_MTP_INDEXm_SIZE 2

/*
 * This structure should be used to declare and program IM_MTP_INDEX.
 *
 */
typedef union BCM56800_A0_IM_MTP_INDEXm_s {
	uint32_t v[1];
	uint32_t im_mtp_index[1];
	uint32_t _im_mtp_index;
} BCM56800_A0_IM_MTP_INDEXm_t;

#define BCM56800_A0_IM_MTP_INDEXm_CLR(r) (r).im_mtp_index[0] = 0
#define BCM56800_A0_IM_MTP_INDEXm_SET(r,d) (r).im_mtp_index[0] = d
#define BCM56800_A0_IM_MTP_INDEXm_GET(r) (r).im_mtp_index[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IM_MTP_INDEXm_PORT_TGIDf_GET(r) (((r).im_mtp_index[0]) & 0x3f)
#define BCM56800_A0_IM_MTP_INDEXm_PORT_TGIDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_IM_MTP_INDEXm_MODULE_IDf_GET(r) ((((r).im_mtp_index[0]) >> 6) & 0x7f)
#define BCM56800_A0_IM_MTP_INDEXm_MODULE_IDf_SET(r,f) (r).im_mtp_index[0]=(((r).im_mtp_index[0] & ~((uint32_t)0x7f << 6)) | ((((uint32_t)f) & 0x7f) << 6))

/*
 * These macros can be used to access IM_MTP_INDEX.
 *
 */
#define BCM56800_A0_READ_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_IM_MTP_INDEXm,i,(m._im_mtp_index),1)
#define BCM56800_A0_WRITE_IM_MTP_INDEXm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_IM_MTP_INDEXm,i,&(m._im_mtp_index),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IM_MTP_INDEXm BCM56800_A0_IM_MTP_INDEXm
#define IM_MTP_INDEXm_MIN BCM56800_A0_IM_MTP_INDEXm_MIN
#define IM_MTP_INDEXm_MAX BCM56800_A0_IM_MTP_INDEXm_MAX
#define IM_MTP_INDEXm_CMAX(u) BCM56800_A0_IM_MTP_INDEXm_CMAX(u)
#define IM_MTP_INDEXm_SIZE BCM56800_A0_IM_MTP_INDEXm_SIZE
typedef BCM56800_A0_IM_MTP_INDEXm_t IM_MTP_INDEXm_t;
#define IM_MTP_INDEXm_CLR BCM56800_A0_IM_MTP_INDEXm_CLR
#define IM_MTP_INDEXm_SET BCM56800_A0_IM_MTP_INDEXm_SET
#define IM_MTP_INDEXm_GET BCM56800_A0_IM_MTP_INDEXm_GET
#define IM_MTP_INDEXm_PORT_TGIDf_GET BCM56800_A0_IM_MTP_INDEXm_PORT_TGIDf_GET
#define IM_MTP_INDEXm_PORT_TGIDf_SET BCM56800_A0_IM_MTP_INDEXm_PORT_TGIDf_SET
#define IM_MTP_INDEXm_MODULE_IDf_GET BCM56800_A0_IM_MTP_INDEXm_MODULE_IDf_GET
#define IM_MTP_INDEXm_MODULE_IDf_SET BCM56800_A0_IM_MTP_INDEXm_MODULE_IDf_SET
#define READ_IM_MTP_INDEXm BCM56800_A0_READ_IM_MTP_INDEXm
#define WRITE_IM_MTP_INDEXm BCM56800_A0_WRITE_IM_MTP_INDEXm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IM_MTP_INDEXm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Switch configuration register
 * SIZE:     32
 * FIELDS:
 *     DT_MODE          Enables double tagging mode
 *     TRUNKS128        Indicates if 128 trunk groups are supported
 *     L2DST_HIT_ENABLE If set, L2 table will update its HIT bit on dest lookup
 *     L3SRC_HIT_ENABLE If set, L3 table will update its HIT bit on src lookup. Only apply to Unicast packets.
 *     DRACO1_5_MIRROR  Enables Draco 1.5 style mirroring
 *     CFI_AS_CNG       For tagged packets, use VLAN's CFI field to map to an internal CNG value (for double tagging)
 *     SNAP_OTHER_DECODE_ENABLE Decode SNAP packets with non-zero OUI for protocol-based VLAN
 *     STNMOVE_ON_L2SRC_DISC Perform station movement on L2 source discard packets
 *     FB_A0_COMPATIBLE FB-A0 compatible mode. Used for disabling source modid checks for mirror pkts on HiGig when in FB style of mirroring.
 *     STACK_MODE       Stacking Mode.
 *     CVLAN_CFI_AS_CNG Treat CFI bit in customer vlan tag as CNG
 *     APPLY_EGR_MASK_ON_L2 Apply Egress mask for L2 switched packets
 *     APPLY_EGR_MASK_ON_L3 Apply Egress mask for L3 switched packets
 *     SVL_ENABLE       Enable Shared VLAN Learning
 *     LOOKUP_L2MC_WITH_FID_ID Enable Shared VLAN Learning
 *     MAP_FID_ID_TO_OUTER_TAG Copy FID-ID as VLAN-ID in outer vlan tag for FP classification only
 *     MAP_FID_ID_TO_INNER_TAG Copy FID-ID as VLAN-ID in inner vlan tag for FP classification only
 *     DISABLE_E2E_HOL_CHECK Disable E2E HOL checking
 *     LBID_RTAG        RTAG selecting how LBID is computed
 *     APPLY_MTU_CHECK_ON_HIGIG_IPMC If set, L3 MTU check is applied to HiGig IPMC packets.
 *     IGNORE_HG_HDR_LAG_FAILOVER If set, HiGig hdrs LAG_FAILOVER bit will be ignored and will be treated as reserved bit.
 *     IGNORE_HG_HDR_DONOT_LEARN If set, HiGig hdrs DONOT_LEARN bit will be ignored and will be treated as reserved bit.
 *     IGNORE_HG_HDR_HDR_EXT_LEN If set, HiGig+ hdrs HDR_EXT_LEN bits will be ignored and will be treated as reserved bit.
 *     IGNORE_MY_MODID  If set, the MY_MODID from the PORT TABLE will be ignored. The chip will not have a module ID (this is the case when the chip is used as a fabric device).
 *
 ******************************************************************************/
#define BCM56800_A0_ING_CONFIGr 0x01180600

#define BCM56800_A0_ING_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_CONFIG.
 *
 */
typedef union BCM56800_A0_ING_CONFIGr_s {
	uint32_t v[1];
	uint32_t ing_config[1];
	uint32_t _ing_config;
} BCM56800_A0_ING_CONFIGr_t;

#define BCM56800_A0_ING_CONFIGr_CLR(r) (r).ing_config[0] = 0
#define BCM56800_A0_ING_CONFIGr_SET(r,d) (r).ing_config[0] = d
#define BCM56800_A0_ING_CONFIGr_GET(r) (r).ing_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_CONFIGr_DT_MODEf_GET(r) (((r).ing_config[0]) & 0x1)
#define BCM56800_A0_ING_CONFIGr_DT_MODEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_ING_CONFIGr_TRUNKS128f_GET(r) ((((r).ing_config[0]) >> 1) & 0x1)
#define BCM56800_A0_ING_CONFIGr_TRUNKS128f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_GET(r) ((((r).ing_config[0]) >> 2) & 0x1)
#define BCM56800_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_GET(r) ((((r).ing_config[0]) >> 3) & 0x1)
#define BCM56800_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_ING_CONFIGr_DRACO1_5_MIRRORf_GET(r) ((((r).ing_config[0]) >> 4) & 0x1)
#define BCM56800_A0_ING_CONFIGr_DRACO1_5_MIRRORf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_ING_CONFIGr_CFI_AS_CNGf_GET(r) ((((r).ing_config[0]) >> 5) & 0x1)
#define BCM56800_A0_ING_CONFIGr_CFI_AS_CNGf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET(r) ((((r).ing_config[0]) >> 6) & 0x1)
#define BCM56800_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET(r) ((((r).ing_config[0]) >> 7) & 0x1)
#define BCM56800_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_GET(r) ((((r).ing_config[0]) >> 8) & 0x1)
#define BCM56800_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_ING_CONFIGr_STACK_MODEf_GET(r) ((((r).ing_config[0]) >> 9) & 0x3)
#define BCM56800_A0_ING_CONFIGr_STACK_MODEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM56800_A0_ING_CONFIGr_CVLAN_CFI_AS_CNGf_GET(r) ((((r).ing_config[0]) >> 11) & 0x1)
#define BCM56800_A0_ING_CONFIGr_CVLAN_CFI_AS_CNGf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET(r) ((((r).ing_config[0]) >> 12) & 0x1)
#define BCM56800_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET(r) ((((r).ing_config[0]) >> 13) & 0x1)
#define BCM56800_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_ING_CONFIGr_SVL_ENABLEf_GET(r) ((((r).ing_config[0]) >> 14) & 0x1)
#define BCM56800_A0_ING_CONFIGr_SVL_ENABLEf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_ING_CONFIGr_LOOKUP_L2MC_WITH_FID_IDf_GET(r) ((((r).ing_config[0]) >> 15) & 0x1)
#define BCM56800_A0_ING_CONFIGr_LOOKUP_L2MC_WITH_FID_IDf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_ING_CONFIGr_MAP_FID_ID_TO_OUTER_TAGf_GET(r) ((((r).ing_config[0]) >> 16) & 0x1)
#define BCM56800_A0_ING_CONFIGr_MAP_FID_ID_TO_OUTER_TAGf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_ING_CONFIGr_MAP_FID_ID_TO_INNER_TAGf_GET(r) ((((r).ing_config[0]) >> 17) & 0x1)
#define BCM56800_A0_ING_CONFIGr_MAP_FID_ID_TO_INNER_TAGf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_ING_CONFIGr_DISABLE_E2E_HOL_CHECKf_GET(r) ((((r).ing_config[0]) >> 18) & 0x1)
#define BCM56800_A0_ING_CONFIGr_DISABLE_E2E_HOL_CHECKf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_ING_CONFIGr_LBID_RTAGf_GET(r) ((((r).ing_config[0]) >> 19) & 0x7)
#define BCM56800_A0_ING_CONFIGr_LBID_RTAGf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM56800_A0_ING_CONFIGr_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_GET(r) ((((r).ing_config[0]) >> 22) & 0x1)
#define BCM56800_A0_ING_CONFIGr_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_LAG_FAILOVERf_GET(r) ((((r).ing_config[0]) >> 23) & 0x1)
#define BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_LAG_FAILOVERf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET(r) ((((r).ing_config[0]) >> 24) & 0x1)
#define BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_HDR_EXT_LENf_GET(r) ((((r).ing_config[0]) >> 25) & 0x1)
#define BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_HDR_EXT_LENf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_ING_CONFIGr_IGNORE_MY_MODIDf_GET(r) ((((r).ing_config[0]) >> 26) & 0x1)
#define BCM56800_A0_ING_CONFIGr_IGNORE_MY_MODIDf_SET(r,f) (r).ing_config[0]=(((r).ing_config[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access ING_CONFIG.
 *
 */
#define BCM56800_A0_READ_ING_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_CONFIGr,(r._ing_config))
#define BCM56800_A0_WRITE_ING_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_CONFIGr,&(r._ing_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_CONFIGr BCM56800_A0_ING_CONFIGr
#define ING_CONFIGr_SIZE BCM56800_A0_ING_CONFIGr_SIZE
typedef BCM56800_A0_ING_CONFIGr_t ING_CONFIGr_t;
#define ING_CONFIGr_CLR BCM56800_A0_ING_CONFIGr_CLR
#define ING_CONFIGr_SET BCM56800_A0_ING_CONFIGr_SET
#define ING_CONFIGr_GET BCM56800_A0_ING_CONFIGr_GET
#define ING_CONFIGr_DT_MODEf_GET BCM56800_A0_ING_CONFIGr_DT_MODEf_GET
#define ING_CONFIGr_DT_MODEf_SET BCM56800_A0_ING_CONFIGr_DT_MODEf_SET
#define ING_CONFIGr_TRUNKS128f_GET BCM56800_A0_ING_CONFIGr_TRUNKS128f_GET
#define ING_CONFIGr_TRUNKS128f_SET BCM56800_A0_ING_CONFIGr_TRUNKS128f_SET
#define ING_CONFIGr_L2DST_HIT_ENABLEf_GET BCM56800_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_GET
#define ING_CONFIGr_L2DST_HIT_ENABLEf_SET BCM56800_A0_ING_CONFIGr_L2DST_HIT_ENABLEf_SET
#define ING_CONFIGr_L3SRC_HIT_ENABLEf_GET BCM56800_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_GET
#define ING_CONFIGr_L3SRC_HIT_ENABLEf_SET BCM56800_A0_ING_CONFIGr_L3SRC_HIT_ENABLEf_SET
#define ING_CONFIGr_DRACO1_5_MIRRORf_GET BCM56800_A0_ING_CONFIGr_DRACO1_5_MIRRORf_GET
#define ING_CONFIGr_DRACO1_5_MIRRORf_SET BCM56800_A0_ING_CONFIGr_DRACO1_5_MIRRORf_SET
#define ING_CONFIGr_CFI_AS_CNGf_GET BCM56800_A0_ING_CONFIGr_CFI_AS_CNGf_GET
#define ING_CONFIGr_CFI_AS_CNGf_SET BCM56800_A0_ING_CONFIGr_CFI_AS_CNGf_SET
#define ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET BCM56800_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_GET
#define ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET BCM56800_A0_ING_CONFIGr_SNAP_OTHER_DECODE_ENABLEf_SET
#define ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET BCM56800_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_GET
#define ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET BCM56800_A0_ING_CONFIGr_STNMOVE_ON_L2SRC_DISCf_SET
#define ING_CONFIGr_FB_A0_COMPATIBLEf_GET BCM56800_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_GET
#define ING_CONFIGr_FB_A0_COMPATIBLEf_SET BCM56800_A0_ING_CONFIGr_FB_A0_COMPATIBLEf_SET
#define ING_CONFIGr_STACK_MODEf_GET BCM56800_A0_ING_CONFIGr_STACK_MODEf_GET
#define ING_CONFIGr_STACK_MODEf_SET BCM56800_A0_ING_CONFIGr_STACK_MODEf_SET
#define ING_CONFIGr_CVLAN_CFI_AS_CNGf_GET BCM56800_A0_ING_CONFIGr_CVLAN_CFI_AS_CNGf_GET
#define ING_CONFIGr_CVLAN_CFI_AS_CNGf_SET BCM56800_A0_ING_CONFIGr_CVLAN_CFI_AS_CNGf_SET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET BCM56800_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_GET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET BCM56800_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L2f_SET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET BCM56800_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_GET
#define ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET BCM56800_A0_ING_CONFIGr_APPLY_EGR_MASK_ON_L3f_SET
#define ING_CONFIGr_SVL_ENABLEf_GET BCM56800_A0_ING_CONFIGr_SVL_ENABLEf_GET
#define ING_CONFIGr_SVL_ENABLEf_SET BCM56800_A0_ING_CONFIGr_SVL_ENABLEf_SET
#define ING_CONFIGr_LOOKUP_L2MC_WITH_FID_IDf_GET BCM56800_A0_ING_CONFIGr_LOOKUP_L2MC_WITH_FID_IDf_GET
#define ING_CONFIGr_LOOKUP_L2MC_WITH_FID_IDf_SET BCM56800_A0_ING_CONFIGr_LOOKUP_L2MC_WITH_FID_IDf_SET
#define ING_CONFIGr_MAP_FID_ID_TO_OUTER_TAGf_GET BCM56800_A0_ING_CONFIGr_MAP_FID_ID_TO_OUTER_TAGf_GET
#define ING_CONFIGr_MAP_FID_ID_TO_OUTER_TAGf_SET BCM56800_A0_ING_CONFIGr_MAP_FID_ID_TO_OUTER_TAGf_SET
#define ING_CONFIGr_MAP_FID_ID_TO_INNER_TAGf_GET BCM56800_A0_ING_CONFIGr_MAP_FID_ID_TO_INNER_TAGf_GET
#define ING_CONFIGr_MAP_FID_ID_TO_INNER_TAGf_SET BCM56800_A0_ING_CONFIGr_MAP_FID_ID_TO_INNER_TAGf_SET
#define ING_CONFIGr_DISABLE_E2E_HOL_CHECKf_GET BCM56800_A0_ING_CONFIGr_DISABLE_E2E_HOL_CHECKf_GET
#define ING_CONFIGr_DISABLE_E2E_HOL_CHECKf_SET BCM56800_A0_ING_CONFIGr_DISABLE_E2E_HOL_CHECKf_SET
#define ING_CONFIGr_LBID_RTAGf_GET BCM56800_A0_ING_CONFIGr_LBID_RTAGf_GET
#define ING_CONFIGr_LBID_RTAGf_SET BCM56800_A0_ING_CONFIGr_LBID_RTAGf_SET
#define ING_CONFIGr_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_GET BCM56800_A0_ING_CONFIGr_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_GET
#define ING_CONFIGr_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_SET BCM56800_A0_ING_CONFIGr_APPLY_MTU_CHECK_ON_HIGIG_IPMCf_SET
#define ING_CONFIGr_IGNORE_HG_HDR_LAG_FAILOVERf_GET BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_LAG_FAILOVERf_GET
#define ING_CONFIGr_IGNORE_HG_HDR_LAG_FAILOVERf_SET BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_LAG_FAILOVERf_SET
#define ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_GET
#define ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_DONOT_LEARNf_SET
#define ING_CONFIGr_IGNORE_HG_HDR_HDR_EXT_LENf_GET BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_HDR_EXT_LENf_GET
#define ING_CONFIGr_IGNORE_HG_HDR_HDR_EXT_LENf_SET BCM56800_A0_ING_CONFIGr_IGNORE_HG_HDR_HDR_EXT_LENf_SET
#define ING_CONFIGr_IGNORE_MY_MODIDf_GET BCM56800_A0_ING_CONFIGr_IGNORE_MY_MODIDf_GET
#define ING_CONFIGr_IGNORE_MY_MODIDf_SET BCM56800_A0_ING_CONFIGr_IGNORE_MY_MODIDf_SET
#define READ_ING_CONFIGr BCM56800_A0_READ_ING_CONFIGr
#define WRITE_ING_CONFIGr BCM56800_A0_WRITE_ING_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_EGRMSKBMAP
 * BLOCKS:   IPIPE
 * DESC:     Ingress Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of ports to be blocked 1=allow-through, 0=block. Note: If any bit in this register belongs to a member of a trunk group (either GE/HIGIG), then in order to function correctly, all bits of that trunk group should be disabled here as well.
 *
 ******************************************************************************/
#define BCM56800_A0_ING_EGRMSKBMAPr 0x0e100047

#define BCM56800_A0_ING_EGRMSKBMAPr_SIZE 4

/*
 * This structure should be used to declare and program ING_EGRMSKBMAP.
 *
 */
typedef union BCM56800_A0_ING_EGRMSKBMAPr_s {
	uint32_t v[1];
	uint32_t ing_egrmskbmap[1];
	uint32_t _ing_egrmskbmap;
} BCM56800_A0_ING_EGRMSKBMAPr_t;

#define BCM56800_A0_ING_EGRMSKBMAPr_CLR(r) (r).ing_egrmskbmap[0] = 0
#define BCM56800_A0_ING_EGRMSKBMAPr_SET(r,d) (r).ing_egrmskbmap[0] = d
#define BCM56800_A0_ING_EGRMSKBMAPr_GET(r) (r).ing_egrmskbmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_EGRMSKBMAPr_BITMAPf_GET(r) (((r).ing_egrmskbmap[0]) & 0x1fffff)
#define BCM56800_A0_ING_EGRMSKBMAPr_BITMAPf_SET(r,f) (r).ing_egrmskbmap[0]=(((r).ing_egrmskbmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access ING_EGRMSKBMAP.
 *
 */
#define BCM56800_A0_READ_ING_EGRMSKBMAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ING_EGRMSKBMAPr,(r._ing_egrmskbmap))
#define BCM56800_A0_WRITE_ING_EGRMSKBMAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ING_EGRMSKBMAPr,&(r._ing_egrmskbmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EGRMSKBMAPr BCM56800_A0_ING_EGRMSKBMAPr
#define ING_EGRMSKBMAPr_SIZE BCM56800_A0_ING_EGRMSKBMAPr_SIZE
typedef BCM56800_A0_ING_EGRMSKBMAPr_t ING_EGRMSKBMAPr_t;
#define ING_EGRMSKBMAPr_CLR BCM56800_A0_ING_EGRMSKBMAPr_CLR
#define ING_EGRMSKBMAPr_SET BCM56800_A0_ING_EGRMSKBMAPr_SET
#define ING_EGRMSKBMAPr_GET BCM56800_A0_ING_EGRMSKBMAPr_GET
#define ING_EGRMSKBMAPr_BITMAPf_GET BCM56800_A0_ING_EGRMSKBMAPr_BITMAPf_GET
#define ING_EGRMSKBMAPr_BITMAPf_SET BCM56800_A0_ING_EGRMSKBMAPr_BITMAPf_SET
#define READ_ING_EGRMSKBMAPr BCM56800_A0_READ_ING_EGRMSKBMAPr
#define WRITE_ING_EGRMSKBMAPr BCM56800_A0_WRITE_ING_EGRMSKBMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_EGRMSKBMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_EVENT_DEBUG
 * BLOCKS:   IPIPE
 * DESC:     Ingress Events Debug Register
 * SIZE:     32
 * FIELDS:
 *     VXLT_MISS        Bit 0 - Packets dropped due to VLAN translation miss
 *     BPDU             Bit 1 - BPDU packet drop
 *     PROTOCOL_PKT     Bit 2 - Protocol packet drop
 *     CML              Bit 3 - Packets dropped due to CML
 *     SRC_ROUTE        Bit 4 - Packets dropped due to source route
 *     L2SRC_DISCARD    Bit 5 - Packets dropped due to L2 source discard
 *     L2SRC_STATIC_MOVE Bit 6 - Packets dropped due to L2 source static movement
 *     L2DST_DISCARD    Bit 7 - Packets dropped due to L2 destination discard
 *     CFI_OR_L3DISABLE Bit 8 - Packets dropped due to CFI or L3 disable
 *     HIGIG_MH_TYPE1   Bit 9 - Packets dropped due to HiGig module header type 1
 *     DISC_STAGE       Bit 10 - Packets dropped in discard stage
 *     SW1_INVALID_VLAN Bit 11 - Packets dropped due to invalid VLAN
 *     PDISC            Bit 12 - Receive policy discard counter - DST_DISCARD, SRC_DISCARD, RATE_CONTROL, etc.
 *     RFILDR           Bit 13 - Packets dropped by FP
 *     RIMDR            Bit 14 - Multicast (L2+L3) packets that are dropped
 *     RDROP            Bit 15 - Port bitmap zero drop condition
 *     RESERVED_0       Bit 16 - Reserved
 *     RESERVED_1       Bit 17 - Reserved
 *     RESERVED_2       Bit 18 - Reserved
 *     DSL3HE           Bit 19 - DOS L3 header error packets
 *     DSL4HE           Bit 20 - DOS L4 header error packets
 *     DSICMP           Bit 21 - DOS ICMP error packets
 *     DSFRAG           Bit 22 - DOS fragment error packets
 *     MTUERR           Bit 23 - Packets trapped to CPU due to egress L3 MTU violation
 *     RESERVED_3       Bit 24 - Reserved
 *     RTUNE            Bit 25 - Receive tunnel error packets
 *     HG_FAILOVER_PORT_DOWN Bit 26 - Packets dropped due to Higig failover port down
 *     HGHDRE           Bit 27 - Higig Header error packets
 *     MCIDXE           Bit 28 - Multicast Index error packets
 *     LAGLUP           Bit 29 - LAG failover loopback packets
 *     LAGLUPD          Bit 30 - LAG failover loopback packets discarded due to backup port down
 *     PARITYD          Bit 31 - Parity error packets
 *
 ******************************************************************************/
#define BCM56800_A0_ING_EVENT_DEBUGr 0x0e180c53

#define BCM56800_A0_ING_EVENT_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program ING_EVENT_DEBUG.
 *
 */
typedef union BCM56800_A0_ING_EVENT_DEBUGr_s {
	uint32_t v[1];
	uint32_t ing_event_debug[1];
	uint32_t _ing_event_debug;
} BCM56800_A0_ING_EVENT_DEBUGr_t;

#define BCM56800_A0_ING_EVENT_DEBUGr_CLR(r) (r).ing_event_debug[0] = 0
#define BCM56800_A0_ING_EVENT_DEBUGr_SET(r,d) (r).ing_event_debug[0] = d
#define BCM56800_A0_ING_EVENT_DEBUGr_GET(r) (r).ing_event_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_EVENT_DEBUGr_VXLT_MISSf_GET(r) (((r).ing_event_debug[0]) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_VXLT_MISSf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_ING_EVENT_DEBUGr_BPDUf_GET(r) ((((r).ing_event_debug[0]) >> 1) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_BPDUf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET(r) ((((r).ing_event_debug[0]) >> 2) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_ING_EVENT_DEBUGr_CMLf_GET(r) ((((r).ing_event_debug[0]) >> 3) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_CMLf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_GET(r) ((((r).ing_event_debug[0]) >> 4) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET(r) ((((r).ing_event_debug[0]) >> 5) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET(r) ((((r).ing_event_debug[0]) >> 6) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_GET(r) ((((r).ing_event_debug[0]) >> 7) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET(r) ((((r).ing_event_debug[0]) >> 8) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET(r) ((((r).ing_event_debug[0]) >> 9) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_ING_EVENT_DEBUGr_DISC_STAGEf_GET(r) ((((r).ing_event_debug[0]) >> 10) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_DISC_STAGEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_ING_EVENT_DEBUGr_SW1_INVALID_VLANf_GET(r) ((((r).ing_event_debug[0]) >> 11) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_SW1_INVALID_VLANf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_ING_EVENT_DEBUGr_PDISCf_GET(r) ((((r).ing_event_debug[0]) >> 12) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_PDISCf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_ING_EVENT_DEBUGr_RFILDRf_GET(r) ((((r).ing_event_debug[0]) >> 13) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_RFILDRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_ING_EVENT_DEBUGr_RIMDRf_GET(r) ((((r).ing_event_debug[0]) >> 14) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_RIMDRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_ING_EVENT_DEBUGr_RDROPf_GET(r) ((((r).ing_event_debug[0]) >> 15) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_RDROPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_0f_GET(r) ((((r).ing_event_debug[0]) >> 16) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_0f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_1f_GET(r) ((((r).ing_event_debug[0]) >> 17) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_1f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_2f_GET(r) ((((r).ing_event_debug[0]) >> 18) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_2f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_ING_EVENT_DEBUGr_DSL3HEf_GET(r) ((((r).ing_event_debug[0]) >> 19) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_DSL3HEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_ING_EVENT_DEBUGr_DSL4HEf_GET(r) ((((r).ing_event_debug[0]) >> 20) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_DSL4HEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_ING_EVENT_DEBUGr_DSICMPf_GET(r) ((((r).ing_event_debug[0]) >> 21) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_DSICMPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_ING_EVENT_DEBUGr_DSFRAGf_GET(r) ((((r).ing_event_debug[0]) >> 22) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_DSFRAGf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_ING_EVENT_DEBUGr_MTUERRf_GET(r) ((((r).ing_event_debug[0]) >> 23) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_MTUERRf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_3f_GET(r) ((((r).ing_event_debug[0]) >> 24) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_3f_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_ING_EVENT_DEBUGr_RTUNEf_GET(r) ((((r).ing_event_debug[0]) >> 25) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_RTUNEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_ING_EVENT_DEBUGr_HG_FAILOVER_PORT_DOWNf_GET(r) ((((r).ing_event_debug[0]) >> 26) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_HG_FAILOVER_PORT_DOWNf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_ING_EVENT_DEBUGr_HGHDREf_GET(r) ((((r).ing_event_debug[0]) >> 27) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_HGHDREf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_ING_EVENT_DEBUGr_MCIDXEf_GET(r) ((((r).ing_event_debug[0]) >> 28) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_MCIDXEf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_ING_EVENT_DEBUGr_LAGLUPf_GET(r) ((((r).ing_event_debug[0]) >> 29) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_LAGLUPf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_ING_EVENT_DEBUGr_LAGLUPDf_GET(r) ((((r).ing_event_debug[0]) >> 30) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_LAGLUPDf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_ING_EVENT_DEBUGr_PARITYDf_GET(r) ((((r).ing_event_debug[0]) >> 31) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUGr_PARITYDf_SET(r,f) (r).ing_event_debug[0]=(((r).ing_event_debug[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ING_EVENT_DEBUG.
 *
 */
#define BCM56800_A0_READ_ING_EVENT_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_EVENT_DEBUGr,(r._ing_event_debug))
#define BCM56800_A0_WRITE_ING_EVENT_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_EVENT_DEBUGr,&(r._ing_event_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EVENT_DEBUGr BCM56800_A0_ING_EVENT_DEBUGr
#define ING_EVENT_DEBUGr_SIZE BCM56800_A0_ING_EVENT_DEBUGr_SIZE
typedef BCM56800_A0_ING_EVENT_DEBUGr_t ING_EVENT_DEBUGr_t;
#define ING_EVENT_DEBUGr_CLR BCM56800_A0_ING_EVENT_DEBUGr_CLR
#define ING_EVENT_DEBUGr_SET BCM56800_A0_ING_EVENT_DEBUGr_SET
#define ING_EVENT_DEBUGr_GET BCM56800_A0_ING_EVENT_DEBUGr_GET
#define ING_EVENT_DEBUGr_VXLT_MISSf_GET BCM56800_A0_ING_EVENT_DEBUGr_VXLT_MISSf_GET
#define ING_EVENT_DEBUGr_VXLT_MISSf_SET BCM56800_A0_ING_EVENT_DEBUGr_VXLT_MISSf_SET
#define ING_EVENT_DEBUGr_BPDUf_GET BCM56800_A0_ING_EVENT_DEBUGr_BPDUf_GET
#define ING_EVENT_DEBUGr_BPDUf_SET BCM56800_A0_ING_EVENT_DEBUGr_BPDUf_SET
#define ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET BCM56800_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_GET
#define ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET BCM56800_A0_ING_EVENT_DEBUGr_PROTOCOL_PKTf_SET
#define ING_EVENT_DEBUGr_CMLf_GET BCM56800_A0_ING_EVENT_DEBUGr_CMLf_GET
#define ING_EVENT_DEBUGr_CMLf_SET BCM56800_A0_ING_EVENT_DEBUGr_CMLf_SET
#define ING_EVENT_DEBUGr_SRC_ROUTEf_GET BCM56800_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_GET
#define ING_EVENT_DEBUGr_SRC_ROUTEf_SET BCM56800_A0_ING_EVENT_DEBUGr_SRC_ROUTEf_SET
#define ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET BCM56800_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_GET
#define ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET BCM56800_A0_ING_EVENT_DEBUGr_L2SRC_DISCARDf_SET
#define ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET BCM56800_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_GET
#define ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET BCM56800_A0_ING_EVENT_DEBUGr_L2SRC_STATIC_MOVEf_SET
#define ING_EVENT_DEBUGr_L2DST_DISCARDf_GET BCM56800_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_GET
#define ING_EVENT_DEBUGr_L2DST_DISCARDf_SET BCM56800_A0_ING_EVENT_DEBUGr_L2DST_DISCARDf_SET
#define ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET BCM56800_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_GET
#define ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET BCM56800_A0_ING_EVENT_DEBUGr_CFI_OR_L3DISABLEf_SET
#define ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET BCM56800_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_GET
#define ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET BCM56800_A0_ING_EVENT_DEBUGr_HIGIG_MH_TYPE1f_SET
#define ING_EVENT_DEBUGr_DISC_STAGEf_GET BCM56800_A0_ING_EVENT_DEBUGr_DISC_STAGEf_GET
#define ING_EVENT_DEBUGr_DISC_STAGEf_SET BCM56800_A0_ING_EVENT_DEBUGr_DISC_STAGEf_SET
#define ING_EVENT_DEBUGr_SW1_INVALID_VLANf_GET BCM56800_A0_ING_EVENT_DEBUGr_SW1_INVALID_VLANf_GET
#define ING_EVENT_DEBUGr_SW1_INVALID_VLANf_SET BCM56800_A0_ING_EVENT_DEBUGr_SW1_INVALID_VLANf_SET
#define ING_EVENT_DEBUGr_PDISCf_GET BCM56800_A0_ING_EVENT_DEBUGr_PDISCf_GET
#define ING_EVENT_DEBUGr_PDISCf_SET BCM56800_A0_ING_EVENT_DEBUGr_PDISCf_SET
#define ING_EVENT_DEBUGr_RFILDRf_GET BCM56800_A0_ING_EVENT_DEBUGr_RFILDRf_GET
#define ING_EVENT_DEBUGr_RFILDRf_SET BCM56800_A0_ING_EVENT_DEBUGr_RFILDRf_SET
#define ING_EVENT_DEBUGr_RIMDRf_GET BCM56800_A0_ING_EVENT_DEBUGr_RIMDRf_GET
#define ING_EVENT_DEBUGr_RIMDRf_SET BCM56800_A0_ING_EVENT_DEBUGr_RIMDRf_SET
#define ING_EVENT_DEBUGr_RDROPf_GET BCM56800_A0_ING_EVENT_DEBUGr_RDROPf_GET
#define ING_EVENT_DEBUGr_RDROPf_SET BCM56800_A0_ING_EVENT_DEBUGr_RDROPf_SET
#define ING_EVENT_DEBUGr_RESERVED_0f_GET BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_0f_GET
#define ING_EVENT_DEBUGr_RESERVED_0f_SET BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_0f_SET
#define ING_EVENT_DEBUGr_RESERVED_1f_GET BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_1f_GET
#define ING_EVENT_DEBUGr_RESERVED_1f_SET BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_1f_SET
#define ING_EVENT_DEBUGr_RESERVED_2f_GET BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_2f_GET
#define ING_EVENT_DEBUGr_RESERVED_2f_SET BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_2f_SET
#define ING_EVENT_DEBUGr_DSL3HEf_GET BCM56800_A0_ING_EVENT_DEBUGr_DSL3HEf_GET
#define ING_EVENT_DEBUGr_DSL3HEf_SET BCM56800_A0_ING_EVENT_DEBUGr_DSL3HEf_SET
#define ING_EVENT_DEBUGr_DSL4HEf_GET BCM56800_A0_ING_EVENT_DEBUGr_DSL4HEf_GET
#define ING_EVENT_DEBUGr_DSL4HEf_SET BCM56800_A0_ING_EVENT_DEBUGr_DSL4HEf_SET
#define ING_EVENT_DEBUGr_DSICMPf_GET BCM56800_A0_ING_EVENT_DEBUGr_DSICMPf_GET
#define ING_EVENT_DEBUGr_DSICMPf_SET BCM56800_A0_ING_EVENT_DEBUGr_DSICMPf_SET
#define ING_EVENT_DEBUGr_DSFRAGf_GET BCM56800_A0_ING_EVENT_DEBUGr_DSFRAGf_GET
#define ING_EVENT_DEBUGr_DSFRAGf_SET BCM56800_A0_ING_EVENT_DEBUGr_DSFRAGf_SET
#define ING_EVENT_DEBUGr_MTUERRf_GET BCM56800_A0_ING_EVENT_DEBUGr_MTUERRf_GET
#define ING_EVENT_DEBUGr_MTUERRf_SET BCM56800_A0_ING_EVENT_DEBUGr_MTUERRf_SET
#define ING_EVENT_DEBUGr_RESERVED_3f_GET BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_3f_GET
#define ING_EVENT_DEBUGr_RESERVED_3f_SET BCM56800_A0_ING_EVENT_DEBUGr_RESERVED_3f_SET
#define ING_EVENT_DEBUGr_RTUNEf_GET BCM56800_A0_ING_EVENT_DEBUGr_RTUNEf_GET
#define ING_EVENT_DEBUGr_RTUNEf_SET BCM56800_A0_ING_EVENT_DEBUGr_RTUNEf_SET
#define ING_EVENT_DEBUGr_HG_FAILOVER_PORT_DOWNf_GET BCM56800_A0_ING_EVENT_DEBUGr_HG_FAILOVER_PORT_DOWNf_GET
#define ING_EVENT_DEBUGr_HG_FAILOVER_PORT_DOWNf_SET BCM56800_A0_ING_EVENT_DEBUGr_HG_FAILOVER_PORT_DOWNf_SET
#define ING_EVENT_DEBUGr_HGHDREf_GET BCM56800_A0_ING_EVENT_DEBUGr_HGHDREf_GET
#define ING_EVENT_DEBUGr_HGHDREf_SET BCM56800_A0_ING_EVENT_DEBUGr_HGHDREf_SET
#define ING_EVENT_DEBUGr_MCIDXEf_GET BCM56800_A0_ING_EVENT_DEBUGr_MCIDXEf_GET
#define ING_EVENT_DEBUGr_MCIDXEf_SET BCM56800_A0_ING_EVENT_DEBUGr_MCIDXEf_SET
#define ING_EVENT_DEBUGr_LAGLUPf_GET BCM56800_A0_ING_EVENT_DEBUGr_LAGLUPf_GET
#define ING_EVENT_DEBUGr_LAGLUPf_SET BCM56800_A0_ING_EVENT_DEBUGr_LAGLUPf_SET
#define ING_EVENT_DEBUGr_LAGLUPDf_GET BCM56800_A0_ING_EVENT_DEBUGr_LAGLUPDf_GET
#define ING_EVENT_DEBUGr_LAGLUPDf_SET BCM56800_A0_ING_EVENT_DEBUGr_LAGLUPDf_SET
#define ING_EVENT_DEBUGr_PARITYDf_GET BCM56800_A0_ING_EVENT_DEBUGr_PARITYDf_GET
#define ING_EVENT_DEBUGr_PARITYDf_SET BCM56800_A0_ING_EVENT_DEBUGr_PARITYDf_SET
#define READ_ING_EVENT_DEBUGr BCM56800_A0_READ_ING_EVENT_DEBUGr
#define WRITE_ING_EVENT_DEBUGr BCM56800_A0_WRITE_ING_EVENT_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_EVENT_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_EVENT_DEBUG_X
 * BLOCKS:   IPIPE
 * DESC:     Ingress Events Debug Register
 * SIZE:     32
 * FIELDS:
 *     VXLT_MISS        Bit 0 - Packets dropped due to VLAN translation miss
 *     BPDU             Bit 1 - BPDU packet drop
 *     PROTOCOL_PKT     Bit 2 - Protocol packet drop
 *     CML              Bit 3 - Packets dropped due to CML
 *     SRC_ROUTE        Bit 4 - Packets dropped due to source route
 *     L2SRC_DISCARD    Bit 5 - Packets dropped due to L2 source discard
 *     L2SRC_STATIC_MOVE Bit 6 - Packets dropped due to L2 source static movement
 *     L2DST_DISCARD    Bit 7 - Packets dropped due to L2 destination discard
 *     CFI_OR_L3DISABLE Bit 8 - Packets dropped due to CFI or L3 disable
 *     HIGIG_MH_TYPE1   Bit 9 - Packets dropped due to HiGig module header type 1
 *     DISC_STAGE       Bit 10 - Packets dropped in discard stage
 *     SW1_INVALID_VLAN Bit 11 - Packets dropped due to invalid VLAN
 *     PDISC            Bit 12 - Receive policy discard counter - DST_DISCARD, SRC_DISCARD, RATE_CONTROL, etc.
 *     RFILDR           Bit 13 - Packets dropped by FP
 *     RIMDR            Bit 14 - Multicast (L2+L3) packets that are dropped
 *     RDROP            Bit 15 - Port bitmap zero drop condition
 *     RESERVED_0       Bit 16 - Reserved
 *     RESERVED_1       Bit 17 - Reserved
 *     RESERVED_2       Bit 18 - Reserved
 *     DSL3HE           Bit 19 - DOS L3 header error packets
 *     DSL4HE           Bit 20 - DOS L4 header error packets
 *     DSICMP           Bit 21 - DOS ICMP error packets
 *     DSFRAG           Bit 22 - DOS fragment error packets
 *     MTUERR           Bit 23 - Packets trapped to CPU due to egress L3 MTU violation
 *     RESERVED_3       Bit 24 - Reserved
 *     RTUNE            Bit 25 - Receive tunnel error packets
 *     HG_FAILOVER_PORT_DOWN Bit 26 - Packets dropped due to Higig failover port down
 *     HGHDRE           Bit 27 - Higig Header error packets
 *     MCIDXE           Bit 28 - Multicast Index error packets
 *     LAGLUP           Bit 29 - LAG failover loopback packets
 *     LAGLUPD          Bit 30 - LAG failover loopback packets discarded due to backup port down
 *     PARITYD          Bit 31 - Parity error packets
 *
 ******************************************************************************/
#define BCM56800_A0_ING_EVENT_DEBUG_Xr 0x0e180253

#define BCM56800_A0_ING_EVENT_DEBUG_Xr_SIZE 4

/*
 * This structure should be used to declare and program ING_EVENT_DEBUG_X.
 *
 */
typedef union BCM56800_A0_ING_EVENT_DEBUG_Xr_s {
	uint32_t v[1];
	uint32_t ing_event_debug_x[1];
	uint32_t _ing_event_debug_x;
} BCM56800_A0_ING_EVENT_DEBUG_Xr_t;

#define BCM56800_A0_ING_EVENT_DEBUG_Xr_CLR(r) (r).ing_event_debug_x[0] = 0
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_SET(r,d) (r).ing_event_debug_x[0] = d
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_GET(r) (r).ing_event_debug_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_VXLT_MISSf_GET(r) (((r).ing_event_debug_x[0]) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_VXLT_MISSf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_BPDUf_GET(r) ((((r).ing_event_debug_x[0]) >> 1) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_BPDUf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_PROTOCOL_PKTf_GET(r) ((((r).ing_event_debug_x[0]) >> 2) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_PROTOCOL_PKTf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_CMLf_GET(r) ((((r).ing_event_debug_x[0]) >> 3) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_CMLf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_SRC_ROUTEf_GET(r) ((((r).ing_event_debug_x[0]) >> 4) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_SRC_ROUTEf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_L2SRC_DISCARDf_GET(r) ((((r).ing_event_debug_x[0]) >> 5) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_L2SRC_DISCARDf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_L2SRC_STATIC_MOVEf_GET(r) ((((r).ing_event_debug_x[0]) >> 6) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_L2SRC_STATIC_MOVEf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_L2DST_DISCARDf_GET(r) ((((r).ing_event_debug_x[0]) >> 7) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_L2DST_DISCARDf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_CFI_OR_L3DISABLEf_GET(r) ((((r).ing_event_debug_x[0]) >> 8) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_CFI_OR_L3DISABLEf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_HIGIG_MH_TYPE1f_GET(r) ((((r).ing_event_debug_x[0]) >> 9) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_HIGIG_MH_TYPE1f_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DISC_STAGEf_GET(r) ((((r).ing_event_debug_x[0]) >> 10) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DISC_STAGEf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_SW1_INVALID_VLANf_GET(r) ((((r).ing_event_debug_x[0]) >> 11) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_SW1_INVALID_VLANf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_PDISCf_GET(r) ((((r).ing_event_debug_x[0]) >> 12) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_PDISCf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RFILDRf_GET(r) ((((r).ing_event_debug_x[0]) >> 13) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RFILDRf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RIMDRf_GET(r) ((((r).ing_event_debug_x[0]) >> 14) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RIMDRf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RDROPf_GET(r) ((((r).ing_event_debug_x[0]) >> 15) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RDROPf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_0f_GET(r) ((((r).ing_event_debug_x[0]) >> 16) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_0f_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_1f_GET(r) ((((r).ing_event_debug_x[0]) >> 17) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_1f_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_2f_GET(r) ((((r).ing_event_debug_x[0]) >> 18) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_2f_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DSL3HEf_GET(r) ((((r).ing_event_debug_x[0]) >> 19) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DSL3HEf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DSL4HEf_GET(r) ((((r).ing_event_debug_x[0]) >> 20) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DSL4HEf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DSICMPf_GET(r) ((((r).ing_event_debug_x[0]) >> 21) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DSICMPf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DSFRAGf_GET(r) ((((r).ing_event_debug_x[0]) >> 22) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_DSFRAGf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_MTUERRf_GET(r) ((((r).ing_event_debug_x[0]) >> 23) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_MTUERRf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_3f_GET(r) ((((r).ing_event_debug_x[0]) >> 24) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_3f_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RTUNEf_GET(r) ((((r).ing_event_debug_x[0]) >> 25) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_RTUNEf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_HG_FAILOVER_PORT_DOWNf_GET(r) ((((r).ing_event_debug_x[0]) >> 26) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_HG_FAILOVER_PORT_DOWNf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_HGHDREf_GET(r) ((((r).ing_event_debug_x[0]) >> 27) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_HGHDREf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_MCIDXEf_GET(r) ((((r).ing_event_debug_x[0]) >> 28) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_MCIDXEf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_LAGLUPf_GET(r) ((((r).ing_event_debug_x[0]) >> 29) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_LAGLUPf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_LAGLUPDf_GET(r) ((((r).ing_event_debug_x[0]) >> 30) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_LAGLUPDf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_PARITYDf_GET(r) ((((r).ing_event_debug_x[0]) >> 31) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Xr_PARITYDf_SET(r,f) (r).ing_event_debug_x[0]=(((r).ing_event_debug_x[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ING_EVENT_DEBUG_X.
 *
 */
#define BCM56800_A0_READ_ING_EVENT_DEBUG_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_EVENT_DEBUG_Xr,(r._ing_event_debug_x))
#define BCM56800_A0_WRITE_ING_EVENT_DEBUG_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_EVENT_DEBUG_Xr,&(r._ing_event_debug_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EVENT_DEBUG_Xr BCM56800_A0_ING_EVENT_DEBUG_Xr
#define ING_EVENT_DEBUG_Xr_SIZE BCM56800_A0_ING_EVENT_DEBUG_Xr_SIZE
typedef BCM56800_A0_ING_EVENT_DEBUG_Xr_t ING_EVENT_DEBUG_Xr_t;
#define ING_EVENT_DEBUG_Xr_CLR BCM56800_A0_ING_EVENT_DEBUG_Xr_CLR
#define ING_EVENT_DEBUG_Xr_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_SET
#define ING_EVENT_DEBUG_Xr_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_GET
#define ING_EVENT_DEBUG_Xr_VXLT_MISSf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_VXLT_MISSf_GET
#define ING_EVENT_DEBUG_Xr_VXLT_MISSf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_VXLT_MISSf_SET
#define ING_EVENT_DEBUG_Xr_BPDUf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_BPDUf_GET
#define ING_EVENT_DEBUG_Xr_BPDUf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_BPDUf_SET
#define ING_EVENT_DEBUG_Xr_PROTOCOL_PKTf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_PROTOCOL_PKTf_GET
#define ING_EVENT_DEBUG_Xr_PROTOCOL_PKTf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_PROTOCOL_PKTf_SET
#define ING_EVENT_DEBUG_Xr_CMLf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_CMLf_GET
#define ING_EVENT_DEBUG_Xr_CMLf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_CMLf_SET
#define ING_EVENT_DEBUG_Xr_SRC_ROUTEf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_SRC_ROUTEf_GET
#define ING_EVENT_DEBUG_Xr_SRC_ROUTEf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_SRC_ROUTEf_SET
#define ING_EVENT_DEBUG_Xr_L2SRC_DISCARDf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_L2SRC_DISCARDf_GET
#define ING_EVENT_DEBUG_Xr_L2SRC_DISCARDf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_L2SRC_DISCARDf_SET
#define ING_EVENT_DEBUG_Xr_L2SRC_STATIC_MOVEf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_L2SRC_STATIC_MOVEf_GET
#define ING_EVENT_DEBUG_Xr_L2SRC_STATIC_MOVEf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_L2SRC_STATIC_MOVEf_SET
#define ING_EVENT_DEBUG_Xr_L2DST_DISCARDf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_L2DST_DISCARDf_GET
#define ING_EVENT_DEBUG_Xr_L2DST_DISCARDf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_L2DST_DISCARDf_SET
#define ING_EVENT_DEBUG_Xr_CFI_OR_L3DISABLEf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_CFI_OR_L3DISABLEf_GET
#define ING_EVENT_DEBUG_Xr_CFI_OR_L3DISABLEf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_CFI_OR_L3DISABLEf_SET
#define ING_EVENT_DEBUG_Xr_HIGIG_MH_TYPE1f_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_HIGIG_MH_TYPE1f_GET
#define ING_EVENT_DEBUG_Xr_HIGIG_MH_TYPE1f_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_HIGIG_MH_TYPE1f_SET
#define ING_EVENT_DEBUG_Xr_DISC_STAGEf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_DISC_STAGEf_GET
#define ING_EVENT_DEBUG_Xr_DISC_STAGEf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_DISC_STAGEf_SET
#define ING_EVENT_DEBUG_Xr_SW1_INVALID_VLANf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_SW1_INVALID_VLANf_GET
#define ING_EVENT_DEBUG_Xr_SW1_INVALID_VLANf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_SW1_INVALID_VLANf_SET
#define ING_EVENT_DEBUG_Xr_PDISCf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_PDISCf_GET
#define ING_EVENT_DEBUG_Xr_PDISCf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_PDISCf_SET
#define ING_EVENT_DEBUG_Xr_RFILDRf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_RFILDRf_GET
#define ING_EVENT_DEBUG_Xr_RFILDRf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_RFILDRf_SET
#define ING_EVENT_DEBUG_Xr_RIMDRf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_RIMDRf_GET
#define ING_EVENT_DEBUG_Xr_RIMDRf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_RIMDRf_SET
#define ING_EVENT_DEBUG_Xr_RDROPf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_RDROPf_GET
#define ING_EVENT_DEBUG_Xr_RDROPf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_RDROPf_SET
#define ING_EVENT_DEBUG_Xr_RESERVED_0f_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_0f_GET
#define ING_EVENT_DEBUG_Xr_RESERVED_0f_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_0f_SET
#define ING_EVENT_DEBUG_Xr_RESERVED_1f_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_1f_GET
#define ING_EVENT_DEBUG_Xr_RESERVED_1f_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_1f_SET
#define ING_EVENT_DEBUG_Xr_RESERVED_2f_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_2f_GET
#define ING_EVENT_DEBUG_Xr_RESERVED_2f_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_2f_SET
#define ING_EVENT_DEBUG_Xr_DSL3HEf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_DSL3HEf_GET
#define ING_EVENT_DEBUG_Xr_DSL3HEf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_DSL3HEf_SET
#define ING_EVENT_DEBUG_Xr_DSL4HEf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_DSL4HEf_GET
#define ING_EVENT_DEBUG_Xr_DSL4HEf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_DSL4HEf_SET
#define ING_EVENT_DEBUG_Xr_DSICMPf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_DSICMPf_GET
#define ING_EVENT_DEBUG_Xr_DSICMPf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_DSICMPf_SET
#define ING_EVENT_DEBUG_Xr_DSFRAGf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_DSFRAGf_GET
#define ING_EVENT_DEBUG_Xr_DSFRAGf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_DSFRAGf_SET
#define ING_EVENT_DEBUG_Xr_MTUERRf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_MTUERRf_GET
#define ING_EVENT_DEBUG_Xr_MTUERRf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_MTUERRf_SET
#define ING_EVENT_DEBUG_Xr_RESERVED_3f_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_3f_GET
#define ING_EVENT_DEBUG_Xr_RESERVED_3f_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_RESERVED_3f_SET
#define ING_EVENT_DEBUG_Xr_RTUNEf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_RTUNEf_GET
#define ING_EVENT_DEBUG_Xr_RTUNEf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_RTUNEf_SET
#define ING_EVENT_DEBUG_Xr_HG_FAILOVER_PORT_DOWNf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_HG_FAILOVER_PORT_DOWNf_GET
#define ING_EVENT_DEBUG_Xr_HG_FAILOVER_PORT_DOWNf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_HG_FAILOVER_PORT_DOWNf_SET
#define ING_EVENT_DEBUG_Xr_HGHDREf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_HGHDREf_GET
#define ING_EVENT_DEBUG_Xr_HGHDREf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_HGHDREf_SET
#define ING_EVENT_DEBUG_Xr_MCIDXEf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_MCIDXEf_GET
#define ING_EVENT_DEBUG_Xr_MCIDXEf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_MCIDXEf_SET
#define ING_EVENT_DEBUG_Xr_LAGLUPf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_LAGLUPf_GET
#define ING_EVENT_DEBUG_Xr_LAGLUPf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_LAGLUPf_SET
#define ING_EVENT_DEBUG_Xr_LAGLUPDf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_LAGLUPDf_GET
#define ING_EVENT_DEBUG_Xr_LAGLUPDf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_LAGLUPDf_SET
#define ING_EVENT_DEBUG_Xr_PARITYDf_GET BCM56800_A0_ING_EVENT_DEBUG_Xr_PARITYDf_GET
#define ING_EVENT_DEBUG_Xr_PARITYDf_SET BCM56800_A0_ING_EVENT_DEBUG_Xr_PARITYDf_SET
#define READ_ING_EVENT_DEBUG_Xr BCM56800_A0_READ_ING_EVENT_DEBUG_Xr
#define WRITE_ING_EVENT_DEBUG_Xr BCM56800_A0_WRITE_ING_EVENT_DEBUG_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_EVENT_DEBUG_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_EVENT_DEBUG_Y
 * BLOCKS:   IPIPE
 * DESC:     Ingress Events Debug Register
 * SIZE:     32
 * FIELDS:
 *     VXLT_MISS        Bit 0 - Packets dropped due to VLAN translation miss
 *     BPDU             Bit 1 - BPDU packet drop
 *     PROTOCOL_PKT     Bit 2 - Protocol packet drop
 *     CML              Bit 3 - Packets dropped due to CML
 *     SRC_ROUTE        Bit 4 - Packets dropped due to source route
 *     L2SRC_DISCARD    Bit 5 - Packets dropped due to L2 source discard
 *     L2SRC_STATIC_MOVE Bit 6 - Packets dropped due to L2 source static movement
 *     L2DST_DISCARD    Bit 7 - Packets dropped due to L2 destination discard
 *     CFI_OR_L3DISABLE Bit 8 - Packets dropped due to CFI or L3 disable
 *     HIGIG_MH_TYPE1   Bit 9 - Packets dropped due to HiGig module header type 1
 *     DISC_STAGE       Bit 10 - Packets dropped in discard stage
 *     SW1_INVALID_VLAN Bit 11 - Packets dropped due to invalid VLAN
 *     PDISC            Bit 12 - Receive policy discard counter - DST_DISCARD, SRC_DISCARD, RATE_CONTROL, etc.
 *     RFILDR           Bit 13 - Packets dropped by FP
 *     RIMDR            Bit 14 - Multicast (L2+L3) packets that are dropped
 *     RDROP            Bit 15 - Port bitmap zero drop condition
 *     RESERVED_0       Bit 16 - Reserved
 *     RESERVED_1       Bit 17 - Reserved
 *     RESERVED_2       Bit 18 - Reserved
 *     DSL3HE           Bit 19 - DOS L3 header error packets
 *     DSL4HE           Bit 20 - DOS L4 header error packets
 *     DSICMP           Bit 21 - DOS ICMP error packets
 *     DSFRAG           Bit 22 - DOS fragment error packets
 *     MTUERR           Bit 23 - Packets trapped to CPU due to egress L3 MTU violation
 *     RESERVED_3       Bit 24 - Reserved
 *     RTUNE            Bit 25 - Receive tunnel error packets
 *     HG_FAILOVER_PORT_DOWN Bit 26 - Packets dropped due to Higig failover port down
 *     HGHDRE           Bit 27 - Higig Header error packets
 *     MCIDXE           Bit 28 - Multicast Index error packets
 *     LAGLUP           Bit 29 - LAG failover loopback packets
 *     LAGLUPD          Bit 30 - LAG failover loopback packets discarded due to backup port down
 *     PARITYD          Bit 31 - Parity error packets
 *
 ******************************************************************************/
#define BCM56800_A0_ING_EVENT_DEBUG_Yr 0x0e180453

#define BCM56800_A0_ING_EVENT_DEBUG_Yr_SIZE 4

/*
 * This structure should be used to declare and program ING_EVENT_DEBUG_Y.
 *
 */
typedef union BCM56800_A0_ING_EVENT_DEBUG_Yr_s {
	uint32_t v[1];
	uint32_t ing_event_debug_y[1];
	uint32_t _ing_event_debug_y;
} BCM56800_A0_ING_EVENT_DEBUG_Yr_t;

#define BCM56800_A0_ING_EVENT_DEBUG_Yr_CLR(r) (r).ing_event_debug_y[0] = 0
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_SET(r,d) (r).ing_event_debug_y[0] = d
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_GET(r) (r).ing_event_debug_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_VXLT_MISSf_GET(r) (((r).ing_event_debug_y[0]) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_VXLT_MISSf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_BPDUf_GET(r) ((((r).ing_event_debug_y[0]) >> 1) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_BPDUf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_PROTOCOL_PKTf_GET(r) ((((r).ing_event_debug_y[0]) >> 2) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_PROTOCOL_PKTf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_CMLf_GET(r) ((((r).ing_event_debug_y[0]) >> 3) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_CMLf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_SRC_ROUTEf_GET(r) ((((r).ing_event_debug_y[0]) >> 4) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_SRC_ROUTEf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_L2SRC_DISCARDf_GET(r) ((((r).ing_event_debug_y[0]) >> 5) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_L2SRC_DISCARDf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_L2SRC_STATIC_MOVEf_GET(r) ((((r).ing_event_debug_y[0]) >> 6) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_L2SRC_STATIC_MOVEf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_L2DST_DISCARDf_GET(r) ((((r).ing_event_debug_y[0]) >> 7) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_L2DST_DISCARDf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_CFI_OR_L3DISABLEf_GET(r) ((((r).ing_event_debug_y[0]) >> 8) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_CFI_OR_L3DISABLEf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_HIGIG_MH_TYPE1f_GET(r) ((((r).ing_event_debug_y[0]) >> 9) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_HIGIG_MH_TYPE1f_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DISC_STAGEf_GET(r) ((((r).ing_event_debug_y[0]) >> 10) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DISC_STAGEf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_SW1_INVALID_VLANf_GET(r) ((((r).ing_event_debug_y[0]) >> 11) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_SW1_INVALID_VLANf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_PDISCf_GET(r) ((((r).ing_event_debug_y[0]) >> 12) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_PDISCf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RFILDRf_GET(r) ((((r).ing_event_debug_y[0]) >> 13) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RFILDRf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RIMDRf_GET(r) ((((r).ing_event_debug_y[0]) >> 14) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RIMDRf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RDROPf_GET(r) ((((r).ing_event_debug_y[0]) >> 15) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RDROPf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_0f_GET(r) ((((r).ing_event_debug_y[0]) >> 16) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_0f_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_1f_GET(r) ((((r).ing_event_debug_y[0]) >> 17) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_1f_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_2f_GET(r) ((((r).ing_event_debug_y[0]) >> 18) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_2f_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DSL3HEf_GET(r) ((((r).ing_event_debug_y[0]) >> 19) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DSL3HEf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DSL4HEf_GET(r) ((((r).ing_event_debug_y[0]) >> 20) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DSL4HEf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DSICMPf_GET(r) ((((r).ing_event_debug_y[0]) >> 21) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DSICMPf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DSFRAGf_GET(r) ((((r).ing_event_debug_y[0]) >> 22) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_DSFRAGf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_MTUERRf_GET(r) ((((r).ing_event_debug_y[0]) >> 23) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_MTUERRf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_3f_GET(r) ((((r).ing_event_debug_y[0]) >> 24) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_3f_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RTUNEf_GET(r) ((((r).ing_event_debug_y[0]) >> 25) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_RTUNEf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_HG_FAILOVER_PORT_DOWNf_GET(r) ((((r).ing_event_debug_y[0]) >> 26) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_HG_FAILOVER_PORT_DOWNf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_HGHDREf_GET(r) ((((r).ing_event_debug_y[0]) >> 27) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_HGHDREf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_MCIDXEf_GET(r) ((((r).ing_event_debug_y[0]) >> 28) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_MCIDXEf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_LAGLUPf_GET(r) ((((r).ing_event_debug_y[0]) >> 29) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_LAGLUPf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_LAGLUPDf_GET(r) ((((r).ing_event_debug_y[0]) >> 30) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_LAGLUPDf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_PARITYDf_GET(r) ((((r).ing_event_debug_y[0]) >> 31) & 0x1)
#define BCM56800_A0_ING_EVENT_DEBUG_Yr_PARITYDf_SET(r,f) (r).ing_event_debug_y[0]=(((r).ing_event_debug_y[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access ING_EVENT_DEBUG_Y.
 *
 */
#define BCM56800_A0_READ_ING_EVENT_DEBUG_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_EVENT_DEBUG_Yr,(r._ing_event_debug_y))
#define BCM56800_A0_WRITE_ING_EVENT_DEBUG_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_EVENT_DEBUG_Yr,&(r._ing_event_debug_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_EVENT_DEBUG_Yr BCM56800_A0_ING_EVENT_DEBUG_Yr
#define ING_EVENT_DEBUG_Yr_SIZE BCM56800_A0_ING_EVENT_DEBUG_Yr_SIZE
typedef BCM56800_A0_ING_EVENT_DEBUG_Yr_t ING_EVENT_DEBUG_Yr_t;
#define ING_EVENT_DEBUG_Yr_CLR BCM56800_A0_ING_EVENT_DEBUG_Yr_CLR
#define ING_EVENT_DEBUG_Yr_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_SET
#define ING_EVENT_DEBUG_Yr_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_GET
#define ING_EVENT_DEBUG_Yr_VXLT_MISSf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_VXLT_MISSf_GET
#define ING_EVENT_DEBUG_Yr_VXLT_MISSf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_VXLT_MISSf_SET
#define ING_EVENT_DEBUG_Yr_BPDUf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_BPDUf_GET
#define ING_EVENT_DEBUG_Yr_BPDUf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_BPDUf_SET
#define ING_EVENT_DEBUG_Yr_PROTOCOL_PKTf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_PROTOCOL_PKTf_GET
#define ING_EVENT_DEBUG_Yr_PROTOCOL_PKTf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_PROTOCOL_PKTf_SET
#define ING_EVENT_DEBUG_Yr_CMLf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_CMLf_GET
#define ING_EVENT_DEBUG_Yr_CMLf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_CMLf_SET
#define ING_EVENT_DEBUG_Yr_SRC_ROUTEf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_SRC_ROUTEf_GET
#define ING_EVENT_DEBUG_Yr_SRC_ROUTEf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_SRC_ROUTEf_SET
#define ING_EVENT_DEBUG_Yr_L2SRC_DISCARDf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_L2SRC_DISCARDf_GET
#define ING_EVENT_DEBUG_Yr_L2SRC_DISCARDf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_L2SRC_DISCARDf_SET
#define ING_EVENT_DEBUG_Yr_L2SRC_STATIC_MOVEf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_L2SRC_STATIC_MOVEf_GET
#define ING_EVENT_DEBUG_Yr_L2SRC_STATIC_MOVEf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_L2SRC_STATIC_MOVEf_SET
#define ING_EVENT_DEBUG_Yr_L2DST_DISCARDf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_L2DST_DISCARDf_GET
#define ING_EVENT_DEBUG_Yr_L2DST_DISCARDf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_L2DST_DISCARDf_SET
#define ING_EVENT_DEBUG_Yr_CFI_OR_L3DISABLEf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_CFI_OR_L3DISABLEf_GET
#define ING_EVENT_DEBUG_Yr_CFI_OR_L3DISABLEf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_CFI_OR_L3DISABLEf_SET
#define ING_EVENT_DEBUG_Yr_HIGIG_MH_TYPE1f_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_HIGIG_MH_TYPE1f_GET
#define ING_EVENT_DEBUG_Yr_HIGIG_MH_TYPE1f_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_HIGIG_MH_TYPE1f_SET
#define ING_EVENT_DEBUG_Yr_DISC_STAGEf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_DISC_STAGEf_GET
#define ING_EVENT_DEBUG_Yr_DISC_STAGEf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_DISC_STAGEf_SET
#define ING_EVENT_DEBUG_Yr_SW1_INVALID_VLANf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_SW1_INVALID_VLANf_GET
#define ING_EVENT_DEBUG_Yr_SW1_INVALID_VLANf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_SW1_INVALID_VLANf_SET
#define ING_EVENT_DEBUG_Yr_PDISCf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_PDISCf_GET
#define ING_EVENT_DEBUG_Yr_PDISCf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_PDISCf_SET
#define ING_EVENT_DEBUG_Yr_RFILDRf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_RFILDRf_GET
#define ING_EVENT_DEBUG_Yr_RFILDRf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_RFILDRf_SET
#define ING_EVENT_DEBUG_Yr_RIMDRf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_RIMDRf_GET
#define ING_EVENT_DEBUG_Yr_RIMDRf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_RIMDRf_SET
#define ING_EVENT_DEBUG_Yr_RDROPf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_RDROPf_GET
#define ING_EVENT_DEBUG_Yr_RDROPf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_RDROPf_SET
#define ING_EVENT_DEBUG_Yr_RESERVED_0f_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_0f_GET
#define ING_EVENT_DEBUG_Yr_RESERVED_0f_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_0f_SET
#define ING_EVENT_DEBUG_Yr_RESERVED_1f_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_1f_GET
#define ING_EVENT_DEBUG_Yr_RESERVED_1f_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_1f_SET
#define ING_EVENT_DEBUG_Yr_RESERVED_2f_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_2f_GET
#define ING_EVENT_DEBUG_Yr_RESERVED_2f_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_2f_SET
#define ING_EVENT_DEBUG_Yr_DSL3HEf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_DSL3HEf_GET
#define ING_EVENT_DEBUG_Yr_DSL3HEf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_DSL3HEf_SET
#define ING_EVENT_DEBUG_Yr_DSL4HEf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_DSL4HEf_GET
#define ING_EVENT_DEBUG_Yr_DSL4HEf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_DSL4HEf_SET
#define ING_EVENT_DEBUG_Yr_DSICMPf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_DSICMPf_GET
#define ING_EVENT_DEBUG_Yr_DSICMPf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_DSICMPf_SET
#define ING_EVENT_DEBUG_Yr_DSFRAGf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_DSFRAGf_GET
#define ING_EVENT_DEBUG_Yr_DSFRAGf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_DSFRAGf_SET
#define ING_EVENT_DEBUG_Yr_MTUERRf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_MTUERRf_GET
#define ING_EVENT_DEBUG_Yr_MTUERRf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_MTUERRf_SET
#define ING_EVENT_DEBUG_Yr_RESERVED_3f_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_3f_GET
#define ING_EVENT_DEBUG_Yr_RESERVED_3f_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_RESERVED_3f_SET
#define ING_EVENT_DEBUG_Yr_RTUNEf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_RTUNEf_GET
#define ING_EVENT_DEBUG_Yr_RTUNEf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_RTUNEf_SET
#define ING_EVENT_DEBUG_Yr_HG_FAILOVER_PORT_DOWNf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_HG_FAILOVER_PORT_DOWNf_GET
#define ING_EVENT_DEBUG_Yr_HG_FAILOVER_PORT_DOWNf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_HG_FAILOVER_PORT_DOWNf_SET
#define ING_EVENT_DEBUG_Yr_HGHDREf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_HGHDREf_GET
#define ING_EVENT_DEBUG_Yr_HGHDREf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_HGHDREf_SET
#define ING_EVENT_DEBUG_Yr_MCIDXEf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_MCIDXEf_GET
#define ING_EVENT_DEBUG_Yr_MCIDXEf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_MCIDXEf_SET
#define ING_EVENT_DEBUG_Yr_LAGLUPf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_LAGLUPf_GET
#define ING_EVENT_DEBUG_Yr_LAGLUPf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_LAGLUPf_SET
#define ING_EVENT_DEBUG_Yr_LAGLUPDf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_LAGLUPDf_GET
#define ING_EVENT_DEBUG_Yr_LAGLUPDf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_LAGLUPDf_SET
#define ING_EVENT_DEBUG_Yr_PARITYDf_GET BCM56800_A0_ING_EVENT_DEBUG_Yr_PARITYDf_GET
#define ING_EVENT_DEBUG_Yr_PARITYDf_SET BCM56800_A0_ING_EVENT_DEBUG_Yr_PARITYDf_SET
#define READ_ING_EVENT_DEBUG_Yr BCM56800_A0_READ_ING_EVENT_DEBUG_Yr
#define WRITE_ING_EVENT_DEBUG_Yr BCM56800_A0_WRITE_ING_EVENT_DEBUG_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_EVENT_DEBUG_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_HW_RESET_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #1
 * SIZE:     32
 * FIELDS:
 *     STAGE_NUMBER     IP stage for the memory table
 *     OFFSET           20-bit starting offset of table for memory
 *
 ******************************************************************************/
#define BCM56800_A0_ING_HW_RESET_CONTROL_1r 0x00180602

#define BCM56800_A0_ING_HW_RESET_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_1.
 *
 */
typedef union BCM56800_A0_ING_HW_RESET_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_1[1];
	uint32_t _ing_hw_reset_control_1;
} BCM56800_A0_ING_HW_RESET_CONTROL_1r_t;

#define BCM56800_A0_ING_HW_RESET_CONTROL_1r_CLR(r) (r).ing_hw_reset_control_1[0] = 0
#define BCM56800_A0_ING_HW_RESET_CONTROL_1r_SET(r,d) (r).ing_hw_reset_control_1[0] = d
#define BCM56800_A0_ING_HW_RESET_CONTROL_1r_GET(r) (r).ing_hw_reset_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET(r) (((r).ing_hw_reset_control_1[0]) & 0x3f)
#define BCM56800_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_GET(r) ((((r).ing_hw_reset_control_1[0]) >> 6) & 0xfffff)
#define BCM56800_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_SET(r,f) (r).ing_hw_reset_control_1[0]=(((r).ing_hw_reset_control_1[0] & ~((uint32_t)0xfffff << 6)) | ((((uint32_t)f) & 0xfffff) << 6))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_ING_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_HW_RESET_CONTROL_1r,(r._ing_hw_reset_control_1))
#define BCM56800_A0_WRITE_ING_HW_RESET_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_HW_RESET_CONTROL_1r,&(r._ing_hw_reset_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_1r BCM56800_A0_ING_HW_RESET_CONTROL_1r
#define ING_HW_RESET_CONTROL_1r_SIZE BCM56800_A0_ING_HW_RESET_CONTROL_1r_SIZE
typedef BCM56800_A0_ING_HW_RESET_CONTROL_1r_t ING_HW_RESET_CONTROL_1r_t;
#define ING_HW_RESET_CONTROL_1r_CLR BCM56800_A0_ING_HW_RESET_CONTROL_1r_CLR
#define ING_HW_RESET_CONTROL_1r_SET BCM56800_A0_ING_HW_RESET_CONTROL_1r_SET
#define ING_HW_RESET_CONTROL_1r_GET BCM56800_A0_ING_HW_RESET_CONTROL_1r_GET
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET BCM56800_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_GET
#define ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET BCM56800_A0_ING_HW_RESET_CONTROL_1r_STAGE_NUMBERf_SET
#define ING_HW_RESET_CONTROL_1r_OFFSETf_GET BCM56800_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_GET
#define ING_HW_RESET_CONTROL_1r_OFFSETf_SET BCM56800_A0_ING_HW_RESET_CONTROL_1r_OFFSETf_SET
#define READ_ING_HW_RESET_CONTROL_1r BCM56800_A0_READ_ING_HW_RESET_CONTROL_1r
#define WRITE_ING_HW_RESET_CONTROL_1r BCM56800_A0_WRITE_ING_HW_RESET_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_HW_RESET_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_HW_RESET_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #2
 * SIZE:     32
 * FIELDS:
 *     COUNT            Number of entries of memory to initialize
 *     RESET_ALL        Indicates all memories in all stages should be initialized (independent of stage or table number)
 *     VALID            Set by software to trigger memory initialization
 *     DONE             Set by arbiter to indicate memory table writes have completed on pipeline
 *
 ******************************************************************************/
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r 0x00180603

#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_2.
 *
 */
typedef union BCM56800_A0_ING_HW_RESET_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_2[1];
	uint32_t _ing_hw_reset_control_2;
} BCM56800_A0_ING_HW_RESET_CONTROL_2r_t;

#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_CLR(r) (r).ing_hw_reset_control_2[0] = 0
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_SET(r,d) (r).ing_hw_reset_control_2[0] = d
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_GET(r) (r).ing_hw_reset_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_COUNTf_GET(r) (((r).ing_hw_reset_control_2[0]) & 0xffff)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_COUNTf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 16) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_VALIDf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 17) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_VALIDf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_DONEf_GET(r) ((((r).ing_hw_reset_control_2[0]) >> 18) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2r_DONEf_SET(r,f) (r).ing_hw_reset_control_2[0]=(((r).ing_hw_reset_control_2[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_ING_HW_RESET_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_HW_RESET_CONTROL_2r,(r._ing_hw_reset_control_2))
#define BCM56800_A0_WRITE_ING_HW_RESET_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_HW_RESET_CONTROL_2r,&(r._ing_hw_reset_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_2r BCM56800_A0_ING_HW_RESET_CONTROL_2r
#define ING_HW_RESET_CONTROL_2r_SIZE BCM56800_A0_ING_HW_RESET_CONTROL_2r_SIZE
typedef BCM56800_A0_ING_HW_RESET_CONTROL_2r_t ING_HW_RESET_CONTROL_2r_t;
#define ING_HW_RESET_CONTROL_2r_CLR BCM56800_A0_ING_HW_RESET_CONTROL_2r_CLR
#define ING_HW_RESET_CONTROL_2r_SET BCM56800_A0_ING_HW_RESET_CONTROL_2r_SET
#define ING_HW_RESET_CONTROL_2r_GET BCM56800_A0_ING_HW_RESET_CONTROL_2r_GET
#define ING_HW_RESET_CONTROL_2r_COUNTf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2r_COUNTf_GET
#define ING_HW_RESET_CONTROL_2r_COUNTf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2r_COUNTf_SET
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_GET
#define ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2r_RESET_ALLf_SET
#define ING_HW_RESET_CONTROL_2r_VALIDf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2r_VALIDf_GET
#define ING_HW_RESET_CONTROL_2r_VALIDf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2r_VALIDf_SET
#define ING_HW_RESET_CONTROL_2r_DONEf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2r_DONEf_GET
#define ING_HW_RESET_CONTROL_2r_DONEf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2r_DONEf_SET
#define READ_ING_HW_RESET_CONTROL_2r BCM56800_A0_READ_ING_HW_RESET_CONTROL_2r
#define WRITE_ING_HW_RESET_CONTROL_2r BCM56800_A0_WRITE_ING_HW_RESET_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_HW_RESET_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_HW_RESET_CONTROL_2_X
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #2
 * SIZE:     32
 * FIELDS:
 *     COUNT            Number of entries of memory to initialize
 *     RESET_ALL        Indicates all memories in all stages should be initialized (independent of stage or table number)
 *     VALID            Set by software to trigger memory initialization
 *     DONE             Set by arbiter to indicate memory table writes have completed on pipeline
 *
 ******************************************************************************/
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr 0x00180203

#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_2_X.
 *
 */
typedef union BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_2_x[1];
	uint32_t _ing_hw_reset_control_2_x;
} BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_t;

#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_CLR(r) (r).ing_hw_reset_control_2_x[0] = 0
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_SET(r,d) (r).ing_hw_reset_control_2_x[0] = d
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_GET(r) (r).ing_hw_reset_control_2_x[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_COUNTf_GET(r) (((r).ing_hw_reset_control_2_x[0]) & 0xffff)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_COUNTf_SET(r,f) (r).ing_hw_reset_control_2_x[0]=(((r).ing_hw_reset_control_2_x[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_RESET_ALLf_GET(r) ((((r).ing_hw_reset_control_2_x[0]) >> 16) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_RESET_ALLf_SET(r,f) (r).ing_hw_reset_control_2_x[0]=(((r).ing_hw_reset_control_2_x[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_VALIDf_GET(r) ((((r).ing_hw_reset_control_2_x[0]) >> 17) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_VALIDf_SET(r,f) (r).ing_hw_reset_control_2_x[0]=(((r).ing_hw_reset_control_2_x[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_DONEf_GET(r) ((((r).ing_hw_reset_control_2_x[0]) >> 18) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_DONEf_SET(r,f) (r).ing_hw_reset_control_2_x[0]=(((r).ing_hw_reset_control_2_x[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_2_X.
 *
 */
#define BCM56800_A0_READ_ING_HW_RESET_CONTROL_2_Xr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr,(r._ing_hw_reset_control_2_x))
#define BCM56800_A0_WRITE_ING_HW_RESET_CONTROL_2_Xr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr,&(r._ing_hw_reset_control_2_x))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_2_Xr BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr
#define ING_HW_RESET_CONTROL_2_Xr_SIZE BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_SIZE
typedef BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_t ING_HW_RESET_CONTROL_2_Xr_t;
#define ING_HW_RESET_CONTROL_2_Xr_CLR BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_CLR
#define ING_HW_RESET_CONTROL_2_Xr_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_SET
#define ING_HW_RESET_CONTROL_2_Xr_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_GET
#define ING_HW_RESET_CONTROL_2_Xr_COUNTf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_COUNTf_GET
#define ING_HW_RESET_CONTROL_2_Xr_COUNTf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_COUNTf_SET
#define ING_HW_RESET_CONTROL_2_Xr_RESET_ALLf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_RESET_ALLf_GET
#define ING_HW_RESET_CONTROL_2_Xr_RESET_ALLf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_RESET_ALLf_SET
#define ING_HW_RESET_CONTROL_2_Xr_VALIDf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_VALIDf_GET
#define ING_HW_RESET_CONTROL_2_Xr_VALIDf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_VALIDf_SET
#define ING_HW_RESET_CONTROL_2_Xr_DONEf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_DONEf_GET
#define ING_HW_RESET_CONTROL_2_Xr_DONEf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr_DONEf_SET
#define READ_ING_HW_RESET_CONTROL_2_Xr BCM56800_A0_READ_ING_HW_RESET_CONTROL_2_Xr
#define WRITE_ING_HW_RESET_CONTROL_2_Xr BCM56800_A0_WRITE_ING_HW_RESET_CONTROL_2_Xr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_HW_RESET_CONTROL_2_Xr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_HW_RESET_CONTROL_2_Y
 * BLOCKS:   IPIPE
 * DESC:     Ingress Pipeline memory hardware initialization register #2
 * SIZE:     32
 * FIELDS:
 *     COUNT            Number of entries of memory to initialize
 *     RESET_ALL        Indicates all memories in all stages should be initialized (independent of stage or table number)
 *     VALID            Set by software to trigger memory initialization
 *     DONE             Set by arbiter to indicate memory table writes have completed on pipeline
 *
 ******************************************************************************/
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr 0x00180403

#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_SIZE 4

/*
 * This structure should be used to declare and program ING_HW_RESET_CONTROL_2_Y.
 *
 */
typedef union BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_s {
	uint32_t v[1];
	uint32_t ing_hw_reset_control_2_y[1];
	uint32_t _ing_hw_reset_control_2_y;
} BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_t;

#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_CLR(r) (r).ing_hw_reset_control_2_y[0] = 0
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_SET(r,d) (r).ing_hw_reset_control_2_y[0] = d
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_GET(r) (r).ing_hw_reset_control_2_y[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_COUNTf_GET(r) (((r).ing_hw_reset_control_2_y[0]) & 0xffff)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_COUNTf_SET(r,f) (r).ing_hw_reset_control_2_y[0]=(((r).ing_hw_reset_control_2_y[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_RESET_ALLf_GET(r) ((((r).ing_hw_reset_control_2_y[0]) >> 16) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_RESET_ALLf_SET(r,f) (r).ing_hw_reset_control_2_y[0]=(((r).ing_hw_reset_control_2_y[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_VALIDf_GET(r) ((((r).ing_hw_reset_control_2_y[0]) >> 17) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_VALIDf_SET(r,f) (r).ing_hw_reset_control_2_y[0]=(((r).ing_hw_reset_control_2_y[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_DONEf_GET(r) ((((r).ing_hw_reset_control_2_y[0]) >> 18) & 0x1)
#define BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_DONEf_SET(r,f) (r).ing_hw_reset_control_2_y[0]=(((r).ing_hw_reset_control_2_y[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))

/*
 * These macros can be used to access ING_HW_RESET_CONTROL_2_Y.
 *
 */
#define BCM56800_A0_READ_ING_HW_RESET_CONTROL_2_Yr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr,(r._ing_hw_reset_control_2_y))
#define BCM56800_A0_WRITE_ING_HW_RESET_CONTROL_2_Yr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr,&(r._ing_hw_reset_control_2_y))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_HW_RESET_CONTROL_2_Yr BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr
#define ING_HW_RESET_CONTROL_2_Yr_SIZE BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_SIZE
typedef BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_t ING_HW_RESET_CONTROL_2_Yr_t;
#define ING_HW_RESET_CONTROL_2_Yr_CLR BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_CLR
#define ING_HW_RESET_CONTROL_2_Yr_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_SET
#define ING_HW_RESET_CONTROL_2_Yr_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_GET
#define ING_HW_RESET_CONTROL_2_Yr_COUNTf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_COUNTf_GET
#define ING_HW_RESET_CONTROL_2_Yr_COUNTf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_COUNTf_SET
#define ING_HW_RESET_CONTROL_2_Yr_RESET_ALLf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_RESET_ALLf_GET
#define ING_HW_RESET_CONTROL_2_Yr_RESET_ALLf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_RESET_ALLf_SET
#define ING_HW_RESET_CONTROL_2_Yr_VALIDf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_VALIDf_GET
#define ING_HW_RESET_CONTROL_2_Yr_VALIDf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_VALIDf_SET
#define ING_HW_RESET_CONTROL_2_Yr_DONEf_GET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_DONEf_GET
#define ING_HW_RESET_CONTROL_2_Yr_DONEf_SET BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr_DONEf_SET
#define READ_ING_HW_RESET_CONTROL_2_Yr BCM56800_A0_READ_ING_HW_RESET_CONTROL_2_Yr
#define WRITE_ING_HW_RESET_CONTROL_2_Yr BCM56800_A0_WRITE_ING_HW_RESET_CONTROL_2_Yr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_HW_RESET_CONTROL_2_Yr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_IPMC_PTR_CTRL
 * BLOCKS:   IPIPE
 * DESC:     IPMC Index Control Register
 * SIZE:     32
 * FIELDS:
 *     LOWER_LIMIT      IPMC Index Low Marker.
 *     UPPER_LIMIT      IPMC Index High Marker
 *     ENABLE           IPMC Index Increment Mode Enable bit is controlling IPMC index increment featurefor all ipmc replicated packet transmit to Higig port. IPMC index need to bewithin the reange defined by IPMCIdxHighMarker and IPMCIdxLowMarker. New IPMCIndex send will be the original IPMC Index added with replicated packet number.Ex. First packet, New IPMC Index = Original IPMC Index + 1;    Second packet, New IPMC Index = Original IPMC Index + 2;    ....    n-th packet, New IPMC Index = Original IPMC Index + n;1: IPMC Index Increment Mode En.0: IPMC Index Increment Mode Disable.
 *
 ******************************************************************************/
#define BCM56800_A0_ING_IPMC_PTR_CTRLr 0x0b180609

#define BCM56800_A0_ING_IPMC_PTR_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program ING_IPMC_PTR_CTRL.
 *
 */
typedef union BCM56800_A0_ING_IPMC_PTR_CTRLr_s {
	uint32_t v[1];
	uint32_t ing_ipmc_ptr_ctrl[1];
	uint32_t _ing_ipmc_ptr_ctrl;
} BCM56800_A0_ING_IPMC_PTR_CTRLr_t;

#define BCM56800_A0_ING_IPMC_PTR_CTRLr_CLR(r) (r).ing_ipmc_ptr_ctrl[0] = 0
#define BCM56800_A0_ING_IPMC_PTR_CTRLr_SET(r,d) (r).ing_ipmc_ptr_ctrl[0] = d
#define BCM56800_A0_ING_IPMC_PTR_CTRLr_GET(r) (r).ing_ipmc_ptr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_IPMC_PTR_CTRLr_LOWER_LIMITf_GET(r) (((r).ing_ipmc_ptr_ctrl[0]) & 0x3ff)
#define BCM56800_A0_ING_IPMC_PTR_CTRLr_LOWER_LIMITf_SET(r,f) (r).ing_ipmc_ptr_ctrl[0]=(((r).ing_ipmc_ptr_ctrl[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM56800_A0_ING_IPMC_PTR_CTRLr_UPPER_LIMITf_GET(r) ((((r).ing_ipmc_ptr_ctrl[0]) >> 10) & 0x3ff)
#define BCM56800_A0_ING_IPMC_PTR_CTRLr_UPPER_LIMITf_SET(r,f) (r).ing_ipmc_ptr_ctrl[0]=(((r).ing_ipmc_ptr_ctrl[0] & ~((uint32_t)0x3ff << 10)) | ((((uint32_t)f) & 0x3ff) << 10))
#define BCM56800_A0_ING_IPMC_PTR_CTRLr_ENABLEf_GET(r) ((((r).ing_ipmc_ptr_ctrl[0]) >> 20) & 0x1)
#define BCM56800_A0_ING_IPMC_PTR_CTRLr_ENABLEf_SET(r,f) (r).ing_ipmc_ptr_ctrl[0]=(((r).ing_ipmc_ptr_ctrl[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access ING_IPMC_PTR_CTRL.
 *
 */
#define BCM56800_A0_READ_ING_IPMC_PTR_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_IPMC_PTR_CTRLr,(r._ing_ipmc_ptr_ctrl))
#define BCM56800_A0_WRITE_ING_IPMC_PTR_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_IPMC_PTR_CTRLr,&(r._ing_ipmc_ptr_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_IPMC_PTR_CTRLr BCM56800_A0_ING_IPMC_PTR_CTRLr
#define ING_IPMC_PTR_CTRLr_SIZE BCM56800_A0_ING_IPMC_PTR_CTRLr_SIZE
typedef BCM56800_A0_ING_IPMC_PTR_CTRLr_t ING_IPMC_PTR_CTRLr_t;
#define ING_IPMC_PTR_CTRLr_CLR BCM56800_A0_ING_IPMC_PTR_CTRLr_CLR
#define ING_IPMC_PTR_CTRLr_SET BCM56800_A0_ING_IPMC_PTR_CTRLr_SET
#define ING_IPMC_PTR_CTRLr_GET BCM56800_A0_ING_IPMC_PTR_CTRLr_GET
#define ING_IPMC_PTR_CTRLr_LOWER_LIMITf_GET BCM56800_A0_ING_IPMC_PTR_CTRLr_LOWER_LIMITf_GET
#define ING_IPMC_PTR_CTRLr_LOWER_LIMITf_SET BCM56800_A0_ING_IPMC_PTR_CTRLr_LOWER_LIMITf_SET
#define ING_IPMC_PTR_CTRLr_UPPER_LIMITf_GET BCM56800_A0_ING_IPMC_PTR_CTRLr_UPPER_LIMITf_GET
#define ING_IPMC_PTR_CTRLr_UPPER_LIMITf_SET BCM56800_A0_ING_IPMC_PTR_CTRLr_UPPER_LIMITf_SET
#define ING_IPMC_PTR_CTRLr_ENABLEf_GET BCM56800_A0_ING_IPMC_PTR_CTRLr_ENABLEf_GET
#define ING_IPMC_PTR_CTRLr_ENABLEf_SET BCM56800_A0_ING_IPMC_PTR_CTRLr_ENABLEf_SET
#define READ_ING_IPMC_PTR_CTRLr BCM56800_A0_READ_ING_IPMC_PTR_CTRLr
#define WRITE_ING_IPMC_PTR_CTRLr BCM56800_A0_WRITE_ING_IPMC_PTR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_IPMC_PTR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  ING_L3_NEXT_HOP
 * BLOCKS:   IPIPE
 * DESC:     Reduced version of L3_NEXT_HOP table.  Used to provide just mod and port/TGID
 * SIZE:     26
 * FIELDS:
 *     L3UC_TUNNEL_TYPE Tunnel Type
 *     PORT_TGID        Port/TGID of next hop
 *     MODULE_ID        Module ID of next hop
 *     VLAN_ID          VLAN ID of next hop
 *
 ******************************************************************************/
#define BCM56800_A0_ING_L3_NEXT_HOPm 0x0d161000

#define BCM56800_A0_ING_L3_NEXT_HOPm_MIN 0
#define BCM56800_A0_ING_L3_NEXT_HOPm_MAX 2047
#define BCM56800_A0_ING_L3_NEXT_HOPm_CMAX(u) 2047
#define BCM56800_A0_ING_L3_NEXT_HOPm_SIZE 4

/*
 * This structure should be used to declare and program ING_L3_NEXT_HOP.
 *
 */
typedef union BCM56800_A0_ING_L3_NEXT_HOPm_s {
	uint32_t v[1];
	uint32_t ing_l3_next_hop[1];
	uint32_t _ing_l3_next_hop;
} BCM56800_A0_ING_L3_NEXT_HOPm_t;

#define BCM56800_A0_ING_L3_NEXT_HOPm_CLR(r) (r).ing_l3_next_hop[0] = 0
#define BCM56800_A0_ING_L3_NEXT_HOPm_SET(r,d) (r).ing_l3_next_hop[0] = d
#define BCM56800_A0_ING_L3_NEXT_HOPm_GET(r) (r).ing_l3_next_hop[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET(r) (((r).ing_l3_next_hop[0]) & 0x1)
#define BCM56800_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 1) & 0x3f)
#define BCM56800_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM56800_A0_ING_L3_NEXT_HOPm_MODULE_IDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 7) & 0x7f)
#define BCM56800_A0_ING_L3_NEXT_HOPm_MODULE_IDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCM56800_A0_ING_L3_NEXT_HOPm_VLAN_IDf_GET(r) ((((r).ing_l3_next_hop[0]) >> 14) & 0xfff)
#define BCM56800_A0_ING_L3_NEXT_HOPm_VLAN_IDf_SET(r,f) (r).ing_l3_next_hop[0]=(((r).ing_l3_next_hop[0] & ~((uint32_t)0xfff << 14)) | ((((uint32_t)f) & 0xfff) << 14))

/*
 * These macros can be used to access ING_L3_NEXT_HOP.
 *
 */
#define BCM56800_A0_READ_ING_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_ING_L3_NEXT_HOPm,i,(m._ing_l3_next_hop),1)
#define BCM56800_A0_WRITE_ING_L3_NEXT_HOPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_ING_L3_NEXT_HOPm,i,&(m._ing_l3_next_hop),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_L3_NEXT_HOPm BCM56800_A0_ING_L3_NEXT_HOPm
#define ING_L3_NEXT_HOPm_MIN BCM56800_A0_ING_L3_NEXT_HOPm_MIN
#define ING_L3_NEXT_HOPm_MAX BCM56800_A0_ING_L3_NEXT_HOPm_MAX
#define ING_L3_NEXT_HOPm_CMAX(u) BCM56800_A0_ING_L3_NEXT_HOPm_CMAX(u)
#define ING_L3_NEXT_HOPm_SIZE BCM56800_A0_ING_L3_NEXT_HOPm_SIZE
typedef BCM56800_A0_ING_L3_NEXT_HOPm_t ING_L3_NEXT_HOPm_t;
#define ING_L3_NEXT_HOPm_CLR BCM56800_A0_ING_L3_NEXT_HOPm_CLR
#define ING_L3_NEXT_HOPm_SET BCM56800_A0_ING_L3_NEXT_HOPm_SET
#define ING_L3_NEXT_HOPm_GET BCM56800_A0_ING_L3_NEXT_HOPm_GET
#define ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET BCM56800_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_GET
#define ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET BCM56800_A0_ING_L3_NEXT_HOPm_L3UC_TUNNEL_TYPEf_SET
#define ING_L3_NEXT_HOPm_PORT_TGIDf_GET BCM56800_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_GET
#define ING_L3_NEXT_HOPm_PORT_TGIDf_SET BCM56800_A0_ING_L3_NEXT_HOPm_PORT_TGIDf_SET
#define ING_L3_NEXT_HOPm_MODULE_IDf_GET BCM56800_A0_ING_L3_NEXT_HOPm_MODULE_IDf_GET
#define ING_L3_NEXT_HOPm_MODULE_IDf_SET BCM56800_A0_ING_L3_NEXT_HOPm_MODULE_IDf_SET
#define ING_L3_NEXT_HOPm_VLAN_IDf_GET BCM56800_A0_ING_L3_NEXT_HOPm_VLAN_IDf_GET
#define ING_L3_NEXT_HOPm_VLAN_IDf_SET BCM56800_A0_ING_L3_NEXT_HOPm_VLAN_IDf_SET
#define READ_ING_L3_NEXT_HOPm BCM56800_A0_READ_ING_L3_NEXT_HOPm
#define WRITE_ING_L3_NEXT_HOPm BCM56800_A0_WRITE_ING_L3_NEXT_HOPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_L3_NEXT_HOPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_L3_NEXT_HOP_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     ING_L3_NEXT_HOP_CONTROL
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr 0x0d180c01

#define BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program ING_L3_NEXT_HOP_DBGCTRL.
 *
 */
typedef union BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t ing_l3_next_hop_dbgctrl[1];
	uint32_t _ing_l3_next_hop_dbgctrl;
} BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_t;

#define BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_CLR(r) (r).ing_l3_next_hop_dbgctrl[0] = 0
#define BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_SET(r,d) (r).ing_l3_next_hop_dbgctrl[0] = d
#define BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_GET(r) (r).ing_l3_next_hop_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_TMf_GET(r) (((r).ing_l3_next_hop_dbgctrl[0]) & 0xf)
#define BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_TMf_SET(r,f) (r).ing_l3_next_hop_dbgctrl[0]=(((r).ing_l3_next_hop_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access ING_L3_NEXT_HOP_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_ING_L3_NEXT_HOP_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr,(r._ing_l3_next_hop_dbgctrl))
#define BCM56800_A0_WRITE_ING_L3_NEXT_HOP_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr,&(r._ing_l3_next_hop_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_L3_NEXT_HOP_DBGCTRLr BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr
#define ING_L3_NEXT_HOP_DBGCTRLr_SIZE BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_SIZE
typedef BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_t ING_L3_NEXT_HOP_DBGCTRLr_t;
#define ING_L3_NEXT_HOP_DBGCTRLr_CLR BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_CLR
#define ING_L3_NEXT_HOP_DBGCTRLr_SET BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_SET
#define ING_L3_NEXT_HOP_DBGCTRLr_GET BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_GET
#define ING_L3_NEXT_HOP_DBGCTRLr_TMf_GET BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_TMf_GET
#define ING_L3_NEXT_HOP_DBGCTRLr_TMf_SET BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr_TMf_SET
#define READ_ING_L3_NEXT_HOP_DBGCTRLr BCM56800_A0_READ_ING_L3_NEXT_HOP_DBGCTRLr
#define WRITE_ING_L3_NEXT_HOP_DBGCTRLr BCM56800_A0_WRITE_ING_L3_NEXT_HOP_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_L3_NEXT_HOP_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_MISC_CONFIG
 * BLOCKS:   IPIPE
 * DESC:     Configuration bits that are needed in Isw2
 * SIZE:     32
 * FIELDS:
 *     APPLY_EGR_MASK_ON_UC_ONLY If set, apply egress mask on unicast packets only.
 *     APPLY_SRCMOD_BLOCK_ON_UC_ONLY If set, apply source modid block on unicast packets only.
 *     DO_NOT_APPLY_SRCMOD_BLOCK_ON_SC If set, do not apply source modid block on system control packets.
 *
 ******************************************************************************/
#define BCM56800_A0_ING_MISC_CONFIGr 0x0e180648

#define BCM56800_A0_ING_MISC_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program ING_MISC_CONFIG.
 *
 */
typedef union BCM56800_A0_ING_MISC_CONFIGr_s {
	uint32_t v[1];
	uint32_t ing_misc_config[1];
	uint32_t _ing_misc_config;
} BCM56800_A0_ING_MISC_CONFIGr_t;

#define BCM56800_A0_ING_MISC_CONFIGr_CLR(r) (r).ing_misc_config[0] = 0
#define BCM56800_A0_ING_MISC_CONFIGr_SET(r,d) (r).ing_misc_config[0] = d
#define BCM56800_A0_ING_MISC_CONFIGr_GET(r) (r).ing_misc_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET(r) (((r).ing_misc_config[0]) & 0x1)
#define BCM56800_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET(r) ((((r).ing_misc_config[0]) >> 1) & 0x1)
#define BCM56800_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET(r) ((((r).ing_misc_config[0]) >> 2) & 0x1)
#define BCM56800_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET(r,f) (r).ing_misc_config[0]=(((r).ing_misc_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access ING_MISC_CONFIG.
 *
 */
#define BCM56800_A0_READ_ING_MISC_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_MISC_CONFIGr,(r._ing_misc_config))
#define BCM56800_A0_WRITE_ING_MISC_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_MISC_CONFIGr,&(r._ing_misc_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_MISC_CONFIGr BCM56800_A0_ING_MISC_CONFIGr
#define ING_MISC_CONFIGr_SIZE BCM56800_A0_ING_MISC_CONFIGr_SIZE
typedef BCM56800_A0_ING_MISC_CONFIGr_t ING_MISC_CONFIGr_t;
#define ING_MISC_CONFIGr_CLR BCM56800_A0_ING_MISC_CONFIGr_CLR
#define ING_MISC_CONFIGr_SET BCM56800_A0_ING_MISC_CONFIGr_SET
#define ING_MISC_CONFIGr_GET BCM56800_A0_ING_MISC_CONFIGr_GET
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET BCM56800_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_GET
#define ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET BCM56800_A0_ING_MISC_CONFIGr_APPLY_EGR_MASK_ON_UC_ONLYf_SET
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET BCM56800_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_GET
#define ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET BCM56800_A0_ING_MISC_CONFIGr_APPLY_SRCMOD_BLOCK_ON_UC_ONLYf_SET
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET BCM56800_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_GET
#define ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET BCM56800_A0_ING_MISC_CONFIGr_DO_NOT_APPLY_SRCMOD_BLOCK_ON_SCf_SET
#define READ_ING_MISC_CONFIGr BCM56800_A0_READ_ING_MISC_CONFIGr
#define WRITE_ING_MISC_CONFIGr BCM56800_A0_WRITE_ING_MISC_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_MISC_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_MODMAP_CTRL
 * BLOCKS:   IPIPE
 * DESC:     Ingress Module Remapping Control Register
 * SIZE:     32
 * FIELDS:
 *     MODULEID_OFFSET  Value added to SRC_MODID in PP-view to generate SRC_MODID in SF-view
 *     ING_MAP_EN       Enable PP-view to SF-view remaping in the ingress
 *     ING_MOD_MAP_ID   ING_MOD_MAP table ID
 *
 ******************************************************************************/
#define BCM56800_A0_ING_MODMAP_CTRLr 0x02100000

#define BCM56800_A0_ING_MODMAP_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program ING_MODMAP_CTRL.
 *
 */
typedef union BCM56800_A0_ING_MODMAP_CTRLr_s {
	uint32_t v[1];
	uint32_t ing_modmap_ctrl[1];
	uint32_t _ing_modmap_ctrl;
} BCM56800_A0_ING_MODMAP_CTRLr_t;

#define BCM56800_A0_ING_MODMAP_CTRLr_CLR(r) (r).ing_modmap_ctrl[0] = 0
#define BCM56800_A0_ING_MODMAP_CTRLr_SET(r,d) (r).ing_modmap_ctrl[0] = d
#define BCM56800_A0_ING_MODMAP_CTRLr_GET(r) (r).ing_modmap_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_MODMAP_CTRLr_MODULEID_OFFSETf_GET(r) (((r).ing_modmap_ctrl[0]) & 0x7f)
#define BCM56800_A0_ING_MODMAP_CTRLr_MODULEID_OFFSETf_SET(r,f) (r).ing_modmap_ctrl[0]=(((r).ing_modmap_ctrl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))
#define BCM56800_A0_ING_MODMAP_CTRLr_ING_MAP_ENf_GET(r) ((((r).ing_modmap_ctrl[0]) >> 7) & 0x1)
#define BCM56800_A0_ING_MODMAP_CTRLr_ING_MAP_ENf_SET(r,f) (r).ing_modmap_ctrl[0]=(((r).ing_modmap_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_ING_MODMAP_CTRLr_ING_MOD_MAP_IDf_GET(r) ((((r).ing_modmap_ctrl[0]) >> 8) & 0x1)
#define BCM56800_A0_ING_MODMAP_CTRLr_ING_MOD_MAP_IDf_SET(r,f) (r).ing_modmap_ctrl[0]=(((r).ing_modmap_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access ING_MODMAP_CTRL.
 *
 */
#define BCM56800_A0_READ_ING_MODMAP_CTRLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_ING_MODMAP_CTRLr,(r._ing_modmap_ctrl))
#define BCM56800_A0_WRITE_ING_MODMAP_CTRLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_ING_MODMAP_CTRLr,&(r._ing_modmap_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_MODMAP_CTRLr BCM56800_A0_ING_MODMAP_CTRLr
#define ING_MODMAP_CTRLr_SIZE BCM56800_A0_ING_MODMAP_CTRLr_SIZE
typedef BCM56800_A0_ING_MODMAP_CTRLr_t ING_MODMAP_CTRLr_t;
#define ING_MODMAP_CTRLr_CLR BCM56800_A0_ING_MODMAP_CTRLr_CLR
#define ING_MODMAP_CTRLr_SET BCM56800_A0_ING_MODMAP_CTRLr_SET
#define ING_MODMAP_CTRLr_GET BCM56800_A0_ING_MODMAP_CTRLr_GET
#define ING_MODMAP_CTRLr_MODULEID_OFFSETf_GET BCM56800_A0_ING_MODMAP_CTRLr_MODULEID_OFFSETf_GET
#define ING_MODMAP_CTRLr_MODULEID_OFFSETf_SET BCM56800_A0_ING_MODMAP_CTRLr_MODULEID_OFFSETf_SET
#define ING_MODMAP_CTRLr_ING_MAP_ENf_GET BCM56800_A0_ING_MODMAP_CTRLr_ING_MAP_ENf_GET
#define ING_MODMAP_CTRLr_ING_MAP_ENf_SET BCM56800_A0_ING_MODMAP_CTRLr_ING_MAP_ENf_SET
#define ING_MODMAP_CTRLr_ING_MOD_MAP_IDf_GET BCM56800_A0_ING_MODMAP_CTRLr_ING_MOD_MAP_IDf_GET
#define ING_MODMAP_CTRLr_ING_MOD_MAP_IDf_SET BCM56800_A0_ING_MODMAP_CTRLr_ING_MOD_MAP_IDf_SET
#define READ_ING_MODMAP_CTRLr BCM56800_A0_READ_ING_MODMAP_CTRLr
#define WRITE_ING_MODMAP_CTRLr BCM56800_A0_WRITE_ING_MODMAP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_MODMAP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  ING_MOD_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Ingress Module Remapping Table
 * SIZE:     63
 * FIELDS:
 *     THRESH_C         Value to compare against the DST_PORT in PP-view
 *     THRESH_B         Value to compare against the DST_PORT in PP-view
 *     THRESH_A         Value to compare against the DST_PORT in PP-view
 *     PORTOFF_D        Offset to subtract from the DST_PORT in PP-view, if it is GT THRESH_C
 *     PORTOFF_C        Offset to subtract from the DST_PORT in PP-view, if it is LEQ THRESH_C and GT THRESH_B
 *     PORTOFF_B        Offset to subtract from the DST_PORT in PP-view, if it is LEQ THRESH_B and GT THRESH_A
 *     PORTOFF_A        Offset to subtract from the DST_PORT in PP-view, if it is LEQ THRESH_A
 *     MOD_D            SF-view DST_MODID to use if the DST_PORT in PP-view is GT THRESH_C
 *     MOD_C            SF-view DST_MODID to use if the DST_PORT in PP-view is LEQ THRESH_C and GT THRESH_B
 *     MOD_B            SF-view DST_MODID to use if the DST_PORT in PP-view is LEQ THRESH_B and GT THRESH_A
 *     MOD_A            SF-view DST_MODID to use if the DST_PORT in PP-view is LEQ THRESH_A
 *
 ******************************************************************************/
#define BCM56800_A0_ING_MOD_MAP_TABLEm 0x02163000

#define BCM56800_A0_ING_MOD_MAP_TABLEm_MIN 0
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MAX 127
#define BCM56800_A0_ING_MOD_MAP_TABLEm_CMAX(u) 127
#define BCM56800_A0_ING_MOD_MAP_TABLEm_SIZE 8

/*
 * This structure should be used to declare and program ING_MOD_MAP_TABLE.
 *
 */
typedef union BCM56800_A0_ING_MOD_MAP_TABLEm_s {
	uint32_t v[2];
	uint32_t ing_mod_map_table[2];
	uint32_t _ing_mod_map_table;
} BCM56800_A0_ING_MOD_MAP_TABLEm_t;

#define BCM56800_A0_ING_MOD_MAP_TABLEm_CLR(r) CDK_MEMSET(&((r)._ing_mod_map_table), 0, sizeof(BCM56800_A0_ING_MOD_MAP_TABLEm_t))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_SET(r,i,d) (r).ing_mod_map_table[i] = d
#define BCM56800_A0_ING_MOD_MAP_TABLEm_GET(r,i) (r).ing_mod_map_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Cf_GET(r) (((r).ing_mod_map_table[0]) & 0x1f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Cf_SET(r,f) (r).ing_mod_map_table[0]=(((r).ing_mod_map_table[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Bf_GET(r) ((((r).ing_mod_map_table[0]) >> 5) & 0x1f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Bf_SET(r,f) (r).ing_mod_map_table[0]=(((r).ing_mod_map_table[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Af_GET(r) ((((r).ing_mod_map_table[0]) >> 10) & 0x1f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Af_SET(r,f) (r).ing_mod_map_table[0]=(((r).ing_mod_map_table[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Df_GET(r) ((((r).ing_mod_map_table[0]) >> 15) & 0x1f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Df_SET(r,f) (r).ing_mod_map_table[0]=(((r).ing_mod_map_table[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Cf_GET(r) ((((r).ing_mod_map_table[0]) >> 20) & 0x1f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Cf_SET(r,f) (r).ing_mod_map_table[0]=(((r).ing_mod_map_table[0] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Bf_GET(r) ((((r).ing_mod_map_table[0]) >> 25) & 0x1f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Bf_SET(r,f) (r).ing_mod_map_table[0]=(((r).ing_mod_map_table[0] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Af_GET(r) cdk_field32_get((r).ing_mod_map_table,30,34)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Af_SET(r,f) cdk_field32_set((r).ing_mod_map_table,30,34,f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Df_GET(r) ((((r).ing_mod_map_table[1]) >> 3) & 0x7f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Df_SET(r,f) (r).ing_mod_map_table[1]=(((r).ing_mod_map_table[1] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Cf_GET(r) ((((r).ing_mod_map_table[1]) >> 10) & 0x7f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Cf_SET(r,f) (r).ing_mod_map_table[1]=(((r).ing_mod_map_table[1] & ~((uint32_t)0x7f << 10)) | ((((uint32_t)f) & 0x7f) << 10))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Bf_GET(r) ((((r).ing_mod_map_table[1]) >> 17) & 0x7f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Bf_SET(r,f) (r).ing_mod_map_table[1]=(((r).ing_mod_map_table[1] & ~((uint32_t)0x7f << 17)) | ((((uint32_t)f) & 0x7f) << 17))
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Af_GET(r) ((((r).ing_mod_map_table[1]) >> 24) & 0x7f)
#define BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Af_SET(r,f) (r).ing_mod_map_table[1]=(((r).ing_mod_map_table[1] & ~((uint32_t)0x7f << 24)) | ((((uint32_t)f) & 0x7f) << 24))

/*
 * These macros can be used to access ING_MOD_MAP_TABLE.
 *
 */
#define BCM56800_A0_READ_ING_MOD_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_ING_MOD_MAP_TABLEm,i,(m._ing_mod_map_table),2)
#define BCM56800_A0_WRITE_ING_MOD_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_ING_MOD_MAP_TABLEm,i,&(m._ing_mod_map_table),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_MOD_MAP_TABLEm BCM56800_A0_ING_MOD_MAP_TABLEm
#define ING_MOD_MAP_TABLEm_MIN BCM56800_A0_ING_MOD_MAP_TABLEm_MIN
#define ING_MOD_MAP_TABLEm_MAX BCM56800_A0_ING_MOD_MAP_TABLEm_MAX
#define ING_MOD_MAP_TABLEm_CMAX(u) BCM56800_A0_ING_MOD_MAP_TABLEm_CMAX(u)
#define ING_MOD_MAP_TABLEm_SIZE BCM56800_A0_ING_MOD_MAP_TABLEm_SIZE
typedef BCM56800_A0_ING_MOD_MAP_TABLEm_t ING_MOD_MAP_TABLEm_t;
#define ING_MOD_MAP_TABLEm_CLR BCM56800_A0_ING_MOD_MAP_TABLEm_CLR
#define ING_MOD_MAP_TABLEm_SET BCM56800_A0_ING_MOD_MAP_TABLEm_SET
#define ING_MOD_MAP_TABLEm_GET BCM56800_A0_ING_MOD_MAP_TABLEm_GET
#define ING_MOD_MAP_TABLEm_THRESH_Cf_GET BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Cf_GET
#define ING_MOD_MAP_TABLEm_THRESH_Cf_SET BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Cf_SET
#define ING_MOD_MAP_TABLEm_THRESH_Bf_GET BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Bf_GET
#define ING_MOD_MAP_TABLEm_THRESH_Bf_SET BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Bf_SET
#define ING_MOD_MAP_TABLEm_THRESH_Af_GET BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Af_GET
#define ING_MOD_MAP_TABLEm_THRESH_Af_SET BCM56800_A0_ING_MOD_MAP_TABLEm_THRESH_Af_SET
#define ING_MOD_MAP_TABLEm_PORTOFF_Df_GET BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Df_GET
#define ING_MOD_MAP_TABLEm_PORTOFF_Df_SET BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Df_SET
#define ING_MOD_MAP_TABLEm_PORTOFF_Cf_GET BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Cf_GET
#define ING_MOD_MAP_TABLEm_PORTOFF_Cf_SET BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Cf_SET
#define ING_MOD_MAP_TABLEm_PORTOFF_Bf_GET BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Bf_GET
#define ING_MOD_MAP_TABLEm_PORTOFF_Bf_SET BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Bf_SET
#define ING_MOD_MAP_TABLEm_PORTOFF_Af_GET BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Af_GET
#define ING_MOD_MAP_TABLEm_PORTOFF_Af_SET BCM56800_A0_ING_MOD_MAP_TABLEm_PORTOFF_Af_SET
#define ING_MOD_MAP_TABLEm_MOD_Df_GET BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Df_GET
#define ING_MOD_MAP_TABLEm_MOD_Df_SET BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Df_SET
#define ING_MOD_MAP_TABLEm_MOD_Cf_GET BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Cf_GET
#define ING_MOD_MAP_TABLEm_MOD_Cf_SET BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Cf_SET
#define ING_MOD_MAP_TABLEm_MOD_Bf_GET BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Bf_GET
#define ING_MOD_MAP_TABLEm_MOD_Bf_SET BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Bf_SET
#define ING_MOD_MAP_TABLEm_MOD_Af_GET BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Af_GET
#define ING_MOD_MAP_TABLEm_MOD_Af_SET BCM56800_A0_ING_MOD_MAP_TABLEm_MOD_Af_SET
#define READ_ING_MOD_MAP_TABLEm BCM56800_A0_READ_ING_MOD_MAP_TABLEm
#define WRITE_ING_MOD_MAP_TABLEm BCM56800_A0_WRITE_ING_MOD_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_MOD_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ING_Q_BEGIN
 * BLOCKS:   IPIPE
 * DESC:     Register starts the IQ Bus which is provided for later ECO reasons, if any.
 * SIZE:     32
 * FIELDS:
 *     QBUS             Debug BUS introduced for later ECO provisions.
 *     AARB_ECO_OFF     Turn off auxillary arbiter ECO that gates learn and age requests with the sbus request.
 *
 ******************************************************************************/
#define BCM56800_A0_ING_Q_BEGINr 0x00180c07

#define BCM56800_A0_ING_Q_BEGINr_SIZE 4

/*
 * This structure should be used to declare and program ING_Q_BEGIN.
 *
 */
typedef union BCM56800_A0_ING_Q_BEGINr_s {
	uint32_t v[1];
	uint32_t ing_q_begin[1];
	uint32_t _ing_q_begin;
} BCM56800_A0_ING_Q_BEGINr_t;

#define BCM56800_A0_ING_Q_BEGINr_CLR(r) (r).ing_q_begin[0] = 0
#define BCM56800_A0_ING_Q_BEGINr_SET(r,d) (r).ing_q_begin[0] = d
#define BCM56800_A0_ING_Q_BEGINr_GET(r) (r).ing_q_begin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_ING_Q_BEGINr_QBUSf_GET(r) (((r).ing_q_begin[0]) & 0xff)
#define BCM56800_A0_ING_Q_BEGINr_QBUSf_SET(r,f) (r).ing_q_begin[0]=(((r).ing_q_begin[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_ING_Q_BEGINr_AARB_ECO_OFFf_GET(r) ((((r).ing_q_begin[0]) >> 8) & 0x1)
#define BCM56800_A0_ING_Q_BEGINr_AARB_ECO_OFFf_SET(r,f) (r).ing_q_begin[0]=(((r).ing_q_begin[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access ING_Q_BEGIN.
 *
 */
#define BCM56800_A0_READ_ING_Q_BEGINr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_ING_Q_BEGINr,(r._ing_q_begin))
#define BCM56800_A0_WRITE_ING_Q_BEGINr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_ING_Q_BEGINr,&(r._ing_q_begin))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ING_Q_BEGINr BCM56800_A0_ING_Q_BEGINr
#define ING_Q_BEGINr_SIZE BCM56800_A0_ING_Q_BEGINr_SIZE
typedef BCM56800_A0_ING_Q_BEGINr_t ING_Q_BEGINr_t;
#define ING_Q_BEGINr_CLR BCM56800_A0_ING_Q_BEGINr_CLR
#define ING_Q_BEGINr_SET BCM56800_A0_ING_Q_BEGINr_SET
#define ING_Q_BEGINr_GET BCM56800_A0_ING_Q_BEGINr_GET
#define ING_Q_BEGINr_QBUSf_GET BCM56800_A0_ING_Q_BEGINr_QBUSf_GET
#define ING_Q_BEGINr_QBUSf_SET BCM56800_A0_ING_Q_BEGINr_QBUSf_SET
#define ING_Q_BEGINr_AARB_ECO_OFFf_GET BCM56800_A0_ING_Q_BEGINr_AARB_ECO_OFFf_GET
#define ING_Q_BEGINr_AARB_ECO_OFFf_SET BCM56800_A0_ING_Q_BEGINr_AARB_ECO_OFFf_SET
#define READ_ING_Q_BEGINr BCM56800_A0_READ_ING_Q_BEGINr
#define WRITE_ING_Q_BEGINr BCM56800_A0_WRITE_ING_Q_BEGINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ING_Q_BEGINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  INPUT_PORT_RX_ENABLE
 * BLOCKS:   MMU
 * DESC:     INPUT_PORT_RX_ENABLE
 * SIZE:     32
 * FIELDS:
 *     INPUT_PORT_RX_ENABLE Input Port Rx Enable Bitmap,The bitmap will be masked by current es tdm slot mode,If current tdm mode is 8 tdm for pipe 0, then potr 8 & 9 enable will get masked out.If current tdm mode is 8 tdm for pipe 1, then potr 18 & 19 enable will get masked out.
 *
 ******************************************************************************/
#define BCM56800_A0_INPUT_PORT_RX_ENABLEr 0x06d80030

#define BCM56800_A0_INPUT_PORT_RX_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program INPUT_PORT_RX_ENABLE.
 *
 */
typedef union BCM56800_A0_INPUT_PORT_RX_ENABLEr_s {
	uint32_t v[1];
	uint32_t input_port_rx_enable[1];
	uint32_t _input_port_rx_enable;
} BCM56800_A0_INPUT_PORT_RX_ENABLEr_t;

#define BCM56800_A0_INPUT_PORT_RX_ENABLEr_CLR(r) (r).input_port_rx_enable[0] = 0
#define BCM56800_A0_INPUT_PORT_RX_ENABLEr_SET(r,d) (r).input_port_rx_enable[0] = d
#define BCM56800_A0_INPUT_PORT_RX_ENABLEr_GET(r) (r).input_port_rx_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_INPUT_PORT_RX_ENABLEr_INPUT_PORT_RX_ENABLEf_GET(r) (((r).input_port_rx_enable[0]) & 0x1fffff)
#define BCM56800_A0_INPUT_PORT_RX_ENABLEr_INPUT_PORT_RX_ENABLEf_SET(r,f) (r).input_port_rx_enable[0]=(((r).input_port_rx_enable[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access INPUT_PORT_RX_ENABLE.
 *
 */
#define BCM56800_A0_READ_INPUT_PORT_RX_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_INPUT_PORT_RX_ENABLEr,(r._input_port_rx_enable))
#define BCM56800_A0_WRITE_INPUT_PORT_RX_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_INPUT_PORT_RX_ENABLEr,&(r._input_port_rx_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INPUT_PORT_RX_ENABLEr BCM56800_A0_INPUT_PORT_RX_ENABLEr
#define INPUT_PORT_RX_ENABLEr_SIZE BCM56800_A0_INPUT_PORT_RX_ENABLEr_SIZE
typedef BCM56800_A0_INPUT_PORT_RX_ENABLEr_t INPUT_PORT_RX_ENABLEr_t;
#define INPUT_PORT_RX_ENABLEr_CLR BCM56800_A0_INPUT_PORT_RX_ENABLEr_CLR
#define INPUT_PORT_RX_ENABLEr_SET BCM56800_A0_INPUT_PORT_RX_ENABLEr_SET
#define INPUT_PORT_RX_ENABLEr_GET BCM56800_A0_INPUT_PORT_RX_ENABLEr_GET
#define INPUT_PORT_RX_ENABLEr_INPUT_PORT_RX_ENABLEf_GET BCM56800_A0_INPUT_PORT_RX_ENABLEr_INPUT_PORT_RX_ENABLEf_GET
#define INPUT_PORT_RX_ENABLEr_INPUT_PORT_RX_ENABLEf_SET BCM56800_A0_INPUT_PORT_RX_ENABLEr_INPUT_PORT_RX_ENABLEf_SET
#define READ_INPUT_PORT_RX_ENABLEr BCM56800_A0_READ_INPUT_PORT_RX_ENABLEr
#define WRITE_INPUT_PORT_RX_ENABLEr BCM56800_A0_WRITE_INPUT_PORT_RX_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_INPUT_PORT_RX_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCGROUPMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm registers.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCGROUPMEMDEBUGr 0x10d80004

#define BCM56800_A0_IPMCGROUPMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program IPMCGROUPMEMDEBUG.
 *
 */
typedef union BCM56800_A0_IPMCGROUPMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t ipmcgroupmemdebug[1];
	uint32_t _ipmcgroupmemdebug;
} BCM56800_A0_IPMCGROUPMEMDEBUGr_t;

#define BCM56800_A0_IPMCGROUPMEMDEBUGr_CLR(r) (r).ipmcgroupmemdebug[0] = 0
#define BCM56800_A0_IPMCGROUPMEMDEBUGr_SET(r,d) (r).ipmcgroupmemdebug[0] = d
#define BCM56800_A0_IPMCGROUPMEMDEBUGr_GET(r) (r).ipmcgroupmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCGROUPMEMDEBUGr_TMf_GET(r) (((r).ipmcgroupmemdebug[0]) & 0xff)
#define BCM56800_A0_IPMCGROUPMEMDEBUGr_TMf_SET(r,f) (r).ipmcgroupmemdebug[0]=(((r).ipmcgroupmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access IPMCGROUPMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_IPMCGROUPMEMDEBUGr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCGROUPMEMDEBUGr+(i),(r._ipmcgroupmemdebug))
#define BCM56800_A0_WRITE_IPMCGROUPMEMDEBUGr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCGROUPMEMDEBUGr+(i),&(r._ipmcgroupmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCGROUPMEMDEBUGr BCM56800_A0_IPMCGROUPMEMDEBUGr
#define IPMCGROUPMEMDEBUGr_SIZE BCM56800_A0_IPMCGROUPMEMDEBUGr_SIZE
typedef BCM56800_A0_IPMCGROUPMEMDEBUGr_t IPMCGROUPMEMDEBUGr_t;
#define IPMCGROUPMEMDEBUGr_CLR BCM56800_A0_IPMCGROUPMEMDEBUGr_CLR
#define IPMCGROUPMEMDEBUGr_SET BCM56800_A0_IPMCGROUPMEMDEBUGr_SET
#define IPMCGROUPMEMDEBUGr_GET BCM56800_A0_IPMCGROUPMEMDEBUGr_GET
#define IPMCGROUPMEMDEBUGr_TMf_GET BCM56800_A0_IPMCGROUPMEMDEBUGr_TMf_GET
#define IPMCGROUPMEMDEBUGr_TMf_SET BCM56800_A0_IPMCGROUPMEMDEBUGr_TMf_SET
#define READ_IPMCGROUPMEMDEBUGr BCM56800_A0_READ_IPMCGROUPMEMDEBUGr
#define WRITE_IPMCGROUPMEMDEBUGr BCM56800_A0_WRITE_IPMCGROUPMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCGROUPMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCIDXINCACONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     IPMCIDXALOWMARKER IPMC Index A Low Marker.
 *     IPMCIDXAHIGHMARKER IPMC Index A High Marker
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCIDXINCACONFIGr 0x04d8005c

#define BCM56800_A0_IPMCIDXINCACONFIGr_SIZE 4

/*
 * This structure should be used to declare and program IPMCIDXINCACONFIG.
 *
 */
typedef union BCM56800_A0_IPMCIDXINCACONFIGr_s {
	uint32_t v[1];
	uint32_t ipmcidxincaconfig[1];
	uint32_t _ipmcidxincaconfig;
} BCM56800_A0_IPMCIDXINCACONFIGr_t;

#define BCM56800_A0_IPMCIDXINCACONFIGr_CLR(r) (r).ipmcidxincaconfig[0] = 0
#define BCM56800_A0_IPMCIDXINCACONFIGr_SET(r,d) (r).ipmcidxincaconfig[0] = d
#define BCM56800_A0_IPMCIDXINCACONFIGr_GET(r) (r).ipmcidxincaconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCIDXINCACONFIGr_IPMCIDXALOWMARKERf_GET(r) (((r).ipmcidxincaconfig[0]) & 0x3ff)
#define BCM56800_A0_IPMCIDXINCACONFIGr_IPMCIDXALOWMARKERf_SET(r,f) (r).ipmcidxincaconfig[0]=(((r).ipmcidxincaconfig[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM56800_A0_IPMCIDXINCACONFIGr_IPMCIDXAHIGHMARKERf_GET(r) ((((r).ipmcidxincaconfig[0]) >> 10) & 0x3ff)
#define BCM56800_A0_IPMCIDXINCACONFIGr_IPMCIDXAHIGHMARKERf_SET(r,f) (r).ipmcidxincaconfig[0]=(((r).ipmcidxincaconfig[0] & ~((uint32_t)0x3ff << 10)) | ((((uint32_t)f) & 0x3ff) << 10))

/*
 * These macros can be used to access IPMCIDXINCACONFIG.
 *
 */
#define BCM56800_A0_READ_IPMCIDXINCACONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCIDXINCACONFIGr,(r._ipmcidxincaconfig))
#define BCM56800_A0_WRITE_IPMCIDXINCACONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCIDXINCACONFIGr,&(r._ipmcidxincaconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCIDXINCACONFIGr BCM56800_A0_IPMCIDXINCACONFIGr
#define IPMCIDXINCACONFIGr_SIZE BCM56800_A0_IPMCIDXINCACONFIGr_SIZE
typedef BCM56800_A0_IPMCIDXINCACONFIGr_t IPMCIDXINCACONFIGr_t;
#define IPMCIDXINCACONFIGr_CLR BCM56800_A0_IPMCIDXINCACONFIGr_CLR
#define IPMCIDXINCACONFIGr_SET BCM56800_A0_IPMCIDXINCACONFIGr_SET
#define IPMCIDXINCACONFIGr_GET BCM56800_A0_IPMCIDXINCACONFIGr_GET
#define IPMCIDXINCACONFIGr_IPMCIDXALOWMARKERf_GET BCM56800_A0_IPMCIDXINCACONFIGr_IPMCIDXALOWMARKERf_GET
#define IPMCIDXINCACONFIGr_IPMCIDXALOWMARKERf_SET BCM56800_A0_IPMCIDXINCACONFIGr_IPMCIDXALOWMARKERf_SET
#define IPMCIDXINCACONFIGr_IPMCIDXAHIGHMARKERf_GET BCM56800_A0_IPMCIDXINCACONFIGr_IPMCIDXAHIGHMARKERf_GET
#define IPMCIDXINCACONFIGr_IPMCIDXAHIGHMARKERf_SET BCM56800_A0_IPMCIDXINCACONFIGr_IPMCIDXAHIGHMARKERf_SET
#define READ_IPMCIDXINCACONFIGr BCM56800_A0_READ_IPMCIDXINCACONFIGr
#define WRITE_IPMCIDXINCACONFIGr BCM56800_A0_WRITE_IPMCIDXINCACONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCIDXINCACONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCIDXINCAEN
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     IPMCIDXINCAEN    Per port IPMC Index Increment A Mode Enable bit is controlling IPMC index A increment featurefor all ipmc replicated packet. IPMC index need to bewithin the range defined by IPMCIdxAHighMarker and IPMCIdxALowMarker. New IPMCIndex send will be the original IPMC Index added with replicated packet number.Ex. First packet, New IPMC Index = Original IPMC Index + 1;    Second packet, New IPMC Index = Original IPMC Index + 2;    ....    n-th packet, New IPMC Index = Original IPMC Index + n;1: IPMC Index Increment A Mode En.0: IPMC Index Increment A Mode Disable.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCIDXINCAENr 0x04d80063

#define BCM56800_A0_IPMCIDXINCAENr_SIZE 4

/*
 * This structure should be used to declare and program IPMCIDXINCAEN.
 *
 */
typedef union BCM56800_A0_IPMCIDXINCAENr_s {
	uint32_t v[1];
	uint32_t ipmcidxincaen[1];
	uint32_t _ipmcidxincaen;
} BCM56800_A0_IPMCIDXINCAENr_t;

#define BCM56800_A0_IPMCIDXINCAENr_CLR(r) (r).ipmcidxincaen[0] = 0
#define BCM56800_A0_IPMCIDXINCAENr_SET(r,d) (r).ipmcidxincaen[0] = d
#define BCM56800_A0_IPMCIDXINCAENr_GET(r) (r).ipmcidxincaen[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCIDXINCAENr_IPMCIDXINCAENf_GET(r) (((r).ipmcidxincaen[0]) & 0x1fffff)
#define BCM56800_A0_IPMCIDXINCAENr_IPMCIDXINCAENf_SET(r,f) (r).ipmcidxincaen[0]=(((r).ipmcidxincaen[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IPMCIDXINCAEN.
 *
 */
#define BCM56800_A0_READ_IPMCIDXINCAENr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCIDXINCAENr,(r._ipmcidxincaen))
#define BCM56800_A0_WRITE_IPMCIDXINCAENr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCIDXINCAENr,&(r._ipmcidxincaen))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCIDXINCAENr BCM56800_A0_IPMCIDXINCAENr
#define IPMCIDXINCAENr_SIZE BCM56800_A0_IPMCIDXINCAENr_SIZE
typedef BCM56800_A0_IPMCIDXINCAENr_t IPMCIDXINCAENr_t;
#define IPMCIDXINCAENr_CLR BCM56800_A0_IPMCIDXINCAENr_CLR
#define IPMCIDXINCAENr_SET BCM56800_A0_IPMCIDXINCAENr_SET
#define IPMCIDXINCAENr_GET BCM56800_A0_IPMCIDXINCAENr_GET
#define IPMCIDXINCAENr_IPMCIDXINCAENf_GET BCM56800_A0_IPMCIDXINCAENr_IPMCIDXINCAENf_GET
#define IPMCIDXINCAENr_IPMCIDXINCAENf_SET BCM56800_A0_IPMCIDXINCAENr_IPMCIDXINCAENf_SET
#define READ_IPMCIDXINCAENr BCM56800_A0_READ_IPMCIDXINCAENr
#define WRITE_IPMCIDXINCAENr BCM56800_A0_WRITE_IPMCIDXINCAENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCIDXINCAENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCIDXINCBCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     IPMCIDXBLOWMARKER IPMC Index B Low Marker.
 *     IPMCIDXBHIGHMARKER IPMC Index B High Marker
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCIDXINCBCONFIGr 0x04d8005d

#define BCM56800_A0_IPMCIDXINCBCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program IPMCIDXINCBCONFIG.
 *
 */
typedef union BCM56800_A0_IPMCIDXINCBCONFIGr_s {
	uint32_t v[1];
	uint32_t ipmcidxincbconfig[1];
	uint32_t _ipmcidxincbconfig;
} BCM56800_A0_IPMCIDXINCBCONFIGr_t;

#define BCM56800_A0_IPMCIDXINCBCONFIGr_CLR(r) (r).ipmcidxincbconfig[0] = 0
#define BCM56800_A0_IPMCIDXINCBCONFIGr_SET(r,d) (r).ipmcidxincbconfig[0] = d
#define BCM56800_A0_IPMCIDXINCBCONFIGr_GET(r) (r).ipmcidxincbconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCIDXINCBCONFIGr_IPMCIDXBLOWMARKERf_GET(r) (((r).ipmcidxincbconfig[0]) & 0x3ff)
#define BCM56800_A0_IPMCIDXINCBCONFIGr_IPMCIDXBLOWMARKERf_SET(r,f) (r).ipmcidxincbconfig[0]=(((r).ipmcidxincbconfig[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM56800_A0_IPMCIDXINCBCONFIGr_IPMCIDXBHIGHMARKERf_GET(r) ((((r).ipmcidxincbconfig[0]) >> 10) & 0x3ff)
#define BCM56800_A0_IPMCIDXINCBCONFIGr_IPMCIDXBHIGHMARKERf_SET(r,f) (r).ipmcidxincbconfig[0]=(((r).ipmcidxincbconfig[0] & ~((uint32_t)0x3ff << 10)) | ((((uint32_t)f) & 0x3ff) << 10))

/*
 * These macros can be used to access IPMCIDXINCBCONFIG.
 *
 */
#define BCM56800_A0_READ_IPMCIDXINCBCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCIDXINCBCONFIGr,(r._ipmcidxincbconfig))
#define BCM56800_A0_WRITE_IPMCIDXINCBCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCIDXINCBCONFIGr,&(r._ipmcidxincbconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCIDXINCBCONFIGr BCM56800_A0_IPMCIDXINCBCONFIGr
#define IPMCIDXINCBCONFIGr_SIZE BCM56800_A0_IPMCIDXINCBCONFIGr_SIZE
typedef BCM56800_A0_IPMCIDXINCBCONFIGr_t IPMCIDXINCBCONFIGr_t;
#define IPMCIDXINCBCONFIGr_CLR BCM56800_A0_IPMCIDXINCBCONFIGr_CLR
#define IPMCIDXINCBCONFIGr_SET BCM56800_A0_IPMCIDXINCBCONFIGr_SET
#define IPMCIDXINCBCONFIGr_GET BCM56800_A0_IPMCIDXINCBCONFIGr_GET
#define IPMCIDXINCBCONFIGr_IPMCIDXBLOWMARKERf_GET BCM56800_A0_IPMCIDXINCBCONFIGr_IPMCIDXBLOWMARKERf_GET
#define IPMCIDXINCBCONFIGr_IPMCIDXBLOWMARKERf_SET BCM56800_A0_IPMCIDXINCBCONFIGr_IPMCIDXBLOWMARKERf_SET
#define IPMCIDXINCBCONFIGr_IPMCIDXBHIGHMARKERf_GET BCM56800_A0_IPMCIDXINCBCONFIGr_IPMCIDXBHIGHMARKERf_GET
#define IPMCIDXINCBCONFIGr_IPMCIDXBHIGHMARKERf_SET BCM56800_A0_IPMCIDXINCBCONFIGr_IPMCIDXBHIGHMARKERf_SET
#define READ_IPMCIDXINCBCONFIGr BCM56800_A0_READ_IPMCIDXINCBCONFIGr
#define WRITE_IPMCIDXINCBCONFIGr BCM56800_A0_WRITE_IPMCIDXINCBCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCIDXINCBCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCIDXINCBEN
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     IPMCIDXINCBEN    Per port IPMC Index Increment B Mode Enable bit is controlling IPMC index B increment featurefor all ipmc replicated packet. IPMC index need to bewithin the range defined by IPMCIdxAHighMarker and IPMCIdxALowMarker. New IPMCIndex send will be the original IPMC Index added with replicated packet number.Ex. First packet, New IPMC Index = Original IPMC Index + 1;    Second packet, New IPMC Index = Original IPMC Index + 2;    ....    n-th packet, New IPMC Index = Original IPMC Index + n;1: IPMC Index Increment B Mode En.0: IPMC Index Increment B Mode Disable.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCIDXINCBENr 0x04d80064

#define BCM56800_A0_IPMCIDXINCBENr_SIZE 4

/*
 * This structure should be used to declare and program IPMCIDXINCBEN.
 *
 */
typedef union BCM56800_A0_IPMCIDXINCBENr_s {
	uint32_t v[1];
	uint32_t ipmcidxincben[1];
	uint32_t _ipmcidxincben;
} BCM56800_A0_IPMCIDXINCBENr_t;

#define BCM56800_A0_IPMCIDXINCBENr_CLR(r) (r).ipmcidxincben[0] = 0
#define BCM56800_A0_IPMCIDXINCBENr_SET(r,d) (r).ipmcidxincben[0] = d
#define BCM56800_A0_IPMCIDXINCBENr_GET(r) (r).ipmcidxincben[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCIDXINCBENr_IPMCIDXINCBENf_GET(r) (((r).ipmcidxincben[0]) & 0x1fffff)
#define BCM56800_A0_IPMCIDXINCBENr_IPMCIDXINCBENf_SET(r,f) (r).ipmcidxincben[0]=(((r).ipmcidxincben[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IPMCIDXINCBEN.
 *
 */
#define BCM56800_A0_READ_IPMCIDXINCBENr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCIDXINCBENr,(r._ipmcidxincben))
#define BCM56800_A0_WRITE_IPMCIDXINCBENr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCIDXINCBENr,&(r._ipmcidxincben))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCIDXINCBENr BCM56800_A0_IPMCIDXINCBENr
#define IPMCIDXINCBENr_SIZE BCM56800_A0_IPMCIDXINCBENr_SIZE
typedef BCM56800_A0_IPMCIDXINCBENr_t IPMCIDXINCBENr_t;
#define IPMCIDXINCBENr_CLR BCM56800_A0_IPMCIDXINCBENr_CLR
#define IPMCIDXINCBENr_SET BCM56800_A0_IPMCIDXINCBENr_SET
#define IPMCIDXINCBENr_GET BCM56800_A0_IPMCIDXINCBENr_GET
#define IPMCIDXINCBENr_IPMCIDXINCBENf_GET BCM56800_A0_IPMCIDXINCBENr_IPMCIDXINCBENf_GET
#define IPMCIDXINCBENr_IPMCIDXINCBENf_SET BCM56800_A0_IPMCIDXINCBENr_IPMCIDXINCBENf_SET
#define READ_IPMCIDXINCBENr BCM56800_A0_READ_IPMCIDXINCBENr
#define WRITE_IPMCIDXINCBENr BCM56800_A0_WRITE_IPMCIDXINCBENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCIDXINCBENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCIDXINCCCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     IPMCIDXCLOWMARKER IPMC Index C Low Marker.
 *     IPMCIDXCHIGHMARKER IPMC Index C High Marker
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCIDXINCCCONFIGr 0x04d8005e

#define BCM56800_A0_IPMCIDXINCCCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program IPMCIDXINCCCONFIG.
 *
 */
typedef union BCM56800_A0_IPMCIDXINCCCONFIGr_s {
	uint32_t v[1];
	uint32_t ipmcidxinccconfig[1];
	uint32_t _ipmcidxinccconfig;
} BCM56800_A0_IPMCIDXINCCCONFIGr_t;

#define BCM56800_A0_IPMCIDXINCCCONFIGr_CLR(r) (r).ipmcidxinccconfig[0] = 0
#define BCM56800_A0_IPMCIDXINCCCONFIGr_SET(r,d) (r).ipmcidxinccconfig[0] = d
#define BCM56800_A0_IPMCIDXINCCCONFIGr_GET(r) (r).ipmcidxinccconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCIDXINCCCONFIGr_IPMCIDXCLOWMARKERf_GET(r) (((r).ipmcidxinccconfig[0]) & 0x3ff)
#define BCM56800_A0_IPMCIDXINCCCONFIGr_IPMCIDXCLOWMARKERf_SET(r,f) (r).ipmcidxinccconfig[0]=(((r).ipmcidxinccconfig[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM56800_A0_IPMCIDXINCCCONFIGr_IPMCIDXCHIGHMARKERf_GET(r) ((((r).ipmcidxinccconfig[0]) >> 10) & 0x3ff)
#define BCM56800_A0_IPMCIDXINCCCONFIGr_IPMCIDXCHIGHMARKERf_SET(r,f) (r).ipmcidxinccconfig[0]=(((r).ipmcidxinccconfig[0] & ~((uint32_t)0x3ff << 10)) | ((((uint32_t)f) & 0x3ff) << 10))

/*
 * These macros can be used to access IPMCIDXINCCCONFIG.
 *
 */
#define BCM56800_A0_READ_IPMCIDXINCCCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCIDXINCCCONFIGr,(r._ipmcidxinccconfig))
#define BCM56800_A0_WRITE_IPMCIDXINCCCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCIDXINCCCONFIGr,&(r._ipmcidxinccconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCIDXINCCCONFIGr BCM56800_A0_IPMCIDXINCCCONFIGr
#define IPMCIDXINCCCONFIGr_SIZE BCM56800_A0_IPMCIDXINCCCONFIGr_SIZE
typedef BCM56800_A0_IPMCIDXINCCCONFIGr_t IPMCIDXINCCCONFIGr_t;
#define IPMCIDXINCCCONFIGr_CLR BCM56800_A0_IPMCIDXINCCCONFIGr_CLR
#define IPMCIDXINCCCONFIGr_SET BCM56800_A0_IPMCIDXINCCCONFIGr_SET
#define IPMCIDXINCCCONFIGr_GET BCM56800_A0_IPMCIDXINCCCONFIGr_GET
#define IPMCIDXINCCCONFIGr_IPMCIDXCLOWMARKERf_GET BCM56800_A0_IPMCIDXINCCCONFIGr_IPMCIDXCLOWMARKERf_GET
#define IPMCIDXINCCCONFIGr_IPMCIDXCLOWMARKERf_SET BCM56800_A0_IPMCIDXINCCCONFIGr_IPMCIDXCLOWMARKERf_SET
#define IPMCIDXINCCCONFIGr_IPMCIDXCHIGHMARKERf_GET BCM56800_A0_IPMCIDXINCCCONFIGr_IPMCIDXCHIGHMARKERf_GET
#define IPMCIDXINCCCONFIGr_IPMCIDXCHIGHMARKERf_SET BCM56800_A0_IPMCIDXINCCCONFIGr_IPMCIDXCHIGHMARKERf_SET
#define READ_IPMCIDXINCCCONFIGr BCM56800_A0_READ_IPMCIDXINCCCONFIGr
#define WRITE_IPMCIDXINCCCONFIGr BCM56800_A0_WRITE_IPMCIDXINCCCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCIDXINCCCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCIDXINCCEN
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     IPMCIDXINCCEN    Per port IPMC Index Increment C Mode Enable bit is controlling IPMC index C increment featurefor all ipmc replicated packet. IPMC index need to bewithin the range defined by IPMCIdxAHighMarker and IPMCIdxALowMarker. New IPMCIndex send will be the original IPMC Index added with replicated packet number.Ex. First packet, New IPMC Index = Original IPMC Index + 1;    Second packet, New IPMC Index = Original IPMC Index + 2;    ....    n-th packet, New IPMC Index = Original IPMC Index + n;1: IPMC Index Increment C Mode En.0: IPMC Index Increment C Mode Disable.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCIDXINCCENr 0x04d80065

#define BCM56800_A0_IPMCIDXINCCENr_SIZE 4

/*
 * This structure should be used to declare and program IPMCIDXINCCEN.
 *
 */
typedef union BCM56800_A0_IPMCIDXINCCENr_s {
	uint32_t v[1];
	uint32_t ipmcidxinccen[1];
	uint32_t _ipmcidxinccen;
} BCM56800_A0_IPMCIDXINCCENr_t;

#define BCM56800_A0_IPMCIDXINCCENr_CLR(r) (r).ipmcidxinccen[0] = 0
#define BCM56800_A0_IPMCIDXINCCENr_SET(r,d) (r).ipmcidxinccen[0] = d
#define BCM56800_A0_IPMCIDXINCCENr_GET(r) (r).ipmcidxinccen[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCIDXINCCENr_IPMCIDXINCCENf_GET(r) (((r).ipmcidxinccen[0]) & 0x1fffff)
#define BCM56800_A0_IPMCIDXINCCENr_IPMCIDXINCCENf_SET(r,f) (r).ipmcidxinccen[0]=(((r).ipmcidxinccen[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IPMCIDXINCCEN.
 *
 */
#define BCM56800_A0_READ_IPMCIDXINCCENr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCIDXINCCENr,(r._ipmcidxinccen))
#define BCM56800_A0_WRITE_IPMCIDXINCCENr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCIDXINCCENr,&(r._ipmcidxinccen))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCIDXINCCENr BCM56800_A0_IPMCIDXINCCENr
#define IPMCIDXINCCENr_SIZE BCM56800_A0_IPMCIDXINCCENr_SIZE
typedef BCM56800_A0_IPMCIDXINCCENr_t IPMCIDXINCCENr_t;
#define IPMCIDXINCCENr_CLR BCM56800_A0_IPMCIDXINCCENr_CLR
#define IPMCIDXINCCENr_SET BCM56800_A0_IPMCIDXINCCENr_SET
#define IPMCIDXINCCENr_GET BCM56800_A0_IPMCIDXINCCENr_GET
#define IPMCIDXINCCENr_IPMCIDXINCCENf_GET BCM56800_A0_IPMCIDXINCCENr_IPMCIDXINCCENf_GET
#define IPMCIDXINCCENr_IPMCIDXINCCENf_SET BCM56800_A0_IPMCIDXINCCENr_IPMCIDXINCCENf_SET
#define READ_IPMCIDXINCCENr BCM56800_A0_READ_IPMCIDXINCCENr
#define WRITE_IPMCIDXINCCENr BCM56800_A0_WRITE_IPMCIDXINCCENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCIDXINCCENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCREPLICATIONCFG0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     REPLICATION_COUNT_EN Per port enable register to start countingipmc replication for specific cos.
 *     REPLICATION_PORT Selected IPMC port between 0 to 9 for acoounting replicating number.
 *     REPLICATION_COS  Selected COS register for acoounting replicating numberon selected IPMC port.Valid COS number: 0 to 7, 14 and 15.
 *     REPLICATION_OVER_LIMIT Replication over limit status register for replication over limit.Once this bit set, a memfail message will be issued. When this bit isset, it needs a read to this register to clear status.
 *     REPLICATION_SRCH_FAIL IPMC replication group or vlan search fail status register is set whenfor any cos happen on each IPMC port 0 to 9. When this bit is set, it needs a read to this register to clear status.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCREPLICATIONCFG0r 0x04d8005f

#define BCM56800_A0_IPMCREPLICATIONCFG0r_SIZE 4

/*
 * This structure should be used to declare and program IPMCREPLICATIONCFG0.
 *
 */
typedef union BCM56800_A0_IPMCREPLICATIONCFG0r_s {
	uint32_t v[1];
	uint32_t ipmcreplicationcfg0[1];
	uint32_t _ipmcreplicationcfg0;
} BCM56800_A0_IPMCREPLICATIONCFG0r_t;

#define BCM56800_A0_IPMCREPLICATIONCFG0r_CLR(r) (r).ipmcreplicationcfg0[0] = 0
#define BCM56800_A0_IPMCREPLICATIONCFG0r_SET(r,d) (r).ipmcreplicationcfg0[0] = d
#define BCM56800_A0_IPMCREPLICATIONCFG0r_GET(r) (r).ipmcreplicationcfg0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_COUNT_ENf_GET(r) (((r).ipmcreplicationcfg0[0]) & 0x1)
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_COUNT_ENf_SET(r,f) (r).ipmcreplicationcfg0[0]=(((r).ipmcreplicationcfg0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_PORTf_GET(r) ((((r).ipmcreplicationcfg0[0]) >> 1) & 0x1f)
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_PORTf_SET(r,f) (r).ipmcreplicationcfg0[0]=(((r).ipmcreplicationcfg0[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_COSf_GET(r) ((((r).ipmcreplicationcfg0[0]) >> 6) & 0xf)
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_COSf_SET(r,f) (r).ipmcreplicationcfg0[0]=(((r).ipmcreplicationcfg0[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_OVER_LIMITf_GET(r) ((((r).ipmcreplicationcfg0[0]) >> 10) & 0x1)
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_OVER_LIMITf_SET(r,f) (r).ipmcreplicationcfg0[0]=(((r).ipmcreplicationcfg0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_SRCH_FAILf_GET(r) ((((r).ipmcreplicationcfg0[0]) >> 11) & 0x3ff)
#define BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_SRCH_FAILf_SET(r,f) (r).ipmcreplicationcfg0[0]=(((r).ipmcreplicationcfg0[0] & ~((uint32_t)0x3ff << 11)) | ((((uint32_t)f) & 0x3ff) << 11))

/*
 * These macros can be used to access IPMCREPLICATIONCFG0.
 *
 */
#define BCM56800_A0_READ_IPMCREPLICATIONCFG0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCREPLICATIONCFG0r,(r._ipmcreplicationcfg0))
#define BCM56800_A0_WRITE_IPMCREPLICATIONCFG0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCREPLICATIONCFG0r,&(r._ipmcreplicationcfg0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCREPLICATIONCFG0r BCM56800_A0_IPMCREPLICATIONCFG0r
#define IPMCREPLICATIONCFG0r_SIZE BCM56800_A0_IPMCREPLICATIONCFG0r_SIZE
typedef BCM56800_A0_IPMCREPLICATIONCFG0r_t IPMCREPLICATIONCFG0r_t;
#define IPMCREPLICATIONCFG0r_CLR BCM56800_A0_IPMCREPLICATIONCFG0r_CLR
#define IPMCREPLICATIONCFG0r_SET BCM56800_A0_IPMCREPLICATIONCFG0r_SET
#define IPMCREPLICATIONCFG0r_GET BCM56800_A0_IPMCREPLICATIONCFG0r_GET
#define IPMCREPLICATIONCFG0r_REPLICATION_COUNT_ENf_GET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_COUNT_ENf_GET
#define IPMCREPLICATIONCFG0r_REPLICATION_COUNT_ENf_SET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_COUNT_ENf_SET
#define IPMCREPLICATIONCFG0r_REPLICATION_PORTf_GET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_PORTf_GET
#define IPMCREPLICATIONCFG0r_REPLICATION_PORTf_SET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_PORTf_SET
#define IPMCREPLICATIONCFG0r_REPLICATION_COSf_GET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_COSf_GET
#define IPMCREPLICATIONCFG0r_REPLICATION_COSf_SET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_COSf_SET
#define IPMCREPLICATIONCFG0r_REPLICATION_OVER_LIMITf_GET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_OVER_LIMITf_GET
#define IPMCREPLICATIONCFG0r_REPLICATION_OVER_LIMITf_SET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_OVER_LIMITf_SET
#define IPMCREPLICATIONCFG0r_REPLICATION_SRCH_FAILf_GET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_SRCH_FAILf_GET
#define IPMCREPLICATIONCFG0r_REPLICATION_SRCH_FAILf_SET BCM56800_A0_IPMCREPLICATIONCFG0r_REPLICATION_SRCH_FAILf_SET
#define READ_IPMCREPLICATIONCFG0r BCM56800_A0_READ_IPMCREPLICATIONCFG0r
#define WRITE_IPMCREPLICATIONCFG0r BCM56800_A0_WRITE_IPMCREPLICATIONCFG0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCREPLICATIONCFG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCREPLICATIONCFG1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     REPLICATION_COUNT_EN Per port enable register to start countingipmc replication for specific cos.
 *     REPLICATION_PORT Selected IPMC port between 10 to 20 for acoounting replicating number.
 *     REPLICATION_COS  Selected COS register for acoounting replicating numberon selected IPMC port.Valid COS number: 0 to 7, 14 and 15.
 *     REPLICATION_OVER_LIMIT Replication over limit status register for replication over limit.Once this bit set, a memfail message will be issued. When this bit isset, it needs a read to this register to clear status.
 *     REPLICATION_SRCH_FAIL IPMC replication group or vlan search fail status register is set whenfor any cos happen on each IPMC port 10 to 20. When this bit is set, it needs a read to this register to clear status.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCREPLICATIONCFG1r 0x04d80061

#define BCM56800_A0_IPMCREPLICATIONCFG1r_SIZE 4

/*
 * This structure should be used to declare and program IPMCREPLICATIONCFG1.
 *
 */
typedef union BCM56800_A0_IPMCREPLICATIONCFG1r_s {
	uint32_t v[1];
	uint32_t ipmcreplicationcfg1[1];
	uint32_t _ipmcreplicationcfg1;
} BCM56800_A0_IPMCREPLICATIONCFG1r_t;

#define BCM56800_A0_IPMCREPLICATIONCFG1r_CLR(r) (r).ipmcreplicationcfg1[0] = 0
#define BCM56800_A0_IPMCREPLICATIONCFG1r_SET(r,d) (r).ipmcreplicationcfg1[0] = d
#define BCM56800_A0_IPMCREPLICATIONCFG1r_GET(r) (r).ipmcreplicationcfg1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_COUNT_ENf_GET(r) (((r).ipmcreplicationcfg1[0]) & 0x1)
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_COUNT_ENf_SET(r,f) (r).ipmcreplicationcfg1[0]=(((r).ipmcreplicationcfg1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_PORTf_GET(r) ((((r).ipmcreplicationcfg1[0]) >> 1) & 0x1f)
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_PORTf_SET(r,f) (r).ipmcreplicationcfg1[0]=(((r).ipmcreplicationcfg1[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_COSf_GET(r) ((((r).ipmcreplicationcfg1[0]) >> 6) & 0xf)
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_COSf_SET(r,f) (r).ipmcreplicationcfg1[0]=(((r).ipmcreplicationcfg1[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_OVER_LIMITf_GET(r) ((((r).ipmcreplicationcfg1[0]) >> 10) & 0x1)
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_OVER_LIMITf_SET(r,f) (r).ipmcreplicationcfg1[0]=(((r).ipmcreplicationcfg1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_SRCH_FAILf_GET(r) ((((r).ipmcreplicationcfg1[0]) >> 11) & 0x7ff)
#define BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_SRCH_FAILf_SET(r,f) (r).ipmcreplicationcfg1[0]=(((r).ipmcreplicationcfg1[0] & ~((uint32_t)0x7ff << 11)) | ((((uint32_t)f) & 0x7ff) << 11))

/*
 * These macros can be used to access IPMCREPLICATIONCFG1.
 *
 */
#define BCM56800_A0_READ_IPMCREPLICATIONCFG1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCREPLICATIONCFG1r,(r._ipmcreplicationcfg1))
#define BCM56800_A0_WRITE_IPMCREPLICATIONCFG1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCREPLICATIONCFG1r,&(r._ipmcreplicationcfg1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCREPLICATIONCFG1r BCM56800_A0_IPMCREPLICATIONCFG1r
#define IPMCREPLICATIONCFG1r_SIZE BCM56800_A0_IPMCREPLICATIONCFG1r_SIZE
typedef BCM56800_A0_IPMCREPLICATIONCFG1r_t IPMCREPLICATIONCFG1r_t;
#define IPMCREPLICATIONCFG1r_CLR BCM56800_A0_IPMCREPLICATIONCFG1r_CLR
#define IPMCREPLICATIONCFG1r_SET BCM56800_A0_IPMCREPLICATIONCFG1r_SET
#define IPMCREPLICATIONCFG1r_GET BCM56800_A0_IPMCREPLICATIONCFG1r_GET
#define IPMCREPLICATIONCFG1r_REPLICATION_COUNT_ENf_GET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_COUNT_ENf_GET
#define IPMCREPLICATIONCFG1r_REPLICATION_COUNT_ENf_SET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_COUNT_ENf_SET
#define IPMCREPLICATIONCFG1r_REPLICATION_PORTf_GET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_PORTf_GET
#define IPMCREPLICATIONCFG1r_REPLICATION_PORTf_SET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_PORTf_SET
#define IPMCREPLICATIONCFG1r_REPLICATION_COSf_GET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_COSf_GET
#define IPMCREPLICATIONCFG1r_REPLICATION_COSf_SET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_COSf_SET
#define IPMCREPLICATIONCFG1r_REPLICATION_OVER_LIMITf_GET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_OVER_LIMITf_GET
#define IPMCREPLICATIONCFG1r_REPLICATION_OVER_LIMITf_SET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_OVER_LIMITf_SET
#define IPMCREPLICATIONCFG1r_REPLICATION_SRCH_FAILf_GET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_SRCH_FAILf_GET
#define IPMCREPLICATIONCFG1r_REPLICATION_SRCH_FAILf_SET BCM56800_A0_IPMCREPLICATIONCFG1r_REPLICATION_SRCH_FAILf_SET
#define READ_IPMCREPLICATIONCFG1r BCM56800_A0_READ_IPMCREPLICATIONCFG1r
#define WRITE_IPMCREPLICATIONCFG1r BCM56800_A0_WRITE_IPMCREPLICATIONCFG1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCREPLICATIONCFG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCREPLICATIONCOUNT0
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     REPLICATION_COUNT Replication Counter for a specified cos of selected egress port how many packetsare doing IPMC replication. Counter will count any replicated packetfor the specified cos on that egrees port between 0 to 9.Counter will keep the total number of whole replication if it is over itsreplication limit. If the limit is not reached for any ipmc replication,Counter will be reset at the end of replication.For the case of replication count over 8191, the counter will not overflow but stay as 8191.
 *     REPLICATION_LIMIT Replication Limit is used on each replication counter to account how manyipmc packet replicated for the specified cos of selected port. A s-bus memfail interruptwill be issued (if REPLICATION_COUNT_EN is enabled) when replication countedis reachiing or over the replication limit.If this limit is set to 0 or over 4096, the internal limit will be use 4k forreplication limit in stead.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCREPLICATIONCOUNT0r 0x04d80060

#define BCM56800_A0_IPMCREPLICATIONCOUNT0r_SIZE 4

/*
 * This structure should be used to declare and program IPMCREPLICATIONCOUNT0.
 *
 */
typedef union BCM56800_A0_IPMCREPLICATIONCOUNT0r_s {
	uint32_t v[1];
	uint32_t ipmcreplicationcount0[1];
	uint32_t _ipmcreplicationcount0;
} BCM56800_A0_IPMCREPLICATIONCOUNT0r_t;

#define BCM56800_A0_IPMCREPLICATIONCOUNT0r_CLR(r) (r).ipmcreplicationcount0[0] = 0
#define BCM56800_A0_IPMCREPLICATIONCOUNT0r_SET(r,d) (r).ipmcreplicationcount0[0] = d
#define BCM56800_A0_IPMCREPLICATIONCOUNT0r_GET(r) (r).ipmcreplicationcount0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCREPLICATIONCOUNT0r_REPLICATION_COUNTf_GET(r) (((r).ipmcreplicationcount0[0]) & 0x1fff)
#define BCM56800_A0_IPMCREPLICATIONCOUNT0r_REPLICATION_COUNTf_SET(r,f) (r).ipmcreplicationcount0[0]=(((r).ipmcreplicationcount0[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM56800_A0_IPMCREPLICATIONCOUNT0r_REPLICATION_LIMITf_GET(r) ((((r).ipmcreplicationcount0[0]) >> 13) & 0x1fff)
#define BCM56800_A0_IPMCREPLICATIONCOUNT0r_REPLICATION_LIMITf_SET(r,f) (r).ipmcreplicationcount0[0]=(((r).ipmcreplicationcount0[0] & ~((uint32_t)0x1fff << 13)) | ((((uint32_t)f) & 0x1fff) << 13))

/*
 * These macros can be used to access IPMCREPLICATIONCOUNT0.
 *
 */
#define BCM56800_A0_READ_IPMCREPLICATIONCOUNT0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCREPLICATIONCOUNT0r,(r._ipmcreplicationcount0))
#define BCM56800_A0_WRITE_IPMCREPLICATIONCOUNT0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCREPLICATIONCOUNT0r,&(r._ipmcreplicationcount0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCREPLICATIONCOUNT0r BCM56800_A0_IPMCREPLICATIONCOUNT0r
#define IPMCREPLICATIONCOUNT0r_SIZE BCM56800_A0_IPMCREPLICATIONCOUNT0r_SIZE
typedef BCM56800_A0_IPMCREPLICATIONCOUNT0r_t IPMCREPLICATIONCOUNT0r_t;
#define IPMCREPLICATIONCOUNT0r_CLR BCM56800_A0_IPMCREPLICATIONCOUNT0r_CLR
#define IPMCREPLICATIONCOUNT0r_SET BCM56800_A0_IPMCREPLICATIONCOUNT0r_SET
#define IPMCREPLICATIONCOUNT0r_GET BCM56800_A0_IPMCREPLICATIONCOUNT0r_GET
#define IPMCREPLICATIONCOUNT0r_REPLICATION_COUNTf_GET BCM56800_A0_IPMCREPLICATIONCOUNT0r_REPLICATION_COUNTf_GET
#define IPMCREPLICATIONCOUNT0r_REPLICATION_COUNTf_SET BCM56800_A0_IPMCREPLICATIONCOUNT0r_REPLICATION_COUNTf_SET
#define IPMCREPLICATIONCOUNT0r_REPLICATION_LIMITf_GET BCM56800_A0_IPMCREPLICATIONCOUNT0r_REPLICATION_LIMITf_GET
#define IPMCREPLICATIONCOUNT0r_REPLICATION_LIMITf_SET BCM56800_A0_IPMCREPLICATIONCOUNT0r_REPLICATION_LIMITf_SET
#define READ_IPMCREPLICATIONCOUNT0r BCM56800_A0_READ_IPMCREPLICATIONCOUNT0r
#define WRITE_IPMCREPLICATIONCOUNT0r BCM56800_A0_WRITE_IPMCREPLICATIONCOUNT0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCREPLICATIONCOUNT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCREPLICATIONCOUNT1
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     REPLICATION_COUNT Replication Counter for a specified cos of selected egress port how many packetsare doing IPMC replication. Counter will count any replicated packetfor the specified cos on that egrees port between 10 to 20.Counter will keep the total number of whole replication if it is over itsreplication limit. If the limit is not reached for any ipmc replication,Counter will be reset at the end of replication.For the case of replication count over 8191, the counter will not overflow but stay as 8191.
 *     REPLICATION_LIMIT Replication Limit is used on each replication counter to account how manyipmc packet replicated for the specified cos of selected port. A s-bus memfail interruptwill be issued (if REPLICATION_COUNT_EN is enabled) when replication countedis reachiing or over the replication limit.If this limit is set to 0 or over 4096, the internal limit will be use 4k forreplication limit in stead.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCREPLICATIONCOUNT1r 0x04d80062

#define BCM56800_A0_IPMCREPLICATIONCOUNT1r_SIZE 4

/*
 * This structure should be used to declare and program IPMCREPLICATIONCOUNT1.
 *
 */
typedef union BCM56800_A0_IPMCREPLICATIONCOUNT1r_s {
	uint32_t v[1];
	uint32_t ipmcreplicationcount1[1];
	uint32_t _ipmcreplicationcount1;
} BCM56800_A0_IPMCREPLICATIONCOUNT1r_t;

#define BCM56800_A0_IPMCREPLICATIONCOUNT1r_CLR(r) (r).ipmcreplicationcount1[0] = 0
#define BCM56800_A0_IPMCREPLICATIONCOUNT1r_SET(r,d) (r).ipmcreplicationcount1[0] = d
#define BCM56800_A0_IPMCREPLICATIONCOUNT1r_GET(r) (r).ipmcreplicationcount1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCREPLICATIONCOUNT1r_REPLICATION_COUNTf_GET(r) (((r).ipmcreplicationcount1[0]) & 0x1fff)
#define BCM56800_A0_IPMCREPLICATIONCOUNT1r_REPLICATION_COUNTf_SET(r,f) (r).ipmcreplicationcount1[0]=(((r).ipmcreplicationcount1[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM56800_A0_IPMCREPLICATIONCOUNT1r_REPLICATION_LIMITf_GET(r) ((((r).ipmcreplicationcount1[0]) >> 13) & 0x1fff)
#define BCM56800_A0_IPMCREPLICATIONCOUNT1r_REPLICATION_LIMITf_SET(r,f) (r).ipmcreplicationcount1[0]=(((r).ipmcreplicationcount1[0] & ~((uint32_t)0x1fff << 13)) | ((((uint32_t)f) & 0x1fff) << 13))

/*
 * These macros can be used to access IPMCREPLICATIONCOUNT1.
 *
 */
#define BCM56800_A0_READ_IPMCREPLICATIONCOUNT1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCREPLICATIONCOUNT1r,(r._ipmcreplicationcount1))
#define BCM56800_A0_WRITE_IPMCREPLICATIONCOUNT1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCREPLICATIONCOUNT1r,&(r._ipmcreplicationcount1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCREPLICATIONCOUNT1r BCM56800_A0_IPMCREPLICATIONCOUNT1r
#define IPMCREPLICATIONCOUNT1r_SIZE BCM56800_A0_IPMCREPLICATIONCOUNT1r_SIZE
typedef BCM56800_A0_IPMCREPLICATIONCOUNT1r_t IPMCREPLICATIONCOUNT1r_t;
#define IPMCREPLICATIONCOUNT1r_CLR BCM56800_A0_IPMCREPLICATIONCOUNT1r_CLR
#define IPMCREPLICATIONCOUNT1r_SET BCM56800_A0_IPMCREPLICATIONCOUNT1r_SET
#define IPMCREPLICATIONCOUNT1r_GET BCM56800_A0_IPMCREPLICATIONCOUNT1r_GET
#define IPMCREPLICATIONCOUNT1r_REPLICATION_COUNTf_GET BCM56800_A0_IPMCREPLICATIONCOUNT1r_REPLICATION_COUNTf_GET
#define IPMCREPLICATIONCOUNT1r_REPLICATION_COUNTf_SET BCM56800_A0_IPMCREPLICATIONCOUNT1r_REPLICATION_COUNTf_SET
#define IPMCREPLICATIONCOUNT1r_REPLICATION_LIMITf_GET BCM56800_A0_IPMCREPLICATIONCOUNT1r_REPLICATION_LIMITf_GET
#define IPMCREPLICATIONCOUNT1r_REPLICATION_LIMITf_SET BCM56800_A0_IPMCREPLICATIONCOUNT1r_REPLICATION_LIMITf_SET
#define READ_IPMCREPLICATIONCOUNT1r BCM56800_A0_READ_IPMCREPLICATIONCOUNT1r
#define WRITE_IPMCREPLICATIONCOUNT1r BCM56800_A0_WRITE_IPMCREPLICATIONCOUNT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCREPLICATIONCOUNT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMCVLANMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               sam registers.
 *
 ******************************************************************************/
#define BCM56800_A0_IPMCVLANMEMDEBUGr 0x10d80008

#define BCM56800_A0_IPMCVLANMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program IPMCVLANMEMDEBUG.
 *
 */
typedef union BCM56800_A0_IPMCVLANMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t ipmcvlanmemdebug[1];
	uint32_t _ipmcvlanmemdebug;
} BCM56800_A0_IPMCVLANMEMDEBUGr_t;

#define BCM56800_A0_IPMCVLANMEMDEBUGr_CLR(r) (r).ipmcvlanmemdebug[0] = 0
#define BCM56800_A0_IPMCVLANMEMDEBUGr_SET(r,d) (r).ipmcvlanmemdebug[0] = d
#define BCM56800_A0_IPMCVLANMEMDEBUGr_GET(r) (r).ipmcvlanmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMCVLANMEMDEBUGr_TMf_GET(r) (((r).ipmcvlanmemdebug[0]) & 0xff)
#define BCM56800_A0_IPMCVLANMEMDEBUGr_TMf_SET(r,f) (r).ipmcvlanmemdebug[0]=(((r).ipmcvlanmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access IPMCVLANMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_IPMCVLANMEMDEBUGr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMCVLANMEMDEBUGr+(i),(r._ipmcvlanmemdebug))
#define BCM56800_A0_WRITE_IPMCVLANMEMDEBUGr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMCVLANMEMDEBUGr+(i),&(r._ipmcvlanmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMCVLANMEMDEBUGr BCM56800_A0_IPMCVLANMEMDEBUGr
#define IPMCVLANMEMDEBUGr_SIZE BCM56800_A0_IPMCVLANMEMDEBUGr_SIZE
typedef BCM56800_A0_IPMCVLANMEMDEBUGr_t IPMCVLANMEMDEBUGr_t;
#define IPMCVLANMEMDEBUGr_CLR BCM56800_A0_IPMCVLANMEMDEBUGr_CLR
#define IPMCVLANMEMDEBUGr_SET BCM56800_A0_IPMCVLANMEMDEBUGr_SET
#define IPMCVLANMEMDEBUGr_GET BCM56800_A0_IPMCVLANMEMDEBUGr_GET
#define IPMCVLANMEMDEBUGr_TMf_GET BCM56800_A0_IPMCVLANMEMDEBUGr_TMf_GET
#define IPMCVLANMEMDEBUGr_TMf_SET BCM56800_A0_IPMCVLANMEMDEBUGr_TMf_SET
#define READ_IPMCVLANMEMDEBUGr BCM56800_A0_READ_IPMCVLANMEMDEBUGr
#define WRITE_IPMCVLANMEMDEBUGr BCM56800_A0_WRITE_IPMCVLANMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMCVLANMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IPMC_L3_MTU
 * BLOCKS:   IPIPE
 * DESC:     IPMC L3 MTU table
 * SIZE:     32
 * FIELDS:
 *     MTU_LEN          L3 MTU length
 *
 ******************************************************************************/
#define BCM56800_A0_IPMC_L3_MTUr 0x0e180640

#define BCM56800_A0_IPMC_L3_MTUr_SIZE 4

/*
 * This structure should be used to declare and program IPMC_L3_MTU.
 *
 */
typedef union BCM56800_A0_IPMC_L3_MTUr_s {
	uint32_t v[1];
	uint32_t ipmc_l3_mtu[1];
	uint32_t _ipmc_l3_mtu;
} BCM56800_A0_IPMC_L3_MTUr_t;

#define BCM56800_A0_IPMC_L3_MTUr_CLR(r) (r).ipmc_l3_mtu[0] = 0
#define BCM56800_A0_IPMC_L3_MTUr_SET(r,d) (r).ipmc_l3_mtu[0] = d
#define BCM56800_A0_IPMC_L3_MTUr_GET(r) (r).ipmc_l3_mtu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPMC_L3_MTUr_MTU_LENf_GET(r) (((r).ipmc_l3_mtu[0]) & 0x3fff)
#define BCM56800_A0_IPMC_L3_MTUr_MTU_LENf_SET(r,f) (r).ipmc_l3_mtu[0]=(((r).ipmc_l3_mtu[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access IPMC_L3_MTU.
 *
 */
#define BCM56800_A0_READ_IPMC_L3_MTUr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_IPMC_L3_MTUr+(i),(r._ipmc_l3_mtu))
#define BCM56800_A0_WRITE_IPMC_L3_MTUr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_IPMC_L3_MTUr+(i),&(r._ipmc_l3_mtu))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPMC_L3_MTUr BCM56800_A0_IPMC_L3_MTUr
#define IPMC_L3_MTUr_SIZE BCM56800_A0_IPMC_L3_MTUr_SIZE
typedef BCM56800_A0_IPMC_L3_MTUr_t IPMC_L3_MTUr_t;
#define IPMC_L3_MTUr_CLR BCM56800_A0_IPMC_L3_MTUr_CLR
#define IPMC_L3_MTUr_SET BCM56800_A0_IPMC_L3_MTUr_SET
#define IPMC_L3_MTUr_GET BCM56800_A0_IPMC_L3_MTUr_GET
#define IPMC_L3_MTUr_MTU_LENf_GET BCM56800_A0_IPMC_L3_MTUr_MTU_LENf_GET
#define IPMC_L3_MTUr_MTU_LENf_SET BCM56800_A0_IPMC_L3_MTUr_MTU_LENf_SET
#define READ_IPMC_L3_MTUr BCM56800_A0_READ_IPMC_L3_MTUr
#define WRITE_IPMC_L3_MTUr BCM56800_A0_WRITE_IPMC_L3_MTUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPMC_L3_MTUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  IPORT_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Port Table, FeatureSpecific-Ethernet
 * SIZE:     86
 * FIELDS:
 *     FILTER_ENABLE    Enable Filtering
 *     VT_MISS_DROP     VLAN translation miss drop
 *     VT_ENABLE        VLAN translation enable
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable
 *     CML              CPU managed learning
 *     PORT_PRI         Port default priority?
 *     IPMC_DO_VLAN     Unknown
 *     V6IPMC_ENABLE    IPv6 IPMC enable
 *     V4IPMC_ENABLE    IPv4 IPMC enable
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     PORT_VID         Port VLAN
 *     HIGIG_PACKET     Port is HiGig port
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module
 *     OUTER_TPID       Outer (switching) VLAN
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs)
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     IGNORE_IPMC_L2_BITMAP Set this bit to disable L2 bridging of IPMC pkts on this port
 *     IGNORE_IPMC_L3_BITMAP Set this bit to disable L3 routing of IPMC pkts on this port
 *     HIGIG_TRUNK      Set this bit if the port is a member if a higig trunkIf set, then HIGIG_PACKET must also be set.
 *     HIGIG_TRUNK_ID   If HIGIG_TRUNK=1, then this is the trunk ID
 *     HIGIG2           If HIGIG_PACKET=1, then this bit indicates if the port is in HiGig2 mode (if HIGIG2=1) or in HiGig mode (if HIGIG2=0)
 *     ALLOW_SRC_MOD    When set, packets whose source modid is equal to my_modid are not dropped
 *     LOCAL_SW_DISABLE When set, local switching is disabled.
 *     RTAG7_PORT_LBN   Per port configurable LBN (Load Balancing Number) for traffic splitting.
 *     RTAG7_HASH_CFG_SEL_TRUNK Selects one of the two sets of hash bits selection configuration for Trunking (LAG). Value 0: Selects config 1 set. Value 1: Selects config2 set.
 *     RTAG7_HASH_CFG_SEL_HIGIG_TRUNK Selects one of the two sets of hash bits selection configuration for HiGig Trunking. Value 0: Selects config 1 set. Value 1: Selects config2 set.
 *     RTAG7_HASH_CFG_SEL_ECMP Selects one of the two sets of hash bits selection configuration for ECMP. Value 0: Selects config 1 set. Value 1: Selects config2 set.
 *     RTAG7_HASH_CFG_SEL_LBID Selects one of the two sets of hash bits selection configuration for LBID to be populated in HiGig2 header. Value 0: Selects config 1 set. Value 1: Selects config2 set.
 *     REMOVE_HG_HDR_SRC_PORT If set to 1, do not forward the pkt to the non-trunk (i.e., not LAG) source port in module header when the MH.SRC_MODID is same as ING_CONFIG.MY_MODID. NOTE: If module header's source port is a trunk (LAG) port, the pkts are not forwarded to its LAG members irrespective of this control bit
 *     RESERVED         Reserved (spare) bits in the PORT_TABLE
 *
 ******************************************************************************/
#define BCM56800_A0_IPORT_TABLEm 0x01101000

#define BCM56800_A0_IPORT_TABLEm_MIN 0
#define BCM56800_A0_IPORT_TABLEm_MAX 20
#define BCM56800_A0_IPORT_TABLEm_CMAX(u) 20
#define BCM56800_A0_IPORT_TABLEm_SIZE 11

/*
 * This structure should be used to declare and program IPORT_TABLE.
 *
 */
typedef union BCM56800_A0_IPORT_TABLEm_s {
	uint32_t v[3];
	uint32_t iport_table[3];
	uint32_t _iport_table;
} BCM56800_A0_IPORT_TABLEm_t;

#define BCM56800_A0_IPORT_TABLEm_CLR(r) CDK_MEMSET(&((r)._iport_table), 0, sizeof(BCM56800_A0_IPORT_TABLEm_t))
#define BCM56800_A0_IPORT_TABLEm_SET(r,i,d) (r).iport_table[i] = d
#define BCM56800_A0_IPORT_TABLEm_GET(r,i) (r).iport_table[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IPORT_TABLEm_FILTER_ENABLEf_GET(r) (((r).iport_table[0]) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_FILTER_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_IPORT_TABLEm_VT_MISS_DROPf_GET(r) ((((r).iport_table[0]) >> 1) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_VT_MISS_DROPf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_IPORT_TABLEm_VT_ENABLEf_GET(r) ((((r).iport_table[0]) >> 2) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_VT_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_IPORT_TABLEm_TRUST_DSCP_V4f_GET(r) ((((r).iport_table[0]) >> 3) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_TRUST_DSCP_V4f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_IPORT_TABLEm_TRUST_DSCP_V6f_GET(r) ((((r).iport_table[0]) >> 4) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_TRUST_DSCP_V6f_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_IPORT_TABLEm_EN_IFILTERf_GET(r) ((((r).iport_table[0]) >> 5) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_EN_IFILTERf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_IPORT_TABLEm_MIRRORf_GET(r) ((((r).iport_table[0]) >> 6) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_MIRRORf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_IPORT_TABLEm_CMLf_GET(r) ((((r).iport_table[0]) >> 7) & 0x7)
#define BCM56800_A0_IPORT_TABLEm_CMLf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56800_A0_IPORT_TABLEm_PORT_PRIf_GET(r) ((((r).iport_table[0]) >> 10) & 0x7)
#define BCM56800_A0_IPORT_TABLEm_PORT_PRIf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56800_A0_IPORT_TABLEm_IPMC_DO_VLANf_GET(r) ((((r).iport_table[0]) >> 13) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_IPMC_DO_VLANf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_IPORT_TABLEm_V6IPMC_ENABLEf_GET(r) ((((r).iport_table[0]) >> 14) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_V6IPMC_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_IPORT_TABLEm_V4IPMC_ENABLEf_GET(r) ((((r).iport_table[0]) >> 15) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_V4IPMC_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_IPORT_TABLEm_V6L3_ENABLEf_GET(r) ((((r).iport_table[0]) >> 16) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_V6L3_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_IPORT_TABLEm_V4L3_ENABLEf_GET(r) ((((r).iport_table[0]) >> 17) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_V4L3_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_IPORT_TABLEm_DROP_BPDUf_GET(r) ((((r).iport_table[0]) >> 18) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_DROP_BPDUf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_IPORT_TABLEm_PORT_DIS_TAGf_GET(r) ((((r).iport_table[0]) >> 19) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_PORT_DIS_TAGf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_GET(r) ((((r).iport_table[0]) >> 20) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET(r) ((((r).iport_table[0]) >> 21) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).iport_table[0]) >> 22) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).iport_table[0]) >> 23) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).iport_table[0]=(((r).iport_table[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_IPORT_TABLEm_PORT_VIDf_GET(r) cdk_field32_get((r).iport_table,24,35)
#define BCM56800_A0_IPORT_TABLEm_PORT_VIDf_SET(r,f) cdk_field32_set((r).iport_table,24,35,f)
#define BCM56800_A0_IPORT_TABLEm_HIGIG_PACKETf_GET(r) ((((r).iport_table[1]) >> 4) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_HIGIG_PACKETf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_IPORT_TABLEm_NNI_PORTf_GET(r) ((((r).iport_table[1]) >> 5) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_NNI_PORTf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).iport_table[1]) >> 6) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_IPORT_TABLEm_MY_MODIDf_GET(r) ((((r).iport_table[1]) >> 7) & 0x7f)
#define BCM56800_A0_IPORT_TABLEm_MY_MODIDf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCM56800_A0_IPORT_TABLEm_OUTER_TPIDf_GET(r) ((((r).iport_table[1]) >> 14) & 0xffff)
#define BCM56800_A0_IPORT_TABLEm_OUTER_TPIDf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0xffff << 14)) | ((((uint32_t)f) & 0xffff) << 14))
#define BCM56800_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_GET(r) ((((r).iport_table[1]) >> 30) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_IPORT_TABLEm_PORT_BRIDGEf_GET(r) ((((r).iport_table[1]) >> 31) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_PORT_BRIDGEf_SET(r,f) (r).iport_table[1]=(((r).iport_table[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_GET(r) (((r).iport_table[2]) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_GET(r) ((((r).iport_table[2]) >> 1) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_IPORT_TABLEm_HIGIG_TRUNKf_GET(r) ((((r).iport_table[2]) >> 2) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_HIGIG_TRUNKf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_IPORT_TABLEm_HIGIG_TRUNK_IDf_GET(r) ((((r).iport_table[2]) >> 3) & 0x7)
#define BCM56800_A0_IPORT_TABLEm_HIGIG_TRUNK_IDf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56800_A0_IPORT_TABLEm_HIGIG2f_GET(r) ((((r).iport_table[2]) >> 6) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_HIGIG2f_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_IPORT_TABLEm_ALLOW_SRC_MODf_GET(r) ((((r).iport_table[2]) >> 7) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_ALLOW_SRC_MODf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_IPORT_TABLEm_LOCAL_SW_DISABLEf_GET(r) ((((r).iport_table[2]) >> 8) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_LOCAL_SW_DISABLEf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_IPORT_TABLEm_RTAG7_PORT_LBNf_GET(r) ((((r).iport_table[2]) >> 9) & 0xf)
#define BCM56800_A0_IPORT_TABLEm_RTAG7_PORT_LBNf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_TRUNKf_GET(r) ((((r).iport_table[2]) >> 13) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_TRUNKf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_GET(r) ((((r).iport_table[2]) >> 14) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_ECMPf_GET(r) ((((r).iport_table[2]) >> 15) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_ECMPf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_LBIDf_GET(r) ((((r).iport_table[2]) >> 16) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_LBIDf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_GET(r) ((((r).iport_table[2]) >> 17) & 0x1)
#define BCM56800_A0_IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_IPORT_TABLEm_RESERVEDf_GET(r) ((((r).iport_table[2]) >> 18) & 0xf)
#define BCM56800_A0_IPORT_TABLEm_RESERVEDf_SET(r,f) (r).iport_table[2]=(((r).iport_table[2] & ~((uint32_t)0xf << 18)) | ((((uint32_t)f) & 0xf) << 18))

/*
 * These macros can be used to access IPORT_TABLE.
 *
 */
#define BCM56800_A0_READ_IPORT_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_IPORT_TABLEm,i,(m._iport_table),3)
#define BCM56800_A0_WRITE_IPORT_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_IPORT_TABLEm,i,&(m._iport_table),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPORT_TABLEm BCM56800_A0_IPORT_TABLEm
#define IPORT_TABLEm_MIN BCM56800_A0_IPORT_TABLEm_MIN
#define IPORT_TABLEm_MAX BCM56800_A0_IPORT_TABLEm_MAX
#define IPORT_TABLEm_CMAX(u) BCM56800_A0_IPORT_TABLEm_CMAX(u)
#define IPORT_TABLEm_SIZE BCM56800_A0_IPORT_TABLEm_SIZE
typedef BCM56800_A0_IPORT_TABLEm_t IPORT_TABLEm_t;
#define IPORT_TABLEm_CLR BCM56800_A0_IPORT_TABLEm_CLR
#define IPORT_TABLEm_SET BCM56800_A0_IPORT_TABLEm_SET
#define IPORT_TABLEm_GET BCM56800_A0_IPORT_TABLEm_GET
#define IPORT_TABLEm_FILTER_ENABLEf_GET BCM56800_A0_IPORT_TABLEm_FILTER_ENABLEf_GET
#define IPORT_TABLEm_FILTER_ENABLEf_SET BCM56800_A0_IPORT_TABLEm_FILTER_ENABLEf_SET
#define IPORT_TABLEm_VT_MISS_DROPf_GET BCM56800_A0_IPORT_TABLEm_VT_MISS_DROPf_GET
#define IPORT_TABLEm_VT_MISS_DROPf_SET BCM56800_A0_IPORT_TABLEm_VT_MISS_DROPf_SET
#define IPORT_TABLEm_VT_ENABLEf_GET BCM56800_A0_IPORT_TABLEm_VT_ENABLEf_GET
#define IPORT_TABLEm_VT_ENABLEf_SET BCM56800_A0_IPORT_TABLEm_VT_ENABLEf_SET
#define IPORT_TABLEm_TRUST_DSCP_V4f_GET BCM56800_A0_IPORT_TABLEm_TRUST_DSCP_V4f_GET
#define IPORT_TABLEm_TRUST_DSCP_V4f_SET BCM56800_A0_IPORT_TABLEm_TRUST_DSCP_V4f_SET
#define IPORT_TABLEm_TRUST_DSCP_V6f_GET BCM56800_A0_IPORT_TABLEm_TRUST_DSCP_V6f_GET
#define IPORT_TABLEm_TRUST_DSCP_V6f_SET BCM56800_A0_IPORT_TABLEm_TRUST_DSCP_V6f_SET
#define IPORT_TABLEm_EN_IFILTERf_GET BCM56800_A0_IPORT_TABLEm_EN_IFILTERf_GET
#define IPORT_TABLEm_EN_IFILTERf_SET BCM56800_A0_IPORT_TABLEm_EN_IFILTERf_SET
#define IPORT_TABLEm_MIRRORf_GET BCM56800_A0_IPORT_TABLEm_MIRRORf_GET
#define IPORT_TABLEm_MIRRORf_SET BCM56800_A0_IPORT_TABLEm_MIRRORf_SET
#define IPORT_TABLEm_CMLf_GET BCM56800_A0_IPORT_TABLEm_CMLf_GET
#define IPORT_TABLEm_CMLf_SET BCM56800_A0_IPORT_TABLEm_CMLf_SET
#define IPORT_TABLEm_PORT_PRIf_GET BCM56800_A0_IPORT_TABLEm_PORT_PRIf_GET
#define IPORT_TABLEm_PORT_PRIf_SET BCM56800_A0_IPORT_TABLEm_PORT_PRIf_SET
#define IPORT_TABLEm_IPMC_DO_VLANf_GET BCM56800_A0_IPORT_TABLEm_IPMC_DO_VLANf_GET
#define IPORT_TABLEm_IPMC_DO_VLANf_SET BCM56800_A0_IPORT_TABLEm_IPMC_DO_VLANf_SET
#define IPORT_TABLEm_V6IPMC_ENABLEf_GET BCM56800_A0_IPORT_TABLEm_V6IPMC_ENABLEf_GET
#define IPORT_TABLEm_V6IPMC_ENABLEf_SET BCM56800_A0_IPORT_TABLEm_V6IPMC_ENABLEf_SET
#define IPORT_TABLEm_V4IPMC_ENABLEf_GET BCM56800_A0_IPORT_TABLEm_V4IPMC_ENABLEf_GET
#define IPORT_TABLEm_V4IPMC_ENABLEf_SET BCM56800_A0_IPORT_TABLEm_V4IPMC_ENABLEf_SET
#define IPORT_TABLEm_V6L3_ENABLEf_GET BCM56800_A0_IPORT_TABLEm_V6L3_ENABLEf_GET
#define IPORT_TABLEm_V6L3_ENABLEf_SET BCM56800_A0_IPORT_TABLEm_V6L3_ENABLEf_SET
#define IPORT_TABLEm_V4L3_ENABLEf_GET BCM56800_A0_IPORT_TABLEm_V4L3_ENABLEf_GET
#define IPORT_TABLEm_V4L3_ENABLEf_SET BCM56800_A0_IPORT_TABLEm_V4L3_ENABLEf_SET
#define IPORT_TABLEm_DROP_BPDUf_GET BCM56800_A0_IPORT_TABLEm_DROP_BPDUf_GET
#define IPORT_TABLEm_DROP_BPDUf_SET BCM56800_A0_IPORT_TABLEm_DROP_BPDUf_SET
#define IPORT_TABLEm_PORT_DIS_TAGf_GET BCM56800_A0_IPORT_TABLEm_PORT_DIS_TAGf_GET
#define IPORT_TABLEm_PORT_DIS_TAGf_SET BCM56800_A0_IPORT_TABLEm_PORT_DIS_TAGf_SET
#define IPORT_TABLEm_PORT_DIS_UNTAGf_GET BCM56800_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_GET
#define IPORT_TABLEm_PORT_DIS_UNTAGf_SET BCM56800_A0_IPORT_TABLEm_PORT_DIS_UNTAGf_SET
#define IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET BCM56800_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_GET
#define IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET BCM56800_A0_IPORT_TABLEm_PASS_CONTROL_FRAMESf_SET
#define IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET BCM56800_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_GET
#define IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET BCM56800_A0_IPORT_TABLEm_SUBNET_BASED_VID_ENABLEf_SET
#define IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET BCM56800_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_GET
#define IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET BCM56800_A0_IPORT_TABLEm_MAC_BASED_VID_ENABLEf_SET
#define IPORT_TABLEm_PORT_VIDf_GET BCM56800_A0_IPORT_TABLEm_PORT_VIDf_GET
#define IPORT_TABLEm_PORT_VIDf_SET BCM56800_A0_IPORT_TABLEm_PORT_VIDf_SET
#define IPORT_TABLEm_HIGIG_PACKETf_GET BCM56800_A0_IPORT_TABLEm_HIGIG_PACKETf_GET
#define IPORT_TABLEm_HIGIG_PACKETf_SET BCM56800_A0_IPORT_TABLEm_HIGIG_PACKETf_SET
#define IPORT_TABLEm_NNI_PORTf_GET BCM56800_A0_IPORT_TABLEm_NNI_PORTf_GET
#define IPORT_TABLEm_NNI_PORTf_SET BCM56800_A0_IPORT_TABLEm_NNI_PORTf_SET
#define IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET BCM56800_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_GET
#define IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET BCM56800_A0_IPORT_TABLEm_MAP_TAG_PKT_PRIORITYf_SET
#define IPORT_TABLEm_MY_MODIDf_GET BCM56800_A0_IPORT_TABLEm_MY_MODIDf_GET
#define IPORT_TABLEm_MY_MODIDf_SET BCM56800_A0_IPORT_TABLEm_MY_MODIDf_SET
#define IPORT_TABLEm_OUTER_TPIDf_GET BCM56800_A0_IPORT_TABLEm_OUTER_TPIDf_GET
#define IPORT_TABLEm_OUTER_TPIDf_SET BCM56800_A0_IPORT_TABLEm_OUTER_TPIDf_SET
#define IPORT_TABLEm_VLAN_PRECEDENCEf_GET BCM56800_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_GET
#define IPORT_TABLEm_VLAN_PRECEDENCEf_SET BCM56800_A0_IPORT_TABLEm_VLAN_PRECEDENCEf_SET
#define IPORT_TABLEm_PORT_BRIDGEf_GET BCM56800_A0_IPORT_TABLEm_PORT_BRIDGEf_GET
#define IPORT_TABLEm_PORT_BRIDGEf_SET BCM56800_A0_IPORT_TABLEm_PORT_BRIDGEf_SET
#define IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_GET BCM56800_A0_IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_GET
#define IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_SET BCM56800_A0_IPORT_TABLEm_IGNORE_IPMC_L2_BITMAPf_SET
#define IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_GET BCM56800_A0_IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_GET
#define IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_SET BCM56800_A0_IPORT_TABLEm_IGNORE_IPMC_L3_BITMAPf_SET
#define IPORT_TABLEm_HIGIG_TRUNKf_GET BCM56800_A0_IPORT_TABLEm_HIGIG_TRUNKf_GET
#define IPORT_TABLEm_HIGIG_TRUNKf_SET BCM56800_A0_IPORT_TABLEm_HIGIG_TRUNKf_SET
#define IPORT_TABLEm_HIGIG_TRUNK_IDf_GET BCM56800_A0_IPORT_TABLEm_HIGIG_TRUNK_IDf_GET
#define IPORT_TABLEm_HIGIG_TRUNK_IDf_SET BCM56800_A0_IPORT_TABLEm_HIGIG_TRUNK_IDf_SET
#define IPORT_TABLEm_HIGIG2f_GET BCM56800_A0_IPORT_TABLEm_HIGIG2f_GET
#define IPORT_TABLEm_HIGIG2f_SET BCM56800_A0_IPORT_TABLEm_HIGIG2f_SET
#define IPORT_TABLEm_ALLOW_SRC_MODf_GET BCM56800_A0_IPORT_TABLEm_ALLOW_SRC_MODf_GET
#define IPORT_TABLEm_ALLOW_SRC_MODf_SET BCM56800_A0_IPORT_TABLEm_ALLOW_SRC_MODf_SET
#define IPORT_TABLEm_LOCAL_SW_DISABLEf_GET BCM56800_A0_IPORT_TABLEm_LOCAL_SW_DISABLEf_GET
#define IPORT_TABLEm_LOCAL_SW_DISABLEf_SET BCM56800_A0_IPORT_TABLEm_LOCAL_SW_DISABLEf_SET
#define IPORT_TABLEm_RTAG7_PORT_LBNf_GET BCM56800_A0_IPORT_TABLEm_RTAG7_PORT_LBNf_GET
#define IPORT_TABLEm_RTAG7_PORT_LBNf_SET BCM56800_A0_IPORT_TABLEm_RTAG7_PORT_LBNf_SET
#define IPORT_TABLEm_RTAG7_HASH_CFG_SEL_TRUNKf_GET BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_TRUNKf_GET
#define IPORT_TABLEm_RTAG7_HASH_CFG_SEL_TRUNKf_SET BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_TRUNKf_SET
#define IPORT_TABLEm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_GET BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_GET
#define IPORT_TABLEm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_SET BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_SET
#define IPORT_TABLEm_RTAG7_HASH_CFG_SEL_ECMPf_GET BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_ECMPf_GET
#define IPORT_TABLEm_RTAG7_HASH_CFG_SEL_ECMPf_SET BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_ECMPf_SET
#define IPORT_TABLEm_RTAG7_HASH_CFG_SEL_LBIDf_GET BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_LBIDf_GET
#define IPORT_TABLEm_RTAG7_HASH_CFG_SEL_LBIDf_SET BCM56800_A0_IPORT_TABLEm_RTAG7_HASH_CFG_SEL_LBIDf_SET
#define IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_GET BCM56800_A0_IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_GET
#define IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_SET BCM56800_A0_IPORT_TABLEm_REMOVE_HG_HDR_SRC_PORTf_SET
#define IPORT_TABLEm_RESERVEDf_GET BCM56800_A0_IPORT_TABLEm_RESERVEDf_GET
#define IPORT_TABLEm_RESERVEDf_SET BCM56800_A0_IPORT_TABLEm_RESERVEDf_SET
#define READ_IPORT_TABLEm BCM56800_A0_READ_IPORT_TABLEm
#define WRITE_IPORT_TABLEm BCM56800_A0_WRITE_IPORT_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IPORT_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR1023
 * BLOCKS:   GXPORT
 * DESC:     Receive 512-1023 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR1023r 0x00f0002a

#define BCM56800_A0_IR1023r_SIZE 8

/*
 * This structure should be used to declare and program IR1023.
 *
 */
typedef union BCM56800_A0_IR1023r_s {
	uint32_t v[2];
	uint32_t ir1023[2];
	uint32_t _ir1023;
} BCM56800_A0_IR1023r_t;

#define BCM56800_A0_IR1023r_CLR(r) CDK_MEMSET(&((r)._ir1023), 0, sizeof(BCM56800_A0_IR1023r_t))
#define BCM56800_A0_IR1023r_SET(r,i,d) (r).ir1023[i] = d
#define BCM56800_A0_IR1023r_GET(r,i) (r).ir1023[i]


/*
 * These macros can be used to access IR1023.
 *
 */
#define BCM56800_A0_READ_IR1023r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR1023r,(r._ir1023))
#define BCM56800_A0_WRITE_IR1023r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR1023r,&(r._ir1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR1023r BCM56800_A0_IR1023r
#define IR1023r_SIZE BCM56800_A0_IR1023r_SIZE
typedef BCM56800_A0_IR1023r_t IR1023r_t;
#define IR1023r_CLR BCM56800_A0_IR1023r_CLR
#define IR1023r_SET BCM56800_A0_IR1023r_SET
#define IR1023r_GET BCM56800_A0_IR1023r_GET
#define READ_IR1023r BCM56800_A0_READ_IR1023r
#define WRITE_IR1023r BCM56800_A0_WRITE_IR1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR127
 * BLOCKS:   GXPORT
 * DESC:     Receive 65-127 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR127r 0x00f00027

#define BCM56800_A0_IR127r_SIZE 8

/*
 * This structure should be used to declare and program IR127.
 *
 */
typedef union BCM56800_A0_IR127r_s {
	uint32_t v[2];
	uint32_t ir127[2];
	uint32_t _ir127;
} BCM56800_A0_IR127r_t;

#define BCM56800_A0_IR127r_CLR(r) CDK_MEMSET(&((r)._ir127), 0, sizeof(BCM56800_A0_IR127r_t))
#define BCM56800_A0_IR127r_SET(r,i,d) (r).ir127[i] = d
#define BCM56800_A0_IR127r_GET(r,i) (r).ir127[i]


/*
 * These macros can be used to access IR127.
 *
 */
#define BCM56800_A0_READ_IR127r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR127r,(r._ir127))
#define BCM56800_A0_WRITE_IR127r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR127r,&(r._ir127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR127r BCM56800_A0_IR127r
#define IR127r_SIZE BCM56800_A0_IR127r_SIZE
typedef BCM56800_A0_IR127r_t IR127r_t;
#define IR127r_CLR BCM56800_A0_IR127r_CLR
#define IR127r_SET BCM56800_A0_IR127r_SET
#define IR127r_GET BCM56800_A0_IR127r_GET
#define READ_IR127r BCM56800_A0_READ_IR127r
#define WRITE_IR127r BCM56800_A0_WRITE_IR127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR1518
 * BLOCKS:   GXPORT
 * DESC:     Receive 1024-1518 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR1518r 0x00f0002b

#define BCM56800_A0_IR1518r_SIZE 8

/*
 * This structure should be used to declare and program IR1518.
 *
 */
typedef union BCM56800_A0_IR1518r_s {
	uint32_t v[2];
	uint32_t ir1518[2];
	uint32_t _ir1518;
} BCM56800_A0_IR1518r_t;

#define BCM56800_A0_IR1518r_CLR(r) CDK_MEMSET(&((r)._ir1518), 0, sizeof(BCM56800_A0_IR1518r_t))
#define BCM56800_A0_IR1518r_SET(r,i,d) (r).ir1518[i] = d
#define BCM56800_A0_IR1518r_GET(r,i) (r).ir1518[i]


/*
 * These macros can be used to access IR1518.
 *
 */
#define BCM56800_A0_READ_IR1518r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR1518r,(r._ir1518))
#define BCM56800_A0_WRITE_IR1518r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR1518r,&(r._ir1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR1518r BCM56800_A0_IR1518r
#define IR1518r_SIZE BCM56800_A0_IR1518r_SIZE
typedef BCM56800_A0_IR1518r_t IR1518r_t;
#define IR1518r_CLR BCM56800_A0_IR1518r_CLR
#define IR1518r_SET BCM56800_A0_IR1518r_SET
#define IR1518r_GET BCM56800_A0_IR1518r_GET
#define READ_IR1518r BCM56800_A0_READ_IR1518r
#define WRITE_IR1518r BCM56800_A0_WRITE_IR1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR16383
 * BLOCKS:   GXPORT
 * DESC:     Receive 9217-16383 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR16383r 0x00f0002f

#define BCM56800_A0_IR16383r_SIZE 8

/*
 * This structure should be used to declare and program IR16383.
 *
 */
typedef union BCM56800_A0_IR16383r_s {
	uint32_t v[2];
	uint32_t ir16383[2];
	uint32_t _ir16383;
} BCM56800_A0_IR16383r_t;

#define BCM56800_A0_IR16383r_CLR(r) CDK_MEMSET(&((r)._ir16383), 0, sizeof(BCM56800_A0_IR16383r_t))
#define BCM56800_A0_IR16383r_SET(r,i,d) (r).ir16383[i] = d
#define BCM56800_A0_IR16383r_GET(r,i) (r).ir16383[i]


/*
 * These macros can be used to access IR16383.
 *
 */
#define BCM56800_A0_READ_IR16383r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR16383r,(r._ir16383))
#define BCM56800_A0_WRITE_IR16383r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR16383r,&(r._ir16383))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR16383r BCM56800_A0_IR16383r
#define IR16383r_SIZE BCM56800_A0_IR16383r_SIZE
typedef BCM56800_A0_IR16383r_t IR16383r_t;
#define IR16383r_CLR BCM56800_A0_IR16383r_CLR
#define IR16383r_SET BCM56800_A0_IR16383r_SET
#define IR16383r_GET BCM56800_A0_IR16383r_GET
#define READ_IR16383r BCM56800_A0_READ_IR16383r
#define WRITE_IR16383r BCM56800_A0_WRITE_IR16383r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR16383r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR2047
 * BLOCKS:   GXPORT
 * DESC:     Receive 1519-2047 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR2047r 0x00f0002c

#define BCM56800_A0_IR2047r_SIZE 8

/*
 * This structure should be used to declare and program IR2047.
 *
 */
typedef union BCM56800_A0_IR2047r_s {
	uint32_t v[2];
	uint32_t ir2047[2];
	uint32_t _ir2047;
} BCM56800_A0_IR2047r_t;

#define BCM56800_A0_IR2047r_CLR(r) CDK_MEMSET(&((r)._ir2047), 0, sizeof(BCM56800_A0_IR2047r_t))
#define BCM56800_A0_IR2047r_SET(r,i,d) (r).ir2047[i] = d
#define BCM56800_A0_IR2047r_GET(r,i) (r).ir2047[i]


/*
 * These macros can be used to access IR2047.
 *
 */
#define BCM56800_A0_READ_IR2047r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR2047r,(r._ir2047))
#define BCM56800_A0_WRITE_IR2047r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR2047r,&(r._ir2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR2047r BCM56800_A0_IR2047r
#define IR2047r_SIZE BCM56800_A0_IR2047r_SIZE
typedef BCM56800_A0_IR2047r_t IR2047r_t;
#define IR2047r_CLR BCM56800_A0_IR2047r_CLR
#define IR2047r_SET BCM56800_A0_IR2047r_SET
#define IR2047r_GET BCM56800_A0_IR2047r_GET
#define READ_IR2047r BCM56800_A0_READ_IR2047r
#define WRITE_IR2047r BCM56800_A0_WRITE_IR2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR255
 * BLOCKS:   GXPORT
 * DESC:     Receive 128-255 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR255r 0x00f00028

#define BCM56800_A0_IR255r_SIZE 8

/*
 * This structure should be used to declare and program IR255.
 *
 */
typedef union BCM56800_A0_IR255r_s {
	uint32_t v[2];
	uint32_t ir255[2];
	uint32_t _ir255;
} BCM56800_A0_IR255r_t;

#define BCM56800_A0_IR255r_CLR(r) CDK_MEMSET(&((r)._ir255), 0, sizeof(BCM56800_A0_IR255r_t))
#define BCM56800_A0_IR255r_SET(r,i,d) (r).ir255[i] = d
#define BCM56800_A0_IR255r_GET(r,i) (r).ir255[i]


/*
 * These macros can be used to access IR255.
 *
 */
#define BCM56800_A0_READ_IR255r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR255r,(r._ir255))
#define BCM56800_A0_WRITE_IR255r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR255r,&(r._ir255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR255r BCM56800_A0_IR255r
#define IR255r_SIZE BCM56800_A0_IR255r_SIZE
typedef BCM56800_A0_IR255r_t IR255r_t;
#define IR255r_CLR BCM56800_A0_IR255r_CLR
#define IR255r_SET BCM56800_A0_IR255r_SET
#define IR255r_GET BCM56800_A0_IR255r_GET
#define READ_IR255r BCM56800_A0_READ_IR255r
#define WRITE_IR255r BCM56800_A0_WRITE_IR255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR4095
 * BLOCKS:   GXPORT
 * DESC:     Receive 2048-4095 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR4095r 0x00f0002d

#define BCM56800_A0_IR4095r_SIZE 8

/*
 * This structure should be used to declare and program IR4095.
 *
 */
typedef union BCM56800_A0_IR4095r_s {
	uint32_t v[2];
	uint32_t ir4095[2];
	uint32_t _ir4095;
} BCM56800_A0_IR4095r_t;

#define BCM56800_A0_IR4095r_CLR(r) CDK_MEMSET(&((r)._ir4095), 0, sizeof(BCM56800_A0_IR4095r_t))
#define BCM56800_A0_IR4095r_SET(r,i,d) (r).ir4095[i] = d
#define BCM56800_A0_IR4095r_GET(r,i) (r).ir4095[i]


/*
 * These macros can be used to access IR4095.
 *
 */
#define BCM56800_A0_READ_IR4095r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR4095r,(r._ir4095))
#define BCM56800_A0_WRITE_IR4095r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR4095r,&(r._ir4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR4095r BCM56800_A0_IR4095r
#define IR4095r_SIZE BCM56800_A0_IR4095r_SIZE
typedef BCM56800_A0_IR4095r_t IR4095r_t;
#define IR4095r_CLR BCM56800_A0_IR4095r_CLR
#define IR4095r_SET BCM56800_A0_IR4095r_SET
#define IR4095r_GET BCM56800_A0_IR4095r_GET
#define READ_IR4095r BCM56800_A0_READ_IR4095r
#define WRITE_IR4095r BCM56800_A0_WRITE_IR4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR511
 * BLOCKS:   GXPORT
 * DESC:     Receive 256-511 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR511r 0x00f00029

#define BCM56800_A0_IR511r_SIZE 8

/*
 * This structure should be used to declare and program IR511.
 *
 */
typedef union BCM56800_A0_IR511r_s {
	uint32_t v[2];
	uint32_t ir511[2];
	uint32_t _ir511;
} BCM56800_A0_IR511r_t;

#define BCM56800_A0_IR511r_CLR(r) CDK_MEMSET(&((r)._ir511), 0, sizeof(BCM56800_A0_IR511r_t))
#define BCM56800_A0_IR511r_SET(r,i,d) (r).ir511[i] = d
#define BCM56800_A0_IR511r_GET(r,i) (r).ir511[i]


/*
 * These macros can be used to access IR511.
 *
 */
#define BCM56800_A0_READ_IR511r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR511r,(r._ir511))
#define BCM56800_A0_WRITE_IR511r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR511r,&(r._ir511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR511r BCM56800_A0_IR511r
#define IR511r_SIZE BCM56800_A0_IR511r_SIZE
typedef BCM56800_A0_IR511r_t IR511r_t;
#define IR511r_CLR BCM56800_A0_IR511r_CLR
#define IR511r_SET BCM56800_A0_IR511r_SET
#define IR511r_GET BCM56800_A0_IR511r_GET
#define READ_IR511r BCM56800_A0_READ_IR511r
#define WRITE_IR511r BCM56800_A0_WRITE_IR511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR64
 * BLOCKS:   GXPORT
 * DESC:     Receive 64 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR64r 0x00f00026

#define BCM56800_A0_IR64r_SIZE 8

/*
 * This structure should be used to declare and program IR64.
 *
 */
typedef union BCM56800_A0_IR64r_s {
	uint32_t v[2];
	uint32_t ir64[2];
	uint32_t _ir64;
} BCM56800_A0_IR64r_t;

#define BCM56800_A0_IR64r_CLR(r) CDK_MEMSET(&((r)._ir64), 0, sizeof(BCM56800_A0_IR64r_t))
#define BCM56800_A0_IR64r_SET(r,i,d) (r).ir64[i] = d
#define BCM56800_A0_IR64r_GET(r,i) (r).ir64[i]


/*
 * These macros can be used to access IR64.
 *
 */
#define BCM56800_A0_READ_IR64r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR64r,(r._ir64))
#define BCM56800_A0_WRITE_IR64r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR64r,&(r._ir64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR64r BCM56800_A0_IR64r
#define IR64r_SIZE BCM56800_A0_IR64r_SIZE
typedef BCM56800_A0_IR64r_t IR64r_t;
#define IR64r_CLR BCM56800_A0_IR64r_CLR
#define IR64r_SET BCM56800_A0_IR64r_SET
#define IR64r_GET BCM56800_A0_IR64r_GET
#define READ_IR64r BCM56800_A0_READ_IR64r
#define WRITE_IR64r BCM56800_A0_WRITE_IR64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IR9216
 * BLOCKS:   GXPORT
 * DESC:     Receive 4096-9216 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IR9216r 0x00f0002e

#define BCM56800_A0_IR9216r_SIZE 8

/*
 * This structure should be used to declare and program IR9216.
 *
 */
typedef union BCM56800_A0_IR9216r_s {
	uint32_t v[2];
	uint32_t ir9216[2];
	uint32_t _ir9216;
} BCM56800_A0_IR9216r_t;

#define BCM56800_A0_IR9216r_CLR(r) CDK_MEMSET(&((r)._ir9216), 0, sizeof(BCM56800_A0_IR9216r_t))
#define BCM56800_A0_IR9216r_SET(r,i,d) (r).ir9216[i] = d
#define BCM56800_A0_IR9216r_GET(r,i) (r).ir9216[i]


/*
 * These macros can be used to access IR9216.
 *
 */
#define BCM56800_A0_READ_IR9216r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IR9216r,(r._ir9216))
#define BCM56800_A0_WRITE_IR9216r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IR9216r,&(r._ir9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IR9216r BCM56800_A0_IR9216r
#define IR9216r_SIZE BCM56800_A0_IR9216r_SIZE
typedef BCM56800_A0_IR9216r_t IR9216r_t;
#define IR9216r_CLR BCM56800_A0_IR9216r_CLR
#define IR9216r_SET BCM56800_A0_IR9216r_SET
#define IR9216r_GET BCM56800_A0_IR9216r_GET
#define READ_IR9216r BCM56800_A0_READ_IR9216r
#define WRITE_IR9216r BCM56800_A0_WRITE_IR9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IR9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRBCA
 * BLOCKS:   GXPORT
 * DESC:     Receive broadcast packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRBCAr 0x00f00034

#define BCM56800_A0_IRBCAr_SIZE 8

/*
 * This structure should be used to declare and program IRBCA.
 *
 */
typedef union BCM56800_A0_IRBCAr_s {
	uint32_t v[2];
	uint32_t irbca[2];
	uint32_t _irbca;
} BCM56800_A0_IRBCAr_t;

#define BCM56800_A0_IRBCAr_CLR(r) CDK_MEMSET(&((r)._irbca), 0, sizeof(BCM56800_A0_IRBCAr_t))
#define BCM56800_A0_IRBCAr_SET(r,i,d) (r).irbca[i] = d
#define BCM56800_A0_IRBCAr_GET(r,i) (r).irbca[i]


/*
 * These macros can be used to access IRBCA.
 *
 */
#define BCM56800_A0_READ_IRBCAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRBCAr,(r._irbca))
#define BCM56800_A0_WRITE_IRBCAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRBCAr,&(r._irbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRBCAr BCM56800_A0_IRBCAr
#define IRBCAr_SIZE BCM56800_A0_IRBCAr_SIZE
typedef BCM56800_A0_IRBCAr_t IRBCAr_t;
#define IRBCAr_CLR BCM56800_A0_IRBCAr_CLR
#define IRBCAr_SET BCM56800_A0_IRBCAr_SET
#define IRBCAr_GET BCM56800_A0_IRBCAr_GET
#define READ_IRBCAr BCM56800_A0_READ_IRBCAr
#define WRITE_IRBCAr BCM56800_A0_WRITE_IRBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRBYT
 * BLOCKS:   GXPORT
 * DESC:     Receive byte counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRBYTr 0x00f0003d

#define BCM56800_A0_IRBYTr_SIZE 8

/*
 * This structure should be used to declare and program IRBYT.
 *
 */
typedef union BCM56800_A0_IRBYTr_s {
	uint32_t v[2];
	uint32_t irbyt[2];
	uint32_t _irbyt;
} BCM56800_A0_IRBYTr_t;

#define BCM56800_A0_IRBYTr_CLR(r) CDK_MEMSET(&((r)._irbyt), 0, sizeof(BCM56800_A0_IRBYTr_t))
#define BCM56800_A0_IRBYTr_SET(r,i,d) (r).irbyt[i] = d
#define BCM56800_A0_IRBYTr_GET(r,i) (r).irbyt[i]


/*
 * These macros can be used to access IRBYT.
 *
 */
#define BCM56800_A0_READ_IRBYTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRBYTr,(r._irbyt))
#define BCM56800_A0_WRITE_IRBYTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRBYTr,&(r._irbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRBYTr BCM56800_A0_IRBYTr
#define IRBYTr_SIZE BCM56800_A0_IRBYTr_SIZE
typedef BCM56800_A0_IRBYTr_t IRBYTr_t;
#define IRBYTr_CLR BCM56800_A0_IRBYTr_CLR
#define IRBYTr_SET BCM56800_A0_IRBYTr_SET
#define IRBYTr_GET BCM56800_A0_IRBYTr_GET
#define READ_IRBYTr BCM56800_A0_READ_IRBYTr
#define WRITE_IRBYTr BCM56800_A0_WRITE_IRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRERBYT
 * BLOCKS:   GXPORT
 * DESC:     Receive error byte counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRERBYTr 0x00f00040

#define BCM56800_A0_IRERBYTr_SIZE 8

/*
 * This structure should be used to declare and program IRERBYT.
 *
 */
typedef union BCM56800_A0_IRERBYTr_s {
	uint32_t v[2];
	uint32_t irerbyt[2];
	uint32_t _irerbyt;
} BCM56800_A0_IRERBYTr_t;

#define BCM56800_A0_IRERBYTr_CLR(r) CDK_MEMSET(&((r)._irerbyt), 0, sizeof(BCM56800_A0_IRERBYTr_t))
#define BCM56800_A0_IRERBYTr_SET(r,i,d) (r).irerbyt[i] = d
#define BCM56800_A0_IRERBYTr_GET(r,i) (r).irerbyt[i]


/*
 * These macros can be used to access IRERBYT.
 *
 */
#define BCM56800_A0_READ_IRERBYTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRERBYTr,(r._irerbyt))
#define BCM56800_A0_WRITE_IRERBYTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRERBYTr,&(r._irerbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRERBYTr BCM56800_A0_IRERBYTr
#define IRERBYTr_SIZE BCM56800_A0_IRERBYTr_SIZE
typedef BCM56800_A0_IRERBYTr_t IRERBYTr_t;
#define IRERBYTr_CLR BCM56800_A0_IRERBYTr_CLR
#define IRERBYTr_SET BCM56800_A0_IRERBYTr_SET
#define IRERBYTr_GET BCM56800_A0_IRERBYTr_GET
#define READ_IRERBYTr BCM56800_A0_READ_IRERBYTr
#define WRITE_IRERBYTr BCM56800_A0_WRITE_IRERBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRERBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRERPKT
 * BLOCKS:   GXPORT
 * DESC:     Received framing error counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRERPKTr 0x00f00041

#define BCM56800_A0_IRERPKTr_SIZE 8

/*
 * This structure should be used to declare and program IRERPKT.
 *
 */
typedef union BCM56800_A0_IRERPKTr_s {
	uint32_t v[2];
	uint32_t irerpkt[2];
	uint32_t _irerpkt;
} BCM56800_A0_IRERPKTr_t;

#define BCM56800_A0_IRERPKTr_CLR(r) CDK_MEMSET(&((r)._irerpkt), 0, sizeof(BCM56800_A0_IRERPKTr_t))
#define BCM56800_A0_IRERPKTr_SET(r,i,d) (r).irerpkt[i] = d
#define BCM56800_A0_IRERPKTr_GET(r,i) (r).irerpkt[i]


/*
 * These macros can be used to access IRERPKT.
 *
 */
#define BCM56800_A0_READ_IRERPKTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRERPKTr,(r._irerpkt))
#define BCM56800_A0_WRITE_IRERPKTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRERPKTr,&(r._irerpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRERPKTr BCM56800_A0_IRERPKTr
#define IRERPKTr_SIZE BCM56800_A0_IRERPKTr_SIZE
typedef BCM56800_A0_IRERPKTr_t IRERPKTr_t;
#define IRERPKTr_CLR BCM56800_A0_IRERPKTr_CLR
#define IRERPKTr_SET BCM56800_A0_IRERPKTr_SET
#define IRERPKTr_GET BCM56800_A0_IRERPKTr_GET
#define READ_IRERPKTr BCM56800_A0_READ_IRERPKTr
#define WRITE_IRERPKTr BCM56800_A0_WRITE_IRERPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRERPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRFCS
 * BLOCKS:   GXPORT
 * DESC:     Receive FCS(CRC) error packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRFCSr 0x00f00032

#define BCM56800_A0_IRFCSr_SIZE 8

/*
 * This structure should be used to declare and program IRFCS.
 *
 */
typedef union BCM56800_A0_IRFCSr_s {
	uint32_t v[2];
	uint32_t irfcs[2];
	uint32_t _irfcs;
} BCM56800_A0_IRFCSr_t;

#define BCM56800_A0_IRFCSr_CLR(r) CDK_MEMSET(&((r)._irfcs), 0, sizeof(BCM56800_A0_IRFCSr_t))
#define BCM56800_A0_IRFCSr_SET(r,i,d) (r).irfcs[i] = d
#define BCM56800_A0_IRFCSr_GET(r,i) (r).irfcs[i]


/*
 * These macros can be used to access IRFCS.
 *
 */
#define BCM56800_A0_READ_IRFCSr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRFCSr,(r._irfcs))
#define BCM56800_A0_WRITE_IRFCSr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRFCSr,&(r._irfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRFCSr BCM56800_A0_IRFCSr
#define IRFCSr_SIZE BCM56800_A0_IRFCSr_SIZE
typedef BCM56800_A0_IRFCSr_t IRFCSr_t;
#define IRFCSr_CLR BCM56800_A0_IRFCSr_CLR
#define IRFCSr_SET BCM56800_A0_IRFCSr_SET
#define IRFCSr_GET BCM56800_A0_IRFCSr_GET
#define READ_IRFCSr BCM56800_A0_READ_IRFCSr
#define WRITE_IRFCSr BCM56800_A0_WRITE_IRFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRFLR
 * BLOCKS:   GXPORT
 * DESC:     Receive length out-of-range packet counter.


 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRFLRr 0x00f0003a

#define BCM56800_A0_IRFLRr_SIZE 8

/*
 * This structure should be used to declare and program IRFLR.
 *
 */
typedef union BCM56800_A0_IRFLRr_s {
	uint32_t v[2];
	uint32_t irflr[2];
	uint32_t _irflr;
} BCM56800_A0_IRFLRr_t;

#define BCM56800_A0_IRFLRr_CLR(r) CDK_MEMSET(&((r)._irflr), 0, sizeof(BCM56800_A0_IRFLRr_t))
#define BCM56800_A0_IRFLRr_SET(r,i,d) (r).irflr[i] = d
#define BCM56800_A0_IRFLRr_GET(r,i) (r).irflr[i]


/*
 * These macros can be used to access IRFLR.
 *
 */
#define BCM56800_A0_READ_IRFLRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRFLRr,(r._irflr))
#define BCM56800_A0_WRITE_IRFLRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRFLRr,&(r._irflr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRFLRr BCM56800_A0_IRFLRr
#define IRFLRr_SIZE BCM56800_A0_IRFLRr_SIZE
typedef BCM56800_A0_IRFLRr_t IRFLRr_t;
#define IRFLRr_CLR BCM56800_A0_IRFLRr_CLR
#define IRFLRr_SET BCM56800_A0_IRFLRr_SET
#define IRFLRr_GET BCM56800_A0_IRFLRr_GET
#define READ_IRFLRr BCM56800_A0_READ_IRFLRr
#define WRITE_IRFLRr BCM56800_A0_WRITE_IRFLRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRFLRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRFRG
 * BLOCKS:   GXPORT
 * DESC:     Receive fragment counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRFRGr 0x00f0003f

#define BCM56800_A0_IRFRGr_SIZE 8

/*
 * This structure should be used to declare and program IRFRG.
 *
 */
typedef union BCM56800_A0_IRFRGr_s {
	uint32_t v[2];
	uint32_t irfrg[2];
	uint32_t _irfrg;
} BCM56800_A0_IRFRGr_t;

#define BCM56800_A0_IRFRGr_CLR(r) CDK_MEMSET(&((r)._irfrg), 0, sizeof(BCM56800_A0_IRFRGr_t))
#define BCM56800_A0_IRFRGr_SET(r,i,d) (r).irfrg[i] = d
#define BCM56800_A0_IRFRGr_GET(r,i) (r).irfrg[i]


/*
 * These macros can be used to access IRFRG.
 *
 */
#define BCM56800_A0_READ_IRFRGr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRFRGr,(r._irfrg))
#define BCM56800_A0_WRITE_IRFRGr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRFRGr,&(r._irfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRFRGr BCM56800_A0_IRFRGr
#define IRFRGr_SIZE BCM56800_A0_IRFRGr_SIZE
typedef BCM56800_A0_IRFRGr_t IRFRGr_t;
#define IRFRGr_CLR BCM56800_A0_IRFRGr_CLR
#define IRFRGr_SET BCM56800_A0_IRFRGr_SET
#define IRFRGr_GET BCM56800_A0_IRFRGr_GET
#define READ_IRFRGr BCM56800_A0_READ_IRFRGr
#define WRITE_IRFRGr BCM56800_A0_WRITE_IRFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRJBR
 * BLOCKS:   GXPORT
 * DESC:     Receive jabber packer counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRJBRr 0x00f00038

#define BCM56800_A0_IRJBRr_SIZE 8

/*
 * This structure should be used to declare and program IRJBR.
 *
 */
typedef union BCM56800_A0_IRJBRr_s {
	uint32_t v[2];
	uint32_t irjbr[2];
	uint32_t _irjbr;
} BCM56800_A0_IRJBRr_t;

#define BCM56800_A0_IRJBRr_CLR(r) CDK_MEMSET(&((r)._irjbr), 0, sizeof(BCM56800_A0_IRJBRr_t))
#define BCM56800_A0_IRJBRr_SET(r,i,d) (r).irjbr[i] = d
#define BCM56800_A0_IRJBRr_GET(r,i) (r).irjbr[i]


/*
 * These macros can be used to access IRJBR.
 *
 */
#define BCM56800_A0_READ_IRJBRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRJBRr,(r._irjbr))
#define BCM56800_A0_WRITE_IRJBRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRJBRr,&(r._irjbr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRJBRr BCM56800_A0_IRJBRr
#define IRJBRr_SIZE BCM56800_A0_IRJBRr_SIZE
typedef BCM56800_A0_IRJBRr_t IRJBRr_t;
#define IRJBRr_CLR BCM56800_A0_IRJBRr_CLR
#define IRJBRr_SET BCM56800_A0_IRJBRr_SET
#define IRJBRr_GET BCM56800_A0_IRJBRr_GET
#define READ_IRJBRr BCM56800_A0_READ_IRJBRr
#define WRITE_IRJBRr BCM56800_A0_WRITE_IRJBRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRJBRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRJUNK
 * BLOCKS:   GXPORT
 * DESC:     Receive interpacket junk counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRJUNKr 0x00f00042

#define BCM56800_A0_IRJUNKr_SIZE 8

/*
 * This structure should be used to declare and program IRJUNK.
 *
 */
typedef union BCM56800_A0_IRJUNKr_s {
	uint32_t v[2];
	uint32_t irjunk[2];
	uint32_t _irjunk;
} BCM56800_A0_IRJUNKr_t;

#define BCM56800_A0_IRJUNKr_CLR(r) CDK_MEMSET(&((r)._irjunk), 0, sizeof(BCM56800_A0_IRJUNKr_t))
#define BCM56800_A0_IRJUNKr_SET(r,i,d) (r).irjunk[i] = d
#define BCM56800_A0_IRJUNKr_GET(r,i) (r).irjunk[i]


/*
 * These macros can be used to access IRJUNK.
 *
 */
#define BCM56800_A0_READ_IRJUNKr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRJUNKr,(r._irjunk))
#define BCM56800_A0_WRITE_IRJUNKr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRJUNKr,&(r._irjunk))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRJUNKr BCM56800_A0_IRJUNKr
#define IRJUNKr_SIZE BCM56800_A0_IRJUNKr_SIZE
typedef BCM56800_A0_IRJUNKr_t IRJUNKr_t;
#define IRJUNKr_CLR BCM56800_A0_IRJUNKr_CLR
#define IRJUNKr_SET BCM56800_A0_IRJUNKr_SET
#define IRJUNKr_GET BCM56800_A0_IRJUNKr_GET
#define READ_IRJUNKr BCM56800_A0_READ_IRJUNKr
#define WRITE_IRJUNKr BCM56800_A0_WRITE_IRJUNKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRJUNKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRMAX
 * BLOCKS:   GXPORT
 * DESC:     Receive max size packet counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRMAXr 0x00f00030

#define BCM56800_A0_IRMAXr_SIZE 8

/*
 * This structure should be used to declare and program IRMAX.
 *
 */
typedef union BCM56800_A0_IRMAXr_s {
	uint32_t v[2];
	uint32_t irmax[2];
	uint32_t _irmax;
} BCM56800_A0_IRMAXr_t;

#define BCM56800_A0_IRMAXr_CLR(r) CDK_MEMSET(&((r)._irmax), 0, sizeof(BCM56800_A0_IRMAXr_t))
#define BCM56800_A0_IRMAXr_SET(r,i,d) (r).irmax[i] = d
#define BCM56800_A0_IRMAXr_GET(r,i) (r).irmax[i]


/*
 * These macros can be used to access IRMAX.
 *
 */
#define BCM56800_A0_READ_IRMAXr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRMAXr,(r._irmax))
#define BCM56800_A0_WRITE_IRMAXr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRMAXr,&(r._irmax))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRMAXr BCM56800_A0_IRMAXr
#define IRMAXr_SIZE BCM56800_A0_IRMAXr_SIZE
typedef BCM56800_A0_IRMAXr_t IRMAXr_t;
#define IRMAXr_CLR BCM56800_A0_IRMAXr_CLR
#define IRMAXr_SET BCM56800_A0_IRMAXr_SET
#define IRMAXr_GET BCM56800_A0_IRMAXr_GET
#define READ_IRMAXr BCM56800_A0_READ_IRMAXr
#define WRITE_IRMAXr BCM56800_A0_WRITE_IRMAXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRMAXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRMCA
 * BLOCKS:   GXPORT
 * DESC:     Receive multicast packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRMCAr 0x00f00033

#define BCM56800_A0_IRMCAr_SIZE 8

/*
 * This structure should be used to declare and program IRMCA.
 *
 */
typedef union BCM56800_A0_IRMCAr_s {
	uint32_t v[2];
	uint32_t irmca[2];
	uint32_t _irmca;
} BCM56800_A0_IRMCAr_t;

#define BCM56800_A0_IRMCAr_CLR(r) CDK_MEMSET(&((r)._irmca), 0, sizeof(BCM56800_A0_IRMCAr_t))
#define BCM56800_A0_IRMCAr_SET(r,i,d) (r).irmca[i] = d
#define BCM56800_A0_IRMCAr_GET(r,i) (r).irmca[i]


/*
 * These macros can be used to access IRMCA.
 *
 */
#define BCM56800_A0_READ_IRMCAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRMCAr,(r._irmca))
#define BCM56800_A0_WRITE_IRMCAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRMCAr,&(r._irmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRMCAr BCM56800_A0_IRMCAr
#define IRMCAr_SIZE BCM56800_A0_IRMCAr_SIZE
typedef BCM56800_A0_IRMCAr_t IRMCAr_t;
#define IRMCAr_CLR BCM56800_A0_IRMCAr_CLR
#define IRMCAr_SET BCM56800_A0_IRMCAr_SET
#define IRMCAr_GET BCM56800_A0_IRMCAr_GET
#define READ_IRMCAr BCM56800_A0_READ_IRMCAr
#define WRITE_IRMCAr BCM56800_A0_WRITE_IRMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRMEB
 * BLOCKS:   GXPORT
 * DESC:     Receive MTU size check failed bad packet counter.

 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRMEBr 0x00f0003c

#define BCM56800_A0_IRMEBr_SIZE 8

/*
 * This structure should be used to declare and program IRMEB.
 *
 */
typedef union BCM56800_A0_IRMEBr_s {
	uint32_t v[2];
	uint32_t irmeb[2];
	uint32_t _irmeb;
} BCM56800_A0_IRMEBr_t;

#define BCM56800_A0_IRMEBr_CLR(r) CDK_MEMSET(&((r)._irmeb), 0, sizeof(BCM56800_A0_IRMEBr_t))
#define BCM56800_A0_IRMEBr_SET(r,i,d) (r).irmeb[i] = d
#define BCM56800_A0_IRMEBr_GET(r,i) (r).irmeb[i]


/*
 * These macros can be used to access IRMEB.
 *
 */
#define BCM56800_A0_READ_IRMEBr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRMEBr,(r._irmeb))
#define BCM56800_A0_WRITE_IRMEBr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRMEBr,&(r._irmeb))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRMEBr BCM56800_A0_IRMEBr
#define IRMEBr_SIZE BCM56800_A0_IRMEBr_SIZE
typedef BCM56800_A0_IRMEBr_t IRMEBr_t;
#define IRMEBr_CLR BCM56800_A0_IRMEBr_CLR
#define IRMEBr_SET BCM56800_A0_IRMEBr_SET
#define IRMEBr_GET BCM56800_A0_IRMEBr_GET
#define READ_IRMEBr BCM56800_A0_READ_IRMEBr
#define WRITE_IRMEBr BCM56800_A0_WRITE_IRMEBr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRMEBr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRMEG
 * BLOCKS:   GXPORT
 * DESC:     Receive MTU size check failed good packet counter.

 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRMEGr 0x00f0003b

#define BCM56800_A0_IRMEGr_SIZE 8

/*
 * This structure should be used to declare and program IRMEG.
 *
 */
typedef union BCM56800_A0_IRMEGr_s {
	uint32_t v[2];
	uint32_t irmeg[2];
	uint32_t _irmeg;
} BCM56800_A0_IRMEGr_t;

#define BCM56800_A0_IRMEGr_CLR(r) CDK_MEMSET(&((r)._irmeg), 0, sizeof(BCM56800_A0_IRMEGr_t))
#define BCM56800_A0_IRMEGr_SET(r,i,d) (r).irmeg[i] = d
#define BCM56800_A0_IRMEGr_GET(r,i) (r).irmeg[i]


/*
 * These macros can be used to access IRMEG.
 *
 */
#define BCM56800_A0_READ_IRMEGr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRMEGr,(r._irmeg))
#define BCM56800_A0_WRITE_IRMEGr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRMEGr,&(r._irmeg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRMEGr BCM56800_A0_IRMEGr
#define IRMEGr_SIZE BCM56800_A0_IRMEGr_SIZE
typedef BCM56800_A0_IRMEGr_t IRMEGr_t;
#define IRMEGr_CLR BCM56800_A0_IRMEGr_CLR
#define IRMEGr_SET BCM56800_A0_IRMEGr_SET
#define IRMEGr_GET BCM56800_A0_IRMEGr_GET
#define READ_IRMEGr BCM56800_A0_READ_IRMEGr
#define WRITE_IRMEGr BCM56800_A0_WRITE_IRMEGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRMEGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IROVR
 * BLOCKS:   GXPORT
 * DESC:     Receive oversize packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IROVRr 0x00f00039

#define BCM56800_A0_IROVRr_SIZE 8

/*
 * This structure should be used to declare and program IROVR.
 *
 */
typedef union BCM56800_A0_IROVRr_s {
	uint32_t v[2];
	uint32_t irovr[2];
	uint32_t _irovr;
} BCM56800_A0_IROVRr_t;

#define BCM56800_A0_IROVRr_CLR(r) CDK_MEMSET(&((r)._irovr), 0, sizeof(BCM56800_A0_IROVRr_t))
#define BCM56800_A0_IROVRr_SET(r,i,d) (r).irovr[i] = d
#define BCM56800_A0_IROVRr_GET(r,i) (r).irovr[i]


/*
 * These macros can be used to access IROVR.
 *
 */
#define BCM56800_A0_READ_IROVRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IROVRr,(r._irovr))
#define BCM56800_A0_WRITE_IROVRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IROVRr,&(r._irovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IROVRr BCM56800_A0_IROVRr
#define IROVRr_SIZE BCM56800_A0_IROVRr_SIZE
typedef BCM56800_A0_IROVRr_t IROVRr_t;
#define IROVRr_CLR BCM56800_A0_IROVRr_CLR
#define IROVRr_SET BCM56800_A0_IROVRr_SET
#define IROVRr_GET BCM56800_A0_IROVRr_GET
#define READ_IROVRr BCM56800_A0_READ_IROVRr
#define WRITE_IROVRr BCM56800_A0_WRITE_IROVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IROVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRPKT
 * BLOCKS:   GXPORT
 * DESC:     Receive packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRPKTr 0x00f00031

#define BCM56800_A0_IRPKTr_SIZE 8

/*
 * This structure should be used to declare and program IRPKT.
 *
 */
typedef union BCM56800_A0_IRPKTr_s {
	uint32_t v[2];
	uint32_t irpkt[2];
	uint32_t _irpkt;
} BCM56800_A0_IRPKTr_t;

#define BCM56800_A0_IRPKTr_CLR(r) CDK_MEMSET(&((r)._irpkt), 0, sizeof(BCM56800_A0_IRPKTr_t))
#define BCM56800_A0_IRPKTr_SET(r,i,d) (r).irpkt[i] = d
#define BCM56800_A0_IRPKTr_GET(r,i) (r).irpkt[i]


/*
 * These macros can be used to access IRPKT.
 *
 */
#define BCM56800_A0_READ_IRPKTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRPKTr,(r._irpkt))
#define BCM56800_A0_WRITE_IRPKTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRPKTr,&(r._irpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRPKTr BCM56800_A0_IRPKTr
#define IRPKTr_SIZE BCM56800_A0_IRPKTr_SIZE
typedef BCM56800_A0_IRPKTr_t IRPKTr_t;
#define IRPKTr_CLR BCM56800_A0_IRPKTr_CLR
#define IRPKTr_SET BCM56800_A0_IRPKTr_SET
#define IRPKTr_GET BCM56800_A0_IRPKTr_GET
#define READ_IRPKTr BCM56800_A0_READ_IRPKTr
#define WRITE_IRPKTr BCM56800_A0_WRITE_IRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRUND
 * BLOCKS:   GXPORT
 * DESC:     Received undersize packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRUNDr 0x00f0003e

#define BCM56800_A0_IRUNDr_SIZE 8

/*
 * This structure should be used to declare and program IRUND.
 *
 */
typedef union BCM56800_A0_IRUNDr_s {
	uint32_t v[2];
	uint32_t irund[2];
	uint32_t _irund;
} BCM56800_A0_IRUNDr_t;

#define BCM56800_A0_IRUNDr_CLR(r) CDK_MEMSET(&((r)._irund), 0, sizeof(BCM56800_A0_IRUNDr_t))
#define BCM56800_A0_IRUNDr_SET(r,i,d) (r).irund[i] = d
#define BCM56800_A0_IRUNDr_GET(r,i) (r).irund[i]


/*
 * These macros can be used to access IRUND.
 *
 */
#define BCM56800_A0_READ_IRUNDr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRUNDr,(r._irund))
#define BCM56800_A0_WRITE_IRUNDr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRUNDr,&(r._irund))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRUNDr BCM56800_A0_IRUNDr
#define IRUNDr_SIZE BCM56800_A0_IRUNDr_SIZE
typedef BCM56800_A0_IRUNDr_t IRUNDr_t;
#define IRUNDr_CLR BCM56800_A0_IRUNDr_CLR
#define IRUNDr_SET BCM56800_A0_IRUNDr_SET
#define IRUNDr_GET BCM56800_A0_IRUNDr_GET
#define READ_IRUNDr BCM56800_A0_READ_IRUNDr
#define WRITE_IRUNDr BCM56800_A0_WRITE_IRUNDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRUNDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRXCF
 * BLOCKS:   GXPORT
 * DESC:     Receive control packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRXCFr 0x00f00035

#define BCM56800_A0_IRXCFr_SIZE 8

/*
 * This structure should be used to declare and program IRXCF.
 *
 */
typedef union BCM56800_A0_IRXCFr_s {
	uint32_t v[2];
	uint32_t irxcf[2];
	uint32_t _irxcf;
} BCM56800_A0_IRXCFr_t;

#define BCM56800_A0_IRXCFr_CLR(r) CDK_MEMSET(&((r)._irxcf), 0, sizeof(BCM56800_A0_IRXCFr_t))
#define BCM56800_A0_IRXCFr_SET(r,i,d) (r).irxcf[i] = d
#define BCM56800_A0_IRXCFr_GET(r,i) (r).irxcf[i]


/*
 * These macros can be used to access IRXCF.
 *
 */
#define BCM56800_A0_READ_IRXCFr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRXCFr,(r._irxcf))
#define BCM56800_A0_WRITE_IRXCFr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRXCFr,&(r._irxcf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRXCFr BCM56800_A0_IRXCFr
#define IRXCFr_SIZE BCM56800_A0_IRXCFr_SIZE
typedef BCM56800_A0_IRXCFr_t IRXCFr_t;
#define IRXCFr_CLR BCM56800_A0_IRXCFr_CLR
#define IRXCFr_SET BCM56800_A0_IRXCFr_SET
#define IRXCFr_GET BCM56800_A0_IRXCFr_GET
#define READ_IRXCFr BCM56800_A0_READ_IRXCFr
#define WRITE_IRXCFr BCM56800_A0_WRITE_IRXCFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRXCFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRXPF
 * BLOCKS:   GXPORT
 * DESC:     Receive PAUSE packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRXPFr 0x00f00036

#define BCM56800_A0_IRXPFr_SIZE 8

/*
 * This structure should be used to declare and program IRXPF.
 *
 */
typedef union BCM56800_A0_IRXPFr_s {
	uint32_t v[2];
	uint32_t irxpf[2];
	uint32_t _irxpf;
} BCM56800_A0_IRXPFr_t;

#define BCM56800_A0_IRXPFr_CLR(r) CDK_MEMSET(&((r)._irxpf), 0, sizeof(BCM56800_A0_IRXPFr_t))
#define BCM56800_A0_IRXPFr_SET(r,i,d) (r).irxpf[i] = d
#define BCM56800_A0_IRXPFr_GET(r,i) (r).irxpf[i]


/*
 * These macros can be used to access IRXPF.
 *
 */
#define BCM56800_A0_READ_IRXPFr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRXPFr,(r._irxpf))
#define BCM56800_A0_WRITE_IRXPFr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRXPFr,&(r._irxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRXPFr BCM56800_A0_IRXPFr
#define IRXPFr_SIZE BCM56800_A0_IRXPFr_SIZE
typedef BCM56800_A0_IRXPFr_t IRXPFr_t;
#define IRXPFr_CLR BCM56800_A0_IRXPFr_CLR
#define IRXPFr_SET BCM56800_A0_IRXPFr_SET
#define IRXPFr_GET BCM56800_A0_IRXPFr_GET
#define READ_IRXPFr BCM56800_A0_READ_IRXPFr
#define WRITE_IRXPFr BCM56800_A0_WRITE_IRXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IRXUO
 * BLOCKS:   GXPORT
 * DESC:     Receive PAUSE packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IRXUOr 0x00f00037

#define BCM56800_A0_IRXUOr_SIZE 8

/*
 * This structure should be used to declare and program IRXUO.
 *
 */
typedef union BCM56800_A0_IRXUOr_s {
	uint32_t v[2];
	uint32_t irxuo[2];
	uint32_t _irxuo;
} BCM56800_A0_IRXUOr_t;

#define BCM56800_A0_IRXUOr_CLR(r) CDK_MEMSET(&((r)._irxuo), 0, sizeof(BCM56800_A0_IRXUOr_t))
#define BCM56800_A0_IRXUOr_SET(r,i,d) (r).irxuo[i] = d
#define BCM56800_A0_IRXUOr_GET(r,i) (r).irxuo[i]


/*
 * These macros can be used to access IRXUO.
 *
 */
#define BCM56800_A0_READ_IRXUOr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IRXUOr,(r._irxuo))
#define BCM56800_A0_WRITE_IRXUOr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IRXUOr,&(r._irxuo))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IRXUOr BCM56800_A0_IRXUOr
#define IRXUOr_SIZE BCM56800_A0_IRXUOr_SIZE
typedef BCM56800_A0_IRXUOr_t IRXUOr_t;
#define IRXUOr_CLR BCM56800_A0_IRXUOr_CLR
#define IRXUOr_SET BCM56800_A0_IRXUOr_SET
#define IRXUOr_GET BCM56800_A0_IRXUOr_GET
#define READ_IRXUOr BCM56800_A0_READ_IRXUOr
#define WRITE_IRXUOr BCM56800_A0_WRITE_IRXUOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IRXUOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT1023
 * BLOCKS:   GXPORT
 * DESC:     Transmit 512-1023 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT1023r 0x00f00017

#define BCM56800_A0_IT1023r_SIZE 8

/*
 * This structure should be used to declare and program IT1023.
 *
 */
typedef union BCM56800_A0_IT1023r_s {
	uint32_t v[2];
	uint32_t it1023[2];
	uint32_t _it1023;
} BCM56800_A0_IT1023r_t;

#define BCM56800_A0_IT1023r_CLR(r) CDK_MEMSET(&((r)._it1023), 0, sizeof(BCM56800_A0_IT1023r_t))
#define BCM56800_A0_IT1023r_SET(r,i,d) (r).it1023[i] = d
#define BCM56800_A0_IT1023r_GET(r,i) (r).it1023[i]


/*
 * These macros can be used to access IT1023.
 *
 */
#define BCM56800_A0_READ_IT1023r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT1023r,(r._it1023))
#define BCM56800_A0_WRITE_IT1023r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT1023r,&(r._it1023))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT1023r BCM56800_A0_IT1023r
#define IT1023r_SIZE BCM56800_A0_IT1023r_SIZE
typedef BCM56800_A0_IT1023r_t IT1023r_t;
#define IT1023r_CLR BCM56800_A0_IT1023r_CLR
#define IT1023r_SET BCM56800_A0_IT1023r_SET
#define IT1023r_GET BCM56800_A0_IT1023r_GET
#define READ_IT1023r BCM56800_A0_READ_IT1023r
#define WRITE_IT1023r BCM56800_A0_WRITE_IT1023r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT1023r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT127
 * BLOCKS:   GXPORT
 * DESC:     Transmit 65-127 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT127r 0x00f00014

#define BCM56800_A0_IT127r_SIZE 8

/*
 * This structure should be used to declare and program IT127.
 *
 */
typedef union BCM56800_A0_IT127r_s {
	uint32_t v[2];
	uint32_t it127[2];
	uint32_t _it127;
} BCM56800_A0_IT127r_t;

#define BCM56800_A0_IT127r_CLR(r) CDK_MEMSET(&((r)._it127), 0, sizeof(BCM56800_A0_IT127r_t))
#define BCM56800_A0_IT127r_SET(r,i,d) (r).it127[i] = d
#define BCM56800_A0_IT127r_GET(r,i) (r).it127[i]


/*
 * These macros can be used to access IT127.
 *
 */
#define BCM56800_A0_READ_IT127r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT127r,(r._it127))
#define BCM56800_A0_WRITE_IT127r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT127r,&(r._it127))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT127r BCM56800_A0_IT127r
#define IT127r_SIZE BCM56800_A0_IT127r_SIZE
typedef BCM56800_A0_IT127r_t IT127r_t;
#define IT127r_CLR BCM56800_A0_IT127r_CLR
#define IT127r_SET BCM56800_A0_IT127r_SET
#define IT127r_GET BCM56800_A0_IT127r_GET
#define READ_IT127r BCM56800_A0_READ_IT127r
#define WRITE_IT127r BCM56800_A0_WRITE_IT127r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT127r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT1518
 * BLOCKS:   GXPORT
 * DESC:     Transmit 1024-1518 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT1518r 0x00f00018

#define BCM56800_A0_IT1518r_SIZE 8

/*
 * This structure should be used to declare and program IT1518.
 *
 */
typedef union BCM56800_A0_IT1518r_s {
	uint32_t v[2];
	uint32_t it1518[2];
	uint32_t _it1518;
} BCM56800_A0_IT1518r_t;

#define BCM56800_A0_IT1518r_CLR(r) CDK_MEMSET(&((r)._it1518), 0, sizeof(BCM56800_A0_IT1518r_t))
#define BCM56800_A0_IT1518r_SET(r,i,d) (r).it1518[i] = d
#define BCM56800_A0_IT1518r_GET(r,i) (r).it1518[i]


/*
 * These macros can be used to access IT1518.
 *
 */
#define BCM56800_A0_READ_IT1518r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT1518r,(r._it1518))
#define BCM56800_A0_WRITE_IT1518r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT1518r,&(r._it1518))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT1518r BCM56800_A0_IT1518r
#define IT1518r_SIZE BCM56800_A0_IT1518r_SIZE
typedef BCM56800_A0_IT1518r_t IT1518r_t;
#define IT1518r_CLR BCM56800_A0_IT1518r_CLR
#define IT1518r_SET BCM56800_A0_IT1518r_SET
#define IT1518r_GET BCM56800_A0_IT1518r_GET
#define READ_IT1518r BCM56800_A0_READ_IT1518r
#define WRITE_IT1518r BCM56800_A0_WRITE_IT1518r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT1518r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT16383
 * BLOCKS:   GXPORT
 * DESC:     Transmit 9217-16383 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT16383r 0x00f0001c

#define BCM56800_A0_IT16383r_SIZE 8

/*
 * This structure should be used to declare and program IT16383.
 *
 */
typedef union BCM56800_A0_IT16383r_s {
	uint32_t v[2];
	uint32_t it16383[2];
	uint32_t _it16383;
} BCM56800_A0_IT16383r_t;

#define BCM56800_A0_IT16383r_CLR(r) CDK_MEMSET(&((r)._it16383), 0, sizeof(BCM56800_A0_IT16383r_t))
#define BCM56800_A0_IT16383r_SET(r,i,d) (r).it16383[i] = d
#define BCM56800_A0_IT16383r_GET(r,i) (r).it16383[i]


/*
 * These macros can be used to access IT16383.
 *
 */
#define BCM56800_A0_READ_IT16383r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT16383r,(r._it16383))
#define BCM56800_A0_WRITE_IT16383r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT16383r,&(r._it16383))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT16383r BCM56800_A0_IT16383r
#define IT16383r_SIZE BCM56800_A0_IT16383r_SIZE
typedef BCM56800_A0_IT16383r_t IT16383r_t;
#define IT16383r_CLR BCM56800_A0_IT16383r_CLR
#define IT16383r_SET BCM56800_A0_IT16383r_SET
#define IT16383r_GET BCM56800_A0_IT16383r_GET
#define READ_IT16383r BCM56800_A0_READ_IT16383r
#define WRITE_IT16383r BCM56800_A0_WRITE_IT16383r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT16383r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT2047
 * BLOCKS:   GXPORT
 * DESC:     Transmit 1519-2047 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT2047r 0x00f00019

#define BCM56800_A0_IT2047r_SIZE 8

/*
 * This structure should be used to declare and program IT2047.
 *
 */
typedef union BCM56800_A0_IT2047r_s {
	uint32_t v[2];
	uint32_t it2047[2];
	uint32_t _it2047;
} BCM56800_A0_IT2047r_t;

#define BCM56800_A0_IT2047r_CLR(r) CDK_MEMSET(&((r)._it2047), 0, sizeof(BCM56800_A0_IT2047r_t))
#define BCM56800_A0_IT2047r_SET(r,i,d) (r).it2047[i] = d
#define BCM56800_A0_IT2047r_GET(r,i) (r).it2047[i]


/*
 * These macros can be used to access IT2047.
 *
 */
#define BCM56800_A0_READ_IT2047r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT2047r,(r._it2047))
#define BCM56800_A0_WRITE_IT2047r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT2047r,&(r._it2047))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT2047r BCM56800_A0_IT2047r
#define IT2047r_SIZE BCM56800_A0_IT2047r_SIZE
typedef BCM56800_A0_IT2047r_t IT2047r_t;
#define IT2047r_CLR BCM56800_A0_IT2047r_CLR
#define IT2047r_SET BCM56800_A0_IT2047r_SET
#define IT2047r_GET BCM56800_A0_IT2047r_GET
#define READ_IT2047r BCM56800_A0_READ_IT2047r
#define WRITE_IT2047r BCM56800_A0_WRITE_IT2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT255
 * BLOCKS:   GXPORT
 * DESC:     Transmit 128-255 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT255r 0x00f00015

#define BCM56800_A0_IT255r_SIZE 8

/*
 * This structure should be used to declare and program IT255.
 *
 */
typedef union BCM56800_A0_IT255r_s {
	uint32_t v[2];
	uint32_t it255[2];
	uint32_t _it255;
} BCM56800_A0_IT255r_t;

#define BCM56800_A0_IT255r_CLR(r) CDK_MEMSET(&((r)._it255), 0, sizeof(BCM56800_A0_IT255r_t))
#define BCM56800_A0_IT255r_SET(r,i,d) (r).it255[i] = d
#define BCM56800_A0_IT255r_GET(r,i) (r).it255[i]


/*
 * These macros can be used to access IT255.
 *
 */
#define BCM56800_A0_READ_IT255r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT255r,(r._it255))
#define BCM56800_A0_WRITE_IT255r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT255r,&(r._it255))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT255r BCM56800_A0_IT255r
#define IT255r_SIZE BCM56800_A0_IT255r_SIZE
typedef BCM56800_A0_IT255r_t IT255r_t;
#define IT255r_CLR BCM56800_A0_IT255r_CLR
#define IT255r_SET BCM56800_A0_IT255r_SET
#define IT255r_GET BCM56800_A0_IT255r_GET
#define READ_IT255r BCM56800_A0_READ_IT255r
#define WRITE_IT255r BCM56800_A0_WRITE_IT255r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT255r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT4095
 * BLOCKS:   GXPORT
 * DESC:     Transmit 2048-4095 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT4095r 0x00f0001a

#define BCM56800_A0_IT4095r_SIZE 8

/*
 * This structure should be used to declare and program IT4095.
 *
 */
typedef union BCM56800_A0_IT4095r_s {
	uint32_t v[2];
	uint32_t it4095[2];
	uint32_t _it4095;
} BCM56800_A0_IT4095r_t;

#define BCM56800_A0_IT4095r_CLR(r) CDK_MEMSET(&((r)._it4095), 0, sizeof(BCM56800_A0_IT4095r_t))
#define BCM56800_A0_IT4095r_SET(r,i,d) (r).it4095[i] = d
#define BCM56800_A0_IT4095r_GET(r,i) (r).it4095[i]


/*
 * These macros can be used to access IT4095.
 *
 */
#define BCM56800_A0_READ_IT4095r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT4095r,(r._it4095))
#define BCM56800_A0_WRITE_IT4095r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT4095r,&(r._it4095))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT4095r BCM56800_A0_IT4095r
#define IT4095r_SIZE BCM56800_A0_IT4095r_SIZE
typedef BCM56800_A0_IT4095r_t IT4095r_t;
#define IT4095r_CLR BCM56800_A0_IT4095r_CLR
#define IT4095r_SET BCM56800_A0_IT4095r_SET
#define IT4095r_GET BCM56800_A0_IT4095r_GET
#define READ_IT4095r BCM56800_A0_READ_IT4095r
#define WRITE_IT4095r BCM56800_A0_WRITE_IT4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT511
 * BLOCKS:   GXPORT
 * DESC:     Transmit 256-511 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT511r 0x00f00016

#define BCM56800_A0_IT511r_SIZE 8

/*
 * This structure should be used to declare and program IT511.
 *
 */
typedef union BCM56800_A0_IT511r_s {
	uint32_t v[2];
	uint32_t it511[2];
	uint32_t _it511;
} BCM56800_A0_IT511r_t;

#define BCM56800_A0_IT511r_CLR(r) CDK_MEMSET(&((r)._it511), 0, sizeof(BCM56800_A0_IT511r_t))
#define BCM56800_A0_IT511r_SET(r,i,d) (r).it511[i] = d
#define BCM56800_A0_IT511r_GET(r,i) (r).it511[i]


/*
 * These macros can be used to access IT511.
 *
 */
#define BCM56800_A0_READ_IT511r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT511r,(r._it511))
#define BCM56800_A0_WRITE_IT511r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT511r,&(r._it511))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT511r BCM56800_A0_IT511r
#define IT511r_SIZE BCM56800_A0_IT511r_SIZE
typedef BCM56800_A0_IT511r_t IT511r_t;
#define IT511r_CLR BCM56800_A0_IT511r_CLR
#define IT511r_SET BCM56800_A0_IT511r_SET
#define IT511r_GET BCM56800_A0_IT511r_GET
#define READ_IT511r BCM56800_A0_READ_IT511r
#define WRITE_IT511r BCM56800_A0_WRITE_IT511r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT511r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT64
 * BLOCKS:   GXPORT
 * DESC:     Transmit 64 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT64r 0x00f00013

#define BCM56800_A0_IT64r_SIZE 8

/*
 * This structure should be used to declare and program IT64.
 *
 */
typedef union BCM56800_A0_IT64r_s {
	uint32_t v[2];
	uint32_t it64[2];
	uint32_t _it64;
} BCM56800_A0_IT64r_t;

#define BCM56800_A0_IT64r_CLR(r) CDK_MEMSET(&((r)._it64), 0, sizeof(BCM56800_A0_IT64r_t))
#define BCM56800_A0_IT64r_SET(r,i,d) (r).it64[i] = d
#define BCM56800_A0_IT64r_GET(r,i) (r).it64[i]


/*
 * These macros can be used to access IT64.
 *
 */
#define BCM56800_A0_READ_IT64r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT64r,(r._it64))
#define BCM56800_A0_WRITE_IT64r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT64r,&(r._it64))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT64r BCM56800_A0_IT64r
#define IT64r_SIZE BCM56800_A0_IT64r_SIZE
typedef BCM56800_A0_IT64r_t IT64r_t;
#define IT64r_CLR BCM56800_A0_IT64r_CLR
#define IT64r_SET BCM56800_A0_IT64r_SET
#define IT64r_GET BCM56800_A0_IT64r_GET
#define READ_IT64r BCM56800_A0_READ_IT64r
#define WRITE_IT64r BCM56800_A0_WRITE_IT64r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT64r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IT9216
 * BLOCKS:   GXPORT
 * DESC:     Transmit 4096-9216 byte packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_IT9216r 0x00f0001b

#define BCM56800_A0_IT9216r_SIZE 8

/*
 * This structure should be used to declare and program IT9216.
 *
 */
typedef union BCM56800_A0_IT9216r_s {
	uint32_t v[2];
	uint32_t it9216[2];
	uint32_t _it9216;
} BCM56800_A0_IT9216r_t;

#define BCM56800_A0_IT9216r_CLR(r) CDK_MEMSET(&((r)._it9216), 0, sizeof(BCM56800_A0_IT9216r_t))
#define BCM56800_A0_IT9216r_SET(r,i,d) (r).it9216[i] = d
#define BCM56800_A0_IT9216r_GET(r,i) (r).it9216[i]


/*
 * These macros can be used to access IT9216.
 *
 */
#define BCM56800_A0_READ_IT9216r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_IT9216r,(r._it9216))
#define BCM56800_A0_WRITE_IT9216r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_IT9216r,&(r._it9216))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IT9216r BCM56800_A0_IT9216r
#define IT9216r_SIZE BCM56800_A0_IT9216r_SIZE
typedef BCM56800_A0_IT9216r_t IT9216r_t;
#define IT9216r_CLR BCM56800_A0_IT9216r_CLR
#define IT9216r_SET BCM56800_A0_IT9216r_SET
#define IT9216r_GET BCM56800_A0_IT9216r_GET
#define READ_IT9216r BCM56800_A0_READ_IT9216r
#define WRITE_IT9216r BCM56800_A0_WRITE_IT9216r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IT9216r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITBCA
 * BLOCKS:   GXPORT
 * DESC:     Transmit broadcast packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITBCAr 0x00f00010

#define BCM56800_A0_ITBCAr_SIZE 8

/*
 * This structure should be used to declare and program ITBCA.
 *
 */
typedef union BCM56800_A0_ITBCAr_s {
	uint32_t v[2];
	uint32_t itbca[2];
	uint32_t _itbca;
} BCM56800_A0_ITBCAr_t;

#define BCM56800_A0_ITBCAr_CLR(r) CDK_MEMSET(&((r)._itbca), 0, sizeof(BCM56800_A0_ITBCAr_t))
#define BCM56800_A0_ITBCAr_SET(r,i,d) (r).itbca[i] = d
#define BCM56800_A0_ITBCAr_GET(r,i) (r).itbca[i]


/*
 * These macros can be used to access ITBCA.
 *
 */
#define BCM56800_A0_READ_ITBCAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITBCAr,(r._itbca))
#define BCM56800_A0_WRITE_ITBCAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITBCAr,&(r._itbca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITBCAr BCM56800_A0_ITBCAr
#define ITBCAr_SIZE BCM56800_A0_ITBCAr_SIZE
typedef BCM56800_A0_ITBCAr_t ITBCAr_t;
#define ITBCAr_CLR BCM56800_A0_ITBCAr_CLR
#define ITBCAr_SET BCM56800_A0_ITBCAr_SET
#define ITBCAr_GET BCM56800_A0_ITBCAr_GET
#define READ_ITBCAr BCM56800_A0_READ_ITBCAr
#define WRITE_ITBCAr BCM56800_A0_WRITE_ITBCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITBCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITBYT
 * BLOCKS:   GXPORT
 * DESC:     Transmit byte counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITBYTr 0x00f00020

#define BCM56800_A0_ITBYTr_SIZE 8

/*
 * This structure should be used to declare and program ITBYT.
 *
 */
typedef union BCM56800_A0_ITBYTr_s {
	uint32_t v[2];
	uint32_t itbyt[2];
	uint32_t _itbyt;
} BCM56800_A0_ITBYTr_t;

#define BCM56800_A0_ITBYTr_CLR(r) CDK_MEMSET(&((r)._itbyt), 0, sizeof(BCM56800_A0_ITBYTr_t))
#define BCM56800_A0_ITBYTr_SET(r,i,d) (r).itbyt[i] = d
#define BCM56800_A0_ITBYTr_GET(r,i) (r).itbyt[i]


/*
 * These macros can be used to access ITBYT.
 *
 */
#define BCM56800_A0_READ_ITBYTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITBYTr,(r._itbyt))
#define BCM56800_A0_WRITE_ITBYTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITBYTr,&(r._itbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITBYTr BCM56800_A0_ITBYTr
#define ITBYTr_SIZE BCM56800_A0_ITBYTr_SIZE
typedef BCM56800_A0_ITBYTr_t ITBYTr_t;
#define ITBYTr_CLR BCM56800_A0_ITBYTr_CLR
#define ITBYTr_SET BCM56800_A0_ITBYTr_SET
#define ITBYTr_GET BCM56800_A0_ITBYTr_GET
#define READ_ITBYTr BCM56800_A0_READ_ITBYTr
#define WRITE_ITBYTr BCM56800_A0_WRITE_ITBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITERR
 * BLOCKS:   GXPORT
 * DESC:     Transmit error packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITERRr 0x00f0001f

#define BCM56800_A0_ITERRr_SIZE 8

/*
 * This structure should be used to declare and program ITERR.
 *
 */
typedef union BCM56800_A0_ITERRr_s {
	uint32_t v[2];
	uint32_t iterr[2];
	uint32_t _iterr;
} BCM56800_A0_ITERRr_t;

#define BCM56800_A0_ITERRr_CLR(r) CDK_MEMSET(&((r)._iterr), 0, sizeof(BCM56800_A0_ITERRr_t))
#define BCM56800_A0_ITERRr_SET(r,i,d) (r).iterr[i] = d
#define BCM56800_A0_ITERRr_GET(r,i) (r).iterr[i]


/*
 * These macros can be used to access ITERR.
 *
 */
#define BCM56800_A0_READ_ITERRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITERRr,(r._iterr))
#define BCM56800_A0_WRITE_ITERRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITERRr,&(r._iterr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITERRr BCM56800_A0_ITERRr
#define ITERRr_SIZE BCM56800_A0_ITERRr_SIZE
typedef BCM56800_A0_ITERRr_t ITERRr_t;
#define ITERRr_CLR BCM56800_A0_ITERRr_CLR
#define ITERRr_SET BCM56800_A0_ITERRr_SET
#define ITERRr_GET BCM56800_A0_ITERRr_GET
#define READ_ITERRr BCM56800_A0_READ_ITERRr
#define WRITE_ITERRr BCM56800_A0_WRITE_ITERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITFCS
 * BLOCKS:   GXPORT
 * DESC:     Transmit FCS(CRC) error counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITFCSr 0x00f0000e

#define BCM56800_A0_ITFCSr_SIZE 8

/*
 * This structure should be used to declare and program ITFCS.
 *
 */
typedef union BCM56800_A0_ITFCSr_s {
	uint32_t v[2];
	uint32_t itfcs[2];
	uint32_t _itfcs;
} BCM56800_A0_ITFCSr_t;

#define BCM56800_A0_ITFCSr_CLR(r) CDK_MEMSET(&((r)._itfcs), 0, sizeof(BCM56800_A0_ITFCSr_t))
#define BCM56800_A0_ITFCSr_SET(r,i,d) (r).itfcs[i] = d
#define BCM56800_A0_ITFCSr_GET(r,i) (r).itfcs[i]


/*
 * These macros can be used to access ITFCS.
 *
 */
#define BCM56800_A0_READ_ITFCSr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITFCSr,(r._itfcs))
#define BCM56800_A0_WRITE_ITFCSr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITFCSr,&(r._itfcs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITFCSr BCM56800_A0_ITFCSr
#define ITFCSr_SIZE BCM56800_A0_ITFCSr_SIZE
typedef BCM56800_A0_ITFCSr_t ITFCSr_t;
#define ITFCSr_CLR BCM56800_A0_ITFCSr_CLR
#define ITFCSr_SET BCM56800_A0_ITFCSr_SET
#define ITFCSr_GET BCM56800_A0_ITFCSr_GET
#define READ_ITFCSr BCM56800_A0_READ_ITFCSr
#define WRITE_ITFCSr BCM56800_A0_WRITE_ITFCSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITFCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITFRG
 * BLOCKS:   GXPORT
 * DESC:     Transmit fragment counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITFRGr 0x00f00011

#define BCM56800_A0_ITFRGr_SIZE 8

/*
 * This structure should be used to declare and program ITFRG.
 *
 */
typedef union BCM56800_A0_ITFRGr_s {
	uint32_t v[2];
	uint32_t itfrg[2];
	uint32_t _itfrg;
} BCM56800_A0_ITFRGr_t;

#define BCM56800_A0_ITFRGr_CLR(r) CDK_MEMSET(&((r)._itfrg), 0, sizeof(BCM56800_A0_ITFRGr_t))
#define BCM56800_A0_ITFRGr_SET(r,i,d) (r).itfrg[i] = d
#define BCM56800_A0_ITFRGr_GET(r,i) (r).itfrg[i]


/*
 * These macros can be used to access ITFRG.
 *
 */
#define BCM56800_A0_READ_ITFRGr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITFRGr,(r._itfrg))
#define BCM56800_A0_WRITE_ITFRGr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITFRGr,&(r._itfrg))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITFRGr BCM56800_A0_ITFRGr
#define ITFRGr_SIZE BCM56800_A0_ITFRGr_SIZE
typedef BCM56800_A0_ITFRGr_t ITFRGr_t;
#define ITFRGr_CLR BCM56800_A0_ITFRGr_CLR
#define ITFRGr_SET BCM56800_A0_ITFRGr_SET
#define ITFRGr_GET BCM56800_A0_ITFRGr_GET
#define READ_ITFRGr BCM56800_A0_READ_ITFRGr
#define WRITE_ITFRGr BCM56800_A0_WRITE_ITFRGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITFRGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITMAX
 * BLOCKS:   GXPORT
 * DESC:     Transmit max size packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITMAXr 0x00f0001d

#define BCM56800_A0_ITMAXr_SIZE 8

/*
 * This structure should be used to declare and program ITMAX.
 *
 */
typedef union BCM56800_A0_ITMAXr_s {
	uint32_t v[2];
	uint32_t itmax[2];
	uint32_t _itmax;
} BCM56800_A0_ITMAXr_t;

#define BCM56800_A0_ITMAXr_CLR(r) CDK_MEMSET(&((r)._itmax), 0, sizeof(BCM56800_A0_ITMAXr_t))
#define BCM56800_A0_ITMAXr_SET(r,i,d) (r).itmax[i] = d
#define BCM56800_A0_ITMAXr_GET(r,i) (r).itmax[i]


/*
 * These macros can be used to access ITMAX.
 *
 */
#define BCM56800_A0_READ_ITMAXr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITMAXr,(r._itmax))
#define BCM56800_A0_WRITE_ITMAXr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITMAXr,&(r._itmax))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITMAXr BCM56800_A0_ITMAXr
#define ITMAXr_SIZE BCM56800_A0_ITMAXr_SIZE
typedef BCM56800_A0_ITMAXr_t ITMAXr_t;
#define ITMAXr_CLR BCM56800_A0_ITMAXr_CLR
#define ITMAXr_SET BCM56800_A0_ITMAXr_SET
#define ITMAXr_GET BCM56800_A0_ITMAXr_GET
#define READ_ITMAXr BCM56800_A0_READ_ITMAXr
#define WRITE_ITMAXr BCM56800_A0_WRITE_ITMAXr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITMAXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITMCA
 * BLOCKS:   GXPORT
 * DESC:     Transmit multicast packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITMCAr 0x00f0000f

#define BCM56800_A0_ITMCAr_SIZE 8

/*
 * This structure should be used to declare and program ITMCA.
 *
 */
typedef union BCM56800_A0_ITMCAr_s {
	uint32_t v[2];
	uint32_t itmca[2];
	uint32_t _itmca;
} BCM56800_A0_ITMCAr_t;

#define BCM56800_A0_ITMCAr_CLR(r) CDK_MEMSET(&((r)._itmca), 0, sizeof(BCM56800_A0_ITMCAr_t))
#define BCM56800_A0_ITMCAr_SET(r,i,d) (r).itmca[i] = d
#define BCM56800_A0_ITMCAr_GET(r,i) (r).itmca[i]


/*
 * These macros can be used to access ITMCA.
 *
 */
#define BCM56800_A0_READ_ITMCAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITMCAr,(r._itmca))
#define BCM56800_A0_WRITE_ITMCAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITMCAr,&(r._itmca))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITMCAr BCM56800_A0_ITMCAr
#define ITMCAr_SIZE BCM56800_A0_ITMCAr_SIZE
typedef BCM56800_A0_ITMCAr_t ITMCAr_t;
#define ITMCAr_CLR BCM56800_A0_ITMCAr_CLR
#define ITMCAr_SET BCM56800_A0_ITMCAr_SET
#define ITMCAr_GET BCM56800_A0_ITMCAr_GET
#define READ_ITMCAr BCM56800_A0_READ_ITMCAr
#define WRITE_ITMCAr BCM56800_A0_WRITE_ITMCAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITMCAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITOVR
 * BLOCKS:   GXPORT
 * DESC:     Transmit oversize packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITOVRr 0x00f00012

#define BCM56800_A0_ITOVRr_SIZE 8

/*
 * This structure should be used to declare and program ITOVR.
 *
 */
typedef union BCM56800_A0_ITOVRr_s {
	uint32_t v[2];
	uint32_t itovr[2];
	uint32_t _itovr;
} BCM56800_A0_ITOVRr_t;

#define BCM56800_A0_ITOVRr_CLR(r) CDK_MEMSET(&((r)._itovr), 0, sizeof(BCM56800_A0_ITOVRr_t))
#define BCM56800_A0_ITOVRr_SET(r,i,d) (r).itovr[i] = d
#define BCM56800_A0_ITOVRr_GET(r,i) (r).itovr[i]


/*
 * These macros can be used to access ITOVR.
 *
 */
#define BCM56800_A0_READ_ITOVRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITOVRr,(r._itovr))
#define BCM56800_A0_WRITE_ITOVRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITOVRr,&(r._itovr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITOVRr BCM56800_A0_ITOVRr
#define ITOVRr_SIZE BCM56800_A0_ITOVRr_SIZE
typedef BCM56800_A0_ITOVRr_t ITOVRr_t;
#define ITOVRr_CLR BCM56800_A0_ITOVRr_CLR
#define ITOVRr_SET BCM56800_A0_ITOVRr_SET
#define ITOVRr_GET BCM56800_A0_ITOVRr_GET
#define READ_ITOVRr BCM56800_A0_READ_ITOVRr
#define WRITE_ITOVRr BCM56800_A0_WRITE_ITOVRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITOVRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITPKT
 * BLOCKS:   GXPORT
 * DESC:     Transmit packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITPKTr 0x00f0000c

#define BCM56800_A0_ITPKTr_SIZE 8

/*
 * This structure should be used to declare and program ITPKT.
 *
 */
typedef union BCM56800_A0_ITPKTr_s {
	uint32_t v[2];
	uint32_t itpkt[2];
	uint32_t _itpkt;
} BCM56800_A0_ITPKTr_t;

#define BCM56800_A0_ITPKTr_CLR(r) CDK_MEMSET(&((r)._itpkt), 0, sizeof(BCM56800_A0_ITPKTr_t))
#define BCM56800_A0_ITPKTr_SET(r,i,d) (r).itpkt[i] = d
#define BCM56800_A0_ITPKTr_GET(r,i) (r).itpkt[i]


/*
 * These macros can be used to access ITPKT.
 *
 */
#define BCM56800_A0_READ_ITPKTr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITPKTr,(r._itpkt))
#define BCM56800_A0_WRITE_ITPKTr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITPKTr,&(r._itpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITPKTr BCM56800_A0_ITPKTr
#define ITPKTr_SIZE BCM56800_A0_ITPKTr_SIZE
typedef BCM56800_A0_ITPKTr_t ITPKTr_t;
#define ITPKTr_CLR BCM56800_A0_ITPKTr_CLR
#define ITPKTr_SET BCM56800_A0_ITPKTr_SET
#define ITPKTr_GET BCM56800_A0_ITPKTr_GET
#define READ_ITPKTr BCM56800_A0_READ_ITPKTr
#define WRITE_ITPKTr BCM56800_A0_WRITE_ITPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITUFL
 * BLOCKS:   GXPORT
 * DESC:     Transmit underflow counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITUFLr 0x00f0001e

#define BCM56800_A0_ITUFLr_SIZE 8

/*
 * This structure should be used to declare and program ITUFL.
 *
 */
typedef union BCM56800_A0_ITUFLr_s {
	uint32_t v[2];
	uint32_t itufl[2];
	uint32_t _itufl;
} BCM56800_A0_ITUFLr_t;

#define BCM56800_A0_ITUFLr_CLR(r) CDK_MEMSET(&((r)._itufl), 0, sizeof(BCM56800_A0_ITUFLr_t))
#define BCM56800_A0_ITUFLr_SET(r,i,d) (r).itufl[i] = d
#define BCM56800_A0_ITUFLr_GET(r,i) (r).itufl[i]


/*
 * These macros can be used to access ITUFL.
 *
 */
#define BCM56800_A0_READ_ITUFLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITUFLr,(r._itufl))
#define BCM56800_A0_WRITE_ITUFLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITUFLr,&(r._itufl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITUFLr BCM56800_A0_ITUFLr
#define ITUFLr_SIZE BCM56800_A0_ITUFLr_SIZE
typedef BCM56800_A0_ITUFLr_t ITUFLr_t;
#define ITUFLr_CLR BCM56800_A0_ITUFLr_CLR
#define ITUFLr_SET BCM56800_A0_ITUFLr_SET
#define ITUFLr_GET BCM56800_A0_ITUFLr_GET
#define READ_ITUFLr BCM56800_A0_READ_ITUFLr
#define WRITE_ITUFLr BCM56800_A0_WRITE_ITUFLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITUFLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  ITXPF
 * BLOCKS:   GXPORT
 * DESC:     Transmit pause packet counter.
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM56800_A0_ITXPFr 0x00f0000d

#define BCM56800_A0_ITXPFr_SIZE 8

/*
 * This structure should be used to declare and program ITXPF.
 *
 */
typedef union BCM56800_A0_ITXPFr_s {
	uint32_t v[2];
	uint32_t itxpf[2];
	uint32_t _itxpf;
} BCM56800_A0_ITXPFr_t;

#define BCM56800_A0_ITXPFr_CLR(r) CDK_MEMSET(&((r)._itxpf), 0, sizeof(BCM56800_A0_ITXPFr_t))
#define BCM56800_A0_ITXPFr_SET(r,i,d) (r).itxpf[i] = d
#define BCM56800_A0_ITXPFr_GET(r,i) (r).itxpf[i]


/*
 * These macros can be used to access ITXPF.
 *
 */
#define BCM56800_A0_READ_ITXPFr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_ITXPFr,(r._itxpf))
#define BCM56800_A0_WRITE_ITXPFr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_ITXPFr,&(r._itxpf))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ITXPFr BCM56800_A0_ITXPFr
#define ITXPFr_SIZE BCM56800_A0_ITXPFr_SIZE
typedef BCM56800_A0_ITXPFr_t ITXPFr_t;
#define ITXPFr_CLR BCM56800_A0_ITXPFr_CLR
#define ITXPFr_SET BCM56800_A0_ITXPFr_SET
#define ITXPFr_GET BCM56800_A0_ITXPFr_GET
#define READ_ITXPFr BCM56800_A0_READ_ITXPFr
#define WRITE_ITXPFr BCM56800_A0_WRITE_ITXPFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_ITXPFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IUNHGI
 * BLOCKS:   IPIPE
 * DESC:     Receive Unknown HGI Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_IUNHGIr 0x0e100011

#define BCM56800_A0_IUNHGIr_SIZE 4

/*
 * This structure should be used to declare and program IUNHGI.
 *
 */
typedef union BCM56800_A0_IUNHGIr_s {
	uint32_t v[1];
	uint32_t iunhgi[1];
	uint32_t _iunhgi;
} BCM56800_A0_IUNHGIr_t;

#define BCM56800_A0_IUNHGIr_CLR(r) (r).iunhgi[0] = 0
#define BCM56800_A0_IUNHGIr_SET(r,d) (r).iunhgi[0] = d
#define BCM56800_A0_IUNHGIr_GET(r) (r).iunhgi[0]


/*
 * These macros can be used to access IUNHGI.
 *
 */
#define BCM56800_A0_READ_IUNHGIr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IUNHGIr,(r._iunhgi))
#define BCM56800_A0_WRITE_IUNHGIr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IUNHGIr,&(r._iunhgi))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNHGIr BCM56800_A0_IUNHGIr
#define IUNHGIr_SIZE BCM56800_A0_IUNHGIr_SIZE
typedef BCM56800_A0_IUNHGIr_t IUNHGIr_t;
#define IUNHGIr_CLR BCM56800_A0_IUNHGIr_CLR
#define IUNHGIr_SET BCM56800_A0_IUNHGIr_SET
#define IUNHGIr_GET BCM56800_A0_IUNHGIr_GET
#define READ_IUNHGIr BCM56800_A0_READ_IUNHGIr
#define WRITE_IUNHGIr BCM56800_A0_WRITE_IUNHGIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IUNHGIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IUNKNOWN_MCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr 0x0e100051

#define BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_MCAST_BLOCK_MASK.
 *
 */
typedef union BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t iunknown_mcast_block_mask[1];
	uint32_t _iunknown_mcast_block_mask;
} BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_t;

#define BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_CLR(r) (r).iunknown_mcast_block_mask[0] = 0
#define BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SET(r,d) (r).iunknown_mcast_block_mask[0] = d
#define BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_GET(r) (r).iunknown_mcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).iunknown_mcast_block_mask[0]) & 0x1fffff)
#define BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).iunknown_mcast_block_mask[0]=(((r).iunknown_mcast_block_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IUNKNOWN_MCAST_BLOCK_MASK.
 *
 */
#define BCM56800_A0_READ_IUNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr,(r._iunknown_mcast_block_mask))
#define BCM56800_A0_WRITE_IUNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr,&(r._iunknown_mcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_MCAST_BLOCK_MASKr BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr
#define IUNKNOWN_MCAST_BLOCK_MASKr_SIZE BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SIZE
typedef BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_t IUNKNOWN_MCAST_BLOCK_MASKr_t;
#define IUNKNOWN_MCAST_BLOCK_MASKr_CLR BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_CLR
#define IUNKNOWN_MCAST_BLOCK_MASKr_SET BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_SET
#define IUNKNOWN_MCAST_BLOCK_MASKr_GET BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_GET
#define IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IUNKNOWN_MCAST_BLOCK_MASKr BCM56800_A0_READ_IUNKNOWN_MCAST_BLOCK_MASKr
#define WRITE_IUNKNOWN_MCAST_BLOCK_MASKr BCM56800_A0_WRITE_IUNKNOWN_MCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IUNKNOWN_MCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IUNKNOWN_UCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr 0x0e100050

#define BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program IUNKNOWN_UCAST_BLOCK_MASK.
 *
 */
typedef union BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t iunknown_ucast_block_mask[1];
	uint32_t _iunknown_ucast_block_mask;
} BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_t;

#define BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_CLR(r) (r).iunknown_ucast_block_mask[0] = 0
#define BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SET(r,d) (r).iunknown_ucast_block_mask[0] = d
#define BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_GET(r) (r).iunknown_ucast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).iunknown_ucast_block_mask[0]) & 0x1fffff)
#define BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).iunknown_ucast_block_mask[0]=(((r).iunknown_ucast_block_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access IUNKNOWN_UCAST_BLOCK_MASK.
 *
 */
#define BCM56800_A0_READ_IUNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr,(r._iunknown_ucast_block_mask))
#define BCM56800_A0_WRITE_IUNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr,&(r._iunknown_ucast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKNOWN_UCAST_BLOCK_MASKr BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr
#define IUNKNOWN_UCAST_BLOCK_MASKr_SIZE BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SIZE
typedef BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_t IUNKNOWN_UCAST_BLOCK_MASKr_t;
#define IUNKNOWN_UCAST_BLOCK_MASKr_CLR BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_CLR
#define IUNKNOWN_UCAST_BLOCK_MASKr_SET BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_SET
#define IUNKNOWN_UCAST_BLOCK_MASKr_GET BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_GET
#define IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_IUNKNOWN_UCAST_BLOCK_MASKr BCM56800_A0_READ_IUNKNOWN_UCAST_BLOCK_MASKr
#define WRITE_IUNKNOWN_UCAST_BLOCK_MASKr BCM56800_A0_WRITE_IUNKNOWN_UCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IUNKNOWN_UCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  IUNKOPC
 * BLOCKS:   IPIPE
 * DESC:     Receive HiGig Packet with Unknown Opcode Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_IUNKOPCr 0x0e100016

#define BCM56800_A0_IUNKOPCr_SIZE 4

/*
 * This structure should be used to declare and program IUNKOPC.
 *
 */
typedef union BCM56800_A0_IUNKOPCr_s {
	uint32_t v[1];
	uint32_t iunkopc[1];
	uint32_t _iunkopc;
} BCM56800_A0_IUNKOPCr_t;

#define BCM56800_A0_IUNKOPCr_CLR(r) (r).iunkopc[0] = 0
#define BCM56800_A0_IUNKOPCr_SET(r,d) (r).iunkopc[0] = d
#define BCM56800_A0_IUNKOPCr_GET(r) (r).iunkopc[0]


/*
 * These macros can be used to access IUNKOPC.
 *
 */
#define BCM56800_A0_READ_IUNKOPCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_IUNKOPCr,(r._iunkopc))
#define BCM56800_A0_WRITE_IUNKOPCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_IUNKOPCr,&(r._iunkopc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUNKOPCr BCM56800_A0_IUNKOPCr
#define IUNKOPCr_SIZE BCM56800_A0_IUNKOPCr_SIZE
typedef BCM56800_A0_IUNKOPCr_t IUNKOPCr_t;
#define IUNKOPCr_CLR BCM56800_A0_IUNKOPCr_CLR
#define IUNKOPCr_SET BCM56800_A0_IUNKOPCr_SET
#define IUNKOPCr_GET BCM56800_A0_IUNKOPCr_GET
#define READ_IUNKOPCr BCM56800_A0_READ_IUNKOPCr
#define WRITE_IUNKOPCr BCM56800_A0_WRITE_IUNKOPCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_IUNKOPCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2MC
 * BLOCKS:   IPIPE
 * DESC:     L2 Multicast table
 * SIZE:     31
 * FIELDS:
 *     HIGIG_TRUNK_OVERRIDE Higig Trunk Override indication
 *     PORT_BITMAP      Multicast port membership
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity for the L2MC RAM
 *
 ******************************************************************************/
#define BCM56800_A0_L2MCm 0x07160000

#define BCM56800_A0_L2MCm_MIN 0
#define BCM56800_A0_L2MCm_MAX 8191
#define BCM56800_A0_L2MCm_CMAX(u) 8191
#define BCM56800_A0_L2MCm_SIZE 4

/*
 * This structure should be used to declare and program L2MC.
 *
 */
typedef union BCM56800_A0_L2MCm_s {
	uint32_t v[1];
	uint32_t l2mc[1];
	uint32_t _l2mc;
} BCM56800_A0_L2MCm_t;

#define BCM56800_A0_L2MCm_CLR(r) (r).l2mc[0] = 0
#define BCM56800_A0_L2MCm_SET(r,d) (r).l2mc[0] = d
#define BCM56800_A0_L2MCm_GET(r) (r).l2mc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_GET(r) (((r).l2mc[0]) & 0xff)
#define BCM56800_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_L2MCm_PORT_BITMAPf_GET(r) ((((r).l2mc[0]) >> 8) & 0x1fffff)
#define BCM56800_A0_L2MCm_PORT_BITMAPf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1fffff << 8)) | ((((uint32_t)f) & 0x1fffff) << 8))
#define BCM56800_A0_L2MCm_VALIDf_GET(r) ((((r).l2mc[0]) >> 29) & 0x1)
#define BCM56800_A0_L2MCm_VALIDf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_L2MCm_EVEN_PARITYf_GET(r) ((((r).l2mc[0]) >> 30) & 0x1)
#define BCM56800_A0_L2MCm_EVEN_PARITYf_SET(r,f) (r).l2mc[0]=(((r).l2mc[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))

/*
 * These macros can be used to access L2MC.
 *
 */
#define BCM56800_A0_READ_L2MCm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2MCm,i,(m._l2mc),1)
#define BCM56800_A0_WRITE_L2MCm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2MCm,i,&(m._l2mc),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MCm BCM56800_A0_L2MCm
#define L2MCm_MIN BCM56800_A0_L2MCm_MIN
#define L2MCm_MAX BCM56800_A0_L2MCm_MAX
#define L2MCm_CMAX(u) BCM56800_A0_L2MCm_CMAX(u)
#define L2MCm_SIZE BCM56800_A0_L2MCm_SIZE
typedef BCM56800_A0_L2MCm_t L2MCm_t;
#define L2MCm_CLR BCM56800_A0_L2MCm_CLR
#define L2MCm_SET BCM56800_A0_L2MCm_SET
#define L2MCm_GET BCM56800_A0_L2MCm_GET
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_GET BCM56800_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_GET
#define L2MCm_HIGIG_TRUNK_OVERRIDEf_SET BCM56800_A0_L2MCm_HIGIG_TRUNK_OVERRIDEf_SET
#define L2MCm_PORT_BITMAPf_GET BCM56800_A0_L2MCm_PORT_BITMAPf_GET
#define L2MCm_PORT_BITMAPf_SET BCM56800_A0_L2MCm_PORT_BITMAPf_SET
#define L2MCm_VALIDf_GET BCM56800_A0_L2MCm_VALIDf_GET
#define L2MCm_VALIDf_SET BCM56800_A0_L2MCm_VALIDf_SET
#define L2MCm_EVEN_PARITYf_GET BCM56800_A0_L2MCm_EVEN_PARITYf_GET
#define L2MCm_EVEN_PARITYf_SET BCM56800_A0_L2MCm_EVEN_PARITYf_SET
#define READ_L2MCm BCM56800_A0_READ_L2MCm
#define WRITE_L2MCm BCM56800_A0_WRITE_L2MCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2MCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2MC_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L2MC_CONTROL
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_L2MC_DBGCTRLr 0x06180c0f

#define BCM56800_A0_L2MC_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L2MC_DBGCTRL.
 *
 */
typedef union BCM56800_A0_L2MC_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t l2mc_dbgctrl[1];
	uint32_t _l2mc_dbgctrl;
} BCM56800_A0_L2MC_DBGCTRLr_t;

#define BCM56800_A0_L2MC_DBGCTRLr_CLR(r) (r).l2mc_dbgctrl[0] = 0
#define BCM56800_A0_L2MC_DBGCTRLr_SET(r,d) (r).l2mc_dbgctrl[0] = d
#define BCM56800_A0_L2MC_DBGCTRLr_GET(r) (r).l2mc_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2MC_DBGCTRLr_TMf_GET(r) (((r).l2mc_dbgctrl[0]) & 0xf)
#define BCM56800_A0_L2MC_DBGCTRLr_TMf_SET(r,f) (r).l2mc_dbgctrl[0]=(((r).l2mc_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access L2MC_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_L2MC_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2MC_DBGCTRLr,(r._l2mc_dbgctrl))
#define BCM56800_A0_WRITE_L2MC_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2MC_DBGCTRLr,&(r._l2mc_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MC_DBGCTRLr BCM56800_A0_L2MC_DBGCTRLr
#define L2MC_DBGCTRLr_SIZE BCM56800_A0_L2MC_DBGCTRLr_SIZE
typedef BCM56800_A0_L2MC_DBGCTRLr_t L2MC_DBGCTRLr_t;
#define L2MC_DBGCTRLr_CLR BCM56800_A0_L2MC_DBGCTRLr_CLR
#define L2MC_DBGCTRLr_SET BCM56800_A0_L2MC_DBGCTRLr_SET
#define L2MC_DBGCTRLr_GET BCM56800_A0_L2MC_DBGCTRLr_GET
#define L2MC_DBGCTRLr_TMf_GET BCM56800_A0_L2MC_DBGCTRLr_TMf_GET
#define L2MC_DBGCTRLr_TMf_SET BCM56800_A0_L2MC_DBGCTRLr_TMf_SET
#define READ_L2MC_DBGCTRLr BCM56800_A0_READ_L2MC_DBGCTRLr
#define WRITE_L2MC_DBGCTRLr BCM56800_A0_WRITE_L2MC_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2MC_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2MC_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2MC_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and ENTRY_IDX are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the L2MC table.
 *
 ******************************************************************************/
#define BCM56800_A0_L2MC_PARITY_CONTROLr 0x06180c11

#define BCM56800_A0_L2MC_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2MC_PARITY_CONTROL.
 *
 */
typedef union BCM56800_A0_L2MC_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2mc_parity_control[1];
	uint32_t _l2mc_parity_control;
} BCM56800_A0_L2MC_PARITY_CONTROLr_t;

#define BCM56800_A0_L2MC_PARITY_CONTROLr_CLR(r) (r).l2mc_parity_control[0] = 0
#define BCM56800_A0_L2MC_PARITY_CONTROLr_SET(r,d) (r).l2mc_parity_control[0] = d
#define BCM56800_A0_L2MC_PARITY_CONTROLr_GET(r) (r).l2mc_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).l2mc_parity_control[0]) & 0x1)
#define BCM56800_A0_L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).l2mc_parity_control[0]=(((r).l2mc_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2MC_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).l2mc_parity_control[0]) >> 1) & 0x1)
#define BCM56800_A0_L2MC_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).l2mc_parity_control[0]=(((r).l2mc_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2MC_PARITY_CONTROL.
 *
 */
#define BCM56800_A0_READ_L2MC_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2MC_PARITY_CONTROLr,(r._l2mc_parity_control))
#define BCM56800_A0_WRITE_L2MC_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2MC_PARITY_CONTROLr,&(r._l2mc_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MC_PARITY_CONTROLr BCM56800_A0_L2MC_PARITY_CONTROLr
#define L2MC_PARITY_CONTROLr_SIZE BCM56800_A0_L2MC_PARITY_CONTROLr_SIZE
typedef BCM56800_A0_L2MC_PARITY_CONTROLr_t L2MC_PARITY_CONTROLr_t;
#define L2MC_PARITY_CONTROLr_CLR BCM56800_A0_L2MC_PARITY_CONTROLr_CLR
#define L2MC_PARITY_CONTROLr_SET BCM56800_A0_L2MC_PARITY_CONTROLr_SET
#define L2MC_PARITY_CONTROLr_GET BCM56800_A0_L2MC_PARITY_CONTROLr_GET
#define L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM56800_A0_L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM56800_A0_L2MC_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define L2MC_PARITY_CONTROLr_PARITY_ENf_GET BCM56800_A0_L2MC_PARITY_CONTROLr_PARITY_ENf_GET
#define L2MC_PARITY_CONTROLr_PARITY_ENf_SET BCM56800_A0_L2MC_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_L2MC_PARITY_CONTROLr BCM56800_A0_READ_L2MC_PARITY_CONTROLr
#define WRITE_L2MC_PARITY_CONTROLr BCM56800_A0_WRITE_L2MC_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2MC_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2MC_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2MC_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ENTRY_IDX        This field indicates the index to the entry in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM56800_A0_L2MC_PARITY_STATUSr 0x06180c12

#define BCM56800_A0_L2MC_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2MC_PARITY_STATUS.
 *
 */
typedef union BCM56800_A0_L2MC_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t l2mc_parity_status[1];
	uint32_t _l2mc_parity_status;
} BCM56800_A0_L2MC_PARITY_STATUSr_t;

#define BCM56800_A0_L2MC_PARITY_STATUSr_CLR(r) (r).l2mc_parity_status[0] = 0
#define BCM56800_A0_L2MC_PARITY_STATUSr_SET(r,d) (r).l2mc_parity_status[0] = d
#define BCM56800_A0_L2MC_PARITY_STATUSr_GET(r) (r).l2mc_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2MC_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).l2mc_parity_status[0]) & 0x1)
#define BCM56800_A0_L2MC_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).l2mc_parity_status[0]=(((r).l2mc_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2MC_PARITY_STATUSr_ENTRY_IDXf_GET(r) ((((r).l2mc_parity_status[0]) >> 1) & 0x1fff)
#define BCM56800_A0_L2MC_PARITY_STATUSr_ENTRY_IDXf_SET(r,f) (r).l2mc_parity_status[0]=(((r).l2mc_parity_status[0] & ~((uint32_t)0x1fff << 1)) | ((((uint32_t)f) & 0x1fff) << 1))

/*
 * These macros can be used to access L2MC_PARITY_STATUS.
 *
 */
#define BCM56800_A0_READ_L2MC_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2MC_PARITY_STATUSr,(r._l2mc_parity_status))
#define BCM56800_A0_WRITE_L2MC_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2MC_PARITY_STATUSr,&(r._l2mc_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2MC_PARITY_STATUSr BCM56800_A0_L2MC_PARITY_STATUSr
#define L2MC_PARITY_STATUSr_SIZE BCM56800_A0_L2MC_PARITY_STATUSr_SIZE
typedef BCM56800_A0_L2MC_PARITY_STATUSr_t L2MC_PARITY_STATUSr_t;
#define L2MC_PARITY_STATUSr_CLR BCM56800_A0_L2MC_PARITY_STATUSr_CLR
#define L2MC_PARITY_STATUSr_SET BCM56800_A0_L2MC_PARITY_STATUSr_SET
#define L2MC_PARITY_STATUSr_GET BCM56800_A0_L2MC_PARITY_STATUSr_GET
#define L2MC_PARITY_STATUSr_PARITY_ERRf_GET BCM56800_A0_L2MC_PARITY_STATUSr_PARITY_ERRf_GET
#define L2MC_PARITY_STATUSr_PARITY_ERRf_SET BCM56800_A0_L2MC_PARITY_STATUSr_PARITY_ERRf_SET
#define L2MC_PARITY_STATUSr_ENTRY_IDXf_GET BCM56800_A0_L2MC_PARITY_STATUSr_ENTRY_IDXf_GET
#define L2MC_PARITY_STATUSr_ENTRY_IDXf_SET BCM56800_A0_L2MC_PARITY_STATUSr_ENTRY_IDXf_SET
#define READ_L2MC_PARITY_STATUSr BCM56800_A0_READ_L2MC_PARITY_STATUSr
#define WRITE_L2MC_PARITY_STATUSr BCM56800_A0_WRITE_L2MC_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2MC_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2X
 * BLOCKS:   IPIPE
 * DESC:     Combined HW managed L2 entry table.  Includes L2_ENTRY, L2_HITDA, and L2_HITSA, FeatureSpecific-Ethernet
 * SIZE:     94
 * FIELDS:
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     CPU              CPU bit
 *     DST_DISCARD      Dst Discard
 *     SRC_DISCARD      Src Discard
 *     SCP              SCP bit
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     L3               Indicates an L3 entry
 *     MAC_BLOCK_INDEX  MAC Block Index
 *     STATIC_BIT       Indicates entry is SW programmed and static
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity for the L2_ENTRY RAM fields (i.e. excludes HIT bits)
 *     HITDA            Dst hit update bit
 *     HITSA            Src hit update bit
 *     L2MC_PTR         Overlay of L2MC pointer
 *     TGID_LO          Overlay of TGID bit only - excludes T bit
 *     T                Trunk bit overlay
 *     TGID_HI          Legacy overlay of TGID on Module_ID
 *     REMOTE_TRUNK     Remote Trunk bit indicates HiGig pkt with remote modid
 *
 ******************************************************************************/
#define BCM56800_A0_L2Xm 0x06120000

#define BCM56800_A0_L2Xm_MIN 0
#define BCM56800_A0_L2Xm_MAX 16383
#define BCM56800_A0_L2Xm_CMAX(u) 16383
#define BCM56800_A0_L2Xm_SIZE 12

/*
 * This structure should be used to declare and program L2X.
 *
 */
typedef union BCM56800_A0_L2Xm_s {
	uint32_t v[3];
	uint32_t l2x[3];
	uint32_t _l2x;
} BCM56800_A0_L2Xm_t;

#define BCM56800_A0_L2Xm_CLR(r) CDK_MEMSET(&((r)._l2x), 0, sizeof(BCM56800_A0_L2Xm_t))
#define BCM56800_A0_L2Xm_SET(r,i,d) (r).l2x[i] = d
#define BCM56800_A0_L2Xm_GET(r,i) (r).l2x[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2Xm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2x,0,47,a)
#define BCM56800_A0_L2Xm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2x,0,47,a)
#define BCM56800_A0_L2Xm_VLAN_IDf_GET(r) ((((r).l2x[1]) >> 16) & 0xfff)
#define BCM56800_A0_L2Xm_VLAN_IDf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56800_A0_L2Xm_PRIf_GET(r) ((((r).l2x[1]) >> 28) & 0x7)
#define BCM56800_A0_L2Xm_PRIf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_L2Xm_CPUf_GET(r) ((((r).l2x[1]) >> 31) & 0x1)
#define BCM56800_A0_L2Xm_CPUf_SET(r,f) (r).l2x[1]=(((r).l2x[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L2Xm_DST_DISCARDf_GET(r) (((r).l2x[2]) & 0x1)
#define BCM56800_A0_L2Xm_DST_DISCARDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2Xm_SRC_DISCARDf_GET(r) ((((r).l2x[2]) >> 1) & 0x1)
#define BCM56800_A0_L2Xm_SRC_DISCARDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L2Xm_SCPf_GET(r) ((((r).l2x[2]) >> 2) & 0x1)
#define BCM56800_A0_L2Xm_SCPf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L2Xm_PORT_TGIDf_GET(r) ((((r).l2x[2]) >> 3) & 0x3f)
#define BCM56800_A0_L2Xm_PORT_TGIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM56800_A0_L2Xm_MODULE_IDf_GET(r) ((((r).l2x[2]) >> 9) & 0x7f)
#define BCM56800_A0_L2Xm_MODULE_IDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM56800_A0_L2Xm_L3f_GET(r) ((((r).l2x[2]) >> 16) & 0x1)
#define BCM56800_A0_L2Xm_L3f_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_L2Xm_MAC_BLOCK_INDEXf_GET(r) ((((r).l2x[2]) >> 17) & 0x1f)
#define BCM56800_A0_L2Xm_MAC_BLOCK_INDEXf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM56800_A0_L2Xm_STATIC_BITf_GET(r) ((((r).l2x[2]) >> 23) & 0x1)
#define BCM56800_A0_L2Xm_STATIC_BITf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_L2Xm_RPEf_GET(r) ((((r).l2x[2]) >> 24) & 0x1)
#define BCM56800_A0_L2Xm_RPEf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_L2Xm_MIRRORf_GET(r) ((((r).l2x[2]) >> 25) & 0x1)
#define BCM56800_A0_L2Xm_MIRRORf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_L2Xm_VALIDf_GET(r) ((((r).l2x[2]) >> 26) & 0x1)
#define BCM56800_A0_L2Xm_VALIDf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_L2Xm_EVEN_PARITYf_GET(r) ((((r).l2x[2]) >> 27) & 0x1)
#define BCM56800_A0_L2Xm_EVEN_PARITYf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_L2Xm_HITDAf_GET(r) ((((r).l2x[2]) >> 28) & 0x1)
#define BCM56800_A0_L2Xm_HITDAf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_L2Xm_HITSAf_GET(r) ((((r).l2x[2]) >> 29) & 0x1)
#define BCM56800_A0_L2Xm_HITSAf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_L2Xm_L2MC_PTRf_GET(r) ((((r).l2x[2]) >> 3) & 0x1fff)
#define BCM56800_A0_L2Xm_L2MC_PTRf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))
#define BCM56800_A0_L2Xm_TGID_LOf_GET(r) ((((r).l2x[2]) >> 3) & 0x1f)
#define BCM56800_A0_L2Xm_TGID_LOf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56800_A0_L2Xm_Tf_GET(r) ((((r).l2x[2]) >> 8) & 0x1)
#define BCM56800_A0_L2Xm_Tf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_L2Xm_TGID_HIf_GET(r) ((((r).l2x[2]) >> 9) & 0x3)
#define BCM56800_A0_L2Xm_TGID_HIf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM56800_A0_L2Xm_REMOTE_TRUNKf_GET(r) ((((r).l2x[2]) >> 15) & 0x1)
#define BCM56800_A0_L2Xm_REMOTE_TRUNKf_SET(r,f) (r).l2x[2]=(((r).l2x[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access L2X.
 *
 */
#define BCM56800_A0_READ_L2Xm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2Xm,i,(m._l2x),3)
#define BCM56800_A0_WRITE_L2Xm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2Xm,i,&(m._l2x),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2Xm BCM56800_A0_L2Xm
#define L2Xm_MIN BCM56800_A0_L2Xm_MIN
#define L2Xm_MAX BCM56800_A0_L2Xm_MAX
#define L2Xm_CMAX(u) BCM56800_A0_L2Xm_CMAX(u)
#define L2Xm_SIZE BCM56800_A0_L2Xm_SIZE
typedef BCM56800_A0_L2Xm_t L2Xm_t;
#define L2Xm_CLR BCM56800_A0_L2Xm_CLR
#define L2Xm_SET BCM56800_A0_L2Xm_SET
#define L2Xm_GET BCM56800_A0_L2Xm_GET
#define L2Xm_MAC_ADDRf_GET BCM56800_A0_L2Xm_MAC_ADDRf_GET
#define L2Xm_MAC_ADDRf_SET BCM56800_A0_L2Xm_MAC_ADDRf_SET
#define L2Xm_VLAN_IDf_GET BCM56800_A0_L2Xm_VLAN_IDf_GET
#define L2Xm_VLAN_IDf_SET BCM56800_A0_L2Xm_VLAN_IDf_SET
#define L2Xm_PRIf_GET BCM56800_A0_L2Xm_PRIf_GET
#define L2Xm_PRIf_SET BCM56800_A0_L2Xm_PRIf_SET
#define L2Xm_CPUf_GET BCM56800_A0_L2Xm_CPUf_GET
#define L2Xm_CPUf_SET BCM56800_A0_L2Xm_CPUf_SET
#define L2Xm_DST_DISCARDf_GET BCM56800_A0_L2Xm_DST_DISCARDf_GET
#define L2Xm_DST_DISCARDf_SET BCM56800_A0_L2Xm_DST_DISCARDf_SET
#define L2Xm_SRC_DISCARDf_GET BCM56800_A0_L2Xm_SRC_DISCARDf_GET
#define L2Xm_SRC_DISCARDf_SET BCM56800_A0_L2Xm_SRC_DISCARDf_SET
#define L2Xm_SCPf_GET BCM56800_A0_L2Xm_SCPf_GET
#define L2Xm_SCPf_SET BCM56800_A0_L2Xm_SCPf_SET
#define L2Xm_PORT_TGIDf_GET BCM56800_A0_L2Xm_PORT_TGIDf_GET
#define L2Xm_PORT_TGIDf_SET BCM56800_A0_L2Xm_PORT_TGIDf_SET
#define L2Xm_MODULE_IDf_GET BCM56800_A0_L2Xm_MODULE_IDf_GET
#define L2Xm_MODULE_IDf_SET BCM56800_A0_L2Xm_MODULE_IDf_SET
#define L2Xm_L3f_GET BCM56800_A0_L2Xm_L3f_GET
#define L2Xm_L3f_SET BCM56800_A0_L2Xm_L3f_SET
#define L2Xm_MAC_BLOCK_INDEXf_GET BCM56800_A0_L2Xm_MAC_BLOCK_INDEXf_GET
#define L2Xm_MAC_BLOCK_INDEXf_SET BCM56800_A0_L2Xm_MAC_BLOCK_INDEXf_SET
#define L2Xm_STATIC_BITf_GET BCM56800_A0_L2Xm_STATIC_BITf_GET
#define L2Xm_STATIC_BITf_SET BCM56800_A0_L2Xm_STATIC_BITf_SET
#define L2Xm_RPEf_GET BCM56800_A0_L2Xm_RPEf_GET
#define L2Xm_RPEf_SET BCM56800_A0_L2Xm_RPEf_SET
#define L2Xm_MIRRORf_GET BCM56800_A0_L2Xm_MIRRORf_GET
#define L2Xm_MIRRORf_SET BCM56800_A0_L2Xm_MIRRORf_SET
#define L2Xm_VALIDf_GET BCM56800_A0_L2Xm_VALIDf_GET
#define L2Xm_VALIDf_SET BCM56800_A0_L2Xm_VALIDf_SET
#define L2Xm_EVEN_PARITYf_GET BCM56800_A0_L2Xm_EVEN_PARITYf_GET
#define L2Xm_EVEN_PARITYf_SET BCM56800_A0_L2Xm_EVEN_PARITYf_SET
#define L2Xm_HITDAf_GET BCM56800_A0_L2Xm_HITDAf_GET
#define L2Xm_HITDAf_SET BCM56800_A0_L2Xm_HITDAf_SET
#define L2Xm_HITSAf_GET BCM56800_A0_L2Xm_HITSAf_GET
#define L2Xm_HITSAf_SET BCM56800_A0_L2Xm_HITSAf_SET
#define L2Xm_L2MC_PTRf_GET BCM56800_A0_L2Xm_L2MC_PTRf_GET
#define L2Xm_L2MC_PTRf_SET BCM56800_A0_L2Xm_L2MC_PTRf_SET
#define L2Xm_TGID_LOf_GET BCM56800_A0_L2Xm_TGID_LOf_GET
#define L2Xm_TGID_LOf_SET BCM56800_A0_L2Xm_TGID_LOf_SET
#define L2Xm_Tf_GET BCM56800_A0_L2Xm_Tf_GET
#define L2Xm_Tf_SET BCM56800_A0_L2Xm_Tf_SET
#define L2Xm_TGID_HIf_GET BCM56800_A0_L2Xm_TGID_HIf_GET
#define L2Xm_TGID_HIf_SET BCM56800_A0_L2Xm_TGID_HIf_SET
#define L2Xm_REMOTE_TRUNKf_GET BCM56800_A0_L2Xm_REMOTE_TRUNKf_GET
#define L2Xm_REMOTE_TRUNKf_SET BCM56800_A0_L2Xm_REMOTE_TRUNKf_SET
#define READ_L2Xm BCM56800_A0_READ_L2Xm
#define WRITE_L2Xm BCM56800_A0_WRITE_L2Xm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2Xm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_AGE_DEBUG
 * BLOCKS:   IPIPE
 * DESC:     Age Debug Register
 * SIZE:     32
 * FIELDS:
 *     AGE_COUNT        Indicates last bucket to be aged (for all timer-based and per-port aging)
 *     START            initiate software-based timer aging (should not be started while timer-based aging is enabled)
 *     COMPLETE         signal software-based timer aging is complete
 *
 ******************************************************************************/
#define BCM56800_A0_L2_AGE_DEBUGr 0x00180206

#define BCM56800_A0_L2_AGE_DEBUGr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_DEBUG.
 *
 */
typedef union BCM56800_A0_L2_AGE_DEBUGr_s {
	uint32_t v[1];
	uint32_t l2_age_debug[1];
	uint32_t _l2_age_debug;
} BCM56800_A0_L2_AGE_DEBUGr_t;

#define BCM56800_A0_L2_AGE_DEBUGr_CLR(r) (r).l2_age_debug[0] = 0
#define BCM56800_A0_L2_AGE_DEBUGr_SET(r,d) (r).l2_age_debug[0] = d
#define BCM56800_A0_L2_AGE_DEBUGr_GET(r) (r).l2_age_debug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_AGE_DEBUGr_AGE_COUNTf_GET(r) (((r).l2_age_debug[0]) & 0x7ff)
#define BCM56800_A0_L2_AGE_DEBUGr_AGE_COUNTf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56800_A0_L2_AGE_DEBUGr_STARTf_GET(r) ((((r).l2_age_debug[0]) >> 11) & 0x1)
#define BCM56800_A0_L2_AGE_DEBUGr_STARTf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_L2_AGE_DEBUGr_COMPLETEf_GET(r) ((((r).l2_age_debug[0]) >> 12) & 0x1)
#define BCM56800_A0_L2_AGE_DEBUGr_COMPLETEf_SET(r,f) (r).l2_age_debug[0]=(((r).l2_age_debug[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access L2_AGE_DEBUG.
 *
 */
#define BCM56800_A0_READ_L2_AGE_DEBUGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_AGE_DEBUGr,(r._l2_age_debug))
#define BCM56800_A0_WRITE_L2_AGE_DEBUGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_AGE_DEBUGr,&(r._l2_age_debug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_AGE_DEBUGr BCM56800_A0_L2_AGE_DEBUGr
#define L2_AGE_DEBUGr_SIZE BCM56800_A0_L2_AGE_DEBUGr_SIZE
typedef BCM56800_A0_L2_AGE_DEBUGr_t L2_AGE_DEBUGr_t;
#define L2_AGE_DEBUGr_CLR BCM56800_A0_L2_AGE_DEBUGr_CLR
#define L2_AGE_DEBUGr_SET BCM56800_A0_L2_AGE_DEBUGr_SET
#define L2_AGE_DEBUGr_GET BCM56800_A0_L2_AGE_DEBUGr_GET
#define L2_AGE_DEBUGr_AGE_COUNTf_GET BCM56800_A0_L2_AGE_DEBUGr_AGE_COUNTf_GET
#define L2_AGE_DEBUGr_AGE_COUNTf_SET BCM56800_A0_L2_AGE_DEBUGr_AGE_COUNTf_SET
#define L2_AGE_DEBUGr_STARTf_GET BCM56800_A0_L2_AGE_DEBUGr_STARTf_GET
#define L2_AGE_DEBUGr_STARTf_SET BCM56800_A0_L2_AGE_DEBUGr_STARTf_SET
#define L2_AGE_DEBUGr_COMPLETEf_GET BCM56800_A0_L2_AGE_DEBUGr_COMPLETEf_GET
#define L2_AGE_DEBUGr_COMPLETEf_SET BCM56800_A0_L2_AGE_DEBUGr_COMPLETEf_SET
#define READ_L2_AGE_DEBUGr BCM56800_A0_READ_L2_AGE_DEBUGr
#define WRITE_L2_AGE_DEBUGr BCM56800_A0_WRITE_L2_AGE_DEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_AGE_DEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_AGE_TIMER
 * BLOCKS:   IPIPE
 * DESC:     Age Timer Register
 * SIZE:     32
 * FIELDS:
 *     AGE_VAL          Age Limit
 *     AGE_ENA          Age Enable
 *
 ******************************************************************************/
#define BCM56800_A0_L2_AGE_TIMERr 0x00180204

#define BCM56800_A0_L2_AGE_TIMERr_SIZE 4

/*
 * This structure should be used to declare and program L2_AGE_TIMER.
 *
 */
typedef union BCM56800_A0_L2_AGE_TIMERr_s {
	uint32_t v[1];
	uint32_t l2_age_timer[1];
	uint32_t _l2_age_timer;
} BCM56800_A0_L2_AGE_TIMERr_t;

#define BCM56800_A0_L2_AGE_TIMERr_CLR(r) (r).l2_age_timer[0] = 0
#define BCM56800_A0_L2_AGE_TIMERr_SET(r,d) (r).l2_age_timer[0] = d
#define BCM56800_A0_L2_AGE_TIMERr_GET(r) (r).l2_age_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_AGE_TIMERr_AGE_VALf_GET(r) (((r).l2_age_timer[0]) & 0xfffff)
#define BCM56800_A0_L2_AGE_TIMERr_AGE_VALf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM56800_A0_L2_AGE_TIMERr_AGE_ENAf_GET(r) ((((r).l2_age_timer[0]) >> 20) & 0x1)
#define BCM56800_A0_L2_AGE_TIMERr_AGE_ENAf_SET(r,f) (r).l2_age_timer[0]=(((r).l2_age_timer[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access L2_AGE_TIMER.
 *
 */
#define BCM56800_A0_READ_L2_AGE_TIMERr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_AGE_TIMERr,(r._l2_age_timer))
#define BCM56800_A0_WRITE_L2_AGE_TIMERr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_AGE_TIMERr,&(r._l2_age_timer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_AGE_TIMERr BCM56800_A0_L2_AGE_TIMERr
#define L2_AGE_TIMERr_SIZE BCM56800_A0_L2_AGE_TIMERr_SIZE
typedef BCM56800_A0_L2_AGE_TIMERr_t L2_AGE_TIMERr_t;
#define L2_AGE_TIMERr_CLR BCM56800_A0_L2_AGE_TIMERr_CLR
#define L2_AGE_TIMERr_SET BCM56800_A0_L2_AGE_TIMERr_SET
#define L2_AGE_TIMERr_GET BCM56800_A0_L2_AGE_TIMERr_GET
#define L2_AGE_TIMERr_AGE_VALf_GET BCM56800_A0_L2_AGE_TIMERr_AGE_VALf_GET
#define L2_AGE_TIMERr_AGE_VALf_SET BCM56800_A0_L2_AGE_TIMERr_AGE_VALf_SET
#define L2_AGE_TIMERr_AGE_ENAf_GET BCM56800_A0_L2_AGE_TIMERr_AGE_ENAf_GET
#define L2_AGE_TIMERr_AGE_ENAf_SET BCM56800_A0_L2_AGE_TIMERr_AGE_ENAf_SET
#define READ_L2_AGE_TIMERr BCM56800_A0_READ_L2_AGE_TIMERr
#define WRITE_L2_AGE_TIMERr BCM56800_A0_WRITE_L2_AGE_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_AGE_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_ENTRY_DBGCTRL0
 * BLOCKS:   IPIPE
 * DESC:     FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     RAM0_TM          TM debug bits for RAM0
 *     RAM1_TM          TM debug bits for RAM1
 *     RAM2_TM          TM debug bits for RAM2
 *     RAM3_TM          TM debug bits for RAM3
 *
 ******************************************************************************/
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r 0x06180209

#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_DBGCTRL0.
 *
 */
typedef union BCM56800_A0_L2_ENTRY_DBGCTRL0r_s {
	uint32_t v[1];
	uint32_t l2_entry_dbgctrl0[1];
	uint32_t _l2_entry_dbgctrl0;
} BCM56800_A0_L2_ENTRY_DBGCTRL0r_t;

#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_CLR(r) (r).l2_entry_dbgctrl0[0] = 0
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_SET(r,d) (r).l2_entry_dbgctrl0[0] = d
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_GET(r) (r).l2_entry_dbgctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM0_TMf_GET(r) (((r).l2_entry_dbgctrl0[0]) & 0xff)
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM0_TMf_SET(r,f) (r).l2_entry_dbgctrl0[0]=(((r).l2_entry_dbgctrl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM1_TMf_GET(r) ((((r).l2_entry_dbgctrl0[0]) >> 8) & 0xff)
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM1_TMf_SET(r,f) (r).l2_entry_dbgctrl0[0]=(((r).l2_entry_dbgctrl0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM2_TMf_GET(r) ((((r).l2_entry_dbgctrl0[0]) >> 16) & 0xff)
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM2_TMf_SET(r,f) (r).l2_entry_dbgctrl0[0]=(((r).l2_entry_dbgctrl0[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM3_TMf_GET(r) ((((r).l2_entry_dbgctrl0[0]) >> 24) & 0xff)
#define BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM3_TMf_SET(r,f) (r).l2_entry_dbgctrl0[0]=(((r).l2_entry_dbgctrl0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access L2_ENTRY_DBGCTRL0.
 *
 */
#define BCM56800_A0_READ_L2_ENTRY_DBGCTRL0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_ENTRY_DBGCTRL0r,(r._l2_entry_dbgctrl0))
#define BCM56800_A0_WRITE_L2_ENTRY_DBGCTRL0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_ENTRY_DBGCTRL0r,&(r._l2_entry_dbgctrl0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_DBGCTRL0r BCM56800_A0_L2_ENTRY_DBGCTRL0r
#define L2_ENTRY_DBGCTRL0r_SIZE BCM56800_A0_L2_ENTRY_DBGCTRL0r_SIZE
typedef BCM56800_A0_L2_ENTRY_DBGCTRL0r_t L2_ENTRY_DBGCTRL0r_t;
#define L2_ENTRY_DBGCTRL0r_CLR BCM56800_A0_L2_ENTRY_DBGCTRL0r_CLR
#define L2_ENTRY_DBGCTRL0r_SET BCM56800_A0_L2_ENTRY_DBGCTRL0r_SET
#define L2_ENTRY_DBGCTRL0r_GET BCM56800_A0_L2_ENTRY_DBGCTRL0r_GET
#define L2_ENTRY_DBGCTRL0r_RAM0_TMf_GET BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM0_TMf_GET
#define L2_ENTRY_DBGCTRL0r_RAM0_TMf_SET BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM0_TMf_SET
#define L2_ENTRY_DBGCTRL0r_RAM1_TMf_GET BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM1_TMf_GET
#define L2_ENTRY_DBGCTRL0r_RAM1_TMf_SET BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM1_TMf_SET
#define L2_ENTRY_DBGCTRL0r_RAM2_TMf_GET BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM2_TMf_GET
#define L2_ENTRY_DBGCTRL0r_RAM2_TMf_SET BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM2_TMf_SET
#define L2_ENTRY_DBGCTRL0r_RAM3_TMf_GET BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM3_TMf_GET
#define L2_ENTRY_DBGCTRL0r_RAM3_TMf_SET BCM56800_A0_L2_ENTRY_DBGCTRL0r_RAM3_TMf_SET
#define READ_L2_ENTRY_DBGCTRL0r BCM56800_A0_READ_L2_ENTRY_DBGCTRL0r
#define WRITE_L2_ENTRY_DBGCTRL0r BCM56800_A0_WRITE_L2_ENTRY_DBGCTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_ENTRY_DBGCTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_ENTRY_DBGCTRL1
 * BLOCKS:   IPIPE
 * DESC:     FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     RAM4_TM          TM debug bits for RAM4
 *     RAM5_TM          TM debug bits for RAM5
 *     RAM6_TM          TM debug bits for RAM6
 *     RAM7_TM          TM debug bits for RAM7
 *
 ******************************************************************************/
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r 0x0618020a

#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_DBGCTRL1.
 *
 */
typedef union BCM56800_A0_L2_ENTRY_DBGCTRL1r_s {
	uint32_t v[1];
	uint32_t l2_entry_dbgctrl1[1];
	uint32_t _l2_entry_dbgctrl1;
} BCM56800_A0_L2_ENTRY_DBGCTRL1r_t;

#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_CLR(r) (r).l2_entry_dbgctrl1[0] = 0
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_SET(r,d) (r).l2_entry_dbgctrl1[0] = d
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_GET(r) (r).l2_entry_dbgctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM4_TMf_GET(r) (((r).l2_entry_dbgctrl1[0]) & 0xff)
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM4_TMf_SET(r,f) (r).l2_entry_dbgctrl1[0]=(((r).l2_entry_dbgctrl1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM5_TMf_GET(r) ((((r).l2_entry_dbgctrl1[0]) >> 8) & 0xff)
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM5_TMf_SET(r,f) (r).l2_entry_dbgctrl1[0]=(((r).l2_entry_dbgctrl1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM6_TMf_GET(r) ((((r).l2_entry_dbgctrl1[0]) >> 16) & 0xff)
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM6_TMf_SET(r,f) (r).l2_entry_dbgctrl1[0]=(((r).l2_entry_dbgctrl1[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM7_TMf_GET(r) ((((r).l2_entry_dbgctrl1[0]) >> 24) & 0xff)
#define BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM7_TMf_SET(r,f) (r).l2_entry_dbgctrl1[0]=(((r).l2_entry_dbgctrl1[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access L2_ENTRY_DBGCTRL1.
 *
 */
#define BCM56800_A0_READ_L2_ENTRY_DBGCTRL1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_ENTRY_DBGCTRL1r,(r._l2_entry_dbgctrl1))
#define BCM56800_A0_WRITE_L2_ENTRY_DBGCTRL1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_ENTRY_DBGCTRL1r,&(r._l2_entry_dbgctrl1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_DBGCTRL1r BCM56800_A0_L2_ENTRY_DBGCTRL1r
#define L2_ENTRY_DBGCTRL1r_SIZE BCM56800_A0_L2_ENTRY_DBGCTRL1r_SIZE
typedef BCM56800_A0_L2_ENTRY_DBGCTRL1r_t L2_ENTRY_DBGCTRL1r_t;
#define L2_ENTRY_DBGCTRL1r_CLR BCM56800_A0_L2_ENTRY_DBGCTRL1r_CLR
#define L2_ENTRY_DBGCTRL1r_SET BCM56800_A0_L2_ENTRY_DBGCTRL1r_SET
#define L2_ENTRY_DBGCTRL1r_GET BCM56800_A0_L2_ENTRY_DBGCTRL1r_GET
#define L2_ENTRY_DBGCTRL1r_RAM4_TMf_GET BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM4_TMf_GET
#define L2_ENTRY_DBGCTRL1r_RAM4_TMf_SET BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM4_TMf_SET
#define L2_ENTRY_DBGCTRL1r_RAM5_TMf_GET BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM5_TMf_GET
#define L2_ENTRY_DBGCTRL1r_RAM5_TMf_SET BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM5_TMf_SET
#define L2_ENTRY_DBGCTRL1r_RAM6_TMf_GET BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM6_TMf_GET
#define L2_ENTRY_DBGCTRL1r_RAM6_TMf_SET BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM6_TMf_SET
#define L2_ENTRY_DBGCTRL1r_RAM7_TMf_GET BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM7_TMf_GET
#define L2_ENTRY_DBGCTRL1r_RAM7_TMf_SET BCM56800_A0_L2_ENTRY_DBGCTRL1r_RAM7_TMf_SET
#define READ_L2_ENTRY_DBGCTRL1r BCM56800_A0_READ_L2_ENTRY_DBGCTRL1r
#define WRITE_L2_ENTRY_DBGCTRL1r BCM56800_A0_WRITE_L2_ENTRY_DBGCTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_ENTRY_DBGCTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_ENTRY table only.  Does not include L2_HITSA or L2_HITDA, FeatureSpecific-Ethernet
 * SIZE:     92
 * FIELDS:
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     CPU              CPU bit
 *     DST_DISCARD      Dst Discard
 *     SRC_DISCARD      Src Discard
 *     SCP              SCP bit
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     L3               Indicates an L3 entry
 *     MAC_BLOCK_INDEX  MAC Block Index
 *     STATIC_BIT       Indicates entry is SW programmed and static
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity for the L2_ENTRY RAM fields (i.e. excludes HIT bits)
 *     L2MC_PTR         Overlay of L2MC pointer
 *     TGID_LO          Overlay of TGID bit only - excludes T bit
 *     T                Trunk bit overlay
 *     TGID_HI          Legacy overlay of TGID on Module_ID
 *     REMOTE_TRUNK     Remote Trunk bit indicates HiGig pkt with remote modid
 *
 ******************************************************************************/
#define BCM56800_A0_L2_ENTRY_ONLYm 0x06128000

#define BCM56800_A0_L2_ENTRY_ONLYm_MIN 0
#define BCM56800_A0_L2_ENTRY_ONLYm_MAX 16383
#define BCM56800_A0_L2_ENTRY_ONLYm_CMAX(u) 16383
#define BCM56800_A0_L2_ENTRY_ONLYm_SIZE 12

/*
 * This structure should be used to declare and program L2_ENTRY_ONLY.
 *
 */
typedef union BCM56800_A0_L2_ENTRY_ONLYm_s {
	uint32_t v[3];
	uint32_t l2_entry_only[3];
	uint32_t _l2_entry_only;
} BCM56800_A0_L2_ENTRY_ONLYm_t;

#define BCM56800_A0_L2_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l2_entry_only), 0, sizeof(BCM56800_A0_L2_ENTRY_ONLYm_t))
#define BCM56800_A0_L2_ENTRY_ONLYm_SET(r,i,d) (r).l2_entry_only[i] = d
#define BCM56800_A0_L2_ENTRY_ONLYm_GET(r,i) (r).l2_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_ENTRY_ONLYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_entry_only,0,47,a)
#define BCM56800_A0_L2_ENTRY_ONLYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_entry_only,0,47,a)
#define BCM56800_A0_L2_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l2_entry_only[1]) >> 16) & 0xfff)
#define BCM56800_A0_L2_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56800_A0_L2_ENTRY_ONLYm_PRIf_GET(r) ((((r).l2_entry_only[1]) >> 28) & 0x7)
#define BCM56800_A0_L2_ENTRY_ONLYm_PRIf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_L2_ENTRY_ONLYm_CPUf_GET(r) ((((r).l2_entry_only[1]) >> 31) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_CPUf_SET(r,f) (r).l2_entry_only[1]=(((r).l2_entry_only[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L2_ENTRY_ONLYm_DST_DISCARDf_GET(r) (((r).l2_entry_only[2]) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_DST_DISCARDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_GET(r) ((((r).l2_entry_only[2]) >> 1) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L2_ENTRY_ONLYm_SCPf_GET(r) ((((r).l2_entry_only[2]) >> 2) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_SCPf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L2_ENTRY_ONLYm_PORT_TGIDf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x3f)
#define BCM56800_A0_L2_ENTRY_ONLYm_PORT_TGIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3))
#define BCM56800_A0_L2_ENTRY_ONLYm_MODULE_IDf_GET(r) ((((r).l2_entry_only[2]) >> 9) & 0x7f)
#define BCM56800_A0_L2_ENTRY_ONLYm_MODULE_IDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM56800_A0_L2_ENTRY_ONLYm_L3f_GET(r) ((((r).l2_entry_only[2]) >> 16) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_L3f_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET(r) ((((r).l2_entry_only[2]) >> 17) & 0x1f)
#define BCM56800_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1f << 17)) | ((((uint32_t)f) & 0x1f) << 17))
#define BCM56800_A0_L2_ENTRY_ONLYm_STATIC_BITf_GET(r) ((((r).l2_entry_only[2]) >> 23) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_STATIC_BITf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_L2_ENTRY_ONLYm_RPEf_GET(r) ((((r).l2_entry_only[2]) >> 24) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_RPEf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_L2_ENTRY_ONLYm_MIRRORf_GET(r) ((((r).l2_entry_only[2]) >> 25) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_MIRRORf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_L2_ENTRY_ONLYm_VALIDf_GET(r) ((((r).l2_entry_only[2]) >> 26) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_GET(r) ((((r).l2_entry_only[2]) >> 27) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_L2_ENTRY_ONLYm_L2MC_PTRf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x1fff)
#define BCM56800_A0_L2_ENTRY_ONLYm_L2MC_PTRf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))
#define BCM56800_A0_L2_ENTRY_ONLYm_TGID_LOf_GET(r) ((((r).l2_entry_only[2]) >> 3) & 0x1f)
#define BCM56800_A0_L2_ENTRY_ONLYm_TGID_LOf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))
#define BCM56800_A0_L2_ENTRY_ONLYm_Tf_GET(r) ((((r).l2_entry_only[2]) >> 8) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_Tf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_L2_ENTRY_ONLYm_TGID_HIf_GET(r) ((((r).l2_entry_only[2]) >> 9) & 0x3)
#define BCM56800_A0_L2_ENTRY_ONLYm_TGID_HIf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM56800_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET(r) ((((r).l2_entry_only[2]) >> 15) & 0x1)
#define BCM56800_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET(r,f) (r).l2_entry_only[2]=(((r).l2_entry_only[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access L2_ENTRY_ONLY.
 *
 */
#define BCM56800_A0_READ_L2_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2_ENTRY_ONLYm,i,(m._l2_entry_only),3)
#define BCM56800_A0_WRITE_L2_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2_ENTRY_ONLYm,i,&(m._l2_entry_only),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_ONLYm BCM56800_A0_L2_ENTRY_ONLYm
#define L2_ENTRY_ONLYm_MIN BCM56800_A0_L2_ENTRY_ONLYm_MIN
#define L2_ENTRY_ONLYm_MAX BCM56800_A0_L2_ENTRY_ONLYm_MAX
#define L2_ENTRY_ONLYm_CMAX(u) BCM56800_A0_L2_ENTRY_ONLYm_CMAX(u)
#define L2_ENTRY_ONLYm_SIZE BCM56800_A0_L2_ENTRY_ONLYm_SIZE
typedef BCM56800_A0_L2_ENTRY_ONLYm_t L2_ENTRY_ONLYm_t;
#define L2_ENTRY_ONLYm_CLR BCM56800_A0_L2_ENTRY_ONLYm_CLR
#define L2_ENTRY_ONLYm_SET BCM56800_A0_L2_ENTRY_ONLYm_SET
#define L2_ENTRY_ONLYm_GET BCM56800_A0_L2_ENTRY_ONLYm_GET
#define L2_ENTRY_ONLYm_MAC_ADDRf_GET BCM56800_A0_L2_ENTRY_ONLYm_MAC_ADDRf_GET
#define L2_ENTRY_ONLYm_MAC_ADDRf_SET BCM56800_A0_L2_ENTRY_ONLYm_MAC_ADDRf_SET
#define L2_ENTRY_ONLYm_VLAN_IDf_GET BCM56800_A0_L2_ENTRY_ONLYm_VLAN_IDf_GET
#define L2_ENTRY_ONLYm_VLAN_IDf_SET BCM56800_A0_L2_ENTRY_ONLYm_VLAN_IDf_SET
#define L2_ENTRY_ONLYm_PRIf_GET BCM56800_A0_L2_ENTRY_ONLYm_PRIf_GET
#define L2_ENTRY_ONLYm_PRIf_SET BCM56800_A0_L2_ENTRY_ONLYm_PRIf_SET
#define L2_ENTRY_ONLYm_CPUf_GET BCM56800_A0_L2_ENTRY_ONLYm_CPUf_GET
#define L2_ENTRY_ONLYm_CPUf_SET BCM56800_A0_L2_ENTRY_ONLYm_CPUf_SET
#define L2_ENTRY_ONLYm_DST_DISCARDf_GET BCM56800_A0_L2_ENTRY_ONLYm_DST_DISCARDf_GET
#define L2_ENTRY_ONLYm_DST_DISCARDf_SET BCM56800_A0_L2_ENTRY_ONLYm_DST_DISCARDf_SET
#define L2_ENTRY_ONLYm_SRC_DISCARDf_GET BCM56800_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_GET
#define L2_ENTRY_ONLYm_SRC_DISCARDf_SET BCM56800_A0_L2_ENTRY_ONLYm_SRC_DISCARDf_SET
#define L2_ENTRY_ONLYm_SCPf_GET BCM56800_A0_L2_ENTRY_ONLYm_SCPf_GET
#define L2_ENTRY_ONLYm_SCPf_SET BCM56800_A0_L2_ENTRY_ONLYm_SCPf_SET
#define L2_ENTRY_ONLYm_PORT_TGIDf_GET BCM56800_A0_L2_ENTRY_ONLYm_PORT_TGIDf_GET
#define L2_ENTRY_ONLYm_PORT_TGIDf_SET BCM56800_A0_L2_ENTRY_ONLYm_PORT_TGIDf_SET
#define L2_ENTRY_ONLYm_MODULE_IDf_GET BCM56800_A0_L2_ENTRY_ONLYm_MODULE_IDf_GET
#define L2_ENTRY_ONLYm_MODULE_IDf_SET BCM56800_A0_L2_ENTRY_ONLYm_MODULE_IDf_SET
#define L2_ENTRY_ONLYm_L3f_GET BCM56800_A0_L2_ENTRY_ONLYm_L3f_GET
#define L2_ENTRY_ONLYm_L3f_SET BCM56800_A0_L2_ENTRY_ONLYm_L3f_SET
#define L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET BCM56800_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_GET
#define L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET BCM56800_A0_L2_ENTRY_ONLYm_MAC_BLOCK_INDEXf_SET
#define L2_ENTRY_ONLYm_STATIC_BITf_GET BCM56800_A0_L2_ENTRY_ONLYm_STATIC_BITf_GET
#define L2_ENTRY_ONLYm_STATIC_BITf_SET BCM56800_A0_L2_ENTRY_ONLYm_STATIC_BITf_SET
#define L2_ENTRY_ONLYm_RPEf_GET BCM56800_A0_L2_ENTRY_ONLYm_RPEf_GET
#define L2_ENTRY_ONLYm_RPEf_SET BCM56800_A0_L2_ENTRY_ONLYm_RPEf_SET
#define L2_ENTRY_ONLYm_MIRRORf_GET BCM56800_A0_L2_ENTRY_ONLYm_MIRRORf_GET
#define L2_ENTRY_ONLYm_MIRRORf_SET BCM56800_A0_L2_ENTRY_ONLYm_MIRRORf_SET
#define L2_ENTRY_ONLYm_VALIDf_GET BCM56800_A0_L2_ENTRY_ONLYm_VALIDf_GET
#define L2_ENTRY_ONLYm_VALIDf_SET BCM56800_A0_L2_ENTRY_ONLYm_VALIDf_SET
#define L2_ENTRY_ONLYm_EVEN_PARITYf_GET BCM56800_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_GET
#define L2_ENTRY_ONLYm_EVEN_PARITYf_SET BCM56800_A0_L2_ENTRY_ONLYm_EVEN_PARITYf_SET
#define L2_ENTRY_ONLYm_L2MC_PTRf_GET BCM56800_A0_L2_ENTRY_ONLYm_L2MC_PTRf_GET
#define L2_ENTRY_ONLYm_L2MC_PTRf_SET BCM56800_A0_L2_ENTRY_ONLYm_L2MC_PTRf_SET
#define L2_ENTRY_ONLYm_TGID_LOf_GET BCM56800_A0_L2_ENTRY_ONLYm_TGID_LOf_GET
#define L2_ENTRY_ONLYm_TGID_LOf_SET BCM56800_A0_L2_ENTRY_ONLYm_TGID_LOf_SET
#define L2_ENTRY_ONLYm_Tf_GET BCM56800_A0_L2_ENTRY_ONLYm_Tf_GET
#define L2_ENTRY_ONLYm_Tf_SET BCM56800_A0_L2_ENTRY_ONLYm_Tf_SET
#define L2_ENTRY_ONLYm_TGID_HIf_GET BCM56800_A0_L2_ENTRY_ONLYm_TGID_HIf_GET
#define L2_ENTRY_ONLYm_TGID_HIf_SET BCM56800_A0_L2_ENTRY_ONLYm_TGID_HIf_SET
#define L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET BCM56800_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_GET
#define L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET BCM56800_A0_L2_ENTRY_ONLYm_REMOTE_TRUNKf_SET
#define READ_L2_ENTRY_ONLYm BCM56800_A0_READ_L2_ENTRY_ONLYm
#define WRITE_L2_ENTRY_ONLYm BCM56800_A0_WRITE_L2_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_ENTRY_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L2_ENTRY_PARITY_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the L2_ENTRY table.
 *
 ******************************************************************************/
#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr 0x0618020d

#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_PARITY_CONTROL.
 *
 */
typedef union BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l2_entry_parity_control[1];
	uint32_t _l2_entry_parity_control;
} BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_t;

#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_CLR(r) (r).l2_entry_parity_control[0] = 0
#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_SET(r,d) (r).l2_entry_parity_control[0] = d
#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_GET(r) (r).l2_entry_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).l2_entry_parity_control[0]) & 0x1)
#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).l2_entry_parity_control[0]=(((r).l2_entry_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).l2_entry_parity_control[0]) >> 1) & 0x1)
#define BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).l2_entry_parity_control[0]=(((r).l2_entry_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2_ENTRY_PARITY_CONTROL.
 *
 */
#define BCM56800_A0_READ_L2_ENTRY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_ENTRY_PARITY_CONTROLr,(r._l2_entry_parity_control))
#define BCM56800_A0_WRITE_L2_ENTRY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_ENTRY_PARITY_CONTROLr,&(r._l2_entry_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_PARITY_CONTROLr BCM56800_A0_L2_ENTRY_PARITY_CONTROLr
#define L2_ENTRY_PARITY_CONTROLr_SIZE BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_SIZE
typedef BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_t L2_ENTRY_PARITY_CONTROLr_t;
#define L2_ENTRY_PARITY_CONTROLr_CLR BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_CLR
#define L2_ENTRY_PARITY_CONTROLr_SET BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_SET
#define L2_ENTRY_PARITY_CONTROLr_GET BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET
#define L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET BCM56800_A0_L2_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_L2_ENTRY_PARITY_CONTROLr BCM56800_A0_READ_L2_ENTRY_PARITY_CONTROLr
#define WRITE_L2_ENTRY_PARITY_CONTROLr BCM56800_A0_WRITE_L2_ENTRY_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_ENTRY_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_ENTRY_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_ENTRY_PARITY_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ENTRY_BM         This bitmap indicates the entries that had parity errors.  Bits 7..0 correspond to entries 7..0.
 *     BUCKET_IDX       This field indicates the index to the bucket in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr 0x0618020e

#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_ENTRY_PARITY_STATUS.
 *
 */
typedef union BCM56800_A0_L2_ENTRY_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_entry_parity_status[1];
	uint32_t _l2_entry_parity_status;
} BCM56800_A0_L2_ENTRY_PARITY_STATUSr_t;

#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_CLR(r) (r).l2_entry_parity_status[0] = 0
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_SET(r,d) (r).l2_entry_parity_status[0] = d
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_GET(r) (r).l2_entry_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).l2_entry_parity_status[0]) & 0x1)
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET(r) ((((r).l2_entry_parity_status[0]) >> 1) & 0xff)
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET(r) ((((r).l2_entry_parity_status[0]) >> 9) & 0x7ff)
#define BCM56800_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET(r,f) (r).l2_entry_parity_status[0]=(((r).l2_entry_parity_status[0] & ~((uint32_t)0x7ff << 9)) | ((((uint32_t)f) & 0x7ff) << 9))

/*
 * These macros can be used to access L2_ENTRY_PARITY_STATUS.
 *
 */
#define BCM56800_A0_READ_L2_ENTRY_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_ENTRY_PARITY_STATUSr,(r._l2_entry_parity_status))
#define BCM56800_A0_WRITE_L2_ENTRY_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_ENTRY_PARITY_STATUSr,&(r._l2_entry_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ENTRY_PARITY_STATUSr BCM56800_A0_L2_ENTRY_PARITY_STATUSr
#define L2_ENTRY_PARITY_STATUSr_SIZE BCM56800_A0_L2_ENTRY_PARITY_STATUSr_SIZE
typedef BCM56800_A0_L2_ENTRY_PARITY_STATUSr_t L2_ENTRY_PARITY_STATUSr_t;
#define L2_ENTRY_PARITY_STATUSr_CLR BCM56800_A0_L2_ENTRY_PARITY_STATUSr_CLR
#define L2_ENTRY_PARITY_STATUSr_SET BCM56800_A0_L2_ENTRY_PARITY_STATUSr_SET
#define L2_ENTRY_PARITY_STATUSr_GET BCM56800_A0_L2_ENTRY_PARITY_STATUSr_GET
#define L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET BCM56800_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET
#define L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET BCM56800_A0_L2_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET
#define L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET BCM56800_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET
#define L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET BCM56800_A0_L2_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET
#define L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET BCM56800_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET
#define L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET BCM56800_A0_L2_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET
#define READ_L2_ENTRY_PARITY_STATUSr BCM56800_A0_READ_L2_ENTRY_PARITY_STATUSr
#define WRITE_L2_ENTRY_PARITY_STATUSr BCM56800_A0_WRITE_L2_ENTRY_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_ENTRY_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2_HITDA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_HITDA_ONLY table.  Just the DA hit bits. FeatureSpecific-Ethernet
 * SIZE:     8
 * FIELDS:
 *     HITDA_0          Hit bit set on Destination MAC addrs hits
 *     HITDA_1          Hit bit set on Destination MAC addrs hits
 *     HITDA_2          Hit bit set on Destination MAC addrs hits
 *     HITDA_3          Hit bit set on Destination MAC addrs hits
 *     HITDA_4          Hit bit set on Destination MAC addrs hits
 *     HITDA_5          Hit bit set on Destination MAC addrs hits
 *     HITDA_6          Hit bit set on Destination MAC addrs hits
 *     HITDA_7          Hit bit set on Destination MAC addrs hits
 *
 ******************************************************************************/
#define BCM56800_A0_L2_HITDA_ONLYm 0x06130000

#define BCM56800_A0_L2_HITDA_ONLYm_MIN 0
#define BCM56800_A0_L2_HITDA_ONLYm_MAX 2047
#define BCM56800_A0_L2_HITDA_ONLYm_CMAX(u) 2047
#define BCM56800_A0_L2_HITDA_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L2_HITDA_ONLY.
 *
 */
typedef union BCM56800_A0_L2_HITDA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_hitda_only[1];
	uint32_t _l2_hitda_only;
} BCM56800_A0_L2_HITDA_ONLYm_t;

#define BCM56800_A0_L2_HITDA_ONLYm_CLR(r) (r).l2_hitda_only[0] = 0
#define BCM56800_A0_L2_HITDA_ONLYm_SET(r,d) (r).l2_hitda_only[0] = d
#define BCM56800_A0_L2_HITDA_ONLYm_GET(r) (r).l2_hitda_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_0f_GET(r) (((r).l2_hitda_only[0]) & 0x1)
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_0f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_1f_GET(r) ((((r).l2_hitda_only[0]) >> 1) & 0x1)
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_1f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_2f_GET(r) ((((r).l2_hitda_only[0]) >> 2) & 0x1)
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_2f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_3f_GET(r) ((((r).l2_hitda_only[0]) >> 3) & 0x1)
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_3f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_4f_GET(r) ((((r).l2_hitda_only[0]) >> 4) & 0x1)
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_4f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_5f_GET(r) ((((r).l2_hitda_only[0]) >> 5) & 0x1)
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_5f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_6f_GET(r) ((((r).l2_hitda_only[0]) >> 6) & 0x1)
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_6f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_7f_GET(r) ((((r).l2_hitda_only[0]) >> 7) & 0x1)
#define BCM56800_A0_L2_HITDA_ONLYm_HITDA_7f_SET(r,f) (r).l2_hitda_only[0]=(((r).l2_hitda_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L2_HITDA_ONLY.
 *
 */
#define BCM56800_A0_READ_L2_HITDA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2_HITDA_ONLYm,i,(m._l2_hitda_only),1)
#define BCM56800_A0_WRITE_L2_HITDA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2_HITDA_ONLYm,i,&(m._l2_hitda_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HITDA_ONLYm BCM56800_A0_L2_HITDA_ONLYm
#define L2_HITDA_ONLYm_MIN BCM56800_A0_L2_HITDA_ONLYm_MIN
#define L2_HITDA_ONLYm_MAX BCM56800_A0_L2_HITDA_ONLYm_MAX
#define L2_HITDA_ONLYm_CMAX(u) BCM56800_A0_L2_HITDA_ONLYm_CMAX(u)
#define L2_HITDA_ONLYm_SIZE BCM56800_A0_L2_HITDA_ONLYm_SIZE
typedef BCM56800_A0_L2_HITDA_ONLYm_t L2_HITDA_ONLYm_t;
#define L2_HITDA_ONLYm_CLR BCM56800_A0_L2_HITDA_ONLYm_CLR
#define L2_HITDA_ONLYm_SET BCM56800_A0_L2_HITDA_ONLYm_SET
#define L2_HITDA_ONLYm_GET BCM56800_A0_L2_HITDA_ONLYm_GET
#define L2_HITDA_ONLYm_HITDA_0f_GET BCM56800_A0_L2_HITDA_ONLYm_HITDA_0f_GET
#define L2_HITDA_ONLYm_HITDA_0f_SET BCM56800_A0_L2_HITDA_ONLYm_HITDA_0f_SET
#define L2_HITDA_ONLYm_HITDA_1f_GET BCM56800_A0_L2_HITDA_ONLYm_HITDA_1f_GET
#define L2_HITDA_ONLYm_HITDA_1f_SET BCM56800_A0_L2_HITDA_ONLYm_HITDA_1f_SET
#define L2_HITDA_ONLYm_HITDA_2f_GET BCM56800_A0_L2_HITDA_ONLYm_HITDA_2f_GET
#define L2_HITDA_ONLYm_HITDA_2f_SET BCM56800_A0_L2_HITDA_ONLYm_HITDA_2f_SET
#define L2_HITDA_ONLYm_HITDA_3f_GET BCM56800_A0_L2_HITDA_ONLYm_HITDA_3f_GET
#define L2_HITDA_ONLYm_HITDA_3f_SET BCM56800_A0_L2_HITDA_ONLYm_HITDA_3f_SET
#define L2_HITDA_ONLYm_HITDA_4f_GET BCM56800_A0_L2_HITDA_ONLYm_HITDA_4f_GET
#define L2_HITDA_ONLYm_HITDA_4f_SET BCM56800_A0_L2_HITDA_ONLYm_HITDA_4f_SET
#define L2_HITDA_ONLYm_HITDA_5f_GET BCM56800_A0_L2_HITDA_ONLYm_HITDA_5f_GET
#define L2_HITDA_ONLYm_HITDA_5f_SET BCM56800_A0_L2_HITDA_ONLYm_HITDA_5f_SET
#define L2_HITDA_ONLYm_HITDA_6f_GET BCM56800_A0_L2_HITDA_ONLYm_HITDA_6f_GET
#define L2_HITDA_ONLYm_HITDA_6f_SET BCM56800_A0_L2_HITDA_ONLYm_HITDA_6f_SET
#define L2_HITDA_ONLYm_HITDA_7f_GET BCM56800_A0_L2_HITDA_ONLYm_HITDA_7f_GET
#define L2_HITDA_ONLYm_HITDA_7f_SET BCM56800_A0_L2_HITDA_ONLYm_HITDA_7f_SET
#define READ_L2_HITDA_ONLYm BCM56800_A0_READ_L2_HITDA_ONLYm
#define WRITE_L2_HITDA_ONLYm BCM56800_A0_WRITE_L2_HITDA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_HITDA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2_HITSA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     HW managed L2_HITSA_ONLY table.  Just the SA hit bits. FeatureSpecific-Ethernet
 * SIZE:     8
 * FIELDS:
 *     HITSA_0          Hit bit set on Source MAC addrs hits
 *     HITSA_1          Hit bit set on Source MAC addrs hits
 *     HITSA_2          Hit bit set on Source MAC addrs hits
 *     HITSA_3          Hit bit set on Source MAC addrs hits
 *     HITSA_4          Hit bit set on Source MAC addrs hits
 *     HITSA_5          Hit bit set on Source MAC addrs hits
 *     HITSA_6          Hit bit set on Source MAC addrs hits
 *     HITSA_7          Hit bit set on Source MAC addrs hits
 *
 ******************************************************************************/
#define BCM56800_A0_L2_HITSA_ONLYm 0x06131000

#define BCM56800_A0_L2_HITSA_ONLYm_MIN 0
#define BCM56800_A0_L2_HITSA_ONLYm_MAX 2047
#define BCM56800_A0_L2_HITSA_ONLYm_CMAX(u) 2047
#define BCM56800_A0_L2_HITSA_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L2_HITSA_ONLY.
 *
 */
typedef union BCM56800_A0_L2_HITSA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_hitsa_only[1];
	uint32_t _l2_hitsa_only;
} BCM56800_A0_L2_HITSA_ONLYm_t;

#define BCM56800_A0_L2_HITSA_ONLYm_CLR(r) (r).l2_hitsa_only[0] = 0
#define BCM56800_A0_L2_HITSA_ONLYm_SET(r,d) (r).l2_hitsa_only[0] = d
#define BCM56800_A0_L2_HITSA_ONLYm_GET(r) (r).l2_hitsa_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_0f_GET(r) (((r).l2_hitsa_only[0]) & 0x1)
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_0f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_1f_GET(r) ((((r).l2_hitsa_only[0]) >> 1) & 0x1)
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_1f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_2f_GET(r) ((((r).l2_hitsa_only[0]) >> 2) & 0x1)
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_2f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_3f_GET(r) ((((r).l2_hitsa_only[0]) >> 3) & 0x1)
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_3f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_4f_GET(r) ((((r).l2_hitsa_only[0]) >> 4) & 0x1)
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_4f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_5f_GET(r) ((((r).l2_hitsa_only[0]) >> 5) & 0x1)
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_5f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_6f_GET(r) ((((r).l2_hitsa_only[0]) >> 6) & 0x1)
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_6f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_7f_GET(r) ((((r).l2_hitsa_only[0]) >> 7) & 0x1)
#define BCM56800_A0_L2_HITSA_ONLYm_HITSA_7f_SET(r,f) (r).l2_hitsa_only[0]=(((r).l2_hitsa_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L2_HITSA_ONLY.
 *
 */
#define BCM56800_A0_READ_L2_HITSA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2_HITSA_ONLYm,i,(m._l2_hitsa_only),1)
#define BCM56800_A0_WRITE_L2_HITSA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2_HITSA_ONLYm,i,&(m._l2_hitsa_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HITSA_ONLYm BCM56800_A0_L2_HITSA_ONLYm
#define L2_HITSA_ONLYm_MIN BCM56800_A0_L2_HITSA_ONLYm_MIN
#define L2_HITSA_ONLYm_MAX BCM56800_A0_L2_HITSA_ONLYm_MAX
#define L2_HITSA_ONLYm_CMAX(u) BCM56800_A0_L2_HITSA_ONLYm_CMAX(u)
#define L2_HITSA_ONLYm_SIZE BCM56800_A0_L2_HITSA_ONLYm_SIZE
typedef BCM56800_A0_L2_HITSA_ONLYm_t L2_HITSA_ONLYm_t;
#define L2_HITSA_ONLYm_CLR BCM56800_A0_L2_HITSA_ONLYm_CLR
#define L2_HITSA_ONLYm_SET BCM56800_A0_L2_HITSA_ONLYm_SET
#define L2_HITSA_ONLYm_GET BCM56800_A0_L2_HITSA_ONLYm_GET
#define L2_HITSA_ONLYm_HITSA_0f_GET BCM56800_A0_L2_HITSA_ONLYm_HITSA_0f_GET
#define L2_HITSA_ONLYm_HITSA_0f_SET BCM56800_A0_L2_HITSA_ONLYm_HITSA_0f_SET
#define L2_HITSA_ONLYm_HITSA_1f_GET BCM56800_A0_L2_HITSA_ONLYm_HITSA_1f_GET
#define L2_HITSA_ONLYm_HITSA_1f_SET BCM56800_A0_L2_HITSA_ONLYm_HITSA_1f_SET
#define L2_HITSA_ONLYm_HITSA_2f_GET BCM56800_A0_L2_HITSA_ONLYm_HITSA_2f_GET
#define L2_HITSA_ONLYm_HITSA_2f_SET BCM56800_A0_L2_HITSA_ONLYm_HITSA_2f_SET
#define L2_HITSA_ONLYm_HITSA_3f_GET BCM56800_A0_L2_HITSA_ONLYm_HITSA_3f_GET
#define L2_HITSA_ONLYm_HITSA_3f_SET BCM56800_A0_L2_HITSA_ONLYm_HITSA_3f_SET
#define L2_HITSA_ONLYm_HITSA_4f_GET BCM56800_A0_L2_HITSA_ONLYm_HITSA_4f_GET
#define L2_HITSA_ONLYm_HITSA_4f_SET BCM56800_A0_L2_HITSA_ONLYm_HITSA_4f_SET
#define L2_HITSA_ONLYm_HITSA_5f_GET BCM56800_A0_L2_HITSA_ONLYm_HITSA_5f_GET
#define L2_HITSA_ONLYm_HITSA_5f_SET BCM56800_A0_L2_HITSA_ONLYm_HITSA_5f_SET
#define L2_HITSA_ONLYm_HITSA_6f_GET BCM56800_A0_L2_HITSA_ONLYm_HITSA_6f_GET
#define L2_HITSA_ONLYm_HITSA_6f_SET BCM56800_A0_L2_HITSA_ONLYm_HITSA_6f_SET
#define L2_HITSA_ONLYm_HITSA_7f_GET BCM56800_A0_L2_HITSA_ONLYm_HITSA_7f_GET
#define L2_HITSA_ONLYm_HITSA_7f_SET BCM56800_A0_L2_HITSA_ONLYm_HITSA_7f_SET
#define READ_L2_HITSA_ONLYm BCM56800_A0_READ_L2_HITSA_ONLYm
#define WRITE_L2_HITSA_ONLYm BCM56800_A0_WRITE_L2_HITSA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_HITSA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_HIT_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L2_HIT_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     HITDA_TM         TM debug bits for L2_HITDA RAM
 *     HITSA_TM         TM debug bits for L2_HITSA RAM
 *
 ******************************************************************************/
#define BCM56800_A0_L2_HIT_DBGCTRLr 0x0618020c

#define BCM56800_A0_L2_HIT_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L2_HIT_DBGCTRL.
 *
 */
typedef union BCM56800_A0_L2_HIT_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t l2_hit_dbgctrl[1];
	uint32_t _l2_hit_dbgctrl;
} BCM56800_A0_L2_HIT_DBGCTRLr_t;

#define BCM56800_A0_L2_HIT_DBGCTRLr_CLR(r) (r).l2_hit_dbgctrl[0] = 0
#define BCM56800_A0_L2_HIT_DBGCTRLr_SET(r,d) (r).l2_hit_dbgctrl[0] = d
#define BCM56800_A0_L2_HIT_DBGCTRLr_GET(r) (r).l2_hit_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_HIT_DBGCTRLr_HITDA_TMf_GET(r) (((r).l2_hit_dbgctrl[0]) & 0xff)
#define BCM56800_A0_L2_HIT_DBGCTRLr_HITDA_TMf_SET(r,f) (r).l2_hit_dbgctrl[0]=(((r).l2_hit_dbgctrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_L2_HIT_DBGCTRLr_HITSA_TMf_GET(r) ((((r).l2_hit_dbgctrl[0]) >> 8) & 0xff)
#define BCM56800_A0_L2_HIT_DBGCTRLr_HITSA_TMf_SET(r,f) (r).l2_hit_dbgctrl[0]=(((r).l2_hit_dbgctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access L2_HIT_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_L2_HIT_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_HIT_DBGCTRLr,(r._l2_hit_dbgctrl))
#define BCM56800_A0_WRITE_L2_HIT_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_HIT_DBGCTRLr,&(r._l2_hit_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_HIT_DBGCTRLr BCM56800_A0_L2_HIT_DBGCTRLr
#define L2_HIT_DBGCTRLr_SIZE BCM56800_A0_L2_HIT_DBGCTRLr_SIZE
typedef BCM56800_A0_L2_HIT_DBGCTRLr_t L2_HIT_DBGCTRLr_t;
#define L2_HIT_DBGCTRLr_CLR BCM56800_A0_L2_HIT_DBGCTRLr_CLR
#define L2_HIT_DBGCTRLr_SET BCM56800_A0_L2_HIT_DBGCTRLr_SET
#define L2_HIT_DBGCTRLr_GET BCM56800_A0_L2_HIT_DBGCTRLr_GET
#define L2_HIT_DBGCTRLr_HITDA_TMf_GET BCM56800_A0_L2_HIT_DBGCTRLr_HITDA_TMf_GET
#define L2_HIT_DBGCTRLr_HITDA_TMf_SET BCM56800_A0_L2_HIT_DBGCTRLr_HITDA_TMf_SET
#define L2_HIT_DBGCTRLr_HITSA_TMf_GET BCM56800_A0_L2_HIT_DBGCTRLr_HITSA_TMf_GET
#define L2_HIT_DBGCTRLr_HITSA_TMf_SET BCM56800_A0_L2_HIT_DBGCTRLr_HITSA_TMf_SET
#define READ_L2_HIT_DBGCTRLr BCM56800_A0_READ_L2_HIT_DBGCTRLr
#define WRITE_L2_HIT_DBGCTRLr BCM56800_A0_WRITE_L2_HIT_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_HIT_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2_MOD_FIFO
 * BLOCKS:   IPIPE
 * DESC:     FIFO for operations that MODify the L2_ENTRY table. FeatureSpecific-Ethernet
 * SIZE:     108
 * FIELDS:
 *     OPER             Operation type:  11->DELETE, 10->PPA_REPLACE, 00->WRITE, 01->reserved
 *     ENTRY_IDX        Index to the entry of the L2_ENTRY table modified.  Valid only for WRITE operations.
 *     BUCKET_IDX       Index to the bucket of the L2_ENTRY table affected.
 *     DELETE_OR_REPL_BM Overlay for DELETE or PPA REPLACE operations.  Bitmap for bucket entries affected.
 *     WR_DATA          Overlay for WRITE operations.  All the L2_ENTRY fields specified in the L2_ENTRY_ONLY view
 *     WR_DATA_OR_REPL_DEL_BM Overlay for WRITE operation:  All the L2_ENTRY fields specified in the L2_ENTRY_ONLY view; used for L2_INSERT, LEARN, and MEMWR.  ...or...  Bitmap or bucket entries affected for DELETE and PPA_REPLACE operations; only 8 bits are valid for this overlay.
 *
 ******************************************************************************/
#define BCM56800_A0_L2_MOD_FIFOm 0x06135000

#define BCM56800_A0_L2_MOD_FIFOm_MIN 0
#define BCM56800_A0_L2_MOD_FIFOm_MAX 15
#define BCM56800_A0_L2_MOD_FIFOm_CMAX(u) 15
#define BCM56800_A0_L2_MOD_FIFOm_SIZE 14

/*
 * This structure should be used to declare and program L2_MOD_FIFO.
 *
 */
typedef union BCM56800_A0_L2_MOD_FIFOm_s {
	uint32_t v[4];
	uint32_t l2_mod_fifo[4];
	uint32_t _l2_mod_fifo;
} BCM56800_A0_L2_MOD_FIFOm_t;

#define BCM56800_A0_L2_MOD_FIFOm_CLR(r) CDK_MEMSET(&((r)._l2_mod_fifo), 0, sizeof(BCM56800_A0_L2_MOD_FIFOm_t))
#define BCM56800_A0_L2_MOD_FIFOm_SET(r,i,d) (r).l2_mod_fifo[i] = d
#define BCM56800_A0_L2_MOD_FIFOm_GET(r,i) (r).l2_mod_fifo[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_MOD_FIFOm_OPERf_GET(r) (((r).l2_mod_fifo[0]) & 0x3)
#define BCM56800_A0_L2_MOD_FIFOm_OPERf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_L2_MOD_FIFOm_ENTRY_IDXf_GET(r) ((((r).l2_mod_fifo[0]) >> 2) & 0x7)
#define BCM56800_A0_L2_MOD_FIFOm_ENTRY_IDXf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM56800_A0_L2_MOD_FIFOm_BUCKET_IDXf_GET(r) ((((r).l2_mod_fifo[0]) >> 5) & 0x7ff)
#define BCM56800_A0_L2_MOD_FIFOm_BUCKET_IDXf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM56800_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET(r) ((((r).l2_mod_fifo[0]) >> 16) & 0xff)
#define BCM56800_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET(r,f) (r).l2_mod_fifo[0]=(((r).l2_mod_fifo[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_L2_MOD_FIFOm_WR_DATAf_GET(r,a) cdk_field_get((r).l2_mod_fifo,16,107,a)
#define BCM56800_A0_L2_MOD_FIFOm_WR_DATAf_SET(r,a) cdk_field_set((r).l2_mod_fifo,16,107,a)
#define BCM56800_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET(r,a) cdk_field_get((r).l2_mod_fifo,16,107,a)
#define BCM56800_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET(r,a) cdk_field_set((r).l2_mod_fifo,16,107,a)

/*
 * These macros can be used to access L2_MOD_FIFO.
 *
 */
#define BCM56800_A0_READ_L2_MOD_FIFOm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2_MOD_FIFOm,i,(m._l2_mod_fifo),4)
#define BCM56800_A0_WRITE_L2_MOD_FIFOm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2_MOD_FIFOm,i,&(m._l2_mod_fifo),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MOD_FIFOm BCM56800_A0_L2_MOD_FIFOm
#define L2_MOD_FIFOm_MIN BCM56800_A0_L2_MOD_FIFOm_MIN
#define L2_MOD_FIFOm_MAX BCM56800_A0_L2_MOD_FIFOm_MAX
#define L2_MOD_FIFOm_CMAX(u) BCM56800_A0_L2_MOD_FIFOm_CMAX(u)
#define L2_MOD_FIFOm_SIZE BCM56800_A0_L2_MOD_FIFOm_SIZE
typedef BCM56800_A0_L2_MOD_FIFOm_t L2_MOD_FIFOm_t;
#define L2_MOD_FIFOm_CLR BCM56800_A0_L2_MOD_FIFOm_CLR
#define L2_MOD_FIFOm_SET BCM56800_A0_L2_MOD_FIFOm_SET
#define L2_MOD_FIFOm_GET BCM56800_A0_L2_MOD_FIFOm_GET
#define L2_MOD_FIFOm_OPERf_GET BCM56800_A0_L2_MOD_FIFOm_OPERf_GET
#define L2_MOD_FIFOm_OPERf_SET BCM56800_A0_L2_MOD_FIFOm_OPERf_SET
#define L2_MOD_FIFOm_ENTRY_IDXf_GET BCM56800_A0_L2_MOD_FIFOm_ENTRY_IDXf_GET
#define L2_MOD_FIFOm_ENTRY_IDXf_SET BCM56800_A0_L2_MOD_FIFOm_ENTRY_IDXf_SET
#define L2_MOD_FIFOm_BUCKET_IDXf_GET BCM56800_A0_L2_MOD_FIFOm_BUCKET_IDXf_GET
#define L2_MOD_FIFOm_BUCKET_IDXf_SET BCM56800_A0_L2_MOD_FIFOm_BUCKET_IDXf_SET
#define L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET BCM56800_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_GET
#define L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET BCM56800_A0_L2_MOD_FIFOm_DELETE_OR_REPL_BMf_SET
#define L2_MOD_FIFOm_WR_DATAf_GET BCM56800_A0_L2_MOD_FIFOm_WR_DATAf_GET
#define L2_MOD_FIFOm_WR_DATAf_SET BCM56800_A0_L2_MOD_FIFOm_WR_DATAf_SET
#define L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET BCM56800_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_GET
#define L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET BCM56800_A0_L2_MOD_FIFOm_WR_DATA_OR_REPL_DEL_BMf_SET
#define READ_L2_MOD_FIFOm BCM56800_A0_READ_L2_MOD_FIFOm
#define WRITE_L2_MOD_FIFOm BCM56800_A0_WRITE_L2_MOD_FIFOm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_MOD_FIFOm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_MOD_FIFO_CNT
 * BLOCKS:   IPIPE
 * DESC:     L2_MOD_FIFO_CNT, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     NUM_OF_ENTRIES   A count of the number of entries in the L2_MOD_FIFO.  This is actually the hardware write pointer, so it points to the last entry in the buffer.
 *
 ******************************************************************************/
#define BCM56800_A0_L2_MOD_FIFO_CNTr 0x0618020b

#define BCM56800_A0_L2_MOD_FIFO_CNTr_SIZE 4

/*
 * This structure should be used to declare and program L2_MOD_FIFO_CNT.
 *
 */
typedef union BCM56800_A0_L2_MOD_FIFO_CNTr_s {
	uint32_t v[1];
	uint32_t l2_mod_fifo_cnt[1];
	uint32_t _l2_mod_fifo_cnt;
} BCM56800_A0_L2_MOD_FIFO_CNTr_t;

#define BCM56800_A0_L2_MOD_FIFO_CNTr_CLR(r) (r).l2_mod_fifo_cnt[0] = 0
#define BCM56800_A0_L2_MOD_FIFO_CNTr_SET(r,d) (r).l2_mod_fifo_cnt[0] = d
#define BCM56800_A0_L2_MOD_FIFO_CNTr_GET(r) (r).l2_mod_fifo_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET(r) (((r).l2_mod_fifo_cnt[0]) & 0x1f)
#define BCM56800_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET(r,f) (r).l2_mod_fifo_cnt[0]=(((r).l2_mod_fifo_cnt[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))

/*
 * These macros can be used to access L2_MOD_FIFO_CNT.
 *
 */
#define BCM56800_A0_READ_L2_MOD_FIFO_CNTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_MOD_FIFO_CNTr,(r._l2_mod_fifo_cnt))
#define BCM56800_A0_WRITE_L2_MOD_FIFO_CNTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_MOD_FIFO_CNTr,&(r._l2_mod_fifo_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_MOD_FIFO_CNTr BCM56800_A0_L2_MOD_FIFO_CNTr
#define L2_MOD_FIFO_CNTr_SIZE BCM56800_A0_L2_MOD_FIFO_CNTr_SIZE
typedef BCM56800_A0_L2_MOD_FIFO_CNTr_t L2_MOD_FIFO_CNTr_t;
#define L2_MOD_FIFO_CNTr_CLR BCM56800_A0_L2_MOD_FIFO_CNTr_CLR
#define L2_MOD_FIFO_CNTr_SET BCM56800_A0_L2_MOD_FIFO_CNTr_SET
#define L2_MOD_FIFO_CNTr_GET BCM56800_A0_L2_MOD_FIFO_CNTr_GET
#define L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET BCM56800_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_GET
#define L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET BCM56800_A0_L2_MOD_FIFO_CNTr_NUM_OF_ENTRIESf_SET
#define READ_L2_MOD_FIFO_CNTr BCM56800_A0_READ_L2_MOD_FIFO_CNTr
#define WRITE_L2_MOD_FIFO_CNTr BCM56800_A0_WRITE_L2_MOD_FIFO_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_MOD_FIFO_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2_USER_ENTRY
 * BLOCKS:   IPIPE
 * DESC:     Combined L2_ENTRY TCAM/Data RAM for guaranteed L2 entries and BPDUs. FeatureSpecific-Ethernet
 * SIZE:     143
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     MASK             Mask for the {VLAN_ID, MAC_ADDR}
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     BPDU             Indicates entry is a BPDU
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRYm 0x06172000

#define BCM56800_A0_L2_USER_ENTRYm_MIN 0
#define BCM56800_A0_L2_USER_ENTRYm_MAX 127
#define BCM56800_A0_L2_USER_ENTRYm_CMAX(u) 127
#define BCM56800_A0_L2_USER_ENTRYm_SIZE 18

/*
 * This structure should be used to declare and program L2_USER_ENTRY.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRYm_s {
	uint32_t v[5];
	uint32_t l2_user_entry[5];
	uint32_t _l2_user_entry;
} BCM56800_A0_L2_USER_ENTRYm_t;

#define BCM56800_A0_L2_USER_ENTRYm_CLR(r) CDK_MEMSET(&((r)._l2_user_entry), 0, sizeof(BCM56800_A0_L2_USER_ENTRYm_t))
#define BCM56800_A0_L2_USER_ENTRYm_SET(r,i,d) (r).l2_user_entry[i] = d
#define BCM56800_A0_L2_USER_ENTRYm_GET(r,i) (r).l2_user_entry[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRYm_VALIDf_GET(r) (((r).l2_user_entry[0]) & 0x1)
#define BCM56800_A0_L2_USER_ENTRYm_VALIDf_SET(r,f) (r).l2_user_entry[0]=(((r).l2_user_entry[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_USER_ENTRYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_user_entry,1,48,a)
#define BCM56800_A0_L2_USER_ENTRYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_user_entry,1,48,a)
#define BCM56800_A0_L2_USER_ENTRYm_VLAN_IDf_GET(r) ((((r).l2_user_entry[1]) >> 17) & 0xfff)
#define BCM56800_A0_L2_USER_ENTRYm_VLAN_IDf_SET(r,f) (r).l2_user_entry[1]=(((r).l2_user_entry[1] & ~((uint32_t)0xfff << 17)) | ((((uint32_t)f) & 0xfff) << 17))
#define BCM56800_A0_L2_USER_ENTRYm_MASKf_GET(r,a) cdk_field_get((r).l2_user_entry,61,120,a)
#define BCM56800_A0_L2_USER_ENTRYm_MASKf_SET(r,a) cdk_field_set((r).l2_user_entry,61,120,a)
#define BCM56800_A0_L2_USER_ENTRYm_PRIf_GET(r) ((((r).l2_user_entry[3]) >> 25) & 0x7)
#define BCM56800_A0_L2_USER_ENTRYm_PRIf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56800_A0_L2_USER_ENTRYm_CPUf_GET(r) ((((r).l2_user_entry[3]) >> 28) & 0x1)
#define BCM56800_A0_L2_USER_ENTRYm_CPUf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_L2_USER_ENTRYm_L3f_GET(r) ((((r).l2_user_entry[3]) >> 29) & 0x1)
#define BCM56800_A0_L2_USER_ENTRYm_L3f_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_L2_USER_ENTRYm_RPEf_GET(r) ((((r).l2_user_entry[3]) >> 30) & 0x1)
#define BCM56800_A0_L2_USER_ENTRYm_RPEf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_L2_USER_ENTRYm_MIRRORf_GET(r) ((((r).l2_user_entry[3]) >> 31) & 0x1)
#define BCM56800_A0_L2_USER_ENTRYm_MIRRORf_SET(r,f) (r).l2_user_entry[3]=(((r).l2_user_entry[3] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L2_USER_ENTRYm_DST_DISCARDf_GET(r) (((r).l2_user_entry[4]) & 0x1)
#define BCM56800_A0_L2_USER_ENTRYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_USER_ENTRYm_PORT_TGIDf_GET(r) ((((r).l2_user_entry[4]) >> 1) & 0x3f)
#define BCM56800_A0_L2_USER_ENTRYm_PORT_TGIDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM56800_A0_L2_USER_ENTRYm_MODULE_IDf_GET(r) ((((r).l2_user_entry[4]) >> 7) & 0x7f)
#define BCM56800_A0_L2_USER_ENTRYm_MODULE_IDf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCM56800_A0_L2_USER_ENTRYm_BPDUf_GET(r) ((((r).l2_user_entry[4]) >> 14) & 0x1)
#define BCM56800_A0_L2_USER_ENTRYm_BPDUf_SET(r,f) (r).l2_user_entry[4]=(((r).l2_user_entry[4] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access L2_USER_ENTRY.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2_USER_ENTRYm,i,(m._l2_user_entry),5)
#define BCM56800_A0_WRITE_L2_USER_ENTRYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2_USER_ENTRYm,i,&(m._l2_user_entry),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRYm BCM56800_A0_L2_USER_ENTRYm
#define L2_USER_ENTRYm_MIN BCM56800_A0_L2_USER_ENTRYm_MIN
#define L2_USER_ENTRYm_MAX BCM56800_A0_L2_USER_ENTRYm_MAX
#define L2_USER_ENTRYm_CMAX(u) BCM56800_A0_L2_USER_ENTRYm_CMAX(u)
#define L2_USER_ENTRYm_SIZE BCM56800_A0_L2_USER_ENTRYm_SIZE
typedef BCM56800_A0_L2_USER_ENTRYm_t L2_USER_ENTRYm_t;
#define L2_USER_ENTRYm_CLR BCM56800_A0_L2_USER_ENTRYm_CLR
#define L2_USER_ENTRYm_SET BCM56800_A0_L2_USER_ENTRYm_SET
#define L2_USER_ENTRYm_GET BCM56800_A0_L2_USER_ENTRYm_GET
#define L2_USER_ENTRYm_VALIDf_GET BCM56800_A0_L2_USER_ENTRYm_VALIDf_GET
#define L2_USER_ENTRYm_VALIDf_SET BCM56800_A0_L2_USER_ENTRYm_VALIDf_SET
#define L2_USER_ENTRYm_MAC_ADDRf_GET BCM56800_A0_L2_USER_ENTRYm_MAC_ADDRf_GET
#define L2_USER_ENTRYm_MAC_ADDRf_SET BCM56800_A0_L2_USER_ENTRYm_MAC_ADDRf_SET
#define L2_USER_ENTRYm_VLAN_IDf_GET BCM56800_A0_L2_USER_ENTRYm_VLAN_IDf_GET
#define L2_USER_ENTRYm_VLAN_IDf_SET BCM56800_A0_L2_USER_ENTRYm_VLAN_IDf_SET
#define L2_USER_ENTRYm_MASKf_GET BCM56800_A0_L2_USER_ENTRYm_MASKf_GET
#define L2_USER_ENTRYm_MASKf_SET BCM56800_A0_L2_USER_ENTRYm_MASKf_SET
#define L2_USER_ENTRYm_PRIf_GET BCM56800_A0_L2_USER_ENTRYm_PRIf_GET
#define L2_USER_ENTRYm_PRIf_SET BCM56800_A0_L2_USER_ENTRYm_PRIf_SET
#define L2_USER_ENTRYm_CPUf_GET BCM56800_A0_L2_USER_ENTRYm_CPUf_GET
#define L2_USER_ENTRYm_CPUf_SET BCM56800_A0_L2_USER_ENTRYm_CPUf_SET
#define L2_USER_ENTRYm_L3f_GET BCM56800_A0_L2_USER_ENTRYm_L3f_GET
#define L2_USER_ENTRYm_L3f_SET BCM56800_A0_L2_USER_ENTRYm_L3f_SET
#define L2_USER_ENTRYm_RPEf_GET BCM56800_A0_L2_USER_ENTRYm_RPEf_GET
#define L2_USER_ENTRYm_RPEf_SET BCM56800_A0_L2_USER_ENTRYm_RPEf_SET
#define L2_USER_ENTRYm_MIRRORf_GET BCM56800_A0_L2_USER_ENTRYm_MIRRORf_GET
#define L2_USER_ENTRYm_MIRRORf_SET BCM56800_A0_L2_USER_ENTRYm_MIRRORf_SET
#define L2_USER_ENTRYm_DST_DISCARDf_GET BCM56800_A0_L2_USER_ENTRYm_DST_DISCARDf_GET
#define L2_USER_ENTRYm_DST_DISCARDf_SET BCM56800_A0_L2_USER_ENTRYm_DST_DISCARDf_SET
#define L2_USER_ENTRYm_PORT_TGIDf_GET BCM56800_A0_L2_USER_ENTRYm_PORT_TGIDf_GET
#define L2_USER_ENTRYm_PORT_TGIDf_SET BCM56800_A0_L2_USER_ENTRYm_PORT_TGIDf_SET
#define L2_USER_ENTRYm_MODULE_IDf_GET BCM56800_A0_L2_USER_ENTRYm_MODULE_IDf_GET
#define L2_USER_ENTRYm_MODULE_IDf_SET BCM56800_A0_L2_USER_ENTRYm_MODULE_IDf_SET
#define L2_USER_ENTRYm_BPDUf_GET BCM56800_A0_L2_USER_ENTRYm_BPDUf_GET
#define L2_USER_ENTRYm_BPDUf_SET BCM56800_A0_L2_USER_ENTRYm_BPDUf_SET
#define READ_L2_USER_ENTRYm BCM56800_A0_READ_L2_USER_ENTRYm
#define WRITE_L2_USER_ENTRYm BCM56800_A0_WRITE_L2_USER_ENTRYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S10_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S10_STATUS       S10_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr 0x06180c08

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s10_status[1];
	uint32_t _l2_user_entry_cam_bist_s10_status;
} BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t;

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s10_status[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s10_status[0] = d
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s10_status[0]) & 0xff)
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s10_status[0]=(((r).l2_user_entry_cam_bist_s10_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr,(r._l2_user_entry_cam_bist_s10_status))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr,&(r._l2_user_entry_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t L2_USER_ENTRY_CAM_BIST_S10_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr_S10_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S10_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S2_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S2_STATUS        L2_USER_ENTRY_CAM_BIST_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr 0x06180c03

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s2_status[1];
	uint32_t _l2_user_entry_cam_bist_s2_status;
} BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t;

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s2_status[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s2_status[0] = d
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s2_status[0]) & 0x7fff)
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s2_status[0]=(((r).l2_user_entry_cam_bist_s2_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr,(r._l2_user_entry_cam_bist_s2_status))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr,&(r._l2_user_entry_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t L2_USER_ENTRY_CAM_BIST_S2_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr_S2_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S2_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S3_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S3_STATUS        S3_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr 0x06180c04

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s3_status[1];
	uint32_t _l2_user_entry_cam_bist_s3_status;
} BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t;

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s3_status[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s3_status[0] = d
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s3_status[0]) & 0xffff)
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s3_status[0]=(((r).l2_user_entry_cam_bist_s3_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr,(r._l2_user_entry_cam_bist_s3_status))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr,&(r._l2_user_entry_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t L2_USER_ENTRY_CAM_BIST_S3_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr_S3_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S3_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S5_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S5_STATUS        S5_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr 0x06180c05

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s5_status[1];
	uint32_t _l2_user_entry_cam_bist_s5_status;
} BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t;

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s5_status[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s5_status[0] = d
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s5_status[0]) & 0x7fff)
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s5_status[0]=(((r).l2_user_entry_cam_bist_s5_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr,(r._l2_user_entry_cam_bist_s5_status))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr,&(r._l2_user_entry_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t L2_USER_ENTRY_CAM_BIST_S5_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr_S5_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S5_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S6_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S6_STATUS        S6_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr 0x06180c06

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s6_status[1];
	uint32_t _l2_user_entry_cam_bist_s6_status;
} BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t;

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s6_status[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s6_status[0] = d
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s6_status[0]) & 0xffff)
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s6_status[0]=(((r).l2_user_entry_cam_bist_s6_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr,(r._l2_user_entry_cam_bist_s6_status))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr,&(r._l2_user_entry_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t L2_USER_ENTRY_CAM_BIST_S6_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr_S6_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S6_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_S8_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S8_STATUS        S8_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr 0x06180c07

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_s8_status[1];
	uint32_t _l2_user_entry_cam_bist_s8_status;
} BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t;

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_s8_status[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_s8_status[0] = d
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET(r) (r).l2_user_entry_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_GET(r) (((r).l2_user_entry_cam_bist_s8_status[0]) & 0xffff)
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_SET(r,f) (r).l2_user_entry_cam_bist_s8_status[0]=(((r).l2_user_entry_cam_bist_s8_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr,(r._l2_user_entry_cam_bist_s8_status))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr,&(r._l2_user_entry_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t L2_USER_ENTRY_CAM_BIST_S8_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_GET
#define L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr_S8_STATUSf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_S8_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_BIST_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr 0x06180c02

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_BIST_STATUS.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_bist_status[1];
	uint32_t _l2_user_entry_cam_bist_status;
} BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_t;

#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_CLR(r) (r).l2_user_entry_cam_bist_status[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SET(r,d) (r).l2_user_entry_cam_bist_status[0] = d
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_GET(r) (r).l2_user_entry_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).l2_user_entry_cam_bist_status[0]) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).l2_user_entry_cam_bist_status[0]=(((r).l2_user_entry_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).l2_user_entry_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).l2_user_entry_cam_bist_status[0]=(((r).l2_user_entry_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_BIST_STATUS.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr,(r._l2_user_entry_cam_bist_status))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr,&(r._l2_user_entry_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_BIST_STATUSr BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr
#define L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_t L2_USER_ENTRY_CAM_BIST_STATUSr_t;
#define L2_USER_ENTRY_CAM_BIST_STATUSr_CLR BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_CLR
#define L2_USER_ENTRY_CAM_BIST_STATUSr_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_SET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_GOf_SET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_GET
#define L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_L2_USER_ENTRY_CAM_BIST_STATUSr BCM56800_A0_READ_L2_USER_ENTRY_CAM_BIST_STATUSr
#define WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_CAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_CAM_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST enable for the CAM
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr 0x06180c01

#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_CAM_DBGCTRL.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_cam_dbgctrl[1];
	uint32_t _l2_user_entry_cam_dbgctrl;
} BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_t;

#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_CLR(r) (r).l2_user_entry_cam_dbgctrl[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_SET(r,d) (r).l2_user_entry_cam_dbgctrl[0] = d
#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_GET(r) (r).l2_user_entry_cam_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_BIST_ENf_GET(r) (((r).l2_user_entry_cam_dbgctrl[0]) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_BIST_ENf_SET(r,f) (r).l2_user_entry_cam_dbgctrl[0]=(((r).l2_user_entry_cam_dbgctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_TMf_GET(r) ((((r).l2_user_entry_cam_dbgctrl[0]) >> 1) & 0x7ff)
#define BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_TMf_SET(r,f) (r).l2_user_entry_cam_dbgctrl[0]=(((r).l2_user_entry_cam_dbgctrl[0] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))

/*
 * These macros can be used to access L2_USER_ENTRY_CAM_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_CAM_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr,(r._l2_user_entry_cam_dbgctrl))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr,&(r._l2_user_entry_cam_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_CAM_DBGCTRLr BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr
#define L2_USER_ENTRY_CAM_DBGCTRLr_SIZE BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_t L2_USER_ENTRY_CAM_DBGCTRLr_t;
#define L2_USER_ENTRY_CAM_DBGCTRLr_CLR BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_CLR
#define L2_USER_ENTRY_CAM_DBGCTRLr_SET BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_SET
#define L2_USER_ENTRY_CAM_DBGCTRLr_GET BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_GET
#define L2_USER_ENTRY_CAM_DBGCTRLr_BIST_ENf_GET BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_BIST_ENf_GET
#define L2_USER_ENTRY_CAM_DBGCTRLr_BIST_ENf_SET BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_BIST_ENf_SET
#define L2_USER_ENTRY_CAM_DBGCTRLr_TMf_GET BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_TMf_GET
#define L2_USER_ENTRY_CAM_DBGCTRLr_TMf_SET BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr_TMf_SET
#define READ_L2_USER_ENTRY_CAM_DBGCTRLr BCM56800_A0_READ_L2_USER_ENTRY_CAM_DBGCTRLr
#define WRITE_L2_USER_ENTRY_CAM_DBGCTRLr BCM56800_A0_WRITE_L2_USER_ENTRY_CAM_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_CAM_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L2_USER_ENTRY_DATA_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L2_USER_ENTRY_DATA_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr 0x06180c10

#define BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L2_USER_ENTRY_DATA_DBGCTRL.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t l2_user_entry_data_dbgctrl[1];
	uint32_t _l2_user_entry_data_dbgctrl;
} BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_t;

#define BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_CLR(r) (r).l2_user_entry_data_dbgctrl[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_SET(r,d) (r).l2_user_entry_data_dbgctrl[0] = d
#define BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_GET(r) (r).l2_user_entry_data_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_TMf_GET(r) (((r).l2_user_entry_data_dbgctrl[0]) & 0xf)
#define BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_TMf_SET(r,f) (r).l2_user_entry_data_dbgctrl[0]=(((r).l2_user_entry_data_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access L2_USER_ENTRY_DATA_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr,(r._l2_user_entry_data_dbgctrl))
#define BCM56800_A0_WRITE_L2_USER_ENTRY_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr,&(r._l2_user_entry_data_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_DATA_DBGCTRLr BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr
#define L2_USER_ENTRY_DATA_DBGCTRLr_SIZE BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_t L2_USER_ENTRY_DATA_DBGCTRLr_t;
#define L2_USER_ENTRY_DATA_DBGCTRLr_CLR BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_CLR
#define L2_USER_ENTRY_DATA_DBGCTRLr_SET BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_SET
#define L2_USER_ENTRY_DATA_DBGCTRLr_GET BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_GET
#define L2_USER_ENTRY_DATA_DBGCTRLr_TMf_GET BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_TMf_GET
#define L2_USER_ENTRY_DATA_DBGCTRLr_TMf_SET BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr_TMf_SET
#define READ_L2_USER_ENTRY_DATA_DBGCTRLr BCM56800_A0_READ_L2_USER_ENTRY_DATA_DBGCTRLr
#define WRITE_L2_USER_ENTRY_DATA_DBGCTRLr BCM56800_A0_WRITE_L2_USER_ENTRY_DATA_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_DATA_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2_USER_ENTRY_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Data SRAM for L2_USER_ENTRY TCAM. FeatureSpecific-Ethernet
 * SIZE:     22
 * FIELDS:
 *     PRI              Priority
 *     CPU              CPU bit
 *     L3               Indicates an L3 entry
 *     RPE              RPE bit
 *     MIRROR           Mirror bit
 *     DST_DISCARD      Dst Discard
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     BPDU             Indicates entry is a BPDU
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm 0x06174000

#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MIN 0
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MAX 127
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_CMAX(u) 127
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program L2_USER_ENTRY_DATA_ONLY.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t l2_user_entry_data_only[1];
	uint32_t _l2_user_entry_data_only;
} BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_t;

#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_CLR(r) (r).l2_user_entry_data_only[0] = 0
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_SET(r,d) (r).l2_user_entry_data_only[0] = d
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_GET(r) (r).l2_user_entry_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_GET(r) (((r).l2_user_entry_data_only[0]) & 0x7)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 3) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_GET(r) ((((r).l2_user_entry_data_only[0]) >> 4) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 5) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 6) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 7) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 8) & 0x3f)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 14) & 0x7f)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x7f << 14)) | ((((uint32_t)f) & 0x7f) << 14))
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET(r) ((((r).l2_user_entry_data_only[0]) >> 21) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET(r,f) (r).l2_user_entry_data_only[0]=(((r).l2_user_entry_data_only[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))

/*
 * These macros can be used to access L2_USER_ENTRY_DATA_ONLY.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm,i,(m._l2_user_entry_data_only),1)
#define BCM56800_A0_WRITE_L2_USER_ENTRY_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm,i,&(m._l2_user_entry_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_DATA_ONLYm BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm
#define L2_USER_ENTRY_DATA_ONLYm_MIN BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MIN
#define L2_USER_ENTRY_DATA_ONLYm_MAX BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MAX
#define L2_USER_ENTRY_DATA_ONLYm_CMAX(u) BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_CMAX(u)
#define L2_USER_ENTRY_DATA_ONLYm_SIZE BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_t L2_USER_ENTRY_DATA_ONLYm_t;
#define L2_USER_ENTRY_DATA_ONLYm_CLR BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_CLR
#define L2_USER_ENTRY_DATA_ONLYm_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_SET
#define L2_USER_ENTRY_DATA_ONLYm_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_GET
#define L2_USER_ENTRY_DATA_ONLYm_PRIf_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_GET
#define L2_USER_ENTRY_DATA_ONLYm_PRIf_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_PRIf_SET
#define L2_USER_ENTRY_DATA_ONLYm_CPUf_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_GET
#define L2_USER_ENTRY_DATA_ONLYm_CPUf_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_CPUf_SET
#define L2_USER_ENTRY_DATA_ONLYm_L3f_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_GET
#define L2_USER_ENTRY_DATA_ONLYm_L3f_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_L3f_SET
#define L2_USER_ENTRY_DATA_ONLYm_RPEf_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_GET
#define L2_USER_ENTRY_DATA_ONLYm_RPEf_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_RPEf_SET
#define L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_GET
#define L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MIRRORf_SET
#define L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_DST_DISCARDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_PORT_TGIDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_GET
#define L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_MODULE_IDf_SET
#define L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_GET
#define L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm_BPDUf_SET
#define READ_L2_USER_ENTRY_DATA_ONLYm BCM56800_A0_READ_L2_USER_ENTRY_DATA_ONLYm
#define WRITE_L2_USER_ENTRY_DATA_ONLYm BCM56800_A0_WRITE_L2_USER_ENTRY_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L2_USER_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     TCAM for guaranteed L2 entries and BPDUs. FeatureSpecific-Ethernet
 * SIZE:     121
 * FIELDS:
 *     VALID            Indicates that the entry is valid
 *     MAC_ADDR         MAC address
 *     VLAN_ID          VLAN ID
 *     MASK             Mask for the {VLAN_ID, MAC_ADDR}
 *
 ******************************************************************************/
#define BCM56800_A0_L2_USER_ENTRY_ONLYm 0x06173000

#define BCM56800_A0_L2_USER_ENTRY_ONLYm_MIN 0
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_MAX 127
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_CMAX(u) 127
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_SIZE 16

/*
 * This structure should be used to declare and program L2_USER_ENTRY_ONLY.
 *
 */
typedef union BCM56800_A0_L2_USER_ENTRY_ONLYm_s {
	uint32_t v[4];
	uint32_t l2_user_entry_only[4];
	uint32_t _l2_user_entry_only;
} BCM56800_A0_L2_USER_ENTRY_ONLYm_t;

#define BCM56800_A0_L2_USER_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l2_user_entry_only), 0, sizeof(BCM56800_A0_L2_USER_ENTRY_ONLYm_t))
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_SET(r,i,d) (r).l2_user_entry_only[i] = d
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_GET(r,i) (r).l2_user_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_VALIDf_GET(r) (((r).l2_user_entry_only[0]) & 0x1)
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l2_user_entry_only[0]=(((r).l2_user_entry_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET(r,a) cdk_field_get((r).l2_user_entry_only,1,48,a)
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET(r,a) cdk_field_set((r).l2_user_entry_only,1,48,a)
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l2_user_entry_only[1]) >> 17) & 0xfff)
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l2_user_entry_only[1]=(((r).l2_user_entry_only[1] & ~((uint32_t)0xfff << 17)) | ((((uint32_t)f) & 0xfff) << 17))
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_MASKf_GET(r,a) cdk_field_get((r).l2_user_entry_only,61,120,a)
#define BCM56800_A0_L2_USER_ENTRY_ONLYm_MASKf_SET(r,a) cdk_field_set((r).l2_user_entry_only,61,120,a)

/*
 * These macros can be used to access L2_USER_ENTRY_ONLY.
 *
 */
#define BCM56800_A0_READ_L2_USER_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L2_USER_ENTRY_ONLYm,i,(m._l2_user_entry_only),4)
#define BCM56800_A0_WRITE_L2_USER_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L2_USER_ENTRY_ONLYm,i,&(m._l2_user_entry_only),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_USER_ENTRY_ONLYm BCM56800_A0_L2_USER_ENTRY_ONLYm
#define L2_USER_ENTRY_ONLYm_MIN BCM56800_A0_L2_USER_ENTRY_ONLYm_MIN
#define L2_USER_ENTRY_ONLYm_MAX BCM56800_A0_L2_USER_ENTRY_ONLYm_MAX
#define L2_USER_ENTRY_ONLYm_CMAX(u) BCM56800_A0_L2_USER_ENTRY_ONLYm_CMAX(u)
#define L2_USER_ENTRY_ONLYm_SIZE BCM56800_A0_L2_USER_ENTRY_ONLYm_SIZE
typedef BCM56800_A0_L2_USER_ENTRY_ONLYm_t L2_USER_ENTRY_ONLYm_t;
#define L2_USER_ENTRY_ONLYm_CLR BCM56800_A0_L2_USER_ENTRY_ONLYm_CLR
#define L2_USER_ENTRY_ONLYm_SET BCM56800_A0_L2_USER_ENTRY_ONLYm_SET
#define L2_USER_ENTRY_ONLYm_GET BCM56800_A0_L2_USER_ENTRY_ONLYm_GET
#define L2_USER_ENTRY_ONLYm_VALIDf_GET BCM56800_A0_L2_USER_ENTRY_ONLYm_VALIDf_GET
#define L2_USER_ENTRY_ONLYm_VALIDf_SET BCM56800_A0_L2_USER_ENTRY_ONLYm_VALIDf_SET
#define L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET BCM56800_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_GET
#define L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET BCM56800_A0_L2_USER_ENTRY_ONLYm_MAC_ADDRf_SET
#define L2_USER_ENTRY_ONLYm_VLAN_IDf_GET BCM56800_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_GET
#define L2_USER_ENTRY_ONLYm_VLAN_IDf_SET BCM56800_A0_L2_USER_ENTRY_ONLYm_VLAN_IDf_SET
#define L2_USER_ENTRY_ONLYm_MASKf_GET BCM56800_A0_L2_USER_ENTRY_ONLYm_MASKf_GET
#define L2_USER_ENTRY_ONLYm_MASKf_SET BCM56800_A0_L2_USER_ENTRY_ONLYm_MASKf_SET
#define READ_L2_USER_ENTRY_ONLYm BCM56800_A0_READ_L2_USER_ENTRY_ONLYm
#define WRITE_L2_USER_ENTRY_ONLYm BCM56800_A0_WRITE_L2_USER_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L2_USER_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3MC_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L3MC_CONTROL
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_L3MC_DBGCTRLr 0x09180c00

#define BCM56800_A0_L3MC_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L3MC_DBGCTRL.
 *
 */
typedef union BCM56800_A0_L3MC_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t l3mc_dbgctrl[1];
	uint32_t _l3mc_dbgctrl;
} BCM56800_A0_L3MC_DBGCTRLr_t;

#define BCM56800_A0_L3MC_DBGCTRLr_CLR(r) (r).l3mc_dbgctrl[0] = 0
#define BCM56800_A0_L3MC_DBGCTRLr_SET(r,d) (r).l3mc_dbgctrl[0] = d
#define BCM56800_A0_L3MC_DBGCTRLr_GET(r) (r).l3mc_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3MC_DBGCTRLr_TMf_GET(r) (((r).l3mc_dbgctrl[0]) & 0xf)
#define BCM56800_A0_L3MC_DBGCTRLr_TMf_SET(r,f) (r).l3mc_dbgctrl[0]=(((r).l3mc_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access L3MC_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_L3MC_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3MC_DBGCTRLr,(r._l3mc_dbgctrl))
#define BCM56800_A0_WRITE_L3MC_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3MC_DBGCTRLr,&(r._l3mc_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3MC_DBGCTRLr BCM56800_A0_L3MC_DBGCTRLr
#define L3MC_DBGCTRLr_SIZE BCM56800_A0_L3MC_DBGCTRLr_SIZE
typedef BCM56800_A0_L3MC_DBGCTRLr_t L3MC_DBGCTRLr_t;
#define L3MC_DBGCTRLr_CLR BCM56800_A0_L3MC_DBGCTRLr_CLR
#define L3MC_DBGCTRLr_SET BCM56800_A0_L3MC_DBGCTRLr_SET
#define L3MC_DBGCTRLr_GET BCM56800_A0_L3MC_DBGCTRLr_GET
#define L3MC_DBGCTRLr_TMf_GET BCM56800_A0_L3MC_DBGCTRLr_TMf_GET
#define L3MC_DBGCTRLr_TMf_SET BCM56800_A0_L3MC_DBGCTRLr_TMf_SET
#define READ_L3MC_DBGCTRLr BCM56800_A0_READ_L3MC_DBGCTRLr
#define WRITE_L3MC_DBGCTRLr BCM56800_A0_WRITE_L3MC_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3MC_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_DEFIP
 * BLOCKS:   IPIPE
 * DESC:     L3 Default IP Route (LPM) TCAM view with data and hit bits. FeatureSpecific-Ethernet
 * SIZE:     178
 * FIELDS:
 *     VALID0           Indicates half-entry 0 is valid
 *     VALID1           Indicates half-entry 1 is valid
 *     MODE0            Indicates contents of half-entry 0; 0=IPv4, 1=IPv6
 *     MODE1            Indicates contents of half-entry 1; 0=IPv4, 1=IPv6
 *     IP_ADDR0         IP address bits for half-entry 0
 *     IP_ADDR1         IP address bits for half-entry 1
 *     MASK0            Subnet mask for half-entry 0
 *     MASK1            Subnet mask for half-entry 1
 *     ECMP1            Indicates if route for half-entry 1 uses ECMP
 *     ECMP_PTR1        Ptr to ECMP group within ECMP table for half-entry 1
 *     ECMP_COUNT1      No. of ECMP routes in group for half-entry 1
 *     PRI1             Priority for half-entry 1
 *     RPE1             RPE bit for half-entry 1
 *     DST_DISCARD1     Discard pkt on L3 DEFIP hit
 *     ECMP0            Indicates if route for half-entry 0 uses ECMP
 *     ECMP_PTR0        Ptr to ECMP group within ECMP table for half-entry 0
 *     ECMP_COUNT0      No. of ECMP routes in group for half-entry 0
 *     PRI0             Priority for half-entry 0
 *     RPE0             RPE bit for half-entry 0
 *     DST_DISCARD0     Discard pkt on L3 DEFIP hit
 *     HIT0             Hit bit for half-entry 0
 *     HIT1             Hit bit for half-entry 1
 *     NEXT_HOP_INDEX1  Next Hop Ptr, only valid for non ECMP routes
 *     NEXT_HOP_INDEX0  Next Hop Ptr, only valid for non ECMP routes
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIPm 0x0a160000

#define BCM56800_A0_L3_DEFIPm_MIN 0
#define BCM56800_A0_L3_DEFIPm_MAX 511
#define BCM56800_A0_L3_DEFIPm_CMAX(u) 511
#define BCM56800_A0_L3_DEFIPm_SIZE 23

/*
 * This structure should be used to declare and program L3_DEFIP.
 *
 */
typedef union BCM56800_A0_L3_DEFIPm_s {
	uint32_t v[6];
	uint32_t l3_defip[6];
	uint32_t _l3_defip;
} BCM56800_A0_L3_DEFIPm_t;

#define BCM56800_A0_L3_DEFIPm_CLR(r) CDK_MEMSET(&((r)._l3_defip), 0, sizeof(BCM56800_A0_L3_DEFIPm_t))
#define BCM56800_A0_L3_DEFIPm_SET(r,i,d) (r).l3_defip[i] = d
#define BCM56800_A0_L3_DEFIPm_GET(r,i) (r).l3_defip[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIPm_VALID0f_GET(r) (((r).l3_defip[0]) & 0x1)
#define BCM56800_A0_L3_DEFIPm_VALID0f_SET(r,f) (r).l3_defip[0]=(((r).l3_defip[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_DEFIPm_VALID1f_GET(r) ((((r).l3_defip[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_DEFIPm_VALID1f_SET(r,f) (r).l3_defip[0]=(((r).l3_defip[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_DEFIPm_MODE0f_GET(r) ((((r).l3_defip[0]) >> 2) & 0x1)
#define BCM56800_A0_L3_DEFIPm_MODE0f_SET(r,f) (r).l3_defip[0]=(((r).l3_defip[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L3_DEFIPm_MODE1f_GET(r) ((((r).l3_defip[0]) >> 3) & 0x1)
#define BCM56800_A0_L3_DEFIPm_MODE1f_SET(r,f) (r).l3_defip[0]=(((r).l3_defip[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_DEFIPm_IP_ADDR0f_GET(r) cdk_field32_get((r).l3_defip,4,35)
#define BCM56800_A0_L3_DEFIPm_IP_ADDR0f_SET(r,f) cdk_field32_set((r).l3_defip,4,35,f)
#define BCM56800_A0_L3_DEFIPm_IP_ADDR1f_GET(r) cdk_field32_get((r).l3_defip,36,67)
#define BCM56800_A0_L3_DEFIPm_IP_ADDR1f_SET(r,f) cdk_field32_set((r).l3_defip,36,67,f)
#define BCM56800_A0_L3_DEFIPm_MASK0f_GET(r) cdk_field32_get((r).l3_defip,68,99)
#define BCM56800_A0_L3_DEFIPm_MASK0f_SET(r,f) cdk_field32_set((r).l3_defip,68,99,f)
#define BCM56800_A0_L3_DEFIPm_MASK1f_GET(r) cdk_field32_get((r).l3_defip,100,131)
#define BCM56800_A0_L3_DEFIPm_MASK1f_SET(r,f) cdk_field32_set((r).l3_defip,100,131,f)
#define BCM56800_A0_L3_DEFIPm_ECMP1f_GET(r) ((((r).l3_defip[4]) >> 4) & 0x1)
#define BCM56800_A0_L3_DEFIPm_ECMP1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L3_DEFIPm_ECMP_PTR1f_GET(r) ((((r).l3_defip[4]) >> 5) & 0x7ff)
#define BCM56800_A0_L3_DEFIPm_ECMP_PTR1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM56800_A0_L3_DEFIPm_ECMP_COUNT1f_GET(r) ((((r).l3_defip[4]) >> 16) & 0x1f)
#define BCM56800_A0_L3_DEFIPm_ECMP_COUNT1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_L3_DEFIPm_PRI1f_GET(r) ((((r).l3_defip[4]) >> 21) & 0x7)
#define BCM56800_A0_L3_DEFIPm_PRI1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM56800_A0_L3_DEFIPm_RPE1f_GET(r) ((((r).l3_defip[4]) >> 24) & 0x1)
#define BCM56800_A0_L3_DEFIPm_RPE1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_L3_DEFIPm_DST_DISCARD1f_GET(r) ((((r).l3_defip[4]) >> 25) & 0x1)
#define BCM56800_A0_L3_DEFIPm_DST_DISCARD1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_L3_DEFIPm_ECMP0f_GET(r) ((((r).l3_defip[4]) >> 26) & 0x1)
#define BCM56800_A0_L3_DEFIPm_ECMP0f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_L3_DEFIPm_ECMP_PTR0f_GET(r) cdk_field32_get((r).l3_defip,155,165)
#define BCM56800_A0_L3_DEFIPm_ECMP_PTR0f_SET(r,f) cdk_field32_set((r).l3_defip,155,165,f)
#define BCM56800_A0_L3_DEFIPm_ECMP_COUNT0f_GET(r) ((((r).l3_defip[5]) >> 6) & 0x1f)
#define BCM56800_A0_L3_DEFIPm_ECMP_COUNT0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6))
#define BCM56800_A0_L3_DEFIPm_PRI0f_GET(r) ((((r).l3_defip[5]) >> 11) & 0x7)
#define BCM56800_A0_L3_DEFIPm_PRI0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM56800_A0_L3_DEFIPm_RPE0f_GET(r) ((((r).l3_defip[5]) >> 14) & 0x1)
#define BCM56800_A0_L3_DEFIPm_RPE0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_L3_DEFIPm_DST_DISCARD0f_GET(r) ((((r).l3_defip[5]) >> 15) & 0x1)
#define BCM56800_A0_L3_DEFIPm_DST_DISCARD0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_L3_DEFIPm_HIT0f_GET(r) ((((r).l3_defip[5]) >> 16) & 0x1)
#define BCM56800_A0_L3_DEFIPm_HIT0f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_L3_DEFIPm_HIT1f_GET(r) ((((r).l3_defip[5]) >> 17) & 0x1)
#define BCM56800_A0_L3_DEFIPm_HIT1f_SET(r,f) (r).l3_defip[5]=(((r).l3_defip[5] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_L3_DEFIPm_NEXT_HOP_INDEX1f_GET(r) ((((r).l3_defip[4]) >> 5) & 0x1fff)
#define BCM56800_A0_L3_DEFIPm_NEXT_HOP_INDEX1f_SET(r,f) (r).l3_defip[4]=(((r).l3_defip[4] & ~((uint32_t)0x1fff << 5)) | ((((uint32_t)f) & 0x1fff) << 5))
#define BCM56800_A0_L3_DEFIPm_NEXT_HOP_INDEX0f_GET(r) cdk_field32_get((r).l3_defip,155,167)
#define BCM56800_A0_L3_DEFIPm_NEXT_HOP_INDEX0f_SET(r,f) cdk_field32_set((r).l3_defip,155,167,f)

/*
 * These macros can be used to access L3_DEFIP.
 *
 */
#define BCM56800_A0_READ_L3_DEFIPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_DEFIPm,i,(m._l3_defip),6)
#define BCM56800_A0_WRITE_L3_DEFIPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_DEFIPm,i,&(m._l3_defip),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIPm BCM56800_A0_L3_DEFIPm
#define L3_DEFIPm_MIN BCM56800_A0_L3_DEFIPm_MIN
#define L3_DEFIPm_MAX BCM56800_A0_L3_DEFIPm_MAX
#define L3_DEFIPm_CMAX(u) BCM56800_A0_L3_DEFIPm_CMAX(u)
#define L3_DEFIPm_SIZE BCM56800_A0_L3_DEFIPm_SIZE
typedef BCM56800_A0_L3_DEFIPm_t L3_DEFIPm_t;
#define L3_DEFIPm_CLR BCM56800_A0_L3_DEFIPm_CLR
#define L3_DEFIPm_SET BCM56800_A0_L3_DEFIPm_SET
#define L3_DEFIPm_GET BCM56800_A0_L3_DEFIPm_GET
#define L3_DEFIPm_VALID0f_GET BCM56800_A0_L3_DEFIPm_VALID0f_GET
#define L3_DEFIPm_VALID0f_SET BCM56800_A0_L3_DEFIPm_VALID0f_SET
#define L3_DEFIPm_VALID1f_GET BCM56800_A0_L3_DEFIPm_VALID1f_GET
#define L3_DEFIPm_VALID1f_SET BCM56800_A0_L3_DEFIPm_VALID1f_SET
#define L3_DEFIPm_MODE0f_GET BCM56800_A0_L3_DEFIPm_MODE0f_GET
#define L3_DEFIPm_MODE0f_SET BCM56800_A0_L3_DEFIPm_MODE0f_SET
#define L3_DEFIPm_MODE1f_GET BCM56800_A0_L3_DEFIPm_MODE1f_GET
#define L3_DEFIPm_MODE1f_SET BCM56800_A0_L3_DEFIPm_MODE1f_SET
#define L3_DEFIPm_IP_ADDR0f_GET BCM56800_A0_L3_DEFIPm_IP_ADDR0f_GET
#define L3_DEFIPm_IP_ADDR0f_SET BCM56800_A0_L3_DEFIPm_IP_ADDR0f_SET
#define L3_DEFIPm_IP_ADDR1f_GET BCM56800_A0_L3_DEFIPm_IP_ADDR1f_GET
#define L3_DEFIPm_IP_ADDR1f_SET BCM56800_A0_L3_DEFIPm_IP_ADDR1f_SET
#define L3_DEFIPm_MASK0f_GET BCM56800_A0_L3_DEFIPm_MASK0f_GET
#define L3_DEFIPm_MASK0f_SET BCM56800_A0_L3_DEFIPm_MASK0f_SET
#define L3_DEFIPm_MASK1f_GET BCM56800_A0_L3_DEFIPm_MASK1f_GET
#define L3_DEFIPm_MASK1f_SET BCM56800_A0_L3_DEFIPm_MASK1f_SET
#define L3_DEFIPm_ECMP1f_GET BCM56800_A0_L3_DEFIPm_ECMP1f_GET
#define L3_DEFIPm_ECMP1f_SET BCM56800_A0_L3_DEFIPm_ECMP1f_SET
#define L3_DEFIPm_ECMP_PTR1f_GET BCM56800_A0_L3_DEFIPm_ECMP_PTR1f_GET
#define L3_DEFIPm_ECMP_PTR1f_SET BCM56800_A0_L3_DEFIPm_ECMP_PTR1f_SET
#define L3_DEFIPm_ECMP_COUNT1f_GET BCM56800_A0_L3_DEFIPm_ECMP_COUNT1f_GET
#define L3_DEFIPm_ECMP_COUNT1f_SET BCM56800_A0_L3_DEFIPm_ECMP_COUNT1f_SET
#define L3_DEFIPm_PRI1f_GET BCM56800_A0_L3_DEFIPm_PRI1f_GET
#define L3_DEFIPm_PRI1f_SET BCM56800_A0_L3_DEFIPm_PRI1f_SET
#define L3_DEFIPm_RPE1f_GET BCM56800_A0_L3_DEFIPm_RPE1f_GET
#define L3_DEFIPm_RPE1f_SET BCM56800_A0_L3_DEFIPm_RPE1f_SET
#define L3_DEFIPm_DST_DISCARD1f_GET BCM56800_A0_L3_DEFIPm_DST_DISCARD1f_GET
#define L3_DEFIPm_DST_DISCARD1f_SET BCM56800_A0_L3_DEFIPm_DST_DISCARD1f_SET
#define L3_DEFIPm_ECMP0f_GET BCM56800_A0_L3_DEFIPm_ECMP0f_GET
#define L3_DEFIPm_ECMP0f_SET BCM56800_A0_L3_DEFIPm_ECMP0f_SET
#define L3_DEFIPm_ECMP_PTR0f_GET BCM56800_A0_L3_DEFIPm_ECMP_PTR0f_GET
#define L3_DEFIPm_ECMP_PTR0f_SET BCM56800_A0_L3_DEFIPm_ECMP_PTR0f_SET
#define L3_DEFIPm_ECMP_COUNT0f_GET BCM56800_A0_L3_DEFIPm_ECMP_COUNT0f_GET
#define L3_DEFIPm_ECMP_COUNT0f_SET BCM56800_A0_L3_DEFIPm_ECMP_COUNT0f_SET
#define L3_DEFIPm_PRI0f_GET BCM56800_A0_L3_DEFIPm_PRI0f_GET
#define L3_DEFIPm_PRI0f_SET BCM56800_A0_L3_DEFIPm_PRI0f_SET
#define L3_DEFIPm_RPE0f_GET BCM56800_A0_L3_DEFIPm_RPE0f_GET
#define L3_DEFIPm_RPE0f_SET BCM56800_A0_L3_DEFIPm_RPE0f_SET
#define L3_DEFIPm_DST_DISCARD0f_GET BCM56800_A0_L3_DEFIPm_DST_DISCARD0f_GET
#define L3_DEFIPm_DST_DISCARD0f_SET BCM56800_A0_L3_DEFIPm_DST_DISCARD0f_SET
#define L3_DEFIPm_HIT0f_GET BCM56800_A0_L3_DEFIPm_HIT0f_GET
#define L3_DEFIPm_HIT0f_SET BCM56800_A0_L3_DEFIPm_HIT0f_SET
#define L3_DEFIPm_HIT1f_GET BCM56800_A0_L3_DEFIPm_HIT1f_GET
#define L3_DEFIPm_HIT1f_SET BCM56800_A0_L3_DEFIPm_HIT1f_SET
#define L3_DEFIPm_NEXT_HOP_INDEX1f_GET BCM56800_A0_L3_DEFIPm_NEXT_HOP_INDEX1f_GET
#define L3_DEFIPm_NEXT_HOP_INDEX1f_SET BCM56800_A0_L3_DEFIPm_NEXT_HOP_INDEX1f_SET
#define L3_DEFIPm_NEXT_HOP_INDEX0f_GET BCM56800_A0_L3_DEFIPm_NEXT_HOP_INDEX0f_GET
#define L3_DEFIPm_NEXT_HOP_INDEX0f_SET BCM56800_A0_L3_DEFIPm_NEXT_HOP_INDEX0f_SET
#define READ_L3_DEFIPm BCM56800_A0_READ_L3_DEFIPm
#define WRITE_L3_DEFIPm BCM56800_A0_WRITE_L3_DEFIPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S10_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S10_STATUS       S10_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr 0x08180c08

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s10_status[1];
	uint32_t _l3_defip_cam_bist_s10_status;
} BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_t;

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_CLR(r) (r).l3_defip_cam_bist_s10_status[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s10_status[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_GET(r) (r).l3_defip_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_S10_STATUSf_GET(r) (((r).l3_defip_cam_bist_s10_status[0]) & 0x7ff)
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_S10_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s10_status[0]=(((r).l3_defip_cam_bist_s10_status[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr,(r._l3_defip_cam_bist_s10_status))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr,&(r._l3_defip_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S10_STATUSr BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr
#define L3_DEFIP_CAM_BIST_S10_STATUSr_SIZE BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_t L3_DEFIP_CAM_BIST_S10_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S10_STATUSr_CLR BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S10_STATUSr_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S10_STATUSr_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S10_STATUSr_S10_STATUSf_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_S10_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S10_STATUSr_S10_STATUSf_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr_S10_STATUSf_SET
#define READ_L3_DEFIP_CAM_BIST_S10_STATUSr BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S10_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S10_STATUSr BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S2_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S2_STATUS        L3_DEFIP_CAM_BIST_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr 0x08180c03

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s2_status[1];
	uint32_t _l3_defip_cam_bist_s2_status;
} BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_t;

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_CLR(r) (r).l3_defip_cam_bist_s2_status[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s2_status[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_GET(r) (r).l3_defip_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_S2_STATUSf_GET(r) (((r).l3_defip_cam_bist_s2_status[0]) & 0x3ffff)
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_S2_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s2_status[0]=(((r).l3_defip_cam_bist_s2_status[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr,(r._l3_defip_cam_bist_s2_status))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr,&(r._l3_defip_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S2_STATUSr BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr
#define L3_DEFIP_CAM_BIST_S2_STATUSr_SIZE BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_t L3_DEFIP_CAM_BIST_S2_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S2_STATUSr_CLR BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S2_STATUSr_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_S2_STATUSf_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_S2_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S2_STATUSr_S2_STATUSf_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr_S2_STATUSf_SET
#define READ_L3_DEFIP_CAM_BIST_S2_STATUSr BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S2_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S2_STATUSr BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S3_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S3_STATUS        S3_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr 0x08180c04

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s3_status[1];
	uint32_t _l3_defip_cam_bist_s3_status;
} BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_t;

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_CLR(r) (r).l3_defip_cam_bist_s3_status[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s3_status[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_GET(r) (r).l3_defip_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_S3_STATUSf_GET(r) (((r).l3_defip_cam_bist_s3_status[0]) & 0x3fffff)
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_S3_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s3_status[0]=(((r).l3_defip_cam_bist_s3_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr,(r._l3_defip_cam_bist_s3_status))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr,&(r._l3_defip_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S3_STATUSr BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr
#define L3_DEFIP_CAM_BIST_S3_STATUSr_SIZE BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_t L3_DEFIP_CAM_BIST_S3_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S3_STATUSr_CLR BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S3_STATUSr_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_S3_STATUSf_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_S3_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S3_STATUSr_S3_STATUSf_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr_S3_STATUSf_SET
#define READ_L3_DEFIP_CAM_BIST_S3_STATUSr BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S3_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S3_STATUSr BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S5_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S5_STATUS        S5_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr 0x08180c05

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s5_status[1];
	uint32_t _l3_defip_cam_bist_s5_status;
} BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_t;

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_CLR(r) (r).l3_defip_cam_bist_s5_status[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s5_status[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_GET(r) (r).l3_defip_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_S5_STATUSf_GET(r) (((r).l3_defip_cam_bist_s5_status[0]) & 0x3ffff)
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_S5_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s5_status[0]=(((r).l3_defip_cam_bist_s5_status[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr,(r._l3_defip_cam_bist_s5_status))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr,&(r._l3_defip_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S5_STATUSr BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr
#define L3_DEFIP_CAM_BIST_S5_STATUSr_SIZE BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_t L3_DEFIP_CAM_BIST_S5_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S5_STATUSr_CLR BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S5_STATUSr_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_S5_STATUSf_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_S5_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S5_STATUSr_S5_STATUSf_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr_S5_STATUSf_SET
#define READ_L3_DEFIP_CAM_BIST_S5_STATUSr BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S5_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S5_STATUSr BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S6_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S6_STATUS        S6_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr 0x08180c06

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s6_status[1];
	uint32_t _l3_defip_cam_bist_s6_status;
} BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_t;

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_CLR(r) (r).l3_defip_cam_bist_s6_status[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s6_status[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_GET(r) (r).l3_defip_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_S6_STATUSf_GET(r) (((r).l3_defip_cam_bist_s6_status[0]) & 0x3fffff)
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_S6_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s6_status[0]=(((r).l3_defip_cam_bist_s6_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr,(r._l3_defip_cam_bist_s6_status))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr,&(r._l3_defip_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S6_STATUSr BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr
#define L3_DEFIP_CAM_BIST_S6_STATUSr_SIZE BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_t L3_DEFIP_CAM_BIST_S6_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S6_STATUSr_CLR BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S6_STATUSr_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_S6_STATUSf_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_S6_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S6_STATUSr_S6_STATUSf_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr_S6_STATUSf_SET
#define READ_L3_DEFIP_CAM_BIST_S6_STATUSr BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S6_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S6_STATUSr BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_S8_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S8_STATUS        S8_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr 0x08180c07

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_s8_status[1];
	uint32_t _l3_defip_cam_bist_s8_status;
} BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_t;

#define BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_CLR(r) (r).l3_defip_cam_bist_s8_status[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_SET(r,d) (r).l3_defip_cam_bist_s8_status[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_GET(r) (r).l3_defip_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_S8_STATUSf_GET(r) (((r).l3_defip_cam_bist_s8_status[0]) & 0x3fffff)
#define BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_S8_STATUSf_SET(r,f) (r).l3_defip_cam_bist_s8_status[0]=(((r).l3_defip_cam_bist_s8_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr,(r._l3_defip_cam_bist_s8_status))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr,&(r._l3_defip_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_S8_STATUSr BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr
#define L3_DEFIP_CAM_BIST_S8_STATUSr_SIZE BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_t L3_DEFIP_CAM_BIST_S8_STATUSr_t;
#define L3_DEFIP_CAM_BIST_S8_STATUSr_CLR BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_S8_STATUSr_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_SET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_GET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_S8_STATUSf_GET BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_S8_STATUSf_GET
#define L3_DEFIP_CAM_BIST_S8_STATUSr_S8_STATUSf_SET BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr_S8_STATUSf_SET
#define READ_L3_DEFIP_CAM_BIST_S8_STATUSr BCM56800_A0_READ_L3_DEFIP_CAM_BIST_S8_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_S8_STATUSr BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_BIST_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr 0x08180c02

#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_BIST_STATUS.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_bist_status[1];
	uint32_t _l3_defip_cam_bist_status;
} BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_t;

#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_CLR(r) (r).l3_defip_cam_bist_status[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_SET(r,d) (r).l3_defip_cam_bist_status[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_GET(r) (r).l3_defip_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).l3_defip_cam_bist_status[0]) & 0x1)
#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).l3_defip_cam_bist_status[0]=(((r).l3_defip_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).l3_defip_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).l3_defip_cam_bist_status[0]=(((r).l3_defip_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_DEFIP_CAM_BIST_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr,(r._l3_defip_cam_bist_status))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr,&(r._l3_defip_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_BIST_STATUSr BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr
#define L3_DEFIP_CAM_BIST_STATUSr_SIZE BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_t L3_DEFIP_CAM_BIST_STATUSr_t;
#define L3_DEFIP_CAM_BIST_STATUSr_CLR BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_CLR
#define L3_DEFIP_CAM_BIST_STATUSr_SET BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_SET
#define L3_DEFIP_CAM_BIST_STATUSr_GET BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_GET
#define L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_GET BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_GET
#define L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_SET BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_GOf_SET
#define L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_GET
#define L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_L3_DEFIP_CAM_BIST_STATUSr BCM56800_A0_READ_L3_DEFIP_CAM_BIST_STATUSr
#define WRITE_L3_DEFIP_CAM_BIST_STATUSr BCM56800_A0_WRITE_L3_DEFIP_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_DBGCTRL0
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_CONTROL0, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     CAM0_TM          TM debug bits for CAM0
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r 0x08180c00

#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_DBGCTRL0.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_dbgctrl0[1];
	uint32_t _l3_defip_cam_dbgctrl0;
} BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_t;

#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_CLR(r) (r).l3_defip_cam_dbgctrl0[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_SET(r,d) (r).l3_defip_cam_dbgctrl0[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_GET(r) (r).l3_defip_cam_dbgctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_CAM0_TMf_GET(r) (((r).l3_defip_cam_dbgctrl0[0]) & 0x7ff)
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_CAM0_TMf_SET(r,f) (r).l3_defip_cam_dbgctrl0[0]=(((r).l3_defip_cam_dbgctrl0[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access L3_DEFIP_CAM_DBGCTRL0.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_DBGCTRL0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r,(r._l3_defip_cam_dbgctrl0))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_DBGCTRL0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r,&(r._l3_defip_cam_dbgctrl0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_DBGCTRL0r BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r
#define L3_DEFIP_CAM_DBGCTRL0r_SIZE BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_t L3_DEFIP_CAM_DBGCTRL0r_t;
#define L3_DEFIP_CAM_DBGCTRL0r_CLR BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_CLR
#define L3_DEFIP_CAM_DBGCTRL0r_SET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_SET
#define L3_DEFIP_CAM_DBGCTRL0r_GET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_GET
#define L3_DEFIP_CAM_DBGCTRL0r_CAM0_TMf_GET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_CAM0_TMf_GET
#define L3_DEFIP_CAM_DBGCTRL0r_CAM0_TMf_SET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r_CAM0_TMf_SET
#define READ_L3_DEFIP_CAM_DBGCTRL0r BCM56800_A0_READ_L3_DEFIP_CAM_DBGCTRL0r
#define WRITE_L3_DEFIP_CAM_DBGCTRL0r BCM56800_A0_WRITE_L3_DEFIP_CAM_DBGCTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_DBGCTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_DBGCTRL1
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_CONTROL1, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_EN0         BIST enable for CAM0
 *     MODE             MODE=0 -> 32 bit mode, MODE=1 -> 64 bit mode
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r 0x08180c01

#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_DBGCTRL1.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_dbgctrl1[1];
	uint32_t _l3_defip_cam_dbgctrl1;
} BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_t;

#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_CLR(r) (r).l3_defip_cam_dbgctrl1[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_SET(r,d) (r).l3_defip_cam_dbgctrl1[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_GET(r) (r).l3_defip_cam_dbgctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_BIST_EN0f_GET(r) (((r).l3_defip_cam_dbgctrl1[0]) & 0x1)
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_BIST_EN0f_SET(r,f) (r).l3_defip_cam_dbgctrl1[0]=(((r).l3_defip_cam_dbgctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_MODEf_GET(r) ((((r).l3_defip_cam_dbgctrl1[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_MODEf_SET(r,f) (r).l3_defip_cam_dbgctrl1[0]=(((r).l3_defip_cam_dbgctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_DEFIP_CAM_DBGCTRL1.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_DBGCTRL1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r,(r._l3_defip_cam_dbgctrl1))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_DBGCTRL1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r,&(r._l3_defip_cam_dbgctrl1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_DBGCTRL1r BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r
#define L3_DEFIP_CAM_DBGCTRL1r_SIZE BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_t L3_DEFIP_CAM_DBGCTRL1r_t;
#define L3_DEFIP_CAM_DBGCTRL1r_CLR BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_CLR
#define L3_DEFIP_CAM_DBGCTRL1r_SET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_SET
#define L3_DEFIP_CAM_DBGCTRL1r_GET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_GET
#define L3_DEFIP_CAM_DBGCTRL1r_BIST_EN0f_GET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_BIST_EN0f_GET
#define L3_DEFIP_CAM_DBGCTRL1r_BIST_EN0f_SET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_BIST_EN0f_SET
#define L3_DEFIP_CAM_DBGCTRL1r_MODEf_GET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_MODEf_GET
#define L3_DEFIP_CAM_DBGCTRL1r_MODEf_SET BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r_MODEf_SET
#define READ_L3_DEFIP_CAM_DBGCTRL1r BCM56800_A0_READ_L3_DEFIP_CAM_DBGCTRL1r
#define WRITE_L3_DEFIP_CAM_DBGCTRL1r BCM56800_A0_WRITE_L3_DEFIP_CAM_DBGCTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_DBGCTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_CAM_ENABLE
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_CAM_ENABLE, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     CAM_0_ENABLE     L3_DEFIP_CAM_ENABLE FOR L3_DEFIP SLICE 0
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_CAM_ENABLEr 0x08180c09

#define BCM56800_A0_L3_DEFIP_CAM_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_CAM_ENABLE.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_CAM_ENABLEr_s {
	uint32_t v[1];
	uint32_t l3_defip_cam_enable[1];
	uint32_t _l3_defip_cam_enable;
} BCM56800_A0_L3_DEFIP_CAM_ENABLEr_t;

#define BCM56800_A0_L3_DEFIP_CAM_ENABLEr_CLR(r) (r).l3_defip_cam_enable[0] = 0
#define BCM56800_A0_L3_DEFIP_CAM_ENABLEr_SET(r,d) (r).l3_defip_cam_enable[0] = d
#define BCM56800_A0_L3_DEFIP_CAM_ENABLEr_GET(r) (r).l3_defip_cam_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_GET(r) (((r).l3_defip_cam_enable[0]) & 0x1)
#define BCM56800_A0_L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_SET(r,f) (r).l3_defip_cam_enable[0]=(((r).l3_defip_cam_enable[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access L3_DEFIP_CAM_ENABLE.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_CAM_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_CAM_ENABLEr,(r._l3_defip_cam_enable))
#define BCM56800_A0_WRITE_L3_DEFIP_CAM_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_CAM_ENABLEr,&(r._l3_defip_cam_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_CAM_ENABLEr BCM56800_A0_L3_DEFIP_CAM_ENABLEr
#define L3_DEFIP_CAM_ENABLEr_SIZE BCM56800_A0_L3_DEFIP_CAM_ENABLEr_SIZE
typedef BCM56800_A0_L3_DEFIP_CAM_ENABLEr_t L3_DEFIP_CAM_ENABLEr_t;
#define L3_DEFIP_CAM_ENABLEr_CLR BCM56800_A0_L3_DEFIP_CAM_ENABLEr_CLR
#define L3_DEFIP_CAM_ENABLEr_SET BCM56800_A0_L3_DEFIP_CAM_ENABLEr_SET
#define L3_DEFIP_CAM_ENABLEr_GET BCM56800_A0_L3_DEFIP_CAM_ENABLEr_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_GET BCM56800_A0_L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_GET
#define L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_SET BCM56800_A0_L3_DEFIP_CAM_ENABLEr_CAM_0_ENABLEf_SET
#define READ_L3_DEFIP_CAM_ENABLEr BCM56800_A0_READ_L3_DEFIP_CAM_ENABLEr
#define WRITE_L3_DEFIP_CAM_ENABLEr BCM56800_A0_WRITE_L3_DEFIP_CAM_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_CAM_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_DEFIP_DATA_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP_DATA_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits for L3_DEFIP_DATA RAM
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr 0x08180c0e

#define BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L3_DEFIP_DATA_DBGCTRL.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t l3_defip_data_dbgctrl[1];
	uint32_t _l3_defip_data_dbgctrl;
} BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_t;

#define BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_CLR(r) (r).l3_defip_data_dbgctrl[0] = 0
#define BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_SET(r,d) (r).l3_defip_data_dbgctrl[0] = d
#define BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_GET(r) (r).l3_defip_data_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_TMf_GET(r) (((r).l3_defip_data_dbgctrl[0]) & 0xf)
#define BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_TMf_SET(r,f) (r).l3_defip_data_dbgctrl[0]=(((r).l3_defip_data_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access L3_DEFIP_DATA_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr,(r._l3_defip_data_dbgctrl))
#define BCM56800_A0_WRITE_L3_DEFIP_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr,&(r._l3_defip_data_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_DATA_DBGCTRLr BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr
#define L3_DEFIP_DATA_DBGCTRLr_SIZE BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_SIZE
typedef BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_t L3_DEFIP_DATA_DBGCTRLr_t;
#define L3_DEFIP_DATA_DBGCTRLr_CLR BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_CLR
#define L3_DEFIP_DATA_DBGCTRLr_SET BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_SET
#define L3_DEFIP_DATA_DBGCTRLr_GET BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_GET
#define L3_DEFIP_DATA_DBGCTRLr_TMf_GET BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_TMf_GET
#define L3_DEFIP_DATA_DBGCTRLr_TMf_SET BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr_TMf_SET
#define READ_L3_DEFIP_DATA_DBGCTRLr BCM56800_A0_READ_L3_DEFIP_DATA_DBGCTRLr
#define WRITE_L3_DEFIP_DATA_DBGCTRLr BCM56800_A0_WRITE_L3_DEFIP_DATA_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_DATA_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_DEFIP_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 Default IP Route (LPM) Data SRAM for the L3_DEFIP TCAM. FeatureSpecific-Ethernet
 * SIZE:     44
 * FIELDS:
 *     ECMP1            Indicates if route for half-entry 1 uses ECMP
 *     ECMP_PTR1        Ptr to ECMP group within ECMP table for half-entry 1
 *     ECMP_COUNT1      No. of ECMP routes in group for half-entry 1
 *     PRI1             Priority for half-entry 1
 *     RPE1             RPE bit for half-entry 1
 *     DST_DISCARD1     Discard pkt on L3 DEFIP hit
 *     ECMP0            Indicates if route for half-entry 0 uses ECMP
 *     ECMP_PTR0        Ptr to ECMP group within ECMP table for half-entry 0
 *     ECMP_COUNT0      No. of ECMP routes in group for half-entry 0
 *     PRI0             Priority for half-entry 0
 *     RPE0             RPE bit for half-entry 0
 *     DST_DISCARD0     Discard pkt on L3 DEFIP hit
 *     NEXT_HOP_INDEX1  Next hop index pointer for half-entry 1
 *     NEXT_HOP_INDEX0  Next hop index pointer for half-entry 0
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm 0x0a162000

#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_MIN 0
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_MAX 511
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_CMAX(u) 511
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_SIZE 6

/*
 * This structure should be used to declare and program L3_DEFIP_DATA_ONLY.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_DATA_ONLYm_s {
	uint32_t v[2];
	uint32_t l3_defip_data_only[2];
	uint32_t _l3_defip_data_only;
} BCM56800_A0_L3_DEFIP_DATA_ONLYm_t;

#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_CLR(r) CDK_MEMSET(&((r)._l3_defip_data_only), 0, sizeof(BCM56800_A0_L3_DEFIP_DATA_ONLYm_t))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_SET(r,i,d) (r).l3_defip_data_only[i] = d
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_GET(r,i) (r).l3_defip_data_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP1f_GET(r) (((r).l3_defip_data_only[0]) & 0x1)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_GET(r) ((((r).l3_defip_data_only[0]) >> 1) & 0x7ff)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_GET(r) ((((r).l3_defip_data_only[0]) >> 12) & 0x1f)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_PRI1f_GET(r) ((((r).l3_defip_data_only[0]) >> 17) & 0x7)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_PRI1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x7 << 17)) | ((((uint32_t)f) & 0x7) << 17))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_RPE1f_GET(r) ((((r).l3_defip_data_only[0]) >> 20) & 0x1)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_RPE1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_DST_DISCARD1f_GET(r) ((((r).l3_defip_data_only[0]) >> 21) & 0x1)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_DST_DISCARD1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP0f_GET(r) ((((r).l3_defip_data_only[0]) >> 22) & 0x1)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP0f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_GET(r) cdk_field32_get((r).l3_defip_data_only,23,33)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_SET(r,f) cdk_field32_set((r).l3_defip_data_only,23,33,f)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_GET(r) ((((r).l3_defip_data_only[1]) >> 2) & 0x1f)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_SET(r,f) (r).l3_defip_data_only[1]=(((r).l3_defip_data_only[1] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_PRI0f_GET(r) ((((r).l3_defip_data_only[1]) >> 7) & 0x7)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_PRI0f_SET(r,f) (r).l3_defip_data_only[1]=(((r).l3_defip_data_only[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_RPE0f_GET(r) ((((r).l3_defip_data_only[1]) >> 10) & 0x1)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_RPE0f_SET(r,f) (r).l3_defip_data_only[1]=(((r).l3_defip_data_only[1] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_DST_DISCARD0f_GET(r) ((((r).l3_defip_data_only[1]) >> 11) & 0x1)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_DST_DISCARD0f_SET(r,f) (r).l3_defip_data_only[1]=(((r).l3_defip_data_only[1] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_GET(r) ((((r).l3_defip_data_only[0]) >> 1) & 0x1fff)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_SET(r,f) (r).l3_defip_data_only[0]=(((r).l3_defip_data_only[0] & ~((uint32_t)0x1fff << 1)) | ((((uint32_t)f) & 0x1fff) << 1))
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_GET(r) cdk_field32_get((r).l3_defip_data_only,23,35)
#define BCM56800_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_SET(r,f) cdk_field32_set((r).l3_defip_data_only,23,35,f)

/*
 * These macros can be used to access L3_DEFIP_DATA_ONLY.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_DEFIP_DATA_ONLYm,i,(m._l3_defip_data_only),2)
#define BCM56800_A0_WRITE_L3_DEFIP_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_DEFIP_DATA_ONLYm,i,&(m._l3_defip_data_only),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_DATA_ONLYm BCM56800_A0_L3_DEFIP_DATA_ONLYm
#define L3_DEFIP_DATA_ONLYm_MIN BCM56800_A0_L3_DEFIP_DATA_ONLYm_MIN
#define L3_DEFIP_DATA_ONLYm_MAX BCM56800_A0_L3_DEFIP_DATA_ONLYm_MAX
#define L3_DEFIP_DATA_ONLYm_CMAX(u) BCM56800_A0_L3_DEFIP_DATA_ONLYm_CMAX(u)
#define L3_DEFIP_DATA_ONLYm_SIZE BCM56800_A0_L3_DEFIP_DATA_ONLYm_SIZE
typedef BCM56800_A0_L3_DEFIP_DATA_ONLYm_t L3_DEFIP_DATA_ONLYm_t;
#define L3_DEFIP_DATA_ONLYm_CLR BCM56800_A0_L3_DEFIP_DATA_ONLYm_CLR
#define L3_DEFIP_DATA_ONLYm_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_SET
#define L3_DEFIP_DATA_ONLYm_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_GET
#define L3_DEFIP_DATA_ONLYm_ECMP1f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP1f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP1f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP1f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR1f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT1f_SET
#define L3_DEFIP_DATA_ONLYm_PRI1f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_PRI1f_GET
#define L3_DEFIP_DATA_ONLYm_PRI1f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_PRI1f_SET
#define L3_DEFIP_DATA_ONLYm_RPE1f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_RPE1f_GET
#define L3_DEFIP_DATA_ONLYm_RPE1f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_RPE1f_SET
#define L3_DEFIP_DATA_ONLYm_DST_DISCARD1f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_DST_DISCARD1f_GET
#define L3_DEFIP_DATA_ONLYm_DST_DISCARD1f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_DST_DISCARD1f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP0f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP0f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP0f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP0f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_PTR0f_SET
#define L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_GET
#define L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_ECMP_COUNT0f_SET
#define L3_DEFIP_DATA_ONLYm_PRI0f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_PRI0f_GET
#define L3_DEFIP_DATA_ONLYm_PRI0f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_PRI0f_SET
#define L3_DEFIP_DATA_ONLYm_RPE0f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_RPE0f_GET
#define L3_DEFIP_DATA_ONLYm_RPE0f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_RPE0f_SET
#define L3_DEFIP_DATA_ONLYm_DST_DISCARD0f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_DST_DISCARD0f_GET
#define L3_DEFIP_DATA_ONLYm_DST_DISCARD0f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_DST_DISCARD0f_SET
#define L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_GET
#define L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX1f_SET
#define L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_GET BCM56800_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_GET
#define L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_SET BCM56800_A0_L3_DEFIP_DATA_ONLYm_NEXT_HOP_INDEX0f_SET
#define READ_L3_DEFIP_DATA_ONLYm BCM56800_A0_READ_L3_DEFIP_DATA_ONLYm
#define WRITE_L3_DEFIP_DATA_ONLYm BCM56800_A0_WRITE_L3_DEFIP_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_DEFIP_HIT_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3_DEFIP Hit bit table, FeatureSpecific-Ethernet
 * SIZE:     2
 * FIELDS:
 *     HIT0             Indicates that the entry #0 has been hit
 *     HIT1             Indicates that the entry #1 has been hit
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm 0x0b122000

#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_MIN 0
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_MAX 511
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_CMAX(u) 511
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L3_DEFIP_HIT_ONLY.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_HIT_ONLYm_s {
	uint32_t v[1];
	uint32_t l3_defip_hit_only[1];
	uint32_t _l3_defip_hit_only;
} BCM56800_A0_L3_DEFIP_HIT_ONLYm_t;

#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_CLR(r) (r).l3_defip_hit_only[0] = 0
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_SET(r,d) (r).l3_defip_hit_only[0] = d
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_GET(r) (r).l3_defip_hit_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_HIT0f_GET(r) (((r).l3_defip_hit_only[0]) & 0x1)
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_HIT0f_SET(r,f) (r).l3_defip_hit_only[0]=(((r).l3_defip_hit_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_HIT1f_GET(r) ((((r).l3_defip_hit_only[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_DEFIP_HIT_ONLYm_HIT1f_SET(r,f) (r).l3_defip_hit_only[0]=(((r).l3_defip_hit_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_DEFIP_HIT_ONLY.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_HIT_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_DEFIP_HIT_ONLYm,i,(m._l3_defip_hit_only),1)
#define BCM56800_A0_WRITE_L3_DEFIP_HIT_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_DEFIP_HIT_ONLYm,i,&(m._l3_defip_hit_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_HIT_ONLYm BCM56800_A0_L3_DEFIP_HIT_ONLYm
#define L3_DEFIP_HIT_ONLYm_MIN BCM56800_A0_L3_DEFIP_HIT_ONLYm_MIN
#define L3_DEFIP_HIT_ONLYm_MAX BCM56800_A0_L3_DEFIP_HIT_ONLYm_MAX
#define L3_DEFIP_HIT_ONLYm_CMAX(u) BCM56800_A0_L3_DEFIP_HIT_ONLYm_CMAX(u)
#define L3_DEFIP_HIT_ONLYm_SIZE BCM56800_A0_L3_DEFIP_HIT_ONLYm_SIZE
typedef BCM56800_A0_L3_DEFIP_HIT_ONLYm_t L3_DEFIP_HIT_ONLYm_t;
#define L3_DEFIP_HIT_ONLYm_CLR BCM56800_A0_L3_DEFIP_HIT_ONLYm_CLR
#define L3_DEFIP_HIT_ONLYm_SET BCM56800_A0_L3_DEFIP_HIT_ONLYm_SET
#define L3_DEFIP_HIT_ONLYm_GET BCM56800_A0_L3_DEFIP_HIT_ONLYm_GET
#define L3_DEFIP_HIT_ONLYm_HIT0f_GET BCM56800_A0_L3_DEFIP_HIT_ONLYm_HIT0f_GET
#define L3_DEFIP_HIT_ONLYm_HIT0f_SET BCM56800_A0_L3_DEFIP_HIT_ONLYm_HIT0f_SET
#define L3_DEFIP_HIT_ONLYm_HIT1f_GET BCM56800_A0_L3_DEFIP_HIT_ONLYm_HIT1f_GET
#define L3_DEFIP_HIT_ONLYm_HIT1f_SET BCM56800_A0_L3_DEFIP_HIT_ONLYm_HIT1f_SET
#define READ_L3_DEFIP_HIT_ONLYm BCM56800_A0_READ_L3_DEFIP_HIT_ONLYm
#define WRITE_L3_DEFIP_HIT_ONLYm BCM56800_A0_WRITE_L3_DEFIP_HIT_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_HIT_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_DEFIP_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 Default IP Route (LPM) TCAM only view. FeatureSpecific-Ethernet
 * SIZE:     132
 * FIELDS:
 *     VALID0           Indicates half-entry 0 is valid
 *     VALID1           Indicates half-entry 1 is valid
 *     MODE0            Indicates contents of half-entry 0; 0=IPv4, 1=IPv6
 *     MODE1            Indicates contents of half-entry 1; 0=IPv4, 1=IPv6
 *     IP_ADDR0         IP address bits for half-entry 0
 *     IP_ADDR1         IP address bits for half-entry 1
 *     MASK0            Subnet mask for half-entry 0
 *     MASK1            Subnet mask for half-entry 1
 *
 ******************************************************************************/
#define BCM56800_A0_L3_DEFIP_ONLYm 0x0a161000

#define BCM56800_A0_L3_DEFIP_ONLYm_MIN 0
#define BCM56800_A0_L3_DEFIP_ONLYm_MAX 511
#define BCM56800_A0_L3_DEFIP_ONLYm_CMAX(u) 511
#define BCM56800_A0_L3_DEFIP_ONLYm_SIZE 17

/*
 * This structure should be used to declare and program L3_DEFIP_ONLY.
 *
 */
typedef union BCM56800_A0_L3_DEFIP_ONLYm_s {
	uint32_t v[5];
	uint32_t l3_defip_only[5];
	uint32_t _l3_defip_only;
} BCM56800_A0_L3_DEFIP_ONLYm_t;

#define BCM56800_A0_L3_DEFIP_ONLYm_CLR(r) CDK_MEMSET(&((r)._l3_defip_only), 0, sizeof(BCM56800_A0_L3_DEFIP_ONLYm_t))
#define BCM56800_A0_L3_DEFIP_ONLYm_SET(r,i,d) (r).l3_defip_only[i] = d
#define BCM56800_A0_L3_DEFIP_ONLYm_GET(r,i) (r).l3_defip_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_DEFIP_ONLYm_VALID0f_GET(r) (((r).l3_defip_only[0]) & 0x1)
#define BCM56800_A0_L3_DEFIP_ONLYm_VALID0f_SET(r,f) (r).l3_defip_only[0]=(((r).l3_defip_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_DEFIP_ONLYm_VALID1f_GET(r) ((((r).l3_defip_only[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_DEFIP_ONLYm_VALID1f_SET(r,f) (r).l3_defip_only[0]=(((r).l3_defip_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_DEFIP_ONLYm_MODE0f_GET(r) ((((r).l3_defip_only[0]) >> 2) & 0x1)
#define BCM56800_A0_L3_DEFIP_ONLYm_MODE0f_SET(r,f) (r).l3_defip_only[0]=(((r).l3_defip_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L3_DEFIP_ONLYm_MODE1f_GET(r) ((((r).l3_defip_only[0]) >> 3) & 0x1)
#define BCM56800_A0_L3_DEFIP_ONLYm_MODE1f_SET(r,f) (r).l3_defip_only[0]=(((r).l3_defip_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_DEFIP_ONLYm_IP_ADDR0f_GET(r) cdk_field32_get((r).l3_defip_only,4,35)
#define BCM56800_A0_L3_DEFIP_ONLYm_IP_ADDR0f_SET(r,f) cdk_field32_set((r).l3_defip_only,4,35,f)
#define BCM56800_A0_L3_DEFIP_ONLYm_IP_ADDR1f_GET(r) cdk_field32_get((r).l3_defip_only,36,67)
#define BCM56800_A0_L3_DEFIP_ONLYm_IP_ADDR1f_SET(r,f) cdk_field32_set((r).l3_defip_only,36,67,f)
#define BCM56800_A0_L3_DEFIP_ONLYm_MASK0f_GET(r) cdk_field32_get((r).l3_defip_only,68,99)
#define BCM56800_A0_L3_DEFIP_ONLYm_MASK0f_SET(r,f) cdk_field32_set((r).l3_defip_only,68,99,f)
#define BCM56800_A0_L3_DEFIP_ONLYm_MASK1f_GET(r) cdk_field32_get((r).l3_defip_only,100,131)
#define BCM56800_A0_L3_DEFIP_ONLYm_MASK1f_SET(r,f) cdk_field32_set((r).l3_defip_only,100,131,f)

/*
 * These macros can be used to access L3_DEFIP_ONLY.
 *
 */
#define BCM56800_A0_READ_L3_DEFIP_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_DEFIP_ONLYm,i,(m._l3_defip_only),5)
#define BCM56800_A0_WRITE_L3_DEFIP_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_DEFIP_ONLYm,i,&(m._l3_defip_only),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_DEFIP_ONLYm BCM56800_A0_L3_DEFIP_ONLYm
#define L3_DEFIP_ONLYm_MIN BCM56800_A0_L3_DEFIP_ONLYm_MIN
#define L3_DEFIP_ONLYm_MAX BCM56800_A0_L3_DEFIP_ONLYm_MAX
#define L3_DEFIP_ONLYm_CMAX(u) BCM56800_A0_L3_DEFIP_ONLYm_CMAX(u)
#define L3_DEFIP_ONLYm_SIZE BCM56800_A0_L3_DEFIP_ONLYm_SIZE
typedef BCM56800_A0_L3_DEFIP_ONLYm_t L3_DEFIP_ONLYm_t;
#define L3_DEFIP_ONLYm_CLR BCM56800_A0_L3_DEFIP_ONLYm_CLR
#define L3_DEFIP_ONLYm_SET BCM56800_A0_L3_DEFIP_ONLYm_SET
#define L3_DEFIP_ONLYm_GET BCM56800_A0_L3_DEFIP_ONLYm_GET
#define L3_DEFIP_ONLYm_VALID0f_GET BCM56800_A0_L3_DEFIP_ONLYm_VALID0f_GET
#define L3_DEFIP_ONLYm_VALID0f_SET BCM56800_A0_L3_DEFIP_ONLYm_VALID0f_SET
#define L3_DEFIP_ONLYm_VALID1f_GET BCM56800_A0_L3_DEFIP_ONLYm_VALID1f_GET
#define L3_DEFIP_ONLYm_VALID1f_SET BCM56800_A0_L3_DEFIP_ONLYm_VALID1f_SET
#define L3_DEFIP_ONLYm_MODE0f_GET BCM56800_A0_L3_DEFIP_ONLYm_MODE0f_GET
#define L3_DEFIP_ONLYm_MODE0f_SET BCM56800_A0_L3_DEFIP_ONLYm_MODE0f_SET
#define L3_DEFIP_ONLYm_MODE1f_GET BCM56800_A0_L3_DEFIP_ONLYm_MODE1f_GET
#define L3_DEFIP_ONLYm_MODE1f_SET BCM56800_A0_L3_DEFIP_ONLYm_MODE1f_SET
#define L3_DEFIP_ONLYm_IP_ADDR0f_GET BCM56800_A0_L3_DEFIP_ONLYm_IP_ADDR0f_GET
#define L3_DEFIP_ONLYm_IP_ADDR0f_SET BCM56800_A0_L3_DEFIP_ONLYm_IP_ADDR0f_SET
#define L3_DEFIP_ONLYm_IP_ADDR1f_GET BCM56800_A0_L3_DEFIP_ONLYm_IP_ADDR1f_GET
#define L3_DEFIP_ONLYm_IP_ADDR1f_SET BCM56800_A0_L3_DEFIP_ONLYm_IP_ADDR1f_SET
#define L3_DEFIP_ONLYm_MASK0f_GET BCM56800_A0_L3_DEFIP_ONLYm_MASK0f_GET
#define L3_DEFIP_ONLYm_MASK0f_SET BCM56800_A0_L3_DEFIP_ONLYm_MASK0f_SET
#define L3_DEFIP_ONLYm_MASK1f_GET BCM56800_A0_L3_DEFIP_ONLYm_MASK1f_GET
#define L3_DEFIP_ONLYm_MASK1f_SET BCM56800_A0_L3_DEFIP_ONLYm_MASK1f_SET
#define READ_L3_DEFIP_ONLYm BCM56800_A0_READ_L3_DEFIP_ONLYm
#define WRITE_L3_DEFIP_ONLYm BCM56800_A0_WRITE_L3_DEFIP_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_DEFIP_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_ECMP
 * BLOCKS:   IPIPE
 * DESC:     L3 Equal Cost Multipath table, FeatureSpecific-Ethernet
 * SIZE:     13
 * FIELDS:
 *     NEXT_HOP_INDEX   Index of next hop for this ECMP route
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ECMPm 0x0d160000

#define BCM56800_A0_L3_ECMPm_MIN 0
#define BCM56800_A0_L3_ECMPm_MAX 127
#define BCM56800_A0_L3_ECMPm_CMAX(u) 127
#define BCM56800_A0_L3_ECMPm_SIZE 2

/*
 * This structure should be used to declare and program L3_ECMP.
 *
 */
typedef union BCM56800_A0_L3_ECMPm_s {
	uint32_t v[1];
	uint32_t l3_ecmp[1];
	uint32_t _l3_ecmp;
} BCM56800_A0_L3_ECMPm_t;

#define BCM56800_A0_L3_ECMPm_CLR(r) (r).l3_ecmp[0] = 0
#define BCM56800_A0_L3_ECMPm_SET(r,d) (r).l3_ecmp[0] = d
#define BCM56800_A0_L3_ECMPm_GET(r) (r).l3_ecmp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ECMPm_NEXT_HOP_INDEXf_GET(r) (((r).l3_ecmp[0]) & 0x1fff)
#define BCM56800_A0_L3_ECMPm_NEXT_HOP_INDEXf_SET(r,f) (r).l3_ecmp[0]=(((r).l3_ecmp[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))

/*
 * These macros can be used to access L3_ECMP.
 *
 */
#define BCM56800_A0_READ_L3_ECMPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_ECMPm,i,(m._l3_ecmp),1)
#define BCM56800_A0_WRITE_L3_ECMPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_ECMPm,i,&(m._l3_ecmp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ECMPm BCM56800_A0_L3_ECMPm
#define L3_ECMPm_MIN BCM56800_A0_L3_ECMPm_MIN
#define L3_ECMPm_MAX BCM56800_A0_L3_ECMPm_MAX
#define L3_ECMPm_CMAX(u) BCM56800_A0_L3_ECMPm_CMAX(u)
#define L3_ECMPm_SIZE BCM56800_A0_L3_ECMPm_SIZE
typedef BCM56800_A0_L3_ECMPm_t L3_ECMPm_t;
#define L3_ECMPm_CLR BCM56800_A0_L3_ECMPm_CLR
#define L3_ECMPm_SET BCM56800_A0_L3_ECMPm_SET
#define L3_ECMPm_GET BCM56800_A0_L3_ECMPm_GET
#define L3_ECMPm_NEXT_HOP_INDEXf_GET BCM56800_A0_L3_ECMPm_NEXT_HOP_INDEXf_GET
#define L3_ECMPm_NEXT_HOP_INDEXf_SET BCM56800_A0_L3_ECMPm_NEXT_HOP_INDEXf_SET
#define READ_L3_ECMPm BCM56800_A0_READ_L3_ECMPm
#define WRITE_L3_ECMPm BCM56800_A0_WRITE_L3_ECMPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ECMPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_ECMP_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L3_ECMP_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ECMP_DBGCTRLr 0x0d180c00

#define BCM56800_A0_L3_ECMP_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L3_ECMP_DBGCTRL.
 *
 */
typedef union BCM56800_A0_L3_ECMP_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t l3_ecmp_dbgctrl[1];
	uint32_t _l3_ecmp_dbgctrl;
} BCM56800_A0_L3_ECMP_DBGCTRLr_t;

#define BCM56800_A0_L3_ECMP_DBGCTRLr_CLR(r) (r).l3_ecmp_dbgctrl[0] = 0
#define BCM56800_A0_L3_ECMP_DBGCTRLr_SET(r,d) (r).l3_ecmp_dbgctrl[0] = d
#define BCM56800_A0_L3_ECMP_DBGCTRLr_GET(r) (r).l3_ecmp_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ECMP_DBGCTRLr_TMf_GET(r) (((r).l3_ecmp_dbgctrl[0]) & 0xf)
#define BCM56800_A0_L3_ECMP_DBGCTRLr_TMf_SET(r,f) (r).l3_ecmp_dbgctrl[0]=(((r).l3_ecmp_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access L3_ECMP_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_L3_ECMP_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_ECMP_DBGCTRLr,(r._l3_ecmp_dbgctrl))
#define BCM56800_A0_WRITE_L3_ECMP_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_ECMP_DBGCTRLr,&(r._l3_ecmp_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ECMP_DBGCTRLr BCM56800_A0_L3_ECMP_DBGCTRLr
#define L3_ECMP_DBGCTRLr_SIZE BCM56800_A0_L3_ECMP_DBGCTRLr_SIZE
typedef BCM56800_A0_L3_ECMP_DBGCTRLr_t L3_ECMP_DBGCTRLr_t;
#define L3_ECMP_DBGCTRLr_CLR BCM56800_A0_L3_ECMP_DBGCTRLr_CLR
#define L3_ECMP_DBGCTRLr_SET BCM56800_A0_L3_ECMP_DBGCTRLr_SET
#define L3_ECMP_DBGCTRLr_GET BCM56800_A0_L3_ECMP_DBGCTRLr_GET
#define L3_ECMP_DBGCTRLr_TMf_GET BCM56800_A0_L3_ECMP_DBGCTRLr_TMf_GET
#define L3_ECMP_DBGCTRLr_TMf_SET BCM56800_A0_L3_ECMP_DBGCTRLr_TMf_SET
#define READ_L3_ECMP_DBGCTRLr BCM56800_A0_READ_L3_ECMP_DBGCTRLr
#define WRITE_L3_ECMP_DBGCTRLr BCM56800_A0_WRITE_L3_ECMP_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ECMP_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_ENTRY_DBGCTRL0
 * BLOCKS:   IPIPE
 * DESC:     L3_ENTRY_CONTROL0, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     RAM0_TM          TM debug bits for RAM0
 *     RAM1_TM          TM debug bits for RAM1
 *     RAM2_TM          TM debug bits for RAM2
 *     RAM3_TM          TM debug bits for RAM3
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r 0x0818020a

#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_SIZE 4

/*
 * This structure should be used to declare and program L3_ENTRY_DBGCTRL0.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_DBGCTRL0r_s {
	uint32_t v[1];
	uint32_t l3_entry_dbgctrl0[1];
	uint32_t _l3_entry_dbgctrl0;
} BCM56800_A0_L3_ENTRY_DBGCTRL0r_t;

#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_CLR(r) (r).l3_entry_dbgctrl0[0] = 0
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_SET(r,d) (r).l3_entry_dbgctrl0[0] = d
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_GET(r) (r).l3_entry_dbgctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM0_TMf_GET(r) (((r).l3_entry_dbgctrl0[0]) & 0xff)
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM0_TMf_SET(r,f) (r).l3_entry_dbgctrl0[0]=(((r).l3_entry_dbgctrl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM1_TMf_GET(r) ((((r).l3_entry_dbgctrl0[0]) >> 8) & 0xff)
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM1_TMf_SET(r,f) (r).l3_entry_dbgctrl0[0]=(((r).l3_entry_dbgctrl0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM2_TMf_GET(r) ((((r).l3_entry_dbgctrl0[0]) >> 16) & 0xff)
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM2_TMf_SET(r,f) (r).l3_entry_dbgctrl0[0]=(((r).l3_entry_dbgctrl0[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM3_TMf_GET(r) ((((r).l3_entry_dbgctrl0[0]) >> 24) & 0xff)
#define BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM3_TMf_SET(r,f) (r).l3_entry_dbgctrl0[0]=(((r).l3_entry_dbgctrl0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access L3_ENTRY_DBGCTRL0.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_DBGCTRL0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_ENTRY_DBGCTRL0r,(r._l3_entry_dbgctrl0))
#define BCM56800_A0_WRITE_L3_ENTRY_DBGCTRL0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_ENTRY_DBGCTRL0r,&(r._l3_entry_dbgctrl0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_DBGCTRL0r BCM56800_A0_L3_ENTRY_DBGCTRL0r
#define L3_ENTRY_DBGCTRL0r_SIZE BCM56800_A0_L3_ENTRY_DBGCTRL0r_SIZE
typedef BCM56800_A0_L3_ENTRY_DBGCTRL0r_t L3_ENTRY_DBGCTRL0r_t;
#define L3_ENTRY_DBGCTRL0r_CLR BCM56800_A0_L3_ENTRY_DBGCTRL0r_CLR
#define L3_ENTRY_DBGCTRL0r_SET BCM56800_A0_L3_ENTRY_DBGCTRL0r_SET
#define L3_ENTRY_DBGCTRL0r_GET BCM56800_A0_L3_ENTRY_DBGCTRL0r_GET
#define L3_ENTRY_DBGCTRL0r_RAM0_TMf_GET BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM0_TMf_GET
#define L3_ENTRY_DBGCTRL0r_RAM0_TMf_SET BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM0_TMf_SET
#define L3_ENTRY_DBGCTRL0r_RAM1_TMf_GET BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM1_TMf_GET
#define L3_ENTRY_DBGCTRL0r_RAM1_TMf_SET BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM1_TMf_SET
#define L3_ENTRY_DBGCTRL0r_RAM2_TMf_GET BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM2_TMf_GET
#define L3_ENTRY_DBGCTRL0r_RAM2_TMf_SET BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM2_TMf_SET
#define L3_ENTRY_DBGCTRL0r_RAM3_TMf_GET BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM3_TMf_GET
#define L3_ENTRY_DBGCTRL0r_RAM3_TMf_SET BCM56800_A0_L3_ENTRY_DBGCTRL0r_RAM3_TMf_SET
#define READ_L3_ENTRY_DBGCTRL0r BCM56800_A0_READ_L3_ENTRY_DBGCTRL0r
#define WRITE_L3_ENTRY_DBGCTRL0r BCM56800_A0_WRITE_L3_ENTRY_DBGCTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_DBGCTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_ENTRY_DBGCTRL1
 * BLOCKS:   IPIPE
 * DESC:     L3_ENTRY_CONTROL1, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     RAM4_TM          TM debug bits for RAM4
 *     RAM5_TM          TM debug bits for RAM5
 *     RAM6_TM          TM debug bits for RAM6
 *     RAM7_TM          TM debug bits for RAM7
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r 0x0818020b

#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_SIZE 4

/*
 * This structure should be used to declare and program L3_ENTRY_DBGCTRL1.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_DBGCTRL1r_s {
	uint32_t v[1];
	uint32_t l3_entry_dbgctrl1[1];
	uint32_t _l3_entry_dbgctrl1;
} BCM56800_A0_L3_ENTRY_DBGCTRL1r_t;

#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_CLR(r) (r).l3_entry_dbgctrl1[0] = 0
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_SET(r,d) (r).l3_entry_dbgctrl1[0] = d
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_GET(r) (r).l3_entry_dbgctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM4_TMf_GET(r) (((r).l3_entry_dbgctrl1[0]) & 0xff)
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM4_TMf_SET(r,f) (r).l3_entry_dbgctrl1[0]=(((r).l3_entry_dbgctrl1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM5_TMf_GET(r) ((((r).l3_entry_dbgctrl1[0]) >> 8) & 0xff)
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM5_TMf_SET(r,f) (r).l3_entry_dbgctrl1[0]=(((r).l3_entry_dbgctrl1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM6_TMf_GET(r) ((((r).l3_entry_dbgctrl1[0]) >> 16) & 0xff)
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM6_TMf_SET(r,f) (r).l3_entry_dbgctrl1[0]=(((r).l3_entry_dbgctrl1[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM7_TMf_GET(r) ((((r).l3_entry_dbgctrl1[0]) >> 24) & 0xff)
#define BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM7_TMf_SET(r,f) (r).l3_entry_dbgctrl1[0]=(((r).l3_entry_dbgctrl1[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access L3_ENTRY_DBGCTRL1.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_DBGCTRL1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_ENTRY_DBGCTRL1r,(r._l3_entry_dbgctrl1))
#define BCM56800_A0_WRITE_L3_ENTRY_DBGCTRL1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_ENTRY_DBGCTRL1r,&(r._l3_entry_dbgctrl1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_DBGCTRL1r BCM56800_A0_L3_ENTRY_DBGCTRL1r
#define L3_ENTRY_DBGCTRL1r_SIZE BCM56800_A0_L3_ENTRY_DBGCTRL1r_SIZE
typedef BCM56800_A0_L3_ENTRY_DBGCTRL1r_t L3_ENTRY_DBGCTRL1r_t;
#define L3_ENTRY_DBGCTRL1r_CLR BCM56800_A0_L3_ENTRY_DBGCTRL1r_CLR
#define L3_ENTRY_DBGCTRL1r_SET BCM56800_A0_L3_ENTRY_DBGCTRL1r_SET
#define L3_ENTRY_DBGCTRL1r_GET BCM56800_A0_L3_ENTRY_DBGCTRL1r_GET
#define L3_ENTRY_DBGCTRL1r_RAM4_TMf_GET BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM4_TMf_GET
#define L3_ENTRY_DBGCTRL1r_RAM4_TMf_SET BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM4_TMf_SET
#define L3_ENTRY_DBGCTRL1r_RAM5_TMf_GET BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM5_TMf_GET
#define L3_ENTRY_DBGCTRL1r_RAM5_TMf_SET BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM5_TMf_SET
#define L3_ENTRY_DBGCTRL1r_RAM6_TMf_GET BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM6_TMf_GET
#define L3_ENTRY_DBGCTRL1r_RAM6_TMf_SET BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM6_TMf_SET
#define L3_ENTRY_DBGCTRL1r_RAM7_TMf_GET BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM7_TMf_GET
#define L3_ENTRY_DBGCTRL1r_RAM7_TMf_SET BCM56800_A0_L3_ENTRY_DBGCTRL1r_RAM7_TMf_SET
#define READ_L3_ENTRY_DBGCTRL1r BCM56800_A0_READ_L3_ENTRY_DBGCTRL1r
#define WRITE_L3_ENTRY_DBGCTRL1r BCM56800_A0_WRITE_L3_ENTRY_DBGCTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_DBGCTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_ENTRY_HIT_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 Hit bit table, FeatureSpecific-Ethernet
 * SIZE:     8
 * FIELDS:
 *     HIT_0            Indicates that the entry has been hit
 *     HIT_1            Indicates that the entry has been hit
 *     HIT_2            Indicates that the entry has been hit
 *     HIT_3            Indicates that the entry has been hit
 *     HIT_4            Indicates that the entry has been hit
 *     HIT_5            Indicates that the entry has been hit
 *     HIT_6            Indicates that the entry has been hit
 *     HIT_7            Indicates that the entry has been hit
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm 0x0b121000

#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_MIN 0
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_MAX 511
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_CMAX(u) 511
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L3_ENTRY_HIT_ONLY.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_HIT_ONLYm_s {
	uint32_t v[1];
	uint32_t l3_entry_hit_only[1];
	uint32_t _l3_entry_hit_only;
} BCM56800_A0_L3_ENTRY_HIT_ONLYm_t;

#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_CLR(r) (r).l3_entry_hit_only[0] = 0
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_SET(r,d) (r).l3_entry_hit_only[0] = d
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_GET(r) (r).l3_entry_hit_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_0f_GET(r) (((r).l3_entry_hit_only[0]) & 0x1)
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_0f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_1f_GET(r) ((((r).l3_entry_hit_only[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_1f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_2f_GET(r) ((((r).l3_entry_hit_only[0]) >> 2) & 0x1)
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_2f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_3f_GET(r) ((((r).l3_entry_hit_only[0]) >> 3) & 0x1)
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_3f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_4f_GET(r) ((((r).l3_entry_hit_only[0]) >> 4) & 0x1)
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_4f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_5f_GET(r) ((((r).l3_entry_hit_only[0]) >> 5) & 0x1)
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_5f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_6f_GET(r) ((((r).l3_entry_hit_only[0]) >> 6) & 0x1)
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_6f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_7f_GET(r) ((((r).l3_entry_hit_only[0]) >> 7) & 0x1)
#define BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_7f_SET(r,f) (r).l3_entry_hit_only[0]=(((r).l3_entry_hit_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L3_ENTRY_HIT_ONLY.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_HIT_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_ENTRY_HIT_ONLYm,i,(m._l3_entry_hit_only),1)
#define BCM56800_A0_WRITE_L3_ENTRY_HIT_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_ENTRY_HIT_ONLYm,i,&(m._l3_entry_hit_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_HIT_ONLYm BCM56800_A0_L3_ENTRY_HIT_ONLYm
#define L3_ENTRY_HIT_ONLYm_MIN BCM56800_A0_L3_ENTRY_HIT_ONLYm_MIN
#define L3_ENTRY_HIT_ONLYm_MAX BCM56800_A0_L3_ENTRY_HIT_ONLYm_MAX
#define L3_ENTRY_HIT_ONLYm_CMAX(u) BCM56800_A0_L3_ENTRY_HIT_ONLYm_CMAX(u)
#define L3_ENTRY_HIT_ONLYm_SIZE BCM56800_A0_L3_ENTRY_HIT_ONLYm_SIZE
typedef BCM56800_A0_L3_ENTRY_HIT_ONLYm_t L3_ENTRY_HIT_ONLYm_t;
#define L3_ENTRY_HIT_ONLYm_CLR BCM56800_A0_L3_ENTRY_HIT_ONLYm_CLR
#define L3_ENTRY_HIT_ONLYm_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_SET
#define L3_ENTRY_HIT_ONLYm_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_GET
#define L3_ENTRY_HIT_ONLYm_HIT_0f_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_0f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_0f_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_0f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_1f_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_1f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_1f_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_1f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_2f_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_2f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_2f_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_2f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_3f_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_3f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_3f_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_3f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_4f_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_4f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_4f_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_4f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_5f_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_5f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_5f_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_5f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_6f_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_6f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_6f_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_6f_SET
#define L3_ENTRY_HIT_ONLYm_HIT_7f_GET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_7f_GET
#define L3_ENTRY_HIT_ONLYm_HIT_7f_SET BCM56800_A0_L3_ENTRY_HIT_ONLYm_HIT_7f_SET
#define READ_L3_ENTRY_HIT_ONLYm BCM56800_A0_READ_L3_ENTRY_HIT_ONLYm
#define WRITE_L3_ENTRY_HIT_ONLYm BCM56800_A0_WRITE_L3_ENTRY_HIT_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_HIT_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_ENTRY_IPV4_MULTICAST
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table IPV4 MULTICAST view, FeatureSpecific-Ethernet
 * SIZE:     99
 * FIELDS:
 *     GROUP_IP_ADDR    32 bit group IP address
 *     SOURCE_IP_ADDR   32 bit source IP address
 *     V6               Indicates entry is used for an IPv6 route.  Must be zero for this view
 *     IPMC             Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID          VLAN ID bits.
 *     L3MC_INDEX       Index into the L3MC table.
 *     NEXT_HOP_INDEX_UNUSED 3 bits of NEXT_HOP_INDEX, unused for this view.
 *     RPE              RPE bit
 *     PRI              Priority
 *     DST_DISCARD      Discard the pkt on DIP match
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity for the L3_ENTRY RAM fields (i.e. excludes HIT bit)
 *     HIT              Hit bit for the entry
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm 0x08124000

#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_MIN 0
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_MAX 4095
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_CMAX(u) 4095
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_SIZE 13

/*
 * This structure should be used to declare and program L3_ENTRY_IPV4_MULTICAST.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_s {
	uint32_t v[4];
	uint32_t l3_entry_ipv4_multicast[4];
	uint32_t _l3_entry_ipv4_multicast;
} BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_t;

#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_CLR(r) CDK_MEMSET(&((r)._l3_entry_ipv4_multicast), 0, sizeof(BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_t))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_SET(r,i,d) (r).l3_entry_ipv4_multicast[i] = d
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_GET(r,i) (r).l3_entry_ipv4_multicast[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_GET(r) ((r).l3_entry_ipv4_multicast[0])
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_SET(r,f) (r).l3_entry_ipv4_multicast[0]=((uint32_t)f)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_GET(r) ((r).l3_entry_ipv4_multicast[1])
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_SET(r,f) (r).l3_entry_ipv4_multicast[1]=((uint32_t)f)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_V6f_GET(r) (((r).l3_entry_ipv4_multicast[2]) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_V6f_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_IPMCf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_IPMCf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 2) & 0xfff)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 14) & 0x3ff)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 24) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_RPEf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 27) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_RPEf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_PRIf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 28) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_PRIf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_DST_DISCARDf_GET(r) ((((r).l3_entry_ipv4_multicast[2]) >> 31) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_DST_DISCARDf_SET(r,f) (r).l3_entry_ipv4_multicast[2]=(((r).l3_entry_ipv4_multicast[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_VALIDf_GET(r) (((r).l3_entry_ipv4_multicast[3]) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_VALIDf_SET(r,f) (r).l3_entry_ipv4_multicast[3]=(((r).l3_entry_ipv4_multicast[3] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_EVEN_PARITYf_GET(r) ((((r).l3_entry_ipv4_multicast[3]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_EVEN_PARITYf_SET(r,f) (r).l3_entry_ipv4_multicast[3]=(((r).l3_entry_ipv4_multicast[3] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_HITf_GET(r) ((((r).l3_entry_ipv4_multicast[3]) >> 2) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_HITf_SET(r,f) (r).l3_entry_ipv4_multicast[3]=(((r).l3_entry_ipv4_multicast[3] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access L3_ENTRY_IPV4_MULTICAST.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_IPV4_MULTICASTm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm,i,(m._l3_entry_ipv4_multicast),4)
#define BCM56800_A0_WRITE_L3_ENTRY_IPV4_MULTICASTm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm,i,&(m._l3_entry_ipv4_multicast),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_IPV4_MULTICASTm BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm
#define L3_ENTRY_IPV4_MULTICASTm_MIN BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_MIN
#define L3_ENTRY_IPV4_MULTICASTm_MAX BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_MAX
#define L3_ENTRY_IPV4_MULTICASTm_CMAX(u) BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_CMAX(u)
#define L3_ENTRY_IPV4_MULTICASTm_SIZE BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_SIZE
typedef BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_t L3_ENTRY_IPV4_MULTICASTm_t;
#define L3_ENTRY_IPV4_MULTICASTm_CLR BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_CLR
#define L3_ENTRY_IPV4_MULTICASTm_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_SET
#define L3_ENTRY_IPV4_MULTICASTm_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_GET
#define L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_GET
#define L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_GROUP_IP_ADDRf_SET
#define L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_GET
#define L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_SOURCE_IP_ADDRf_SET
#define L3_ENTRY_IPV4_MULTICASTm_V6f_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_V6f_GET
#define L3_ENTRY_IPV4_MULTICASTm_V6f_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_V6f_SET
#define L3_ENTRY_IPV4_MULTICASTm_IPMCf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_IPMCf_GET
#define L3_ENTRY_IPV4_MULTICASTm_IPMCf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_IPMCf_SET
#define L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_GET
#define L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_VLAN_IDf_SET
#define L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_GET
#define L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_L3MC_INDEXf_SET
#define L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_GET
#define L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_NEXT_HOP_INDEX_UNUSEDf_SET
#define L3_ENTRY_IPV4_MULTICASTm_RPEf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_RPEf_GET
#define L3_ENTRY_IPV4_MULTICASTm_RPEf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_RPEf_SET
#define L3_ENTRY_IPV4_MULTICASTm_PRIf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_PRIf_GET
#define L3_ENTRY_IPV4_MULTICASTm_PRIf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_PRIf_SET
#define L3_ENTRY_IPV4_MULTICASTm_DST_DISCARDf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_DST_DISCARDf_GET
#define L3_ENTRY_IPV4_MULTICASTm_DST_DISCARDf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_DST_DISCARDf_SET
#define L3_ENTRY_IPV4_MULTICASTm_VALIDf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_VALIDf_GET
#define L3_ENTRY_IPV4_MULTICASTm_VALIDf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_VALIDf_SET
#define L3_ENTRY_IPV4_MULTICASTm_EVEN_PARITYf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_EVEN_PARITYf_GET
#define L3_ENTRY_IPV4_MULTICASTm_EVEN_PARITYf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_EVEN_PARITYf_SET
#define L3_ENTRY_IPV4_MULTICASTm_HITf_GET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_HITf_GET
#define L3_ENTRY_IPV4_MULTICASTm_HITf_SET BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm_HITf_SET
#define READ_L3_ENTRY_IPV4_MULTICASTm BCM56800_A0_READ_L3_ENTRY_IPV4_MULTICASTm
#define WRITE_L3_ENTRY_IPV4_MULTICASTm BCM56800_A0_WRITE_L3_ENTRY_IPV4_MULTICASTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_IPV4_MULTICASTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_ENTRY_IPV4_UNICAST
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table IPV4 UNICAST view, FeatureSpecific-Ethernet
 * SIZE:     99
 * FIELDS:
 *     IP_ADDR          32 bit IP address
 *     IP_ADDR_UNUSED   IP address bits not used for this view
 *     V6               Indicates entry is used for an IPv6 route.  Must be zero for this view
 *     IPMC             Indicates entry is used for an IPMC route.  Must be zero for this view
 *     VLAN_ID          VLAN ID bits.  Not used for this view.
 *     NEXT_HOP_INDEX   Index for the next hop (overlaid for IPMC packets becomes {IPMC_MTU_INDEX[2:0],L3MC_INDEX[9:0]})
 *     RPE              RPE bit
 *     PRI              Priority
 *     DST_DISCARD      Discard the pkt on DIP match
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity for the L3_ENTRY RAM fields (i.e. excludes HIT bit)
 *     HIT              Hit bit for the entry
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm 0x08123000

#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_MIN 0
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_MAX 4095
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_CMAX(u) 4095
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_SIZE 13

/*
 * This structure should be used to declare and program L3_ENTRY_IPV4_UNICAST.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_s {
	uint32_t v[4];
	uint32_t l3_entry_ipv4_unicast[4];
	uint32_t _l3_entry_ipv4_unicast;
} BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_t;

#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_CLR(r) CDK_MEMSET(&((r)._l3_entry_ipv4_unicast), 0, sizeof(BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_t))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_SET(r,i,d) (r).l3_entry_ipv4_unicast[i] = d
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_GET(r,i) (r).l3_entry_ipv4_unicast[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_GET(r) ((r).l3_entry_ipv4_unicast[0])
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_SET(r,f) (r).l3_entry_ipv4_unicast[0]=((uint32_t)f)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_GET(r) ((r).l3_entry_ipv4_unicast[1])
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_SET(r,f) (r).l3_entry_ipv4_unicast[1]=((uint32_t)f)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_V6f_GET(r) (((r).l3_entry_ipv4_unicast[2]) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_V6f_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IPMCf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IPMCf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 2) & 0xfff)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 14) & 0x1fff)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1fff << 14)) | ((((uint32_t)f) & 0x1fff) << 14))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_RPEf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 27) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_RPEf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_PRIf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 28) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_PRIf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_DST_DISCARDf_GET(r) ((((r).l3_entry_ipv4_unicast[2]) >> 31) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_DST_DISCARDf_SET(r,f) (r).l3_entry_ipv4_unicast[2]=(((r).l3_entry_ipv4_unicast[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_VALIDf_GET(r) (((r).l3_entry_ipv4_unicast[3]) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_VALIDf_SET(r,f) (r).l3_entry_ipv4_unicast[3]=(((r).l3_entry_ipv4_unicast[3] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_EVEN_PARITYf_GET(r) ((((r).l3_entry_ipv4_unicast[3]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_EVEN_PARITYf_SET(r,f) (r).l3_entry_ipv4_unicast[3]=(((r).l3_entry_ipv4_unicast[3] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_HITf_GET(r) ((((r).l3_entry_ipv4_unicast[3]) >> 2) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_HITf_SET(r,f) (r).l3_entry_ipv4_unicast[3]=(((r).l3_entry_ipv4_unicast[3] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access L3_ENTRY_IPV4_UNICAST.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_IPV4_UNICASTm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_ENTRY_IPV4_UNICASTm,i,(m._l3_entry_ipv4_unicast),4)
#define BCM56800_A0_WRITE_L3_ENTRY_IPV4_UNICASTm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_ENTRY_IPV4_UNICASTm,i,&(m._l3_entry_ipv4_unicast),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_IPV4_UNICASTm BCM56800_A0_L3_ENTRY_IPV4_UNICASTm
#define L3_ENTRY_IPV4_UNICASTm_MIN BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_MIN
#define L3_ENTRY_IPV4_UNICASTm_MAX BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_MAX
#define L3_ENTRY_IPV4_UNICASTm_CMAX(u) BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_CMAX(u)
#define L3_ENTRY_IPV4_UNICASTm_SIZE BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_SIZE
typedef BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_t L3_ENTRY_IPV4_UNICASTm_t;
#define L3_ENTRY_IPV4_UNICASTm_CLR BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_CLR
#define L3_ENTRY_IPV4_UNICASTm_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_SET
#define L3_ENTRY_IPV4_UNICASTm_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_GET
#define L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_GET
#define L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDRf_SET
#define L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_GET
#define L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IP_ADDR_UNUSEDf_SET
#define L3_ENTRY_IPV4_UNICASTm_V6f_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_V6f_GET
#define L3_ENTRY_IPV4_UNICASTm_V6f_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_V6f_SET
#define L3_ENTRY_IPV4_UNICASTm_IPMCf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IPMCf_GET
#define L3_ENTRY_IPV4_UNICASTm_IPMCf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_IPMCf_SET
#define L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_GET
#define L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_VLAN_IDf_SET
#define L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_GET
#define L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_NEXT_HOP_INDEXf_SET
#define L3_ENTRY_IPV4_UNICASTm_RPEf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_RPEf_GET
#define L3_ENTRY_IPV4_UNICASTm_RPEf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_RPEf_SET
#define L3_ENTRY_IPV4_UNICASTm_PRIf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_PRIf_GET
#define L3_ENTRY_IPV4_UNICASTm_PRIf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_PRIf_SET
#define L3_ENTRY_IPV4_UNICASTm_DST_DISCARDf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_DST_DISCARDf_GET
#define L3_ENTRY_IPV4_UNICASTm_DST_DISCARDf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_DST_DISCARDf_SET
#define L3_ENTRY_IPV4_UNICASTm_VALIDf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_VALIDf_GET
#define L3_ENTRY_IPV4_UNICASTm_VALIDf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_VALIDf_SET
#define L3_ENTRY_IPV4_UNICASTm_EVEN_PARITYf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_EVEN_PARITYf_GET
#define L3_ENTRY_IPV4_UNICASTm_EVEN_PARITYf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_EVEN_PARITYf_SET
#define L3_ENTRY_IPV4_UNICASTm_HITf_GET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_HITf_GET
#define L3_ENTRY_IPV4_UNICASTm_HITf_SET BCM56800_A0_L3_ENTRY_IPV4_UNICASTm_HITf_SET
#define READ_L3_ENTRY_IPV4_UNICASTm BCM56800_A0_READ_L3_ENTRY_IPV4_UNICASTm
#define WRITE_L3_ENTRY_IPV4_UNICASTm BCM56800_A0_WRITE_L3_ENTRY_IPV4_UNICASTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_IPV4_UNICASTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_ENTRY_IPV6_MULTICAST
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table IPV6 MULTICAST view, FeatureSpecific-Ethernet
 * SIZE:     396
 * FIELDS:
 *     GROUP_IP_ADDR_LWR_64 Lower 64 bits of the Group IP addrs.
 *     V6_0             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_0           Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID_0        VLAN ID bits.  Same as the other 3 VLAN_ID fields in this view.
 *     L3MC_INDEX_0     Index into the L3MC table.  Same as the other 3 L3MC_INDEX fields.
 *     NEXT_HOP_INDEX_UNUSED_0 3 bits of NEXT_HOP_INDEX, unused for this view.
 *     RPE_0            RPE bit.  Same as the other RPE fields.
 *     PRI_0            Priority.  Same as the other PRI fields.
 *     DST_DISCARD_0    Discard the pkt on DIP match
 *     VALID_0          Indicates that the entry is valid.  Same as the other VALID fields.
 *     EVEN_PARITY_0    Even parity for the L3_ENTRY RAM fields entry 0 (i.e. excludes HIT bit)
 *     GROUP_IP_ADDR_UPR_56 Lower 64 bits of the Group IP addrs.
 *     GROUP_IP_ADDR_UNUSED IP address bits that are unused for this view.
 *     V6_1             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_1           Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID_1        VLAN ID bits.  Same as the other 3 VLAN_ID fields in this view.
 *     L3MC_INDEX_1     Index into the L3MC table.  Same as the other 3 L3MC_INDEX fields.
 *     NEXT_HOP_INDEX_UNUSED_1 3 bits of NEXT_HOP_INDEX, unused for this view.
 *     RPE_1            RPE bit.  Same as the other RPE fields.
 *     PRI_1            Priority.  Same as the other PRI fields.
 *     DST_DISCARD_1    Discard the pkt on DIP match
 *     VALID_1          Indicates that the entry is valid.  Same as the other VALID fields.
 *     EVEN_PARITY_1    Even parity for the L3_ENTRY RAM fields entry 1 (i.e. excludes HIT bit)
 *     SOURCE_IP_ADDR_LWR_64 Lower 64 bits of the Source IP addrs.
 *     V6_2             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_2           Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID_2        VLAN ID bits.  Same as the other 3 VLAN_ID fields in this view.
 *     L3MC_INDEX_2     Index into the L3MC table.  Same as the other 3 L3MC_INDEX fields.
 *     NEXT_HOP_INDEX_UNUSED_2 3 bits of NEXT_HOP_INDEX, unused for this view.
 *     RPE_2            RPE bit.  Same as the other RPE fields.
 *     PRI_2            Priority.  Same as the other PRI fields.
 *     DST_DISCARD_2    Discard the pkt on DIP match
 *     VALID_2          Indicates that the entry is valid.  Same as the other VALID fields.
 *     EVEN_PARITY_2    Even parity for the L3_ENTRY RAM fields entry 2 (i.e. excludes HIT bit)
 *     SOURCE_IP_ADDR_UPR_64 Upper 64 bits of the Source IP addrs.
 *     V6_3             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_3           Indicates entry is used for an IPMC route.  Must be 1 for this view
 *     VLAN_ID_3        VLAN ID bits.  Same as the other 3 VLAN_ID fields in this view.
 *     L3MC_INDEX_3     Index into the L3MC table.  Same as the other 3 L3MC_INDEX fields.
 *     NEXT_HOP_INDEX_UNUSED_3 3 bits of NEXT_HOP_INDEX, unused for this view.
 *     RPE_3            RPE bit.  Same as the other RPE fields.
 *     PRI_3            Priority.  Same as the other PRI fields.
 *     DST_DISCARD_3    Discard the pkt on DIP match
 *     VALID_3          Indicates that the entry is valid.  Same as the other VALID fields.
 *     EVEN_PARITY_3    Even parity for the L3_ENTRY RAM fields entry 3 (i.e. excludes HIT bit)
 *     HIT_0            Indicates that the entry is valid.
 *     HIT_1            Indicates that the entry is valid.  Same value as HIT_0.
 *     HIT_2            Indicates that the entry is valid.  Same value as HIT_0.
 *     HIT_3            Indicates that the entry is valid.  Same value as HIT_0.
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm 0x08126000

#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_MIN 0
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_MAX 1023
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_CMAX(u) 1023
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SIZE 50

/*
 * This structure should be used to declare and program L3_ENTRY_IPV6_MULTICAST.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_s {
	uint32_t v[13];
	uint32_t l3_entry_ipv6_multicast[13];
	uint32_t _l3_entry_ipv6_multicast;
} BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_t;

#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_CLR(r) CDK_MEMSET(&((r)._l3_entry_ipv6_multicast), 0, sizeof(BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_t))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SET(r,i,d) (r).l3_entry_ipv6_multicast[i] = d
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GET(r,i) (r).l3_entry_ipv6_multicast[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_multicast,0,63,a)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_multicast,0,63,a)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_0f_GET(r) (((r).l3_entry_ipv6_multicast[2]) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 2) & 0xfff)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 14) & 0x3ff)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 24) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 27) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 28) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_0f_GET(r) ((((r).l3_entry_ipv6_multicast[2]) >> 31) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_0f_SET(r,f) (r).l3_entry_ipv6_multicast[2]=(((r).l3_entry_ipv6_multicast[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_0f_GET(r) (((r).l3_entry_ipv6_multicast[3]) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_0f_SET(r,f) (r).l3_entry_ipv6_multicast[3]=(((r).l3_entry_ipv6_multicast[3] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_0f_GET(r) ((((r).l3_entry_ipv6_multicast[3]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_0f_SET(r,f) (r).l3_entry_ipv6_multicast[3]=(((r).l3_entry_ipv6_multicast[3] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_multicast,98,153,a)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_multicast,98,153,a)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_GET(r) cdk_field32_get((r).l3_entry_ipv6_multicast,154,161)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_SET(r,f) cdk_field32_set((r).l3_entry_ipv6_multicast,154,161,f)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 2) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 3) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 4) & 0xfff)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 16) & 0x3ff)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x3ff << 16)) | ((((uint32_t)f) & 0x3ff) << 16))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 26) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x7 << 26)) | ((((uint32_t)f) & 0x7) << 26))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_1f_GET(r) ((((r).l3_entry_ipv6_multicast[5]) >> 29) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_1f_SET(r,f) (r).l3_entry_ipv6_multicast[5]=(((r).l3_entry_ipv6_multicast[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_1f_GET(r) cdk_field32_get((r).l3_entry_ipv6_multicast,190,192)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_1f_SET(r,f) cdk_field32_set((r).l3_entry_ipv6_multicast,190,192,f)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_1f_GET(r) ((((r).l3_entry_ipv6_multicast[6]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_1f_SET(r,f) (r).l3_entry_ipv6_multicast[6]=(((r).l3_entry_ipv6_multicast[6] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_1f_GET(r) ((((r).l3_entry_ipv6_multicast[6]) >> 2) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_1f_SET(r,f) (r).l3_entry_ipv6_multicast[6]=(((r).l3_entry_ipv6_multicast[6] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_1f_GET(r) ((((r).l3_entry_ipv6_multicast[6]) >> 3) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_1f_SET(r,f) (r).l3_entry_ipv6_multicast[6]=(((r).l3_entry_ipv6_multicast[6] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_multicast,196,259,a)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_multicast,196,259,a)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 4) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 5) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 6) & 0xfff)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 18) & 0x3ff)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x3ff << 18)) | ((((uint32_t)f) & 0x3ff) << 18))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 28) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_2f_GET(r) ((((r).l3_entry_ipv6_multicast[8]) >> 31) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_2f_SET(r,f) (r).l3_entry_ipv6_multicast[8]=(((r).l3_entry_ipv6_multicast[8] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_2f_GET(r) (((r).l3_entry_ipv6_multicast[9]) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_2f_SET(r,f) (r).l3_entry_ipv6_multicast[9]=(((r).l3_entry_ipv6_multicast[9] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_2f_GET(r) ((((r).l3_entry_ipv6_multicast[9]) >> 3) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_2f_SET(r,f) (r).l3_entry_ipv6_multicast[9]=(((r).l3_entry_ipv6_multicast[9] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_2f_GET(r) ((((r).l3_entry_ipv6_multicast[9]) >> 4) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_2f_SET(r,f) (r).l3_entry_ipv6_multicast[9]=(((r).l3_entry_ipv6_multicast[9] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_2f_GET(r) ((((r).l3_entry_ipv6_multicast[9]) >> 5) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_2f_SET(r,f) (r).l3_entry_ipv6_multicast[9]=(((r).l3_entry_ipv6_multicast[9] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_multicast,294,357,a)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_multicast,294,357,a)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 6) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 7) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 8) & 0xfff)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_GET(r) ((((r).l3_entry_ipv6_multicast[11]) >> 20) & 0x3ff)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_SET(r,f) (r).l3_entry_ipv6_multicast[11]=(((r).l3_entry_ipv6_multicast[11] & ~((uint32_t)0x3ff << 20)) | ((((uint32_t)f) & 0x3ff) << 20))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_GET(r) cdk_field32_get((r).l3_entry_ipv6_multicast,382,384)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_SET(r,f) cdk_field32_set((r).l3_entry_ipv6_multicast,382,384,f)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_3f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_3f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_3f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 2) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_3f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_3f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 5) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_3f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_3f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 6) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_3f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_3f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 7) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_3f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_0f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 8) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_0f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_1f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 9) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_1f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_2f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 10) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_2f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_3f_GET(r) ((((r).l3_entry_ipv6_multicast[12]) >> 11) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_3f_SET(r,f) (r).l3_entry_ipv6_multicast[12]=(((r).l3_entry_ipv6_multicast[12] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access L3_ENTRY_IPV6_MULTICAST.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_IPV6_MULTICASTm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm,i,(m._l3_entry_ipv6_multicast),13)
#define BCM56800_A0_WRITE_L3_ENTRY_IPV6_MULTICASTm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm,i,&(m._l3_entry_ipv6_multicast),13)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_IPV6_MULTICASTm BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm
#define L3_ENTRY_IPV6_MULTICASTm_MIN BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_MIN
#define L3_ENTRY_IPV6_MULTICASTm_MAX BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_MAX
#define L3_ENTRY_IPV6_MULTICASTm_CMAX(u) BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_CMAX(u)
#define L3_ENTRY_IPV6_MULTICASTm_SIZE BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SIZE
typedef BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_t L3_ENTRY_IPV6_MULTICASTm_t;
#define L3_ENTRY_IPV6_MULTICASTm_CLR BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_CLR
#define L3_ENTRY_IPV6_MULTICASTm_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SET
#define L3_ENTRY_IPV6_MULTICASTm_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_GET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_LWR_64f_SET
#define L3_ENTRY_IPV6_MULTICASTm_V6_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_V6_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_GET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UPR_56f_SET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_GET
#define L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_GROUP_IP_ADDR_UNUSEDf_SET
#define L3_ENTRY_IPV6_MULTICASTm_V6_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_V6_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_GET
#define L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_LWR_64f_SET
#define L3_ENTRY_IPV6_MULTICASTm_V6_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_V6_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_GET
#define L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_SOURCE_IP_ADDR_UPR_64f_SET
#define L3_ENTRY_IPV6_MULTICASTm_V6_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_V6_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_V6_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_IPMC_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VLAN_ID_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_L3MC_INDEX_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_NEXT_HOP_INDEX_UNUSED_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_RPE_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_RPE_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_PRI_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_PRI_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_DST_DISCARD_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_VALID_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_VALID_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_EVEN_PARITY_3f_SET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_0f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_0f_GET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_0f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_0f_SET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_1f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_1f_GET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_1f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_1f_SET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_2f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_2f_GET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_2f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_2f_SET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_3f_GET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_3f_GET
#define L3_ENTRY_IPV6_MULTICASTm_HIT_3f_SET BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm_HIT_3f_SET
#define READ_L3_ENTRY_IPV6_MULTICASTm BCM56800_A0_READ_L3_ENTRY_IPV6_MULTICASTm
#define WRITE_L3_ENTRY_IPV6_MULTICASTm BCM56800_A0_WRITE_L3_ENTRY_IPV6_MULTICASTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_IPV6_MULTICASTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_ENTRY_IPV6_UNICAST
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table IPV6 UNICAST view, FeatureSpecific-Ethernet
 * SIZE:     198
 * FIELDS:
 *     IP_ADDR_LWR_64   Lower 64 bits of the IP address
 *     V6_0             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_0           Indicates entry is used for an IPMC route.  Must be zero for this view
 *     VLAN_ID_UNUSED_0 VLAN ID bits.  Not used for this view.
 *     NEXT_HOP_INDEX_0 Index for the next hop.  Same value as NEXT_HOP_INDEX_1.
 *     RPE_0            RPE bit.  Same value as RPE_1.
 *     PRI_0            Priority.  Same value as RPE_1.
 *     DST_DISCARD_0    Discard the pkt on DIP match
 *     VALID_0          Indicates that the entry is valid.  Same value as VALID_1.
 *     EVEN_PARITY_0    Even parity for the L3_ENTRY RAM fields entry 0 (i.e. excludes HIT bit)
 *     IP_ADDR_UPR_64   Upper 64 bits of the IP address
 *     V6_1             Indicates entry is used for an IPv6 route.  Must be 1 for this view
 *     IPMC_1           Indicates entry is used for an IPMC route.  Must be zero for this view
 *     VLAN_ID_UNUSED_1 VLAN ID bits.  Not used for this view.
 *     NEXT_HOP_INDEX_1 Index for the next hop.  Same value as NEXT_HOP_INDEX_0.
 *     RPE_1            RPE bit.  Same value as RPE_0.
 *     PRI_1            Priority.  Same value as RPE_0.
 *     DST_DISCARD_1    Discard the pkt on DIP match
 *     VALID_1          Indicates that the entry is valid.  Same value as VALID_0.
 *     EVEN_PARITY_1    Even parity for the L3_ENTRY RAM fields entry 1 (i.e. excludes HIT bit)
 *     HIT_0            Indicates that the entry is valid.  Same value as HIT_1.
 *     HIT_1            Indicates that the entry is valid.  Same value as HIT_0.
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm 0x08125000

#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_MIN 0
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_MAX 2047
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_CMAX(u) 2047
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_SIZE 25

/*
 * This structure should be used to declare and program L3_ENTRY_IPV6_UNICAST.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_s {
	uint32_t v[7];
	uint32_t l3_entry_ipv6_unicast[7];
	uint32_t _l3_entry_ipv6_unicast;
} BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_t;

#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_CLR(r) CDK_MEMSET(&((r)._l3_entry_ipv6_unicast), 0, sizeof(BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_t))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_SET(r,i,d) (r).l3_entry_ipv6_unicast[i] = d
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_GET(r,i) (r).l3_entry_ipv6_unicast[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_unicast,0,63,a)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_unicast,0,63,a)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_V6_0f_GET(r) (((r).l3_entry_ipv6_unicast[2]) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_V6_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 2) & 0xfff)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 14) & 0x1fff)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1fff << 14)) | ((((uint32_t)f) & 0x1fff) << 14))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_RPE_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 27) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_RPE_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_PRI_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 28) & 0x7)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_PRI_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_0f_GET(r) ((((r).l3_entry_ipv6_unicast[2]) >> 31) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_0f_SET(r,f) (r).l3_entry_ipv6_unicast[2]=(((r).l3_entry_ipv6_unicast[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VALID_0f_GET(r) (((r).l3_entry_ipv6_unicast[3]) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VALID_0f_SET(r,f) (r).l3_entry_ipv6_unicast[3]=(((r).l3_entry_ipv6_unicast[3] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_0f_GET(r) ((((r).l3_entry_ipv6_unicast[3]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_0f_SET(r,f) (r).l3_entry_ipv6_unicast[3]=(((r).l3_entry_ipv6_unicast[3] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_GET(r,a) cdk_field_get((r).l3_entry_ipv6_unicast,98,161,a)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_SET(r,a) cdk_field_set((r).l3_entry_ipv6_unicast,98,161,a)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_V6_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 2) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_V6_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 3) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 4) & 0xfff)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 16) & 0x1fff)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1fff << 16)) | ((((uint32_t)f) & 0x1fff) << 16))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_RPE_1f_GET(r) ((((r).l3_entry_ipv6_unicast[5]) >> 29) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_RPE_1f_SET(r,f) (r).l3_entry_ipv6_unicast[5]=(((r).l3_entry_ipv6_unicast[5] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_PRI_1f_GET(r) cdk_field32_get((r).l3_entry_ipv6_unicast,190,192)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_PRI_1f_SET(r,f) cdk_field32_set((r).l3_entry_ipv6_unicast,190,192,f)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_1f_GET(r) ((((r).l3_entry_ipv6_unicast[6]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_1f_SET(r,f) (r).l3_entry_ipv6_unicast[6]=(((r).l3_entry_ipv6_unicast[6] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VALID_1f_GET(r) ((((r).l3_entry_ipv6_unicast[6]) >> 2) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VALID_1f_SET(r,f) (r).l3_entry_ipv6_unicast[6]=(((r).l3_entry_ipv6_unicast[6] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_1f_GET(r) ((((r).l3_entry_ipv6_unicast[6]) >> 3) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_1f_SET(r,f) (r).l3_entry_ipv6_unicast[6]=(((r).l3_entry_ipv6_unicast[6] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_HIT_0f_GET(r) ((((r).l3_entry_ipv6_unicast[6]) >> 4) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_HIT_0f_SET(r,f) (r).l3_entry_ipv6_unicast[6]=(((r).l3_entry_ipv6_unicast[6] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_HIT_1f_GET(r) ((((r).l3_entry_ipv6_unicast[6]) >> 5) & 0x1)
#define BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_HIT_1f_SET(r,f) (r).l3_entry_ipv6_unicast[6]=(((r).l3_entry_ipv6_unicast[6] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access L3_ENTRY_IPV6_UNICAST.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_IPV6_UNICASTm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_ENTRY_IPV6_UNICASTm,i,(m._l3_entry_ipv6_unicast),7)
#define BCM56800_A0_WRITE_L3_ENTRY_IPV6_UNICASTm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_ENTRY_IPV6_UNICASTm,i,&(m._l3_entry_ipv6_unicast),7)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_IPV6_UNICASTm BCM56800_A0_L3_ENTRY_IPV6_UNICASTm
#define L3_ENTRY_IPV6_UNICASTm_MIN BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_MIN
#define L3_ENTRY_IPV6_UNICASTm_MAX BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_MAX
#define L3_ENTRY_IPV6_UNICASTm_CMAX(u) BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_CMAX(u)
#define L3_ENTRY_IPV6_UNICASTm_SIZE BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_SIZE
typedef BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_t L3_ENTRY_IPV6_UNICASTm_t;
#define L3_ENTRY_IPV6_UNICASTm_CLR BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_CLR
#define L3_ENTRY_IPV6_UNICASTm_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_SET
#define L3_ENTRY_IPV6_UNICASTm_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_GET
#define L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_GET
#define L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_LWR_64f_SET
#define L3_ENTRY_IPV6_UNICASTm_V6_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_V6_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_V6_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_V6_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_IPMC_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_IPMC_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_RPE_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_RPE_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_RPE_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_RPE_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_PRI_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_PRI_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_PRI_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_PRI_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_VALID_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VALID_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_VALID_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VALID_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_GET
#define L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IP_ADDR_UPR_64f_SET
#define L3_ENTRY_IPV6_UNICASTm_V6_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_V6_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_V6_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_V6_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_IPMC_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_IPMC_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_IPMC_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VLAN_ID_UNUSED_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_NEXT_HOP_INDEX_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_RPE_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_RPE_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_RPE_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_RPE_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_PRI_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_PRI_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_PRI_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_PRI_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_DST_DISCARD_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_VALID_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VALID_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_VALID_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_VALID_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_EVEN_PARITY_1f_SET
#define L3_ENTRY_IPV6_UNICASTm_HIT_0f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_HIT_0f_GET
#define L3_ENTRY_IPV6_UNICASTm_HIT_0f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_HIT_0f_SET
#define L3_ENTRY_IPV6_UNICASTm_HIT_1f_GET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_HIT_1f_GET
#define L3_ENTRY_IPV6_UNICASTm_HIT_1f_SET BCM56800_A0_L3_ENTRY_IPV6_UNICASTm_HIT_1f_SET
#define READ_L3_ENTRY_IPV6_UNICASTm BCM56800_A0_READ_L3_ENTRY_IPV6_UNICASTm
#define WRITE_L3_ENTRY_IPV6_UNICASTm BCM56800_A0_WRITE_L3_ENTRY_IPV6_UNICASTm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_IPV6_UNICASTm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_ENTRY_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table with fb_regs arch view.  No hit bits, FeatureSpecific-Ethernet
 * SIZE:     98
 * FIELDS:
 *     IP_ADDR          64 bits of IP address
 *     V6               Indicates entry is used for an IPv6 route.  Must be zero for this view
 *     IPMC             Indicates entry is used for an IPMC route.  Must be zero for this view
 *     VLAN_ID          VLAN ID bits.  Not used for this view.
 *     NEXT_HOP_INDEX   Index for the next hop
 *     RPE              RPE bit
 *     PRI              Priority
 *     DST_DISCARD      Discard the pkt on DIP match
 *     VALID            Indicates that the entry is valid
 *     EVEN_PARITY      Even parity for the L3_ENTRY RAM fields (i.e. excludes HIT bits)
 *     L3MC_INDEX       Overlay for L3 MC index
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_ONLYm 0x08122000

#define BCM56800_A0_L3_ENTRY_ONLYm_MIN 0
#define BCM56800_A0_L3_ENTRY_ONLYm_MAX 4095
#define BCM56800_A0_L3_ENTRY_ONLYm_CMAX(u) 4095
#define BCM56800_A0_L3_ENTRY_ONLYm_SIZE 13

/*
 * This structure should be used to declare and program L3_ENTRY_ONLY.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_ONLYm_s {
	uint32_t v[4];
	uint32_t l3_entry_only[4];
	uint32_t _l3_entry_only;
} BCM56800_A0_L3_ENTRY_ONLYm_t;

#define BCM56800_A0_L3_ENTRY_ONLYm_CLR(r) CDK_MEMSET(&((r)._l3_entry_only), 0, sizeof(BCM56800_A0_L3_ENTRY_ONLYm_t))
#define BCM56800_A0_L3_ENTRY_ONLYm_SET(r,i,d) (r).l3_entry_only[i] = d
#define BCM56800_A0_L3_ENTRY_ONLYm_GET(r,i) (r).l3_entry_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_ONLYm_IP_ADDRf_GET(r,a) cdk_field_get((r).l3_entry_only,0,63,a)
#define BCM56800_A0_L3_ENTRY_ONLYm_IP_ADDRf_SET(r,a) cdk_field_set((r).l3_entry_only,0,63,a)
#define BCM56800_A0_L3_ENTRY_ONLYm_V6f_GET(r) (((r).l3_entry_only[2]) & 0x1)
#define BCM56800_A0_L3_ENTRY_ONLYm_V6f_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_ONLYm_IPMCf_GET(r) ((((r).l3_entry_only[2]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_ONLYm_IPMCf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_ONLYm_VLAN_IDf_GET(r) ((((r).l3_entry_only[2]) >> 2) & 0xfff)
#define BCM56800_A0_L3_ENTRY_ONLYm_VLAN_IDf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2))
#define BCM56800_A0_L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_GET(r) ((((r).l3_entry_only[2]) >> 14) & 0x1fff)
#define BCM56800_A0_L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1fff << 14)) | ((((uint32_t)f) & 0x1fff) << 14))
#define BCM56800_A0_L3_ENTRY_ONLYm_RPEf_GET(r) ((((r).l3_entry_only[2]) >> 27) & 0x1)
#define BCM56800_A0_L3_ENTRY_ONLYm_RPEf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_L3_ENTRY_ONLYm_PRIf_GET(r) ((((r).l3_entry_only[2]) >> 28) & 0x7)
#define BCM56800_A0_L3_ENTRY_ONLYm_PRIf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_L3_ENTRY_ONLYm_DST_DISCARDf_GET(r) ((((r).l3_entry_only[2]) >> 31) & 0x1)
#define BCM56800_A0_L3_ENTRY_ONLYm_DST_DISCARDf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_L3_ENTRY_ONLYm_VALIDf_GET(r) (((r).l3_entry_only[3]) & 0x1)
#define BCM56800_A0_L3_ENTRY_ONLYm_VALIDf_SET(r,f) (r).l3_entry_only[3]=(((r).l3_entry_only[3] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_ONLYm_EVEN_PARITYf_GET(r) ((((r).l3_entry_only[3]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_ONLYm_EVEN_PARITYf_SET(r,f) (r).l3_entry_only[3]=(((r).l3_entry_only[3] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_ONLYm_L3MC_INDEXf_GET(r) ((((r).l3_entry_only[2]) >> 14) & 0x3ff)
#define BCM56800_A0_L3_ENTRY_ONLYm_L3MC_INDEXf_SET(r,f) (r).l3_entry_only[2]=(((r).l3_entry_only[2] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))

/*
 * These macros can be used to access L3_ENTRY_ONLY.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_ENTRY_ONLYm,i,(m._l3_entry_only),4)
#define BCM56800_A0_WRITE_L3_ENTRY_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_ENTRY_ONLYm,i,&(m._l3_entry_only),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_ONLYm BCM56800_A0_L3_ENTRY_ONLYm
#define L3_ENTRY_ONLYm_MIN BCM56800_A0_L3_ENTRY_ONLYm_MIN
#define L3_ENTRY_ONLYm_MAX BCM56800_A0_L3_ENTRY_ONLYm_MAX
#define L3_ENTRY_ONLYm_CMAX(u) BCM56800_A0_L3_ENTRY_ONLYm_CMAX(u)
#define L3_ENTRY_ONLYm_SIZE BCM56800_A0_L3_ENTRY_ONLYm_SIZE
typedef BCM56800_A0_L3_ENTRY_ONLYm_t L3_ENTRY_ONLYm_t;
#define L3_ENTRY_ONLYm_CLR BCM56800_A0_L3_ENTRY_ONLYm_CLR
#define L3_ENTRY_ONLYm_SET BCM56800_A0_L3_ENTRY_ONLYm_SET
#define L3_ENTRY_ONLYm_GET BCM56800_A0_L3_ENTRY_ONLYm_GET
#define L3_ENTRY_ONLYm_IP_ADDRf_GET BCM56800_A0_L3_ENTRY_ONLYm_IP_ADDRf_GET
#define L3_ENTRY_ONLYm_IP_ADDRf_SET BCM56800_A0_L3_ENTRY_ONLYm_IP_ADDRf_SET
#define L3_ENTRY_ONLYm_V6f_GET BCM56800_A0_L3_ENTRY_ONLYm_V6f_GET
#define L3_ENTRY_ONLYm_V6f_SET BCM56800_A0_L3_ENTRY_ONLYm_V6f_SET
#define L3_ENTRY_ONLYm_IPMCf_GET BCM56800_A0_L3_ENTRY_ONLYm_IPMCf_GET
#define L3_ENTRY_ONLYm_IPMCf_SET BCM56800_A0_L3_ENTRY_ONLYm_IPMCf_SET
#define L3_ENTRY_ONLYm_VLAN_IDf_GET BCM56800_A0_L3_ENTRY_ONLYm_VLAN_IDf_GET
#define L3_ENTRY_ONLYm_VLAN_IDf_SET BCM56800_A0_L3_ENTRY_ONLYm_VLAN_IDf_SET
#define L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_GET BCM56800_A0_L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_GET
#define L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_SET BCM56800_A0_L3_ENTRY_ONLYm_NEXT_HOP_INDEXf_SET
#define L3_ENTRY_ONLYm_RPEf_GET BCM56800_A0_L3_ENTRY_ONLYm_RPEf_GET
#define L3_ENTRY_ONLYm_RPEf_SET BCM56800_A0_L3_ENTRY_ONLYm_RPEf_SET
#define L3_ENTRY_ONLYm_PRIf_GET BCM56800_A0_L3_ENTRY_ONLYm_PRIf_GET
#define L3_ENTRY_ONLYm_PRIf_SET BCM56800_A0_L3_ENTRY_ONLYm_PRIf_SET
#define L3_ENTRY_ONLYm_DST_DISCARDf_GET BCM56800_A0_L3_ENTRY_ONLYm_DST_DISCARDf_GET
#define L3_ENTRY_ONLYm_DST_DISCARDf_SET BCM56800_A0_L3_ENTRY_ONLYm_DST_DISCARDf_SET
#define L3_ENTRY_ONLYm_VALIDf_GET BCM56800_A0_L3_ENTRY_ONLYm_VALIDf_GET
#define L3_ENTRY_ONLYm_VALIDf_SET BCM56800_A0_L3_ENTRY_ONLYm_VALIDf_SET
#define L3_ENTRY_ONLYm_EVEN_PARITYf_GET BCM56800_A0_L3_ENTRY_ONLYm_EVEN_PARITYf_GET
#define L3_ENTRY_ONLYm_EVEN_PARITYf_SET BCM56800_A0_L3_ENTRY_ONLYm_EVEN_PARITYf_SET
#define L3_ENTRY_ONLYm_L3MC_INDEXf_GET BCM56800_A0_L3_ENTRY_ONLYm_L3MC_INDEXf_GET
#define L3_ENTRY_ONLYm_L3MC_INDEXf_SET BCM56800_A0_L3_ENTRY_ONLYm_L3MC_INDEXf_SET
#define READ_L3_ENTRY_ONLYm BCM56800_A0_READ_L3_ENTRY_ONLYm
#define WRITE_L3_ENTRY_ONLYm BCM56800_A0_WRITE_L3_ENTRY_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_ENTRY_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     L3_ENTRY_PARITY_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and BUCKET_IDX/ENTRY_BM are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the L3_ENTRY table.
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr 0x0818020c

#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program L3_ENTRY_PARITY_CONTROL.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t l3_entry_parity_control[1];
	uint32_t _l3_entry_parity_control;
} BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_t;

#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_CLR(r) (r).l3_entry_parity_control[0] = 0
#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_SET(r,d) (r).l3_entry_parity_control[0] = d
#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_GET(r) (r).l3_entry_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).l3_entry_parity_control[0]) & 0x1)
#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).l3_entry_parity_control[0]=(((r).l3_entry_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).l3_entry_parity_control[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).l3_entry_parity_control[0]=(((r).l3_entry_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_ENTRY_PARITY_CONTROL.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_ENTRY_PARITY_CONTROLr,(r._l3_entry_parity_control))
#define BCM56800_A0_WRITE_L3_ENTRY_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_ENTRY_PARITY_CONTROLr,&(r._l3_entry_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_PARITY_CONTROLr BCM56800_A0_L3_ENTRY_PARITY_CONTROLr
#define L3_ENTRY_PARITY_CONTROLr_SIZE BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_SIZE
typedef BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_t L3_ENTRY_PARITY_CONTROLr_t;
#define L3_ENTRY_PARITY_CONTROLr_CLR BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_CLR
#define L3_ENTRY_PARITY_CONTROLr_SET BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_SET
#define L3_ENTRY_PARITY_CONTROLr_GET BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_GET
#define L3_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define L3_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define L3_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_PARITY_ENf_GET
#define L3_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET BCM56800_A0_L3_ENTRY_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_L3_ENTRY_PARITY_CONTROLr BCM56800_A0_READ_L3_ENTRY_PARITY_CONTROLr
#define WRITE_L3_ENTRY_PARITY_CONTROLr BCM56800_A0_WRITE_L3_ENTRY_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_ENTRY_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_ENTRY_PARITY_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ENTRY_BM         This bitmap indicates the entries that had parity errors.  Bits 7..0 correspond to entries 7..0.
 *     BUCKET_IDX       This field indicates the index to the bucket in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr 0x0818020d

#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_ENTRY_PARITY_STATUS.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_entry_parity_status[1];
	uint32_t _l3_entry_parity_status;
} BCM56800_A0_L3_ENTRY_PARITY_STATUSr_t;

#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_CLR(r) (r).l3_entry_parity_status[0] = 0
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_SET(r,d) (r).l3_entry_parity_status[0] = d
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_GET(r) (r).l3_entry_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).l3_entry_parity_status[0]) & 0x1)
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).l3_entry_parity_status[0]=(((r).l3_entry_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET(r) ((((r).l3_entry_parity_status[0]) >> 1) & 0xff)
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET(r,f) (r).l3_entry_parity_status[0]=(((r).l3_entry_parity_status[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1))
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET(r) ((((r).l3_entry_parity_status[0]) >> 9) & 0x1ff)
#define BCM56800_A0_L3_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET(r,f) (r).l3_entry_parity_status[0]=(((r).l3_entry_parity_status[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))

/*
 * These macros can be used to access L3_ENTRY_PARITY_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_ENTRY_PARITY_STATUSr,(r._l3_entry_parity_status))
#define BCM56800_A0_WRITE_L3_ENTRY_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_ENTRY_PARITY_STATUSr,&(r._l3_entry_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_PARITY_STATUSr BCM56800_A0_L3_ENTRY_PARITY_STATUSr
#define L3_ENTRY_PARITY_STATUSr_SIZE BCM56800_A0_L3_ENTRY_PARITY_STATUSr_SIZE
typedef BCM56800_A0_L3_ENTRY_PARITY_STATUSr_t L3_ENTRY_PARITY_STATUSr_t;
#define L3_ENTRY_PARITY_STATUSr_CLR BCM56800_A0_L3_ENTRY_PARITY_STATUSr_CLR
#define L3_ENTRY_PARITY_STATUSr_SET BCM56800_A0_L3_ENTRY_PARITY_STATUSr_SET
#define L3_ENTRY_PARITY_STATUSr_GET BCM56800_A0_L3_ENTRY_PARITY_STATUSr_GET
#define L3_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET BCM56800_A0_L3_ENTRY_PARITY_STATUSr_PARITY_ERRf_GET
#define L3_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET BCM56800_A0_L3_ENTRY_PARITY_STATUSr_PARITY_ERRf_SET
#define L3_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET BCM56800_A0_L3_ENTRY_PARITY_STATUSr_ENTRY_BMf_GET
#define L3_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET BCM56800_A0_L3_ENTRY_PARITY_STATUSr_ENTRY_BMf_SET
#define L3_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET BCM56800_A0_L3_ENTRY_PARITY_STATUSr_BUCKET_IDXf_GET
#define L3_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET BCM56800_A0_L3_ENTRY_PARITY_STATUSr_BUCKET_IDXf_SET
#define READ_L3_ENTRY_PARITY_STATUSr BCM56800_A0_READ_L3_ENTRY_PARITY_STATUSr
#define WRITE_L3_ENTRY_PARITY_STATUSr BCM56800_A0_WRITE_L3_ENTRY_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_ENTRY_VALID_ONLY
 * BLOCKS:   IPIPE
 * DESC:     L3 routing table Valid Bits only view.  Organized into buckets. FeatureSpecific-Ethernet
 * SIZE:     8
 * FIELDS:
 *     VALID_0          Indicates that the entry is valid.
 *     VALID_1          Indicates that the entry is valid.
 *     VALID_2          Indicates that the entry is valid.
 *     VALID_3          Indicates that the entry is valid.
 *     VALID_4          Indicates that the entry is valid.
 *     VALID_5          Indicates that the entry is valid.
 *     VALID_6          Indicates that the entry is valid.
 *     VALID_7          Indicates that the entry is valid.
 *
 ******************************************************************************/
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm 0x08127000

#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_MIN 0
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_MAX 511
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_CMAX(u) 511
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_SIZE 1

/*
 * This structure should be used to declare and program L3_ENTRY_VALID_ONLY.
 *
 */
typedef union BCM56800_A0_L3_ENTRY_VALID_ONLYm_s {
	uint32_t v[1];
	uint32_t l3_entry_valid_only[1];
	uint32_t _l3_entry_valid_only;
} BCM56800_A0_L3_ENTRY_VALID_ONLYm_t;

#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_CLR(r) (r).l3_entry_valid_only[0] = 0
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_SET(r,d) (r).l3_entry_valid_only[0] = d
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_GET(r) (r).l3_entry_valid_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_0f_GET(r) (((r).l3_entry_valid_only[0]) & 0x1)
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_0f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_1f_GET(r) ((((r).l3_entry_valid_only[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_1f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_2f_GET(r) ((((r).l3_entry_valid_only[0]) >> 2) & 0x1)
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_2f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_3f_GET(r) ((((r).l3_entry_valid_only[0]) >> 3) & 0x1)
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_3f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_4f_GET(r) ((((r).l3_entry_valid_only[0]) >> 4) & 0x1)
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_4f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_5f_GET(r) ((((r).l3_entry_valid_only[0]) >> 5) & 0x1)
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_5f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_6f_GET(r) ((((r).l3_entry_valid_only[0]) >> 6) & 0x1)
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_6f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_7f_GET(r) ((((r).l3_entry_valid_only[0]) >> 7) & 0x1)
#define BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_7f_SET(r,f) (r).l3_entry_valid_only[0]=(((r).l3_entry_valid_only[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access L3_ENTRY_VALID_ONLY.
 *
 */
#define BCM56800_A0_READ_L3_ENTRY_VALID_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_ENTRY_VALID_ONLYm,i,(m._l3_entry_valid_only),1)
#define BCM56800_A0_WRITE_L3_ENTRY_VALID_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_ENTRY_VALID_ONLYm,i,&(m._l3_entry_valid_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_ENTRY_VALID_ONLYm BCM56800_A0_L3_ENTRY_VALID_ONLYm
#define L3_ENTRY_VALID_ONLYm_MIN BCM56800_A0_L3_ENTRY_VALID_ONLYm_MIN
#define L3_ENTRY_VALID_ONLYm_MAX BCM56800_A0_L3_ENTRY_VALID_ONLYm_MAX
#define L3_ENTRY_VALID_ONLYm_CMAX(u) BCM56800_A0_L3_ENTRY_VALID_ONLYm_CMAX(u)
#define L3_ENTRY_VALID_ONLYm_SIZE BCM56800_A0_L3_ENTRY_VALID_ONLYm_SIZE
typedef BCM56800_A0_L3_ENTRY_VALID_ONLYm_t L3_ENTRY_VALID_ONLYm_t;
#define L3_ENTRY_VALID_ONLYm_CLR BCM56800_A0_L3_ENTRY_VALID_ONLYm_CLR
#define L3_ENTRY_VALID_ONLYm_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_SET
#define L3_ENTRY_VALID_ONLYm_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_GET
#define L3_ENTRY_VALID_ONLYm_VALID_0f_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_0f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_0f_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_0f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_1f_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_1f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_1f_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_1f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_2f_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_2f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_2f_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_2f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_3f_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_3f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_3f_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_3f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_4f_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_4f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_4f_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_4f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_5f_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_5f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_5f_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_5f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_6f_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_6f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_6f_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_6f_SET
#define L3_ENTRY_VALID_ONLYm_VALID_7f_GET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_7f_GET
#define L3_ENTRY_VALID_ONLYm_VALID_7f_SET BCM56800_A0_L3_ENTRY_VALID_ONLYm_VALID_7f_SET
#define READ_L3_ENTRY_VALID_ONLYm BCM56800_A0_READ_L3_ENTRY_VALID_ONLYm
#define WRITE_L3_ENTRY_VALID_ONLYm BCM56800_A0_WRITE_L3_ENTRY_VALID_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_ENTRY_VALID_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_IPMC
 * BLOCKS:   IPIPE
 * DESC:     L3 IPMC Table
 * SIZE:     69
 * FIELDS:
 *     HIGIG_TRUNK_OVERRIDE Higig Trunk Override bits
 *     PORT_TGID        Port or TGID
 *     MODULE_ID        Module ID
 *     VALID            Indicates entry is valid
 *     L2_BITMAP        L2 port bitmap
 *     L3_BITMAP        L3 port bitmap
 *     IPMC_TUNNEL_TYPE Tunnel type of at least one of egress intf
 *     IPMC_MTU_INDEX   Overlay for index of MIN IPMC MTU
 *
 ******************************************************************************/
#define BCM56800_A0_L3_IPMCm 0x09160000

#define BCM56800_A0_L3_IPMCm_MIN 0
#define BCM56800_A0_L3_IPMCm_MAX 1023
#define BCM56800_A0_L3_IPMCm_CMAX(u) 1023
#define BCM56800_A0_L3_IPMCm_SIZE 9

/*
 * This structure should be used to declare and program L3_IPMC.
 *
 */
typedef union BCM56800_A0_L3_IPMCm_s {
	uint32_t v[3];
	uint32_t l3_ipmc[3];
	uint32_t _l3_ipmc;
} BCM56800_A0_L3_IPMCm_t;

#define BCM56800_A0_L3_IPMCm_CLR(r) CDK_MEMSET(&((r)._l3_ipmc), 0, sizeof(BCM56800_A0_L3_IPMCm_t))
#define BCM56800_A0_L3_IPMCm_SET(r,i,d) (r).l3_ipmc[i] = d
#define BCM56800_A0_L3_IPMCm_GET(r,i) (r).l3_ipmc[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_GET(r) (((r).l3_ipmc[0]) & 0xff)
#define BCM56800_A0_L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).l3_ipmc[0]=(((r).l3_ipmc[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_L3_IPMCm_PORT_TGIDf_GET(r) ((((r).l3_ipmc[0]) >> 8) & 0x3f)
#define BCM56800_A0_L3_IPMCm_PORT_TGIDf_SET(r,f) (r).l3_ipmc[0]=(((r).l3_ipmc[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM56800_A0_L3_IPMCm_MODULE_IDf_GET(r) ((((r).l3_ipmc[0]) >> 14) & 0x7f)
#define BCM56800_A0_L3_IPMCm_MODULE_IDf_SET(r,f) (r).l3_ipmc[0]=(((r).l3_ipmc[0] & ~((uint32_t)0x7f << 14)) | ((((uint32_t)f) & 0x7f) << 14))
#define BCM56800_A0_L3_IPMCm_VALIDf_GET(r) ((((r).l3_ipmc[0]) >> 21) & 0x1)
#define BCM56800_A0_L3_IPMCm_VALIDf_SET(r,f) (r).l3_ipmc[0]=(((r).l3_ipmc[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_L3_IPMCm_L2_BITMAPf_GET(r) cdk_field32_get((r).l3_ipmc,22,42)
#define BCM56800_A0_L3_IPMCm_L2_BITMAPf_SET(r,f) cdk_field32_set((r).l3_ipmc,22,42,f)
#define BCM56800_A0_L3_IPMCm_L3_BITMAPf_GET(r) ((((r).l3_ipmc[1]) >> 11) & 0x1fffff)
#define BCM56800_A0_L3_IPMCm_L3_BITMAPf_SET(r,f) (r).l3_ipmc[1]=(((r).l3_ipmc[1] & ~((uint32_t)0x1fffff << 11)) | ((((uint32_t)f) & 0x1fffff) << 11))
#define BCM56800_A0_L3_IPMCm_IPMC_TUNNEL_TYPEf_GET(r) (((r).l3_ipmc[2]) & 0x3)
#define BCM56800_A0_L3_IPMCm_IPMC_TUNNEL_TYPEf_SET(r,f) (r).l3_ipmc[2]=(((r).l3_ipmc[2] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_L3_IPMCm_IPMC_MTU_INDEXf_GET(r) ((((r).l3_ipmc[2]) >> 2) & 0x7)
#define BCM56800_A0_L3_IPMCm_IPMC_MTU_INDEXf_SET(r,f) (r).l3_ipmc[2]=(((r).l3_ipmc[2] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))

/*
 * These macros can be used to access L3_IPMC.
 *
 */
#define BCM56800_A0_READ_L3_IPMCm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_IPMCm,i,(m._l3_ipmc),3)
#define BCM56800_A0_WRITE_L3_IPMCm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_IPMCm,i,&(m._l3_ipmc),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_IPMCm BCM56800_A0_L3_IPMCm
#define L3_IPMCm_MIN BCM56800_A0_L3_IPMCm_MIN
#define L3_IPMCm_MAX BCM56800_A0_L3_IPMCm_MAX
#define L3_IPMCm_CMAX(u) BCM56800_A0_L3_IPMCm_CMAX(u)
#define L3_IPMCm_SIZE BCM56800_A0_L3_IPMCm_SIZE
typedef BCM56800_A0_L3_IPMCm_t L3_IPMCm_t;
#define L3_IPMCm_CLR BCM56800_A0_L3_IPMCm_CLR
#define L3_IPMCm_SET BCM56800_A0_L3_IPMCm_SET
#define L3_IPMCm_GET BCM56800_A0_L3_IPMCm_GET
#define L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_GET BCM56800_A0_L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_GET
#define L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_SET BCM56800_A0_L3_IPMCm_HIGIG_TRUNK_OVERRIDEf_SET
#define L3_IPMCm_PORT_TGIDf_GET BCM56800_A0_L3_IPMCm_PORT_TGIDf_GET
#define L3_IPMCm_PORT_TGIDf_SET BCM56800_A0_L3_IPMCm_PORT_TGIDf_SET
#define L3_IPMCm_MODULE_IDf_GET BCM56800_A0_L3_IPMCm_MODULE_IDf_GET
#define L3_IPMCm_MODULE_IDf_SET BCM56800_A0_L3_IPMCm_MODULE_IDf_SET
#define L3_IPMCm_VALIDf_GET BCM56800_A0_L3_IPMCm_VALIDf_GET
#define L3_IPMCm_VALIDf_SET BCM56800_A0_L3_IPMCm_VALIDf_SET
#define L3_IPMCm_L2_BITMAPf_GET BCM56800_A0_L3_IPMCm_L2_BITMAPf_GET
#define L3_IPMCm_L2_BITMAPf_SET BCM56800_A0_L3_IPMCm_L2_BITMAPf_SET
#define L3_IPMCm_L3_BITMAPf_GET BCM56800_A0_L3_IPMCm_L3_BITMAPf_GET
#define L3_IPMCm_L3_BITMAPf_SET BCM56800_A0_L3_IPMCm_L3_BITMAPf_SET
#define L3_IPMCm_IPMC_TUNNEL_TYPEf_GET BCM56800_A0_L3_IPMCm_IPMC_TUNNEL_TYPEf_GET
#define L3_IPMCm_IPMC_TUNNEL_TYPEf_SET BCM56800_A0_L3_IPMCm_IPMC_TUNNEL_TYPEf_SET
#define L3_IPMCm_IPMC_MTU_INDEXf_GET BCM56800_A0_L3_IPMCm_IPMC_MTU_INDEXf_GET
#define L3_IPMCm_IPMC_MTU_INDEXf_SET BCM56800_A0_L3_IPMCm_IPMC_MTU_INDEXf_SET
#define READ_L3_IPMCm BCM56800_A0_READ_L3_IPMCm
#define WRITE_L3_IPMCm BCM56800_A0_WRITE_L3_IPMCm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_IPMCm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  L3_TUNNEL
 * BLOCKS:   IPIPE
 * DESC:     L3 Tunnel Table TCAM, FeatureSpecific-Ethernet
 * SIZE:     169
 * FIELDS:
 *     VALID            Valid bit for each TCAM entry
 *     SIP              Source IP Address for tunnel table lookup
 *     DIP              Destination IP Address for tunnel table lookup
 *     SIP_MASK         Source IP Address Mask
 *     DIP_MASK         Destination IP Address Mask
 *     SUB_TUNNEL_TYPE  Indicates L3 tunnel type.  For automatic tunnels it indicates either ISATAP or 6-to-4.  For configured tunnels, it indicates if IPv4 in IPv4 (if sub_tunnel_type[1]==1) and/or IPv6 in IPv4 tunnels (if sub_tunnel_type[0]==1) are allowed.
 *     TUNNEL_TYPE      Indicates whether the tunnel is an auto or configured tunnel
 *     USE_OUTER_HDR_DSCP Use IPv4 outer header's DSCP field
 *     USE_OUTER_HDR_TTL Use IPv4 outer header's TTL field
 *     DONOT_CHANGE_INNER_HDR_DSCP Do not change inner header's DSCP field
 *     ALLOWED_PORT_BITMAP Port bitmap for this tunnel
 *     IINTF            L3 interface for this tunnel for IPMC switching
 *     USE_TUNNEL_DSCP  Trust dscp per tunnel
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNELm 0x02160000

#define BCM56800_A0_L3_TUNNELm_MIN 0
#define BCM56800_A0_L3_TUNNELm_MAX 127
#define BCM56800_A0_L3_TUNNELm_CMAX(u) 127
#define BCM56800_A0_L3_TUNNELm_SIZE 22

/*
 * This structure should be used to declare and program L3_TUNNEL.
 *
 */
typedef union BCM56800_A0_L3_TUNNELm_s {
	uint32_t v[6];
	uint32_t l3_tunnel[6];
	uint32_t _l3_tunnel;
} BCM56800_A0_L3_TUNNELm_t;

#define BCM56800_A0_L3_TUNNELm_CLR(r) CDK_MEMSET(&((r)._l3_tunnel), 0, sizeof(BCM56800_A0_L3_TUNNELm_t))
#define BCM56800_A0_L3_TUNNELm_SET(r,i,d) (r).l3_tunnel[i] = d
#define BCM56800_A0_L3_TUNNELm_GET(r,i) (r).l3_tunnel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNELm_VALIDf_GET(r) (((r).l3_tunnel[0]) & 0x1)
#define BCM56800_A0_L3_TUNNELm_VALIDf_SET(r,f) (r).l3_tunnel[0]=(((r).l3_tunnel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_TUNNELm_SIPf_GET(r) cdk_field32_get((r).l3_tunnel,1,32)
#define BCM56800_A0_L3_TUNNELm_SIPf_SET(r,f) cdk_field32_set((r).l3_tunnel,1,32,f)
#define BCM56800_A0_L3_TUNNELm_DIPf_GET(r) cdk_field32_get((r).l3_tunnel,33,64)
#define BCM56800_A0_L3_TUNNELm_DIPf_SET(r,f) cdk_field32_set((r).l3_tunnel,33,64,f)
#define BCM56800_A0_L3_TUNNELm_SIP_MASKf_GET(r) cdk_field32_get((r).l3_tunnel,65,96)
#define BCM56800_A0_L3_TUNNELm_SIP_MASKf_SET(r,f) cdk_field32_set((r).l3_tunnel,65,96,f)
#define BCM56800_A0_L3_TUNNELm_DIP_MASKf_GET(r) cdk_field32_get((r).l3_tunnel,97,128)
#define BCM56800_A0_L3_TUNNELm_DIP_MASKf_SET(r,f) cdk_field32_set((r).l3_tunnel,97,128,f)
#define BCM56800_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_GET(r) ((((r).l3_tunnel[4]) >> 1) & 0x3)
#define BCM56800_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56800_A0_L3_TUNNELm_TUNNEL_TYPEf_GET(r) ((((r).l3_tunnel[4]) >> 3) & 0x1)
#define BCM56800_A0_L3_TUNNELm_TUNNEL_TYPEf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET(r) ((((r).l3_tunnel[4]) >> 4) & 0x1)
#define BCM56800_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_GET(r) ((((r).l3_tunnel[4]) >> 5) & 0x1)
#define BCM56800_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET(r) ((((r).l3_tunnel[4]) >> 6) & 0x1)
#define BCM56800_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET(r) ((((r).l3_tunnel[4]) >> 7) & 0x1fffff)
#define BCM56800_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET(r,f) (r).l3_tunnel[4]=(((r).l3_tunnel[4] & ~((uint32_t)0x1fffff << 7)) | ((((uint32_t)f) & 0x1fffff) << 7))
#define BCM56800_A0_L3_TUNNELm_IINTFf_GET(r) cdk_field32_get((r).l3_tunnel,156,167)
#define BCM56800_A0_L3_TUNNELm_IINTFf_SET(r,f) cdk_field32_set((r).l3_tunnel,156,167,f)
#define BCM56800_A0_L3_TUNNELm_USE_TUNNEL_DSCPf_GET(r) ((((r).l3_tunnel[5]) >> 8) & 0x1)
#define BCM56800_A0_L3_TUNNELm_USE_TUNNEL_DSCPf_SET(r,f) (r).l3_tunnel[5]=(((r).l3_tunnel[5] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access L3_TUNNEL.
 *
 */
#define BCM56800_A0_READ_L3_TUNNELm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_L3_TUNNELm,i,(m._l3_tunnel),6)
#define BCM56800_A0_WRITE_L3_TUNNELm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_L3_TUNNELm,i,&(m._l3_tunnel),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNELm BCM56800_A0_L3_TUNNELm
#define L3_TUNNELm_MIN BCM56800_A0_L3_TUNNELm_MIN
#define L3_TUNNELm_MAX BCM56800_A0_L3_TUNNELm_MAX
#define L3_TUNNELm_CMAX(u) BCM56800_A0_L3_TUNNELm_CMAX(u)
#define L3_TUNNELm_SIZE BCM56800_A0_L3_TUNNELm_SIZE
typedef BCM56800_A0_L3_TUNNELm_t L3_TUNNELm_t;
#define L3_TUNNELm_CLR BCM56800_A0_L3_TUNNELm_CLR
#define L3_TUNNELm_SET BCM56800_A0_L3_TUNNELm_SET
#define L3_TUNNELm_GET BCM56800_A0_L3_TUNNELm_GET
#define L3_TUNNELm_VALIDf_GET BCM56800_A0_L3_TUNNELm_VALIDf_GET
#define L3_TUNNELm_VALIDf_SET BCM56800_A0_L3_TUNNELm_VALIDf_SET
#define L3_TUNNELm_SIPf_GET BCM56800_A0_L3_TUNNELm_SIPf_GET
#define L3_TUNNELm_SIPf_SET BCM56800_A0_L3_TUNNELm_SIPf_SET
#define L3_TUNNELm_DIPf_GET BCM56800_A0_L3_TUNNELm_DIPf_GET
#define L3_TUNNELm_DIPf_SET BCM56800_A0_L3_TUNNELm_DIPf_SET
#define L3_TUNNELm_SIP_MASKf_GET BCM56800_A0_L3_TUNNELm_SIP_MASKf_GET
#define L3_TUNNELm_SIP_MASKf_SET BCM56800_A0_L3_TUNNELm_SIP_MASKf_SET
#define L3_TUNNELm_DIP_MASKf_GET BCM56800_A0_L3_TUNNELm_DIP_MASKf_GET
#define L3_TUNNELm_DIP_MASKf_SET BCM56800_A0_L3_TUNNELm_DIP_MASKf_SET
#define L3_TUNNELm_SUB_TUNNEL_TYPEf_GET BCM56800_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_GET
#define L3_TUNNELm_SUB_TUNNEL_TYPEf_SET BCM56800_A0_L3_TUNNELm_SUB_TUNNEL_TYPEf_SET
#define L3_TUNNELm_TUNNEL_TYPEf_GET BCM56800_A0_L3_TUNNELm_TUNNEL_TYPEf_GET
#define L3_TUNNELm_TUNNEL_TYPEf_SET BCM56800_A0_L3_TUNNELm_TUNNEL_TYPEf_SET
#define L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET BCM56800_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_GET
#define L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET BCM56800_A0_L3_TUNNELm_USE_OUTER_HDR_DSCPf_SET
#define L3_TUNNELm_USE_OUTER_HDR_TTLf_GET BCM56800_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_GET
#define L3_TUNNELm_USE_OUTER_HDR_TTLf_SET BCM56800_A0_L3_TUNNELm_USE_OUTER_HDR_TTLf_SET
#define L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET BCM56800_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_GET
#define L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET BCM56800_A0_L3_TUNNELm_DONOT_CHANGE_INNER_HDR_DSCPf_SET
#define L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET BCM56800_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_GET
#define L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET BCM56800_A0_L3_TUNNELm_ALLOWED_PORT_BITMAPf_SET
#define L3_TUNNELm_IINTFf_GET BCM56800_A0_L3_TUNNELm_IINTFf_GET
#define L3_TUNNELm_IINTFf_SET BCM56800_A0_L3_TUNNELm_IINTFf_SET
#define L3_TUNNELm_USE_TUNNEL_DSCPf_GET BCM56800_A0_L3_TUNNELm_USE_TUNNEL_DSCPf_GET
#define L3_TUNNELm_USE_TUNNEL_DSCPf_SET BCM56800_A0_L3_TUNNELm_USE_TUNNEL_DSCPf_SET
#define READ_L3_TUNNELm BCM56800_A0_READ_L3_TUNNELm
#define WRITE_L3_TUNNELm BCM56800_A0_WRITE_L3_TUNNELm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNELm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_TUNNEL_CAM_BIST_S10_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S10_STATUS       S10_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr 0x02180c15

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s10_status[1];
	uint32_t _l3_tunnel_cam_bist_s10_status;
} BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_t;

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s10_status[0] = 0
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s10_status[0] = d
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_S10_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s10_status[0]) & 0xff)
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_S10_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s10_status[0]=(((r).l3_tunnel_cam_bist_s10_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr,(r._l3_tunnel_cam_bist_s10_status))
#define BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr,&(r._l3_tunnel_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S10_STATUSr BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_SIZE BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_t L3_TUNNEL_CAM_BIST_S10_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_CLR BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_S10_STATUSf_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_S10_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S10_STATUSr_S10_STATUSf_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr_S10_STATUSf_SET
#define READ_L3_TUNNEL_CAM_BIST_S10_STATUSr BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S10_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S10_STATUSr BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNEL_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_TUNNEL_CAM_BIST_S2_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S2_STATUS        L3_TUNNEL_CAM_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr 0x02180c10

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s2_status[1];
	uint32_t _l3_tunnel_cam_bist_s2_status;
} BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_t;

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s2_status[0] = 0
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s2_status[0] = d
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_S2_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s2_status[0]) & 0x7fff)
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_S2_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s2_status[0]=(((r).l3_tunnel_cam_bist_s2_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr,(r._l3_tunnel_cam_bist_s2_status))
#define BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr,&(r._l3_tunnel_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S2_STATUSr BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_SIZE BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_t L3_TUNNEL_CAM_BIST_S2_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_CLR BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_S2_STATUSf_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_S2_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S2_STATUSr_S2_STATUSf_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr_S2_STATUSf_SET
#define READ_L3_TUNNEL_CAM_BIST_S2_STATUSr BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S2_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S2_STATUSr BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNEL_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_TUNNEL_CAM_BIST_S3_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S3_STATUS        S3_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr 0x02180c11

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s3_status[1];
	uint32_t _l3_tunnel_cam_bist_s3_status;
} BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_t;

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s3_status[0] = 0
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s3_status[0] = d
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_S3_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s3_status[0]) & 0xffff)
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_S3_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s3_status[0]=(((r).l3_tunnel_cam_bist_s3_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr,(r._l3_tunnel_cam_bist_s3_status))
#define BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr,&(r._l3_tunnel_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S3_STATUSr BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_SIZE BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_t L3_TUNNEL_CAM_BIST_S3_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_CLR BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_S3_STATUSf_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_S3_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S3_STATUSr_S3_STATUSf_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr_S3_STATUSf_SET
#define READ_L3_TUNNEL_CAM_BIST_S3_STATUSr BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S3_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S3_STATUSr BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNEL_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_TUNNEL_CAM_BIST_S5_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S5_STATUS        S5_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr 0x02180c12

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s5_status[1];
	uint32_t _l3_tunnel_cam_bist_s5_status;
} BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_t;

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s5_status[0] = 0
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s5_status[0] = d
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_S5_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s5_status[0]) & 0x7fff)
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_S5_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s5_status[0]=(((r).l3_tunnel_cam_bist_s5_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr,(r._l3_tunnel_cam_bist_s5_status))
#define BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr,&(r._l3_tunnel_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S5_STATUSr BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_SIZE BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_t L3_TUNNEL_CAM_BIST_S5_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_CLR BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_S5_STATUSf_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_S5_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S5_STATUSr_S5_STATUSf_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr_S5_STATUSf_SET
#define READ_L3_TUNNEL_CAM_BIST_S5_STATUSr BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S5_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S5_STATUSr BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNEL_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_TUNNEL_CAM_BIST_S6_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S6_STATUS        S6_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr 0x02180c13

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s6_status[1];
	uint32_t _l3_tunnel_cam_bist_s6_status;
} BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_t;

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s6_status[0] = 0
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s6_status[0] = d
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_S6_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s6_status[0]) & 0xffff)
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_S6_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s6_status[0]=(((r).l3_tunnel_cam_bist_s6_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr,(r._l3_tunnel_cam_bist_s6_status))
#define BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr,&(r._l3_tunnel_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S6_STATUSr BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_SIZE BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_t L3_TUNNEL_CAM_BIST_S6_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_CLR BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_S6_STATUSf_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_S6_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S6_STATUSr_S6_STATUSf_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr_S6_STATUSf_SET
#define READ_L3_TUNNEL_CAM_BIST_S6_STATUSr BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S6_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S6_STATUSr BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNEL_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_TUNNEL_CAM_BIST_S8_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S8_STATUS        S8_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr 0x02180c14

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_s8_status[1];
	uint32_t _l3_tunnel_cam_bist_s8_status;
} BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_t;

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_s8_status[0] = 0
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_s8_status[0] = d
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_GET(r) (r).l3_tunnel_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_S8_STATUSf_GET(r) (((r).l3_tunnel_cam_bist_s8_status[0]) & 0xffff)
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_S8_STATUSf_SET(r,f) (r).l3_tunnel_cam_bist_s8_status[0]=(((r).l3_tunnel_cam_bist_s8_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr,(r._l3_tunnel_cam_bist_s8_status))
#define BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr,&(r._l3_tunnel_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_S8_STATUSr BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_SIZE BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_t L3_TUNNEL_CAM_BIST_S8_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_CLR BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_S8_STATUSf_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_S8_STATUSf_GET
#define L3_TUNNEL_CAM_BIST_S8_STATUSr_S8_STATUSf_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr_S8_STATUSf_SET
#define READ_L3_TUNNEL_CAM_BIST_S8_STATUSr BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_S8_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_S8_STATUSr BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNEL_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_TUNNEL_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     L3_TUNNEL_CAM_BIST_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag
 *     BIST_DONE        BIST completion status
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr 0x02180c17

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_BIST_STATUS.
 *
 */
typedef union BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_bist_status[1];
	uint32_t _l3_tunnel_cam_bist_status;
} BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_t;

#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_CLR(r) (r).l3_tunnel_cam_bist_status[0] = 0
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_SET(r,d) (r).l3_tunnel_cam_bist_status[0] = d
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_GET(r) (r).l3_tunnel_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).l3_tunnel_cam_bist_status[0]) & 0x1)
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).l3_tunnel_cam_bist_status[0]=(((r).l3_tunnel_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).l3_tunnel_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).l3_tunnel_cam_bist_status[0]=(((r).l3_tunnel_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L3_TUNNEL_CAM_BIST_STATUS.
 *
 */
#define BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr,(r._l3_tunnel_cam_bist_status))
#define BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr,&(r._l3_tunnel_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_BIST_STATUSr BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr
#define L3_TUNNEL_CAM_BIST_STATUSr_SIZE BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_SIZE
typedef BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_t L3_TUNNEL_CAM_BIST_STATUSr_t;
#define L3_TUNNEL_CAM_BIST_STATUSr_CLR BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_CLR
#define L3_TUNNEL_CAM_BIST_STATUSr_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_SET
#define L3_TUNNEL_CAM_BIST_STATUSr_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_GET
#define L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_GET
#define L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_GOf_SET
#define L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_GET
#define L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_L3_TUNNEL_CAM_BIST_STATUSr BCM56800_A0_READ_L3_TUNNEL_CAM_BIST_STATUSr
#define WRITE_L3_TUNNEL_CAM_BIST_STATUSr BCM56800_A0_WRITE_L3_TUNNEL_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNEL_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  L3_TUNNEL_CAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     L3_TUNNEL_CAM_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST enable
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr 0x02180c18

#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program L3_TUNNEL_CAM_DBGCTRL.
 *
 */
typedef union BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t l3_tunnel_cam_dbgctrl[1];
	uint32_t _l3_tunnel_cam_dbgctrl;
} BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_t;

#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_CLR(r) (r).l3_tunnel_cam_dbgctrl[0] = 0
#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_SET(r,d) (r).l3_tunnel_cam_dbgctrl[0] = d
#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_GET(r) (r).l3_tunnel_cam_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_BIST_ENf_GET(r) (((r).l3_tunnel_cam_dbgctrl[0]) & 0x1)
#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_BIST_ENf_SET(r,f) (r).l3_tunnel_cam_dbgctrl[0]=(((r).l3_tunnel_cam_dbgctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_TMf_GET(r) ((((r).l3_tunnel_cam_dbgctrl[0]) >> 1) & 0x7ff)
#define BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_TMf_SET(r,f) (r).l3_tunnel_cam_dbgctrl[0]=(((r).l3_tunnel_cam_dbgctrl[0] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))

/*
 * These macros can be used to access L3_TUNNEL_CAM_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_L3_TUNNEL_CAM_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr,(r._l3_tunnel_cam_dbgctrl))
#define BCM56800_A0_WRITE_L3_TUNNEL_CAM_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr,&(r._l3_tunnel_cam_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L3_TUNNEL_CAM_DBGCTRLr BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr
#define L3_TUNNEL_CAM_DBGCTRLr_SIZE BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_SIZE
typedef BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_t L3_TUNNEL_CAM_DBGCTRLr_t;
#define L3_TUNNEL_CAM_DBGCTRLr_CLR BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_CLR
#define L3_TUNNEL_CAM_DBGCTRLr_SET BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_SET
#define L3_TUNNEL_CAM_DBGCTRLr_GET BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_GET
#define L3_TUNNEL_CAM_DBGCTRLr_BIST_ENf_GET BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_BIST_ENf_GET
#define L3_TUNNEL_CAM_DBGCTRLr_BIST_ENf_SET BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_BIST_ENf_SET
#define L3_TUNNEL_CAM_DBGCTRLr_TMf_GET BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_TMf_GET
#define L3_TUNNEL_CAM_DBGCTRLr_TMf_SET BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr_TMf_SET
#define READ_L3_TUNNEL_CAM_DBGCTRLr BCM56800_A0_READ_L3_TUNNEL_CAM_DBGCTRLr
#define WRITE_L3_TUNNEL_CAM_DBGCTRLr BCM56800_A0_WRITE_L3_TUNNEL_CAM_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_L3_TUNNEL_CAM_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  LINK_STATUS
 * BLOCKS:   IPIPE
 * DESC:     Link Status Indication Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Link status indication bitmap, 1=up, 0=down.
 *
 ******************************************************************************/
#define BCM56800_A0_LINK_STATUSr 0x0e180639

#define BCM56800_A0_LINK_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program LINK_STATUS.
 *
 */
typedef union BCM56800_A0_LINK_STATUSr_s {
	uint32_t v[1];
	uint32_t link_status[1];
	uint32_t _link_status;
} BCM56800_A0_LINK_STATUSr_t;

#define BCM56800_A0_LINK_STATUSr_CLR(r) (r).link_status[0] = 0
#define BCM56800_A0_LINK_STATUSr_SET(r,d) (r).link_status[0] = d
#define BCM56800_A0_LINK_STATUSr_GET(r) (r).link_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_LINK_STATUSr_BITMAPf_GET(r) (((r).link_status[0]) & 0x1fffff)
#define BCM56800_A0_LINK_STATUSr_BITMAPf_SET(r,f) (r).link_status[0]=(((r).link_status[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access LINK_STATUS.
 *
 */
#define BCM56800_A0_READ_LINK_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_LINK_STATUSr,(r._link_status))
#define BCM56800_A0_WRITE_LINK_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_LINK_STATUSr,&(r._link_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LINK_STATUSr BCM56800_A0_LINK_STATUSr
#define LINK_STATUSr_SIZE BCM56800_A0_LINK_STATUSr_SIZE
typedef BCM56800_A0_LINK_STATUSr_t LINK_STATUSr_t;
#define LINK_STATUSr_CLR BCM56800_A0_LINK_STATUSr_CLR
#define LINK_STATUSr_SET BCM56800_A0_LINK_STATUSr_SET
#define LINK_STATUSr_GET BCM56800_A0_LINK_STATUSr_GET
#define LINK_STATUSr_BITMAPf_GET BCM56800_A0_LINK_STATUSr_BITMAPf_GET
#define LINK_STATUSr_BITMAPf_SET BCM56800_A0_LINK_STATUSr_BITMAPf_SET
#define READ_LINK_STATUSr BCM56800_A0_READ_LINK_STATUSr
#define WRITE_LINK_STATUSr BCM56800_A0_WRITE_LINK_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_LINK_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  LOCAL_SW_DISABLE_DEFAULT_PBM
 * BLOCKS:   IPIPE
 * DESC:     Local switching disable default port bitmap, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     PORT_BITMAP      If local switching is disabled, packets will be forwarded according to this field.
 *
 ******************************************************************************/
#define BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr 0x0e100048

#define BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE 4

/*
 * This structure should be used to declare and program LOCAL_SW_DISABLE_DEFAULT_PBM.
 *
 */
typedef union BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_s {
	uint32_t v[1];
	uint32_t local_sw_disable_default_pbm[1];
	uint32_t _local_sw_disable_default_pbm;
} BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_t;

#define BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_CLR(r) (r).local_sw_disable_default_pbm[0] = 0
#define BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_SET(r,d) (r).local_sw_disable_default_pbm[0] = d
#define BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_GET(r) (r).local_sw_disable_default_pbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET(r) (((r).local_sw_disable_default_pbm[0]) & 0x1fffff)
#define BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET(r,f) (r).local_sw_disable_default_pbm[0]=(((r).local_sw_disable_default_pbm[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access LOCAL_SW_DISABLE_DEFAULT_PBM.
 *
 */
#define BCM56800_A0_READ_LOCAL_SW_DISABLE_DEFAULT_PBMr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr,(r._local_sw_disable_default_pbm))
#define BCM56800_A0_WRITE_LOCAL_SW_DISABLE_DEFAULT_PBMr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr,&(r._local_sw_disable_default_pbm))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LOCAL_SW_DISABLE_DEFAULT_PBMr BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_SIZE
typedef BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_t LOCAL_SW_DISABLE_DEFAULT_PBMr_t;
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_CLR BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_CLR
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_SET BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_SET
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_GET BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_GET
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_GET
#define LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr_PORT_BITMAPf_SET
#define READ_LOCAL_SW_DISABLE_DEFAULT_PBMr BCM56800_A0_READ_LOCAL_SW_DISABLE_DEFAULT_PBMr
#define WRITE_LOCAL_SW_DISABLE_DEFAULT_PBMr BCM56800_A0_WRITE_LOCAL_SW_DISABLE_DEFAULT_PBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_LOCAL_SW_DISABLE_DEFAULT_PBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MAC_BLOCK
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table
 * SIZE:     21
 * FIELDS:
 *     MAC_BLOCK_MASK   MAC block mask
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_BLOCKm 0x0e164000

#define BCM56800_A0_MAC_BLOCKm_MIN 0
#define BCM56800_A0_MAC_BLOCKm_MAX 31
#define BCM56800_A0_MAC_BLOCKm_CMAX(u) 31
#define BCM56800_A0_MAC_BLOCKm_SIZE 3

/*
 * This structure should be used to declare and program MAC_BLOCK.
 *
 */
typedef union BCM56800_A0_MAC_BLOCKm_s {
	uint32_t v[1];
	uint32_t mac_block[1];
	uint32_t _mac_block;
} BCM56800_A0_MAC_BLOCKm_t;

#define BCM56800_A0_MAC_BLOCKm_CLR(r) (r).mac_block[0] = 0
#define BCM56800_A0_MAC_BLOCKm_SET(r,d) (r).mac_block[0] = d
#define BCM56800_A0_MAC_BLOCKm_GET(r) (r).mac_block[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_GET(r) (((r).mac_block[0]) & 0x1fffff)
#define BCM56800_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_SET(r,f) (r).mac_block[0]=(((r).mac_block[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access MAC_BLOCK.
 *
 */
#define BCM56800_A0_READ_MAC_BLOCKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MAC_BLOCKm,i,(m._mac_block),1)
#define BCM56800_A0_WRITE_MAC_BLOCKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MAC_BLOCKm,i,&(m._mac_block),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_BLOCKm BCM56800_A0_MAC_BLOCKm
#define MAC_BLOCKm_MIN BCM56800_A0_MAC_BLOCKm_MIN
#define MAC_BLOCKm_MAX BCM56800_A0_MAC_BLOCKm_MAX
#define MAC_BLOCKm_CMAX(u) BCM56800_A0_MAC_BLOCKm_CMAX(u)
#define MAC_BLOCKm_SIZE BCM56800_A0_MAC_BLOCKm_SIZE
typedef BCM56800_A0_MAC_BLOCKm_t MAC_BLOCKm_t;
#define MAC_BLOCKm_CLR BCM56800_A0_MAC_BLOCKm_CLR
#define MAC_BLOCKm_SET BCM56800_A0_MAC_BLOCKm_SET
#define MAC_BLOCKm_GET BCM56800_A0_MAC_BLOCKm_GET
#define MAC_BLOCKm_MAC_BLOCK_MASKf_GET BCM56800_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_GET
#define MAC_BLOCKm_MAC_BLOCK_MASKf_SET BCM56800_A0_MAC_BLOCKm_MAC_BLOCK_MASKf_SET
#define READ_MAC_BLOCKm BCM56800_A0_READ_MAC_BLOCKm
#define WRITE_MAC_BLOCKm BCM56800_A0_WRITE_MAC_BLOCKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_BLOCKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_CntMaxSz
 * BLOCKS:   GXPORT
 * DESC:     Max size packet for counter increment
 * SIZE:     64
 * FIELDS:
 *     SZ               Maximum size of packet received/transmitted that will increment,if appropriate, IRMCA, IRBCA, IRFCS, IRXCF, IRXPF, IRXUO, IROVR, IRJBR,ITMCA, ITBCA, ITFCS, ITXPF, ITOVR
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_CNTMAXSZr 0x00f00005

#define BCM56800_A0_MAC_CNTMAXSZr_SIZE 8

/*
 * This structure should be used to declare and program MAC_CntMaxSz.
 *
 */
typedef union BCM56800_A0_MAC_CNTMAXSZr_s {
	uint32_t v[2];
	uint32_t mac_cntmaxsz[2];
	uint32_t _mac_cntmaxsz;
} BCM56800_A0_MAC_CNTMAXSZr_t;

#define BCM56800_A0_MAC_CNTMAXSZr_CLR(r) CDK_MEMSET(&((r)._mac_cntmaxsz), 0, sizeof(BCM56800_A0_MAC_CNTMAXSZr_t))
#define BCM56800_A0_MAC_CNTMAXSZr_SET(r,i,d) (r).mac_cntmaxsz[i] = d
#define BCM56800_A0_MAC_CNTMAXSZr_GET(r,i) (r).mac_cntmaxsz[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_CNTMAXSZr_SZf_GET(r) (((r).mac_cntmaxsz[0]) & 0x3fff)
#define BCM56800_A0_MAC_CNTMAXSZr_SZf_SET(r,f) (r).mac_cntmaxsz[0]=(((r).mac_cntmaxsz[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access MAC_CntMaxSz.
 *
 */
#define BCM56800_A0_READ_MAC_CNTMAXSZr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_CNTMAXSZr,(r._mac_cntmaxsz))
#define BCM56800_A0_WRITE_MAC_CNTMAXSZr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_CNTMAXSZr,&(r._mac_cntmaxsz))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_CNTMAXSZr BCM56800_A0_MAC_CNTMAXSZr
#define MAC_CNTMAXSZr_SIZE BCM56800_A0_MAC_CNTMAXSZr_SIZE
typedef BCM56800_A0_MAC_CNTMAXSZr_t MAC_CNTMAXSZr_t;
#define MAC_CNTMAXSZr_CLR BCM56800_A0_MAC_CNTMAXSZr_CLR
#define MAC_CNTMAXSZr_SET BCM56800_A0_MAC_CNTMAXSZr_SET
#define MAC_CNTMAXSZr_GET BCM56800_A0_MAC_CNTMAXSZr_GET
#define MAC_CNTMAXSZr_SZf_GET BCM56800_A0_MAC_CNTMAXSZr_SZf_GET
#define MAC_CNTMAXSZr_SZf_SET BCM56800_A0_MAC_CNTMAXSZr_SZf_SET
#define READ_MAC_CNTMAXSZr BCM56800_A0_READ_MAC_CNTMAXSZr
#define WRITE_MAC_CNTMAXSZr BCM56800_A0_WRITE_MAC_CNTMAXSZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_CNTMAXSZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_CoreSpare0
 * BLOCKS:   GXPORT
 * DESC:     Spare reg for ECO on core clock domain
 * SIZE:     64
 * FIELDS:
 *     RSVD             SPARE REGISTERS 0
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_CORESPARE0r 0x00f00006

#define BCM56800_A0_MAC_CORESPARE0r_SIZE 8

/*
 * This structure should be used to declare and program MAC_CoreSpare0.
 *
 */
typedef union BCM56800_A0_MAC_CORESPARE0r_s {
	uint32_t v[2];
	uint32_t mac_corespare0[2];
	uint32_t _mac_corespare0;
} BCM56800_A0_MAC_CORESPARE0r_t;

#define BCM56800_A0_MAC_CORESPARE0r_CLR(r) CDK_MEMSET(&((r)._mac_corespare0), 0, sizeof(BCM56800_A0_MAC_CORESPARE0r_t))
#define BCM56800_A0_MAC_CORESPARE0r_SET(r,i,d) (r).mac_corespare0[i] = d
#define BCM56800_A0_MAC_CORESPARE0r_GET(r,i) (r).mac_corespare0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_CORESPARE0r_RSVDf_GET(r) ((r).mac_corespare0[0])
#define BCM56800_A0_MAC_CORESPARE0r_RSVDf_SET(r,f) (r).mac_corespare0[0]=((uint32_t)f)

/*
 * These macros can be used to access MAC_CoreSpare0.
 *
 */
#define BCM56800_A0_READ_MAC_CORESPARE0r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_CORESPARE0r,(r._mac_corespare0))
#define BCM56800_A0_WRITE_MAC_CORESPARE0r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_CORESPARE0r,&(r._mac_corespare0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_CORESPARE0r BCM56800_A0_MAC_CORESPARE0r
#define MAC_CORESPARE0r_SIZE BCM56800_A0_MAC_CORESPARE0r_SIZE
typedef BCM56800_A0_MAC_CORESPARE0r_t MAC_CORESPARE0r_t;
#define MAC_CORESPARE0r_CLR BCM56800_A0_MAC_CORESPARE0r_CLR
#define MAC_CORESPARE0r_SET BCM56800_A0_MAC_CORESPARE0r_SET
#define MAC_CORESPARE0r_GET BCM56800_A0_MAC_CORESPARE0r_GET
#define MAC_CORESPARE0r_RSVDf_GET BCM56800_A0_MAC_CORESPARE0r_RSVDf_GET
#define MAC_CORESPARE0r_RSVDf_SET BCM56800_A0_MAC_CORESPARE0r_RSVDf_SET
#define READ_MAC_CORESPARE0r BCM56800_A0_READ_MAC_CORESPARE0r
#define WRITE_MAC_CORESPARE0r BCM56800_A0_WRITE_MAC_CORESPARE0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_CORESPARE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_Ctrl
 * BLOCKS:   GXPORT
 * DESC:     MAC control.
 * SIZE:     64
 * FIELDS:
 *     TXEN             Transmit enable.
 *     RXEN             Receive enable.
 *     LCLLOOP          Local loopback mode from the Tx FIFO to the Rx FIFO.
 *     RMTLOOP          Remote loopback mode from the XGMII receive to XGMII transmit.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_CTRLr 0x00f00000

#define BCM56800_A0_MAC_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_Ctrl.
 *
 */
typedef union BCM56800_A0_MAC_CTRLr_s {
	uint32_t v[2];
	uint32_t mac_ctrl[2];
	uint32_t _mac_ctrl;
} BCM56800_A0_MAC_CTRLr_t;

#define BCM56800_A0_MAC_CTRLr_CLR(r) CDK_MEMSET(&((r)._mac_ctrl), 0, sizeof(BCM56800_A0_MAC_CTRLr_t))
#define BCM56800_A0_MAC_CTRLr_SET(r,i,d) (r).mac_ctrl[i] = d
#define BCM56800_A0_MAC_CTRLr_GET(r,i) (r).mac_ctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_CTRLr_TXENf_GET(r) (((r).mac_ctrl[0]) & 0x1)
#define BCM56800_A0_MAC_CTRLr_TXENf_SET(r,f) (r).mac_ctrl[0]=(((r).mac_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MAC_CTRLr_RXENf_GET(r) ((((r).mac_ctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_MAC_CTRLr_RXENf_SET(r,f) (r).mac_ctrl[0]=(((r).mac_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MAC_CTRLr_LCLLOOPf_GET(r) ((((r).mac_ctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_MAC_CTRLr_LCLLOOPf_SET(r,f) (r).mac_ctrl[0]=(((r).mac_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MAC_CTRLr_RMTLOOPf_GET(r) ((((r).mac_ctrl[0]) >> 3) & 0x1)
#define BCM56800_A0_MAC_CTRLr_RMTLOOPf_SET(r,f) (r).mac_ctrl[0]=(((r).mac_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))

/*
 * These macros can be used to access MAC_Ctrl.
 *
 */
#define BCM56800_A0_READ_MAC_CTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_CTRLr,(r._mac_ctrl))
#define BCM56800_A0_WRITE_MAC_CTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_CTRLr,&(r._mac_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_CTRLr BCM56800_A0_MAC_CTRLr
#define MAC_CTRLr_SIZE BCM56800_A0_MAC_CTRLr_SIZE
typedef BCM56800_A0_MAC_CTRLr_t MAC_CTRLr_t;
#define MAC_CTRLr_CLR BCM56800_A0_MAC_CTRLr_CLR
#define MAC_CTRLr_SET BCM56800_A0_MAC_CTRLr_SET
#define MAC_CTRLr_GET BCM56800_A0_MAC_CTRLr_GET
#define MAC_CTRLr_TXENf_GET BCM56800_A0_MAC_CTRLr_TXENf_GET
#define MAC_CTRLr_TXENf_SET BCM56800_A0_MAC_CTRLr_TXENf_SET
#define MAC_CTRLr_RXENf_GET BCM56800_A0_MAC_CTRLr_RXENf_GET
#define MAC_CTRLr_RXENf_SET BCM56800_A0_MAC_CTRLr_RXENf_SET
#define MAC_CTRLr_LCLLOOPf_GET BCM56800_A0_MAC_CTRLr_LCLLOOPf_GET
#define MAC_CTRLr_LCLLOOPf_SET BCM56800_A0_MAC_CTRLr_LCLLOOPf_SET
#define MAC_CTRLr_RMTLOOPf_GET BCM56800_A0_MAC_CTRLr_RMTLOOPf_GET
#define MAC_CTRLr_RMTLOOPf_SET BCM56800_A0_MAC_CTRLr_RMTLOOPf_SET
#define READ_MAC_CTRLr BCM56800_A0_READ_MAC_CTRLr
#define WRITE_MAC_CTRLr BCM56800_A0_WRITE_MAC_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_RxCtrl
 * BLOCKS:   GXPORT
 * DESC:     Receive control.
 * SIZE:     64
 * FIELDS:
 *     HDRMODE          Header mode.
 *     STRIPCRC         CRC is checked, then stripped from the packet received.
 *     IGNORECRC        CRC errors are ignored.
 *     STRICTPRMBL      Preamble is set to IEEE Ethernet format.
 *     RXPAUSEN         Received PAUSE packets will inhibit transmission.
 *     RXPASSCTRL       Mac Control packets are passed to the system.
 *     ANYSTART         True to allow any non-Idle character to start a packet.  False to require /Start per XGMII spec 
 *     HIGIG2MODE       Port in Higig2Mode
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_RXCTRLr 0x00f00021

#define BCM56800_A0_MAC_RXCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxCtrl.
 *
 */
typedef union BCM56800_A0_MAC_RXCTRLr_s {
	uint32_t v[2];
	uint32_t mac_rxctrl[2];
	uint32_t _mac_rxctrl;
} BCM56800_A0_MAC_RXCTRLr_t;

#define BCM56800_A0_MAC_RXCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_rxctrl), 0, sizeof(BCM56800_A0_MAC_RXCTRLr_t))
#define BCM56800_A0_MAC_RXCTRLr_SET(r,i,d) (r).mac_rxctrl[i] = d
#define BCM56800_A0_MAC_RXCTRLr_GET(r,i) (r).mac_rxctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_RXCTRLr_HDRMODEf_GET(r) (((r).mac_rxctrl[0]) & 0x3)
#define BCM56800_A0_MAC_RXCTRLr_HDRMODEf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_MAC_RXCTRLr_STRIPCRCf_GET(r) ((((r).mac_rxctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_MAC_RXCTRLr_STRIPCRCf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MAC_RXCTRLr_IGNORECRCf_GET(r) ((((r).mac_rxctrl[0]) >> 3) & 0x1)
#define BCM56800_A0_MAC_RXCTRLr_IGNORECRCf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MAC_RXCTRLr_STRICTPRMBLf_GET(r) ((((r).mac_rxctrl[0]) >> 4) & 0x1)
#define BCM56800_A0_MAC_RXCTRLr_STRICTPRMBLf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MAC_RXCTRLr_RXPAUSENf_GET(r) ((((r).mac_rxctrl[0]) >> 5) & 0x1)
#define BCM56800_A0_MAC_RXCTRLr_RXPAUSENf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_MAC_RXCTRLr_RXPASSCTRLf_GET(r) ((((r).mac_rxctrl[0]) >> 6) & 0x1)
#define BCM56800_A0_MAC_RXCTRLr_RXPASSCTRLf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_MAC_RXCTRLr_ANYSTARTf_GET(r) ((((r).mac_rxctrl[0]) >> 7) & 0x1)
#define BCM56800_A0_MAC_RXCTRLr_ANYSTARTf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_MAC_RXCTRLr_HIGIG2MODEf_GET(r) ((((r).mac_rxctrl[0]) >> 8) & 0x1)
#define BCM56800_A0_MAC_RXCTRLr_HIGIG2MODEf_SET(r,f) (r).mac_rxctrl[0]=(((r).mac_rxctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MAC_RxCtrl.
 *
 */
#define BCM56800_A0_READ_MAC_RXCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_RXCTRLr,(r._mac_rxctrl))
#define BCM56800_A0_WRITE_MAC_RXCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_RXCTRLr,&(r._mac_rxctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXCTRLr BCM56800_A0_MAC_RXCTRLr
#define MAC_RXCTRLr_SIZE BCM56800_A0_MAC_RXCTRLr_SIZE
typedef BCM56800_A0_MAC_RXCTRLr_t MAC_RXCTRLr_t;
#define MAC_RXCTRLr_CLR BCM56800_A0_MAC_RXCTRLr_CLR
#define MAC_RXCTRLr_SET BCM56800_A0_MAC_RXCTRLr_SET
#define MAC_RXCTRLr_GET BCM56800_A0_MAC_RXCTRLr_GET
#define MAC_RXCTRLr_HDRMODEf_GET BCM56800_A0_MAC_RXCTRLr_HDRMODEf_GET
#define MAC_RXCTRLr_HDRMODEf_SET BCM56800_A0_MAC_RXCTRLr_HDRMODEf_SET
#define MAC_RXCTRLr_STRIPCRCf_GET BCM56800_A0_MAC_RXCTRLr_STRIPCRCf_GET
#define MAC_RXCTRLr_STRIPCRCf_SET BCM56800_A0_MAC_RXCTRLr_STRIPCRCf_SET
#define MAC_RXCTRLr_IGNORECRCf_GET BCM56800_A0_MAC_RXCTRLr_IGNORECRCf_GET
#define MAC_RXCTRLr_IGNORECRCf_SET BCM56800_A0_MAC_RXCTRLr_IGNORECRCf_SET
#define MAC_RXCTRLr_STRICTPRMBLf_GET BCM56800_A0_MAC_RXCTRLr_STRICTPRMBLf_GET
#define MAC_RXCTRLr_STRICTPRMBLf_SET BCM56800_A0_MAC_RXCTRLr_STRICTPRMBLf_SET
#define MAC_RXCTRLr_RXPAUSENf_GET BCM56800_A0_MAC_RXCTRLr_RXPAUSENf_GET
#define MAC_RXCTRLr_RXPAUSENf_SET BCM56800_A0_MAC_RXCTRLr_RXPAUSENf_SET
#define MAC_RXCTRLr_RXPASSCTRLf_GET BCM56800_A0_MAC_RXCTRLr_RXPASSCTRLf_GET
#define MAC_RXCTRLr_RXPASSCTRLf_SET BCM56800_A0_MAC_RXCTRLr_RXPASSCTRLf_SET
#define MAC_RXCTRLr_ANYSTARTf_GET BCM56800_A0_MAC_RXCTRLr_ANYSTARTf_GET
#define MAC_RXCTRLr_ANYSTARTf_SET BCM56800_A0_MAC_RXCTRLr_ANYSTARTf_SET
#define MAC_RXCTRLr_HIGIG2MODEf_GET BCM56800_A0_MAC_RXCTRLr_HIGIG2MODEf_GET
#define MAC_RXCTRLr_HIGIG2MODEf_SET BCM56800_A0_MAC_RXCTRLr_HIGIG2MODEf_SET
#define READ_MAC_RXCTRLr BCM56800_A0_READ_MAC_RXCTRLr
#define WRITE_MAC_RXCTRLr BCM56800_A0_WRITE_MAC_RXCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_RXCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_RxLSSCtrl
 * BLOCKS:   GXPORT
 * DESC:     Control for LSS (ordered set) messages
 * SIZE:     64
 * FIELDS:
 *     LOCALFAULTDISABLE True to disable enable processing of LSS message type: Local Fault.When clear and a local fault LSS message is received, a continuousstream of "Remote Fault" LSS messages will be transmitted to thelink partner.
 *     REMOTEFAULTDISABLE True to disable processing of LSS message type: Remote Fault.When clear and a remote fault LSS message is received, a continuousstream of IDLES will be transmitted to the link partner.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_RXLSSCTRLr 0x00f00024

#define BCM56800_A0_MAC_RXLSSCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxLSSCtrl.
 *
 */
typedef union BCM56800_A0_MAC_RXLSSCTRLr_s {
	uint32_t v[2];
	uint32_t mac_rxlssctrl[2];
	uint32_t _mac_rxlssctrl;
} BCM56800_A0_MAC_RXLSSCTRLr_t;

#define BCM56800_A0_MAC_RXLSSCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_rxlssctrl), 0, sizeof(BCM56800_A0_MAC_RXLSSCTRLr_t))
#define BCM56800_A0_MAC_RXLSSCTRLr_SET(r,i,d) (r).mac_rxlssctrl[i] = d
#define BCM56800_A0_MAC_RXLSSCTRLr_GET(r,i) (r).mac_rxlssctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_GET(r) (((r).mac_rxlssctrl[0]) & 0x1)
#define BCM56800_A0_MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_SET(r,f) (r).mac_rxlssctrl[0]=(((r).mac_rxlssctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_GET(r) ((((r).mac_rxlssctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_SET(r,f) (r).mac_rxlssctrl[0]=(((r).mac_rxlssctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access MAC_RxLSSCtrl.
 *
 */
#define BCM56800_A0_READ_MAC_RXLSSCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_RXLSSCTRLr,(r._mac_rxlssctrl))
#define BCM56800_A0_WRITE_MAC_RXLSSCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_RXLSSCTRLr,&(r._mac_rxlssctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXLSSCTRLr BCM56800_A0_MAC_RXLSSCTRLr
#define MAC_RXLSSCTRLr_SIZE BCM56800_A0_MAC_RXLSSCTRLr_SIZE
typedef BCM56800_A0_MAC_RXLSSCTRLr_t MAC_RXLSSCTRLr_t;
#define MAC_RXLSSCTRLr_CLR BCM56800_A0_MAC_RXLSSCTRLr_CLR
#define MAC_RXLSSCTRLr_SET BCM56800_A0_MAC_RXLSSCTRLr_SET
#define MAC_RXLSSCTRLr_GET BCM56800_A0_MAC_RXLSSCTRLr_GET
#define MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_GET BCM56800_A0_MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_GET
#define MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_SET BCM56800_A0_MAC_RXLSSCTRLr_LOCALFAULTDISABLEf_SET
#define MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_GET BCM56800_A0_MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_GET
#define MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_SET BCM56800_A0_MAC_RXLSSCTRLr_REMOTEFAULTDISABLEf_SET
#define READ_MAC_RXLSSCTRLr BCM56800_A0_READ_MAC_RXLSSCTRLr
#define WRITE_MAC_RXLSSCTRLr BCM56800_A0_WRITE_MAC_RXLSSCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_RXLSSCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_RxLSSStat
 * BLOCKS:   GXPORT
 * DESC:     Status for LSS (ordered set) messages
 * SIZE:     64
 * FIELDS:
 *     LOCALFAULTSTAT   True while "local fault" LSS messages are being received
 *     REMOTEFAULTSTAT  True while "remote fault" LSS messages are being received
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_RXLSSSTATr 0x00f00043

#define BCM56800_A0_MAC_RXLSSSTATr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxLSSStat.
 *
 */
typedef union BCM56800_A0_MAC_RXLSSSTATr_s {
	uint32_t v[2];
	uint32_t mac_rxlssstat[2];
	uint32_t _mac_rxlssstat;
} BCM56800_A0_MAC_RXLSSSTATr_t;

#define BCM56800_A0_MAC_RXLSSSTATr_CLR(r) CDK_MEMSET(&((r)._mac_rxlssstat), 0, sizeof(BCM56800_A0_MAC_RXLSSSTATr_t))
#define BCM56800_A0_MAC_RXLSSSTATr_SET(r,i,d) (r).mac_rxlssstat[i] = d
#define BCM56800_A0_MAC_RXLSSSTATr_GET(r,i) (r).mac_rxlssstat[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_RXLSSSTATr_LOCALFAULTSTATf_GET(r) (((r).mac_rxlssstat[0]) & 0x1)
#define BCM56800_A0_MAC_RXLSSSTATr_LOCALFAULTSTATf_SET(r,f) (r).mac_rxlssstat[0]=(((r).mac_rxlssstat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MAC_RXLSSSTATr_REMOTEFAULTSTATf_GET(r) ((((r).mac_rxlssstat[0]) >> 1) & 0x1)
#define BCM56800_A0_MAC_RXLSSSTATr_REMOTEFAULTSTATf_SET(r,f) (r).mac_rxlssstat[0]=(((r).mac_rxlssstat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access MAC_RxLSSStat.
 *
 */
#define BCM56800_A0_READ_MAC_RXLSSSTATr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_RXLSSSTATr,(r._mac_rxlssstat))
#define BCM56800_A0_WRITE_MAC_RXLSSSTATr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_RXLSSSTATr,&(r._mac_rxlssstat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXLSSSTATr BCM56800_A0_MAC_RXLSSSTATr
#define MAC_RXLSSSTATr_SIZE BCM56800_A0_MAC_RXLSSSTATr_SIZE
typedef BCM56800_A0_MAC_RXLSSSTATr_t MAC_RXLSSSTATr_t;
#define MAC_RXLSSSTATr_CLR BCM56800_A0_MAC_RXLSSSTATr_CLR
#define MAC_RXLSSSTATr_SET BCM56800_A0_MAC_RXLSSSTATr_SET
#define MAC_RXLSSSTATr_GET BCM56800_A0_MAC_RXLSSSTATr_GET
#define MAC_RXLSSSTATr_LOCALFAULTSTATf_GET BCM56800_A0_MAC_RXLSSSTATr_LOCALFAULTSTATf_GET
#define MAC_RXLSSSTATr_LOCALFAULTSTATf_SET BCM56800_A0_MAC_RXLSSSTATr_LOCALFAULTSTATf_SET
#define MAC_RXLSSSTATr_REMOTEFAULTSTATf_GET BCM56800_A0_MAC_RXLSSSTATr_REMOTEFAULTSTATf_GET
#define MAC_RXLSSSTATr_REMOTEFAULTSTATf_SET BCM56800_A0_MAC_RXLSSSTATr_REMOTEFAULTSTATf_SET
#define READ_MAC_RXLSSSTATr BCM56800_A0_READ_MAC_RXLSSSTATr
#define WRITE_MAC_RXLSSSTATr BCM56800_A0_WRITE_MAC_RXLSSSTATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_RXLSSSTATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_RxLlfcMsgFlds
 * BLOCKS:   GXPORT
 * DESC:     Programmable RX LLFC Message fields
 * SIZE:     64
 * FIELDS:
 *     LLFC_MSG_TYPE_LOGICAL Value used to decode dw0_byte1 of incoming LLFC message
 *     LLFC_FC_OBJ_LOGICAL Value used to decode dw1_byte0 of incoming LLFC message
 *     LLFC_MSG_TYPE_PHYSICAL Value used to decode dw0_byte1 of incoming PLFC message
 *     LLFC_FC_OBJ_PHYSICAL Value used to decode dw1_byte0 of incoming PLFC message
 *     LLFC_EN          This bit enables llfc for Rx path in Bigmac, works with llfc_en in xport
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr 0x00f00046

#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxLlfcMsgFlds.
 *
 */
typedef union BCM56800_A0_MAC_RXLLFCMSGFLDSr_s {
	uint32_t v[2];
	uint32_t mac_rxllfcmsgflds[2];
	uint32_t _mac_rxllfcmsgflds;
} BCM56800_A0_MAC_RXLLFCMSGFLDSr_t;

#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_CLR(r) CDK_MEMSET(&((r)._mac_rxllfcmsgflds), 0, sizeof(BCM56800_A0_MAC_RXLLFCMSGFLDSr_t))
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_SET(r,i,d) (r).mac_rxllfcmsgflds[i] = d
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_GET(r,i) (r).mac_rxllfcmsgflds[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_GET(r) (((r).mac_rxllfcmsgflds[0]) & 0xff)
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_SET(r,f) (r).mac_rxllfcmsgflds[0]=(((r).mac_rxllfcmsgflds[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_GET(r) ((((r).mac_rxllfcmsgflds[0]) >> 8) & 0xf)
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_SET(r,f) (r).mac_rxllfcmsgflds[0]=(((r).mac_rxllfcmsgflds[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_PHYSICALf_GET(r) ((((r).mac_rxllfcmsgflds[0]) >> 12) & 0xff)
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_PHYSICALf_SET(r,f) (r).mac_rxllfcmsgflds[0]=(((r).mac_rxllfcmsgflds[0] & ~((uint32_t)0xff << 12)) | ((((uint32_t)f) & 0xff) << 12))
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_PHYSICALf_GET(r) ((((r).mac_rxllfcmsgflds[0]) >> 20) & 0xf)
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_PHYSICALf_SET(r,f) (r).mac_rxllfcmsgflds[0]=(((r).mac_rxllfcmsgflds[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_ENf_GET(r) ((((r).mac_rxllfcmsgflds[0]) >> 24) & 0x1)
#define BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_ENf_SET(r,f) (r).mac_rxllfcmsgflds[0]=(((r).mac_rxllfcmsgflds[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access MAC_RxLlfcMsgFlds.
 *
 */
#define BCM56800_A0_READ_MAC_RXLLFCMSGFLDSr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_RXLLFCMSGFLDSr,(r._mac_rxllfcmsgflds))
#define BCM56800_A0_WRITE_MAC_RXLLFCMSGFLDSr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_RXLLFCMSGFLDSr,&(r._mac_rxllfcmsgflds))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXLLFCMSGFLDSr BCM56800_A0_MAC_RXLLFCMSGFLDSr
#define MAC_RXLLFCMSGFLDSr_SIZE BCM56800_A0_MAC_RXLLFCMSGFLDSr_SIZE
typedef BCM56800_A0_MAC_RXLLFCMSGFLDSr_t MAC_RXLLFCMSGFLDSr_t;
#define MAC_RXLLFCMSGFLDSr_CLR BCM56800_A0_MAC_RXLLFCMSGFLDSr_CLR
#define MAC_RXLLFCMSGFLDSr_SET BCM56800_A0_MAC_RXLLFCMSGFLDSr_SET
#define MAC_RXLLFCMSGFLDSr_GET BCM56800_A0_MAC_RXLLFCMSGFLDSr_GET
#define MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_GET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_GET
#define MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_SET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_SET
#define MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_GET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_GET
#define MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_SET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_SET
#define MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_PHYSICALf_GET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_PHYSICALf_GET
#define MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_PHYSICALf_SET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_MSG_TYPE_PHYSICALf_SET
#define MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_PHYSICALf_GET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_PHYSICALf_GET
#define MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_PHYSICALf_SET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_FC_OBJ_PHYSICALf_SET
#define MAC_RXLLFCMSGFLDSr_LLFC_ENf_GET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_ENf_GET
#define MAC_RXLLFCMSGFLDSr_LLFC_ENf_SET BCM56800_A0_MAC_RXLLFCMSGFLDSr_LLFC_ENf_SET
#define READ_MAC_RXLLFCMSGFLDSr BCM56800_A0_READ_MAC_RXLLFCMSGFLDSr
#define WRITE_MAC_RXLLFCMSGFLDSr BCM56800_A0_WRITE_MAC_RXLLFCMSGFLDSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_RXLLFCMSGFLDSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_RxMACSA
 * BLOCKS:   GXPORT
 * DESC:     Receive source address.
 * SIZE:     64
 * FIELDS:
 *     SA               SA recognized for MAC control packets in addition to the standard 0x0180C2000001. 
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_RXMACSAr 0x00f00022

#define BCM56800_A0_MAC_RXMACSAr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxMACSA.
 *
 */
typedef union BCM56800_A0_MAC_RXMACSAr_s {
	uint32_t v[2];
	uint32_t mac_rxmacsa[2];
	uint32_t _mac_rxmacsa;
} BCM56800_A0_MAC_RXMACSAr_t;

#define BCM56800_A0_MAC_RXMACSAr_CLR(r) CDK_MEMSET(&((r)._mac_rxmacsa), 0, sizeof(BCM56800_A0_MAC_RXMACSAr_t))
#define BCM56800_A0_MAC_RXMACSAr_SET(r,i,d) (r).mac_rxmacsa[i] = d
#define BCM56800_A0_MAC_RXMACSAr_GET(r,i) (r).mac_rxmacsa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_RXMACSAr_SAf_GET(r,a) cdk_field_get((r).mac_rxmacsa,0,47,a)
#define BCM56800_A0_MAC_RXMACSAr_SAf_SET(r,a) cdk_field_set((r).mac_rxmacsa,0,47,a)

/*
 * These macros can be used to access MAC_RxMACSA.
 *
 */
#define BCM56800_A0_READ_MAC_RXMACSAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_RXMACSAr,(r._mac_rxmacsa))
#define BCM56800_A0_WRITE_MAC_RXMACSAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_RXMACSAr,&(r._mac_rxmacsa))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXMACSAr BCM56800_A0_MAC_RXMACSAr
#define MAC_RXMACSAr_SIZE BCM56800_A0_MAC_RXMACSAr_SIZE
typedef BCM56800_A0_MAC_RXMACSAr_t MAC_RXMACSAr_t;
#define MAC_RXMACSAr_CLR BCM56800_A0_MAC_RXMACSAr_CLR
#define MAC_RXMACSAr_SET BCM56800_A0_MAC_RXMACSAr_SET
#define MAC_RXMACSAr_GET BCM56800_A0_MAC_RXMACSAr_GET
#define MAC_RXMACSAr_SAf_GET BCM56800_A0_MAC_RXMACSAr_SAf_GET
#define MAC_RXMACSAr_SAf_SET BCM56800_A0_MAC_RXMACSAr_SAf_SET
#define READ_MAC_RXMACSAr BCM56800_A0_READ_MAC_RXMACSAr
#define WRITE_MAC_RXMACSAr BCM56800_A0_WRITE_MAC_RXMACSAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_RXMACSAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_RxMaxSz
 * BLOCKS:   GXPORT
 * DESC:     Receive maximum packet size.
 * SIZE:     64
 * FIELDS:
 *     SZ               Maximum byte size of packet received by the MAC.Legal range is 64 to 16360 inclusive.Does not include preamble in IEEE mode or CRC in STRIP mode.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_RXMAXSZr 0x00f00023

#define BCM56800_A0_MAC_RXMAXSZr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxMaxSz.
 *
 */
typedef union BCM56800_A0_MAC_RXMAXSZr_s {
	uint32_t v[2];
	uint32_t mac_rxmaxsz[2];
	uint32_t _mac_rxmaxsz;
} BCM56800_A0_MAC_RXMAXSZr_t;

#define BCM56800_A0_MAC_RXMAXSZr_CLR(r) CDK_MEMSET(&((r)._mac_rxmaxsz), 0, sizeof(BCM56800_A0_MAC_RXMAXSZr_t))
#define BCM56800_A0_MAC_RXMAXSZr_SET(r,i,d) (r).mac_rxmaxsz[i] = d
#define BCM56800_A0_MAC_RXMAXSZr_GET(r,i) (r).mac_rxmaxsz[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_RXMAXSZr_SZf_GET(r) (((r).mac_rxmaxsz[0]) & 0x3fff)
#define BCM56800_A0_MAC_RXMAXSZr_SZf_SET(r,f) (r).mac_rxmaxsz[0]=(((r).mac_rxmaxsz[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access MAC_RxMaxSz.
 *
 */
#define BCM56800_A0_READ_MAC_RXMAXSZr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_RXMAXSZr,(r._mac_rxmaxsz))
#define BCM56800_A0_WRITE_MAC_RXMAXSZr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_RXMAXSZr,&(r._mac_rxmaxsz))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXMAXSZr BCM56800_A0_MAC_RXMAXSZr
#define MAC_RXMAXSZr_SIZE BCM56800_A0_MAC_RXMAXSZr_SIZE
typedef BCM56800_A0_MAC_RXMAXSZr_t MAC_RXMAXSZr_t;
#define MAC_RXMAXSZr_CLR BCM56800_A0_MAC_RXMAXSZr_CLR
#define MAC_RXMAXSZr_SET BCM56800_A0_MAC_RXMAXSZr_SET
#define MAC_RXMAXSZr_GET BCM56800_A0_MAC_RXMAXSZr_GET
#define MAC_RXMAXSZr_SZf_GET BCM56800_A0_MAC_RXMAXSZr_SZf_GET
#define MAC_RXMAXSZr_SZf_SET BCM56800_A0_MAC_RXMAXSZr_SZf_SET
#define READ_MAC_RXMAXSZr BCM56800_A0_READ_MAC_RXMAXSZr
#define WRITE_MAC_RXMAXSZr BCM56800_A0_WRITE_MAC_RXMAXSZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_RXMAXSZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_RxMuxCtrl
 * BLOCKS:   GXPORT
 * DESC:     Receive test mux control.
 * SIZE:     64
 * FIELDS:
 *     EN               Drive muxed Rx data.
 *     PASSTHRU         Drive rxmux_data_out and rxmux_clk_out from rxmux_data_in and rxmux_clk_in. 
 *     LANE             Selects which lane to output.
 *     TSTMUX           Pass test mux bits from XGXS_IP core on high lane of the Rx mux chain.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_RXMUXCTRLr 0x00f00004

#define BCM56800_A0_MAC_RXMUXCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxMuxCtrl.
 *
 */
typedef union BCM56800_A0_MAC_RXMUXCTRLr_s {
	uint32_t v[2];
	uint32_t mac_rxmuxctrl[2];
	uint32_t _mac_rxmuxctrl;
} BCM56800_A0_MAC_RXMUXCTRLr_t;

#define BCM56800_A0_MAC_RXMUXCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_rxmuxctrl), 0, sizeof(BCM56800_A0_MAC_RXMUXCTRLr_t))
#define BCM56800_A0_MAC_RXMUXCTRLr_SET(r,i,d) (r).mac_rxmuxctrl[i] = d
#define BCM56800_A0_MAC_RXMUXCTRLr_GET(r,i) (r).mac_rxmuxctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_RXMUXCTRLr_ENf_GET(r) (((r).mac_rxmuxctrl[0]) & 0x1)
#define BCM56800_A0_MAC_RXMUXCTRLr_ENf_SET(r,f) (r).mac_rxmuxctrl[0]=(((r).mac_rxmuxctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MAC_RXMUXCTRLr_PASSTHRUf_GET(r) ((((r).mac_rxmuxctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_MAC_RXMUXCTRLr_PASSTHRUf_SET(r,f) (r).mac_rxmuxctrl[0]=(((r).mac_rxmuxctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MAC_RXMUXCTRLr_LANEf_GET(r) ((((r).mac_rxmuxctrl[0]) >> 2) & 0x3)
#define BCM56800_A0_MAC_RXMUXCTRLr_LANEf_SET(r,f) (r).mac_rxmuxctrl[0]=(((r).mac_rxmuxctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_MAC_RXMUXCTRLr_TSTMUXf_GET(r) ((((r).mac_rxmuxctrl[0]) >> 4) & 0x1)
#define BCM56800_A0_MAC_RXMUXCTRLr_TSTMUXf_SET(r,f) (r).mac_rxmuxctrl[0]=(((r).mac_rxmuxctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access MAC_RxMuxCtrl.
 *
 */
#define BCM56800_A0_READ_MAC_RXMUXCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_RXMUXCTRLr,(r._mac_rxmuxctrl))
#define BCM56800_A0_WRITE_MAC_RXMUXCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_RXMUXCTRLr,&(r._mac_rxmuxctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXMUXCTRLr BCM56800_A0_MAC_RXMUXCTRLr
#define MAC_RXMUXCTRLr_SIZE BCM56800_A0_MAC_RXMUXCTRLr_SIZE
typedef BCM56800_A0_MAC_RXMUXCTRLr_t MAC_RXMUXCTRLr_t;
#define MAC_RXMUXCTRLr_CLR BCM56800_A0_MAC_RXMUXCTRLr_CLR
#define MAC_RXMUXCTRLr_SET BCM56800_A0_MAC_RXMUXCTRLr_SET
#define MAC_RXMUXCTRLr_GET BCM56800_A0_MAC_RXMUXCTRLr_GET
#define MAC_RXMUXCTRLr_ENf_GET BCM56800_A0_MAC_RXMUXCTRLr_ENf_GET
#define MAC_RXMUXCTRLr_ENf_SET BCM56800_A0_MAC_RXMUXCTRLr_ENf_SET
#define MAC_RXMUXCTRLr_PASSTHRUf_GET BCM56800_A0_MAC_RXMUXCTRLr_PASSTHRUf_GET
#define MAC_RXMUXCTRLr_PASSTHRUf_SET BCM56800_A0_MAC_RXMUXCTRLr_PASSTHRUf_SET
#define MAC_RXMUXCTRLr_LANEf_GET BCM56800_A0_MAC_RXMUXCTRLr_LANEf_GET
#define MAC_RXMUXCTRLr_LANEf_SET BCM56800_A0_MAC_RXMUXCTRLr_LANEf_SET
#define MAC_RXMUXCTRLr_TSTMUXf_GET BCM56800_A0_MAC_RXMUXCTRLr_TSTMUXf_GET
#define MAC_RXMUXCTRLr_TSTMUXf_SET BCM56800_A0_MAC_RXMUXCTRLr_TSTMUXf_SET
#define READ_MAC_RXMUXCTRLr BCM56800_A0_READ_MAC_RXMUXCTRLr
#define WRITE_MAC_RXMUXCTRLr BCM56800_A0_WRITE_MAC_RXMUXCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_RXMUXCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_RxSpare0
 * BLOCKS:   GXPORT
 * DESC:     Control for LSS (ordered set) messages
 * SIZE:     64
 * FIELDS:
 *     SPARE            SPARE REGISTERS 0
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_RXSPARE0r 0x00f00025

#define BCM56800_A0_MAC_RXSPARE0r_SIZE 8

/*
 * This structure should be used to declare and program MAC_RxSpare0.
 *
 */
typedef union BCM56800_A0_MAC_RXSPARE0r_s {
	uint32_t v[2];
	uint32_t mac_rxspare0[2];
	uint32_t _mac_rxspare0;
} BCM56800_A0_MAC_RXSPARE0r_t;

#define BCM56800_A0_MAC_RXSPARE0r_CLR(r) CDK_MEMSET(&((r)._mac_rxspare0), 0, sizeof(BCM56800_A0_MAC_RXSPARE0r_t))
#define BCM56800_A0_MAC_RXSPARE0r_SET(r,i,d) (r).mac_rxspare0[i] = d
#define BCM56800_A0_MAC_RXSPARE0r_GET(r,i) (r).mac_rxspare0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_RXSPARE0r_SPAREf_GET(r) ((r).mac_rxspare0[0])
#define BCM56800_A0_MAC_RXSPARE0r_SPAREf_SET(r,f) (r).mac_rxspare0[0]=((uint32_t)f)

/*
 * These macros can be used to access MAC_RxSpare0.
 *
 */
#define BCM56800_A0_READ_MAC_RXSPARE0r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_RXSPARE0r,(r._mac_rxspare0))
#define BCM56800_A0_WRITE_MAC_RXSPARE0r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_RXSPARE0r,&(r._mac_rxspare0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_RXSPARE0r BCM56800_A0_MAC_RXSPARE0r
#define MAC_RXSPARE0r_SIZE BCM56800_A0_MAC_RXSPARE0r_SIZE
typedef BCM56800_A0_MAC_RXSPARE0r_t MAC_RXSPARE0r_t;
#define MAC_RXSPARE0r_CLR BCM56800_A0_MAC_RXSPARE0r_CLR
#define MAC_RXSPARE0r_SET BCM56800_A0_MAC_RXSPARE0r_SET
#define MAC_RXSPARE0r_GET BCM56800_A0_MAC_RXSPARE0r_GET
#define MAC_RXSPARE0r_SPAREf_GET BCM56800_A0_MAC_RXSPARE0r_SPAREf_GET
#define MAC_RXSPARE0r_SPAREf_SET BCM56800_A0_MAC_RXSPARE0r_SPAREf_SET
#define READ_MAC_RXSPARE0r BCM56800_A0_READ_MAC_RXSPARE0r
#define WRITE_MAC_RXSPARE0r BCM56800_A0_WRITE_MAC_RXSPARE0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_RXSPARE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TX_STATUS
 * BLOCKS:   GXPORT
 * DESC:      TriMAC tx status register
 * SIZE:     32
 * FIELDS:
 *     TXFIFO_ERR       When set, indicates TriMAC tx fifo underrun occur.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TX_STATUSr 0x00f00303

#define BCM56800_A0_MAC_TX_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MAC_TX_STATUS.
 *
 */
typedef union BCM56800_A0_MAC_TX_STATUSr_s {
	uint32_t v[1];
	uint32_t mac_tx_status[1];
	uint32_t _mac_tx_status;
} BCM56800_A0_MAC_TX_STATUSr_t;

#define BCM56800_A0_MAC_TX_STATUSr_CLR(r) (r).mac_tx_status[0] = 0
#define BCM56800_A0_MAC_TX_STATUSr_SET(r,d) (r).mac_tx_status[0] = d
#define BCM56800_A0_MAC_TX_STATUSr_GET(r) (r).mac_tx_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TX_STATUSr_TXFIFO_ERRf_GET(r) (((r).mac_tx_status[0]) & 0x1)
#define BCM56800_A0_MAC_TX_STATUSr_TXFIFO_ERRf_SET(r,f) (r).mac_tx_status[0]=(((r).mac_tx_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MAC_TX_STATUS.
 *
 */
#define BCM56800_A0_READ_MAC_TX_STATUSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MAC_TX_STATUSr,(r._mac_tx_status))
#define BCM56800_A0_WRITE_MAC_TX_STATUSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MAC_TX_STATUSr,&(r._mac_tx_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TX_STATUSr BCM56800_A0_MAC_TX_STATUSr
#define MAC_TX_STATUSr_SIZE BCM56800_A0_MAC_TX_STATUSr_SIZE
typedef BCM56800_A0_MAC_TX_STATUSr_t MAC_TX_STATUSr_t;
#define MAC_TX_STATUSr_CLR BCM56800_A0_MAC_TX_STATUSr_CLR
#define MAC_TX_STATUSr_SET BCM56800_A0_MAC_TX_STATUSr_SET
#define MAC_TX_STATUSr_GET BCM56800_A0_MAC_TX_STATUSr_GET
#define MAC_TX_STATUSr_TXFIFO_ERRf_GET BCM56800_A0_MAC_TX_STATUSr_TXFIFO_ERRf_GET
#define MAC_TX_STATUSr_TXFIFO_ERRf_SET BCM56800_A0_MAC_TX_STATUSr_TXFIFO_ERRf_SET
#define READ_MAC_TX_STATUSr BCM56800_A0_READ_MAC_TX_STATUSr
#define WRITE_MAC_TX_STATUSr BCM56800_A0_WRITE_MAC_TX_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TX_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TxCtrl
 * BLOCKS:   GXPORT
 * DESC:     Transmit control.
 * SIZE:     64
 * FIELDS:
 *     HDRMODE          Header mode.
 *     CRC_MODE         CRC mode.
 *     AVGIPG           Average interpacket gap. Must be >=8.
 *     THROTNUM         Number of bytes of extra interpacket gap to be forced whenever txThrotDemon bytes have been transmitted. 
 *     THROTDENOM       Number of bytes to transmite before adding txThrotNumer bytes to the IPG. 
 *     PAUSEEN          Send PAUSE packets whenever TxPause input is true.
 *     DISCARD          Accept packets from the host but do not transmit.  Transmite must be enabled. 
 *     ANYSTART         Don\'t force the first byte of a packet to be /Start
 *     HIGIG2MODE       Port in Higig2 Mode
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TXCTRLr 0x00f00007

#define BCM56800_A0_MAC_TXCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxCtrl.
 *
 */
typedef union BCM56800_A0_MAC_TXCTRLr_s {
	uint32_t v[2];
	uint32_t mac_txctrl[2];
	uint32_t _mac_txctrl;
} BCM56800_A0_MAC_TXCTRLr_t;

#define BCM56800_A0_MAC_TXCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_txctrl), 0, sizeof(BCM56800_A0_MAC_TXCTRLr_t))
#define BCM56800_A0_MAC_TXCTRLr_SET(r,i,d) (r).mac_txctrl[i] = d
#define BCM56800_A0_MAC_TXCTRLr_GET(r,i) (r).mac_txctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TXCTRLr_HDRMODEf_GET(r) (((r).mac_txctrl[0]) & 0x3)
#define BCM56800_A0_MAC_TXCTRLr_HDRMODEf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_MAC_TXCTRLr_CRC_MODEf_GET(r) ((((r).mac_txctrl[0]) >> 2) & 0x3)
#define BCM56800_A0_MAC_TXCTRLr_CRC_MODEf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_MAC_TXCTRLr_AVGIPGf_GET(r) ((((r).mac_txctrl[0]) >> 4) & 0x1f)
#define BCM56800_A0_MAC_TXCTRLr_AVGIPGf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM56800_A0_MAC_TXCTRLr_THROTNUMf_GET(r) ((((r).mac_txctrl[0]) >> 9) & 0x3f)
#define BCM56800_A0_MAC_TXCTRLr_THROTNUMf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM56800_A0_MAC_TXCTRLr_THROTDENOMf_GET(r) ((((r).mac_txctrl[0]) >> 15) & 0xff)
#define BCM56800_A0_MAC_TXCTRLr_THROTDENOMf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0xff << 15)) | ((((uint32_t)f) & 0xff) << 15))
#define BCM56800_A0_MAC_TXCTRLr_PAUSEENf_GET(r) ((((r).mac_txctrl[0]) >> 23) & 0x1)
#define BCM56800_A0_MAC_TXCTRLr_PAUSEENf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_MAC_TXCTRLr_DISCARDf_GET(r) ((((r).mac_txctrl[0]) >> 24) & 0x1)
#define BCM56800_A0_MAC_TXCTRLr_DISCARDf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_MAC_TXCTRLr_ANYSTARTf_GET(r) ((((r).mac_txctrl[0]) >> 25) & 0x1)
#define BCM56800_A0_MAC_TXCTRLr_ANYSTARTf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_MAC_TXCTRLr_HIGIG2MODEf_GET(r) ((((r).mac_txctrl[0]) >> 26) & 0x1)
#define BCM56800_A0_MAC_TXCTRLr_HIGIG2MODEf_SET(r,f) (r).mac_txctrl[0]=(((r).mac_txctrl[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MAC_TxCtrl.
 *
 */
#define BCM56800_A0_READ_MAC_TXCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_TXCTRLr,(r._mac_txctrl))
#define BCM56800_A0_WRITE_MAC_TXCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_TXCTRLr,&(r._mac_txctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXCTRLr BCM56800_A0_MAC_TXCTRLr
#define MAC_TXCTRLr_SIZE BCM56800_A0_MAC_TXCTRLr_SIZE
typedef BCM56800_A0_MAC_TXCTRLr_t MAC_TXCTRLr_t;
#define MAC_TXCTRLr_CLR BCM56800_A0_MAC_TXCTRLr_CLR
#define MAC_TXCTRLr_SET BCM56800_A0_MAC_TXCTRLr_SET
#define MAC_TXCTRLr_GET BCM56800_A0_MAC_TXCTRLr_GET
#define MAC_TXCTRLr_HDRMODEf_GET BCM56800_A0_MAC_TXCTRLr_HDRMODEf_GET
#define MAC_TXCTRLr_HDRMODEf_SET BCM56800_A0_MAC_TXCTRLr_HDRMODEf_SET
#define MAC_TXCTRLr_CRC_MODEf_GET BCM56800_A0_MAC_TXCTRLr_CRC_MODEf_GET
#define MAC_TXCTRLr_CRC_MODEf_SET BCM56800_A0_MAC_TXCTRLr_CRC_MODEf_SET
#define MAC_TXCTRLr_AVGIPGf_GET BCM56800_A0_MAC_TXCTRLr_AVGIPGf_GET
#define MAC_TXCTRLr_AVGIPGf_SET BCM56800_A0_MAC_TXCTRLr_AVGIPGf_SET
#define MAC_TXCTRLr_THROTNUMf_GET BCM56800_A0_MAC_TXCTRLr_THROTNUMf_GET
#define MAC_TXCTRLr_THROTNUMf_SET BCM56800_A0_MAC_TXCTRLr_THROTNUMf_SET
#define MAC_TXCTRLr_THROTDENOMf_GET BCM56800_A0_MAC_TXCTRLr_THROTDENOMf_GET
#define MAC_TXCTRLr_THROTDENOMf_SET BCM56800_A0_MAC_TXCTRLr_THROTDENOMf_SET
#define MAC_TXCTRLr_PAUSEENf_GET BCM56800_A0_MAC_TXCTRLr_PAUSEENf_GET
#define MAC_TXCTRLr_PAUSEENf_SET BCM56800_A0_MAC_TXCTRLr_PAUSEENf_SET
#define MAC_TXCTRLr_DISCARDf_GET BCM56800_A0_MAC_TXCTRLr_DISCARDf_GET
#define MAC_TXCTRLr_DISCARDf_SET BCM56800_A0_MAC_TXCTRLr_DISCARDf_SET
#define MAC_TXCTRLr_ANYSTARTf_GET BCM56800_A0_MAC_TXCTRLr_ANYSTARTf_GET
#define MAC_TXCTRLr_ANYSTARTf_SET BCM56800_A0_MAC_TXCTRLr_ANYSTARTf_SET
#define MAC_TXCTRLr_HIGIG2MODEf_GET BCM56800_A0_MAC_TXCTRLr_HIGIG2MODEf_GET
#define MAC_TXCTRLr_HIGIG2MODEf_SET BCM56800_A0_MAC_TXCTRLr_HIGIG2MODEf_SET
#define READ_MAC_TXCTRLr BCM56800_A0_READ_MAC_TXCTRLr
#define WRITE_MAC_TXCTRLr BCM56800_A0_WRITE_MAC_TXCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TXCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TxLlfcCtrl
 * BLOCKS:   GXPORT
 * DESC:     TX LLFC Control Reg.
 * SIZE:     64
 * FIELDS:
 *     LLFC_EN          This bit enables llfc for Tx path in Bigmac, works with llfc_en in xport
 *     LLFC_IN_IPG_ONLY When set, LLFC is inserted only during IPG
 *     LLFC_CUT_THROUGH_MODE When set and llfc_in_ipg_only =0, GXPORT operates in cut-through mode
 *     LLFC_IMG         The minimum Inter Message gap that must be observed between 2 HG2 Messages
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TXLLFCCTRLr 0x00f00044

#define BCM56800_A0_MAC_TXLLFCCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxLlfcCtrl.
 *
 */
typedef union BCM56800_A0_MAC_TXLLFCCTRLr_s {
	uint32_t v[2];
	uint32_t mac_txllfcctrl[2];
	uint32_t _mac_txllfcctrl;
} BCM56800_A0_MAC_TXLLFCCTRLr_t;

#define BCM56800_A0_MAC_TXLLFCCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_txllfcctrl), 0, sizeof(BCM56800_A0_MAC_TXLLFCCTRLr_t))
#define BCM56800_A0_MAC_TXLLFCCTRLr_SET(r,i,d) (r).mac_txllfcctrl[i] = d
#define BCM56800_A0_MAC_TXLLFCCTRLr_GET(r,i) (r).mac_txllfcctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_ENf_GET(r) (((r).mac_txllfcctrl[0]) & 0x1)
#define BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_ENf_SET(r,f) (r).mac_txllfcctrl[0]=(((r).mac_txllfcctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_IN_IPG_ONLYf_GET(r) ((((r).mac_txllfcctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_IN_IPG_ONLYf_SET(r,f) (r).mac_txllfcctrl[0]=(((r).mac_txllfcctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_CUT_THROUGH_MODEf_GET(r) ((((r).mac_txllfcctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_CUT_THROUGH_MODEf_SET(r,f) (r).mac_txllfcctrl[0]=(((r).mac_txllfcctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_IMGf_GET(r) ((((r).mac_txllfcctrl[0]) >> 3) & 0xff)
#define BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_IMGf_SET(r,f) (r).mac_txllfcctrl[0]=(((r).mac_txllfcctrl[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))

/*
 * These macros can be used to access MAC_TxLlfcCtrl.
 *
 */
#define BCM56800_A0_READ_MAC_TXLLFCCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_TXLLFCCTRLr,(r._mac_txllfcctrl))
#define BCM56800_A0_WRITE_MAC_TXLLFCCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_TXLLFCCTRLr,&(r._mac_txllfcctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXLLFCCTRLr BCM56800_A0_MAC_TXLLFCCTRLr
#define MAC_TXLLFCCTRLr_SIZE BCM56800_A0_MAC_TXLLFCCTRLr_SIZE
typedef BCM56800_A0_MAC_TXLLFCCTRLr_t MAC_TXLLFCCTRLr_t;
#define MAC_TXLLFCCTRLr_CLR BCM56800_A0_MAC_TXLLFCCTRLr_CLR
#define MAC_TXLLFCCTRLr_SET BCM56800_A0_MAC_TXLLFCCTRLr_SET
#define MAC_TXLLFCCTRLr_GET BCM56800_A0_MAC_TXLLFCCTRLr_GET
#define MAC_TXLLFCCTRLr_LLFC_ENf_GET BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_ENf_GET
#define MAC_TXLLFCCTRLr_LLFC_ENf_SET BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_ENf_SET
#define MAC_TXLLFCCTRLr_LLFC_IN_IPG_ONLYf_GET BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_IN_IPG_ONLYf_GET
#define MAC_TXLLFCCTRLr_LLFC_IN_IPG_ONLYf_SET BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_IN_IPG_ONLYf_SET
#define MAC_TXLLFCCTRLr_LLFC_CUT_THROUGH_MODEf_GET BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_CUT_THROUGH_MODEf_GET
#define MAC_TXLLFCCTRLr_LLFC_CUT_THROUGH_MODEf_SET BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_CUT_THROUGH_MODEf_SET
#define MAC_TXLLFCCTRLr_LLFC_IMGf_GET BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_IMGf_GET
#define MAC_TXLLFCCTRLr_LLFC_IMGf_SET BCM56800_A0_MAC_TXLLFCCTRLr_LLFC_IMGf_SET
#define READ_MAC_TXLLFCCTRLr BCM56800_A0_READ_MAC_TXLLFCCTRLr
#define WRITE_MAC_TXLLFCCTRLr BCM56800_A0_WRITE_MAC_TXLLFCCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TXLLFCCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TxLlfcMsgFlds
 * BLOCKS:   GXPORT
 * DESC:     Programmable TX LLFC Message fields.
 * SIZE:     64
 * FIELDS:
 *     LLFC_MSG_TYPE_LOGICAL Value used for dw0_byte1 of outgoing LLFC message
 *     LLFC_FC_OBJ_LOGICAL Value used for dw1_byte0 of outgoing LLFC message
 *     LLFC_XOFF_TIME   Value used for DW2_byte2 and DW2_byte3 of the outgoing LLFC messages
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr 0x00f00045

#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxLlfcMsgFlds.
 *
 */
typedef union BCM56800_A0_MAC_TXLLFCMSGFLDSr_s {
	uint32_t v[2];
	uint32_t mac_txllfcmsgflds[2];
	uint32_t _mac_txllfcmsgflds;
} BCM56800_A0_MAC_TXLLFCMSGFLDSr_t;

#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_CLR(r) CDK_MEMSET(&((r)._mac_txllfcmsgflds), 0, sizeof(BCM56800_A0_MAC_TXLLFCMSGFLDSr_t))
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_SET(r,i,d) (r).mac_txllfcmsgflds[i] = d
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_GET(r,i) (r).mac_txllfcmsgflds[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_GET(r) (((r).mac_txllfcmsgflds[0]) & 0xff)
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_SET(r,f) (r).mac_txllfcmsgflds[0]=(((r).mac_txllfcmsgflds[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_GET(r) ((((r).mac_txllfcmsgflds[0]) >> 8) & 0xf)
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_SET(r,f) (r).mac_txllfcmsgflds[0]=(((r).mac_txllfcmsgflds[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_XOFF_TIMEf_GET(r) ((((r).mac_txllfcmsgflds[0]) >> 12) & 0xffff)
#define BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_XOFF_TIMEf_SET(r,f) (r).mac_txllfcmsgflds[0]=(((r).mac_txllfcmsgflds[0] & ~((uint32_t)0xffff << 12)) | ((((uint32_t)f) & 0xffff) << 12))

/*
 * These macros can be used to access MAC_TxLlfcMsgFlds.
 *
 */
#define BCM56800_A0_READ_MAC_TXLLFCMSGFLDSr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_TXLLFCMSGFLDSr,(r._mac_txllfcmsgflds))
#define BCM56800_A0_WRITE_MAC_TXLLFCMSGFLDSr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_TXLLFCMSGFLDSr,&(r._mac_txllfcmsgflds))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXLLFCMSGFLDSr BCM56800_A0_MAC_TXLLFCMSGFLDSr
#define MAC_TXLLFCMSGFLDSr_SIZE BCM56800_A0_MAC_TXLLFCMSGFLDSr_SIZE
typedef BCM56800_A0_MAC_TXLLFCMSGFLDSr_t MAC_TXLLFCMSGFLDSr_t;
#define MAC_TXLLFCMSGFLDSr_CLR BCM56800_A0_MAC_TXLLFCMSGFLDSr_CLR
#define MAC_TXLLFCMSGFLDSr_SET BCM56800_A0_MAC_TXLLFCMSGFLDSr_SET
#define MAC_TXLLFCMSGFLDSr_GET BCM56800_A0_MAC_TXLLFCMSGFLDSr_GET
#define MAC_TXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_GET BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_GET
#define MAC_TXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_SET BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_MSG_TYPE_LOGICALf_SET
#define MAC_TXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_GET BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_GET
#define MAC_TXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_SET BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_FC_OBJ_LOGICALf_SET
#define MAC_TXLLFCMSGFLDSr_LLFC_XOFF_TIMEf_GET BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_XOFF_TIMEf_GET
#define MAC_TXLLFCMSGFLDSr_LLFC_XOFF_TIMEf_SET BCM56800_A0_MAC_TXLLFCMSGFLDSr_LLFC_XOFF_TIMEf_SET
#define READ_MAC_TXLLFCMSGFLDSr BCM56800_A0_READ_MAC_TXLLFCMSGFLDSr
#define WRITE_MAC_TXLLFCMSGFLDSr BCM56800_A0_WRITE_MAC_TXLLFCMSGFLDSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TXLLFCMSGFLDSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TxMACSA
 * BLOCKS:   GXPORT
 * DESC:     Transmit source address.
 * SIZE:     64
 * FIELDS:
 *     SA               Used as the SA in PAUSE packets transmitted by the MAC.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TXMACSAr 0x00f00008

#define BCM56800_A0_MAC_TXMACSAr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxMACSA.
 *
 */
typedef union BCM56800_A0_MAC_TXMACSAr_s {
	uint32_t v[2];
	uint32_t mac_txmacsa[2];
	uint32_t _mac_txmacsa;
} BCM56800_A0_MAC_TXMACSAr_t;

#define BCM56800_A0_MAC_TXMACSAr_CLR(r) CDK_MEMSET(&((r)._mac_txmacsa), 0, sizeof(BCM56800_A0_MAC_TXMACSAr_t))
#define BCM56800_A0_MAC_TXMACSAr_SET(r,i,d) (r).mac_txmacsa[i] = d
#define BCM56800_A0_MAC_TXMACSAr_GET(r,i) (r).mac_txmacsa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TXMACSAr_SAf_GET(r,a) cdk_field_get((r).mac_txmacsa,0,47,a)
#define BCM56800_A0_MAC_TXMACSAr_SAf_SET(r,a) cdk_field_set((r).mac_txmacsa,0,47,a)

/*
 * These macros can be used to access MAC_TxMACSA.
 *
 */
#define BCM56800_A0_READ_MAC_TXMACSAr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_TXMACSAr,(r._mac_txmacsa))
#define BCM56800_A0_WRITE_MAC_TXMACSAr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_TXMACSAr,&(r._mac_txmacsa))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXMACSAr BCM56800_A0_MAC_TXMACSAr
#define MAC_TXMACSAr_SIZE BCM56800_A0_MAC_TXMACSAr_SIZE
typedef BCM56800_A0_MAC_TXMACSAr_t MAC_TXMACSAr_t;
#define MAC_TXMACSAr_CLR BCM56800_A0_MAC_TXMACSAr_CLR
#define MAC_TXMACSAr_SET BCM56800_A0_MAC_TXMACSAr_SET
#define MAC_TXMACSAr_GET BCM56800_A0_MAC_TXMACSAr_GET
#define MAC_TXMACSAr_SAf_GET BCM56800_A0_MAC_TXMACSAr_SAf_GET
#define MAC_TXMACSAr_SAf_SET BCM56800_A0_MAC_TXMACSAr_SAf_SET
#define READ_MAC_TXMACSAr BCM56800_A0_READ_MAC_TXMACSAr
#define WRITE_MAC_TXMACSAr BCM56800_A0_WRITE_MAC_TXMACSAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TXMACSAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TxMaxSz
 * BLOCKS:   GXPORT
 * DESC:     Transmit maximum size.
 * SIZE:     64
 * FIELDS:
 *     SZ               Maximum byte size of packets transmitted by the MAC.Legal range is 64 to 16360 inclusive.The size represented here includes the added 8-byte preamble inIEEE mode but does not include the CRC in APPEND mode.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TXMAXSZr 0x00f00009

#define BCM56800_A0_MAC_TXMAXSZr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxMaxSz.
 *
 */
typedef union BCM56800_A0_MAC_TXMAXSZr_s {
	uint32_t v[2];
	uint32_t mac_txmaxsz[2];
	uint32_t _mac_txmaxsz;
} BCM56800_A0_MAC_TXMAXSZr_t;

#define BCM56800_A0_MAC_TXMAXSZr_CLR(r) CDK_MEMSET(&((r)._mac_txmaxsz), 0, sizeof(BCM56800_A0_MAC_TXMAXSZr_t))
#define BCM56800_A0_MAC_TXMAXSZr_SET(r,i,d) (r).mac_txmaxsz[i] = d
#define BCM56800_A0_MAC_TXMAXSZr_GET(r,i) (r).mac_txmaxsz[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TXMAXSZr_SZf_GET(r) (((r).mac_txmaxsz[0]) & 0x3fff)
#define BCM56800_A0_MAC_TXMAXSZr_SZf_SET(r,f) (r).mac_txmaxsz[0]=(((r).mac_txmaxsz[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access MAC_TxMaxSz.
 *
 */
#define BCM56800_A0_READ_MAC_TXMAXSZr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_TXMAXSZr,(r._mac_txmaxsz))
#define BCM56800_A0_WRITE_MAC_TXMAXSZr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_TXMAXSZr,&(r._mac_txmaxsz))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXMAXSZr BCM56800_A0_MAC_TXMAXSZr
#define MAC_TXMAXSZr_SIZE BCM56800_A0_MAC_TXMAXSZr_SIZE
typedef BCM56800_A0_MAC_TXMAXSZr_t MAC_TXMAXSZr_t;
#define MAC_TXMAXSZr_CLR BCM56800_A0_MAC_TXMAXSZr_CLR
#define MAC_TXMAXSZr_SET BCM56800_A0_MAC_TXMAXSZr_SET
#define MAC_TXMAXSZr_GET BCM56800_A0_MAC_TXMAXSZr_GET
#define MAC_TXMAXSZr_SZf_GET BCM56800_A0_MAC_TXMAXSZr_SZf_GET
#define MAC_TXMAXSZr_SZf_SET BCM56800_A0_MAC_TXMAXSZr_SZf_SET
#define READ_MAC_TXMAXSZr BCM56800_A0_READ_MAC_TXMAXSZr
#define WRITE_MAC_TXMAXSZr BCM56800_A0_WRITE_MAC_TXMAXSZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TXMAXSZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TxMuxCtrl
 * BLOCKS:   GXPORT
 * DESC:     Transmit test mux control.
 * SIZE:     64
 * FIELDS:
 *     OUTEN            Drive Tx data from the test bypass port.
 *     RINGEN           Drive txmux_data_out and txmux_clk_out.
 *     PASSTHRU         Drive txmux_data_out and txmux_clk_out from txmux_data_in and txmux_clk_in. 
 *     LANE             Lane select when RINGENBL==1 and PASSTHRU==0.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TXMUXCTRLr 0x00f00003

#define BCM56800_A0_MAC_TXMUXCTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxMuxCtrl.
 *
 */
typedef union BCM56800_A0_MAC_TXMUXCTRLr_s {
	uint32_t v[2];
	uint32_t mac_txmuxctrl[2];
	uint32_t _mac_txmuxctrl;
} BCM56800_A0_MAC_TXMUXCTRLr_t;

#define BCM56800_A0_MAC_TXMUXCTRLr_CLR(r) CDK_MEMSET(&((r)._mac_txmuxctrl), 0, sizeof(BCM56800_A0_MAC_TXMUXCTRLr_t))
#define BCM56800_A0_MAC_TXMUXCTRLr_SET(r,i,d) (r).mac_txmuxctrl[i] = d
#define BCM56800_A0_MAC_TXMUXCTRLr_GET(r,i) (r).mac_txmuxctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TXMUXCTRLr_OUTENf_GET(r) (((r).mac_txmuxctrl[0]) & 0x1)
#define BCM56800_A0_MAC_TXMUXCTRLr_OUTENf_SET(r,f) (r).mac_txmuxctrl[0]=(((r).mac_txmuxctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MAC_TXMUXCTRLr_RINGENf_GET(r) ((((r).mac_txmuxctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_MAC_TXMUXCTRLr_RINGENf_SET(r,f) (r).mac_txmuxctrl[0]=(((r).mac_txmuxctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MAC_TXMUXCTRLr_PASSTHRUf_GET(r) ((((r).mac_txmuxctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_MAC_TXMUXCTRLr_PASSTHRUf_SET(r,f) (r).mac_txmuxctrl[0]=(((r).mac_txmuxctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MAC_TXMUXCTRLr_LANEf_GET(r) ((((r).mac_txmuxctrl[0]) >> 3) & 0x3)
#define BCM56800_A0_MAC_TXMUXCTRLr_LANEf_SET(r,f) (r).mac_txmuxctrl[0]=(((r).mac_txmuxctrl[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))

/*
 * These macros can be used to access MAC_TxMuxCtrl.
 *
 */
#define BCM56800_A0_READ_MAC_TXMUXCTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_TXMUXCTRLr,(r._mac_txmuxctrl))
#define BCM56800_A0_WRITE_MAC_TXMUXCTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_TXMUXCTRLr,&(r._mac_txmuxctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXMUXCTRLr BCM56800_A0_MAC_TXMUXCTRLr
#define MAC_TXMUXCTRLr_SIZE BCM56800_A0_MAC_TXMUXCTRLr_SIZE
typedef BCM56800_A0_MAC_TXMUXCTRLr_t MAC_TXMUXCTRLr_t;
#define MAC_TXMUXCTRLr_CLR BCM56800_A0_MAC_TXMUXCTRLr_CLR
#define MAC_TXMUXCTRLr_SET BCM56800_A0_MAC_TXMUXCTRLr_SET
#define MAC_TXMUXCTRLr_GET BCM56800_A0_MAC_TXMUXCTRLr_GET
#define MAC_TXMUXCTRLr_OUTENf_GET BCM56800_A0_MAC_TXMUXCTRLr_OUTENf_GET
#define MAC_TXMUXCTRLr_OUTENf_SET BCM56800_A0_MAC_TXMUXCTRLr_OUTENf_SET
#define MAC_TXMUXCTRLr_RINGENf_GET BCM56800_A0_MAC_TXMUXCTRLr_RINGENf_GET
#define MAC_TXMUXCTRLr_RINGENf_SET BCM56800_A0_MAC_TXMUXCTRLr_RINGENf_SET
#define MAC_TXMUXCTRLr_PASSTHRUf_GET BCM56800_A0_MAC_TXMUXCTRLr_PASSTHRUf_GET
#define MAC_TXMUXCTRLr_PASSTHRUf_SET BCM56800_A0_MAC_TXMUXCTRLr_PASSTHRUf_SET
#define MAC_TXMUXCTRLr_LANEf_GET BCM56800_A0_MAC_TXMUXCTRLr_LANEf_GET
#define MAC_TXMUXCTRLr_LANEf_SET BCM56800_A0_MAC_TXMUXCTRLr_LANEf_SET
#define READ_MAC_TXMUXCTRLr BCM56800_A0_READ_MAC_TXMUXCTRLr
#define WRITE_MAC_TXMUXCTRLr BCM56800_A0_WRITE_MAC_TXMUXCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TXMUXCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TxPseThr
 * BLOCKS:   GXPORT
 * DESC:     Transmit PAUSE threshold.
 * SIZE:     64
 * FIELDS:
 *     XOFF             Threshold for pause timer to cause XOFF to be resent.
 *     XON              Threshold for pause timer before XON is sent.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TXPSETHRr 0x00f0000a

#define BCM56800_A0_MAC_TXPSETHRr_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxPseThr.
 *
 */
typedef union BCM56800_A0_MAC_TXPSETHRr_s {
	uint32_t v[2];
	uint32_t mac_txpsethr[2];
	uint32_t _mac_txpsethr;
} BCM56800_A0_MAC_TXPSETHRr_t;

#define BCM56800_A0_MAC_TXPSETHRr_CLR(r) CDK_MEMSET(&((r)._mac_txpsethr), 0, sizeof(BCM56800_A0_MAC_TXPSETHRr_t))
#define BCM56800_A0_MAC_TXPSETHRr_SET(r,i,d) (r).mac_txpsethr[i] = d
#define BCM56800_A0_MAC_TXPSETHRr_GET(r,i) (r).mac_txpsethr[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TXPSETHRr_XOFFf_GET(r) (((r).mac_txpsethr[0]) & 0xffff)
#define BCM56800_A0_MAC_TXPSETHRr_XOFFf_SET(r,f) (r).mac_txpsethr[0]=(((r).mac_txpsethr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_MAC_TXPSETHRr_XONf_GET(r) ((((r).mac_txpsethr[0]) >> 16) & 0xffff)
#define BCM56800_A0_MAC_TXPSETHRr_XONf_SET(r,f) (r).mac_txpsethr[0]=(((r).mac_txpsethr[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MAC_TxPseThr.
 *
 */
#define BCM56800_A0_READ_MAC_TXPSETHRr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_TXPSETHRr,(r._mac_txpsethr))
#define BCM56800_A0_WRITE_MAC_TXPSETHRr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_TXPSETHRr,&(r._mac_txpsethr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXPSETHRr BCM56800_A0_MAC_TXPSETHRr
#define MAC_TXPSETHRr_SIZE BCM56800_A0_MAC_TXPSETHRr_SIZE
typedef BCM56800_A0_MAC_TXPSETHRr_t MAC_TXPSETHRr_t;
#define MAC_TXPSETHRr_CLR BCM56800_A0_MAC_TXPSETHRr_CLR
#define MAC_TXPSETHRr_SET BCM56800_A0_MAC_TXPSETHRr_SET
#define MAC_TXPSETHRr_GET BCM56800_A0_MAC_TXPSETHRr_GET
#define MAC_TXPSETHRr_XOFFf_GET BCM56800_A0_MAC_TXPSETHRr_XOFFf_GET
#define MAC_TXPSETHRr_XOFFf_SET BCM56800_A0_MAC_TXPSETHRr_XOFFf_SET
#define MAC_TXPSETHRr_XONf_GET BCM56800_A0_MAC_TXPSETHRr_XONf_GET
#define MAC_TXPSETHRr_XONf_SET BCM56800_A0_MAC_TXPSETHRr_XONf_SET
#define READ_MAC_TXPSETHRr BCM56800_A0_READ_MAC_TXPSETHRr
#define WRITE_MAC_TXPSETHRr BCM56800_A0_WRITE_MAC_TXPSETHRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TXPSETHRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_TxSpare0
 * BLOCKS:   GXPORT
 * DESC:     Spare reg for ECO on TX clock domain
 * SIZE:     64
 * FIELDS:
 *     RSVD             SPARE REGISTERS 0
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_TXSPARE0r 0x00f0000b

#define BCM56800_A0_MAC_TXSPARE0r_SIZE 8

/*
 * This structure should be used to declare and program MAC_TxSpare0.
 *
 */
typedef union BCM56800_A0_MAC_TXSPARE0r_s {
	uint32_t v[2];
	uint32_t mac_txspare0[2];
	uint32_t _mac_txspare0;
} BCM56800_A0_MAC_TXSPARE0r_t;

#define BCM56800_A0_MAC_TXSPARE0r_CLR(r) CDK_MEMSET(&((r)._mac_txspare0), 0, sizeof(BCM56800_A0_MAC_TXSPARE0r_t))
#define BCM56800_A0_MAC_TXSPARE0r_SET(r,i,d) (r).mac_txspare0[i] = d
#define BCM56800_A0_MAC_TXSPARE0r_GET(r,i) (r).mac_txspare0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_TXSPARE0r_RSVDf_GET(r) ((r).mac_txspare0[0])
#define BCM56800_A0_MAC_TXSPARE0r_RSVDf_SET(r,f) (r).mac_txspare0[0]=((uint32_t)f)

/*
 * These macros can be used to access MAC_TxSpare0.
 *
 */
#define BCM56800_A0_READ_MAC_TXSPARE0r(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_TXSPARE0r,(r._mac_txspare0))
#define BCM56800_A0_WRITE_MAC_TXSPARE0r(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_TXSPARE0r,&(r._mac_txspare0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TXSPARE0r BCM56800_A0_MAC_TXSPARE0r
#define MAC_TXSPARE0r_SIZE BCM56800_A0_MAC_TXSPARE0r_SIZE
typedef BCM56800_A0_MAC_TXSPARE0r_t MAC_TXSPARE0r_t;
#define MAC_TXSPARE0r_CLR BCM56800_A0_MAC_TXSPARE0r_CLR
#define MAC_TXSPARE0r_SET BCM56800_A0_MAC_TXSPARE0r_SET
#define MAC_TXSPARE0r_GET BCM56800_A0_MAC_TXSPARE0r_GET
#define MAC_TXSPARE0r_RSVDf_GET BCM56800_A0_MAC_TXSPARE0r_RSVDf_GET
#define MAC_TXSPARE0r_RSVDf_SET BCM56800_A0_MAC_TXSPARE0r_RSVDf_SET
#define READ_MAC_TXSPARE0r BCM56800_A0_READ_MAC_TXSPARE0r
#define WRITE_MAC_TXSPARE0r BCM56800_A0_WRITE_MAC_TXSPARE0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_TXSPARE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_XGXS_Ctrl
 * BLOCKS:   GXPORT
 * DESC:     XGXS_IP control.
 * SIZE:     64
 * FIELDS:
 *     PWRDWN           Shutdown digital clocks.
 *     IDDQ             Shutdown analog clocks but leave analog section powered.
 *     HW_RSTL          Hard reset (active low).
 *     RSTB_MDIOREGS    Reset MDIO XGXS Regs (active low).
 *     RSTB_PLL         Reset XGXS PLL (active low).
 *     BIGMACRSTL       Bigmac reset (active low).
 *     TXFIFO_RSTL      Tx FIFO reset (active low).
 *     AFIFO_RST        Automatically reset Tx FIFO on over/underflow.
 *     PLLBYP           Bypass refclk PLL and run transmit and receive clocks from refclk pin.
 *     LCREFEN          Set to 1 to select clock from LCPLL - otherwise from clock pads.
 *     RESERVED         reserved
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_XGXS_CTRLr 0x00f00001

#define BCM56800_A0_MAC_XGXS_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program MAC_XGXS_Ctrl.
 *
 */
typedef union BCM56800_A0_MAC_XGXS_CTRLr_s {
	uint32_t v[2];
	uint32_t mac_xgxs_ctrl[2];
	uint32_t _mac_xgxs_ctrl;
} BCM56800_A0_MAC_XGXS_CTRLr_t;

#define BCM56800_A0_MAC_XGXS_CTRLr_CLR(r) CDK_MEMSET(&((r)._mac_xgxs_ctrl), 0, sizeof(BCM56800_A0_MAC_XGXS_CTRLr_t))
#define BCM56800_A0_MAC_XGXS_CTRLr_SET(r,i,d) (r).mac_xgxs_ctrl[i] = d
#define BCM56800_A0_MAC_XGXS_CTRLr_GET(r,i) (r).mac_xgxs_ctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_XGXS_CTRLr_PWRDWNf_GET(r) (((r).mac_xgxs_ctrl[0]) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_PWRDWNf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MAC_XGXS_CTRLr_IDDQf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_IDDQf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MAC_XGXS_CTRLr_HW_RSTLf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 2) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_HW_RSTLf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MAC_XGXS_CTRLr_RSTB_MDIOREGSf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 3) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_RSTB_MDIOREGSf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MAC_XGXS_CTRLr_RSTB_PLLf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 4) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_RSTB_PLLf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MAC_XGXS_CTRLr_BIGMACRSTLf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 5) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_BIGMACRSTLf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_MAC_XGXS_CTRLr_TXFIFO_RSTLf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 6) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_TXFIFO_RSTLf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_MAC_XGXS_CTRLr_AFIFO_RSTf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 7) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_AFIFO_RSTf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_MAC_XGXS_CTRLr_PLLBYPf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 8) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_PLLBYPf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_MAC_XGXS_CTRLr_LCREFENf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 9) & 0x1)
#define BCM56800_A0_MAC_XGXS_CTRLr_LCREFENf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_MAC_XGXS_CTRLr_RESERVEDf_GET(r) ((((r).mac_xgxs_ctrl[0]) >> 10) & 0x3fff)
#define BCM56800_A0_MAC_XGXS_CTRLr_RESERVEDf_SET(r,f) (r).mac_xgxs_ctrl[0]=(((r).mac_xgxs_ctrl[0] & ~((uint32_t)0x3fff << 10)) | ((((uint32_t)f) & 0x3fff) << 10))

/*
 * These macros can be used to access MAC_XGXS_Ctrl.
 *
 */
#define BCM56800_A0_READ_MAC_XGXS_CTRLr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_XGXS_CTRLr,(r._mac_xgxs_ctrl))
#define BCM56800_A0_WRITE_MAC_XGXS_CTRLr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_XGXS_CTRLr,&(r._mac_xgxs_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_XGXS_CTRLr BCM56800_A0_MAC_XGXS_CTRLr
#define MAC_XGXS_CTRLr_SIZE BCM56800_A0_MAC_XGXS_CTRLr_SIZE
typedef BCM56800_A0_MAC_XGXS_CTRLr_t MAC_XGXS_CTRLr_t;
#define MAC_XGXS_CTRLr_CLR BCM56800_A0_MAC_XGXS_CTRLr_CLR
#define MAC_XGXS_CTRLr_SET BCM56800_A0_MAC_XGXS_CTRLr_SET
#define MAC_XGXS_CTRLr_GET BCM56800_A0_MAC_XGXS_CTRLr_GET
#define MAC_XGXS_CTRLr_PWRDWNf_GET BCM56800_A0_MAC_XGXS_CTRLr_PWRDWNf_GET
#define MAC_XGXS_CTRLr_PWRDWNf_SET BCM56800_A0_MAC_XGXS_CTRLr_PWRDWNf_SET
#define MAC_XGXS_CTRLr_IDDQf_GET BCM56800_A0_MAC_XGXS_CTRLr_IDDQf_GET
#define MAC_XGXS_CTRLr_IDDQf_SET BCM56800_A0_MAC_XGXS_CTRLr_IDDQf_SET
#define MAC_XGXS_CTRLr_HW_RSTLf_GET BCM56800_A0_MAC_XGXS_CTRLr_HW_RSTLf_GET
#define MAC_XGXS_CTRLr_HW_RSTLf_SET BCM56800_A0_MAC_XGXS_CTRLr_HW_RSTLf_SET
#define MAC_XGXS_CTRLr_RSTB_MDIOREGSf_GET BCM56800_A0_MAC_XGXS_CTRLr_RSTB_MDIOREGSf_GET
#define MAC_XGXS_CTRLr_RSTB_MDIOREGSf_SET BCM56800_A0_MAC_XGXS_CTRLr_RSTB_MDIOREGSf_SET
#define MAC_XGXS_CTRLr_RSTB_PLLf_GET BCM56800_A0_MAC_XGXS_CTRLr_RSTB_PLLf_GET
#define MAC_XGXS_CTRLr_RSTB_PLLf_SET BCM56800_A0_MAC_XGXS_CTRLr_RSTB_PLLf_SET
#define MAC_XGXS_CTRLr_BIGMACRSTLf_GET BCM56800_A0_MAC_XGXS_CTRLr_BIGMACRSTLf_GET
#define MAC_XGXS_CTRLr_BIGMACRSTLf_SET BCM56800_A0_MAC_XGXS_CTRLr_BIGMACRSTLf_SET
#define MAC_XGXS_CTRLr_TXFIFO_RSTLf_GET BCM56800_A0_MAC_XGXS_CTRLr_TXFIFO_RSTLf_GET
#define MAC_XGXS_CTRLr_TXFIFO_RSTLf_SET BCM56800_A0_MAC_XGXS_CTRLr_TXFIFO_RSTLf_SET
#define MAC_XGXS_CTRLr_AFIFO_RSTf_GET BCM56800_A0_MAC_XGXS_CTRLr_AFIFO_RSTf_GET
#define MAC_XGXS_CTRLr_AFIFO_RSTf_SET BCM56800_A0_MAC_XGXS_CTRLr_AFIFO_RSTf_SET
#define MAC_XGXS_CTRLr_PLLBYPf_GET BCM56800_A0_MAC_XGXS_CTRLr_PLLBYPf_GET
#define MAC_XGXS_CTRLr_PLLBYPf_SET BCM56800_A0_MAC_XGXS_CTRLr_PLLBYPf_SET
#define MAC_XGXS_CTRLr_LCREFENf_GET BCM56800_A0_MAC_XGXS_CTRLr_LCREFENf_GET
#define MAC_XGXS_CTRLr_LCREFENf_SET BCM56800_A0_MAC_XGXS_CTRLr_LCREFENf_SET
#define MAC_XGXS_CTRLr_RESERVEDf_GET BCM56800_A0_MAC_XGXS_CTRLr_RESERVEDf_GET
#define MAC_XGXS_CTRLr_RESERVEDf_SET BCM56800_A0_MAC_XGXS_CTRLr_RESERVEDf_SET
#define READ_MAC_XGXS_CTRLr BCM56800_A0_READ_MAC_XGXS_CTRLr
#define WRITE_MAC_XGXS_CTRLr BCM56800_A0_WRITE_MAC_XGXS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_XGXS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAC_XGXS_Stat
 * BLOCKS:   GXPORT
 * DESC:     XGXS_UNICORE status.
 * SIZE:     64
 * FIELDS:
 *     LINKORED         Link ORed link10g with link_status.
 *     LINK10G          Link status for 10G.
 *     LINKSERDES       Link status for Serdes.
 *     RXACT            Rx active packet.
 *     TXACT            Tx active packet.
 *     TXPLL_LOCK       Txpll lock status.
 *     AUTONEG_COMPLETE Autoneg complete.
 *     DUPLEX_STATUS    full-duplex or Half-duplex.
 *     SGMII            sgmii or fiber mode.
 *     SPEED_10         Speed 10 Mbps.
 *     SPEED_100        Speed 100 Mbps.
 *     SPEED_1000       Speed 1000 Mbps.
 *     SPEED_2500       Speed 2500 Mbps.
 *     SPEED_5000       Speed 5000 Mbps.
 *     SPEED_6000       Speed 6000 Mbps.
 *     SPEED_10000      Speed 10000 Mbps.
 *     SPEED_10000_CX4  Speed 10000cx4 Mbps.
 *     SPEED_12000      Speed 12000 Mbps.
 *     SPEED_12500      Speed 12500 Mbps.
 *     SPEED_13000      Speed 13000 Mbps.
 *     SPEED_15000      Speed 15000 Mbps.
 *     SPEED_16000      Speed 16000 Mbps.
 *
 ******************************************************************************/
#define BCM56800_A0_MAC_XGXS_STATr 0x00f00002

#define BCM56800_A0_MAC_XGXS_STATr_SIZE 8

/*
 * This structure should be used to declare and program MAC_XGXS_Stat.
 *
 */
typedef union BCM56800_A0_MAC_XGXS_STATr_s {
	uint32_t v[2];
	uint32_t mac_xgxs_stat[2];
	uint32_t _mac_xgxs_stat;
} BCM56800_A0_MAC_XGXS_STATr_t;

#define BCM56800_A0_MAC_XGXS_STATr_CLR(r) CDK_MEMSET(&((r)._mac_xgxs_stat), 0, sizeof(BCM56800_A0_MAC_XGXS_STATr_t))
#define BCM56800_A0_MAC_XGXS_STATr_SET(r,i,d) (r).mac_xgxs_stat[i] = d
#define BCM56800_A0_MAC_XGXS_STATr_GET(r,i) (r).mac_xgxs_stat[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAC_XGXS_STATr_LINKOREDf_GET(r) (((r).mac_xgxs_stat[0]) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_LINKOREDf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MAC_XGXS_STATr_LINK10Gf_GET(r) ((((r).mac_xgxs_stat[0]) >> 1) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_LINK10Gf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MAC_XGXS_STATr_LINKSERDESf_GET(r) ((((r).mac_xgxs_stat[0]) >> 2) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_LINKSERDESf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MAC_XGXS_STATr_RXACTf_GET(r) ((((r).mac_xgxs_stat[0]) >> 3) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_RXACTf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MAC_XGXS_STATr_TXACTf_GET(r) ((((r).mac_xgxs_stat[0]) >> 4) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_TXACTf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MAC_XGXS_STATr_TXPLL_LOCKf_GET(r) ((((r).mac_xgxs_stat[0]) >> 5) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_TXPLL_LOCKf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_MAC_XGXS_STATr_AUTONEG_COMPLETEf_GET(r) ((((r).mac_xgxs_stat[0]) >> 6) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_AUTONEG_COMPLETEf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_MAC_XGXS_STATr_DUPLEX_STATUSf_GET(r) ((((r).mac_xgxs_stat[0]) >> 7) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_DUPLEX_STATUSf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_MAC_XGXS_STATr_SGMIIf_GET(r) ((((r).mac_xgxs_stat[0]) >> 8) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SGMIIf_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_10f_GET(r) ((((r).mac_xgxs_stat[0]) >> 9) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_10f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_100f_GET(r) ((((r).mac_xgxs_stat[0]) >> 10) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_100f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_1000f_GET(r) ((((r).mac_xgxs_stat[0]) >> 11) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_1000f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_2500f_GET(r) ((((r).mac_xgxs_stat[0]) >> 12) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_2500f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_5000f_GET(r) ((((r).mac_xgxs_stat[0]) >> 13) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_5000f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_6000f_GET(r) ((((r).mac_xgxs_stat[0]) >> 14) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_6000f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_10000f_GET(r) ((((r).mac_xgxs_stat[0]) >> 15) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_10000f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_10000_CX4f_GET(r) ((((r).mac_xgxs_stat[0]) >> 16) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_10000_CX4f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_12000f_GET(r) ((((r).mac_xgxs_stat[0]) >> 17) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_12000f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_12500f_GET(r) ((((r).mac_xgxs_stat[0]) >> 18) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_12500f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_13000f_GET(r) ((((r).mac_xgxs_stat[0]) >> 19) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_13000f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_15000f_GET(r) ((((r).mac_xgxs_stat[0]) >> 20) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_15000f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_16000f_GET(r) ((((r).mac_xgxs_stat[0]) >> 21) & 0x1)
#define BCM56800_A0_MAC_XGXS_STATr_SPEED_16000f_SET(r,f) (r).mac_xgxs_stat[0]=(((r).mac_xgxs_stat[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))

/*
 * These macros can be used to access MAC_XGXS_Stat.
 *
 */
#define BCM56800_A0_READ_MAC_XGXS_STATr(u,p,r) cdk_xgs_reg64_port_read(u,p,BCM56800_A0_MAC_XGXS_STATr,(r._mac_xgxs_stat))
#define BCM56800_A0_WRITE_MAC_XGXS_STATr(u,p,r) cdk_xgs_reg64_port_write(u,p,BCM56800_A0_MAC_XGXS_STATr,&(r._mac_xgxs_stat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_XGXS_STATr BCM56800_A0_MAC_XGXS_STATr
#define MAC_XGXS_STATr_SIZE BCM56800_A0_MAC_XGXS_STATr_SIZE
typedef BCM56800_A0_MAC_XGXS_STATr_t MAC_XGXS_STATr_t;
#define MAC_XGXS_STATr_CLR BCM56800_A0_MAC_XGXS_STATr_CLR
#define MAC_XGXS_STATr_SET BCM56800_A0_MAC_XGXS_STATr_SET
#define MAC_XGXS_STATr_GET BCM56800_A0_MAC_XGXS_STATr_GET
#define MAC_XGXS_STATr_LINKOREDf_GET BCM56800_A0_MAC_XGXS_STATr_LINKOREDf_GET
#define MAC_XGXS_STATr_LINKOREDf_SET BCM56800_A0_MAC_XGXS_STATr_LINKOREDf_SET
#define MAC_XGXS_STATr_LINK10Gf_GET BCM56800_A0_MAC_XGXS_STATr_LINK10Gf_GET
#define MAC_XGXS_STATr_LINK10Gf_SET BCM56800_A0_MAC_XGXS_STATr_LINK10Gf_SET
#define MAC_XGXS_STATr_LINKSERDESf_GET BCM56800_A0_MAC_XGXS_STATr_LINKSERDESf_GET
#define MAC_XGXS_STATr_LINKSERDESf_SET BCM56800_A0_MAC_XGXS_STATr_LINKSERDESf_SET
#define MAC_XGXS_STATr_RXACTf_GET BCM56800_A0_MAC_XGXS_STATr_RXACTf_GET
#define MAC_XGXS_STATr_RXACTf_SET BCM56800_A0_MAC_XGXS_STATr_RXACTf_SET
#define MAC_XGXS_STATr_TXACTf_GET BCM56800_A0_MAC_XGXS_STATr_TXACTf_GET
#define MAC_XGXS_STATr_TXACTf_SET BCM56800_A0_MAC_XGXS_STATr_TXACTf_SET
#define MAC_XGXS_STATr_TXPLL_LOCKf_GET BCM56800_A0_MAC_XGXS_STATr_TXPLL_LOCKf_GET
#define MAC_XGXS_STATr_TXPLL_LOCKf_SET BCM56800_A0_MAC_XGXS_STATr_TXPLL_LOCKf_SET
#define MAC_XGXS_STATr_AUTONEG_COMPLETEf_GET BCM56800_A0_MAC_XGXS_STATr_AUTONEG_COMPLETEf_GET
#define MAC_XGXS_STATr_AUTONEG_COMPLETEf_SET BCM56800_A0_MAC_XGXS_STATr_AUTONEG_COMPLETEf_SET
#define MAC_XGXS_STATr_DUPLEX_STATUSf_GET BCM56800_A0_MAC_XGXS_STATr_DUPLEX_STATUSf_GET
#define MAC_XGXS_STATr_DUPLEX_STATUSf_SET BCM56800_A0_MAC_XGXS_STATr_DUPLEX_STATUSf_SET
#define MAC_XGXS_STATr_SGMIIf_GET BCM56800_A0_MAC_XGXS_STATr_SGMIIf_GET
#define MAC_XGXS_STATr_SGMIIf_SET BCM56800_A0_MAC_XGXS_STATr_SGMIIf_SET
#define MAC_XGXS_STATr_SPEED_10f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_10f_GET
#define MAC_XGXS_STATr_SPEED_10f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_10f_SET
#define MAC_XGXS_STATr_SPEED_100f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_100f_GET
#define MAC_XGXS_STATr_SPEED_100f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_100f_SET
#define MAC_XGXS_STATr_SPEED_1000f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_1000f_GET
#define MAC_XGXS_STATr_SPEED_1000f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_1000f_SET
#define MAC_XGXS_STATr_SPEED_2500f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_2500f_GET
#define MAC_XGXS_STATr_SPEED_2500f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_2500f_SET
#define MAC_XGXS_STATr_SPEED_5000f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_5000f_GET
#define MAC_XGXS_STATr_SPEED_5000f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_5000f_SET
#define MAC_XGXS_STATr_SPEED_6000f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_6000f_GET
#define MAC_XGXS_STATr_SPEED_6000f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_6000f_SET
#define MAC_XGXS_STATr_SPEED_10000f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_10000f_GET
#define MAC_XGXS_STATr_SPEED_10000f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_10000f_SET
#define MAC_XGXS_STATr_SPEED_10000_CX4f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_10000_CX4f_GET
#define MAC_XGXS_STATr_SPEED_10000_CX4f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_10000_CX4f_SET
#define MAC_XGXS_STATr_SPEED_12000f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_12000f_GET
#define MAC_XGXS_STATr_SPEED_12000f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_12000f_SET
#define MAC_XGXS_STATr_SPEED_12500f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_12500f_GET
#define MAC_XGXS_STATr_SPEED_12500f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_12500f_SET
#define MAC_XGXS_STATr_SPEED_13000f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_13000f_GET
#define MAC_XGXS_STATr_SPEED_13000f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_13000f_SET
#define MAC_XGXS_STATr_SPEED_15000f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_15000f_GET
#define MAC_XGXS_STATr_SPEED_15000f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_15000f_SET
#define MAC_XGXS_STATr_SPEED_16000f_GET BCM56800_A0_MAC_XGXS_STATr_SPEED_16000f_GET
#define MAC_XGXS_STATr_SPEED_16000f_SET BCM56800_A0_MAC_XGXS_STATr_SPEED_16000f_SET
#define READ_MAC_XGXS_STATr BCM56800_A0_READ_MAC_XGXS_STATr
#define WRITE_MAC_XGXS_STATr BCM56800_A0_WRITE_MAC_XGXS_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAC_XGXS_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAXBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MAX_BUCKET       Maximum rate bucket with unit is 0.5 bit.
 *     OUT_PROFILE_FLAG OUT_PROFILE_FLAG inidcates the current state of maximum rate bucket1: out of profile0: In profileDefault value is in profile.
 *     PARITY           Parity for max bucket and flag fields
 *
 ******************************************************************************/
#define BCM56800_A0_MAXBUCKETr 0x0ad00018

#define BCM56800_A0_MAXBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program MAXBUCKET.
 *
 */
typedef union BCM56800_A0_MAXBUCKETr_s {
	uint32_t v[1];
	uint32_t maxbucket[1];
	uint32_t _maxbucket;
} BCM56800_A0_MAXBUCKETr_t;

#define BCM56800_A0_MAXBUCKETr_CLR(r) (r).maxbucket[0] = 0
#define BCM56800_A0_MAXBUCKETr_SET(r,d) (r).maxbucket[0] = d
#define BCM56800_A0_MAXBUCKETr_GET(r) (r).maxbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAXBUCKETr_MAX_BUCKETf_GET(r) (((r).maxbucket[0]) & 0x1fffffff)
#define BCM56800_A0_MAXBUCKETr_MAX_BUCKETf_SET(r,f) (r).maxbucket[0]=(((r).maxbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56800_A0_MAXBUCKETr_OUT_PROFILE_FLAGf_GET(r) ((((r).maxbucket[0]) >> 29) & 0x1)
#define BCM56800_A0_MAXBUCKETr_OUT_PROFILE_FLAGf_SET(r,f) (r).maxbucket[0]=(((r).maxbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_MAXBUCKETr_PARITYf_GET(r) ((((r).maxbucket[0]) >> 30) & 0x1)
#define BCM56800_A0_MAXBUCKETr_PARITYf_SET(r,f) (r).maxbucket[0]=(((r).maxbucket[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))

/*
 * These macros can be used to access MAXBUCKET.
 *
 */
#define BCM56800_A0_READ_MAXBUCKETr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MAXBUCKETr+(i),(r._maxbucket))
#define BCM56800_A0_WRITE_MAXBUCKETr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MAXBUCKETr+(i),&(r._maxbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXBUCKETr BCM56800_A0_MAXBUCKETr
#define MAXBUCKETr_SIZE BCM56800_A0_MAXBUCKETr_SIZE
typedef BCM56800_A0_MAXBUCKETr_t MAXBUCKETr_t;
#define MAXBUCKETr_CLR BCM56800_A0_MAXBUCKETr_CLR
#define MAXBUCKETr_SET BCM56800_A0_MAXBUCKETr_SET
#define MAXBUCKETr_GET BCM56800_A0_MAXBUCKETr_GET
#define MAXBUCKETr_MAX_BUCKETf_GET BCM56800_A0_MAXBUCKETr_MAX_BUCKETf_GET
#define MAXBUCKETr_MAX_BUCKETf_SET BCM56800_A0_MAXBUCKETr_MAX_BUCKETf_SET
#define MAXBUCKETr_OUT_PROFILE_FLAGf_GET BCM56800_A0_MAXBUCKETr_OUT_PROFILE_FLAGf_GET
#define MAXBUCKETr_OUT_PROFILE_FLAGf_SET BCM56800_A0_MAXBUCKETr_OUT_PROFILE_FLAGf_SET
#define MAXBUCKETr_PARITYf_GET BCM56800_A0_MAXBUCKETr_PARITYf_GET
#define MAXBUCKETr_PARITYf_SET BCM56800_A0_MAXBUCKETr_PARITYf_SET
#define READ_MAXBUCKETr BCM56800_A0_READ_MAXBUCKETr
#define WRITE_MAXBUCKETr BCM56800_A0_WRITE_MAXBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAXBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAXBUCKETCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MAX_THD_SEL      Threshold for Maximum Bucket. The setting of Threshold determines the size of bucket.This Low Threshold setting is not related to Maximum rate.0x0: Disable, Maximum bucket function is disabled.0x1:  32k bits, (32*1024),0x2:  64k bits, (64*1024),0x3: 128k bits, (128*1024),0x4: 256k bits, (256*1024),0x5: 512k bits, (512*1024),0x6:   1M bits, (1024*1024),0x7:   2M bits, (2*1024*1024),0x8:   4M bits, (4*1024*1024),0x9:   8M bits, (8*1024*1024),0xa:  16M bits, (16*1024*1024),0xb:  32M bits, (32*1024*1024),0xc:  64M bits, (64*1024*1024),0xd: 128M bits, (128*1024*1024),0xe: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,0xf: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,
 *     MAX_REFRESH      Refresh count for Maximum Bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set REFRESH = 7812, Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set REFRESH = 15624.
 *     PARITY           Parity for max bucket config fields
 *
 ******************************************************************************/
#define BCM56800_A0_MAXBUCKETCONFIGr 0x0ad00010

#define BCM56800_A0_MAXBUCKETCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MAXBUCKETCONFIG.
 *
 */
typedef union BCM56800_A0_MAXBUCKETCONFIGr_s {
	uint32_t v[1];
	uint32_t maxbucketconfig[1];
	uint32_t _maxbucketconfig;
} BCM56800_A0_MAXBUCKETCONFIGr_t;

#define BCM56800_A0_MAXBUCKETCONFIGr_CLR(r) (r).maxbucketconfig[0] = 0
#define BCM56800_A0_MAXBUCKETCONFIGr_SET(r,d) (r).maxbucketconfig[0] = d
#define BCM56800_A0_MAXBUCKETCONFIGr_GET(r) (r).maxbucketconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_GET(r) (((r).maxbucketconfig[0]) & 0xf)
#define BCM56800_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_GET(r) ((((r).maxbucketconfig[0]) >> 4) & 0x3ffff)
#define BCM56800_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32_t)0x3ffff << 4)) | ((((uint32_t)f) & 0x3ffff) << 4))
#define BCM56800_A0_MAXBUCKETCONFIGr_PARITYf_GET(r) ((((r).maxbucketconfig[0]) >> 22) & 0x1)
#define BCM56800_A0_MAXBUCKETCONFIGr_PARITYf_SET(r,f) (r).maxbucketconfig[0]=(((r).maxbucketconfig[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))

/*
 * These macros can be used to access MAXBUCKETCONFIG.
 *
 */
#define BCM56800_A0_READ_MAXBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MAXBUCKETCONFIGr+(i),(r._maxbucketconfig))
#define BCM56800_A0_WRITE_MAXBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MAXBUCKETCONFIGr+(i),&(r._maxbucketconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXBUCKETCONFIGr BCM56800_A0_MAXBUCKETCONFIGr
#define MAXBUCKETCONFIGr_SIZE BCM56800_A0_MAXBUCKETCONFIGr_SIZE
typedef BCM56800_A0_MAXBUCKETCONFIGr_t MAXBUCKETCONFIGr_t;
#define MAXBUCKETCONFIGr_CLR BCM56800_A0_MAXBUCKETCONFIGr_CLR
#define MAXBUCKETCONFIGr_SET BCM56800_A0_MAXBUCKETCONFIGr_SET
#define MAXBUCKETCONFIGr_GET BCM56800_A0_MAXBUCKETCONFIGr_GET
#define MAXBUCKETCONFIGr_MAX_THD_SELf_GET BCM56800_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_GET
#define MAXBUCKETCONFIGr_MAX_THD_SELf_SET BCM56800_A0_MAXBUCKETCONFIGr_MAX_THD_SELf_SET
#define MAXBUCKETCONFIGr_MAX_REFRESHf_GET BCM56800_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_GET
#define MAXBUCKETCONFIGr_MAX_REFRESHf_SET BCM56800_A0_MAXBUCKETCONFIGr_MAX_REFRESHf_SET
#define MAXBUCKETCONFIGr_PARITYf_GET BCM56800_A0_MAXBUCKETCONFIGr_PARITYf_GET
#define MAXBUCKETCONFIGr_PARITYf_SET BCM56800_A0_MAXBUCKETCONFIGr_PARITYf_SET
#define READ_MAXBUCKETCONFIGr BCM56800_A0_READ_MAXBUCKETCONFIGr
#define WRITE_MAXBUCKETCONFIGr BCM56800_A0_WRITE_MAXBUCKETCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAXBUCKETCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MAXFR
 * BLOCKS:   GXPORT
 * DESC:     Max Frame Length
 * SIZE:     32
 * FIELDS:
 *     MAXFR            Max Frame Length is now 1518 Decimal
 *
 ******************************************************************************/
#define BCM56800_A0_MAXFRr 0x00f00108

#define BCM56800_A0_MAXFRr_SIZE 4

/*
 * This structure should be used to declare and program MAXFR.
 *
 */
typedef union BCM56800_A0_MAXFRr_s {
	uint32_t v[1];
	uint32_t maxfr[1];
	uint32_t _maxfr;
} BCM56800_A0_MAXFRr_t;

#define BCM56800_A0_MAXFRr_CLR(r) (r).maxfr[0] = 0
#define BCM56800_A0_MAXFRr_SET(r,d) (r).maxfr[0] = d
#define BCM56800_A0_MAXFRr_GET(r) (r).maxfr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MAXFRr_MAXFRf_GET(r) (((r).maxfr[0]) & 0xffff)
#define BCM56800_A0_MAXFRr_MAXFRf_SET(r,f) (r).maxfr[0]=(((r).maxfr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MAXFR.
 *
 */
#define BCM56800_A0_READ_MAXFRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MAXFRr,(r._maxfr))
#define BCM56800_A0_WRITE_MAXFRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MAXFRr,&(r._maxfr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAXFRr BCM56800_A0_MAXFRr
#define MAXFRr_SIZE BCM56800_A0_MAXFRr_SIZE
typedef BCM56800_A0_MAXFRr_t MAXFRr_t;
#define MAXFRr_CLR BCM56800_A0_MAXFRr_CLR
#define MAXFRr_SET BCM56800_A0_MAXFRr_SET
#define MAXFRr_GET BCM56800_A0_MAXFRr_GET
#define MAXFRr_MAXFRf_GET BCM56800_A0_MAXFRr_MAXFRf_GET
#define MAXFRr_MAXFRf_SET BCM56800_A0_MAXFRr_MAXFRf_SET
#define READ_MAXFRr BCM56800_A0_READ_MAXFRr
#define WRITE_MAXFRr BCM56800_A0_WRITE_MAXFRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MAXFRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MCAST_STORM_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Ethernet Multicast Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        Rate Limit, count as number of packets
 *     ENABLE           Multicast rate control enable
 *
 ******************************************************************************/
#define BCM56800_A0_MCAST_STORM_CONTROLr 0x0b100002

#define BCM56800_A0_MCAST_STORM_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MCAST_STORM_CONTROL.
 *
 */
typedef union BCM56800_A0_MCAST_STORM_CONTROLr_s {
	uint32_t v[1];
	uint32_t mcast_storm_control[1];
	uint32_t _mcast_storm_control;
} BCM56800_A0_MCAST_STORM_CONTROLr_t;

#define BCM56800_A0_MCAST_STORM_CONTROLr_CLR(r) (r).mcast_storm_control[0] = 0
#define BCM56800_A0_MCAST_STORM_CONTROLr_SET(r,d) (r).mcast_storm_control[0] = d
#define BCM56800_A0_MCAST_STORM_CONTROLr_GET(r) (r).mcast_storm_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MCAST_STORM_CONTROLr_THRESHOLDf_GET(r) (((r).mcast_storm_control[0]) & 0x1ffffff)
#define BCM56800_A0_MCAST_STORM_CONTROLr_THRESHOLDf_SET(r,f) (r).mcast_storm_control[0]=(((r).mcast_storm_control[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56800_A0_MCAST_STORM_CONTROLr_ENABLEf_GET(r) ((((r).mcast_storm_control[0]) >> 25) & 0x1)
#define BCM56800_A0_MCAST_STORM_CONTROLr_ENABLEf_SET(r,f) (r).mcast_storm_control[0]=(((r).mcast_storm_control[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))

/*
 * These macros can be used to access MCAST_STORM_CONTROL.
 *
 */
#define BCM56800_A0_READ_MCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MCAST_STORM_CONTROLr,(r._mcast_storm_control))
#define BCM56800_A0_WRITE_MCAST_STORM_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MCAST_STORM_CONTROLr,&(r._mcast_storm_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MCAST_STORM_CONTROLr BCM56800_A0_MCAST_STORM_CONTROLr
#define MCAST_STORM_CONTROLr_SIZE BCM56800_A0_MCAST_STORM_CONTROLr_SIZE
typedef BCM56800_A0_MCAST_STORM_CONTROLr_t MCAST_STORM_CONTROLr_t;
#define MCAST_STORM_CONTROLr_CLR BCM56800_A0_MCAST_STORM_CONTROLr_CLR
#define MCAST_STORM_CONTROLr_SET BCM56800_A0_MCAST_STORM_CONTROLr_SET
#define MCAST_STORM_CONTROLr_GET BCM56800_A0_MCAST_STORM_CONTROLr_GET
#define MCAST_STORM_CONTROLr_THRESHOLDf_GET BCM56800_A0_MCAST_STORM_CONTROLr_THRESHOLDf_GET
#define MCAST_STORM_CONTROLr_THRESHOLDf_SET BCM56800_A0_MCAST_STORM_CONTROLr_THRESHOLDf_SET
#define MCAST_STORM_CONTROLr_ENABLEf_GET BCM56800_A0_MCAST_STORM_CONTROLr_ENABLEf_GET
#define MCAST_STORM_CONTROLr_ENABLEf_SET BCM56800_A0_MCAST_STORM_CONTROLr_ENABLEf_SET
#define READ_MCAST_STORM_CONTROLr BCM56800_A0_READ_MCAST_STORM_CONTROLr
#define WRITE_MCAST_STORM_CONTROLr BCM56800_A0_WRITE_MCAST_STORM_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MCAST_STORM_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MC_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Multicast Control Register1 for HiGig2 pkts
 * SIZE:     32
 * FIELDS:
 *     HIGIG2_BC_BASE_OFFSET Base offset for Broadcast packets.
 *     HIGIG2_BC_SIZE   Number of Broadcast groups(i.e. VLANS) in MC space
 *
 ******************************************************************************/
#define BCM56800_A0_MC_CONTROL_1r 0x01180606

#define BCM56800_A0_MC_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program MC_CONTROL_1.
 *
 */
typedef union BCM56800_A0_MC_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t mc_control_1[1];
	uint32_t _mc_control_1;
} BCM56800_A0_MC_CONTROL_1r_t;

#define BCM56800_A0_MC_CONTROL_1r_CLR(r) (r).mc_control_1[0] = 0
#define BCM56800_A0_MC_CONTROL_1r_SET(r,d) (r).mc_control_1[0] = d
#define BCM56800_A0_MC_CONTROL_1r_GET(r) (r).mc_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET(r) (((r).mc_control_1[0]) & 0xffff)
#define BCM56800_A0_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET(r,f) (r).mc_control_1[0]=(((r).mc_control_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET(r) ((((r).mc_control_1[0]) >> 16) & 0xffff)
#define BCM56800_A0_MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET(r,f) (r).mc_control_1[0]=(((r).mc_control_1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MC_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_MC_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MC_CONTROL_1r,(r._mc_control_1))
#define BCM56800_A0_WRITE_MC_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MC_CONTROL_1r,&(r._mc_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MC_CONTROL_1r BCM56800_A0_MC_CONTROL_1r
#define MC_CONTROL_1r_SIZE BCM56800_A0_MC_CONTROL_1r_SIZE
typedef BCM56800_A0_MC_CONTROL_1r_t MC_CONTROL_1r_t;
#define MC_CONTROL_1r_CLR BCM56800_A0_MC_CONTROL_1r_CLR
#define MC_CONTROL_1r_SET BCM56800_A0_MC_CONTROL_1r_SET
#define MC_CONTROL_1r_GET BCM56800_A0_MC_CONTROL_1r_GET
#define MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET BCM56800_A0_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_GET
#define MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET BCM56800_A0_MC_CONTROL_1r_HIGIG2_BC_BASE_OFFSETf_SET
#define MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET BCM56800_A0_MC_CONTROL_1r_HIGIG2_BC_SIZEf_GET
#define MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET BCM56800_A0_MC_CONTROL_1r_HIGIG2_BC_SIZEf_SET
#define READ_MC_CONTROL_1r BCM56800_A0_READ_MC_CONTROL_1r
#define WRITE_MC_CONTROL_1r BCM56800_A0_WRITE_MC_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MC_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MC_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Multicast Control Register2 for HiGig2 pkts
 * SIZE:     32
 * FIELDS:
 *     HIGIG2_L2MC_BASE_OFFSET Base offset in MC space for L2 Multicast packets.
 *     HIGIG2_L2MC_SIZE Number of L2 Multicast groups in MC space
 *
 ******************************************************************************/
#define BCM56800_A0_MC_CONTROL_2r 0x01180607

#define BCM56800_A0_MC_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program MC_CONTROL_2.
 *
 */
typedef union BCM56800_A0_MC_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t mc_control_2[1];
	uint32_t _mc_control_2;
} BCM56800_A0_MC_CONTROL_2r_t;

#define BCM56800_A0_MC_CONTROL_2r_CLR(r) (r).mc_control_2[0] = 0
#define BCM56800_A0_MC_CONTROL_2r_SET(r,d) (r).mc_control_2[0] = d
#define BCM56800_A0_MC_CONTROL_2r_GET(r) (r).mc_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MC_CONTROL_2r_HIGIG2_L2MC_BASE_OFFSETf_GET(r) (((r).mc_control_2[0]) & 0xffff)
#define BCM56800_A0_MC_CONTROL_2r_HIGIG2_L2MC_BASE_OFFSETf_SET(r,f) (r).mc_control_2[0]=(((r).mc_control_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_MC_CONTROL_2r_HIGIG2_L2MC_SIZEf_GET(r) ((((r).mc_control_2[0]) >> 16) & 0xffff)
#define BCM56800_A0_MC_CONTROL_2r_HIGIG2_L2MC_SIZEf_SET(r,f) (r).mc_control_2[0]=(((r).mc_control_2[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MC_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_MC_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MC_CONTROL_2r,(r._mc_control_2))
#define BCM56800_A0_WRITE_MC_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MC_CONTROL_2r,&(r._mc_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MC_CONTROL_2r BCM56800_A0_MC_CONTROL_2r
#define MC_CONTROL_2r_SIZE BCM56800_A0_MC_CONTROL_2r_SIZE
typedef BCM56800_A0_MC_CONTROL_2r_t MC_CONTROL_2r_t;
#define MC_CONTROL_2r_CLR BCM56800_A0_MC_CONTROL_2r_CLR
#define MC_CONTROL_2r_SET BCM56800_A0_MC_CONTROL_2r_SET
#define MC_CONTROL_2r_GET BCM56800_A0_MC_CONTROL_2r_GET
#define MC_CONTROL_2r_HIGIG2_L2MC_BASE_OFFSETf_GET BCM56800_A0_MC_CONTROL_2r_HIGIG2_L2MC_BASE_OFFSETf_GET
#define MC_CONTROL_2r_HIGIG2_L2MC_BASE_OFFSETf_SET BCM56800_A0_MC_CONTROL_2r_HIGIG2_L2MC_BASE_OFFSETf_SET
#define MC_CONTROL_2r_HIGIG2_L2MC_SIZEf_GET BCM56800_A0_MC_CONTROL_2r_HIGIG2_L2MC_SIZEf_GET
#define MC_CONTROL_2r_HIGIG2_L2MC_SIZEf_SET BCM56800_A0_MC_CONTROL_2r_HIGIG2_L2MC_SIZEf_SET
#define READ_MC_CONTROL_2r BCM56800_A0_READ_MC_CONTROL_2r
#define WRITE_MC_CONTROL_2r BCM56800_A0_WRITE_MC_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MC_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MC_CONTROL_3
 * BLOCKS:   IPIPE
 * DESC:     Multicast Control Register3 for HiGig2 pkts
 * SIZE:     32
 * FIELDS:
 *     HIGIG2_IPMC_BASE_OFFSET Base offset in MC space for IP Multicast packets.
 *     HIGIG2_IPMC_SIZE Number of IP Multicast groups in MC space
 *
 ******************************************************************************/
#define BCM56800_A0_MC_CONTROL_3r 0x01180608

#define BCM56800_A0_MC_CONTROL_3r_SIZE 4

/*
 * This structure should be used to declare and program MC_CONTROL_3.
 *
 */
typedef union BCM56800_A0_MC_CONTROL_3r_s {
	uint32_t v[1];
	uint32_t mc_control_3[1];
	uint32_t _mc_control_3;
} BCM56800_A0_MC_CONTROL_3r_t;

#define BCM56800_A0_MC_CONTROL_3r_CLR(r) (r).mc_control_3[0] = 0
#define BCM56800_A0_MC_CONTROL_3r_SET(r,d) (r).mc_control_3[0] = d
#define BCM56800_A0_MC_CONTROL_3r_GET(r) (r).mc_control_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MC_CONTROL_3r_HIGIG2_IPMC_BASE_OFFSETf_GET(r) (((r).mc_control_3[0]) & 0xffff)
#define BCM56800_A0_MC_CONTROL_3r_HIGIG2_IPMC_BASE_OFFSETf_SET(r,f) (r).mc_control_3[0]=(((r).mc_control_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_MC_CONTROL_3r_HIGIG2_IPMC_SIZEf_GET(r) ((((r).mc_control_3[0]) >> 16) & 0xffff)
#define BCM56800_A0_MC_CONTROL_3r_HIGIG2_IPMC_SIZEf_SET(r,f) (r).mc_control_3[0]=(((r).mc_control_3[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MC_CONTROL_3.
 *
 */
#define BCM56800_A0_READ_MC_CONTROL_3r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MC_CONTROL_3r,(r._mc_control_3))
#define BCM56800_A0_WRITE_MC_CONTROL_3r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MC_CONTROL_3r,&(r._mc_control_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MC_CONTROL_3r BCM56800_A0_MC_CONTROL_3r
#define MC_CONTROL_3r_SIZE BCM56800_A0_MC_CONTROL_3r_SIZE
typedef BCM56800_A0_MC_CONTROL_3r_t MC_CONTROL_3r_t;
#define MC_CONTROL_3r_CLR BCM56800_A0_MC_CONTROL_3r_CLR
#define MC_CONTROL_3r_SET BCM56800_A0_MC_CONTROL_3r_SET
#define MC_CONTROL_3r_GET BCM56800_A0_MC_CONTROL_3r_GET
#define MC_CONTROL_3r_HIGIG2_IPMC_BASE_OFFSETf_GET BCM56800_A0_MC_CONTROL_3r_HIGIG2_IPMC_BASE_OFFSETf_GET
#define MC_CONTROL_3r_HIGIG2_IPMC_BASE_OFFSETf_SET BCM56800_A0_MC_CONTROL_3r_HIGIG2_IPMC_BASE_OFFSETf_SET
#define MC_CONTROL_3r_HIGIG2_IPMC_SIZEf_GET BCM56800_A0_MC_CONTROL_3r_HIGIG2_IPMC_SIZEf_GET
#define MC_CONTROL_3r_HIGIG2_IPMC_SIZEf_SET BCM56800_A0_MC_CONTROL_3r_HIGIG2_IPMC_SIZEf_SET
#define READ_MC_CONTROL_3r BCM56800_A0_READ_MC_CONTROL_3r
#define WRITE_MC_CONTROL_3r BCM56800_A0_WRITE_MC_CONTROL_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MC_CONTROL_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MC_CONTROL_4
 * BLOCKS:   IPIPE
 * DESC:     Multicast Control Register4
 * SIZE:     32
 * FIELDS:
 *     L2MC_MASK_LEN    Mask Length for L2MC groups.
 *     IPMC_MASK_LEN    Mask Length for IPMC groups.
 *     ALLOW_L2MC_INDEX_WRAP_AROUND If this bit is set and the L2MC group index is bigger than HIGIG2_L2MC_SIZE, apply the mask based on HIGIG2_L2MC_MASK_LEN.
 *     ALLOW_IPMC_INDEX_WRAP_AROUND If this bit is set and the IPMC group index is bigger than HIGIG2_IPMC_SIZE, apply the mask based on HIGIG2_IPMC_MASK_LEN.
 *
 ******************************************************************************/
#define BCM56800_A0_MC_CONTROL_4r 0x06180615

#define BCM56800_A0_MC_CONTROL_4r_SIZE 4

/*
 * This structure should be used to declare and program MC_CONTROL_4.
 *
 */
typedef union BCM56800_A0_MC_CONTROL_4r_s {
	uint32_t v[1];
	uint32_t mc_control_4[1];
	uint32_t _mc_control_4;
} BCM56800_A0_MC_CONTROL_4r_t;

#define BCM56800_A0_MC_CONTROL_4r_CLR(r) (r).mc_control_4[0] = 0
#define BCM56800_A0_MC_CONTROL_4r_SET(r,d) (r).mc_control_4[0] = d
#define BCM56800_A0_MC_CONTROL_4r_GET(r) (r).mc_control_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MC_CONTROL_4r_L2MC_MASK_LENf_GET(r) (((r).mc_control_4[0]) & 0x1f)
#define BCM56800_A0_MC_CONTROL_4r_L2MC_MASK_LENf_SET(r,f) (r).mc_control_4[0]=(((r).mc_control_4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_MC_CONTROL_4r_IPMC_MASK_LENf_GET(r) ((((r).mc_control_4[0]) >> 5) & 0x1f)
#define BCM56800_A0_MC_CONTROL_4r_IPMC_MASK_LENf_SET(r,f) (r).mc_control_4[0]=(((r).mc_control_4[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_MC_CONTROL_4r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_GET(r) ((((r).mc_control_4[0]) >> 10) & 0x1)
#define BCM56800_A0_MC_CONTROL_4r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_SET(r,f) (r).mc_control_4[0]=(((r).mc_control_4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_MC_CONTROL_4r_ALLOW_IPMC_INDEX_WRAP_AROUNDf_GET(r) ((((r).mc_control_4[0]) >> 11) & 0x1)
#define BCM56800_A0_MC_CONTROL_4r_ALLOW_IPMC_INDEX_WRAP_AROUNDf_SET(r,f) (r).mc_control_4[0]=(((r).mc_control_4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access MC_CONTROL_4.
 *
 */
#define BCM56800_A0_READ_MC_CONTROL_4r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MC_CONTROL_4r,(r._mc_control_4))
#define BCM56800_A0_WRITE_MC_CONTROL_4r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MC_CONTROL_4r,&(r._mc_control_4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MC_CONTROL_4r BCM56800_A0_MC_CONTROL_4r
#define MC_CONTROL_4r_SIZE BCM56800_A0_MC_CONTROL_4r_SIZE
typedef BCM56800_A0_MC_CONTROL_4r_t MC_CONTROL_4r_t;
#define MC_CONTROL_4r_CLR BCM56800_A0_MC_CONTROL_4r_CLR
#define MC_CONTROL_4r_SET BCM56800_A0_MC_CONTROL_4r_SET
#define MC_CONTROL_4r_GET BCM56800_A0_MC_CONTROL_4r_GET
#define MC_CONTROL_4r_L2MC_MASK_LENf_GET BCM56800_A0_MC_CONTROL_4r_L2MC_MASK_LENf_GET
#define MC_CONTROL_4r_L2MC_MASK_LENf_SET BCM56800_A0_MC_CONTROL_4r_L2MC_MASK_LENf_SET
#define MC_CONTROL_4r_IPMC_MASK_LENf_GET BCM56800_A0_MC_CONTROL_4r_IPMC_MASK_LENf_GET
#define MC_CONTROL_4r_IPMC_MASK_LENf_SET BCM56800_A0_MC_CONTROL_4r_IPMC_MASK_LENf_SET
#define MC_CONTROL_4r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_GET BCM56800_A0_MC_CONTROL_4r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_GET
#define MC_CONTROL_4r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_SET BCM56800_A0_MC_CONTROL_4r_ALLOW_L2MC_INDEX_WRAP_AROUNDf_SET
#define MC_CONTROL_4r_ALLOW_IPMC_INDEX_WRAP_AROUNDf_GET BCM56800_A0_MC_CONTROL_4r_ALLOW_IPMC_INDEX_WRAP_AROUNDf_GET
#define MC_CONTROL_4r_ALLOW_IPMC_INDEX_WRAP_AROUNDf_SET BCM56800_A0_MC_CONTROL_4r_ALLOW_IPMC_INDEX_WRAP_AROUNDf_SET
#define READ_MC_CONTROL_4r BCM56800_A0_READ_MC_CONTROL_4r
#define WRITE_MC_CONTROL_4r BCM56800_A0_WRITE_MC_CONTROL_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MC_CONTROL_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MC_CONTROL_5
 * BLOCKS:   IPIPE
 * DESC:     Multicast Control Register5
 * SIZE:     32
 * FIELDS:
 *     SHARED_TABLE_L2MC_SIZE Size of the L2MC region in the shared L2MC table.
 *     SHARED_TABLE_IPMC_SIZE Size of the IPMC region in the shared L2MC table.
 *
 ******************************************************************************/
#define BCM56800_A0_MC_CONTROL_5r 0x06180616

#define BCM56800_A0_MC_CONTROL_5r_SIZE 4

/*
 * This structure should be used to declare and program MC_CONTROL_5.
 *
 */
typedef union BCM56800_A0_MC_CONTROL_5r_s {
	uint32_t v[1];
	uint32_t mc_control_5[1];
	uint32_t _mc_control_5;
} BCM56800_A0_MC_CONTROL_5r_t;

#define BCM56800_A0_MC_CONTROL_5r_CLR(r) (r).mc_control_5[0] = 0
#define BCM56800_A0_MC_CONTROL_5r_SET(r,d) (r).mc_control_5[0] = d
#define BCM56800_A0_MC_CONTROL_5r_GET(r) (r).mc_control_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MC_CONTROL_5r_SHARED_TABLE_L2MC_SIZEf_GET(r) (((r).mc_control_5[0]) & 0x1fff)
#define BCM56800_A0_MC_CONTROL_5r_SHARED_TABLE_L2MC_SIZEf_SET(r,f) (r).mc_control_5[0]=(((r).mc_control_5[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM56800_A0_MC_CONTROL_5r_SHARED_TABLE_IPMC_SIZEf_GET(r) ((((r).mc_control_5[0]) >> 13) & 0x1fff)
#define BCM56800_A0_MC_CONTROL_5r_SHARED_TABLE_IPMC_SIZEf_SET(r,f) (r).mc_control_5[0]=(((r).mc_control_5[0] & ~((uint32_t)0x1fff << 13)) | ((((uint32_t)f) & 0x1fff) << 13))

/*
 * These macros can be used to access MC_CONTROL_5.
 *
 */
#define BCM56800_A0_READ_MC_CONTROL_5r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MC_CONTROL_5r,(r._mc_control_5))
#define BCM56800_A0_WRITE_MC_CONTROL_5r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MC_CONTROL_5r,&(r._mc_control_5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MC_CONTROL_5r BCM56800_A0_MC_CONTROL_5r
#define MC_CONTROL_5r_SIZE BCM56800_A0_MC_CONTROL_5r_SIZE
typedef BCM56800_A0_MC_CONTROL_5r_t MC_CONTROL_5r_t;
#define MC_CONTROL_5r_CLR BCM56800_A0_MC_CONTROL_5r_CLR
#define MC_CONTROL_5r_SET BCM56800_A0_MC_CONTROL_5r_SET
#define MC_CONTROL_5r_GET BCM56800_A0_MC_CONTROL_5r_GET
#define MC_CONTROL_5r_SHARED_TABLE_L2MC_SIZEf_GET BCM56800_A0_MC_CONTROL_5r_SHARED_TABLE_L2MC_SIZEf_GET
#define MC_CONTROL_5r_SHARED_TABLE_L2MC_SIZEf_SET BCM56800_A0_MC_CONTROL_5r_SHARED_TABLE_L2MC_SIZEf_SET
#define MC_CONTROL_5r_SHARED_TABLE_IPMC_SIZEf_GET BCM56800_A0_MC_CONTROL_5r_SHARED_TABLE_IPMC_SIZEf_GET
#define MC_CONTROL_5r_SHARED_TABLE_IPMC_SIZEf_SET BCM56800_A0_MC_CONTROL_5r_SHARED_TABLE_IPMC_SIZEf_SET
#define READ_MC_CONTROL_5r BCM56800_A0_READ_MC_CONTROL_5r
#define WRITE_MC_CONTROL_5r BCM56800_A0_WRITE_MC_CONTROL_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MC_CONTROL_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MEM1_IPMCGRP_TBL_PARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ADDR             parity error ptr.
 *
 ******************************************************************************/
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr 0x10d8001f

#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program MEM1_IPMCGRP_TBL_PARITYERRORPTR.
 *
 */
typedef union BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t mem1_ipmcgrp_tbl_parityerrorptr[1];
	uint32_t _mem1_ipmcgrp_tbl_parityerrorptr;
} BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_t;

#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_CLR(r) (r).mem1_ipmcgrp_tbl_parityerrorptr[0] = 0
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_SET(r,d) (r).mem1_ipmcgrp_tbl_parityerrorptr[0] = d
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_GET(r) (r).mem1_ipmcgrp_tbl_parityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_GET(r) (((r).mem1_ipmcgrp_tbl_parityerrorptr[0]) & 0x3ff)
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_SET(r,f) (r).mem1_ipmcgrp_tbl_parityerrorptr[0]=(((r).mem1_ipmcgrp_tbl_parityerrorptr[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access MEM1_IPMCGRP_TBL_PARITYERRORPTR.
 *
 */
#define BCM56800_A0_READ_MEM1_IPMCGRP_TBL_PARITYERRORPTRr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr+(i),(r._mem1_ipmcgrp_tbl_parityerrorptr))
#define BCM56800_A0_WRITE_MEM1_IPMCGRP_TBL_PARITYERRORPTRr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr+(i),&(r._mem1_ipmcgrp_tbl_parityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM1_IPMCGRP_TBL_PARITYERRORPTRr BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr
#define MEM1_IPMCGRP_TBL_PARITYERRORPTRr_SIZE BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_SIZE
typedef BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_t MEM1_IPMCGRP_TBL_PARITYERRORPTRr_t;
#define MEM1_IPMCGRP_TBL_PARITYERRORPTRr_CLR BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_CLR
#define MEM1_IPMCGRP_TBL_PARITYERRORPTRr_SET BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_SET
#define MEM1_IPMCGRP_TBL_PARITYERRORPTRr_GET BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_GET
#define MEM1_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_GET BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_GET
#define MEM1_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_SET BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr_ADDRf_SET
#define READ_MEM1_IPMCGRP_TBL_PARITYERRORPTRr BCM56800_A0_READ_MEM1_IPMCGRP_TBL_PARITYERRORPTRr
#define WRITE_MEM1_IPMCGRP_TBL_PARITYERRORPTRr BCM56800_A0_WRITE_MEM1_IPMCGRP_TBL_PARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MEM1_IPMCGRP_TBL_PARITYERROR_STATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     STATUS           parity error staus.
 *
 ******************************************************************************/
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr 0x10d80023

#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MEM1_IPMCGRP_TBL_PARITYERROR_STATUS.
 *
 */
typedef union BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_s {
	uint32_t v[1];
	uint32_t mem1_ipmcgrp_tbl_parityerror_status[1];
	uint32_t _mem1_ipmcgrp_tbl_parityerror_status;
} BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_t;

#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_CLR(r) (r).mem1_ipmcgrp_tbl_parityerror_status[0] = 0
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_SET(r,d) (r).mem1_ipmcgrp_tbl_parityerror_status[0] = d
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_GET(r) (r).mem1_ipmcgrp_tbl_parityerror_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_GET(r) (((r).mem1_ipmcgrp_tbl_parityerror_status[0]) & 0xf)
#define BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_SET(r,f) (r).mem1_ipmcgrp_tbl_parityerror_status[0]=(((r).mem1_ipmcgrp_tbl_parityerror_status[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access MEM1_IPMCGRP_TBL_PARITYERROR_STATUS.
 *
 */
#define BCM56800_A0_READ_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr,(r._mem1_ipmcgrp_tbl_parityerror_status))
#define BCM56800_A0_WRITE_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr,&(r._mem1_ipmcgrp_tbl_parityerror_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr
#define MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_SIZE BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_SIZE
typedef BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_t MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_t;
#define MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_CLR BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_CLR
#define MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_SET BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_SET
#define MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_GET BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_GET
#define MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_GET BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_GET
#define MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_SET BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr_STATUSf_SET
#define READ_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr BCM56800_A0_READ_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr
#define WRITE_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr BCM56800_A0_WRITE_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MEM1_IPMCVLAN_TBL_PARITYERRORPTR
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     ADDR             parity error ptr.
 *
 ******************************************************************************/
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr 0x10d80024

#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_SIZE 4

/*
 * This structure should be used to declare and program MEM1_IPMCVLAN_TBL_PARITYERRORPTR.
 *
 */
typedef union BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_s {
	uint32_t v[1];
	uint32_t mem1_ipmcvlan_tbl_parityerrorptr[1];
	uint32_t _mem1_ipmcvlan_tbl_parityerrorptr;
} BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_t;

#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_CLR(r) (r).mem1_ipmcvlan_tbl_parityerrorptr[0] = 0
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_SET(r,d) (r).mem1_ipmcvlan_tbl_parityerrorptr[0] = d
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_GET(r) (r).mem1_ipmcvlan_tbl_parityerrorptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_ADDRf_GET(r) (((r).mem1_ipmcvlan_tbl_parityerrorptr[0]) & 0x7ff)
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_ADDRf_SET(r,f) (r).mem1_ipmcvlan_tbl_parityerrorptr[0]=(((r).mem1_ipmcvlan_tbl_parityerrorptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access MEM1_IPMCVLAN_TBL_PARITYERRORPTR.
 *
 */
#define BCM56800_A0_READ_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr+(i),(r._mem1_ipmcvlan_tbl_parityerrorptr))
#define BCM56800_A0_WRITE_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr+(i),&(r._mem1_ipmcvlan_tbl_parityerrorptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM1_IPMCVLAN_TBL_PARITYERRORPTRr BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr
#define MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_SIZE BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_SIZE
typedef BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_t MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_t;
#define MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_CLR BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_CLR
#define MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_SET BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_SET
#define MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_GET BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_GET
#define MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_ADDRf_GET BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_ADDRf_GET
#define MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_ADDRf_SET BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr_ADDRf_SET
#define READ_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr BCM56800_A0_READ_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr
#define WRITE_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr BCM56800_A0_WRITE_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERRORPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MEM1_IPMCVLAN_TBL_PARITYERROR_STATUS
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     STATUS           parity error staus.
 *
 ******************************************************************************/
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr 0x10d80026

#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program MEM1_IPMCVLAN_TBL_PARITYERROR_STATUS.
 *
 */
typedef union BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_s {
	uint32_t v[1];
	uint32_t mem1_ipmcvlan_tbl_parityerror_status[1];
	uint32_t _mem1_ipmcvlan_tbl_parityerror_status;
} BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_t;

#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_CLR(r) (r).mem1_ipmcvlan_tbl_parityerror_status[0] = 0
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_SET(r,d) (r).mem1_ipmcvlan_tbl_parityerror_status[0] = d
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_GET(r) (r).mem1_ipmcvlan_tbl_parityerror_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_STATUSf_GET(r) (((r).mem1_ipmcvlan_tbl_parityerror_status[0]) & 0x3)
#define BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_STATUSf_SET(r,f) (r).mem1_ipmcvlan_tbl_parityerror_status[0]=(((r).mem1_ipmcvlan_tbl_parityerror_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))

/*
 * These macros can be used to access MEM1_IPMCVLAN_TBL_PARITYERROR_STATUS.
 *
 */
#define BCM56800_A0_READ_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr,(r._mem1_ipmcvlan_tbl_parityerror_status))
#define BCM56800_A0_WRITE_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr,&(r._mem1_ipmcvlan_tbl_parityerror_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr
#define MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_SIZE BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_SIZE
typedef BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_t MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_t;
#define MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_CLR BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_CLR
#define MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_SET BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_SET
#define MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_GET BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_GET
#define MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_STATUSf_GET BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_STATUSf_GET
#define MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_STATUSf_SET BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr_STATUSf_SET
#define READ_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr BCM56800_A0_READ_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr
#define WRITE_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr BCM56800_A0_WRITE_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MEM_FAIL_INT_CTR
 * BLOCKS:   MMU
 * DESC:     Memory Fail Interrupt Counter
 * SIZE:     32
 * FIELDS:
 *     INT_CTR          Interrupt counter
 *
 ******************************************************************************/
#define BCM56800_A0_MEM_FAIL_INT_CTRr 0x0cd80003

#define BCM56800_A0_MEM_FAIL_INT_CTRr_SIZE 4

/*
 * This structure should be used to declare and program MEM_FAIL_INT_CTR.
 *
 */
typedef union BCM56800_A0_MEM_FAIL_INT_CTRr_s {
	uint32_t v[1];
	uint32_t mem_fail_int_ctr[1];
	uint32_t _mem_fail_int_ctr;
} BCM56800_A0_MEM_FAIL_INT_CTRr_t;

#define BCM56800_A0_MEM_FAIL_INT_CTRr_CLR(r) (r).mem_fail_int_ctr[0] = 0
#define BCM56800_A0_MEM_FAIL_INT_CTRr_SET(r,d) (r).mem_fail_int_ctr[0] = d
#define BCM56800_A0_MEM_FAIL_INT_CTRr_GET(r) (r).mem_fail_int_ctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MEM_FAIL_INT_CTRr_INT_CTRf_GET(r) ((r).mem_fail_int_ctr[0])
#define BCM56800_A0_MEM_FAIL_INT_CTRr_INT_CTRf_SET(r,f) (r).mem_fail_int_ctr[0]=((uint32_t)f)

/*
 * These macros can be used to access MEM_FAIL_INT_CTR.
 *
 */
#define BCM56800_A0_READ_MEM_FAIL_INT_CTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MEM_FAIL_INT_CTRr,(r._mem_fail_int_ctr))
#define BCM56800_A0_WRITE_MEM_FAIL_INT_CTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MEM_FAIL_INT_CTRr,&(r._mem_fail_int_ctr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FAIL_INT_CTRr BCM56800_A0_MEM_FAIL_INT_CTRr
#define MEM_FAIL_INT_CTRr_SIZE BCM56800_A0_MEM_FAIL_INT_CTRr_SIZE
typedef BCM56800_A0_MEM_FAIL_INT_CTRr_t MEM_FAIL_INT_CTRr_t;
#define MEM_FAIL_INT_CTRr_CLR BCM56800_A0_MEM_FAIL_INT_CTRr_CLR
#define MEM_FAIL_INT_CTRr_SET BCM56800_A0_MEM_FAIL_INT_CTRr_SET
#define MEM_FAIL_INT_CTRr_GET BCM56800_A0_MEM_FAIL_INT_CTRr_GET
#define MEM_FAIL_INT_CTRr_INT_CTRf_GET BCM56800_A0_MEM_FAIL_INT_CTRr_INT_CTRf_GET
#define MEM_FAIL_INT_CTRr_INT_CTRf_SET BCM56800_A0_MEM_FAIL_INT_CTRr_INT_CTRf_SET
#define READ_MEM_FAIL_INT_CTRr BCM56800_A0_READ_MEM_FAIL_INT_CTRr
#define WRITE_MEM_FAIL_INT_CTRr BCM56800_A0_WRITE_MEM_FAIL_INT_CTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MEM_FAIL_INT_CTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MEM_FAIL_INT_EN
 * BLOCKS:   MMU
 * DESC:     Memory Fail Interrupt Enable
 * SIZE:     32
 * FIELDS:
 *     AGING_CTR_PAR_ERR_EN AGING CTR parity error enable
 *     AGING_EXP_PAR_ERR_EN AGING EXP parity error enable
 *     CCP_PAR_ERR_EN   CCP parity error enable
 *     CFAP_PAR_ERR_EN  CFAP parity error enable
 *     CFAP_MEM_FAIL_EN CFAP memory fail error enable
 *     DEQ_PKTHDR_CPU_ERR_EN DEQ packet header CPU error enable
 *     DEQ_PKTHDR0_ERR_EN DEQ packet header 0 error enable
 *     DEQ0_NOT_IP_ERR_EN DEQ0 not IP error enable
 *     DEQ1_NOT_IP_ERR_EN DEQ1 not IP error enable
 *     DEQ0_CELLCRC_ERR_EN DEQ0 cell CRC error enable
 *     DEQ1_CELLCRC_ERR_EN DEQ1 cell CRC error enable
 *     ENQ_IPMC_TBL_PAR_ERR_EN ENQ IPMC table parity error enable
 *     MEM1_IPMC_TBL_PAR_ERR_EN MEM IPMC table parity error enable
 *     MEM1_VLAN_TBL_PAR_ERR_EN MEM VLAN table parity error enable
 *     TOQ0_CELLHDR_PAR_ERR_EN TOQ0 cell header parity error enable
 *     TOQ0_PKTHDR1_PAR_ERR_EN TOQ0 packet header #1 parity error enable
 *     TOQ0_PKTLINK_PAR_ERR_EN TOQ0 packet link parity error enable
 *     TOQ0_CELLLINK_PAR_ERR_EN TOQ0 cell link parity error enable
 *     TOQ0_IPMC_TBL_PAR_ERR_EN TOQ0 IPMC table parity error enable
 *     TOQ0_VLAN_TBL_PAR_ERR_EN TOQ0 VLAN table parity error enable
 *     TOQ1_CELLHDR_PAR_ERR_EN TOQ1 cell header parity error enable
 *     TOQ1_PKTHDR1_PAR_ERR_EN TOQ1 packet header #1 parity error enable
 *     TOQ1_PKTLINK_PAR_ERR_EN TOQ1 packet link parity error enable
 *     TOQ1_CELLLINK_PAR_ERR_EN TOQ1 cell link parity error enable
 *     TOQ1_IPMC_TBL_PAR_ERR_EN TOQ1 IPMC table parity error enable
 *     TOQ1_VLAN_TBL_PAR_ERR_EN TOQ1 VLAN table parity error enable
 *     MTRO_PAR_ERR_EN  MTRO parity error enable
 *
 ******************************************************************************/
#define BCM56800_A0_MEM_FAIL_INT_ENr 0x0cd80001

#define BCM56800_A0_MEM_FAIL_INT_ENr_SIZE 4

/*
 * This structure should be used to declare and program MEM_FAIL_INT_EN.
 *
 */
typedef union BCM56800_A0_MEM_FAIL_INT_ENr_s {
	uint32_t v[1];
	uint32_t mem_fail_int_en[1];
	uint32_t _mem_fail_int_en;
} BCM56800_A0_MEM_FAIL_INT_ENr_t;

#define BCM56800_A0_MEM_FAIL_INT_ENr_CLR(r) (r).mem_fail_int_en[0] = 0
#define BCM56800_A0_MEM_FAIL_INT_ENr_SET(r,d) (r).mem_fail_int_en[0] = d
#define BCM56800_A0_MEM_FAIL_INT_ENr_GET(r) (r).mem_fail_int_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MEM_FAIL_INT_ENr_AGING_CTR_PAR_ERR_ENf_GET(r) (((r).mem_fail_int_en[0]) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_AGING_CTR_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MEM_FAIL_INT_ENr_AGING_EXP_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 1) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_AGING_EXP_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MEM_FAIL_INT_ENr_CCP_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 2) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_CCP_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MEM_FAIL_INT_ENr_CFAP_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 3) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_CFAP_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MEM_FAIL_INT_ENr_CFAP_MEM_FAIL_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 4) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_CFAP_MEM_FAIL_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ_PKTHDR_CPU_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 5) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ_PKTHDR_CPU_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ_PKTHDR0_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 6) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ_PKTHDR0_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ0_NOT_IP_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 7) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ0_NOT_IP_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ1_NOT_IP_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 8) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ1_NOT_IP_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ0_CELLCRC_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 9) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ0_CELLCRC_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ1_CELLCRC_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 10) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_DEQ1_CELLCRC_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_MEM_FAIL_INT_ENr_ENQ_IPMC_TBL_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 11) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_ENQ_IPMC_TBL_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MEM_FAIL_INT_ENr_MEM1_IPMC_TBL_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 12) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_MEM1_IPMC_TBL_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_MEM_FAIL_INT_ENr_MEM1_VLAN_TBL_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 13) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_MEM1_VLAN_TBL_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_CELLHDR_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 14) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_CELLHDR_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_PKTHDR1_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 15) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_PKTHDR1_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_PKTLINK_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 16) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_PKTLINK_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_CELLLINK_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 17) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_CELLLINK_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_IPMC_TBL_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 18) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_IPMC_TBL_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_VLAN_TBL_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 19) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_VLAN_TBL_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_CELLHDR_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 20) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_CELLHDR_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_PKTHDR1_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 21) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_PKTHDR1_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_PKTLINK_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 22) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_PKTLINK_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_CELLLINK_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 23) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_CELLLINK_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_IPMC_TBL_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 24) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_IPMC_TBL_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_VLAN_TBL_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 25) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_VLAN_TBL_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_MEM_FAIL_INT_ENr_MTRO_PAR_ERR_ENf_GET(r) ((((r).mem_fail_int_en[0]) >> 26) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_ENr_MTRO_PAR_ERR_ENf_SET(r,f) (r).mem_fail_int_en[0]=(((r).mem_fail_int_en[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MEM_FAIL_INT_EN.
 *
 */
#define BCM56800_A0_READ_MEM_FAIL_INT_ENr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MEM_FAIL_INT_ENr,(r._mem_fail_int_en))
#define BCM56800_A0_WRITE_MEM_FAIL_INT_ENr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MEM_FAIL_INT_ENr,&(r._mem_fail_int_en))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FAIL_INT_ENr BCM56800_A0_MEM_FAIL_INT_ENr
#define MEM_FAIL_INT_ENr_SIZE BCM56800_A0_MEM_FAIL_INT_ENr_SIZE
typedef BCM56800_A0_MEM_FAIL_INT_ENr_t MEM_FAIL_INT_ENr_t;
#define MEM_FAIL_INT_ENr_CLR BCM56800_A0_MEM_FAIL_INT_ENr_CLR
#define MEM_FAIL_INT_ENr_SET BCM56800_A0_MEM_FAIL_INT_ENr_SET
#define MEM_FAIL_INT_ENr_GET BCM56800_A0_MEM_FAIL_INT_ENr_GET
#define MEM_FAIL_INT_ENr_AGING_CTR_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_AGING_CTR_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_AGING_CTR_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_AGING_CTR_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_AGING_EXP_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_AGING_EXP_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_AGING_EXP_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_AGING_EXP_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_CCP_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_CCP_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_CCP_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_CCP_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_CFAP_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_CFAP_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_CFAP_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_CFAP_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_CFAP_MEM_FAIL_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_CFAP_MEM_FAIL_ENf_GET
#define MEM_FAIL_INT_ENr_CFAP_MEM_FAIL_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_CFAP_MEM_FAIL_ENf_SET
#define MEM_FAIL_INT_ENr_DEQ_PKTHDR_CPU_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ_PKTHDR_CPU_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_DEQ_PKTHDR_CPU_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ_PKTHDR_CPU_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_DEQ_PKTHDR0_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ_PKTHDR0_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_DEQ_PKTHDR0_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ_PKTHDR0_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_DEQ0_NOT_IP_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ0_NOT_IP_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_DEQ0_NOT_IP_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ0_NOT_IP_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_DEQ1_NOT_IP_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ1_NOT_IP_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_DEQ1_NOT_IP_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ1_NOT_IP_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_DEQ0_CELLCRC_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ0_CELLCRC_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_DEQ0_CELLCRC_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ0_CELLCRC_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_DEQ1_CELLCRC_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ1_CELLCRC_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_DEQ1_CELLCRC_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_DEQ1_CELLCRC_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_ENQ_IPMC_TBL_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_ENQ_IPMC_TBL_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_ENQ_IPMC_TBL_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_ENQ_IPMC_TBL_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_MEM1_IPMC_TBL_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_MEM1_IPMC_TBL_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_MEM1_IPMC_TBL_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_MEM1_IPMC_TBL_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_MEM1_VLAN_TBL_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_MEM1_VLAN_TBL_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_MEM1_VLAN_TBL_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_MEM1_VLAN_TBL_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ0_CELLHDR_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_CELLHDR_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ0_CELLHDR_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_CELLHDR_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ0_PKTHDR1_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_PKTHDR1_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ0_PKTHDR1_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_PKTHDR1_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ0_PKTLINK_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_PKTLINK_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ0_PKTLINK_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_PKTLINK_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ0_CELLLINK_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_CELLLINK_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ0_CELLLINK_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_CELLLINK_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ0_IPMC_TBL_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_IPMC_TBL_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ0_IPMC_TBL_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_IPMC_TBL_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ0_VLAN_TBL_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_VLAN_TBL_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ0_VLAN_TBL_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ0_VLAN_TBL_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ1_CELLHDR_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_CELLHDR_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ1_CELLHDR_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_CELLHDR_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ1_PKTHDR1_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_PKTHDR1_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ1_PKTHDR1_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_PKTHDR1_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ1_PKTLINK_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_PKTLINK_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ1_PKTLINK_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_PKTLINK_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ1_CELLLINK_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_CELLLINK_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ1_CELLLINK_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_CELLLINK_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ1_IPMC_TBL_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_IPMC_TBL_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ1_IPMC_TBL_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_IPMC_TBL_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_TOQ1_VLAN_TBL_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_VLAN_TBL_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_TOQ1_VLAN_TBL_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_TOQ1_VLAN_TBL_PAR_ERR_ENf_SET
#define MEM_FAIL_INT_ENr_MTRO_PAR_ERR_ENf_GET BCM56800_A0_MEM_FAIL_INT_ENr_MTRO_PAR_ERR_ENf_GET
#define MEM_FAIL_INT_ENr_MTRO_PAR_ERR_ENf_SET BCM56800_A0_MEM_FAIL_INT_ENr_MTRO_PAR_ERR_ENf_SET
#define READ_MEM_FAIL_INT_ENr BCM56800_A0_READ_MEM_FAIL_INT_ENr
#define WRITE_MEM_FAIL_INT_ENr BCM56800_A0_WRITE_MEM_FAIL_INT_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MEM_FAIL_INT_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MEM_FAIL_INT_STAT
 * BLOCKS:   MMU
 * DESC:     Memory Fail Interrupt Status
 * SIZE:     32
 * FIELDS:
 *     AGING_CTR_PAR_ERR AGING CTR parity error
 *     AGING_EXP_PAR_ERR AGING EXP parity error
 *     CCP_PAR_ERR      CCP parity error
 *     CFAP_PAR_ERR     CFAP parity error
 *     CFAP_MEM_FAIL    CFAP memory fail error
 *     DEQ_PKTHDR_CPU_ERR DEQ packet header CPU error
 *     DEQ_PKTHDR0_ERR  DEQ packet header 0 error
 *     DEQ0_NOT_IP_ERR  DEQ0 not IP error
 *     DEQ1_NOT_IP_ERR  DEQ1 not IP error
 *     DEQ0_CELLCRC_ERR DEQ0 cell CRC error
 *     DEQ1_CELLCRC_ERR DEQ1 cell CRC error
 *     ENQ_IPMC_TBL_PAR_ERR ENQ IPMC table parity error
 *     MEM1_IPMC_TBL_PAR_ERR MEM IPMC table parity error
 *     MEM1_VLAN_TBL_PAR_ERR MEM VLAN table parity error
 *     TOQ0_CELLHDR_PAR_ERR TOQ0 cell header parity error
 *     TOQ0_PKTHDR1_PAR_ERR TOQ0 packet header #1 parity error
 *     TOQ0_PKTLINK_PAR_ERR TOQ0 packet link parity error
 *     TOQ0_CELLLINK_PAR_ERR TOQ0 cell link parity error
 *     TOQ0_IPMC_TBL_PAR_ERR TOQ0 IPMC table parity error
 *     TOQ0_VLAN_TBL_PAR_ERR TOQ0 VLAN table parity error
 *     TOQ1_CELLHDR_PAR_ERR TOQ1 cell header parity error
 *     TOQ1_PKTHDR1_PAR_ERR TOQ1 packet header #1 parity error
 *     TOQ1_PKTLINK_PAR_ERR TOQ1 packet link parity error
 *     TOQ1_CELLLINK_PAR_ERR TOQ1 cell link parity error
 *     TOQ1_IPMC_TBL_PAR_ERR TOQ1 IPMC table parity error
 *     TOQ1_VLAN_TBL_PAR_ERR TOQ1 VLAN table parity error
 *     MTRO_PAR_ERR     MTRO parity error
 *
 ******************************************************************************/
#define BCM56800_A0_MEM_FAIL_INT_STATr 0x0cd80002

#define BCM56800_A0_MEM_FAIL_INT_STATr_SIZE 4

/*
 * This structure should be used to declare and program MEM_FAIL_INT_STAT.
 *
 */
typedef union BCM56800_A0_MEM_FAIL_INT_STATr_s {
	uint32_t v[1];
	uint32_t mem_fail_int_stat[1];
	uint32_t _mem_fail_int_stat;
} BCM56800_A0_MEM_FAIL_INT_STATr_t;

#define BCM56800_A0_MEM_FAIL_INT_STATr_CLR(r) (r).mem_fail_int_stat[0] = 0
#define BCM56800_A0_MEM_FAIL_INT_STATr_SET(r,d) (r).mem_fail_int_stat[0] = d
#define BCM56800_A0_MEM_FAIL_INT_STATr_GET(r) (r).mem_fail_int_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MEM_FAIL_INT_STATr_AGING_CTR_PAR_ERRf_GET(r) (((r).mem_fail_int_stat[0]) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_AGING_CTR_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MEM_FAIL_INT_STATr_AGING_EXP_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 1) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_AGING_EXP_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MEM_FAIL_INT_STATr_CCP_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 2) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_CCP_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MEM_FAIL_INT_STATr_CFAP_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 3) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_CFAP_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MEM_FAIL_INT_STATr_CFAP_MEM_FAILf_GET(r) ((((r).mem_fail_int_stat[0]) >> 4) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_CFAP_MEM_FAILf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ_PKTHDR_CPU_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 5) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ_PKTHDR_CPU_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ_PKTHDR0_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 6) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ_PKTHDR0_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ0_NOT_IP_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 7) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ0_NOT_IP_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ1_NOT_IP_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 8) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ1_NOT_IP_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ0_CELLCRC_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 9) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ0_CELLCRC_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ1_CELLCRC_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 10) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_DEQ1_CELLCRC_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_MEM_FAIL_INT_STATr_ENQ_IPMC_TBL_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 11) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_ENQ_IPMC_TBL_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MEM_FAIL_INT_STATr_MEM1_IPMC_TBL_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 12) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_MEM1_IPMC_TBL_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_MEM_FAIL_INT_STATr_MEM1_VLAN_TBL_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 13) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_MEM1_VLAN_TBL_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_CELLHDR_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 14) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_CELLHDR_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_PKTHDR1_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 15) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_PKTHDR1_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_PKTLINK_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 16) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_PKTLINK_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_CELLLINK_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 17) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_CELLLINK_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_IPMC_TBL_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 18) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_IPMC_TBL_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_VLAN_TBL_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 19) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_VLAN_TBL_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_CELLHDR_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 20) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_CELLHDR_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_PKTHDR1_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 21) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_PKTHDR1_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_PKTLINK_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 22) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_PKTLINK_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_CELLLINK_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 23) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_CELLLINK_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_IPMC_TBL_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 24) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_IPMC_TBL_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_VLAN_TBL_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 25) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_VLAN_TBL_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_MEM_FAIL_INT_STATr_MTRO_PAR_ERRf_GET(r) ((((r).mem_fail_int_stat[0]) >> 26) & 0x1)
#define BCM56800_A0_MEM_FAIL_INT_STATr_MTRO_PAR_ERRf_SET(r,f) (r).mem_fail_int_stat[0]=(((r).mem_fail_int_stat[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MEM_FAIL_INT_STAT.
 *
 */
#define BCM56800_A0_READ_MEM_FAIL_INT_STATr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MEM_FAIL_INT_STATr,(r._mem_fail_int_stat))
#define BCM56800_A0_WRITE_MEM_FAIL_INT_STATr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MEM_FAIL_INT_STATr,&(r._mem_fail_int_stat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FAIL_INT_STATr BCM56800_A0_MEM_FAIL_INT_STATr
#define MEM_FAIL_INT_STATr_SIZE BCM56800_A0_MEM_FAIL_INT_STATr_SIZE
typedef BCM56800_A0_MEM_FAIL_INT_STATr_t MEM_FAIL_INT_STATr_t;
#define MEM_FAIL_INT_STATr_CLR BCM56800_A0_MEM_FAIL_INT_STATr_CLR
#define MEM_FAIL_INT_STATr_SET BCM56800_A0_MEM_FAIL_INT_STATr_SET
#define MEM_FAIL_INT_STATr_GET BCM56800_A0_MEM_FAIL_INT_STATr_GET
#define MEM_FAIL_INT_STATr_AGING_CTR_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_AGING_CTR_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_AGING_CTR_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_AGING_CTR_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_AGING_EXP_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_AGING_EXP_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_AGING_EXP_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_AGING_EXP_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_CCP_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_CCP_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_CCP_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_CCP_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_CFAP_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_CFAP_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_CFAP_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_CFAP_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_CFAP_MEM_FAILf_GET BCM56800_A0_MEM_FAIL_INT_STATr_CFAP_MEM_FAILf_GET
#define MEM_FAIL_INT_STATr_CFAP_MEM_FAILf_SET BCM56800_A0_MEM_FAIL_INT_STATr_CFAP_MEM_FAILf_SET
#define MEM_FAIL_INT_STATr_DEQ_PKTHDR_CPU_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ_PKTHDR_CPU_ERRf_GET
#define MEM_FAIL_INT_STATr_DEQ_PKTHDR_CPU_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ_PKTHDR_CPU_ERRf_SET
#define MEM_FAIL_INT_STATr_DEQ_PKTHDR0_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ_PKTHDR0_ERRf_GET
#define MEM_FAIL_INT_STATr_DEQ_PKTHDR0_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ_PKTHDR0_ERRf_SET
#define MEM_FAIL_INT_STATr_DEQ0_NOT_IP_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ0_NOT_IP_ERRf_GET
#define MEM_FAIL_INT_STATr_DEQ0_NOT_IP_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ0_NOT_IP_ERRf_SET
#define MEM_FAIL_INT_STATr_DEQ1_NOT_IP_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ1_NOT_IP_ERRf_GET
#define MEM_FAIL_INT_STATr_DEQ1_NOT_IP_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ1_NOT_IP_ERRf_SET
#define MEM_FAIL_INT_STATr_DEQ0_CELLCRC_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ0_CELLCRC_ERRf_GET
#define MEM_FAIL_INT_STATr_DEQ0_CELLCRC_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ0_CELLCRC_ERRf_SET
#define MEM_FAIL_INT_STATr_DEQ1_CELLCRC_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ1_CELLCRC_ERRf_GET
#define MEM_FAIL_INT_STATr_DEQ1_CELLCRC_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_DEQ1_CELLCRC_ERRf_SET
#define MEM_FAIL_INT_STATr_ENQ_IPMC_TBL_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_ENQ_IPMC_TBL_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_ENQ_IPMC_TBL_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_ENQ_IPMC_TBL_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_MEM1_IPMC_TBL_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_MEM1_IPMC_TBL_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_MEM1_IPMC_TBL_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_MEM1_IPMC_TBL_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_MEM1_VLAN_TBL_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_MEM1_VLAN_TBL_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_MEM1_VLAN_TBL_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_MEM1_VLAN_TBL_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ0_CELLHDR_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_CELLHDR_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ0_CELLHDR_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_CELLHDR_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ0_PKTHDR1_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_PKTHDR1_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ0_PKTHDR1_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_PKTHDR1_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ0_PKTLINK_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_PKTLINK_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ0_PKTLINK_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_PKTLINK_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ0_CELLLINK_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_CELLLINK_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ0_CELLLINK_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_CELLLINK_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ0_IPMC_TBL_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_IPMC_TBL_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ0_IPMC_TBL_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_IPMC_TBL_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ0_VLAN_TBL_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_VLAN_TBL_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ0_VLAN_TBL_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ0_VLAN_TBL_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ1_CELLHDR_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_CELLHDR_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ1_CELLHDR_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_CELLHDR_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ1_PKTHDR1_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_PKTHDR1_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ1_PKTHDR1_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_PKTHDR1_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ1_PKTLINK_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_PKTLINK_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ1_PKTLINK_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_PKTLINK_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ1_CELLLINK_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_CELLLINK_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ1_CELLLINK_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_CELLLINK_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ1_IPMC_TBL_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_IPMC_TBL_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ1_IPMC_TBL_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_IPMC_TBL_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_TOQ1_VLAN_TBL_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_VLAN_TBL_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_TOQ1_VLAN_TBL_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_TOQ1_VLAN_TBL_PAR_ERRf_SET
#define MEM_FAIL_INT_STATr_MTRO_PAR_ERRf_GET BCM56800_A0_MEM_FAIL_INT_STATr_MTRO_PAR_ERRf_GET
#define MEM_FAIL_INT_STATr_MTRO_PAR_ERRf_SET BCM56800_A0_MEM_FAIL_INT_STATr_MTRO_PAR_ERRf_SET
#define READ_MEM_FAIL_INT_STATr BCM56800_A0_READ_MEM_FAIL_INT_STATr
#define WRITE_MEM_FAIL_INT_STATr BCM56800_A0_WRITE_MEM_FAIL_INT_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MEM_FAIL_INT_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MINBUCKET
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_BUCKET       Minimum rate bucket with unit is 0.5 bit.
 *     OUT_PROFILE_FLAG OUT_PROFILE_FLAG inidcates the current state of minimum rate bucket1: out of profile0: In profileDefault value is out of profile.
 *     PARITY           Parity for min bucket and flag fields
 *
 ******************************************************************************/
#define BCM56800_A0_MINBUCKETr 0x0ad00008

#define BCM56800_A0_MINBUCKETr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKET.
 *
 */
typedef union BCM56800_A0_MINBUCKETr_s {
	uint32_t v[1];
	uint32_t minbucket[1];
	uint32_t _minbucket;
} BCM56800_A0_MINBUCKETr_t;

#define BCM56800_A0_MINBUCKETr_CLR(r) (r).minbucket[0] = 0
#define BCM56800_A0_MINBUCKETr_SET(r,d) (r).minbucket[0] = d
#define BCM56800_A0_MINBUCKETr_GET(r) (r).minbucket[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MINBUCKETr_MIN_BUCKETf_GET(r) (((r).minbucket[0]) & 0x1fffffff)
#define BCM56800_A0_MINBUCKETr_MIN_BUCKETf_SET(r,f) (r).minbucket[0]=(((r).minbucket[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))
#define BCM56800_A0_MINBUCKETr_OUT_PROFILE_FLAGf_GET(r) ((((r).minbucket[0]) >> 29) & 0x1)
#define BCM56800_A0_MINBUCKETr_OUT_PROFILE_FLAGf_SET(r,f) (r).minbucket[0]=(((r).minbucket[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_MINBUCKETr_PARITYf_GET(r) ((((r).minbucket[0]) >> 30) & 0x1)
#define BCM56800_A0_MINBUCKETr_PARITYf_SET(r,f) (r).minbucket[0]=(((r).minbucket[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))

/*
 * These macros can be used to access MINBUCKET.
 *
 */
#define BCM56800_A0_READ_MINBUCKETr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MINBUCKETr+(i),(r._minbucket))
#define BCM56800_A0_WRITE_MINBUCKETr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MINBUCKETr+(i),&(r._minbucket))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETr BCM56800_A0_MINBUCKETr
#define MINBUCKETr_SIZE BCM56800_A0_MINBUCKETr_SIZE
typedef BCM56800_A0_MINBUCKETr_t MINBUCKETr_t;
#define MINBUCKETr_CLR BCM56800_A0_MINBUCKETr_CLR
#define MINBUCKETr_SET BCM56800_A0_MINBUCKETr_SET
#define MINBUCKETr_GET BCM56800_A0_MINBUCKETr_GET
#define MINBUCKETr_MIN_BUCKETf_GET BCM56800_A0_MINBUCKETr_MIN_BUCKETf_GET
#define MINBUCKETr_MIN_BUCKETf_SET BCM56800_A0_MINBUCKETr_MIN_BUCKETf_SET
#define MINBUCKETr_OUT_PROFILE_FLAGf_GET BCM56800_A0_MINBUCKETr_OUT_PROFILE_FLAGf_GET
#define MINBUCKETr_OUT_PROFILE_FLAGf_SET BCM56800_A0_MINBUCKETr_OUT_PROFILE_FLAGf_SET
#define MINBUCKETr_PARITYf_GET BCM56800_A0_MINBUCKETr_PARITYf_GET
#define MINBUCKETr_PARITYf_SET BCM56800_A0_MINBUCKETr_PARITYf_SET
#define READ_MINBUCKETr BCM56800_A0_READ_MINBUCKETr
#define WRITE_MINBUCKETr BCM56800_A0_WRITE_MINBUCKETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MINBUCKETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MINBUCKETCONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     MIN_LO_THD_SEL   Low Threshold for Minimum bucket.The setting of Threshold determines the burstness it can send before bucket hit the low threshold and becomes out-profile status (Meet minimum bandwdith requirement)This Low Threshold setting is not related to Minimumm rate. 0x0: Disable, Minimum Bucket function is disabled.0x1:  32k bits, (32*1024),0x2:  64k bits, (64*1024),0x3: 128k bits, (128*1024),0x4: 256k bits, (256*1024),0x5: 512k bits, (512*1024),0x6:   1M bits, (1024*1024),0x7:   2M bits, (2*1024*1024),0x8:   4M bits, (4*1024*1024),0x9:   8M bits, (8*1024*1024),0xa:  16M bits, (16*1024*1024),0xb:  32M bits, (32*1024*1024),0xc:  64M bits, (64*1024*1024),0xd: 128M bits, (128*1024*1024),0xe: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,0xf: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,
 *     MIN_HI_THD_SEL   High Threshold for minimum rate bucket.The setting of Threshold determines the size of Minimum Bucket. (Meet minimum bandwdith requirement)This High Threshold setting is not related to Minimumm rate. 0x0: Disable, Minimum Bucket function is disabled.0x1:  32k bits, (32*1024),0x2:  64k bits, (64*1024),0x3: 128k bits, (128*1024),0x4: 256k bits, (256*1024),0x5: 512k bits, (512*1024),0x6:   1M bits, (1024*1024),0x7:   2M bits, (2*1024*1024),0x8:   4M bits, (4*1024*1024),0x9:   8M bits, (8*1024*1024),0xa:  16M bits, (16*1024*1024),0xb:  32M bits, (32*1024*1024),0xc:  64M bits, (64*1024*1024),0xd: 128M bits, (128*1024*1024),0xe: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,0xf: 128M bits, (128*1024*1024), Bucket saturated at 128M bits,
 *     MIN_REFRESH      Refresh count for minimum rate bucket. Every unit of REFRESH represents 64,000 bps, (bits per second).Example 1:  To set metering rate to 500 Mbps (500,000,000 bps),             should set REFRESH = 7812,Example 2:  To set metering rate to 1 Gbps (1,000,000,000 bps),             should set REFRESH = 15624.
 *     PARITY           Parity for min bucket config fields
 *
 ******************************************************************************/
#define BCM56800_A0_MINBUCKETCONFIGr 0x0ad00000

#define BCM56800_A0_MINBUCKETCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MINBUCKETCONFIG.
 *
 */
typedef union BCM56800_A0_MINBUCKETCONFIGr_s {
	uint32_t v[1];
	uint32_t minbucketconfig[1];
	uint32_t _minbucketconfig;
} BCM56800_A0_MINBUCKETCONFIGr_t;

#define BCM56800_A0_MINBUCKETCONFIGr_CLR(r) (r).minbucketconfig[0] = 0
#define BCM56800_A0_MINBUCKETCONFIGr_SET(r,d) (r).minbucketconfig[0] = d
#define BCM56800_A0_MINBUCKETCONFIGr_GET(r) (r).minbucketconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MINBUCKETCONFIGr_MIN_LO_THD_SELf_GET(r) (((r).minbucketconfig[0]) & 0xf)
#define BCM56800_A0_MINBUCKETCONFIGr_MIN_LO_THD_SELf_SET(r,f) (r).minbucketconfig[0]=(((r).minbucketconfig[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_MINBUCKETCONFIGr_MIN_HI_THD_SELf_GET(r) ((((r).minbucketconfig[0]) >> 4) & 0xf)
#define BCM56800_A0_MINBUCKETCONFIGr_MIN_HI_THD_SELf_SET(r,f) (r).minbucketconfig[0]=(((r).minbucketconfig[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_MINBUCKETCONFIGr_MIN_REFRESHf_GET(r) ((((r).minbucketconfig[0]) >> 8) & 0x3ffff)
#define BCM56800_A0_MINBUCKETCONFIGr_MIN_REFRESHf_SET(r,f) (r).minbucketconfig[0]=(((r).minbucketconfig[0] & ~((uint32_t)0x3ffff << 8)) | ((((uint32_t)f) & 0x3ffff) << 8))
#define BCM56800_A0_MINBUCKETCONFIGr_PARITYf_GET(r) ((((r).minbucketconfig[0]) >> 26) & 0x1)
#define BCM56800_A0_MINBUCKETCONFIGr_PARITYf_SET(r,f) (r).minbucketconfig[0]=(((r).minbucketconfig[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))

/*
 * These macros can be used to access MINBUCKETCONFIG.
 *
 */
#define BCM56800_A0_READ_MINBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MINBUCKETCONFIGr+(i),(r._minbucketconfig))
#define BCM56800_A0_WRITE_MINBUCKETCONFIGr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MINBUCKETCONFIGr+(i),&(r._minbucketconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINBUCKETCONFIGr BCM56800_A0_MINBUCKETCONFIGr
#define MINBUCKETCONFIGr_SIZE BCM56800_A0_MINBUCKETCONFIGr_SIZE
typedef BCM56800_A0_MINBUCKETCONFIGr_t MINBUCKETCONFIGr_t;
#define MINBUCKETCONFIGr_CLR BCM56800_A0_MINBUCKETCONFIGr_CLR
#define MINBUCKETCONFIGr_SET BCM56800_A0_MINBUCKETCONFIGr_SET
#define MINBUCKETCONFIGr_GET BCM56800_A0_MINBUCKETCONFIGr_GET
#define MINBUCKETCONFIGr_MIN_LO_THD_SELf_GET BCM56800_A0_MINBUCKETCONFIGr_MIN_LO_THD_SELf_GET
#define MINBUCKETCONFIGr_MIN_LO_THD_SELf_SET BCM56800_A0_MINBUCKETCONFIGr_MIN_LO_THD_SELf_SET
#define MINBUCKETCONFIGr_MIN_HI_THD_SELf_GET BCM56800_A0_MINBUCKETCONFIGr_MIN_HI_THD_SELf_GET
#define MINBUCKETCONFIGr_MIN_HI_THD_SELf_SET BCM56800_A0_MINBUCKETCONFIGr_MIN_HI_THD_SELf_SET
#define MINBUCKETCONFIGr_MIN_REFRESHf_GET BCM56800_A0_MINBUCKETCONFIGr_MIN_REFRESHf_GET
#define MINBUCKETCONFIGr_MIN_REFRESHf_SET BCM56800_A0_MINBUCKETCONFIGr_MIN_REFRESHf_SET
#define MINBUCKETCONFIGr_PARITYf_GET BCM56800_A0_MINBUCKETCONFIGr_PARITYf_GET
#define MINBUCKETCONFIGr_PARITYf_SET BCM56800_A0_MINBUCKETCONFIGr_PARITYf_SET
#define READ_MINBUCKETCONFIGr BCM56800_A0_READ_MINBUCKETCONFIGr
#define WRITE_MINBUCKETCONFIGr BCM56800_A0_WRITE_MINBUCKETCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MINBUCKETCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MINSPCONFIG
 * BLOCKS:   MMU
 * DESC:     Select a COS Queue as Strict Priority when schedule in MinBW modes
 * SIZE:     32
 * FIELDS:
 *     COS0_IS_SP       When in MinBW, set this bit will treat this COS queue as stric Priority whenshcduling between 8 different queues. If reset to zero, this COS queue willfollow round robin fashion with other round-robined COS queue.Larger the number, higher the priority.
 *     COS1_IS_SP       When in MinBW, set this bit will treat this COS queue as stric Priority whenshcduling between 8 different queues. If reset to zero, this COS queue willfollow round robin fashion with other round-robined COS queue.Larger the number, higher the priority.
 *     COS2_IS_SP       When in MinBW, set this bit will treat this COS queue as stric Priority whenshcduling between 8 different queues. If reset to zero, this COS queue willfollow round robin fashion with other round-robined COS queue.Larger the number, higher the priority.
 *     COS3_IS_SP       When in MinBW, set this bit will treat this COS queue as stric Priority whenshcduling between 8 different queues. If reset to zero, this COS queue willfollow round robin fashion with other round-robined COS queue.Larger the number, higher the priority.
 *     COS4_IS_SP       When in MinBW, set this bit will treat this COS queue as stric Priority whenshcduling between 8 different queues. If reset to zero, this COS queue willfollow round robin fashion with other round-robined COS queue.Larger the number, higher the priority.
 *     COS5_IS_SP       When in MinBW, set this bit will treat this COS queue as stric Priority whenshcduling between 8 different queues. If reset to zero, this COS queue willfollow round robin fashion with other round-robined COS queue.Larger the number, higher the priority.
 *     COS6_IS_SP       When in MinBW, set this bit will treat this COS queue as stric Priority whenshcduling between 8 different queues. If reset to zero, this COS queue willfollow round robin fashion with other round-robined COS queue.Larger the number, higher the priority.
 *     COS7_IS_SP       When in MinBW, set this bit will treat this COS queue as stric Priority whenshcduling between 8 different queues. If reset to zero, this COS queue willfollow round robin fashion with other round-robined COS queue.Larger the number, higher the priority.
 *
 ******************************************************************************/
#define BCM56800_A0_MINSPCONFIGr 0x06d00050

#define BCM56800_A0_MINSPCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MINSPCONFIG.
 *
 */
typedef union BCM56800_A0_MINSPCONFIGr_s {
	uint32_t v[1];
	uint32_t minspconfig[1];
	uint32_t _minspconfig;
} BCM56800_A0_MINSPCONFIGr_t;

#define BCM56800_A0_MINSPCONFIGr_CLR(r) (r).minspconfig[0] = 0
#define BCM56800_A0_MINSPCONFIGr_SET(r,d) (r).minspconfig[0] = d
#define BCM56800_A0_MINSPCONFIGr_GET(r) (r).minspconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MINSPCONFIGr_COS0_IS_SPf_GET(r) (((r).minspconfig[0]) & 0x1)
#define BCM56800_A0_MINSPCONFIGr_COS0_IS_SPf_SET(r,f) (r).minspconfig[0]=(((r).minspconfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MINSPCONFIGr_COS1_IS_SPf_GET(r) ((((r).minspconfig[0]) >> 1) & 0x1)
#define BCM56800_A0_MINSPCONFIGr_COS1_IS_SPf_SET(r,f) (r).minspconfig[0]=(((r).minspconfig[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MINSPCONFIGr_COS2_IS_SPf_GET(r) ((((r).minspconfig[0]) >> 2) & 0x1)
#define BCM56800_A0_MINSPCONFIGr_COS2_IS_SPf_SET(r,f) (r).minspconfig[0]=(((r).minspconfig[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MINSPCONFIGr_COS3_IS_SPf_GET(r) ((((r).minspconfig[0]) >> 3) & 0x1)
#define BCM56800_A0_MINSPCONFIGr_COS3_IS_SPf_SET(r,f) (r).minspconfig[0]=(((r).minspconfig[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MINSPCONFIGr_COS4_IS_SPf_GET(r) ((((r).minspconfig[0]) >> 4) & 0x1)
#define BCM56800_A0_MINSPCONFIGr_COS4_IS_SPf_SET(r,f) (r).minspconfig[0]=(((r).minspconfig[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MINSPCONFIGr_COS5_IS_SPf_GET(r) ((((r).minspconfig[0]) >> 5) & 0x1)
#define BCM56800_A0_MINSPCONFIGr_COS5_IS_SPf_SET(r,f) (r).minspconfig[0]=(((r).minspconfig[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_MINSPCONFIGr_COS6_IS_SPf_GET(r) ((((r).minspconfig[0]) >> 6) & 0x1)
#define BCM56800_A0_MINSPCONFIGr_COS6_IS_SPf_SET(r,f) (r).minspconfig[0]=(((r).minspconfig[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_MINSPCONFIGr_COS7_IS_SPf_GET(r) ((((r).minspconfig[0]) >> 7) & 0x1)
#define BCM56800_A0_MINSPCONFIGr_COS7_IS_SPf_SET(r,f) (r).minspconfig[0]=(((r).minspconfig[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MINSPCONFIG.
 *
 */
#define BCM56800_A0_READ_MINSPCONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MINSPCONFIGr,(r._minspconfig))
#define BCM56800_A0_WRITE_MINSPCONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MINSPCONFIGr,&(r._minspconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINSPCONFIGr BCM56800_A0_MINSPCONFIGr
#define MINSPCONFIGr_SIZE BCM56800_A0_MINSPCONFIGr_SIZE
typedef BCM56800_A0_MINSPCONFIGr_t MINSPCONFIGr_t;
#define MINSPCONFIGr_CLR BCM56800_A0_MINSPCONFIGr_CLR
#define MINSPCONFIGr_SET BCM56800_A0_MINSPCONFIGr_SET
#define MINSPCONFIGr_GET BCM56800_A0_MINSPCONFIGr_GET
#define MINSPCONFIGr_COS0_IS_SPf_GET BCM56800_A0_MINSPCONFIGr_COS0_IS_SPf_GET
#define MINSPCONFIGr_COS0_IS_SPf_SET BCM56800_A0_MINSPCONFIGr_COS0_IS_SPf_SET
#define MINSPCONFIGr_COS1_IS_SPf_GET BCM56800_A0_MINSPCONFIGr_COS1_IS_SPf_GET
#define MINSPCONFIGr_COS1_IS_SPf_SET BCM56800_A0_MINSPCONFIGr_COS1_IS_SPf_SET
#define MINSPCONFIGr_COS2_IS_SPf_GET BCM56800_A0_MINSPCONFIGr_COS2_IS_SPf_GET
#define MINSPCONFIGr_COS2_IS_SPf_SET BCM56800_A0_MINSPCONFIGr_COS2_IS_SPf_SET
#define MINSPCONFIGr_COS3_IS_SPf_GET BCM56800_A0_MINSPCONFIGr_COS3_IS_SPf_GET
#define MINSPCONFIGr_COS3_IS_SPf_SET BCM56800_A0_MINSPCONFIGr_COS3_IS_SPf_SET
#define MINSPCONFIGr_COS4_IS_SPf_GET BCM56800_A0_MINSPCONFIGr_COS4_IS_SPf_GET
#define MINSPCONFIGr_COS4_IS_SPf_SET BCM56800_A0_MINSPCONFIGr_COS4_IS_SPf_SET
#define MINSPCONFIGr_COS5_IS_SPf_GET BCM56800_A0_MINSPCONFIGr_COS5_IS_SPf_GET
#define MINSPCONFIGr_COS5_IS_SPf_SET BCM56800_A0_MINSPCONFIGr_COS5_IS_SPf_SET
#define MINSPCONFIGr_COS6_IS_SPf_GET BCM56800_A0_MINSPCONFIGr_COS6_IS_SPf_GET
#define MINSPCONFIGr_COS6_IS_SPf_SET BCM56800_A0_MINSPCONFIGr_COS6_IS_SPf_SET
#define MINSPCONFIGr_COS7_IS_SPf_GET BCM56800_A0_MINSPCONFIGr_COS7_IS_SPf_GET
#define MINSPCONFIGr_COS7_IS_SPf_SET BCM56800_A0_MINSPCONFIGr_COS7_IS_SPf_SET
#define READ_MINSPCONFIGr BCM56800_A0_READ_MINSPCONFIGr
#define WRITE_MINSPCONFIGr BCM56800_A0_WRITE_MINSPCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MINSPCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MIRROR_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Mirror control register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     M_ENABLE         Enable mirroring
 *     IM_MTP_INDEX     Ingress MTP index
 *     EM_MTP_INDEX     Egress MTP index
 *     NON_UC_EM_MTP_INDEX Non-unicast egress MTP index
 *     SRC_MODID_BLOCK_MIRROR_ONLY_PKT Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=1, MH.MD=0 ports
 *     SRC_MODID_BLOCK_MIRROR_COPY Apply the source modid block masks, programmed in SRC_MODID_BLOCK table, for MTP of HiGig pkts with MH.M=1, MH.MO=0, MH.MD=0 ports
 *
 ******************************************************************************/
#define BCM56800_A0_MIRROR_CONTROLr 0x0e100643

#define BCM56800_A0_MIRROR_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program MIRROR_CONTROL.
 *
 */
typedef union BCM56800_A0_MIRROR_CONTROLr_s {
	uint32_t v[1];
	uint32_t mirror_control[1];
	uint32_t _mirror_control;
} BCM56800_A0_MIRROR_CONTROLr_t;

#define BCM56800_A0_MIRROR_CONTROLr_CLR(r) (r).mirror_control[0] = 0
#define BCM56800_A0_MIRROR_CONTROLr_SET(r,d) (r).mirror_control[0] = d
#define BCM56800_A0_MIRROR_CONTROLr_GET(r) (r).mirror_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MIRROR_CONTROLr_M_ENABLEf_GET(r) (((r).mirror_control[0]) & 0x1)
#define BCM56800_A0_MIRROR_CONTROLr_M_ENABLEf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 1) & 0x3)
#define BCM56800_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM56800_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 3) & 0x3)
#define BCM56800_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM56800_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET(r) ((((r).mirror_control[0]) >> 5) & 0x3)
#define BCM56800_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56800_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET(r) ((((r).mirror_control[0]) >> 7) & 0x1)
#define BCM56800_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET(r) ((((r).mirror_control[0]) >> 8) & 0x1)
#define BCM56800_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET(r,f) (r).mirror_control[0]=(((r).mirror_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MIRROR_CONTROL.
 *
 */
#define BCM56800_A0_READ_MIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MIRROR_CONTROLr,(r._mirror_control))
#define BCM56800_A0_WRITE_MIRROR_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MIRROR_CONTROLr,&(r._mirror_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRROR_CONTROLr BCM56800_A0_MIRROR_CONTROLr
#define MIRROR_CONTROLr_SIZE BCM56800_A0_MIRROR_CONTROLr_SIZE
typedef BCM56800_A0_MIRROR_CONTROLr_t MIRROR_CONTROLr_t;
#define MIRROR_CONTROLr_CLR BCM56800_A0_MIRROR_CONTROLr_CLR
#define MIRROR_CONTROLr_SET BCM56800_A0_MIRROR_CONTROLr_SET
#define MIRROR_CONTROLr_GET BCM56800_A0_MIRROR_CONTROLr_GET
#define MIRROR_CONTROLr_M_ENABLEf_GET BCM56800_A0_MIRROR_CONTROLr_M_ENABLEf_GET
#define MIRROR_CONTROLr_M_ENABLEf_SET BCM56800_A0_MIRROR_CONTROLr_M_ENABLEf_SET
#define MIRROR_CONTROLr_IM_MTP_INDEXf_GET BCM56800_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_IM_MTP_INDEXf_SET BCM56800_A0_MIRROR_CONTROLr_IM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_EM_MTP_INDEXf_GET BCM56800_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_EM_MTP_INDEXf_SET BCM56800_A0_MIRROR_CONTROLr_EM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET BCM56800_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_GET
#define MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET BCM56800_A0_MIRROR_CONTROLr_NON_UC_EM_MTP_INDEXf_SET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET BCM56800_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_GET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET BCM56800_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_ONLY_PKTf_SET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET BCM56800_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_GET
#define MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET BCM56800_A0_MIRROR_CONTROLr_SRC_MODID_BLOCK_MIRROR_COPYf_SET
#define READ_MIRROR_CONTROLr BCM56800_A0_READ_MIRROR_CONTROLr
#define WRITE_MIRROR_CONTROLr BCM56800_A0_WRITE_MIRROR_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MIRROR_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MISCCONFIG
 * BLOCKS:   MMU
 * DESC:     Controls various functions in the MMU
 * SIZE:     32
 * FIELDS:
 *     METERING_CLK_EN  SW overlay: Clock refresh enable
 *     SLAM_MEM         Stop memory initialization
 *     PARITY_CHK_EN    Enable hardare to check parity bit
 *     PARITY_GEN_EN    Enable hardare to generate parity bit
 *     PARITY_STAT_CLEAR Clear parity status registers
 *     STACK_MODE       Stack Mode to TOQ
 *     IPMC_IND_MODE    IPMC IND mode to TOQ
 *     DRACO_1_5_MIRRORING_MODE_EN Draco 1.5 mirroring mode enable to TOQ
 *     DEQ_ECC_REPAIR_EN DEQ ECC repair enable
 *
 ******************************************************************************/
#define BCM56800_A0_MISCCONFIGr 0x0cd80000

#define BCM56800_A0_MISCCONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MISCCONFIG.
 *
 */
typedef union BCM56800_A0_MISCCONFIGr_s {
	uint32_t v[1];
	uint32_t miscconfig[1];
	uint32_t _miscconfig;
} BCM56800_A0_MISCCONFIGr_t;

#define BCM56800_A0_MISCCONFIGr_CLR(r) (r).miscconfig[0] = 0
#define BCM56800_A0_MISCCONFIGr_SET(r,d) (r).miscconfig[0] = d
#define BCM56800_A0_MISCCONFIGr_GET(r) (r).miscconfig[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MISCCONFIGr_METERING_CLK_ENf_GET(r) (((r).miscconfig[0]) & 0x1)
#define BCM56800_A0_MISCCONFIGr_METERING_CLK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MISCCONFIGr_SLAM_MEMf_GET(r) ((((r).miscconfig[0]) >> 1) & 0x1)
#define BCM56800_A0_MISCCONFIGr_SLAM_MEMf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MISCCONFIGr_PARITY_CHK_ENf_GET(r) ((((r).miscconfig[0]) >> 2) & 0x1)
#define BCM56800_A0_MISCCONFIGr_PARITY_CHK_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MISCCONFIGr_PARITY_GEN_ENf_GET(r) ((((r).miscconfig[0]) >> 3) & 0x1)
#define BCM56800_A0_MISCCONFIGr_PARITY_GEN_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MISCCONFIGr_PARITY_STAT_CLEARf_GET(r) ((((r).miscconfig[0]) >> 4) & 0x1)
#define BCM56800_A0_MISCCONFIGr_PARITY_STAT_CLEARf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MISCCONFIGr_STACK_MODEf_GET(r) ((((r).miscconfig[0]) >> 5) & 0x3)
#define BCM56800_A0_MISCCONFIGr_STACK_MODEf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM56800_A0_MISCCONFIGr_IPMC_IND_MODEf_GET(r) ((((r).miscconfig[0]) >> 7) & 0x1)
#define BCM56800_A0_MISCCONFIGr_IPMC_IND_MODEf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_GET(r) ((((r).miscconfig[0]) >> 8) & 0x1)
#define BCM56800_A0_MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_MISCCONFIGr_DEQ_ECC_REPAIR_ENf_GET(r) ((((r).miscconfig[0]) >> 9) & 0x1)
#define BCM56800_A0_MISCCONFIGr_DEQ_ECC_REPAIR_ENf_SET(r,f) (r).miscconfig[0]=(((r).miscconfig[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access MISCCONFIG.
 *
 */
#define BCM56800_A0_READ_MISCCONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MISCCONFIGr,(r._miscconfig))
#define BCM56800_A0_WRITE_MISCCONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MISCCONFIGr,&(r._miscconfig))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MISCCONFIGr BCM56800_A0_MISCCONFIGr
#define MISCCONFIGr_SIZE BCM56800_A0_MISCCONFIGr_SIZE
typedef BCM56800_A0_MISCCONFIGr_t MISCCONFIGr_t;
#define MISCCONFIGr_CLR BCM56800_A0_MISCCONFIGr_CLR
#define MISCCONFIGr_SET BCM56800_A0_MISCCONFIGr_SET
#define MISCCONFIGr_GET BCM56800_A0_MISCCONFIGr_GET
#define MISCCONFIGr_METERING_CLK_ENf_GET BCM56800_A0_MISCCONFIGr_METERING_CLK_ENf_GET
#define MISCCONFIGr_METERING_CLK_ENf_SET BCM56800_A0_MISCCONFIGr_METERING_CLK_ENf_SET
#define MISCCONFIGr_SLAM_MEMf_GET BCM56800_A0_MISCCONFIGr_SLAM_MEMf_GET
#define MISCCONFIGr_SLAM_MEMf_SET BCM56800_A0_MISCCONFIGr_SLAM_MEMf_SET
#define MISCCONFIGr_PARITY_CHK_ENf_GET BCM56800_A0_MISCCONFIGr_PARITY_CHK_ENf_GET
#define MISCCONFIGr_PARITY_CHK_ENf_SET BCM56800_A0_MISCCONFIGr_PARITY_CHK_ENf_SET
#define MISCCONFIGr_PARITY_GEN_ENf_GET BCM56800_A0_MISCCONFIGr_PARITY_GEN_ENf_GET
#define MISCCONFIGr_PARITY_GEN_ENf_SET BCM56800_A0_MISCCONFIGr_PARITY_GEN_ENf_SET
#define MISCCONFIGr_PARITY_STAT_CLEARf_GET BCM56800_A0_MISCCONFIGr_PARITY_STAT_CLEARf_GET
#define MISCCONFIGr_PARITY_STAT_CLEARf_SET BCM56800_A0_MISCCONFIGr_PARITY_STAT_CLEARf_SET
#define MISCCONFIGr_STACK_MODEf_GET BCM56800_A0_MISCCONFIGr_STACK_MODEf_GET
#define MISCCONFIGr_STACK_MODEf_SET BCM56800_A0_MISCCONFIGr_STACK_MODEf_SET
#define MISCCONFIGr_IPMC_IND_MODEf_GET BCM56800_A0_MISCCONFIGr_IPMC_IND_MODEf_GET
#define MISCCONFIGr_IPMC_IND_MODEf_SET BCM56800_A0_MISCCONFIGr_IPMC_IND_MODEf_SET
#define MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_GET BCM56800_A0_MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_GET
#define MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_SET BCM56800_A0_MISCCONFIGr_DRACO_1_5_MIRRORING_MODE_ENf_SET
#define MISCCONFIGr_DEQ_ECC_REPAIR_ENf_GET BCM56800_A0_MISCCONFIGr_DEQ_ECC_REPAIR_ENf_GET
#define MISCCONFIGr_DEQ_ECC_REPAIR_ENf_SET BCM56800_A0_MISCCONFIGr_DEQ_ECC_REPAIR_ENf_SET
#define READ_MISCCONFIGr BCM56800_A0_READ_MISCCONFIGr
#define WRITE_MISCCONFIGr BCM56800_A0_WRITE_MISCCONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MISCCONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_AGING_CTR
 * BLOCKS:   MMU
 * DESC:     Aging Counter RAM
 * SIZE:     25
 * FIELDS:
 *     AGING_CTR        AGING_CTR
 *     PARITY           Parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_AGING_CTRm 0x0dd84000

#define BCM56800_A0_MMU_AGING_CTRm_MIN 0
#define BCM56800_A0_MMU_AGING_CTRm_MAX 1535
#define BCM56800_A0_MMU_AGING_CTRm_CMAX(u) 1535
#define BCM56800_A0_MMU_AGING_CTRm_SIZE 4

/*
 * This structure should be used to declare and program MMU_AGING_CTR.
 *
 */
typedef union BCM56800_A0_MMU_AGING_CTRm_s {
	uint32_t v[1];
	uint32_t mmu_aging_ctr[1];
	uint32_t _mmu_aging_ctr;
} BCM56800_A0_MMU_AGING_CTRm_t;

#define BCM56800_A0_MMU_AGING_CTRm_CLR(r) (r).mmu_aging_ctr[0] = 0
#define BCM56800_A0_MMU_AGING_CTRm_SET(r,d) (r).mmu_aging_ctr[0] = d
#define BCM56800_A0_MMU_AGING_CTRm_GET(r) (r).mmu_aging_ctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_AGING_CTRm_AGING_CTRf_GET(r) (((r).mmu_aging_ctr[0]) & 0xffffff)
#define BCM56800_A0_MMU_AGING_CTRm_AGING_CTRf_SET(r,f) (r).mmu_aging_ctr[0]=(((r).mmu_aging_ctr[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM56800_A0_MMU_AGING_CTRm_PARITYf_GET(r) ((((r).mmu_aging_ctr[0]) >> 24) & 0x1)
#define BCM56800_A0_MMU_AGING_CTRm_PARITYf_SET(r,f) (r).mmu_aging_ctr[0]=(((r).mmu_aging_ctr[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access MMU_AGING_CTR.
 *
 */
#define BCM56800_A0_READ_MMU_AGING_CTRm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_AGING_CTRm,i,(m._mmu_aging_ctr),1)
#define BCM56800_A0_WRITE_MMU_AGING_CTRm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_AGING_CTRm,i,&(m._mmu_aging_ctr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_AGING_CTRm BCM56800_A0_MMU_AGING_CTRm
#define MMU_AGING_CTRm_MIN BCM56800_A0_MMU_AGING_CTRm_MIN
#define MMU_AGING_CTRm_MAX BCM56800_A0_MMU_AGING_CTRm_MAX
#define MMU_AGING_CTRm_CMAX(u) BCM56800_A0_MMU_AGING_CTRm_CMAX(u)
#define MMU_AGING_CTRm_SIZE BCM56800_A0_MMU_AGING_CTRm_SIZE
typedef BCM56800_A0_MMU_AGING_CTRm_t MMU_AGING_CTRm_t;
#define MMU_AGING_CTRm_CLR BCM56800_A0_MMU_AGING_CTRm_CLR
#define MMU_AGING_CTRm_SET BCM56800_A0_MMU_AGING_CTRm_SET
#define MMU_AGING_CTRm_GET BCM56800_A0_MMU_AGING_CTRm_GET
#define MMU_AGING_CTRm_AGING_CTRf_GET BCM56800_A0_MMU_AGING_CTRm_AGING_CTRf_GET
#define MMU_AGING_CTRm_AGING_CTRf_SET BCM56800_A0_MMU_AGING_CTRm_AGING_CTRf_SET
#define MMU_AGING_CTRm_PARITYf_GET BCM56800_A0_MMU_AGING_CTRm_PARITYf_GET
#define MMU_AGING_CTRm_PARITYf_SET BCM56800_A0_MMU_AGING_CTRm_PARITYf_SET
#define READ_MMU_AGING_CTRm BCM56800_A0_READ_MMU_AGING_CTRm
#define WRITE_MMU_AGING_CTRm BCM56800_A0_WRITE_MMU_AGING_CTRm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_AGING_CTRm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_AGING_EXP
 * BLOCKS:   MMU
 * DESC:     Aging Expiration Status RAM
 * SIZE:     9
 * FIELDS:
 *     AGING_EXP        AGING_EXP
 *     PARITY           Parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_AGING_EXPm 0x0dd88000

#define BCM56800_A0_MMU_AGING_EXPm_MIN 0
#define BCM56800_A0_MMU_AGING_EXPm_MAX 1535
#define BCM56800_A0_MMU_AGING_EXPm_CMAX(u) 1535
#define BCM56800_A0_MMU_AGING_EXPm_SIZE 2

/*
 * This structure should be used to declare and program MMU_AGING_EXP.
 *
 */
typedef union BCM56800_A0_MMU_AGING_EXPm_s {
	uint32_t v[1];
	uint32_t mmu_aging_exp[1];
	uint32_t _mmu_aging_exp;
} BCM56800_A0_MMU_AGING_EXPm_t;

#define BCM56800_A0_MMU_AGING_EXPm_CLR(r) (r).mmu_aging_exp[0] = 0
#define BCM56800_A0_MMU_AGING_EXPm_SET(r,d) (r).mmu_aging_exp[0] = d
#define BCM56800_A0_MMU_AGING_EXPm_GET(r) (r).mmu_aging_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_AGING_EXPm_AGING_EXPf_GET(r) (((r).mmu_aging_exp[0]) & 0xff)
#define BCM56800_A0_MMU_AGING_EXPm_AGING_EXPf_SET(r,f) (r).mmu_aging_exp[0]=(((r).mmu_aging_exp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_MMU_AGING_EXPm_PARITYf_GET(r) ((((r).mmu_aging_exp[0]) >> 8) & 0x1)
#define BCM56800_A0_MMU_AGING_EXPm_PARITYf_SET(r,f) (r).mmu_aging_exp[0]=(((r).mmu_aging_exp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))

/*
 * These macros can be used to access MMU_AGING_EXP.
 *
 */
#define BCM56800_A0_READ_MMU_AGING_EXPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_AGING_EXPm,i,(m._mmu_aging_exp),1)
#define BCM56800_A0_WRITE_MMU_AGING_EXPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_AGING_EXPm,i,&(m._mmu_aging_exp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_AGING_EXPm BCM56800_A0_MMU_AGING_EXPm
#define MMU_AGING_EXPm_MIN BCM56800_A0_MMU_AGING_EXPm_MIN
#define MMU_AGING_EXPm_MAX BCM56800_A0_MMU_AGING_EXPm_MAX
#define MMU_AGING_EXPm_CMAX(u) BCM56800_A0_MMU_AGING_EXPm_CMAX(u)
#define MMU_AGING_EXPm_SIZE BCM56800_A0_MMU_AGING_EXPm_SIZE
typedef BCM56800_A0_MMU_AGING_EXPm_t MMU_AGING_EXPm_t;
#define MMU_AGING_EXPm_CLR BCM56800_A0_MMU_AGING_EXPm_CLR
#define MMU_AGING_EXPm_SET BCM56800_A0_MMU_AGING_EXPm_SET
#define MMU_AGING_EXPm_GET BCM56800_A0_MMU_AGING_EXPm_GET
#define MMU_AGING_EXPm_AGING_EXPf_GET BCM56800_A0_MMU_AGING_EXPm_AGING_EXPf_GET
#define MMU_AGING_EXPm_AGING_EXPf_SET BCM56800_A0_MMU_AGING_EXPm_AGING_EXPf_SET
#define MMU_AGING_EXPm_PARITYf_GET BCM56800_A0_MMU_AGING_EXPm_PARITYf_GET
#define MMU_AGING_EXPm_PARITYf_SET BCM56800_A0_MMU_AGING_EXPm_PARITYf_SET
#define READ_MMU_AGING_EXPm BCM56800_A0_READ_MMU_AGING_EXPm
#define WRITE_MMU_AGING_EXPm BCM56800_A0_WRITE_MMU_AGING_EXPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_AGING_EXPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPCellHeader
 * BLOCKS:   MMU
 * DESC:     CBP Header RAM
 * SIZE:     16
 * FIELDS:
 *     CELL_LENGTH      Last Cell Length is valid when END_CELL is 1
 *     PURGE_CELL       cell is purged
 *     END_CELL         End cell flag of a packet
 *     SHARED_CELL      Shared cell
 *     ECC              ECC
 *     PARITY           Parity bit
 *     DATA             data for which ecc is computed
 *     ECCP             Cell header Parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPCELLHEADERm 0x10d78000

#define BCM56800_A0_MMU_CBPCELLHEADERm_MIN 0
#define BCM56800_A0_MMU_CBPCELLHEADERm_MAX 12287
#define BCM56800_A0_MMU_CBPCELLHEADERm_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPCELLHEADERm_SIZE 2

/*
 * This structure should be used to declare and program MMU_CBPCellHeader.
 *
 */
typedef union BCM56800_A0_MMU_CBPCELLHEADERm_s {
	uint32_t v[1];
	uint32_t mmu_cbpcellheader[1];
	uint32_t _mmu_cbpcellheader;
} BCM56800_A0_MMU_CBPCELLHEADERm_t;

#define BCM56800_A0_MMU_CBPCELLHEADERm_CLR(r) (r).mmu_cbpcellheader[0] = 0
#define BCM56800_A0_MMU_CBPCELLHEADERm_SET(r,d) (r).mmu_cbpcellheader[0] = d
#define BCM56800_A0_MMU_CBPCELLHEADERm_GET(r) (r).mmu_cbpcellheader[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_GET(r) (((r).mmu_cbpcellheader[0]) & 0xff)
#define BCM56800_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 8) & 0x1)
#define BCM56800_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_MMU_CBPCELLHEADERm_END_CELLf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 9) & 0x1)
#define BCM56800_A0_MMU_CBPCELLHEADERm_END_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_MMU_CBPCELLHEADERm_SHARED_CELLf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 10) & 0x1)
#define BCM56800_A0_MMU_CBPCELLHEADERm_SHARED_CELLf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_MMU_CBPCELLHEADERm_ECCf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 11) & 0xf)
#define BCM56800_A0_MMU_CBPCELLHEADERm_ECCf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM56800_A0_MMU_CBPCELLHEADERm_PARITYf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 15) & 0x1)
#define BCM56800_A0_MMU_CBPCELLHEADERm_PARITYf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MMU_CBPCELLHEADERm_DATAf_GET(r) (((r).mmu_cbpcellheader[0]) & 0x7ff)
#define BCM56800_A0_MMU_CBPCELLHEADERm_DATAf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56800_A0_MMU_CBPCELLHEADERm_ECCPf_GET(r) ((((r).mmu_cbpcellheader[0]) >> 11) & 0x1f)
#define BCM56800_A0_MMU_CBPCELLHEADERm_ECCPf_SET(r,f) (r).mmu_cbpcellheader[0]=(((r).mmu_cbpcellheader[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access MMU_CBPCellHeader.
 *
 */
#define BCM56800_A0_READ_MMU_CBPCELLHEADERm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPCELLHEADERm,i,(m._mmu_cbpcellheader),1)
#define BCM56800_A0_WRITE_MMU_CBPCELLHEADERm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPCELLHEADERm,i,&(m._mmu_cbpcellheader),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPCELLHEADERm BCM56800_A0_MMU_CBPCELLHEADERm
#define MMU_CBPCELLHEADERm_MIN BCM56800_A0_MMU_CBPCELLHEADERm_MIN
#define MMU_CBPCELLHEADERm_MAX BCM56800_A0_MMU_CBPCELLHEADERm_MAX
#define MMU_CBPCELLHEADERm_CMAX(u) BCM56800_A0_MMU_CBPCELLHEADERm_CMAX(u)
#define MMU_CBPCELLHEADERm_SIZE BCM56800_A0_MMU_CBPCELLHEADERm_SIZE
typedef BCM56800_A0_MMU_CBPCELLHEADERm_t MMU_CBPCELLHEADERm_t;
#define MMU_CBPCELLHEADERm_CLR BCM56800_A0_MMU_CBPCELLHEADERm_CLR
#define MMU_CBPCELLHEADERm_SET BCM56800_A0_MMU_CBPCELLHEADERm_SET
#define MMU_CBPCELLHEADERm_GET BCM56800_A0_MMU_CBPCELLHEADERm_GET
#define MMU_CBPCELLHEADERm_CELL_LENGTHf_GET BCM56800_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_GET
#define MMU_CBPCELLHEADERm_CELL_LENGTHf_SET BCM56800_A0_MMU_CBPCELLHEADERm_CELL_LENGTHf_SET
#define MMU_CBPCELLHEADERm_PURGE_CELLf_GET BCM56800_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_GET
#define MMU_CBPCELLHEADERm_PURGE_CELLf_SET BCM56800_A0_MMU_CBPCELLHEADERm_PURGE_CELLf_SET
#define MMU_CBPCELLHEADERm_END_CELLf_GET BCM56800_A0_MMU_CBPCELLHEADERm_END_CELLf_GET
#define MMU_CBPCELLHEADERm_END_CELLf_SET BCM56800_A0_MMU_CBPCELLHEADERm_END_CELLf_SET
#define MMU_CBPCELLHEADERm_SHARED_CELLf_GET BCM56800_A0_MMU_CBPCELLHEADERm_SHARED_CELLf_GET
#define MMU_CBPCELLHEADERm_SHARED_CELLf_SET BCM56800_A0_MMU_CBPCELLHEADERm_SHARED_CELLf_SET
#define MMU_CBPCELLHEADERm_ECCf_GET BCM56800_A0_MMU_CBPCELLHEADERm_ECCf_GET
#define MMU_CBPCELLHEADERm_ECCf_SET BCM56800_A0_MMU_CBPCELLHEADERm_ECCf_SET
#define MMU_CBPCELLHEADERm_PARITYf_GET BCM56800_A0_MMU_CBPCELLHEADERm_PARITYf_GET
#define MMU_CBPCELLHEADERm_PARITYf_SET BCM56800_A0_MMU_CBPCELLHEADERm_PARITYf_SET
#define MMU_CBPCELLHEADERm_DATAf_GET BCM56800_A0_MMU_CBPCELLHEADERm_DATAf_GET
#define MMU_CBPCELLHEADERm_DATAf_SET BCM56800_A0_MMU_CBPCELLHEADERm_DATAf_SET
#define MMU_CBPCELLHEADERm_ECCPf_GET BCM56800_A0_MMU_CBPCELLHEADERm_ECCPf_GET
#define MMU_CBPCELLHEADERm_ECCPf_SET BCM56800_A0_MMU_CBPCELLHEADERm_ECCPf_SET
#define READ_MMU_CBPCELLHEADERm BCM56800_A0_READ_MMU_CBPCELLHEADERm
#define WRITE_MMU_CBPCELLHEADERm BCM56800_A0_WRITE_MMU_CBPCELLHEADERm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPCELLHEADERm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData0
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 0
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [63:0]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA0m 0x0fd00000

#define BCM56800_A0_MMU_CBPDATA0m_MIN 0
#define BCM56800_A0_MMU_CBPDATA0m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA0m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA0m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData0.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA0m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata0[2];
	uint32_t _mmu_cbpdata0;
} BCM56800_A0_MMU_CBPDATA0m_t;

#define BCM56800_A0_MMU_CBPDATA0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata0), 0, sizeof(BCM56800_A0_MMU_CBPDATA0m_t))
#define BCM56800_A0_MMU_CBPDATA0m_SET(r,i,d) (r).mmu_cbpdata0[i] = d
#define BCM56800_A0_MMU_CBPDATA0m_GET(r,i) (r).mmu_cbpdata0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA0m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata0,0,63,a)
#define BCM56800_A0_MMU_CBPDATA0m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata0,0,63,a)

/*
 * These macros can be used to access MMU_CBPData0.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA0m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA0m,i,(m._mmu_cbpdata0),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA0m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA0m,i,&(m._mmu_cbpdata0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA0m BCM56800_A0_MMU_CBPDATA0m
#define MMU_CBPDATA0m_MIN BCM56800_A0_MMU_CBPDATA0m_MIN
#define MMU_CBPDATA0m_MAX BCM56800_A0_MMU_CBPDATA0m_MAX
#define MMU_CBPDATA0m_CMAX(u) BCM56800_A0_MMU_CBPDATA0m_CMAX(u)
#define MMU_CBPDATA0m_SIZE BCM56800_A0_MMU_CBPDATA0m_SIZE
typedef BCM56800_A0_MMU_CBPDATA0m_t MMU_CBPDATA0m_t;
#define MMU_CBPDATA0m_CLR BCM56800_A0_MMU_CBPDATA0m_CLR
#define MMU_CBPDATA0m_SET BCM56800_A0_MMU_CBPDATA0m_SET
#define MMU_CBPDATA0m_GET BCM56800_A0_MMU_CBPDATA0m_GET
#define MMU_CBPDATA0m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA0m_CBPDATAf_GET
#define MMU_CBPDATA0m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA0m_CBPDATAf_SET
#define READ_MMU_CBPDATA0m BCM56800_A0_READ_MMU_CBPDATA0m
#define WRITE_MMU_CBPDATA0m BCM56800_A0_WRITE_MMU_CBPDATA0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData1
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 1
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [127:64]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA1m 0x0fd04000

#define BCM56800_A0_MMU_CBPDATA1m_MIN 0
#define BCM56800_A0_MMU_CBPDATA1m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA1m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA1m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData1.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA1m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata1[2];
	uint32_t _mmu_cbpdata1;
} BCM56800_A0_MMU_CBPDATA1m_t;

#define BCM56800_A0_MMU_CBPDATA1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata1), 0, sizeof(BCM56800_A0_MMU_CBPDATA1m_t))
#define BCM56800_A0_MMU_CBPDATA1m_SET(r,i,d) (r).mmu_cbpdata1[i] = d
#define BCM56800_A0_MMU_CBPDATA1m_GET(r,i) (r).mmu_cbpdata1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA1m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata1,0,63,a)
#define BCM56800_A0_MMU_CBPDATA1m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata1,0,63,a)

/*
 * These macros can be used to access MMU_CBPData1.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA1m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA1m,i,(m._mmu_cbpdata1),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA1m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA1m,i,&(m._mmu_cbpdata1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA1m BCM56800_A0_MMU_CBPDATA1m
#define MMU_CBPDATA1m_MIN BCM56800_A0_MMU_CBPDATA1m_MIN
#define MMU_CBPDATA1m_MAX BCM56800_A0_MMU_CBPDATA1m_MAX
#define MMU_CBPDATA1m_CMAX(u) BCM56800_A0_MMU_CBPDATA1m_CMAX(u)
#define MMU_CBPDATA1m_SIZE BCM56800_A0_MMU_CBPDATA1m_SIZE
typedef BCM56800_A0_MMU_CBPDATA1m_t MMU_CBPDATA1m_t;
#define MMU_CBPDATA1m_CLR BCM56800_A0_MMU_CBPDATA1m_CLR
#define MMU_CBPDATA1m_SET BCM56800_A0_MMU_CBPDATA1m_SET
#define MMU_CBPDATA1m_GET BCM56800_A0_MMU_CBPDATA1m_GET
#define MMU_CBPDATA1m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA1m_CBPDATAf_GET
#define MMU_CBPDATA1m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA1m_CBPDATAf_SET
#define READ_MMU_CBPDATA1m BCM56800_A0_READ_MMU_CBPDATA1m
#define WRITE_MMU_CBPDATA1m BCM56800_A0_WRITE_MMU_CBPDATA1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData10
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 10
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [703:640]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA10m 0x0fd28000

#define BCM56800_A0_MMU_CBPDATA10m_MIN 0
#define BCM56800_A0_MMU_CBPDATA10m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA10m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA10m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData10.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA10m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata10[2];
	uint32_t _mmu_cbpdata10;
} BCM56800_A0_MMU_CBPDATA10m_t;

#define BCM56800_A0_MMU_CBPDATA10m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata10), 0, sizeof(BCM56800_A0_MMU_CBPDATA10m_t))
#define BCM56800_A0_MMU_CBPDATA10m_SET(r,i,d) (r).mmu_cbpdata10[i] = d
#define BCM56800_A0_MMU_CBPDATA10m_GET(r,i) (r).mmu_cbpdata10[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA10m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata10,0,63,a)
#define BCM56800_A0_MMU_CBPDATA10m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata10,0,63,a)

/*
 * These macros can be used to access MMU_CBPData10.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA10m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA10m,i,(m._mmu_cbpdata10),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA10m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA10m,i,&(m._mmu_cbpdata10),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA10m BCM56800_A0_MMU_CBPDATA10m
#define MMU_CBPDATA10m_MIN BCM56800_A0_MMU_CBPDATA10m_MIN
#define MMU_CBPDATA10m_MAX BCM56800_A0_MMU_CBPDATA10m_MAX
#define MMU_CBPDATA10m_CMAX(u) BCM56800_A0_MMU_CBPDATA10m_CMAX(u)
#define MMU_CBPDATA10m_SIZE BCM56800_A0_MMU_CBPDATA10m_SIZE
typedef BCM56800_A0_MMU_CBPDATA10m_t MMU_CBPDATA10m_t;
#define MMU_CBPDATA10m_CLR BCM56800_A0_MMU_CBPDATA10m_CLR
#define MMU_CBPDATA10m_SET BCM56800_A0_MMU_CBPDATA10m_SET
#define MMU_CBPDATA10m_GET BCM56800_A0_MMU_CBPDATA10m_GET
#define MMU_CBPDATA10m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA10m_CBPDATAf_GET
#define MMU_CBPDATA10m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA10m_CBPDATAf_SET
#define READ_MMU_CBPDATA10m BCM56800_A0_READ_MMU_CBPDATA10m
#define WRITE_MMU_CBPDATA10m BCM56800_A0_WRITE_MMU_CBPDATA10m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA10m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData11
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 11
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [767:704]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA11m 0x0fd2c000

#define BCM56800_A0_MMU_CBPDATA11m_MIN 0
#define BCM56800_A0_MMU_CBPDATA11m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA11m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA11m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData11.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA11m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata11[2];
	uint32_t _mmu_cbpdata11;
} BCM56800_A0_MMU_CBPDATA11m_t;

#define BCM56800_A0_MMU_CBPDATA11m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata11), 0, sizeof(BCM56800_A0_MMU_CBPDATA11m_t))
#define BCM56800_A0_MMU_CBPDATA11m_SET(r,i,d) (r).mmu_cbpdata11[i] = d
#define BCM56800_A0_MMU_CBPDATA11m_GET(r,i) (r).mmu_cbpdata11[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA11m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata11,0,63,a)
#define BCM56800_A0_MMU_CBPDATA11m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata11,0,63,a)

/*
 * These macros can be used to access MMU_CBPData11.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA11m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA11m,i,(m._mmu_cbpdata11),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA11m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA11m,i,&(m._mmu_cbpdata11),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA11m BCM56800_A0_MMU_CBPDATA11m
#define MMU_CBPDATA11m_MIN BCM56800_A0_MMU_CBPDATA11m_MIN
#define MMU_CBPDATA11m_MAX BCM56800_A0_MMU_CBPDATA11m_MAX
#define MMU_CBPDATA11m_CMAX(u) BCM56800_A0_MMU_CBPDATA11m_CMAX(u)
#define MMU_CBPDATA11m_SIZE BCM56800_A0_MMU_CBPDATA11m_SIZE
typedef BCM56800_A0_MMU_CBPDATA11m_t MMU_CBPDATA11m_t;
#define MMU_CBPDATA11m_CLR BCM56800_A0_MMU_CBPDATA11m_CLR
#define MMU_CBPDATA11m_SET BCM56800_A0_MMU_CBPDATA11m_SET
#define MMU_CBPDATA11m_GET BCM56800_A0_MMU_CBPDATA11m_GET
#define MMU_CBPDATA11m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA11m_CBPDATAf_GET
#define MMU_CBPDATA11m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA11m_CBPDATAf_SET
#define READ_MMU_CBPDATA11m BCM56800_A0_READ_MMU_CBPDATA11m
#define WRITE_MMU_CBPDATA11m BCM56800_A0_WRITE_MMU_CBPDATA11m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA11m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData12
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 12
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [831:768]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA12m 0x0fd30000

#define BCM56800_A0_MMU_CBPDATA12m_MIN 0
#define BCM56800_A0_MMU_CBPDATA12m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA12m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA12m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData12.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA12m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata12[2];
	uint32_t _mmu_cbpdata12;
} BCM56800_A0_MMU_CBPDATA12m_t;

#define BCM56800_A0_MMU_CBPDATA12m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata12), 0, sizeof(BCM56800_A0_MMU_CBPDATA12m_t))
#define BCM56800_A0_MMU_CBPDATA12m_SET(r,i,d) (r).mmu_cbpdata12[i] = d
#define BCM56800_A0_MMU_CBPDATA12m_GET(r,i) (r).mmu_cbpdata12[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA12m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata12,0,63,a)
#define BCM56800_A0_MMU_CBPDATA12m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata12,0,63,a)

/*
 * These macros can be used to access MMU_CBPData12.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA12m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA12m,i,(m._mmu_cbpdata12),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA12m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA12m,i,&(m._mmu_cbpdata12),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA12m BCM56800_A0_MMU_CBPDATA12m
#define MMU_CBPDATA12m_MIN BCM56800_A0_MMU_CBPDATA12m_MIN
#define MMU_CBPDATA12m_MAX BCM56800_A0_MMU_CBPDATA12m_MAX
#define MMU_CBPDATA12m_CMAX(u) BCM56800_A0_MMU_CBPDATA12m_CMAX(u)
#define MMU_CBPDATA12m_SIZE BCM56800_A0_MMU_CBPDATA12m_SIZE
typedef BCM56800_A0_MMU_CBPDATA12m_t MMU_CBPDATA12m_t;
#define MMU_CBPDATA12m_CLR BCM56800_A0_MMU_CBPDATA12m_CLR
#define MMU_CBPDATA12m_SET BCM56800_A0_MMU_CBPDATA12m_SET
#define MMU_CBPDATA12m_GET BCM56800_A0_MMU_CBPDATA12m_GET
#define MMU_CBPDATA12m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA12m_CBPDATAf_GET
#define MMU_CBPDATA12m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA12m_CBPDATAf_SET
#define READ_MMU_CBPDATA12m BCM56800_A0_READ_MMU_CBPDATA12m
#define WRITE_MMU_CBPDATA12m BCM56800_A0_WRITE_MMU_CBPDATA12m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA12m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData13
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 13
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [895:832]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA13m 0x0fd34000

#define BCM56800_A0_MMU_CBPDATA13m_MIN 0
#define BCM56800_A0_MMU_CBPDATA13m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA13m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA13m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData13.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA13m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata13[2];
	uint32_t _mmu_cbpdata13;
} BCM56800_A0_MMU_CBPDATA13m_t;

#define BCM56800_A0_MMU_CBPDATA13m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata13), 0, sizeof(BCM56800_A0_MMU_CBPDATA13m_t))
#define BCM56800_A0_MMU_CBPDATA13m_SET(r,i,d) (r).mmu_cbpdata13[i] = d
#define BCM56800_A0_MMU_CBPDATA13m_GET(r,i) (r).mmu_cbpdata13[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA13m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata13,0,63,a)
#define BCM56800_A0_MMU_CBPDATA13m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata13,0,63,a)

/*
 * These macros can be used to access MMU_CBPData13.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA13m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA13m,i,(m._mmu_cbpdata13),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA13m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA13m,i,&(m._mmu_cbpdata13),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA13m BCM56800_A0_MMU_CBPDATA13m
#define MMU_CBPDATA13m_MIN BCM56800_A0_MMU_CBPDATA13m_MIN
#define MMU_CBPDATA13m_MAX BCM56800_A0_MMU_CBPDATA13m_MAX
#define MMU_CBPDATA13m_CMAX(u) BCM56800_A0_MMU_CBPDATA13m_CMAX(u)
#define MMU_CBPDATA13m_SIZE BCM56800_A0_MMU_CBPDATA13m_SIZE
typedef BCM56800_A0_MMU_CBPDATA13m_t MMU_CBPDATA13m_t;
#define MMU_CBPDATA13m_CLR BCM56800_A0_MMU_CBPDATA13m_CLR
#define MMU_CBPDATA13m_SET BCM56800_A0_MMU_CBPDATA13m_SET
#define MMU_CBPDATA13m_GET BCM56800_A0_MMU_CBPDATA13m_GET
#define MMU_CBPDATA13m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA13m_CBPDATAf_GET
#define MMU_CBPDATA13m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA13m_CBPDATAf_SET
#define READ_MMU_CBPDATA13m BCM56800_A0_READ_MMU_CBPDATA13m
#define WRITE_MMU_CBPDATA13m BCM56800_A0_WRITE_MMU_CBPDATA13m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA13m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData14
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 14
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [959:896]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA14m 0x0fd38000

#define BCM56800_A0_MMU_CBPDATA14m_MIN 0
#define BCM56800_A0_MMU_CBPDATA14m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA14m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA14m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData14.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA14m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata14[2];
	uint32_t _mmu_cbpdata14;
} BCM56800_A0_MMU_CBPDATA14m_t;

#define BCM56800_A0_MMU_CBPDATA14m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata14), 0, sizeof(BCM56800_A0_MMU_CBPDATA14m_t))
#define BCM56800_A0_MMU_CBPDATA14m_SET(r,i,d) (r).mmu_cbpdata14[i] = d
#define BCM56800_A0_MMU_CBPDATA14m_GET(r,i) (r).mmu_cbpdata14[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA14m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata14,0,63,a)
#define BCM56800_A0_MMU_CBPDATA14m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata14,0,63,a)

/*
 * These macros can be used to access MMU_CBPData14.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA14m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA14m,i,(m._mmu_cbpdata14),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA14m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA14m,i,&(m._mmu_cbpdata14),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA14m BCM56800_A0_MMU_CBPDATA14m
#define MMU_CBPDATA14m_MIN BCM56800_A0_MMU_CBPDATA14m_MIN
#define MMU_CBPDATA14m_MAX BCM56800_A0_MMU_CBPDATA14m_MAX
#define MMU_CBPDATA14m_CMAX(u) BCM56800_A0_MMU_CBPDATA14m_CMAX(u)
#define MMU_CBPDATA14m_SIZE BCM56800_A0_MMU_CBPDATA14m_SIZE
typedef BCM56800_A0_MMU_CBPDATA14m_t MMU_CBPDATA14m_t;
#define MMU_CBPDATA14m_CLR BCM56800_A0_MMU_CBPDATA14m_CLR
#define MMU_CBPDATA14m_SET BCM56800_A0_MMU_CBPDATA14m_SET
#define MMU_CBPDATA14m_GET BCM56800_A0_MMU_CBPDATA14m_GET
#define MMU_CBPDATA14m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA14m_CBPDATAf_GET
#define MMU_CBPDATA14m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA14m_CBPDATAf_SET
#define READ_MMU_CBPDATA14m BCM56800_A0_READ_MMU_CBPDATA14m
#define WRITE_MMU_CBPDATA14m BCM56800_A0_WRITE_MMU_CBPDATA14m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA14m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData15
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 15
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [1023:960]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA15m 0x0fd3c000

#define BCM56800_A0_MMU_CBPDATA15m_MIN 0
#define BCM56800_A0_MMU_CBPDATA15m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA15m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA15m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData15.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA15m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata15[2];
	uint32_t _mmu_cbpdata15;
} BCM56800_A0_MMU_CBPDATA15m_t;

#define BCM56800_A0_MMU_CBPDATA15m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata15), 0, sizeof(BCM56800_A0_MMU_CBPDATA15m_t))
#define BCM56800_A0_MMU_CBPDATA15m_SET(r,i,d) (r).mmu_cbpdata15[i] = d
#define BCM56800_A0_MMU_CBPDATA15m_GET(r,i) (r).mmu_cbpdata15[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA15m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata15,0,63,a)
#define BCM56800_A0_MMU_CBPDATA15m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata15,0,63,a)

/*
 * These macros can be used to access MMU_CBPData15.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA15m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA15m,i,(m._mmu_cbpdata15),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA15m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA15m,i,&(m._mmu_cbpdata15),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA15m BCM56800_A0_MMU_CBPDATA15m
#define MMU_CBPDATA15m_MIN BCM56800_A0_MMU_CBPDATA15m_MIN
#define MMU_CBPDATA15m_MAX BCM56800_A0_MMU_CBPDATA15m_MAX
#define MMU_CBPDATA15m_CMAX(u) BCM56800_A0_MMU_CBPDATA15m_CMAX(u)
#define MMU_CBPDATA15m_SIZE BCM56800_A0_MMU_CBPDATA15m_SIZE
typedef BCM56800_A0_MMU_CBPDATA15m_t MMU_CBPDATA15m_t;
#define MMU_CBPDATA15m_CLR BCM56800_A0_MMU_CBPDATA15m_CLR
#define MMU_CBPDATA15m_SET BCM56800_A0_MMU_CBPDATA15m_SET
#define MMU_CBPDATA15m_GET BCM56800_A0_MMU_CBPDATA15m_GET
#define MMU_CBPDATA15m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA15m_CBPDATAf_GET
#define MMU_CBPDATA15m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA15m_CBPDATAf_SET
#define READ_MMU_CBPDATA15m BCM56800_A0_READ_MMU_CBPDATA15m
#define WRITE_MMU_CBPDATA15m BCM56800_A0_WRITE_MMU_CBPDATA15m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA15m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData2
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 2
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [191:128]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA2m 0x0fd08000

#define BCM56800_A0_MMU_CBPDATA2m_MIN 0
#define BCM56800_A0_MMU_CBPDATA2m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA2m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA2m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData2.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA2m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata2[2];
	uint32_t _mmu_cbpdata2;
} BCM56800_A0_MMU_CBPDATA2m_t;

#define BCM56800_A0_MMU_CBPDATA2m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata2), 0, sizeof(BCM56800_A0_MMU_CBPDATA2m_t))
#define BCM56800_A0_MMU_CBPDATA2m_SET(r,i,d) (r).mmu_cbpdata2[i] = d
#define BCM56800_A0_MMU_CBPDATA2m_GET(r,i) (r).mmu_cbpdata2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA2m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata2,0,63,a)
#define BCM56800_A0_MMU_CBPDATA2m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata2,0,63,a)

/*
 * These macros can be used to access MMU_CBPData2.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA2m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA2m,i,(m._mmu_cbpdata2),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA2m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA2m,i,&(m._mmu_cbpdata2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA2m BCM56800_A0_MMU_CBPDATA2m
#define MMU_CBPDATA2m_MIN BCM56800_A0_MMU_CBPDATA2m_MIN
#define MMU_CBPDATA2m_MAX BCM56800_A0_MMU_CBPDATA2m_MAX
#define MMU_CBPDATA2m_CMAX(u) BCM56800_A0_MMU_CBPDATA2m_CMAX(u)
#define MMU_CBPDATA2m_SIZE BCM56800_A0_MMU_CBPDATA2m_SIZE
typedef BCM56800_A0_MMU_CBPDATA2m_t MMU_CBPDATA2m_t;
#define MMU_CBPDATA2m_CLR BCM56800_A0_MMU_CBPDATA2m_CLR
#define MMU_CBPDATA2m_SET BCM56800_A0_MMU_CBPDATA2m_SET
#define MMU_CBPDATA2m_GET BCM56800_A0_MMU_CBPDATA2m_GET
#define MMU_CBPDATA2m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA2m_CBPDATAf_GET
#define MMU_CBPDATA2m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA2m_CBPDATAf_SET
#define READ_MMU_CBPDATA2m BCM56800_A0_READ_MMU_CBPDATA2m
#define WRITE_MMU_CBPDATA2m BCM56800_A0_WRITE_MMU_CBPDATA2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData3
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 3
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [255:192]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA3m 0x0fd0c000

#define BCM56800_A0_MMU_CBPDATA3m_MIN 0
#define BCM56800_A0_MMU_CBPDATA3m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA3m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA3m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData3.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA3m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata3[2];
	uint32_t _mmu_cbpdata3;
} BCM56800_A0_MMU_CBPDATA3m_t;

#define BCM56800_A0_MMU_CBPDATA3m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata3), 0, sizeof(BCM56800_A0_MMU_CBPDATA3m_t))
#define BCM56800_A0_MMU_CBPDATA3m_SET(r,i,d) (r).mmu_cbpdata3[i] = d
#define BCM56800_A0_MMU_CBPDATA3m_GET(r,i) (r).mmu_cbpdata3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA3m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata3,0,63,a)
#define BCM56800_A0_MMU_CBPDATA3m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata3,0,63,a)

/*
 * These macros can be used to access MMU_CBPData3.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA3m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA3m,i,(m._mmu_cbpdata3),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA3m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA3m,i,&(m._mmu_cbpdata3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA3m BCM56800_A0_MMU_CBPDATA3m
#define MMU_CBPDATA3m_MIN BCM56800_A0_MMU_CBPDATA3m_MIN
#define MMU_CBPDATA3m_MAX BCM56800_A0_MMU_CBPDATA3m_MAX
#define MMU_CBPDATA3m_CMAX(u) BCM56800_A0_MMU_CBPDATA3m_CMAX(u)
#define MMU_CBPDATA3m_SIZE BCM56800_A0_MMU_CBPDATA3m_SIZE
typedef BCM56800_A0_MMU_CBPDATA3m_t MMU_CBPDATA3m_t;
#define MMU_CBPDATA3m_CLR BCM56800_A0_MMU_CBPDATA3m_CLR
#define MMU_CBPDATA3m_SET BCM56800_A0_MMU_CBPDATA3m_SET
#define MMU_CBPDATA3m_GET BCM56800_A0_MMU_CBPDATA3m_GET
#define MMU_CBPDATA3m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA3m_CBPDATAf_GET
#define MMU_CBPDATA3m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA3m_CBPDATAf_SET
#define READ_MMU_CBPDATA3m BCM56800_A0_READ_MMU_CBPDATA3m
#define WRITE_MMU_CBPDATA3m BCM56800_A0_WRITE_MMU_CBPDATA3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData4
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 4
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [319:256]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA4m 0x0fd10000

#define BCM56800_A0_MMU_CBPDATA4m_MIN 0
#define BCM56800_A0_MMU_CBPDATA4m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA4m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA4m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData4.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA4m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata4[2];
	uint32_t _mmu_cbpdata4;
} BCM56800_A0_MMU_CBPDATA4m_t;

#define BCM56800_A0_MMU_CBPDATA4m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata4), 0, sizeof(BCM56800_A0_MMU_CBPDATA4m_t))
#define BCM56800_A0_MMU_CBPDATA4m_SET(r,i,d) (r).mmu_cbpdata4[i] = d
#define BCM56800_A0_MMU_CBPDATA4m_GET(r,i) (r).mmu_cbpdata4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA4m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata4,0,63,a)
#define BCM56800_A0_MMU_CBPDATA4m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata4,0,63,a)

/*
 * These macros can be used to access MMU_CBPData4.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA4m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA4m,i,(m._mmu_cbpdata4),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA4m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA4m,i,&(m._mmu_cbpdata4),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA4m BCM56800_A0_MMU_CBPDATA4m
#define MMU_CBPDATA4m_MIN BCM56800_A0_MMU_CBPDATA4m_MIN
#define MMU_CBPDATA4m_MAX BCM56800_A0_MMU_CBPDATA4m_MAX
#define MMU_CBPDATA4m_CMAX(u) BCM56800_A0_MMU_CBPDATA4m_CMAX(u)
#define MMU_CBPDATA4m_SIZE BCM56800_A0_MMU_CBPDATA4m_SIZE
typedef BCM56800_A0_MMU_CBPDATA4m_t MMU_CBPDATA4m_t;
#define MMU_CBPDATA4m_CLR BCM56800_A0_MMU_CBPDATA4m_CLR
#define MMU_CBPDATA4m_SET BCM56800_A0_MMU_CBPDATA4m_SET
#define MMU_CBPDATA4m_GET BCM56800_A0_MMU_CBPDATA4m_GET
#define MMU_CBPDATA4m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA4m_CBPDATAf_GET
#define MMU_CBPDATA4m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA4m_CBPDATAf_SET
#define READ_MMU_CBPDATA4m BCM56800_A0_READ_MMU_CBPDATA4m
#define WRITE_MMU_CBPDATA4m BCM56800_A0_WRITE_MMU_CBPDATA4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData5
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 5
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [383:320]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA5m 0x0fd14000

#define BCM56800_A0_MMU_CBPDATA5m_MIN 0
#define BCM56800_A0_MMU_CBPDATA5m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA5m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA5m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData5.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA5m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata5[2];
	uint32_t _mmu_cbpdata5;
} BCM56800_A0_MMU_CBPDATA5m_t;

#define BCM56800_A0_MMU_CBPDATA5m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata5), 0, sizeof(BCM56800_A0_MMU_CBPDATA5m_t))
#define BCM56800_A0_MMU_CBPDATA5m_SET(r,i,d) (r).mmu_cbpdata5[i] = d
#define BCM56800_A0_MMU_CBPDATA5m_GET(r,i) (r).mmu_cbpdata5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA5m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata5,0,63,a)
#define BCM56800_A0_MMU_CBPDATA5m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata5,0,63,a)

/*
 * These macros can be used to access MMU_CBPData5.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA5m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA5m,i,(m._mmu_cbpdata5),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA5m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA5m,i,&(m._mmu_cbpdata5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA5m BCM56800_A0_MMU_CBPDATA5m
#define MMU_CBPDATA5m_MIN BCM56800_A0_MMU_CBPDATA5m_MIN
#define MMU_CBPDATA5m_MAX BCM56800_A0_MMU_CBPDATA5m_MAX
#define MMU_CBPDATA5m_CMAX(u) BCM56800_A0_MMU_CBPDATA5m_CMAX(u)
#define MMU_CBPDATA5m_SIZE BCM56800_A0_MMU_CBPDATA5m_SIZE
typedef BCM56800_A0_MMU_CBPDATA5m_t MMU_CBPDATA5m_t;
#define MMU_CBPDATA5m_CLR BCM56800_A0_MMU_CBPDATA5m_CLR
#define MMU_CBPDATA5m_SET BCM56800_A0_MMU_CBPDATA5m_SET
#define MMU_CBPDATA5m_GET BCM56800_A0_MMU_CBPDATA5m_GET
#define MMU_CBPDATA5m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA5m_CBPDATAf_GET
#define MMU_CBPDATA5m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA5m_CBPDATAf_SET
#define READ_MMU_CBPDATA5m BCM56800_A0_READ_MMU_CBPDATA5m
#define WRITE_MMU_CBPDATA5m BCM56800_A0_WRITE_MMU_CBPDATA5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData6
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 6
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [447:384]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA6m 0x0fd18000

#define BCM56800_A0_MMU_CBPDATA6m_MIN 0
#define BCM56800_A0_MMU_CBPDATA6m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA6m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA6m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData6.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA6m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata6[2];
	uint32_t _mmu_cbpdata6;
} BCM56800_A0_MMU_CBPDATA6m_t;

#define BCM56800_A0_MMU_CBPDATA6m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata6), 0, sizeof(BCM56800_A0_MMU_CBPDATA6m_t))
#define BCM56800_A0_MMU_CBPDATA6m_SET(r,i,d) (r).mmu_cbpdata6[i] = d
#define BCM56800_A0_MMU_CBPDATA6m_GET(r,i) (r).mmu_cbpdata6[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA6m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata6,0,63,a)
#define BCM56800_A0_MMU_CBPDATA6m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata6,0,63,a)

/*
 * These macros can be used to access MMU_CBPData6.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA6m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA6m,i,(m._mmu_cbpdata6),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA6m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA6m,i,&(m._mmu_cbpdata6),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA6m BCM56800_A0_MMU_CBPDATA6m
#define MMU_CBPDATA6m_MIN BCM56800_A0_MMU_CBPDATA6m_MIN
#define MMU_CBPDATA6m_MAX BCM56800_A0_MMU_CBPDATA6m_MAX
#define MMU_CBPDATA6m_CMAX(u) BCM56800_A0_MMU_CBPDATA6m_CMAX(u)
#define MMU_CBPDATA6m_SIZE BCM56800_A0_MMU_CBPDATA6m_SIZE
typedef BCM56800_A0_MMU_CBPDATA6m_t MMU_CBPDATA6m_t;
#define MMU_CBPDATA6m_CLR BCM56800_A0_MMU_CBPDATA6m_CLR
#define MMU_CBPDATA6m_SET BCM56800_A0_MMU_CBPDATA6m_SET
#define MMU_CBPDATA6m_GET BCM56800_A0_MMU_CBPDATA6m_GET
#define MMU_CBPDATA6m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA6m_CBPDATAf_GET
#define MMU_CBPDATA6m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA6m_CBPDATAf_SET
#define READ_MMU_CBPDATA6m BCM56800_A0_READ_MMU_CBPDATA6m
#define WRITE_MMU_CBPDATA6m BCM56800_A0_WRITE_MMU_CBPDATA6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData7
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 7
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [511:448]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA7m 0x0fd1c000

#define BCM56800_A0_MMU_CBPDATA7m_MIN 0
#define BCM56800_A0_MMU_CBPDATA7m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA7m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA7m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData7.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA7m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata7[2];
	uint32_t _mmu_cbpdata7;
} BCM56800_A0_MMU_CBPDATA7m_t;

#define BCM56800_A0_MMU_CBPDATA7m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata7), 0, sizeof(BCM56800_A0_MMU_CBPDATA7m_t))
#define BCM56800_A0_MMU_CBPDATA7m_SET(r,i,d) (r).mmu_cbpdata7[i] = d
#define BCM56800_A0_MMU_CBPDATA7m_GET(r,i) (r).mmu_cbpdata7[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA7m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata7,0,63,a)
#define BCM56800_A0_MMU_CBPDATA7m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata7,0,63,a)

/*
 * These macros can be used to access MMU_CBPData7.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA7m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA7m,i,(m._mmu_cbpdata7),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA7m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA7m,i,&(m._mmu_cbpdata7),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA7m BCM56800_A0_MMU_CBPDATA7m
#define MMU_CBPDATA7m_MIN BCM56800_A0_MMU_CBPDATA7m_MIN
#define MMU_CBPDATA7m_MAX BCM56800_A0_MMU_CBPDATA7m_MAX
#define MMU_CBPDATA7m_CMAX(u) BCM56800_A0_MMU_CBPDATA7m_CMAX(u)
#define MMU_CBPDATA7m_SIZE BCM56800_A0_MMU_CBPDATA7m_SIZE
typedef BCM56800_A0_MMU_CBPDATA7m_t MMU_CBPDATA7m_t;
#define MMU_CBPDATA7m_CLR BCM56800_A0_MMU_CBPDATA7m_CLR
#define MMU_CBPDATA7m_SET BCM56800_A0_MMU_CBPDATA7m_SET
#define MMU_CBPDATA7m_GET BCM56800_A0_MMU_CBPDATA7m_GET
#define MMU_CBPDATA7m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA7m_CBPDATAf_GET
#define MMU_CBPDATA7m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA7m_CBPDATAf_SET
#define READ_MMU_CBPDATA7m BCM56800_A0_READ_MMU_CBPDATA7m
#define WRITE_MMU_CBPDATA7m BCM56800_A0_WRITE_MMU_CBPDATA7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData8
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 8
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [575:512]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA8m 0x0fd20000

#define BCM56800_A0_MMU_CBPDATA8m_MIN 0
#define BCM56800_A0_MMU_CBPDATA8m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA8m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA8m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData8.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA8m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata8[2];
	uint32_t _mmu_cbpdata8;
} BCM56800_A0_MMU_CBPDATA8m_t;

#define BCM56800_A0_MMU_CBPDATA8m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata8), 0, sizeof(BCM56800_A0_MMU_CBPDATA8m_t))
#define BCM56800_A0_MMU_CBPDATA8m_SET(r,i,d) (r).mmu_cbpdata8[i] = d
#define BCM56800_A0_MMU_CBPDATA8m_GET(r,i) (r).mmu_cbpdata8[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA8m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata8,0,63,a)
#define BCM56800_A0_MMU_CBPDATA8m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata8,0,63,a)

/*
 * These macros can be used to access MMU_CBPData8.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA8m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA8m,i,(m._mmu_cbpdata8),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA8m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA8m,i,&(m._mmu_cbpdata8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA8m BCM56800_A0_MMU_CBPDATA8m
#define MMU_CBPDATA8m_MIN BCM56800_A0_MMU_CBPDATA8m_MIN
#define MMU_CBPDATA8m_MAX BCM56800_A0_MMU_CBPDATA8m_MAX
#define MMU_CBPDATA8m_CMAX(u) BCM56800_A0_MMU_CBPDATA8m_CMAX(u)
#define MMU_CBPDATA8m_SIZE BCM56800_A0_MMU_CBPDATA8m_SIZE
typedef BCM56800_A0_MMU_CBPDATA8m_t MMU_CBPDATA8m_t;
#define MMU_CBPDATA8m_CLR BCM56800_A0_MMU_CBPDATA8m_CLR
#define MMU_CBPDATA8m_SET BCM56800_A0_MMU_CBPDATA8m_SET
#define MMU_CBPDATA8m_GET BCM56800_A0_MMU_CBPDATA8m_GET
#define MMU_CBPDATA8m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA8m_CBPDATAf_GET
#define MMU_CBPDATA8m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA8m_CBPDATAf_SET
#define READ_MMU_CBPDATA8m BCM56800_A0_READ_MMU_CBPDATA8m
#define WRITE_MMU_CBPDATA8m BCM56800_A0_WRITE_MMU_CBPDATA8m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA8m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPData9
 * BLOCKS:   MMU
 * DESC:     CBP Data RAM 9
 * SIZE:     64
 * FIELDS:
 *     CBPDATA          CBPData [639:576]
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPDATA9m 0x0fd24000

#define BCM56800_A0_MMU_CBPDATA9m_MIN 0
#define BCM56800_A0_MMU_CBPDATA9m_MAX 12287
#define BCM56800_A0_MMU_CBPDATA9m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPDATA9m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPData9.
 *
 */
typedef union BCM56800_A0_MMU_CBPDATA9m_s {
	uint32_t v[2];
	uint32_t mmu_cbpdata9[2];
	uint32_t _mmu_cbpdata9;
} BCM56800_A0_MMU_CBPDATA9m_t;

#define BCM56800_A0_MMU_CBPDATA9m_CLR(r) CDK_MEMSET(&((r)._mmu_cbpdata9), 0, sizeof(BCM56800_A0_MMU_CBPDATA9m_t))
#define BCM56800_A0_MMU_CBPDATA9m_SET(r,i,d) (r).mmu_cbpdata9[i] = d
#define BCM56800_A0_MMU_CBPDATA9m_GET(r,i) (r).mmu_cbpdata9[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPDATA9m_CBPDATAf_GET(r,a) cdk_field_get((r).mmu_cbpdata9,0,63,a)
#define BCM56800_A0_MMU_CBPDATA9m_CBPDATAf_SET(r,a) cdk_field_set((r).mmu_cbpdata9,0,63,a)

/*
 * These macros can be used to access MMU_CBPData9.
 *
 */
#define BCM56800_A0_READ_MMU_CBPDATA9m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPDATA9m,i,(m._mmu_cbpdata9),2)
#define BCM56800_A0_WRITE_MMU_CBPDATA9m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPDATA9m,i,&(m._mmu_cbpdata9),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPDATA9m BCM56800_A0_MMU_CBPDATA9m
#define MMU_CBPDATA9m_MIN BCM56800_A0_MMU_CBPDATA9m_MIN
#define MMU_CBPDATA9m_MAX BCM56800_A0_MMU_CBPDATA9m_MAX
#define MMU_CBPDATA9m_CMAX(u) BCM56800_A0_MMU_CBPDATA9m_CMAX(u)
#define MMU_CBPDATA9m_SIZE BCM56800_A0_MMU_CBPDATA9m_SIZE
typedef BCM56800_A0_MMU_CBPDATA9m_t MMU_CBPDATA9m_t;
#define MMU_CBPDATA9m_CLR BCM56800_A0_MMU_CBPDATA9m_CLR
#define MMU_CBPDATA9m_SET BCM56800_A0_MMU_CBPDATA9m_SET
#define MMU_CBPDATA9m_GET BCM56800_A0_MMU_CBPDATA9m_GET
#define MMU_CBPDATA9m_CBPDATAf_GET BCM56800_A0_MMU_CBPDATA9m_CBPDATAf_GET
#define MMU_CBPDATA9m_CBPDATAf_SET BCM56800_A0_MMU_CBPDATA9m_CBPDATAf_SET
#define READ_MMU_CBPDATA9m BCM56800_A0_READ_MMU_CBPDATA9m
#define WRITE_MMU_CBPDATA9m BCM56800_A0_WRITE_MMU_CBPDATA9m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPDATA9m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPPktHeader0_mem0
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 0
 * SIZE:     64
 * FIELDS:
 *     HEADER_TYPE      header type
 *     MH_PRIORITY      mh priority
 *     CNG              cng
 *     CLASSIFICATION_TAG classification tag
 *     DESTINATION      destination
 *     LBID             lbid
 *     ECN              ecn
 *     DO_NOT_CHANGE_TTL do not change ttl
 *     HDR_EXT_OVERLAY  header ext overlay
 *     MC               header ext overlay
 *     HG2_FRC_RESERVED hg2 frc reserved
 *     RESERVED         reserved
 *     PARITY           parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m 0x0fd48000

#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MIN 0
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MAX 12287
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPPktHeader0_mem0.
 *
 */
typedef union BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader0_mem0[2];
	uint32_t _mmu_cbppktheader0_mem0;
} BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_t;

#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader0_mem0), 0, sizeof(BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_t))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_SET(r,i,d) (r).mmu_cbppktheader0_mem0[i] = d
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_GET(r,i) (r).mmu_cbppktheader0_mem0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HEADER_TYPEf_GET(r) (((r).mmu_cbppktheader0_mem0[0]) & 0x7)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HEADER_TYPEf_SET(r,f) (r).mmu_cbppktheader0_mem0[0]=(((r).mmu_cbppktheader0_mem0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MH_PRIORITYf_GET(r) ((((r).mmu_cbppktheader0_mem0[0]) >> 3) & 0xf)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MH_PRIORITYf_SET(r,f) (r).mmu_cbppktheader0_mem0[0]=(((r).mmu_cbppktheader0_mem0[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CNGf_GET(r) ((((r).mmu_cbppktheader0_mem0[0]) >> 7) & 0x3)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CNGf_SET(r,f) (r).mmu_cbppktheader0_mem0[0]=(((r).mmu_cbppktheader0_mem0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CLASSIFICATION_TAGf_GET(r) ((((r).mmu_cbppktheader0_mem0[0]) >> 9) & 0xffff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CLASSIFICATION_TAGf_SET(r,f) (r).mmu_cbppktheader0_mem0[0]=(((r).mmu_cbppktheader0_mem0[0] & ~((uint32_t)0xffff << 9)) | ((((uint32_t)f) & 0xffff) << 9))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_DESTINATIONf_GET(r) ((((r).mmu_cbppktheader0_mem0[0]) >> 25) & 0x3f)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_DESTINATIONf_SET(r,f) (r).mmu_cbppktheader0_mem0[0]=(((r).mmu_cbppktheader0_mem0[0] & ~((uint32_t)0x3f << 25)) | ((((uint32_t)f) & 0x3f) << 25))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_LBIDf_GET(r) cdk_field32_get((r).mmu_cbppktheader0_mem0,31,38)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_LBIDf_SET(r,f) cdk_field32_set((r).mmu_cbppktheader0_mem0,31,38,f)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_ECNf_GET(r) ((((r).mmu_cbppktheader0_mem0[1]) >> 7) & 0x3)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_ECNf_SET(r,f) (r).mmu_cbppktheader0_mem0[1]=(((r).mmu_cbppktheader0_mem0[1] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_DO_NOT_CHANGE_TTLf_GET(r) ((((r).mmu_cbppktheader0_mem0[1]) >> 9) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_DO_NOT_CHANGE_TTLf_SET(r,f) (r).mmu_cbppktheader0_mem0[1]=(((r).mmu_cbppktheader0_mem0[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HDR_EXT_OVERLAYf_GET(r) ((((r).mmu_cbppktheader0_mem0[1]) >> 10) & 0xff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HDR_EXT_OVERLAYf_SET(r,f) (r).mmu_cbppktheader0_mem0[1]=(((r).mmu_cbppktheader0_mem0[1] & ~((uint32_t)0xff << 10)) | ((((uint32_t)f) & 0xff) << 10))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MCf_GET(r) ((((r).mmu_cbppktheader0_mem0[1]) >> 18) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MCf_SET(r,f) (r).mmu_cbppktheader0_mem0[1]=(((r).mmu_cbppktheader0_mem0[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HG2_FRC_RESERVEDf_GET(r) ((((r).mmu_cbppktheader0_mem0[1]) >> 19) & 0x3f)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HG2_FRC_RESERVEDf_SET(r,f) (r).mmu_cbppktheader0_mem0[1]=(((r).mmu_cbppktheader0_mem0[1] & ~((uint32_t)0x3f << 19)) | ((((uint32_t)f) & 0x3f) << 19))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_RESERVEDf_GET(r) ((((r).mmu_cbppktheader0_mem0[1]) >> 25) & 0x3f)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_RESERVEDf_SET(r,f) (r).mmu_cbppktheader0_mem0[1]=(((r).mmu_cbppktheader0_mem0[1] & ~((uint32_t)0x3f << 25)) | ((((uint32_t)f) & 0x3f) << 25))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_PARITYf_GET(r) ((((r).mmu_cbppktheader0_mem0[1]) >> 31) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_PARITYf_SET(r,f) (r).mmu_cbppktheader0_mem0[1]=(((r).mmu_cbppktheader0_mem0[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access MMU_CBPPktHeader0_mem0.
 *
 */
#define BCM56800_A0_READ_MMU_CBPPKTHEADER0_MEM0m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m,i,(m._mmu_cbppktheader0_mem0),2)
#define BCM56800_A0_WRITE_MMU_CBPPKTHEADER0_MEM0m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m,i,&(m._mmu_cbppktheader0_mem0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER0_MEM0m BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m
#define MMU_CBPPKTHEADER0_MEM0m_MIN BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MIN
#define MMU_CBPPKTHEADER0_MEM0m_MAX BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MAX
#define MMU_CBPPKTHEADER0_MEM0m_CMAX(u) BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CMAX(u)
#define MMU_CBPPKTHEADER0_MEM0m_SIZE BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_SIZE
typedef BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_t MMU_CBPPKTHEADER0_MEM0m_t;
#define MMU_CBPPKTHEADER0_MEM0m_CLR BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CLR
#define MMU_CBPPKTHEADER0_MEM0m_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_SET
#define MMU_CBPPKTHEADER0_MEM0m_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_GET
#define MMU_CBPPKTHEADER0_MEM0m_HEADER_TYPEf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HEADER_TYPEf_GET
#define MMU_CBPPKTHEADER0_MEM0m_HEADER_TYPEf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HEADER_TYPEf_SET
#define MMU_CBPPKTHEADER0_MEM0m_MH_PRIORITYf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MH_PRIORITYf_GET
#define MMU_CBPPKTHEADER0_MEM0m_MH_PRIORITYf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MH_PRIORITYf_SET
#define MMU_CBPPKTHEADER0_MEM0m_CNGf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CNGf_GET
#define MMU_CBPPKTHEADER0_MEM0m_CNGf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CNGf_SET
#define MMU_CBPPKTHEADER0_MEM0m_CLASSIFICATION_TAGf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CLASSIFICATION_TAGf_GET
#define MMU_CBPPKTHEADER0_MEM0m_CLASSIFICATION_TAGf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_CLASSIFICATION_TAGf_SET
#define MMU_CBPPKTHEADER0_MEM0m_DESTINATIONf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_DESTINATIONf_GET
#define MMU_CBPPKTHEADER0_MEM0m_DESTINATIONf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_DESTINATIONf_SET
#define MMU_CBPPKTHEADER0_MEM0m_LBIDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_LBIDf_GET
#define MMU_CBPPKTHEADER0_MEM0m_LBIDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_LBIDf_SET
#define MMU_CBPPKTHEADER0_MEM0m_ECNf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_ECNf_GET
#define MMU_CBPPKTHEADER0_MEM0m_ECNf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_ECNf_SET
#define MMU_CBPPKTHEADER0_MEM0m_DO_NOT_CHANGE_TTLf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_DO_NOT_CHANGE_TTLf_GET
#define MMU_CBPPKTHEADER0_MEM0m_DO_NOT_CHANGE_TTLf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_DO_NOT_CHANGE_TTLf_SET
#define MMU_CBPPKTHEADER0_MEM0m_HDR_EXT_OVERLAYf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HDR_EXT_OVERLAYf_GET
#define MMU_CBPPKTHEADER0_MEM0m_HDR_EXT_OVERLAYf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HDR_EXT_OVERLAYf_SET
#define MMU_CBPPKTHEADER0_MEM0m_MCf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MCf_GET
#define MMU_CBPPKTHEADER0_MEM0m_MCf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_MCf_SET
#define MMU_CBPPKTHEADER0_MEM0m_HG2_FRC_RESERVEDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HG2_FRC_RESERVEDf_GET
#define MMU_CBPPKTHEADER0_MEM0m_HG2_FRC_RESERVEDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_HG2_FRC_RESERVEDf_SET
#define MMU_CBPPKTHEADER0_MEM0m_RESERVEDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_RESERVEDf_GET
#define MMU_CBPPKTHEADER0_MEM0m_RESERVEDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_RESERVEDf_SET
#define MMU_CBPPKTHEADER0_MEM0m_PARITYf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_PARITYf_GET
#define MMU_CBPPKTHEADER0_MEM0m_PARITYf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m_PARITYf_SET
#define READ_MMU_CBPPKTHEADER0_MEM0m BCM56800_A0_READ_MMU_CBPPKTHEADER0_MEM0m
#define WRITE_MMU_CBPPKTHEADER0_MEM0m BCM56800_A0_WRITE_MMU_CBPPKTHEADER0_MEM0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPPKTHEADER0_MEM0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPPktHeader0_mem1
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 1
 * SIZE:     64
 * FIELDS:
 *     VC_LABEL         vc label
 *     PKT_VLAN_TAG     parity
 *     SRC_MODID        src modid
 *     SRC_PORT_TGID    src port tgid
 *     USE_OUTER_HDR_TTL use outer hdr ttl
 *     MH_OPCODE_OVERLAY mh opcode overlay
 *     RESERVED         reserved
 *     PARITY           parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m 0x0fd4c000

#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_MIN 0
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_MAX 12287
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SIZE 8

/*
 * This structure should be used to declare and program MMU_CBPPktHeader0_mem1.
 *
 */
typedef union BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader0_mem1[2];
	uint32_t _mmu_cbppktheader0_mem1;
} BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_t;

#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader0_mem1), 0, sizeof(BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_t))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SET(r,i,d) (r).mmu_cbppktheader0_mem1[i] = d
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_GET(r,i) (r).mmu_cbppktheader0_mem1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_VC_LABELf_GET(r) (((r).mmu_cbppktheader0_mem1[0]) & 0xffff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_VC_LABELf_SET(r,f) (r).mmu_cbppktheader0_mem1[0]=(((r).mmu_cbppktheader0_mem1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_PKT_VLAN_TAGf_GET(r) ((((r).mmu_cbppktheader0_mem1[0]) >> 16) & 0xffff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_PKT_VLAN_TAGf_SET(r,f) (r).mmu_cbppktheader0_mem1[0]=(((r).mmu_cbppktheader0_mem1[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SRC_MODIDf_GET(r) (((r).mmu_cbppktheader0_mem1[1]) & 0xff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SRC_MODIDf_SET(r,f) (r).mmu_cbppktheader0_mem1[1]=(((r).mmu_cbppktheader0_mem1[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SRC_PORT_TGIDf_GET(r) ((((r).mmu_cbppktheader0_mem1[1]) >> 8) & 0xff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SRC_PORT_TGIDf_SET(r,f) (r).mmu_cbppktheader0_mem1[1]=(((r).mmu_cbppktheader0_mem1[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_USE_OUTER_HDR_TTLf_GET(r) ((((r).mmu_cbppktheader0_mem1[1]) >> 16) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_USE_OUTER_HDR_TTLf_SET(r,f) (r).mmu_cbppktheader0_mem1[1]=(((r).mmu_cbppktheader0_mem1[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_MH_OPCODE_OVERLAYf_GET(r) ((((r).mmu_cbppktheader0_mem1[1]) >> 17) & 0xff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_MH_OPCODE_OVERLAYf_SET(r,f) (r).mmu_cbppktheader0_mem1[1]=(((r).mmu_cbppktheader0_mem1[1] & ~((uint32_t)0xff << 17)) | ((((uint32_t)f) & 0xff) << 17))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_RESERVEDf_GET(r) ((((r).mmu_cbppktheader0_mem1[1]) >> 25) & 0x3f)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_RESERVEDf_SET(r,f) (r).mmu_cbppktheader0_mem1[1]=(((r).mmu_cbppktheader0_mem1[1] & ~((uint32_t)0x3f << 25)) | ((((uint32_t)f) & 0x3f) << 25))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_PARITYf_GET(r) ((((r).mmu_cbppktheader0_mem1[1]) >> 31) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_PARITYf_SET(r,f) (r).mmu_cbppktheader0_mem1[1]=(((r).mmu_cbppktheader0_mem1[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access MMU_CBPPktHeader0_mem1.
 *
 */
#define BCM56800_A0_READ_MMU_CBPPKTHEADER0_MEM1m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m,i,(m._mmu_cbppktheader0_mem1),2)
#define BCM56800_A0_WRITE_MMU_CBPPKTHEADER0_MEM1m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m,i,&(m._mmu_cbppktheader0_mem1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER0_MEM1m BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m
#define MMU_CBPPKTHEADER0_MEM1m_MIN BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_MIN
#define MMU_CBPPKTHEADER0_MEM1m_MAX BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_MAX
#define MMU_CBPPKTHEADER0_MEM1m_CMAX(u) BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_CMAX(u)
#define MMU_CBPPKTHEADER0_MEM1m_SIZE BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SIZE
typedef BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_t MMU_CBPPKTHEADER0_MEM1m_t;
#define MMU_CBPPKTHEADER0_MEM1m_CLR BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_CLR
#define MMU_CBPPKTHEADER0_MEM1m_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SET
#define MMU_CBPPKTHEADER0_MEM1m_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_GET
#define MMU_CBPPKTHEADER0_MEM1m_VC_LABELf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_VC_LABELf_GET
#define MMU_CBPPKTHEADER0_MEM1m_VC_LABELf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_VC_LABELf_SET
#define MMU_CBPPKTHEADER0_MEM1m_PKT_VLAN_TAGf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_PKT_VLAN_TAGf_GET
#define MMU_CBPPKTHEADER0_MEM1m_PKT_VLAN_TAGf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_PKT_VLAN_TAGf_SET
#define MMU_CBPPKTHEADER0_MEM1m_SRC_MODIDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SRC_MODIDf_GET
#define MMU_CBPPKTHEADER0_MEM1m_SRC_MODIDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SRC_MODIDf_SET
#define MMU_CBPPKTHEADER0_MEM1m_SRC_PORT_TGIDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SRC_PORT_TGIDf_GET
#define MMU_CBPPKTHEADER0_MEM1m_SRC_PORT_TGIDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_SRC_PORT_TGIDf_SET
#define MMU_CBPPKTHEADER0_MEM1m_USE_OUTER_HDR_TTLf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_USE_OUTER_HDR_TTLf_GET
#define MMU_CBPPKTHEADER0_MEM1m_USE_OUTER_HDR_TTLf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_USE_OUTER_HDR_TTLf_SET
#define MMU_CBPPKTHEADER0_MEM1m_MH_OPCODE_OVERLAYf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_MH_OPCODE_OVERLAYf_GET
#define MMU_CBPPKTHEADER0_MEM1m_MH_OPCODE_OVERLAYf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_MH_OPCODE_OVERLAYf_SET
#define MMU_CBPPKTHEADER0_MEM1m_RESERVEDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_RESERVEDf_GET
#define MMU_CBPPKTHEADER0_MEM1m_RESERVEDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_RESERVEDf_SET
#define MMU_CBPPKTHEADER0_MEM1m_PARITYf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_PARITYf_GET
#define MMU_CBPPKTHEADER0_MEM1m_PARITYf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m_PARITYf_SET
#define READ_MMU_CBPPKTHEADER0_MEM1m BCM56800_A0_READ_MMU_CBPPKTHEADER0_MEM1m
#define WRITE_MMU_CBPPKTHEADER0_MEM1m BCM56800_A0_WRITE_MMU_CBPPKTHEADER0_MEM1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPPKTHEADER0_MEM1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPPktHeader0_mem2
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 2
 * SIZE:     56
 * FIELDS:
 *     BPDU             bpdu
 *     L3UC             l3uc
 *     DECAP_IPTUNNEL   decap iptunnel
 *     NHOP_INDEX       nhop index
 *     MTP_INDEX        mtp index
 *     DSCP             dscp
 *     ADD_VID          add vid
 *     INPUT_PRIORITY   input priority
 *     COS              cos
 *     CPU_COS          cpu cos
 *     INGRESS_TAGGED   ingress tagged
 *     UNMOD_PKT_VALID  unmod pkt valid
 *     HGI              hgi
 *     RESERVED         reserved
 *     PARITY           parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m 0x0fd50000

#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_MIN 0
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_MAX 12287
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_SIZE 7

/*
 * This structure should be used to declare and program MMU_CBPPktHeader0_mem2.
 *
 */
typedef union BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader0_mem2[2];
	uint32_t _mmu_cbppktheader0_mem2;
} BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_t;

#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader0_mem2), 0, sizeof(BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_t))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_SET(r,i,d) (r).mmu_cbppktheader0_mem2[i] = d
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_GET(r,i) (r).mmu_cbppktheader0_mem2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_BPDUf_GET(r) (((r).mmu_cbppktheader0_mem2[0]) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_BPDUf_SET(r,f) (r).mmu_cbppktheader0_mem2[0]=(((r).mmu_cbppktheader0_mem2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_L3UCf_GET(r) ((((r).mmu_cbppktheader0_mem2[0]) >> 1) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_L3UCf_SET(r,f) (r).mmu_cbppktheader0_mem2[0]=(((r).mmu_cbppktheader0_mem2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_DECAP_IPTUNNELf_GET(r) ((((r).mmu_cbppktheader0_mem2[0]) >> 2) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_DECAP_IPTUNNELf_SET(r,f) (r).mmu_cbppktheader0_mem2[0]=(((r).mmu_cbppktheader0_mem2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_NHOP_INDEXf_GET(r) ((((r).mmu_cbppktheader0_mem2[0]) >> 3) & 0x1fff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_NHOP_INDEXf_SET(r,f) (r).mmu_cbppktheader0_mem2[0]=(((r).mmu_cbppktheader0_mem2[0] & ~((uint32_t)0x1fff << 3)) | ((((uint32_t)f) & 0x1fff) << 3))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_MTP_INDEXf_GET(r) ((((r).mmu_cbppktheader0_mem2[0]) >> 16) & 0x7f)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_MTP_INDEXf_SET(r,f) (r).mmu_cbppktheader0_mem2[0]=(((r).mmu_cbppktheader0_mem2[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_DSCPf_GET(r) ((((r).mmu_cbppktheader0_mem2[0]) >> 23) & 0x3f)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_DSCPf_SET(r,f) (r).mmu_cbppktheader0_mem2[0]=(((r).mmu_cbppktheader0_mem2[0] & ~((uint32_t)0x3f << 23)) | ((((uint32_t)f) & 0x3f) << 23))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_ADD_VIDf_GET(r) ((((r).mmu_cbppktheader0_mem2[0]) >> 29) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_ADD_VIDf_SET(r,f) (r).mmu_cbppktheader0_mem2[0]=(((r).mmu_cbppktheader0_mem2[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_INPUT_PRIORITYf_GET(r) cdk_field32_get((r).mmu_cbppktheader0_mem2,30,33)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_INPUT_PRIORITYf_SET(r,f) cdk_field32_set((r).mmu_cbppktheader0_mem2,30,33,f)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_COSf_GET(r) ((((r).mmu_cbppktheader0_mem2[1]) >> 2) & 0xf)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_COSf_SET(r,f) (r).mmu_cbppktheader0_mem2[1]=(((r).mmu_cbppktheader0_mem2[1] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_CPU_COSf_GET(r) ((((r).mmu_cbppktheader0_mem2[1]) >> 6) & 0xf)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_CPU_COSf_SET(r,f) (r).mmu_cbppktheader0_mem2[1]=(((r).mmu_cbppktheader0_mem2[1] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_INGRESS_TAGGEDf_GET(r) ((((r).mmu_cbppktheader0_mem2[1]) >> 10) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_INGRESS_TAGGEDf_SET(r,f) (r).mmu_cbppktheader0_mem2[1]=(((r).mmu_cbppktheader0_mem2[1] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_UNMOD_PKT_VALIDf_GET(r) ((((r).mmu_cbppktheader0_mem2[1]) >> 11) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_UNMOD_PKT_VALIDf_SET(r,f) (r).mmu_cbppktheader0_mem2[1]=(((r).mmu_cbppktheader0_mem2[1] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_HGIf_GET(r) ((((r).mmu_cbppktheader0_mem2[1]) >> 12) & 0x3)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_HGIf_SET(r,f) (r).mmu_cbppktheader0_mem2[1]=(((r).mmu_cbppktheader0_mem2[1] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_RESERVEDf_GET(r) ((((r).mmu_cbppktheader0_mem2[1]) >> 14) & 0x1ff)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_RESERVEDf_SET(r,f) (r).mmu_cbppktheader0_mem2[1]=(((r).mmu_cbppktheader0_mem2[1] & ~((uint32_t)0x1ff << 14)) | ((((uint32_t)f) & 0x1ff) << 14))
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_PARITYf_GET(r) ((((r).mmu_cbppktheader0_mem2[1]) >> 23) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_PARITYf_SET(r,f) (r).mmu_cbppktheader0_mem2[1]=(((r).mmu_cbppktheader0_mem2[1] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))

/*
 * These macros can be used to access MMU_CBPPktHeader0_mem2.
 *
 */
#define BCM56800_A0_READ_MMU_CBPPKTHEADER0_MEM2m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m,i,(m._mmu_cbppktheader0_mem2),2)
#define BCM56800_A0_WRITE_MMU_CBPPKTHEADER0_MEM2m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m,i,&(m._mmu_cbppktheader0_mem2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER0_MEM2m BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m
#define MMU_CBPPKTHEADER0_MEM2m_MIN BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_MIN
#define MMU_CBPPKTHEADER0_MEM2m_MAX BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_MAX
#define MMU_CBPPKTHEADER0_MEM2m_CMAX(u) BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_CMAX(u)
#define MMU_CBPPKTHEADER0_MEM2m_SIZE BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_SIZE
typedef BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_t MMU_CBPPKTHEADER0_MEM2m_t;
#define MMU_CBPPKTHEADER0_MEM2m_CLR BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_CLR
#define MMU_CBPPKTHEADER0_MEM2m_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_SET
#define MMU_CBPPKTHEADER0_MEM2m_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_GET
#define MMU_CBPPKTHEADER0_MEM2m_BPDUf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_BPDUf_GET
#define MMU_CBPPKTHEADER0_MEM2m_BPDUf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_BPDUf_SET
#define MMU_CBPPKTHEADER0_MEM2m_L3UCf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_L3UCf_GET
#define MMU_CBPPKTHEADER0_MEM2m_L3UCf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_L3UCf_SET
#define MMU_CBPPKTHEADER0_MEM2m_DECAP_IPTUNNELf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_DECAP_IPTUNNELf_GET
#define MMU_CBPPKTHEADER0_MEM2m_DECAP_IPTUNNELf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_DECAP_IPTUNNELf_SET
#define MMU_CBPPKTHEADER0_MEM2m_NHOP_INDEXf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_NHOP_INDEXf_GET
#define MMU_CBPPKTHEADER0_MEM2m_NHOP_INDEXf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_NHOP_INDEXf_SET
#define MMU_CBPPKTHEADER0_MEM2m_MTP_INDEXf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_MTP_INDEXf_GET
#define MMU_CBPPKTHEADER0_MEM2m_MTP_INDEXf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_MTP_INDEXf_SET
#define MMU_CBPPKTHEADER0_MEM2m_DSCPf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_DSCPf_GET
#define MMU_CBPPKTHEADER0_MEM2m_DSCPf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_DSCPf_SET
#define MMU_CBPPKTHEADER0_MEM2m_ADD_VIDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_ADD_VIDf_GET
#define MMU_CBPPKTHEADER0_MEM2m_ADD_VIDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_ADD_VIDf_SET
#define MMU_CBPPKTHEADER0_MEM2m_INPUT_PRIORITYf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_INPUT_PRIORITYf_GET
#define MMU_CBPPKTHEADER0_MEM2m_INPUT_PRIORITYf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_INPUT_PRIORITYf_SET
#define MMU_CBPPKTHEADER0_MEM2m_COSf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_COSf_GET
#define MMU_CBPPKTHEADER0_MEM2m_COSf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_COSf_SET
#define MMU_CBPPKTHEADER0_MEM2m_CPU_COSf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_CPU_COSf_GET
#define MMU_CBPPKTHEADER0_MEM2m_CPU_COSf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_CPU_COSf_SET
#define MMU_CBPPKTHEADER0_MEM2m_INGRESS_TAGGEDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_INGRESS_TAGGEDf_GET
#define MMU_CBPPKTHEADER0_MEM2m_INGRESS_TAGGEDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_INGRESS_TAGGEDf_SET
#define MMU_CBPPKTHEADER0_MEM2m_UNMOD_PKT_VALIDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_UNMOD_PKT_VALIDf_GET
#define MMU_CBPPKTHEADER0_MEM2m_UNMOD_PKT_VALIDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_UNMOD_PKT_VALIDf_SET
#define MMU_CBPPKTHEADER0_MEM2m_HGIf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_HGIf_GET
#define MMU_CBPPKTHEADER0_MEM2m_HGIf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_HGIf_SET
#define MMU_CBPPKTHEADER0_MEM2m_RESERVEDf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_RESERVEDf_GET
#define MMU_CBPPKTHEADER0_MEM2m_RESERVEDf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_RESERVEDf_SET
#define MMU_CBPPKTHEADER0_MEM2m_PARITYf_GET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_PARITYf_GET
#define MMU_CBPPKTHEADER0_MEM2m_PARITYf_SET BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m_PARITYf_SET
#define READ_MMU_CBPPKTHEADER0_MEM2m BCM56800_A0_READ_MMU_CBPPKTHEADER0_MEM2m
#define WRITE_MMU_CBPPKTHEADER0_MEM2m BCM56800_A0_WRITE_MMU_CBPPKTHEADER0_MEM2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPPKTHEADER0_MEM2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPPktHeader1_mem0
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 1 MEM0
 * SIZE:     38
 * FIELDS:
 *     PORT_BITMAP      port bitmap
 *     EM_LOCAL_MTP     em local mtp
 *     IM_LOCAL_MTP     im local mtp
 *     SRC_PORT_NUM     Source Port num
 *     RESERVED_BITS    reserved bits
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m 0x10d70000

#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_MIN 0
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_MAX 12287
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeader1_mem0.
 *
 */
typedef union BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader1_mem0[2];
	uint32_t _mmu_cbppktheader1_mem0;
} BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_t;

#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader1_mem0), 0, sizeof(BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_t))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_SET(r,i,d) (r).mmu_cbppktheader1_mem0[i] = d
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_GET(r,i) (r).mmu_cbppktheader1_mem0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_PORT_BITMAPf_GET(r) (((r).mmu_cbppktheader1_mem0[0]) & 0x1fffff)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_PORT_BITMAPf_SET(r,f) (r).mmu_cbppktheader1_mem0[0]=(((r).mmu_cbppktheader1_mem0[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_EM_LOCAL_MTPf_GET(r) ((((r).mmu_cbppktheader1_mem0[0]) >> 21) & 0x1f)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_EM_LOCAL_MTPf_SET(r,f) (r).mmu_cbppktheader1_mem0[0]=(((r).mmu_cbppktheader1_mem0[0] & ~((uint32_t)0x1f << 21)) | ((((uint32_t)f) & 0x1f) << 21))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_IM_LOCAL_MTPf_GET(r) ((((r).mmu_cbppktheader1_mem0[0]) >> 26) & 0x1f)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_IM_LOCAL_MTPf_SET(r,f) (r).mmu_cbppktheader1_mem0[0]=(((r).mmu_cbppktheader1_mem0[0] & ~((uint32_t)0x1f << 26)) | ((((uint32_t)f) & 0x1f) << 26))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_SRC_PORT_NUMf_GET(r) cdk_field32_get((r).mmu_cbppktheader1_mem0,31,35)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_SRC_PORT_NUMf_SET(r,f) cdk_field32_set((r).mmu_cbppktheader1_mem0,31,35,f)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_RESERVED_BITSf_GET(r) ((((r).mmu_cbppktheader1_mem0[1]) >> 4) & 0x3)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_RESERVED_BITSf_SET(r,f) (r).mmu_cbppktheader1_mem0[1]=(((r).mmu_cbppktheader1_mem0[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))

/*
 * These macros can be used to access MMU_CBPPktHeader1_mem0.
 *
 */
#define BCM56800_A0_READ_MMU_CBPPKTHEADER1_MEM0m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m,i,(m._mmu_cbppktheader1_mem0),2)
#define BCM56800_A0_WRITE_MMU_CBPPKTHEADER1_MEM0m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m,i,&(m._mmu_cbppktheader1_mem0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER1_MEM0m BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m
#define MMU_CBPPKTHEADER1_MEM0m_MIN BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_MIN
#define MMU_CBPPKTHEADER1_MEM0m_MAX BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_MAX
#define MMU_CBPPKTHEADER1_MEM0m_CMAX(u) BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_CMAX(u)
#define MMU_CBPPKTHEADER1_MEM0m_SIZE BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_SIZE
typedef BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_t MMU_CBPPKTHEADER1_MEM0m_t;
#define MMU_CBPPKTHEADER1_MEM0m_CLR BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_CLR
#define MMU_CBPPKTHEADER1_MEM0m_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_SET
#define MMU_CBPPKTHEADER1_MEM0m_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_GET
#define MMU_CBPPKTHEADER1_MEM0m_PORT_BITMAPf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_PORT_BITMAPf_GET
#define MMU_CBPPKTHEADER1_MEM0m_PORT_BITMAPf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_PORT_BITMAPf_SET
#define MMU_CBPPKTHEADER1_MEM0m_EM_LOCAL_MTPf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_EM_LOCAL_MTPf_GET
#define MMU_CBPPKTHEADER1_MEM0m_EM_LOCAL_MTPf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_EM_LOCAL_MTPf_SET
#define MMU_CBPPKTHEADER1_MEM0m_IM_LOCAL_MTPf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_IM_LOCAL_MTPf_GET
#define MMU_CBPPKTHEADER1_MEM0m_IM_LOCAL_MTPf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_IM_LOCAL_MTPf_SET
#define MMU_CBPPKTHEADER1_MEM0m_SRC_PORT_NUMf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_SRC_PORT_NUMf_GET
#define MMU_CBPPKTHEADER1_MEM0m_SRC_PORT_NUMf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_SRC_PORT_NUMf_SET
#define MMU_CBPPKTHEADER1_MEM0m_RESERVED_BITSf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_RESERVED_BITSf_GET
#define MMU_CBPPKTHEADER1_MEM0m_RESERVED_BITSf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m_RESERVED_BITSf_SET
#define READ_MMU_CBPPKTHEADER1_MEM0m BCM56800_A0_READ_MMU_CBPPKTHEADER1_MEM0m
#define WRITE_MMU_CBPPKTHEADER1_MEM0m BCM56800_A0_WRITE_MMU_CBPPKTHEADER1_MEM0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPPKTHEADER1_MEM0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPPktHeader1_mem1
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header RAM 1 MEM0
 * SIZE:     40
 * FIELDS:
 *     L3_BITMAP        l3 bitmap
 *     MC_INDEX         mc_index
 *     RESERVED         reserved
 *     ECCP             ecc
 *     DATA             data in this table for which ecc is computed
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m 0x10d74000

#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_MIN 0
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_MAX 12287
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeader1_mem1.
 *
 */
typedef union BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheader1_mem1[2];
	uint32_t _mmu_cbppktheader1_mem1;
} BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_t;

#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheader1_mem1), 0, sizeof(BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_t))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_SET(r,i,d) (r).mmu_cbppktheader1_mem1[i] = d
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_GET(r,i) (r).mmu_cbppktheader1_mem1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_L3_BITMAPf_GET(r) (((r).mmu_cbppktheader1_mem1[0]) & 0x1fffff)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_L3_BITMAPf_SET(r,f) (r).mmu_cbppktheader1_mem1[0]=(((r).mmu_cbppktheader1_mem1[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_MC_INDEXf_GET(r) ((((r).mmu_cbppktheader1_mem1[0]) >> 21) & 0x3ff)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_MC_INDEXf_SET(r,f) (r).mmu_cbppktheader1_mem1[0]=(((r).mmu_cbppktheader1_mem1[0] & ~((uint32_t)0x3ff << 21)) | ((((uint32_t)f) & 0x3ff) << 21))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_RESERVEDf_GET(r) ((((r).mmu_cbppktheader1_mem1[0]) >> 31) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_RESERVEDf_SET(r,f) (r).mmu_cbppktheader1_mem1[0]=(((r).mmu_cbppktheader1_mem1[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_ECCPf_GET(r) (((r).mmu_cbppktheader1_mem1[1]) & 0xff)
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_ECCPf_SET(r,f) (r).mmu_cbppktheader1_mem1[1]=(((r).mmu_cbppktheader1_mem1[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_DATAf_GET(r) ((r).mmu_cbppktheader1_mem1[0])
#define BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_DATAf_SET(r,f) (r).mmu_cbppktheader1_mem1[0]=((uint32_t)f)

/*
 * These macros can be used to access MMU_CBPPktHeader1_mem1.
 *
 */
#define BCM56800_A0_READ_MMU_CBPPKTHEADER1_MEM1m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m,i,(m._mmu_cbppktheader1_mem1),2)
#define BCM56800_A0_WRITE_MMU_CBPPKTHEADER1_MEM1m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m,i,&(m._mmu_cbppktheader1_mem1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADER1_MEM1m BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m
#define MMU_CBPPKTHEADER1_MEM1m_MIN BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_MIN
#define MMU_CBPPKTHEADER1_MEM1m_MAX BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_MAX
#define MMU_CBPPKTHEADER1_MEM1m_CMAX(u) BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_CMAX(u)
#define MMU_CBPPKTHEADER1_MEM1m_SIZE BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_SIZE
typedef BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_t MMU_CBPPKTHEADER1_MEM1m_t;
#define MMU_CBPPKTHEADER1_MEM1m_CLR BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_CLR
#define MMU_CBPPKTHEADER1_MEM1m_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_SET
#define MMU_CBPPKTHEADER1_MEM1m_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_GET
#define MMU_CBPPKTHEADER1_MEM1m_L3_BITMAPf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_L3_BITMAPf_GET
#define MMU_CBPPKTHEADER1_MEM1m_L3_BITMAPf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_L3_BITMAPf_SET
#define MMU_CBPPKTHEADER1_MEM1m_MC_INDEXf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_MC_INDEXf_GET
#define MMU_CBPPKTHEADER1_MEM1m_MC_INDEXf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_MC_INDEXf_SET
#define MMU_CBPPKTHEADER1_MEM1m_RESERVEDf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_RESERVEDf_GET
#define MMU_CBPPKTHEADER1_MEM1m_RESERVEDf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_RESERVEDf_SET
#define MMU_CBPPKTHEADER1_MEM1m_ECCPf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_ECCPf_GET
#define MMU_CBPPKTHEADER1_MEM1m_ECCPf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_ECCPf_SET
#define MMU_CBPPKTHEADER1_MEM1m_DATAf_GET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_DATAf_GET
#define MMU_CBPPKTHEADER1_MEM1m_DATAf_SET BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m_DATAf_SET
#define READ_MMU_CBPPKTHEADER1_MEM1m BCM56800_A0_READ_MMU_CBPPKTHEADER1_MEM1m
#define WRITE_MMU_CBPPKTHEADER1_MEM1m BCM56800_A0_WRITE_MMU_CBPPKTHEADER1_MEM1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPPKTHEADER1_MEM1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CBPPktHeaderCPU
 * BLOCKS:   MMU
 * DESC:     CBP Packet Header CPU RAM
 * SIZE:     38
 * FIELDS:
 *     CPU_OPCODE       Surce Port ID/TGID
 *     MATCHED_RULE     Source Port Number
 *     RESERVED_BITS    Reserved bits
 *     PARITY           parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm 0x0fd44000

#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_MIN 0
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_MAX 12287
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_CMAX(u) 12287
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_SIZE 5

/*
 * This structure should be used to declare and program MMU_CBPPktHeaderCPU.
 *
 */
typedef union BCM56800_A0_MMU_CBPPKTHEADERCPUm_s {
	uint32_t v[2];
	uint32_t mmu_cbppktheadercpu[2];
	uint32_t _mmu_cbppktheadercpu;
} BCM56800_A0_MMU_CBPPKTHEADERCPUm_t;

#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_CLR(r) CDK_MEMSET(&((r)._mmu_cbppktheadercpu), 0, sizeof(BCM56800_A0_MMU_CBPPKTHEADERCPUm_t))
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_SET(r,i,d) (r).mmu_cbppktheadercpu[i] = d
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_GET(r,i) (r).mmu_cbppktheadercpu[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_CPU_OPCODEf_GET(r) (((r).mmu_cbppktheadercpu[0]) & 0x1ffffff)
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_CPU_OPCODEf_SET(r,f) (r).mmu_cbppktheadercpu[0]=(((r).mmu_cbppktheadercpu[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_MATCHED_RULEf_GET(r) cdk_field32_get((r).mmu_cbppktheadercpu,25,35)
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_MATCHED_RULEf_SET(r,f) cdk_field32_set((r).mmu_cbppktheadercpu,25,35,f)
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_RESERVED_BITSf_GET(r) ((((r).mmu_cbppktheadercpu[1]) >> 4) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_RESERVED_BITSf_SET(r,f) (r).mmu_cbppktheadercpu[1]=(((r).mmu_cbppktheadercpu[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_PARITYf_GET(r) ((((r).mmu_cbppktheadercpu[1]) >> 5) & 0x1)
#define BCM56800_A0_MMU_CBPPKTHEADERCPUm_PARITYf_SET(r,f) (r).mmu_cbppktheadercpu[1]=(((r).mmu_cbppktheadercpu[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access MMU_CBPPktHeaderCPU.
 *
 */
#define BCM56800_A0_READ_MMU_CBPPKTHEADERCPUm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CBPPKTHEADERCPUm,i,(m._mmu_cbppktheadercpu),2)
#define BCM56800_A0_WRITE_MMU_CBPPKTHEADERCPUm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CBPPKTHEADERCPUm,i,&(m._mmu_cbppktheadercpu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CBPPKTHEADERCPUm BCM56800_A0_MMU_CBPPKTHEADERCPUm
#define MMU_CBPPKTHEADERCPUm_MIN BCM56800_A0_MMU_CBPPKTHEADERCPUm_MIN
#define MMU_CBPPKTHEADERCPUm_MAX BCM56800_A0_MMU_CBPPKTHEADERCPUm_MAX
#define MMU_CBPPKTHEADERCPUm_CMAX(u) BCM56800_A0_MMU_CBPPKTHEADERCPUm_CMAX(u)
#define MMU_CBPPKTHEADERCPUm_SIZE BCM56800_A0_MMU_CBPPKTHEADERCPUm_SIZE
typedef BCM56800_A0_MMU_CBPPKTHEADERCPUm_t MMU_CBPPKTHEADERCPUm_t;
#define MMU_CBPPKTHEADERCPUm_CLR BCM56800_A0_MMU_CBPPKTHEADERCPUm_CLR
#define MMU_CBPPKTHEADERCPUm_SET BCM56800_A0_MMU_CBPPKTHEADERCPUm_SET
#define MMU_CBPPKTHEADERCPUm_GET BCM56800_A0_MMU_CBPPKTHEADERCPUm_GET
#define MMU_CBPPKTHEADERCPUm_CPU_OPCODEf_GET BCM56800_A0_MMU_CBPPKTHEADERCPUm_CPU_OPCODEf_GET
#define MMU_CBPPKTHEADERCPUm_CPU_OPCODEf_SET BCM56800_A0_MMU_CBPPKTHEADERCPUm_CPU_OPCODEf_SET
#define MMU_CBPPKTHEADERCPUm_MATCHED_RULEf_GET BCM56800_A0_MMU_CBPPKTHEADERCPUm_MATCHED_RULEf_GET
#define MMU_CBPPKTHEADERCPUm_MATCHED_RULEf_SET BCM56800_A0_MMU_CBPPKTHEADERCPUm_MATCHED_RULEf_SET
#define MMU_CBPPKTHEADERCPUm_RESERVED_BITSf_GET BCM56800_A0_MMU_CBPPKTHEADERCPUm_RESERVED_BITSf_GET
#define MMU_CBPPKTHEADERCPUm_RESERVED_BITSf_SET BCM56800_A0_MMU_CBPPKTHEADERCPUm_RESERVED_BITSf_SET
#define MMU_CBPPKTHEADERCPUm_PARITYf_GET BCM56800_A0_MMU_CBPPKTHEADERCPUm_PARITYf_GET
#define MMU_CBPPKTHEADERCPUm_PARITYf_SET BCM56800_A0_MMU_CBPPKTHEADERCPUm_PARITYf_SET
#define READ_MMU_CBPPKTHEADERCPUm BCM56800_A0_READ_MMU_CBPPKTHEADERCPUm
#define WRITE_MMU_CBPPKTHEADERCPUm BCM56800_A0_WRITE_MMU_CBPPKTHEADERCPUm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CBPPKTHEADERCPUm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CCP_MEM
 * BLOCKS:   MMU
 * DESC:     Copy Count Pool RAM
 * SIZE:     15
 * FIELDS:
 *     PTR_0            Packet's copy count
 *     PTR_1            Packet's copy count
 *     ECC              ECC bits for 1-bit error correction
 *     PARITY           Parity bit for 2-bit error detection
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CCP_MEMm 0x08d00000

#define BCM56800_A0_MMU_CCP_MEMm_MIN 0
#define BCM56800_A0_MMU_CCP_MEMm_MAX 6143
#define BCM56800_A0_MMU_CCP_MEMm_CMAX(u) 6143
#define BCM56800_A0_MMU_CCP_MEMm_SIZE 2

/*
 * This structure should be used to declare and program MMU_CCP_MEM.
 *
 */
typedef union BCM56800_A0_MMU_CCP_MEMm_s {
	uint32_t v[1];
	uint32_t mmu_ccp_mem[1];
	uint32_t _mmu_ccp_mem;
} BCM56800_A0_MMU_CCP_MEMm_t;

#define BCM56800_A0_MMU_CCP_MEMm_CLR(r) (r).mmu_ccp_mem[0] = 0
#define BCM56800_A0_MMU_CCP_MEMm_SET(r,d) (r).mmu_ccp_mem[0] = d
#define BCM56800_A0_MMU_CCP_MEMm_GET(r) (r).mmu_ccp_mem[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CCP_MEMm_PTR_0f_GET(r) (((r).mmu_ccp_mem[0]) & 0x1f)
#define BCM56800_A0_MMU_CCP_MEMm_PTR_0f_SET(r,f) (r).mmu_ccp_mem[0]=(((r).mmu_ccp_mem[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_MMU_CCP_MEMm_PTR_1f_GET(r) ((((r).mmu_ccp_mem[0]) >> 5) & 0x1f)
#define BCM56800_A0_MMU_CCP_MEMm_PTR_1f_SET(r,f) (r).mmu_ccp_mem[0]=(((r).mmu_ccp_mem[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM56800_A0_MMU_CCP_MEMm_ECCf_GET(r) ((((r).mmu_ccp_mem[0]) >> 10) & 0xf)
#define BCM56800_A0_MMU_CCP_MEMm_ECCf_SET(r,f) (r).mmu_ccp_mem[0]=(((r).mmu_ccp_mem[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))
#define BCM56800_A0_MMU_CCP_MEMm_PARITYf_GET(r) ((((r).mmu_ccp_mem[0]) >> 14) & 0x1)
#define BCM56800_A0_MMU_CCP_MEMm_PARITYf_SET(r,f) (r).mmu_ccp_mem[0]=(((r).mmu_ccp_mem[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access MMU_CCP_MEM.
 *
 */
#define BCM56800_A0_READ_MMU_CCP_MEMm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CCP_MEMm,i,(m._mmu_ccp_mem),1)
#define BCM56800_A0_WRITE_MMU_CCP_MEMm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CCP_MEMm,i,&(m._mmu_ccp_mem),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CCP_MEMm BCM56800_A0_MMU_CCP_MEMm
#define MMU_CCP_MEMm_MIN BCM56800_A0_MMU_CCP_MEMm_MIN
#define MMU_CCP_MEMm_MAX BCM56800_A0_MMU_CCP_MEMm_MAX
#define MMU_CCP_MEMm_CMAX(u) BCM56800_A0_MMU_CCP_MEMm_CMAX(u)
#define MMU_CCP_MEMm_SIZE BCM56800_A0_MMU_CCP_MEMm_SIZE
typedef BCM56800_A0_MMU_CCP_MEMm_t MMU_CCP_MEMm_t;
#define MMU_CCP_MEMm_CLR BCM56800_A0_MMU_CCP_MEMm_CLR
#define MMU_CCP_MEMm_SET BCM56800_A0_MMU_CCP_MEMm_SET
#define MMU_CCP_MEMm_GET BCM56800_A0_MMU_CCP_MEMm_GET
#define MMU_CCP_MEMm_PTR_0f_GET BCM56800_A0_MMU_CCP_MEMm_PTR_0f_GET
#define MMU_CCP_MEMm_PTR_0f_SET BCM56800_A0_MMU_CCP_MEMm_PTR_0f_SET
#define MMU_CCP_MEMm_PTR_1f_GET BCM56800_A0_MMU_CCP_MEMm_PTR_1f_GET
#define MMU_CCP_MEMm_PTR_1f_SET BCM56800_A0_MMU_CCP_MEMm_PTR_1f_SET
#define MMU_CCP_MEMm_ECCf_GET BCM56800_A0_MMU_CCP_MEMm_ECCf_GET
#define MMU_CCP_MEMm_ECCf_SET BCM56800_A0_MMU_CCP_MEMm_ECCf_SET
#define MMU_CCP_MEMm_PARITYf_GET BCM56800_A0_MMU_CCP_MEMm_PARITYf_GET
#define MMU_CCP_MEMm_PARITYf_SET BCM56800_A0_MMU_CCP_MEMm_PARITYf_SET
#define READ_MMU_CCP_MEMm BCM56800_A0_READ_MMU_CCP_MEMm
#define WRITE_MMU_CCP_MEMm BCM56800_A0_WRITE_MMU_CCP_MEMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CCP_MEMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CELLLINK
 * BLOCKS:   MMU
 * DESC:     CELLLINK
 * SIZE:     20
 * FIELDS:
 *     DATA             data for which ecc is computed
 *     ECC              ECC
 *     PARITY           Parity bit
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CELLLINKm 0x10d7c000

#define BCM56800_A0_MMU_CELLLINKm_MIN 0
#define BCM56800_A0_MMU_CELLLINKm_MAX 12287
#define BCM56800_A0_MMU_CELLLINKm_CMAX(u) 12287
#define BCM56800_A0_MMU_CELLLINKm_SIZE 3

/*
 * This structure should be used to declare and program MMU_CELLLINK.
 *
 */
typedef union BCM56800_A0_MMU_CELLLINKm_s {
	uint32_t v[1];
	uint32_t mmu_celllink[1];
	uint32_t _mmu_celllink;
} BCM56800_A0_MMU_CELLLINKm_t;

#define BCM56800_A0_MMU_CELLLINKm_CLR(r) (r).mmu_celllink[0] = 0
#define BCM56800_A0_MMU_CELLLINKm_SET(r,d) (r).mmu_celllink[0] = d
#define BCM56800_A0_MMU_CELLLINKm_GET(r) (r).mmu_celllink[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CELLLINKm_DATAf_GET(r) (((r).mmu_celllink[0]) & 0x3fff)
#define BCM56800_A0_MMU_CELLLINKm_DATAf_SET(r,f) (r).mmu_celllink[0]=(((r).mmu_celllink[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_CELLLINKm_ECCf_GET(r) ((((r).mmu_celllink[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_CELLLINKm_ECCf_SET(r,f) (r).mmu_celllink[0]=(((r).mmu_celllink[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_CELLLINKm_PARITYf_GET(r) ((((r).mmu_celllink[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_CELLLINKm_PARITYf_SET(r,f) (r).mmu_celllink[0]=(((r).mmu_celllink[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_CELLLINKm_NEXT_PKTf_GET(r) (((r).mmu_celllink[0]) & 0x3fff)
#define BCM56800_A0_MMU_CELLLINKm_NEXT_PKTf_SET(r,f) (r).mmu_celllink[0]=(((r).mmu_celllink[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_CELLLINKm_ECCPf_GET(r) ((((r).mmu_celllink[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_CELLLINKm_ECCPf_SET(r,f) (r).mmu_celllink[0]=(((r).mmu_celllink[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_CELLLINK.
 *
 */
#define BCM56800_A0_READ_MMU_CELLLINKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CELLLINKm,i,(m._mmu_celllink),1)
#define BCM56800_A0_WRITE_MMU_CELLLINKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CELLLINKm,i,&(m._mmu_celllink),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CELLLINKm BCM56800_A0_MMU_CELLLINKm
#define MMU_CELLLINKm_MIN BCM56800_A0_MMU_CELLLINKm_MIN
#define MMU_CELLLINKm_MAX BCM56800_A0_MMU_CELLLINKm_MAX
#define MMU_CELLLINKm_CMAX(u) BCM56800_A0_MMU_CELLLINKm_CMAX(u)
#define MMU_CELLLINKm_SIZE BCM56800_A0_MMU_CELLLINKm_SIZE
typedef BCM56800_A0_MMU_CELLLINKm_t MMU_CELLLINKm_t;
#define MMU_CELLLINKm_CLR BCM56800_A0_MMU_CELLLINKm_CLR
#define MMU_CELLLINKm_SET BCM56800_A0_MMU_CELLLINKm_SET
#define MMU_CELLLINKm_GET BCM56800_A0_MMU_CELLLINKm_GET
#define MMU_CELLLINKm_DATAf_GET BCM56800_A0_MMU_CELLLINKm_DATAf_GET
#define MMU_CELLLINKm_DATAf_SET BCM56800_A0_MMU_CELLLINKm_DATAf_SET
#define MMU_CELLLINKm_ECCf_GET BCM56800_A0_MMU_CELLLINKm_ECCf_GET
#define MMU_CELLLINKm_ECCf_SET BCM56800_A0_MMU_CELLLINKm_ECCf_SET
#define MMU_CELLLINKm_PARITYf_GET BCM56800_A0_MMU_CELLLINKm_PARITYf_GET
#define MMU_CELLLINKm_PARITYf_SET BCM56800_A0_MMU_CELLLINKm_PARITYf_SET
#define MMU_CELLLINKm_NEXT_PKTf_GET BCM56800_A0_MMU_CELLLINKm_NEXT_PKTf_GET
#define MMU_CELLLINKm_NEXT_PKTf_SET BCM56800_A0_MMU_CELLLINKm_NEXT_PKTf_SET
#define MMU_CELLLINKm_ECCPf_GET BCM56800_A0_MMU_CELLLINKm_ECCPf_GET
#define MMU_CELLLINKm_ECCPf_SET BCM56800_A0_MMU_CELLLINKm_ECCPf_SET
#define READ_MMU_CELLLINKm BCM56800_A0_READ_MMU_CELLLINKm
#define WRITE_MMU_CELLLINKm BCM56800_A0_WRITE_MMU_CELLLINKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CELLLINKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CFAP_MEM
 * BLOCKS:   MMU
 * DESC:     CBP Free Address Pool RAM
 * SIZE:     35
 * FIELDS:
 *     PTR_0            CBP Free Address 0
 *     PTR_1            CBP Free Address 1
 *     ECC              ECC bits for 1-bit error correction
 *     PARITY           Parity bit for 2-bit error detection
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CFAP_MEMm 0x07d00000

#define BCM56800_A0_MMU_CFAP_MEMm_MIN 0
#define BCM56800_A0_MMU_CFAP_MEMm_MAX 6143
#define BCM56800_A0_MMU_CFAP_MEMm_CMAX(u) 6143
#define BCM56800_A0_MMU_CFAP_MEMm_SIZE 5

/*
 * This structure should be used to declare and program MMU_CFAP_MEM.
 *
 */
typedef union BCM56800_A0_MMU_CFAP_MEMm_s {
	uint32_t v[2];
	uint32_t mmu_cfap_mem[2];
	uint32_t _mmu_cfap_mem;
} BCM56800_A0_MMU_CFAP_MEMm_t;

#define BCM56800_A0_MMU_CFAP_MEMm_CLR(r) CDK_MEMSET(&((r)._mmu_cfap_mem), 0, sizeof(BCM56800_A0_MMU_CFAP_MEMm_t))
#define BCM56800_A0_MMU_CFAP_MEMm_SET(r,i,d) (r).mmu_cfap_mem[i] = d
#define BCM56800_A0_MMU_CFAP_MEMm_GET(r,i) (r).mmu_cfap_mem[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CFAP_MEMm_PTR_0f_GET(r) (((r).mmu_cfap_mem[0]) & 0x3fff)
#define BCM56800_A0_MMU_CFAP_MEMm_PTR_0f_SET(r,f) (r).mmu_cfap_mem[0]=(((r).mmu_cfap_mem[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_CFAP_MEMm_PTR_1f_GET(r) ((((r).mmu_cfap_mem[0]) >> 14) & 0x3fff)
#define BCM56800_A0_MMU_CFAP_MEMm_PTR_1f_SET(r,f) (r).mmu_cfap_mem[0]=(((r).mmu_cfap_mem[0] & ~((uint32_t)0x3fff << 14)) | ((((uint32_t)f) & 0x3fff) << 14))
#define BCM56800_A0_MMU_CFAP_MEMm_ECCf_GET(r) cdk_field32_get((r).mmu_cfap_mem,28,33)
#define BCM56800_A0_MMU_CFAP_MEMm_ECCf_SET(r,f) cdk_field32_set((r).mmu_cfap_mem,28,33,f)
#define BCM56800_A0_MMU_CFAP_MEMm_PARITYf_GET(r) ((((r).mmu_cfap_mem[1]) >> 2) & 0x1)
#define BCM56800_A0_MMU_CFAP_MEMm_PARITYf_SET(r,f) (r).mmu_cfap_mem[1]=(((r).mmu_cfap_mem[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access MMU_CFAP_MEM.
 *
 */
#define BCM56800_A0_READ_MMU_CFAP_MEMm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CFAP_MEMm,i,(m._mmu_cfap_mem),2)
#define BCM56800_A0_WRITE_MMU_CFAP_MEMm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CFAP_MEMm,i,&(m._mmu_cfap_mem),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CFAP_MEMm BCM56800_A0_MMU_CFAP_MEMm
#define MMU_CFAP_MEMm_MIN BCM56800_A0_MMU_CFAP_MEMm_MIN
#define MMU_CFAP_MEMm_MAX BCM56800_A0_MMU_CFAP_MEMm_MAX
#define MMU_CFAP_MEMm_CMAX(u) BCM56800_A0_MMU_CFAP_MEMm_CMAX(u)
#define MMU_CFAP_MEMm_SIZE BCM56800_A0_MMU_CFAP_MEMm_SIZE
typedef BCM56800_A0_MMU_CFAP_MEMm_t MMU_CFAP_MEMm_t;
#define MMU_CFAP_MEMm_CLR BCM56800_A0_MMU_CFAP_MEMm_CLR
#define MMU_CFAP_MEMm_SET BCM56800_A0_MMU_CFAP_MEMm_SET
#define MMU_CFAP_MEMm_GET BCM56800_A0_MMU_CFAP_MEMm_GET
#define MMU_CFAP_MEMm_PTR_0f_GET BCM56800_A0_MMU_CFAP_MEMm_PTR_0f_GET
#define MMU_CFAP_MEMm_PTR_0f_SET BCM56800_A0_MMU_CFAP_MEMm_PTR_0f_SET
#define MMU_CFAP_MEMm_PTR_1f_GET BCM56800_A0_MMU_CFAP_MEMm_PTR_1f_GET
#define MMU_CFAP_MEMm_PTR_1f_SET BCM56800_A0_MMU_CFAP_MEMm_PTR_1f_SET
#define MMU_CFAP_MEMm_ECCf_GET BCM56800_A0_MMU_CFAP_MEMm_ECCf_GET
#define MMU_CFAP_MEMm_ECCf_SET BCM56800_A0_MMU_CFAP_MEMm_ECCf_SET
#define MMU_CFAP_MEMm_PARITYf_GET BCM56800_A0_MMU_CFAP_MEMm_PARITYf_GET
#define MMU_CFAP_MEMm_PARITYf_SET BCM56800_A0_MMU_CFAP_MEMm_PARITYf_SET
#define READ_MMU_CFAP_MEMm BCM56800_A0_READ_MMU_CFAP_MEMm
#define WRITE_MMU_CFAP_MEMm BCM56800_A0_WRITE_MMU_CFAP_MEMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CFAP_MEMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_CellCHK
 * BLOCKS:   MMU
 * DESC:     Cell CRC Check
 * SIZE:     12
 * FIELDS:
 *     ECC              cell ECC from IP
 *     PARITY           parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_CELLCHKm 0x0fd40000

#define BCM56800_A0_MMU_CELLCHKm_MIN 0
#define BCM56800_A0_MMU_CELLCHKm_MAX 12287
#define BCM56800_A0_MMU_CELLCHKm_CMAX(u) 12287
#define BCM56800_A0_MMU_CELLCHKm_SIZE 2

/*
 * This structure should be used to declare and program MMU_CellCHK.
 *
 */
typedef union BCM56800_A0_MMU_CELLCHKm_s {
	uint32_t v[1];
	uint32_t mmu_cellchk[1];
	uint32_t _mmu_cellchk;
} BCM56800_A0_MMU_CELLCHKm_t;

#define BCM56800_A0_MMU_CELLCHKm_CLR(r) (r).mmu_cellchk[0] = 0
#define BCM56800_A0_MMU_CELLCHKm_SET(r,d) (r).mmu_cellchk[0] = d
#define BCM56800_A0_MMU_CELLCHKm_GET(r) (r).mmu_cellchk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_CELLCHKm_ECCf_GET(r) (((r).mmu_cellchk[0]) & 0x7ff)
#define BCM56800_A0_MMU_CELLCHKm_ECCf_SET(r,f) (r).mmu_cellchk[0]=(((r).mmu_cellchk[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56800_A0_MMU_CELLCHKm_PARITYf_GET(r) ((((r).mmu_cellchk[0]) >> 11) & 0x1)
#define BCM56800_A0_MMU_CELLCHKm_PARITYf_SET(r,f) (r).mmu_cellchk[0]=(((r).mmu_cellchk[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access MMU_CellCHK.
 *
 */
#define BCM56800_A0_READ_MMU_CELLCHKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_CELLCHKm,i,(m._mmu_cellchk),1)
#define BCM56800_A0_WRITE_MMU_CELLCHKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_CELLCHKm,i,&(m._mmu_cellchk),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_CELLCHKm BCM56800_A0_MMU_CELLCHKm
#define MMU_CELLCHKm_MIN BCM56800_A0_MMU_CELLCHKm_MIN
#define MMU_CELLCHKm_MAX BCM56800_A0_MMU_CELLCHKm_MAX
#define MMU_CELLCHKm_CMAX(u) BCM56800_A0_MMU_CELLCHKm_CMAX(u)
#define MMU_CELLCHKm_SIZE BCM56800_A0_MMU_CELLCHKm_SIZE
typedef BCM56800_A0_MMU_CELLCHKm_t MMU_CELLCHKm_t;
#define MMU_CELLCHKm_CLR BCM56800_A0_MMU_CELLCHKm_CLR
#define MMU_CELLCHKm_SET BCM56800_A0_MMU_CELLCHKm_SET
#define MMU_CELLCHKm_GET BCM56800_A0_MMU_CELLCHKm_GET
#define MMU_CELLCHKm_ECCf_GET BCM56800_A0_MMU_CELLCHKm_ECCf_GET
#define MMU_CELLCHKm_ECCf_SET BCM56800_A0_MMU_CELLCHKm_ECCf_SET
#define MMU_CELLCHKm_PARITYf_GET BCM56800_A0_MMU_CELLCHKm_PARITYf_GET
#define MMU_CELLCHKm_PARITYf_SET BCM56800_A0_MMU_CELLCHKm_PARITYf_SET
#define READ_MMU_CELLCHKm BCM56800_A0_READ_MMU_CELLCHKm
#define WRITE_MMU_CELLCHKm BCM56800_A0_WRITE_MMU_CELLCHKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_CELLCHKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL0
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 0
 * SIZE:     62
 * FIELDS:
 *     PORT0_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 0
 *     PORT0_LAST       Last IP copy indication
 *     PORT1_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 1
 *     PORT1_LAST       Last IP copy indication
 *     PORT2_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 2
 *     PORT2_LAST       Last IP copy indication
 *     PORT3_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 3
 *     PORT3_LAST       Last IP copy indication
 *     PORT4_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 4
 *     PORT4_LAST       Last IP copy indication
 *     DATA0            data over which parity0 is computed
 *     DATA1            data over which parity0 is computed
 *     PARITY0          parity for lower 32bits
 *     PARITY1          parity for upper 32bits
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m 0x10d54000

#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_MIN 0
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_MAX 1023
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_CMAX(u) 1023
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_SIZE 8

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL0.
 *
 */
typedef union BCM56800_A0_MMU_IPMC_GROUP_TBL0m_s {
	uint32_t v[2];
	uint32_t mmu_ipmc_group_tbl0[2];
	uint32_t _mmu_ipmc_group_tbl0;
} BCM56800_A0_MMU_IPMC_GROUP_TBL0m_t;

#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_group_tbl0), 0, sizeof(BCM56800_A0_MMU_IPMC_GROUP_TBL0m_t))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_SET(r,i,d) (r).mmu_ipmc_group_tbl0[i] = d
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_GET(r,i) (r).mmu_ipmc_group_tbl0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl0[0]) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl0[0]=(((r).mmu_ipmc_group_tbl0[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT0_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl0[0]) >> 11) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT0_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl0[0]=(((r).mmu_ipmc_group_tbl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl0[0]) >> 12) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl0[0]=(((r).mmu_ipmc_group_tbl0[0] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT1_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl0[0]) >> 23) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT1_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl0[0]=(((r).mmu_ipmc_group_tbl0[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl0,24,34)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl0,24,34,f)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT2_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 3) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT2_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 4) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT3_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 15) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT3_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 16) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT4_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 27) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT4_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_DATA0f_GET(r) ((r).mmu_ipmc_group_tbl0[0])
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_DATA0f_SET(r,f) (r).mmu_ipmc_group_tbl0[0]=((uint32_t)f)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_DATA1f_GET(r) (((r).mmu_ipmc_group_tbl0[1]) & 0xfffffff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_DATA1f_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PARITY0f_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 28) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PARITY0f_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PARITY1f_GET(r) ((((r).mmu_ipmc_group_tbl0[1]) >> 29) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PARITY1f_SET(r,f) (r).mmu_ipmc_group_tbl0[1]=(((r).mmu_ipmc_group_tbl0[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL0.
 *
 */
#define BCM56800_A0_READ_MMU_IPMC_GROUP_TBL0m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_IPMC_GROUP_TBL0m,i,(m._mmu_ipmc_group_tbl0),2)
#define BCM56800_A0_WRITE_MMU_IPMC_GROUP_TBL0m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_IPMC_GROUP_TBL0m,i,&(m._mmu_ipmc_group_tbl0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL0m BCM56800_A0_MMU_IPMC_GROUP_TBL0m
#define MMU_IPMC_GROUP_TBL0m_MIN BCM56800_A0_MMU_IPMC_GROUP_TBL0m_MIN
#define MMU_IPMC_GROUP_TBL0m_MAX BCM56800_A0_MMU_IPMC_GROUP_TBL0m_MAX
#define MMU_IPMC_GROUP_TBL0m_CMAX(u) BCM56800_A0_MMU_IPMC_GROUP_TBL0m_CMAX(u)
#define MMU_IPMC_GROUP_TBL0m_SIZE BCM56800_A0_MMU_IPMC_GROUP_TBL0m_SIZE
typedef BCM56800_A0_MMU_IPMC_GROUP_TBL0m_t MMU_IPMC_GROUP_TBL0m_t;
#define MMU_IPMC_GROUP_TBL0m_CLR BCM56800_A0_MMU_IPMC_GROUP_TBL0m_CLR
#define MMU_IPMC_GROUP_TBL0m_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_SET
#define MMU_IPMC_GROUP_TBL0m_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_GET
#define MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT0_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT0_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT0_LASTf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT0_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT0_LASTf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT1_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT1_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT1_LASTf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT1_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT1_LASTf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT2_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT2_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT2_LASTf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT2_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT2_LASTf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT3_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT3_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT3_LASTf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT3_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT3_LASTf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT4_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL0m_PORT4_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT4_LASTf_GET
#define MMU_IPMC_GROUP_TBL0m_PORT4_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PORT4_LASTf_SET
#define MMU_IPMC_GROUP_TBL0m_DATA0f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_DATA0f_GET
#define MMU_IPMC_GROUP_TBL0m_DATA0f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_DATA0f_SET
#define MMU_IPMC_GROUP_TBL0m_DATA1f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_DATA1f_GET
#define MMU_IPMC_GROUP_TBL0m_DATA1f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_DATA1f_SET
#define MMU_IPMC_GROUP_TBL0m_PARITY0f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PARITY0f_GET
#define MMU_IPMC_GROUP_TBL0m_PARITY0f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PARITY0f_SET
#define MMU_IPMC_GROUP_TBL0m_PARITY1f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PARITY1f_GET
#define MMU_IPMC_GROUP_TBL0m_PARITY1f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL0m_PARITY1f_SET
#define READ_MMU_IPMC_GROUP_TBL0m BCM56800_A0_READ_MMU_IPMC_GROUP_TBL0m
#define WRITE_MMU_IPMC_GROUP_TBL0m BCM56800_A0_WRITE_MMU_IPMC_GROUP_TBL0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_IPMC_GROUP_TBL0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL1
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 1
 * SIZE:     62
 * FIELDS:
 *     PORT5_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 0
 *     PORT5_LAST       Last IP copy indication
 *     PORT6_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 1
 *     PORT6_LAST       Last IP copy indication
 *     PORT7_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 2
 *     PORT7_LAST       Last IP copy indication
 *     PORT8_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 3
 *     PORT8_LAST       Last IP copy indication
 *     PORT9_1STPTR     11 bit first pointer to LSB VLAN Bitmap for Port 4
 *     PORT9_LAST       Last IP copy indication
 *     DATA0            data over which parity0 is computed
 *     DATA1            data over which parity0 is computed
 *     PARITY0          parity for lower 32bits
 *     PARITY1          parity for upper 32bits
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m 0x10d58000

#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_MIN 0
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_MAX 1023
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_CMAX(u) 1023
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_SIZE 8

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL1.
 *
 */
typedef union BCM56800_A0_MMU_IPMC_GROUP_TBL1m_s {
	uint32_t v[2];
	uint32_t mmu_ipmc_group_tbl1[2];
	uint32_t _mmu_ipmc_group_tbl1;
} BCM56800_A0_MMU_IPMC_GROUP_TBL1m_t;

#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_group_tbl1), 0, sizeof(BCM56800_A0_MMU_IPMC_GROUP_TBL1m_t))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_SET(r,i,d) (r).mmu_ipmc_group_tbl1[i] = d
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_GET(r,i) (r).mmu_ipmc_group_tbl1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT5_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl1[0]) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT5_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl1[0]=(((r).mmu_ipmc_group_tbl1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT5_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl1[0]) >> 11) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT5_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl1[0]=(((r).mmu_ipmc_group_tbl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl1[0]) >> 12) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl1[0]=(((r).mmu_ipmc_group_tbl1[0] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT6_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl1[0]) >> 23) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT6_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl1[0]=(((r).mmu_ipmc_group_tbl1[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl1,24,34)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl1,24,34,f)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT7_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 3) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT7_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 4) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT8_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 15) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT8_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 16) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT9_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 27) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT9_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_DATA0f_GET(r) ((r).mmu_ipmc_group_tbl1[0])
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_DATA0f_SET(r,f) (r).mmu_ipmc_group_tbl1[0]=((uint32_t)f)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_DATA1f_GET(r) (((r).mmu_ipmc_group_tbl1[1]) & 0xfffffff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_DATA1f_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PARITY0f_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 28) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PARITY0f_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PARITY1f_GET(r) ((((r).mmu_ipmc_group_tbl1[1]) >> 29) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PARITY1f_SET(r,f) (r).mmu_ipmc_group_tbl1[1]=(((r).mmu_ipmc_group_tbl1[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL1.
 *
 */
#define BCM56800_A0_READ_MMU_IPMC_GROUP_TBL1m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_IPMC_GROUP_TBL1m,i,(m._mmu_ipmc_group_tbl1),2)
#define BCM56800_A0_WRITE_MMU_IPMC_GROUP_TBL1m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_IPMC_GROUP_TBL1m,i,&(m._mmu_ipmc_group_tbl1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL1m BCM56800_A0_MMU_IPMC_GROUP_TBL1m
#define MMU_IPMC_GROUP_TBL1m_MIN BCM56800_A0_MMU_IPMC_GROUP_TBL1m_MIN
#define MMU_IPMC_GROUP_TBL1m_MAX BCM56800_A0_MMU_IPMC_GROUP_TBL1m_MAX
#define MMU_IPMC_GROUP_TBL1m_CMAX(u) BCM56800_A0_MMU_IPMC_GROUP_TBL1m_CMAX(u)
#define MMU_IPMC_GROUP_TBL1m_SIZE BCM56800_A0_MMU_IPMC_GROUP_TBL1m_SIZE
typedef BCM56800_A0_MMU_IPMC_GROUP_TBL1m_t MMU_IPMC_GROUP_TBL1m_t;
#define MMU_IPMC_GROUP_TBL1m_CLR BCM56800_A0_MMU_IPMC_GROUP_TBL1m_CLR
#define MMU_IPMC_GROUP_TBL1m_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_SET
#define MMU_IPMC_GROUP_TBL1m_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_GET
#define MMU_IPMC_GROUP_TBL1m_PORT5_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT5_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT5_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT5_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT5_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT5_LASTf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT5_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT5_LASTf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT6_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT6_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT6_LASTf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT6_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT6_LASTf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT7_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT7_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT7_LASTf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT7_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT7_LASTf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT8_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT8_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT8_LASTf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT8_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT8_LASTf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT9_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL1m_PORT9_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT9_LASTf_GET
#define MMU_IPMC_GROUP_TBL1m_PORT9_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PORT9_LASTf_SET
#define MMU_IPMC_GROUP_TBL1m_DATA0f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_DATA0f_GET
#define MMU_IPMC_GROUP_TBL1m_DATA0f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_DATA0f_SET
#define MMU_IPMC_GROUP_TBL1m_DATA1f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_DATA1f_GET
#define MMU_IPMC_GROUP_TBL1m_DATA1f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_DATA1f_SET
#define MMU_IPMC_GROUP_TBL1m_PARITY0f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PARITY0f_GET
#define MMU_IPMC_GROUP_TBL1m_PARITY0f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PARITY0f_SET
#define MMU_IPMC_GROUP_TBL1m_PARITY1f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PARITY1f_GET
#define MMU_IPMC_GROUP_TBL1m_PARITY1f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL1m_PARITY1f_SET
#define READ_MMU_IPMC_GROUP_TBL1m BCM56800_A0_READ_MMU_IPMC_GROUP_TBL1m
#define WRITE_MMU_IPMC_GROUP_TBL1m BCM56800_A0_WRITE_MMU_IPMC_GROUP_TBL1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_IPMC_GROUP_TBL1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL2
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 2
 * SIZE:     62
 * FIELDS:
 *     PORT10_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 0
 *     PORT10_LAST      Last IP copy indication
 *     PORT11_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 1
 *     PORT11_LAST      Last IP copy indication
 *     PORT12_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 2
 *     PORT12_LAST      Last IP copy indication
 *     PORT13_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 3
 *     PORT13_LAST      Last IP copy indication
 *     PORT14_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 4
 *     PORT14_LAST      Last IP copy indication
 *     DATA0            data over which parity0 is computed
 *     DATA1            data over which parity0 is computed
 *     PARITY0          parity for lower 32bits
 *     PARITY1          parity for upper 32bits
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m 0x10d5c000

#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_MIN 0
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_MAX 1023
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_CMAX(u) 1023
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_SIZE 8

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL2.
 *
 */
typedef union BCM56800_A0_MMU_IPMC_GROUP_TBL2m_s {
	uint32_t v[2];
	uint32_t mmu_ipmc_group_tbl2[2];
	uint32_t _mmu_ipmc_group_tbl2;
} BCM56800_A0_MMU_IPMC_GROUP_TBL2m_t;

#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_group_tbl2), 0, sizeof(BCM56800_A0_MMU_IPMC_GROUP_TBL2m_t))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_SET(r,i,d) (r).mmu_ipmc_group_tbl2[i] = d
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_GET(r,i) (r).mmu_ipmc_group_tbl2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT10_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl2[0]) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT10_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl2[0]=(((r).mmu_ipmc_group_tbl2[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT10_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl2[0]) >> 11) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT10_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl2[0]=(((r).mmu_ipmc_group_tbl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT11_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl2[0]) >> 12) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT11_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl2[0]=(((r).mmu_ipmc_group_tbl2[0] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT11_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl2[0]) >> 23) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT11_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl2[0]=(((r).mmu_ipmc_group_tbl2[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl2,24,34)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl2,24,34,f)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT12_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 3) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT12_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 4) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT13_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 15) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT13_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 16) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT14_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 27) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT14_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_DATA0f_GET(r) ((r).mmu_ipmc_group_tbl2[0])
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_DATA0f_SET(r,f) (r).mmu_ipmc_group_tbl2[0]=((uint32_t)f)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_DATA1f_GET(r) (((r).mmu_ipmc_group_tbl2[1]) & 0xfffffff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_DATA1f_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PARITY0f_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 28) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PARITY0f_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PARITY1f_GET(r) ((((r).mmu_ipmc_group_tbl2[1]) >> 29) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PARITY1f_SET(r,f) (r).mmu_ipmc_group_tbl2[1]=(((r).mmu_ipmc_group_tbl2[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL2.
 *
 */
#define BCM56800_A0_READ_MMU_IPMC_GROUP_TBL2m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_IPMC_GROUP_TBL2m,i,(m._mmu_ipmc_group_tbl2),2)
#define BCM56800_A0_WRITE_MMU_IPMC_GROUP_TBL2m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_IPMC_GROUP_TBL2m,i,&(m._mmu_ipmc_group_tbl2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL2m BCM56800_A0_MMU_IPMC_GROUP_TBL2m
#define MMU_IPMC_GROUP_TBL2m_MIN BCM56800_A0_MMU_IPMC_GROUP_TBL2m_MIN
#define MMU_IPMC_GROUP_TBL2m_MAX BCM56800_A0_MMU_IPMC_GROUP_TBL2m_MAX
#define MMU_IPMC_GROUP_TBL2m_CMAX(u) BCM56800_A0_MMU_IPMC_GROUP_TBL2m_CMAX(u)
#define MMU_IPMC_GROUP_TBL2m_SIZE BCM56800_A0_MMU_IPMC_GROUP_TBL2m_SIZE
typedef BCM56800_A0_MMU_IPMC_GROUP_TBL2m_t MMU_IPMC_GROUP_TBL2m_t;
#define MMU_IPMC_GROUP_TBL2m_CLR BCM56800_A0_MMU_IPMC_GROUP_TBL2m_CLR
#define MMU_IPMC_GROUP_TBL2m_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_SET
#define MMU_IPMC_GROUP_TBL2m_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_GET
#define MMU_IPMC_GROUP_TBL2m_PORT10_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT10_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT10_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT10_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT10_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT10_LASTf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT10_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT10_LASTf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT11_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT11_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT11_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT11_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT11_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT11_LASTf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT11_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT11_LASTf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT12_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT12_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT12_LASTf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT12_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT12_LASTf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT13_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT13_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT13_LASTf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT13_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT13_LASTf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT14_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL2m_PORT14_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT14_LASTf_GET
#define MMU_IPMC_GROUP_TBL2m_PORT14_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PORT14_LASTf_SET
#define MMU_IPMC_GROUP_TBL2m_DATA0f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_DATA0f_GET
#define MMU_IPMC_GROUP_TBL2m_DATA0f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_DATA0f_SET
#define MMU_IPMC_GROUP_TBL2m_DATA1f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_DATA1f_GET
#define MMU_IPMC_GROUP_TBL2m_DATA1f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_DATA1f_SET
#define MMU_IPMC_GROUP_TBL2m_PARITY0f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PARITY0f_GET
#define MMU_IPMC_GROUP_TBL2m_PARITY0f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PARITY0f_SET
#define MMU_IPMC_GROUP_TBL2m_PARITY1f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PARITY1f_GET
#define MMU_IPMC_GROUP_TBL2m_PARITY1f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL2m_PARITY1f_SET
#define READ_MMU_IPMC_GROUP_TBL2m BCM56800_A0_READ_MMU_IPMC_GROUP_TBL2m
#define WRITE_MMU_IPMC_GROUP_TBL2m BCM56800_A0_WRITE_MMU_IPMC_GROUP_TBL2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_IPMC_GROUP_TBL2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_IPMC_GROUP_TBL3
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN Group Table 3
 * SIZE:     62
 * FIELDS:
 *     PORT15_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 0
 *     PORT15_LAST      Last IP copy indication
 *     PORT16_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 1
 *     PORT16_LAST      Last IP copy indication
 *     PORT17_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 2
 *     PORT17_LAST      Last IP copy indication
 *     PORT18_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 3
 *     PORT18_LAST      Last IP copy indication
 *     PORT19_1STPTR    11 bit first pointer to LSB VLAN Bitmap for Port 4
 *     PORT19_LAST      Last IP copy indication
 *     DATA0            data over which parity0 is computed
 *     DATA1            data over which parity0 is computed
 *     PARITY0          parity for lower 32bits
 *     PARITY1          parity for upper 32bits
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m 0x10d60000

#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_MIN 0
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_MAX 1023
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_CMAX(u) 1023
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_SIZE 8

/*
 * This structure should be used to declare and program MMU_IPMC_GROUP_TBL3.
 *
 */
typedef union BCM56800_A0_MMU_IPMC_GROUP_TBL3m_s {
	uint32_t v[2];
	uint32_t mmu_ipmc_group_tbl3[2];
	uint32_t _mmu_ipmc_group_tbl3;
} BCM56800_A0_MMU_IPMC_GROUP_TBL3m_t;

#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_group_tbl3), 0, sizeof(BCM56800_A0_MMU_IPMC_GROUP_TBL3m_t))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_SET(r,i,d) (r).mmu_ipmc_group_tbl3[i] = d
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_GET(r,i) (r).mmu_ipmc_group_tbl3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT15_1STPTRf_GET(r) (((r).mmu_ipmc_group_tbl3[0]) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT15_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl3[0]=(((r).mmu_ipmc_group_tbl3[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT15_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl3[0]) >> 11) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT15_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl3[0]=(((r).mmu_ipmc_group_tbl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT16_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl3[0]) >> 12) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT16_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl3[0]=(((r).mmu_ipmc_group_tbl3[0] & ~((uint32_t)0x7ff << 12)) | ((((uint32_t)f) & 0x7ff) << 12))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT16_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl3[0]) >> 23) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT16_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl3[0]=(((r).mmu_ipmc_group_tbl3[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT17_1STPTRf_GET(r) cdk_field32_get((r).mmu_ipmc_group_tbl3,24,34)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT17_1STPTRf_SET(r,f) cdk_field32_set((r).mmu_ipmc_group_tbl3,24,34,f)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT17_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 3) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT17_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 4) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT18_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 15) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT18_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 16) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x7ff << 16)) | ((((uint32_t)f) & 0x7ff) << 16))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT19_LASTf_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 27) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT19_LASTf_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_DATA0f_GET(r) ((r).mmu_ipmc_group_tbl3[0])
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_DATA0f_SET(r,f) (r).mmu_ipmc_group_tbl3[0]=((uint32_t)f)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_DATA1f_GET(r) (((r).mmu_ipmc_group_tbl3[1]) & 0xfffffff)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_DATA1f_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PARITY0f_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 28) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PARITY0f_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PARITY1f_GET(r) ((((r).mmu_ipmc_group_tbl3[1]) >> 29) & 0x1)
#define BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PARITY1f_SET(r,f) (r).mmu_ipmc_group_tbl3[1]=(((r).mmu_ipmc_group_tbl3[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))

/*
 * These macros can be used to access MMU_IPMC_GROUP_TBL3.
 *
 */
#define BCM56800_A0_READ_MMU_IPMC_GROUP_TBL3m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_IPMC_GROUP_TBL3m,i,(m._mmu_ipmc_group_tbl3),2)
#define BCM56800_A0_WRITE_MMU_IPMC_GROUP_TBL3m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_IPMC_GROUP_TBL3m,i,&(m._mmu_ipmc_group_tbl3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_GROUP_TBL3m BCM56800_A0_MMU_IPMC_GROUP_TBL3m
#define MMU_IPMC_GROUP_TBL3m_MIN BCM56800_A0_MMU_IPMC_GROUP_TBL3m_MIN
#define MMU_IPMC_GROUP_TBL3m_MAX BCM56800_A0_MMU_IPMC_GROUP_TBL3m_MAX
#define MMU_IPMC_GROUP_TBL3m_CMAX(u) BCM56800_A0_MMU_IPMC_GROUP_TBL3m_CMAX(u)
#define MMU_IPMC_GROUP_TBL3m_SIZE BCM56800_A0_MMU_IPMC_GROUP_TBL3m_SIZE
typedef BCM56800_A0_MMU_IPMC_GROUP_TBL3m_t MMU_IPMC_GROUP_TBL3m_t;
#define MMU_IPMC_GROUP_TBL3m_CLR BCM56800_A0_MMU_IPMC_GROUP_TBL3m_CLR
#define MMU_IPMC_GROUP_TBL3m_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_SET
#define MMU_IPMC_GROUP_TBL3m_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_GET
#define MMU_IPMC_GROUP_TBL3m_PORT15_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT15_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT15_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT15_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT15_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT15_LASTf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT15_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT15_LASTf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT16_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT16_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT16_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT16_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT16_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT16_LASTf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT16_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT16_LASTf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT17_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT17_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT17_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT17_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT17_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT17_LASTf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT17_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT17_LASTf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT18_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT18_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT18_LASTf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT18_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT18_LASTf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT19_1STPTRf_SET
#define MMU_IPMC_GROUP_TBL3m_PORT19_LASTf_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT19_LASTf_GET
#define MMU_IPMC_GROUP_TBL3m_PORT19_LASTf_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PORT19_LASTf_SET
#define MMU_IPMC_GROUP_TBL3m_DATA0f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_DATA0f_GET
#define MMU_IPMC_GROUP_TBL3m_DATA0f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_DATA0f_SET
#define MMU_IPMC_GROUP_TBL3m_DATA1f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_DATA1f_GET
#define MMU_IPMC_GROUP_TBL3m_DATA1f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_DATA1f_SET
#define MMU_IPMC_GROUP_TBL3m_PARITY0f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PARITY0f_GET
#define MMU_IPMC_GROUP_TBL3m_PARITY0f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PARITY0f_SET
#define MMU_IPMC_GROUP_TBL3m_PARITY1f_GET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PARITY1f_GET
#define MMU_IPMC_GROUP_TBL3m_PARITY1f_SET BCM56800_A0_MMU_IPMC_GROUP_TBL3m_PARITY1f_SET
#define READ_MMU_IPMC_GROUP_TBL3m BCM56800_A0_READ_MMU_IPMC_GROUP_TBL3m
#define WRITE_MMU_IPMC_GROUP_TBL3m BCM56800_A0_WRITE_MMU_IPMC_GROUP_TBL3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_IPMC_GROUP_TBL3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_IPMC_VLAN_TBL
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN LSB Bitmap Table RAM 0
 * SIZE:     84
 * FIELDS:
 *     PARITY0          parity
 *     LAST             Last Flag
 *     NEXTPTR          11 bits Next VLAN Bitmap Pointer
 *     MSB_VLAN         6 bits MSB for VLAN [11:6]
 *     LSB_VLAN_BM      64 bits of LSB VLAN Bitmap
 *     PARITY1          parity
 *     DATA0            data0 fields
 *     DATA1            data1 fields
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm 0x10d6c000

#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_MIN 0
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_MAX 2047
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_CMAX(u) 2047
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_SIZE 11

/*
 * This structure should be used to declare and program MMU_IPMC_VLAN_TBL.
 *
 */
typedef union BCM56800_A0_MMU_IPMC_VLAN_TBLm_s {
	uint32_t v[3];
	uint32_t mmu_ipmc_vlan_tbl[3];
	uint32_t _mmu_ipmc_vlan_tbl;
} BCM56800_A0_MMU_IPMC_VLAN_TBLm_t;

#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_vlan_tbl), 0, sizeof(BCM56800_A0_MMU_IPMC_VLAN_TBLm_t))
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_SET(r,i,d) (r).mmu_ipmc_vlan_tbl[i] = d
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_GET(r,i) (r).mmu_ipmc_vlan_tbl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_PARITY0f_GET(r) (((r).mmu_ipmc_vlan_tbl[0]) & 0x1)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_PARITY0f_SET(r,f) (r).mmu_ipmc_vlan_tbl[0]=(((r).mmu_ipmc_vlan_tbl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_LASTf_GET(r) ((((r).mmu_ipmc_vlan_tbl[0]) >> 1) & 0x1)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_LASTf_SET(r,f) (r).mmu_ipmc_vlan_tbl[0]=(((r).mmu_ipmc_vlan_tbl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_NEXTPTRf_GET(r) ((((r).mmu_ipmc_vlan_tbl[0]) >> 2) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_NEXTPTRf_SET(r,f) (r).mmu_ipmc_vlan_tbl[0]=(((r).mmu_ipmc_vlan_tbl[0] & ~((uint32_t)0x7ff << 2)) | ((((uint32_t)f) & 0x7ff) << 2))
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_MSB_VLANf_GET(r) ((((r).mmu_ipmc_vlan_tbl[0]) >> 13) & 0x3f)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_MSB_VLANf_SET(r,f) (r).mmu_ipmc_vlan_tbl[0]=(((r).mmu_ipmc_vlan_tbl[0] & ~((uint32_t)0x3f << 13)) | ((((uint32_t)f) & 0x3f) << 13))
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_GET(r,a) cdk_field_get((r).mmu_ipmc_vlan_tbl,19,82,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_SET(r,a) cdk_field_set((r).mmu_ipmc_vlan_tbl,19,82,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_PARITY1f_GET(r) ((((r).mmu_ipmc_vlan_tbl[2]) >> 19) & 0x1)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_PARITY1f_SET(r,f) (r).mmu_ipmc_vlan_tbl[2]=(((r).mmu_ipmc_vlan_tbl[2] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_DATA0f_GET(r,a) cdk_field_get((r).mmu_ipmc_vlan_tbl,1,41,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_DATA0f_SET(r,a) cdk_field_set((r).mmu_ipmc_vlan_tbl,1,41,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_DATA1f_GET(r,a) cdk_field_get((r).mmu_ipmc_vlan_tbl,42,82,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBLm_DATA1f_SET(r,a) cdk_field_set((r).mmu_ipmc_vlan_tbl,42,82,a)

/*
 * These macros can be used to access MMU_IPMC_VLAN_TBL.
 *
 */
#define BCM56800_A0_READ_MMU_IPMC_VLAN_TBLm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_IPMC_VLAN_TBLm,i,(m._mmu_ipmc_vlan_tbl),3)
#define BCM56800_A0_WRITE_MMU_IPMC_VLAN_TBLm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_IPMC_VLAN_TBLm,i,&(m._mmu_ipmc_vlan_tbl),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_VLAN_TBLm BCM56800_A0_MMU_IPMC_VLAN_TBLm
#define MMU_IPMC_VLAN_TBLm_MIN BCM56800_A0_MMU_IPMC_VLAN_TBLm_MIN
#define MMU_IPMC_VLAN_TBLm_MAX BCM56800_A0_MMU_IPMC_VLAN_TBLm_MAX
#define MMU_IPMC_VLAN_TBLm_CMAX(u) BCM56800_A0_MMU_IPMC_VLAN_TBLm_CMAX(u)
#define MMU_IPMC_VLAN_TBLm_SIZE BCM56800_A0_MMU_IPMC_VLAN_TBLm_SIZE
typedef BCM56800_A0_MMU_IPMC_VLAN_TBLm_t MMU_IPMC_VLAN_TBLm_t;
#define MMU_IPMC_VLAN_TBLm_CLR BCM56800_A0_MMU_IPMC_VLAN_TBLm_CLR
#define MMU_IPMC_VLAN_TBLm_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_SET
#define MMU_IPMC_VLAN_TBLm_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_GET
#define MMU_IPMC_VLAN_TBLm_PARITY0f_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_PARITY0f_GET
#define MMU_IPMC_VLAN_TBLm_PARITY0f_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_PARITY0f_SET
#define MMU_IPMC_VLAN_TBLm_LASTf_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_LASTf_GET
#define MMU_IPMC_VLAN_TBLm_LASTf_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_LASTf_SET
#define MMU_IPMC_VLAN_TBLm_NEXTPTRf_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_NEXTPTRf_GET
#define MMU_IPMC_VLAN_TBLm_NEXTPTRf_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_NEXTPTRf_SET
#define MMU_IPMC_VLAN_TBLm_MSB_VLANf_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_MSB_VLANf_GET
#define MMU_IPMC_VLAN_TBLm_MSB_VLANf_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_MSB_VLANf_SET
#define MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_GET
#define MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_LSB_VLAN_BMf_SET
#define MMU_IPMC_VLAN_TBLm_PARITY1f_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_PARITY1f_GET
#define MMU_IPMC_VLAN_TBLm_PARITY1f_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_PARITY1f_SET
#define MMU_IPMC_VLAN_TBLm_DATA0f_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_DATA0f_GET
#define MMU_IPMC_VLAN_TBLm_DATA0f_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_DATA0f_SET
#define MMU_IPMC_VLAN_TBLm_DATA1f_GET BCM56800_A0_MMU_IPMC_VLAN_TBLm_DATA1f_GET
#define MMU_IPMC_VLAN_TBLm_DATA1f_SET BCM56800_A0_MMU_IPMC_VLAN_TBLm_DATA1f_SET
#define READ_MMU_IPMC_VLAN_TBLm BCM56800_A0_READ_MMU_IPMC_VLAN_TBLm
#define WRITE_MMU_IPMC_VLAN_TBLm BCM56800_A0_WRITE_MMU_IPMC_VLAN_TBLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_IPMC_VLAN_TBLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_IPMC_VLAN_TBL_MEM0
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN LSB Bitmap Table RAM 0
 * SIZE:     42
 * FIELDS:
 *     PARITY           parity
 *     LAST             Last Flag
 *     NEXTPTR          11 bits Next VLAN Bitmap Pointer
 *     MSB_VLAN         6 bits MSB for VLAN [11:6]
 *     LSB_VLAN_BM_LOWER lower 23 bits of LSB VLAN Bitmap
 *     DATA             DATA
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m 0x10d64000

#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_MIN 0
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_MAX 2047
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_CMAX(u) 2047
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_SIZE 6

/*
 * This structure should be used to declare and program MMU_IPMC_VLAN_TBL_MEM0.
 *
 */
typedef union BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_s {
	uint32_t v[2];
	uint32_t mmu_ipmc_vlan_tbl_mem0[2];
	uint32_t _mmu_ipmc_vlan_tbl_mem0;
} BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_t;

#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_vlan_tbl_mem0), 0, sizeof(BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_t))
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_SET(r,i,d) (r).mmu_ipmc_vlan_tbl_mem0[i] = d
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_GET(r,i) (r).mmu_ipmc_vlan_tbl_mem0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_PARITYf_GET(r) (((r).mmu_ipmc_vlan_tbl_mem0[0]) & 0x1)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_PARITYf_SET(r,f) (r).mmu_ipmc_vlan_tbl_mem0[0]=(((r).mmu_ipmc_vlan_tbl_mem0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_LASTf_GET(r) ((((r).mmu_ipmc_vlan_tbl_mem0[0]) >> 1) & 0x1)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_LASTf_SET(r,f) (r).mmu_ipmc_vlan_tbl_mem0[0]=(((r).mmu_ipmc_vlan_tbl_mem0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_NEXTPTRf_GET(r) ((((r).mmu_ipmc_vlan_tbl_mem0[0]) >> 2) & 0x7ff)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_NEXTPTRf_SET(r,f) (r).mmu_ipmc_vlan_tbl_mem0[0]=(((r).mmu_ipmc_vlan_tbl_mem0[0] & ~((uint32_t)0x7ff << 2)) | ((((uint32_t)f) & 0x7ff) << 2))
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_MSB_VLANf_GET(r) ((((r).mmu_ipmc_vlan_tbl_mem0[0]) >> 13) & 0x3f)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_MSB_VLANf_SET(r,f) (r).mmu_ipmc_vlan_tbl_mem0[0]=(((r).mmu_ipmc_vlan_tbl_mem0[0] & ~((uint32_t)0x3f << 13)) | ((((uint32_t)f) & 0x3f) << 13))
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_LSB_VLAN_BM_LOWERf_GET(r) cdk_field32_get((r).mmu_ipmc_vlan_tbl_mem0,19,41)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_LSB_VLAN_BM_LOWERf_SET(r,f) cdk_field32_set((r).mmu_ipmc_vlan_tbl_mem0,19,41,f)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_DATAf_GET(r,a) cdk_field_get((r).mmu_ipmc_vlan_tbl_mem0,1,41,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_DATAf_SET(r,a) cdk_field_set((r).mmu_ipmc_vlan_tbl_mem0,1,41,a)

/*
 * These macros can be used to access MMU_IPMC_VLAN_TBL_MEM0.
 *
 */
#define BCM56800_A0_READ_MMU_IPMC_VLAN_TBL_MEM0m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m,i,(m._mmu_ipmc_vlan_tbl_mem0),2)
#define BCM56800_A0_WRITE_MMU_IPMC_VLAN_TBL_MEM0m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m,i,&(m._mmu_ipmc_vlan_tbl_mem0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_VLAN_TBL_MEM0m BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m
#define MMU_IPMC_VLAN_TBL_MEM0m_MIN BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_MIN
#define MMU_IPMC_VLAN_TBL_MEM0m_MAX BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_MAX
#define MMU_IPMC_VLAN_TBL_MEM0m_CMAX(u) BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_CMAX(u)
#define MMU_IPMC_VLAN_TBL_MEM0m_SIZE BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_SIZE
typedef BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_t MMU_IPMC_VLAN_TBL_MEM0m_t;
#define MMU_IPMC_VLAN_TBL_MEM0m_CLR BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_CLR
#define MMU_IPMC_VLAN_TBL_MEM0m_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_SET
#define MMU_IPMC_VLAN_TBL_MEM0m_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_GET
#define MMU_IPMC_VLAN_TBL_MEM0m_PARITYf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_PARITYf_GET
#define MMU_IPMC_VLAN_TBL_MEM0m_PARITYf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_PARITYf_SET
#define MMU_IPMC_VLAN_TBL_MEM0m_LASTf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_LASTf_GET
#define MMU_IPMC_VLAN_TBL_MEM0m_LASTf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_LASTf_SET
#define MMU_IPMC_VLAN_TBL_MEM0m_NEXTPTRf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_NEXTPTRf_GET
#define MMU_IPMC_VLAN_TBL_MEM0m_NEXTPTRf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_NEXTPTRf_SET
#define MMU_IPMC_VLAN_TBL_MEM0m_MSB_VLANf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_MSB_VLANf_GET
#define MMU_IPMC_VLAN_TBL_MEM0m_MSB_VLANf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_MSB_VLANf_SET
#define MMU_IPMC_VLAN_TBL_MEM0m_LSB_VLAN_BM_LOWERf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_LSB_VLAN_BM_LOWERf_GET
#define MMU_IPMC_VLAN_TBL_MEM0m_LSB_VLAN_BM_LOWERf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_LSB_VLAN_BM_LOWERf_SET
#define MMU_IPMC_VLAN_TBL_MEM0m_DATAf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_DATAf_GET
#define MMU_IPMC_VLAN_TBL_MEM0m_DATAf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m_DATAf_SET
#define READ_MMU_IPMC_VLAN_TBL_MEM0m BCM56800_A0_READ_MMU_IPMC_VLAN_TBL_MEM0m
#define WRITE_MMU_IPMC_VLAN_TBL_MEM0m BCM56800_A0_WRITE_MMU_IPMC_VLAN_TBL_MEM0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_IPMC_VLAN_TBL_MEM1
 * BLOCKS:   MMU
 * DESC:     IPMC VLAN LSB Bitmap Table RAM 0
 * SIZE:     42
 * FIELDS:
 *     DATA             data
 *     PARITY           parity
 *     LSB_VLAN_BM_UPPER upper 41 bits of LSB VLAN Bitmap
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m 0x10d68000

#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_MIN 0
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_MAX 2047
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_CMAX(u) 2047
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_SIZE 6

/*
 * This structure should be used to declare and program MMU_IPMC_VLAN_TBL_MEM1.
 *
 */
typedef union BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_s {
	uint32_t v[2];
	uint32_t mmu_ipmc_vlan_tbl_mem1[2];
	uint32_t _mmu_ipmc_vlan_tbl_mem1;
} BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_t;

#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_CLR(r) CDK_MEMSET(&((r)._mmu_ipmc_vlan_tbl_mem1), 0, sizeof(BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_t))
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_SET(r,i,d) (r).mmu_ipmc_vlan_tbl_mem1[i] = d
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_GET(r,i) (r).mmu_ipmc_vlan_tbl_mem1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_DATAf_GET(r,a) cdk_field_get((r).mmu_ipmc_vlan_tbl_mem1,0,40,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_DATAf_SET(r,a) cdk_field_set((r).mmu_ipmc_vlan_tbl_mem1,0,40,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_PARITYf_GET(r) ((((r).mmu_ipmc_vlan_tbl_mem1[1]) >> 9) & 0x1)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_PARITYf_SET(r,f) (r).mmu_ipmc_vlan_tbl_mem1[1]=(((r).mmu_ipmc_vlan_tbl_mem1[1] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_LSB_VLAN_BM_UPPERf_GET(r,a) cdk_field_get((r).mmu_ipmc_vlan_tbl_mem1,0,40,a)
#define BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_LSB_VLAN_BM_UPPERf_SET(r,a) cdk_field_set((r).mmu_ipmc_vlan_tbl_mem1,0,40,a)

/*
 * These macros can be used to access MMU_IPMC_VLAN_TBL_MEM1.
 *
 */
#define BCM56800_A0_READ_MMU_IPMC_VLAN_TBL_MEM1m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m,i,(m._mmu_ipmc_vlan_tbl_mem1),2)
#define BCM56800_A0_WRITE_MMU_IPMC_VLAN_TBL_MEM1m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m,i,&(m._mmu_ipmc_vlan_tbl_mem1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_IPMC_VLAN_TBL_MEM1m BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m
#define MMU_IPMC_VLAN_TBL_MEM1m_MIN BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_MIN
#define MMU_IPMC_VLAN_TBL_MEM1m_MAX BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_MAX
#define MMU_IPMC_VLAN_TBL_MEM1m_CMAX(u) BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_CMAX(u)
#define MMU_IPMC_VLAN_TBL_MEM1m_SIZE BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_SIZE
typedef BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_t MMU_IPMC_VLAN_TBL_MEM1m_t;
#define MMU_IPMC_VLAN_TBL_MEM1m_CLR BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_CLR
#define MMU_IPMC_VLAN_TBL_MEM1m_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_SET
#define MMU_IPMC_VLAN_TBL_MEM1m_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_GET
#define MMU_IPMC_VLAN_TBL_MEM1m_DATAf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_DATAf_GET
#define MMU_IPMC_VLAN_TBL_MEM1m_DATAf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_DATAf_SET
#define MMU_IPMC_VLAN_TBL_MEM1m_PARITYf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_PARITYf_GET
#define MMU_IPMC_VLAN_TBL_MEM1m_PARITYf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_PARITYf_SET
#define MMU_IPMC_VLAN_TBL_MEM1m_LSB_VLAN_BM_UPPERf_GET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_LSB_VLAN_BM_UPPERf_GET
#define MMU_IPMC_VLAN_TBL_MEM1m_LSB_VLAN_BM_UPPERf_SET BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m_LSB_VLAN_BM_UPPERf_SET
#define READ_MMU_IPMC_VLAN_TBL_MEM1m BCM56800_A0_READ_MMU_IPMC_VLAN_TBL_MEM1m
#define WRITE_MMU_IPMC_VLAN_TBL_MEM1m BCM56800_A0_WRITE_MMU_IPMC_VLAN_TBL_MEM1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_IPMC_VLAN_TBL_MEM1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MMU_LLFC_RX_CONFIG
 * BLOCKS:   MMU
 * DESC:     MMU LLFC Recieve Configuration
 * SIZE:     32
 * FIELDS:
 *     XOFF_TIMEOUT_VALUE If there is no BKP update after the last one, INTF will wait this longand reset the XOFF statuses to XON.  The time is indicated by thisnumber multplied by 250 ns.
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_LLFC_RX_CONFIGr 0x0bd0000f

#define BCM56800_A0_MMU_LLFC_RX_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MMU_LLFC_RX_CONFIG.
 *
 */
typedef union BCM56800_A0_MMU_LLFC_RX_CONFIGr_s {
	uint32_t v[1];
	uint32_t mmu_llfc_rx_config[1];
	uint32_t _mmu_llfc_rx_config;
} BCM56800_A0_MMU_LLFC_RX_CONFIGr_t;

#define BCM56800_A0_MMU_LLFC_RX_CONFIGr_CLR(r) (r).mmu_llfc_rx_config[0] = 0
#define BCM56800_A0_MMU_LLFC_RX_CONFIGr_SET(r,d) (r).mmu_llfc_rx_config[0] = d
#define BCM56800_A0_MMU_LLFC_RX_CONFIGr_GET(r) (r).mmu_llfc_rx_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_LLFC_RX_CONFIGr_XOFF_TIMEOUT_VALUEf_GET(r) (((r).mmu_llfc_rx_config[0]) & 0xffff)
#define BCM56800_A0_MMU_LLFC_RX_CONFIGr_XOFF_TIMEOUT_VALUEf_SET(r,f) (r).mmu_llfc_rx_config[0]=(((r).mmu_llfc_rx_config[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MMU_LLFC_RX_CONFIG.
 *
 */
#define BCM56800_A0_READ_MMU_LLFC_RX_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MMU_LLFC_RX_CONFIGr,(r._mmu_llfc_rx_config))
#define BCM56800_A0_WRITE_MMU_LLFC_RX_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MMU_LLFC_RX_CONFIGr,&(r._mmu_llfc_rx_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_LLFC_RX_CONFIGr BCM56800_A0_MMU_LLFC_RX_CONFIGr
#define MMU_LLFC_RX_CONFIGr_SIZE BCM56800_A0_MMU_LLFC_RX_CONFIGr_SIZE
typedef BCM56800_A0_MMU_LLFC_RX_CONFIGr_t MMU_LLFC_RX_CONFIGr_t;
#define MMU_LLFC_RX_CONFIGr_CLR BCM56800_A0_MMU_LLFC_RX_CONFIGr_CLR
#define MMU_LLFC_RX_CONFIGr_SET BCM56800_A0_MMU_LLFC_RX_CONFIGr_SET
#define MMU_LLFC_RX_CONFIGr_GET BCM56800_A0_MMU_LLFC_RX_CONFIGr_GET
#define MMU_LLFC_RX_CONFIGr_XOFF_TIMEOUT_VALUEf_GET BCM56800_A0_MMU_LLFC_RX_CONFIGr_XOFF_TIMEOUT_VALUEf_GET
#define MMU_LLFC_RX_CONFIGr_XOFF_TIMEOUT_VALUEf_SET BCM56800_A0_MMU_LLFC_RX_CONFIGr_XOFF_TIMEOUT_VALUEf_SET
#define READ_MMU_LLFC_RX_CONFIGr BCM56800_A0_READ_MMU_LLFC_RX_CONFIGr
#define WRITE_MMU_LLFC_RX_CONFIGr BCM56800_A0_WRITE_MMU_LLFC_RX_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_LLFC_RX_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MMU_LLFC_TX_CONFIG_1
 * BLOCKS:   MMU
 * DESC:     LLC Configuration register 1
 * SIZE:     32
 * FIELDS:
 *     BW_TIMER_VALUE   This limits the XON message bandwidth by sending XON (after XOFF)message after a specified time only.  The unit is in multiplesof 250 nano-sceonds.
 *     MTRI_PRI_BKP     Priority bitmap when per-port metering triggers flow control
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r 0x0bd80006

#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_SIZE 4

/*
 * This structure should be used to declare and program MMU_LLFC_TX_CONFIG_1.
 *
 */
typedef union BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_s {
	uint32_t v[1];
	uint32_t mmu_llfc_tx_config_1[1];
	uint32_t _mmu_llfc_tx_config_1;
} BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_t;

#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_CLR(r) (r).mmu_llfc_tx_config_1[0] = 0
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_SET(r,d) (r).mmu_llfc_tx_config_1[0] = d
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_GET(r) (r).mmu_llfc_tx_config_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_BW_TIMER_VALUEf_GET(r) (((r).mmu_llfc_tx_config_1[0]) & 0xfff)
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_BW_TIMER_VALUEf_SET(r,f) (r).mmu_llfc_tx_config_1[0]=(((r).mmu_llfc_tx_config_1[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_MTRI_PRI_BKPf_GET(r) ((((r).mmu_llfc_tx_config_1[0]) >> 12) & 0xffff)
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_MTRI_PRI_BKPf_SET(r,f) (r).mmu_llfc_tx_config_1[0]=(((r).mmu_llfc_tx_config_1[0] & ~((uint32_t)0xffff << 12)) | ((((uint32_t)f) & 0xffff) << 12))

/*
 * These macros can be used to access MMU_LLFC_TX_CONFIG_1.
 *
 */
#define BCM56800_A0_READ_MMU_LLFC_TX_CONFIG_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MMU_LLFC_TX_CONFIG_1r,(r._mmu_llfc_tx_config_1))
#define BCM56800_A0_WRITE_MMU_LLFC_TX_CONFIG_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MMU_LLFC_TX_CONFIG_1r,&(r._mmu_llfc_tx_config_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_LLFC_TX_CONFIG_1r BCM56800_A0_MMU_LLFC_TX_CONFIG_1r
#define MMU_LLFC_TX_CONFIG_1r_SIZE BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_SIZE
typedef BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_t MMU_LLFC_TX_CONFIG_1r_t;
#define MMU_LLFC_TX_CONFIG_1r_CLR BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_CLR
#define MMU_LLFC_TX_CONFIG_1r_SET BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_SET
#define MMU_LLFC_TX_CONFIG_1r_GET BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_GET
#define MMU_LLFC_TX_CONFIG_1r_BW_TIMER_VALUEf_GET BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_BW_TIMER_VALUEf_GET
#define MMU_LLFC_TX_CONFIG_1r_BW_TIMER_VALUEf_SET BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_BW_TIMER_VALUEf_SET
#define MMU_LLFC_TX_CONFIG_1r_MTRI_PRI_BKPf_GET BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_MTRI_PRI_BKPf_GET
#define MMU_LLFC_TX_CONFIG_1r_MTRI_PRI_BKPf_SET BCM56800_A0_MMU_LLFC_TX_CONFIG_1r_MTRI_PRI_BKPf_SET
#define READ_MMU_LLFC_TX_CONFIG_1r BCM56800_A0_READ_MMU_LLFC_TX_CONFIG_1r
#define WRITE_MMU_LLFC_TX_CONFIG_1r BCM56800_A0_WRITE_MMU_LLFC_TX_CONFIG_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_LLFC_TX_CONFIG_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MMU_LLFC_TX_CONFIG_2
 * BLOCKS:   MMU
 * DESC:     LLC Configuration register 2
 * SIZE:     32
 * FIELDS:
 *     XOFF_REFRESH_TIME This limits the XOFF message frequency by sending XOFFmessage after a specified time only.  The unit is in multiplesof 250 nano-sceonds.
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_2r 0x0bd80007

#define BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_SIZE 4

/*
 * This structure should be used to declare and program MMU_LLFC_TX_CONFIG_2.
 *
 */
typedef union BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_s {
	uint32_t v[1];
	uint32_t mmu_llfc_tx_config_2[1];
	uint32_t _mmu_llfc_tx_config_2;
} BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_t;

#define BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_CLR(r) (r).mmu_llfc_tx_config_2[0] = 0
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_SET(r,d) (r).mmu_llfc_tx_config_2[0] = d
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_GET(r) (r).mmu_llfc_tx_config_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_XOFF_REFRESH_TIMEf_GET(r) (((r).mmu_llfc_tx_config_2[0]) & 0xffff)
#define BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_XOFF_REFRESH_TIMEf_SET(r,f) (r).mmu_llfc_tx_config_2[0]=(((r).mmu_llfc_tx_config_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MMU_LLFC_TX_CONFIG_2.
 *
 */
#define BCM56800_A0_READ_MMU_LLFC_TX_CONFIG_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MMU_LLFC_TX_CONFIG_2r,(r._mmu_llfc_tx_config_2))
#define BCM56800_A0_WRITE_MMU_LLFC_TX_CONFIG_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MMU_LLFC_TX_CONFIG_2r,&(r._mmu_llfc_tx_config_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_LLFC_TX_CONFIG_2r BCM56800_A0_MMU_LLFC_TX_CONFIG_2r
#define MMU_LLFC_TX_CONFIG_2r_SIZE BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_SIZE
typedef BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_t MMU_LLFC_TX_CONFIG_2r_t;
#define MMU_LLFC_TX_CONFIG_2r_CLR BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_CLR
#define MMU_LLFC_TX_CONFIG_2r_SET BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_SET
#define MMU_LLFC_TX_CONFIG_2r_GET BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_GET
#define MMU_LLFC_TX_CONFIG_2r_XOFF_REFRESH_TIMEf_GET BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_XOFF_REFRESH_TIMEf_GET
#define MMU_LLFC_TX_CONFIG_2r_XOFF_REFRESH_TIMEf_SET BCM56800_A0_MMU_LLFC_TX_CONFIG_2r_XOFF_REFRESH_TIMEf_SET
#define READ_MMU_LLFC_TX_CONFIG_2r BCM56800_A0_READ_MMU_LLFC_TX_CONFIG_2r
#define WRITE_MMU_LLFC_TX_CONFIG_2r BCM56800_A0_WRITE_MMU_LLFC_TX_CONFIG_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_LLFC_TX_CONFIG_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK0
 * BLOCKS:   MMU
 * DESC:     PKTLINK0
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             ECC Parity
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK0m 0x10d00000

#define BCM56800_A0_MMU_PKTLINK0m_MIN 0
#define BCM56800_A0_MMU_PKTLINK0m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK0m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK0m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK0.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK0m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink0[1];
	uint32_t _mmu_pktlink0;
} BCM56800_A0_MMU_PKTLINK0m_t;

#define BCM56800_A0_MMU_PKTLINK0m_CLR(r) (r).mmu_pktlink0[0] = 0
#define BCM56800_A0_MMU_PKTLINK0m_SET(r,d) (r).mmu_pktlink0[0] = d
#define BCM56800_A0_MMU_PKTLINK0m_GET(r) (r).mmu_pktlink0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK0m_NEXT_PKTf_GET(r) (((r).mmu_pktlink0[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK0m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink0[0]=(((r).mmu_pktlink0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK0m_ECCf_GET(r) ((((r).mmu_pktlink0[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK0m_ECCf_SET(r,f) (r).mmu_pktlink0[0]=(((r).mmu_pktlink0[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK0m_PARITYf_GET(r) ((((r).mmu_pktlink0[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK0m_PARITYf_SET(r,f) (r).mmu_pktlink0[0]=(((r).mmu_pktlink0[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK0m_ECCPf_GET(r) ((((r).mmu_pktlink0[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK0m_ECCPf_SET(r,f) (r).mmu_pktlink0[0]=(((r).mmu_pktlink0[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK0.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK0m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK0m,i,(m._mmu_pktlink0),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK0m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK0m,i,&(m._mmu_pktlink0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK0m BCM56800_A0_MMU_PKTLINK0m
#define MMU_PKTLINK0m_MIN BCM56800_A0_MMU_PKTLINK0m_MIN
#define MMU_PKTLINK0m_MAX BCM56800_A0_MMU_PKTLINK0m_MAX
#define MMU_PKTLINK0m_CMAX(u) BCM56800_A0_MMU_PKTLINK0m_CMAX(u)
#define MMU_PKTLINK0m_SIZE BCM56800_A0_MMU_PKTLINK0m_SIZE
typedef BCM56800_A0_MMU_PKTLINK0m_t MMU_PKTLINK0m_t;
#define MMU_PKTLINK0m_CLR BCM56800_A0_MMU_PKTLINK0m_CLR
#define MMU_PKTLINK0m_SET BCM56800_A0_MMU_PKTLINK0m_SET
#define MMU_PKTLINK0m_GET BCM56800_A0_MMU_PKTLINK0m_GET
#define MMU_PKTLINK0m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK0m_NEXT_PKTf_GET
#define MMU_PKTLINK0m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK0m_NEXT_PKTf_SET
#define MMU_PKTLINK0m_ECCf_GET BCM56800_A0_MMU_PKTLINK0m_ECCf_GET
#define MMU_PKTLINK0m_ECCf_SET BCM56800_A0_MMU_PKTLINK0m_ECCf_SET
#define MMU_PKTLINK0m_PARITYf_GET BCM56800_A0_MMU_PKTLINK0m_PARITYf_GET
#define MMU_PKTLINK0m_PARITYf_SET BCM56800_A0_MMU_PKTLINK0m_PARITYf_SET
#define MMU_PKTLINK0m_ECCPf_GET BCM56800_A0_MMU_PKTLINK0m_ECCPf_GET
#define MMU_PKTLINK0m_ECCPf_SET BCM56800_A0_MMU_PKTLINK0m_ECCPf_SET
#define READ_MMU_PKTLINK0m BCM56800_A0_READ_MMU_PKTLINK0m
#define WRITE_MMU_PKTLINK0m BCM56800_A0_WRITE_MMU_PKTLINK0m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK0m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK1
 * BLOCKS:   MMU
 * DESC:     PKTLINK1
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK1m 0x10d04000

#define BCM56800_A0_MMU_PKTLINK1m_MIN 0
#define BCM56800_A0_MMU_PKTLINK1m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK1m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK1m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK1.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK1m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink1[1];
	uint32_t _mmu_pktlink1;
} BCM56800_A0_MMU_PKTLINK1m_t;

#define BCM56800_A0_MMU_PKTLINK1m_CLR(r) (r).mmu_pktlink1[0] = 0
#define BCM56800_A0_MMU_PKTLINK1m_SET(r,d) (r).mmu_pktlink1[0] = d
#define BCM56800_A0_MMU_PKTLINK1m_GET(r) (r).mmu_pktlink1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK1m_NEXT_PKTf_GET(r) (((r).mmu_pktlink1[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK1m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink1[0]=(((r).mmu_pktlink1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK1m_ECCf_GET(r) ((((r).mmu_pktlink1[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK1m_ECCf_SET(r,f) (r).mmu_pktlink1[0]=(((r).mmu_pktlink1[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK1m_PARITYf_GET(r) ((((r).mmu_pktlink1[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK1m_PARITYf_SET(r,f) (r).mmu_pktlink1[0]=(((r).mmu_pktlink1[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK1m_ECCPf_GET(r) ((((r).mmu_pktlink1[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK1m_ECCPf_SET(r,f) (r).mmu_pktlink1[0]=(((r).mmu_pktlink1[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK1.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK1m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK1m,i,(m._mmu_pktlink1),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK1m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK1m,i,&(m._mmu_pktlink1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK1m BCM56800_A0_MMU_PKTLINK1m
#define MMU_PKTLINK1m_MIN BCM56800_A0_MMU_PKTLINK1m_MIN
#define MMU_PKTLINK1m_MAX BCM56800_A0_MMU_PKTLINK1m_MAX
#define MMU_PKTLINK1m_CMAX(u) BCM56800_A0_MMU_PKTLINK1m_CMAX(u)
#define MMU_PKTLINK1m_SIZE BCM56800_A0_MMU_PKTLINK1m_SIZE
typedef BCM56800_A0_MMU_PKTLINK1m_t MMU_PKTLINK1m_t;
#define MMU_PKTLINK1m_CLR BCM56800_A0_MMU_PKTLINK1m_CLR
#define MMU_PKTLINK1m_SET BCM56800_A0_MMU_PKTLINK1m_SET
#define MMU_PKTLINK1m_GET BCM56800_A0_MMU_PKTLINK1m_GET
#define MMU_PKTLINK1m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK1m_NEXT_PKTf_GET
#define MMU_PKTLINK1m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK1m_NEXT_PKTf_SET
#define MMU_PKTLINK1m_ECCf_GET BCM56800_A0_MMU_PKTLINK1m_ECCf_GET
#define MMU_PKTLINK1m_ECCf_SET BCM56800_A0_MMU_PKTLINK1m_ECCf_SET
#define MMU_PKTLINK1m_PARITYf_GET BCM56800_A0_MMU_PKTLINK1m_PARITYf_GET
#define MMU_PKTLINK1m_PARITYf_SET BCM56800_A0_MMU_PKTLINK1m_PARITYf_SET
#define MMU_PKTLINK1m_ECCPf_GET BCM56800_A0_MMU_PKTLINK1m_ECCPf_GET
#define MMU_PKTLINK1m_ECCPf_SET BCM56800_A0_MMU_PKTLINK1m_ECCPf_SET
#define READ_MMU_PKTLINK1m BCM56800_A0_READ_MMU_PKTLINK1m
#define WRITE_MMU_PKTLINK1m BCM56800_A0_WRITE_MMU_PKTLINK1m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK1m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK10
 * BLOCKS:   MMU
 * DESC:     PKTLINK10
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK10m 0x10d28000

#define BCM56800_A0_MMU_PKTLINK10m_MIN 0
#define BCM56800_A0_MMU_PKTLINK10m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK10m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK10m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK10.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK10m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink10[1];
	uint32_t _mmu_pktlink10;
} BCM56800_A0_MMU_PKTLINK10m_t;

#define BCM56800_A0_MMU_PKTLINK10m_CLR(r) (r).mmu_pktlink10[0] = 0
#define BCM56800_A0_MMU_PKTLINK10m_SET(r,d) (r).mmu_pktlink10[0] = d
#define BCM56800_A0_MMU_PKTLINK10m_GET(r) (r).mmu_pktlink10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK10m_NEXT_PKTf_GET(r) (((r).mmu_pktlink10[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK10m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink10[0]=(((r).mmu_pktlink10[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK10m_ECCf_GET(r) ((((r).mmu_pktlink10[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK10m_ECCf_SET(r,f) (r).mmu_pktlink10[0]=(((r).mmu_pktlink10[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK10m_PARITYf_GET(r) ((((r).mmu_pktlink10[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK10m_PARITYf_SET(r,f) (r).mmu_pktlink10[0]=(((r).mmu_pktlink10[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK10m_ECCPf_GET(r) ((((r).mmu_pktlink10[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK10m_ECCPf_SET(r,f) (r).mmu_pktlink10[0]=(((r).mmu_pktlink10[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK10.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK10m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK10m,i,(m._mmu_pktlink10),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK10m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK10m,i,&(m._mmu_pktlink10),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK10m BCM56800_A0_MMU_PKTLINK10m
#define MMU_PKTLINK10m_MIN BCM56800_A0_MMU_PKTLINK10m_MIN
#define MMU_PKTLINK10m_MAX BCM56800_A0_MMU_PKTLINK10m_MAX
#define MMU_PKTLINK10m_CMAX(u) BCM56800_A0_MMU_PKTLINK10m_CMAX(u)
#define MMU_PKTLINK10m_SIZE BCM56800_A0_MMU_PKTLINK10m_SIZE
typedef BCM56800_A0_MMU_PKTLINK10m_t MMU_PKTLINK10m_t;
#define MMU_PKTLINK10m_CLR BCM56800_A0_MMU_PKTLINK10m_CLR
#define MMU_PKTLINK10m_SET BCM56800_A0_MMU_PKTLINK10m_SET
#define MMU_PKTLINK10m_GET BCM56800_A0_MMU_PKTLINK10m_GET
#define MMU_PKTLINK10m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK10m_NEXT_PKTf_GET
#define MMU_PKTLINK10m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK10m_NEXT_PKTf_SET
#define MMU_PKTLINK10m_ECCf_GET BCM56800_A0_MMU_PKTLINK10m_ECCf_GET
#define MMU_PKTLINK10m_ECCf_SET BCM56800_A0_MMU_PKTLINK10m_ECCf_SET
#define MMU_PKTLINK10m_PARITYf_GET BCM56800_A0_MMU_PKTLINK10m_PARITYf_GET
#define MMU_PKTLINK10m_PARITYf_SET BCM56800_A0_MMU_PKTLINK10m_PARITYf_SET
#define MMU_PKTLINK10m_ECCPf_GET BCM56800_A0_MMU_PKTLINK10m_ECCPf_GET
#define MMU_PKTLINK10m_ECCPf_SET BCM56800_A0_MMU_PKTLINK10m_ECCPf_SET
#define READ_MMU_PKTLINK10m BCM56800_A0_READ_MMU_PKTLINK10m
#define WRITE_MMU_PKTLINK10m BCM56800_A0_WRITE_MMU_PKTLINK10m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK10m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK11
 * BLOCKS:   MMU
 * DESC:     PKTLINK11
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK11m 0x10d2c000

#define BCM56800_A0_MMU_PKTLINK11m_MIN 0
#define BCM56800_A0_MMU_PKTLINK11m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK11m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK11m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK11.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK11m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink11[1];
	uint32_t _mmu_pktlink11;
} BCM56800_A0_MMU_PKTLINK11m_t;

#define BCM56800_A0_MMU_PKTLINK11m_CLR(r) (r).mmu_pktlink11[0] = 0
#define BCM56800_A0_MMU_PKTLINK11m_SET(r,d) (r).mmu_pktlink11[0] = d
#define BCM56800_A0_MMU_PKTLINK11m_GET(r) (r).mmu_pktlink11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK11m_NEXT_PKTf_GET(r) (((r).mmu_pktlink11[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK11m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink11[0]=(((r).mmu_pktlink11[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK11m_ECCf_GET(r) ((((r).mmu_pktlink11[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK11m_ECCf_SET(r,f) (r).mmu_pktlink11[0]=(((r).mmu_pktlink11[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK11m_PARITYf_GET(r) ((((r).mmu_pktlink11[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK11m_PARITYf_SET(r,f) (r).mmu_pktlink11[0]=(((r).mmu_pktlink11[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK11m_ECCPf_GET(r) ((((r).mmu_pktlink11[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK11m_ECCPf_SET(r,f) (r).mmu_pktlink11[0]=(((r).mmu_pktlink11[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK11.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK11m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK11m,i,(m._mmu_pktlink11),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK11m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK11m,i,&(m._mmu_pktlink11),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK11m BCM56800_A0_MMU_PKTLINK11m
#define MMU_PKTLINK11m_MIN BCM56800_A0_MMU_PKTLINK11m_MIN
#define MMU_PKTLINK11m_MAX BCM56800_A0_MMU_PKTLINK11m_MAX
#define MMU_PKTLINK11m_CMAX(u) BCM56800_A0_MMU_PKTLINK11m_CMAX(u)
#define MMU_PKTLINK11m_SIZE BCM56800_A0_MMU_PKTLINK11m_SIZE
typedef BCM56800_A0_MMU_PKTLINK11m_t MMU_PKTLINK11m_t;
#define MMU_PKTLINK11m_CLR BCM56800_A0_MMU_PKTLINK11m_CLR
#define MMU_PKTLINK11m_SET BCM56800_A0_MMU_PKTLINK11m_SET
#define MMU_PKTLINK11m_GET BCM56800_A0_MMU_PKTLINK11m_GET
#define MMU_PKTLINK11m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK11m_NEXT_PKTf_GET
#define MMU_PKTLINK11m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK11m_NEXT_PKTf_SET
#define MMU_PKTLINK11m_ECCf_GET BCM56800_A0_MMU_PKTLINK11m_ECCf_GET
#define MMU_PKTLINK11m_ECCf_SET BCM56800_A0_MMU_PKTLINK11m_ECCf_SET
#define MMU_PKTLINK11m_PARITYf_GET BCM56800_A0_MMU_PKTLINK11m_PARITYf_GET
#define MMU_PKTLINK11m_PARITYf_SET BCM56800_A0_MMU_PKTLINK11m_PARITYf_SET
#define MMU_PKTLINK11m_ECCPf_GET BCM56800_A0_MMU_PKTLINK11m_ECCPf_GET
#define MMU_PKTLINK11m_ECCPf_SET BCM56800_A0_MMU_PKTLINK11m_ECCPf_SET
#define READ_MMU_PKTLINK11m BCM56800_A0_READ_MMU_PKTLINK11m
#define WRITE_MMU_PKTLINK11m BCM56800_A0_WRITE_MMU_PKTLINK11m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK11m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK12
 * BLOCKS:   MMU
 * DESC:     PKTLINK12
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK12m 0x10d30000

#define BCM56800_A0_MMU_PKTLINK12m_MIN 0
#define BCM56800_A0_MMU_PKTLINK12m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK12m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK12m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK12.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK12m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink12[1];
	uint32_t _mmu_pktlink12;
} BCM56800_A0_MMU_PKTLINK12m_t;

#define BCM56800_A0_MMU_PKTLINK12m_CLR(r) (r).mmu_pktlink12[0] = 0
#define BCM56800_A0_MMU_PKTLINK12m_SET(r,d) (r).mmu_pktlink12[0] = d
#define BCM56800_A0_MMU_PKTLINK12m_GET(r) (r).mmu_pktlink12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK12m_NEXT_PKTf_GET(r) (((r).mmu_pktlink12[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK12m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink12[0]=(((r).mmu_pktlink12[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK12m_ECCf_GET(r) ((((r).mmu_pktlink12[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK12m_ECCf_SET(r,f) (r).mmu_pktlink12[0]=(((r).mmu_pktlink12[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK12m_PARITYf_GET(r) ((((r).mmu_pktlink12[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK12m_PARITYf_SET(r,f) (r).mmu_pktlink12[0]=(((r).mmu_pktlink12[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK12m_ECCPf_GET(r) ((((r).mmu_pktlink12[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK12m_ECCPf_SET(r,f) (r).mmu_pktlink12[0]=(((r).mmu_pktlink12[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK12.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK12m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK12m,i,(m._mmu_pktlink12),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK12m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK12m,i,&(m._mmu_pktlink12),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK12m BCM56800_A0_MMU_PKTLINK12m
#define MMU_PKTLINK12m_MIN BCM56800_A0_MMU_PKTLINK12m_MIN
#define MMU_PKTLINK12m_MAX BCM56800_A0_MMU_PKTLINK12m_MAX
#define MMU_PKTLINK12m_CMAX(u) BCM56800_A0_MMU_PKTLINK12m_CMAX(u)
#define MMU_PKTLINK12m_SIZE BCM56800_A0_MMU_PKTLINK12m_SIZE
typedef BCM56800_A0_MMU_PKTLINK12m_t MMU_PKTLINK12m_t;
#define MMU_PKTLINK12m_CLR BCM56800_A0_MMU_PKTLINK12m_CLR
#define MMU_PKTLINK12m_SET BCM56800_A0_MMU_PKTLINK12m_SET
#define MMU_PKTLINK12m_GET BCM56800_A0_MMU_PKTLINK12m_GET
#define MMU_PKTLINK12m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK12m_NEXT_PKTf_GET
#define MMU_PKTLINK12m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK12m_NEXT_PKTf_SET
#define MMU_PKTLINK12m_ECCf_GET BCM56800_A0_MMU_PKTLINK12m_ECCf_GET
#define MMU_PKTLINK12m_ECCf_SET BCM56800_A0_MMU_PKTLINK12m_ECCf_SET
#define MMU_PKTLINK12m_PARITYf_GET BCM56800_A0_MMU_PKTLINK12m_PARITYf_GET
#define MMU_PKTLINK12m_PARITYf_SET BCM56800_A0_MMU_PKTLINK12m_PARITYf_SET
#define MMU_PKTLINK12m_ECCPf_GET BCM56800_A0_MMU_PKTLINK12m_ECCPf_GET
#define MMU_PKTLINK12m_ECCPf_SET BCM56800_A0_MMU_PKTLINK12m_ECCPf_SET
#define READ_MMU_PKTLINK12m BCM56800_A0_READ_MMU_PKTLINK12m
#define WRITE_MMU_PKTLINK12m BCM56800_A0_WRITE_MMU_PKTLINK12m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK12m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK13
 * BLOCKS:   MMU
 * DESC:     PKTLINK13
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK13m 0x10d34000

#define BCM56800_A0_MMU_PKTLINK13m_MIN 0
#define BCM56800_A0_MMU_PKTLINK13m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK13m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK13m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK13.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK13m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink13[1];
	uint32_t _mmu_pktlink13;
} BCM56800_A0_MMU_PKTLINK13m_t;

#define BCM56800_A0_MMU_PKTLINK13m_CLR(r) (r).mmu_pktlink13[0] = 0
#define BCM56800_A0_MMU_PKTLINK13m_SET(r,d) (r).mmu_pktlink13[0] = d
#define BCM56800_A0_MMU_PKTLINK13m_GET(r) (r).mmu_pktlink13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK13m_NEXT_PKTf_GET(r) (((r).mmu_pktlink13[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK13m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink13[0]=(((r).mmu_pktlink13[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK13m_ECCf_GET(r) ((((r).mmu_pktlink13[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK13m_ECCf_SET(r,f) (r).mmu_pktlink13[0]=(((r).mmu_pktlink13[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK13m_PARITYf_GET(r) ((((r).mmu_pktlink13[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK13m_PARITYf_SET(r,f) (r).mmu_pktlink13[0]=(((r).mmu_pktlink13[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK13m_ECCPf_GET(r) ((((r).mmu_pktlink13[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK13m_ECCPf_SET(r,f) (r).mmu_pktlink13[0]=(((r).mmu_pktlink13[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK13.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK13m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK13m,i,(m._mmu_pktlink13),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK13m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK13m,i,&(m._mmu_pktlink13),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK13m BCM56800_A0_MMU_PKTLINK13m
#define MMU_PKTLINK13m_MIN BCM56800_A0_MMU_PKTLINK13m_MIN
#define MMU_PKTLINK13m_MAX BCM56800_A0_MMU_PKTLINK13m_MAX
#define MMU_PKTLINK13m_CMAX(u) BCM56800_A0_MMU_PKTLINK13m_CMAX(u)
#define MMU_PKTLINK13m_SIZE BCM56800_A0_MMU_PKTLINK13m_SIZE
typedef BCM56800_A0_MMU_PKTLINK13m_t MMU_PKTLINK13m_t;
#define MMU_PKTLINK13m_CLR BCM56800_A0_MMU_PKTLINK13m_CLR
#define MMU_PKTLINK13m_SET BCM56800_A0_MMU_PKTLINK13m_SET
#define MMU_PKTLINK13m_GET BCM56800_A0_MMU_PKTLINK13m_GET
#define MMU_PKTLINK13m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK13m_NEXT_PKTf_GET
#define MMU_PKTLINK13m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK13m_NEXT_PKTf_SET
#define MMU_PKTLINK13m_ECCf_GET BCM56800_A0_MMU_PKTLINK13m_ECCf_GET
#define MMU_PKTLINK13m_ECCf_SET BCM56800_A0_MMU_PKTLINK13m_ECCf_SET
#define MMU_PKTLINK13m_PARITYf_GET BCM56800_A0_MMU_PKTLINK13m_PARITYf_GET
#define MMU_PKTLINK13m_PARITYf_SET BCM56800_A0_MMU_PKTLINK13m_PARITYf_SET
#define MMU_PKTLINK13m_ECCPf_GET BCM56800_A0_MMU_PKTLINK13m_ECCPf_GET
#define MMU_PKTLINK13m_ECCPf_SET BCM56800_A0_MMU_PKTLINK13m_ECCPf_SET
#define READ_MMU_PKTLINK13m BCM56800_A0_READ_MMU_PKTLINK13m
#define WRITE_MMU_PKTLINK13m BCM56800_A0_WRITE_MMU_PKTLINK13m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK13m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK14
 * BLOCKS:   MMU
 * DESC:     PKTLINK14
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK14m 0x10d38000

#define BCM56800_A0_MMU_PKTLINK14m_MIN 0
#define BCM56800_A0_MMU_PKTLINK14m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK14m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK14m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK14.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK14m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink14[1];
	uint32_t _mmu_pktlink14;
} BCM56800_A0_MMU_PKTLINK14m_t;

#define BCM56800_A0_MMU_PKTLINK14m_CLR(r) (r).mmu_pktlink14[0] = 0
#define BCM56800_A0_MMU_PKTLINK14m_SET(r,d) (r).mmu_pktlink14[0] = d
#define BCM56800_A0_MMU_PKTLINK14m_GET(r) (r).mmu_pktlink14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK14m_NEXT_PKTf_GET(r) (((r).mmu_pktlink14[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK14m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink14[0]=(((r).mmu_pktlink14[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK14m_ECCf_GET(r) ((((r).mmu_pktlink14[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK14m_ECCf_SET(r,f) (r).mmu_pktlink14[0]=(((r).mmu_pktlink14[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK14m_PARITYf_GET(r) ((((r).mmu_pktlink14[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK14m_PARITYf_SET(r,f) (r).mmu_pktlink14[0]=(((r).mmu_pktlink14[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK14m_ECCPf_GET(r) ((((r).mmu_pktlink14[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK14m_ECCPf_SET(r,f) (r).mmu_pktlink14[0]=(((r).mmu_pktlink14[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK14.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK14m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK14m,i,(m._mmu_pktlink14),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK14m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK14m,i,&(m._mmu_pktlink14),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK14m BCM56800_A0_MMU_PKTLINK14m
#define MMU_PKTLINK14m_MIN BCM56800_A0_MMU_PKTLINK14m_MIN
#define MMU_PKTLINK14m_MAX BCM56800_A0_MMU_PKTLINK14m_MAX
#define MMU_PKTLINK14m_CMAX(u) BCM56800_A0_MMU_PKTLINK14m_CMAX(u)
#define MMU_PKTLINK14m_SIZE BCM56800_A0_MMU_PKTLINK14m_SIZE
typedef BCM56800_A0_MMU_PKTLINK14m_t MMU_PKTLINK14m_t;
#define MMU_PKTLINK14m_CLR BCM56800_A0_MMU_PKTLINK14m_CLR
#define MMU_PKTLINK14m_SET BCM56800_A0_MMU_PKTLINK14m_SET
#define MMU_PKTLINK14m_GET BCM56800_A0_MMU_PKTLINK14m_GET
#define MMU_PKTLINK14m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK14m_NEXT_PKTf_GET
#define MMU_PKTLINK14m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK14m_NEXT_PKTf_SET
#define MMU_PKTLINK14m_ECCf_GET BCM56800_A0_MMU_PKTLINK14m_ECCf_GET
#define MMU_PKTLINK14m_ECCf_SET BCM56800_A0_MMU_PKTLINK14m_ECCf_SET
#define MMU_PKTLINK14m_PARITYf_GET BCM56800_A0_MMU_PKTLINK14m_PARITYf_GET
#define MMU_PKTLINK14m_PARITYf_SET BCM56800_A0_MMU_PKTLINK14m_PARITYf_SET
#define MMU_PKTLINK14m_ECCPf_GET BCM56800_A0_MMU_PKTLINK14m_ECCPf_GET
#define MMU_PKTLINK14m_ECCPf_SET BCM56800_A0_MMU_PKTLINK14m_ECCPf_SET
#define READ_MMU_PKTLINK14m BCM56800_A0_READ_MMU_PKTLINK14m
#define WRITE_MMU_PKTLINK14m BCM56800_A0_WRITE_MMU_PKTLINK14m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK14m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK15
 * BLOCKS:   MMU
 * DESC:     PKTLINK15
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK15m 0x10d3c000

#define BCM56800_A0_MMU_PKTLINK15m_MIN 0
#define BCM56800_A0_MMU_PKTLINK15m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK15m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK15m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK15.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK15m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink15[1];
	uint32_t _mmu_pktlink15;
} BCM56800_A0_MMU_PKTLINK15m_t;

#define BCM56800_A0_MMU_PKTLINK15m_CLR(r) (r).mmu_pktlink15[0] = 0
#define BCM56800_A0_MMU_PKTLINK15m_SET(r,d) (r).mmu_pktlink15[0] = d
#define BCM56800_A0_MMU_PKTLINK15m_GET(r) (r).mmu_pktlink15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK15m_NEXT_PKTf_GET(r) (((r).mmu_pktlink15[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK15m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink15[0]=(((r).mmu_pktlink15[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK15m_ECCf_GET(r) ((((r).mmu_pktlink15[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK15m_ECCf_SET(r,f) (r).mmu_pktlink15[0]=(((r).mmu_pktlink15[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK15m_PARITYf_GET(r) ((((r).mmu_pktlink15[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK15m_PARITYf_SET(r,f) (r).mmu_pktlink15[0]=(((r).mmu_pktlink15[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK15m_ECCPf_GET(r) ((((r).mmu_pktlink15[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK15m_ECCPf_SET(r,f) (r).mmu_pktlink15[0]=(((r).mmu_pktlink15[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK15.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK15m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK15m,i,(m._mmu_pktlink15),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK15m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK15m,i,&(m._mmu_pktlink15),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK15m BCM56800_A0_MMU_PKTLINK15m
#define MMU_PKTLINK15m_MIN BCM56800_A0_MMU_PKTLINK15m_MIN
#define MMU_PKTLINK15m_MAX BCM56800_A0_MMU_PKTLINK15m_MAX
#define MMU_PKTLINK15m_CMAX(u) BCM56800_A0_MMU_PKTLINK15m_CMAX(u)
#define MMU_PKTLINK15m_SIZE BCM56800_A0_MMU_PKTLINK15m_SIZE
typedef BCM56800_A0_MMU_PKTLINK15m_t MMU_PKTLINK15m_t;
#define MMU_PKTLINK15m_CLR BCM56800_A0_MMU_PKTLINK15m_CLR
#define MMU_PKTLINK15m_SET BCM56800_A0_MMU_PKTLINK15m_SET
#define MMU_PKTLINK15m_GET BCM56800_A0_MMU_PKTLINK15m_GET
#define MMU_PKTLINK15m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK15m_NEXT_PKTf_GET
#define MMU_PKTLINK15m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK15m_NEXT_PKTf_SET
#define MMU_PKTLINK15m_ECCf_GET BCM56800_A0_MMU_PKTLINK15m_ECCf_GET
#define MMU_PKTLINK15m_ECCf_SET BCM56800_A0_MMU_PKTLINK15m_ECCf_SET
#define MMU_PKTLINK15m_PARITYf_GET BCM56800_A0_MMU_PKTLINK15m_PARITYf_GET
#define MMU_PKTLINK15m_PARITYf_SET BCM56800_A0_MMU_PKTLINK15m_PARITYf_SET
#define MMU_PKTLINK15m_ECCPf_GET BCM56800_A0_MMU_PKTLINK15m_ECCPf_GET
#define MMU_PKTLINK15m_ECCPf_SET BCM56800_A0_MMU_PKTLINK15m_ECCPf_SET
#define READ_MMU_PKTLINK15m BCM56800_A0_READ_MMU_PKTLINK15m
#define WRITE_MMU_PKTLINK15m BCM56800_A0_WRITE_MMU_PKTLINK15m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK15m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK16
 * BLOCKS:   MMU
 * DESC:     PKTLINK16
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK16m 0x10d40000

#define BCM56800_A0_MMU_PKTLINK16m_MIN 0
#define BCM56800_A0_MMU_PKTLINK16m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK16m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK16m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK16.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK16m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink16[1];
	uint32_t _mmu_pktlink16;
} BCM56800_A0_MMU_PKTLINK16m_t;

#define BCM56800_A0_MMU_PKTLINK16m_CLR(r) (r).mmu_pktlink16[0] = 0
#define BCM56800_A0_MMU_PKTLINK16m_SET(r,d) (r).mmu_pktlink16[0] = d
#define BCM56800_A0_MMU_PKTLINK16m_GET(r) (r).mmu_pktlink16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK16m_NEXT_PKTf_GET(r) (((r).mmu_pktlink16[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK16m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink16[0]=(((r).mmu_pktlink16[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK16m_ECCf_GET(r) ((((r).mmu_pktlink16[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK16m_ECCf_SET(r,f) (r).mmu_pktlink16[0]=(((r).mmu_pktlink16[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK16m_PARITYf_GET(r) ((((r).mmu_pktlink16[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK16m_PARITYf_SET(r,f) (r).mmu_pktlink16[0]=(((r).mmu_pktlink16[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK16m_ECCPf_GET(r) ((((r).mmu_pktlink16[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK16m_ECCPf_SET(r,f) (r).mmu_pktlink16[0]=(((r).mmu_pktlink16[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK16.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK16m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK16m,i,(m._mmu_pktlink16),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK16m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK16m,i,&(m._mmu_pktlink16),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK16m BCM56800_A0_MMU_PKTLINK16m
#define MMU_PKTLINK16m_MIN BCM56800_A0_MMU_PKTLINK16m_MIN
#define MMU_PKTLINK16m_MAX BCM56800_A0_MMU_PKTLINK16m_MAX
#define MMU_PKTLINK16m_CMAX(u) BCM56800_A0_MMU_PKTLINK16m_CMAX(u)
#define MMU_PKTLINK16m_SIZE BCM56800_A0_MMU_PKTLINK16m_SIZE
typedef BCM56800_A0_MMU_PKTLINK16m_t MMU_PKTLINK16m_t;
#define MMU_PKTLINK16m_CLR BCM56800_A0_MMU_PKTLINK16m_CLR
#define MMU_PKTLINK16m_SET BCM56800_A0_MMU_PKTLINK16m_SET
#define MMU_PKTLINK16m_GET BCM56800_A0_MMU_PKTLINK16m_GET
#define MMU_PKTLINK16m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK16m_NEXT_PKTf_GET
#define MMU_PKTLINK16m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK16m_NEXT_PKTf_SET
#define MMU_PKTLINK16m_ECCf_GET BCM56800_A0_MMU_PKTLINK16m_ECCf_GET
#define MMU_PKTLINK16m_ECCf_SET BCM56800_A0_MMU_PKTLINK16m_ECCf_SET
#define MMU_PKTLINK16m_PARITYf_GET BCM56800_A0_MMU_PKTLINK16m_PARITYf_GET
#define MMU_PKTLINK16m_PARITYf_SET BCM56800_A0_MMU_PKTLINK16m_PARITYf_SET
#define MMU_PKTLINK16m_ECCPf_GET BCM56800_A0_MMU_PKTLINK16m_ECCPf_GET
#define MMU_PKTLINK16m_ECCPf_SET BCM56800_A0_MMU_PKTLINK16m_ECCPf_SET
#define READ_MMU_PKTLINK16m BCM56800_A0_READ_MMU_PKTLINK16m
#define WRITE_MMU_PKTLINK16m BCM56800_A0_WRITE_MMU_PKTLINK16m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK16m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK17
 * BLOCKS:   MMU
 * DESC:     PKTLINK17
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK17m 0x10d44000

#define BCM56800_A0_MMU_PKTLINK17m_MIN 0
#define BCM56800_A0_MMU_PKTLINK17m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK17m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK17m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK17.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK17m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink17[1];
	uint32_t _mmu_pktlink17;
} BCM56800_A0_MMU_PKTLINK17m_t;

#define BCM56800_A0_MMU_PKTLINK17m_CLR(r) (r).mmu_pktlink17[0] = 0
#define BCM56800_A0_MMU_PKTLINK17m_SET(r,d) (r).mmu_pktlink17[0] = d
#define BCM56800_A0_MMU_PKTLINK17m_GET(r) (r).mmu_pktlink17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK17m_NEXT_PKTf_GET(r) (((r).mmu_pktlink17[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK17m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink17[0]=(((r).mmu_pktlink17[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK17m_ECCf_GET(r) ((((r).mmu_pktlink17[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK17m_ECCf_SET(r,f) (r).mmu_pktlink17[0]=(((r).mmu_pktlink17[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK17m_PARITYf_GET(r) ((((r).mmu_pktlink17[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK17m_PARITYf_SET(r,f) (r).mmu_pktlink17[0]=(((r).mmu_pktlink17[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK17m_ECCPf_GET(r) ((((r).mmu_pktlink17[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK17m_ECCPf_SET(r,f) (r).mmu_pktlink17[0]=(((r).mmu_pktlink17[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK17.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK17m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK17m,i,(m._mmu_pktlink17),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK17m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK17m,i,&(m._mmu_pktlink17),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK17m BCM56800_A0_MMU_PKTLINK17m
#define MMU_PKTLINK17m_MIN BCM56800_A0_MMU_PKTLINK17m_MIN
#define MMU_PKTLINK17m_MAX BCM56800_A0_MMU_PKTLINK17m_MAX
#define MMU_PKTLINK17m_CMAX(u) BCM56800_A0_MMU_PKTLINK17m_CMAX(u)
#define MMU_PKTLINK17m_SIZE BCM56800_A0_MMU_PKTLINK17m_SIZE
typedef BCM56800_A0_MMU_PKTLINK17m_t MMU_PKTLINK17m_t;
#define MMU_PKTLINK17m_CLR BCM56800_A0_MMU_PKTLINK17m_CLR
#define MMU_PKTLINK17m_SET BCM56800_A0_MMU_PKTLINK17m_SET
#define MMU_PKTLINK17m_GET BCM56800_A0_MMU_PKTLINK17m_GET
#define MMU_PKTLINK17m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK17m_NEXT_PKTf_GET
#define MMU_PKTLINK17m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK17m_NEXT_PKTf_SET
#define MMU_PKTLINK17m_ECCf_GET BCM56800_A0_MMU_PKTLINK17m_ECCf_GET
#define MMU_PKTLINK17m_ECCf_SET BCM56800_A0_MMU_PKTLINK17m_ECCf_SET
#define MMU_PKTLINK17m_PARITYf_GET BCM56800_A0_MMU_PKTLINK17m_PARITYf_GET
#define MMU_PKTLINK17m_PARITYf_SET BCM56800_A0_MMU_PKTLINK17m_PARITYf_SET
#define MMU_PKTLINK17m_ECCPf_GET BCM56800_A0_MMU_PKTLINK17m_ECCPf_GET
#define MMU_PKTLINK17m_ECCPf_SET BCM56800_A0_MMU_PKTLINK17m_ECCPf_SET
#define READ_MMU_PKTLINK17m BCM56800_A0_READ_MMU_PKTLINK17m
#define WRITE_MMU_PKTLINK17m BCM56800_A0_WRITE_MMU_PKTLINK17m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK17m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK18
 * BLOCKS:   MMU
 * DESC:     PKTLINK18
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK18m 0x10d48000

#define BCM56800_A0_MMU_PKTLINK18m_MIN 0
#define BCM56800_A0_MMU_PKTLINK18m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK18m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK18m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK18.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK18m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink18[1];
	uint32_t _mmu_pktlink18;
} BCM56800_A0_MMU_PKTLINK18m_t;

#define BCM56800_A0_MMU_PKTLINK18m_CLR(r) (r).mmu_pktlink18[0] = 0
#define BCM56800_A0_MMU_PKTLINK18m_SET(r,d) (r).mmu_pktlink18[0] = d
#define BCM56800_A0_MMU_PKTLINK18m_GET(r) (r).mmu_pktlink18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK18m_NEXT_PKTf_GET(r) (((r).mmu_pktlink18[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK18m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink18[0]=(((r).mmu_pktlink18[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK18m_ECCf_GET(r) ((((r).mmu_pktlink18[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK18m_ECCf_SET(r,f) (r).mmu_pktlink18[0]=(((r).mmu_pktlink18[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK18m_PARITYf_GET(r) ((((r).mmu_pktlink18[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK18m_PARITYf_SET(r,f) (r).mmu_pktlink18[0]=(((r).mmu_pktlink18[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK18m_ECCPf_GET(r) ((((r).mmu_pktlink18[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK18m_ECCPf_SET(r,f) (r).mmu_pktlink18[0]=(((r).mmu_pktlink18[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK18.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK18m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK18m,i,(m._mmu_pktlink18),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK18m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK18m,i,&(m._mmu_pktlink18),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK18m BCM56800_A0_MMU_PKTLINK18m
#define MMU_PKTLINK18m_MIN BCM56800_A0_MMU_PKTLINK18m_MIN
#define MMU_PKTLINK18m_MAX BCM56800_A0_MMU_PKTLINK18m_MAX
#define MMU_PKTLINK18m_CMAX(u) BCM56800_A0_MMU_PKTLINK18m_CMAX(u)
#define MMU_PKTLINK18m_SIZE BCM56800_A0_MMU_PKTLINK18m_SIZE
typedef BCM56800_A0_MMU_PKTLINK18m_t MMU_PKTLINK18m_t;
#define MMU_PKTLINK18m_CLR BCM56800_A0_MMU_PKTLINK18m_CLR
#define MMU_PKTLINK18m_SET BCM56800_A0_MMU_PKTLINK18m_SET
#define MMU_PKTLINK18m_GET BCM56800_A0_MMU_PKTLINK18m_GET
#define MMU_PKTLINK18m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK18m_NEXT_PKTf_GET
#define MMU_PKTLINK18m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK18m_NEXT_PKTf_SET
#define MMU_PKTLINK18m_ECCf_GET BCM56800_A0_MMU_PKTLINK18m_ECCf_GET
#define MMU_PKTLINK18m_ECCf_SET BCM56800_A0_MMU_PKTLINK18m_ECCf_SET
#define MMU_PKTLINK18m_PARITYf_GET BCM56800_A0_MMU_PKTLINK18m_PARITYf_GET
#define MMU_PKTLINK18m_PARITYf_SET BCM56800_A0_MMU_PKTLINK18m_PARITYf_SET
#define MMU_PKTLINK18m_ECCPf_GET BCM56800_A0_MMU_PKTLINK18m_ECCPf_GET
#define MMU_PKTLINK18m_ECCPf_SET BCM56800_A0_MMU_PKTLINK18m_ECCPf_SET
#define READ_MMU_PKTLINK18m BCM56800_A0_READ_MMU_PKTLINK18m
#define WRITE_MMU_PKTLINK18m BCM56800_A0_WRITE_MMU_PKTLINK18m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK18m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK19
 * BLOCKS:   MMU
 * DESC:     PKTLINK19
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK19m 0x10d4c000

#define BCM56800_A0_MMU_PKTLINK19m_MIN 0
#define BCM56800_A0_MMU_PKTLINK19m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK19m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK19m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK19.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK19m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink19[1];
	uint32_t _mmu_pktlink19;
} BCM56800_A0_MMU_PKTLINK19m_t;

#define BCM56800_A0_MMU_PKTLINK19m_CLR(r) (r).mmu_pktlink19[0] = 0
#define BCM56800_A0_MMU_PKTLINK19m_SET(r,d) (r).mmu_pktlink19[0] = d
#define BCM56800_A0_MMU_PKTLINK19m_GET(r) (r).mmu_pktlink19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK19m_NEXT_PKTf_GET(r) (((r).mmu_pktlink19[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK19m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink19[0]=(((r).mmu_pktlink19[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK19m_ECCf_GET(r) ((((r).mmu_pktlink19[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK19m_ECCf_SET(r,f) (r).mmu_pktlink19[0]=(((r).mmu_pktlink19[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK19m_PARITYf_GET(r) ((((r).mmu_pktlink19[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK19m_PARITYf_SET(r,f) (r).mmu_pktlink19[0]=(((r).mmu_pktlink19[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK19m_ECCPf_GET(r) ((((r).mmu_pktlink19[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK19m_ECCPf_SET(r,f) (r).mmu_pktlink19[0]=(((r).mmu_pktlink19[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK19.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK19m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK19m,i,(m._mmu_pktlink19),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK19m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK19m,i,&(m._mmu_pktlink19),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK19m BCM56800_A0_MMU_PKTLINK19m
#define MMU_PKTLINK19m_MIN BCM56800_A0_MMU_PKTLINK19m_MIN
#define MMU_PKTLINK19m_MAX BCM56800_A0_MMU_PKTLINK19m_MAX
#define MMU_PKTLINK19m_CMAX(u) BCM56800_A0_MMU_PKTLINK19m_CMAX(u)
#define MMU_PKTLINK19m_SIZE BCM56800_A0_MMU_PKTLINK19m_SIZE
typedef BCM56800_A0_MMU_PKTLINK19m_t MMU_PKTLINK19m_t;
#define MMU_PKTLINK19m_CLR BCM56800_A0_MMU_PKTLINK19m_CLR
#define MMU_PKTLINK19m_SET BCM56800_A0_MMU_PKTLINK19m_SET
#define MMU_PKTLINK19m_GET BCM56800_A0_MMU_PKTLINK19m_GET
#define MMU_PKTLINK19m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK19m_NEXT_PKTf_GET
#define MMU_PKTLINK19m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK19m_NEXT_PKTf_SET
#define MMU_PKTLINK19m_ECCf_GET BCM56800_A0_MMU_PKTLINK19m_ECCf_GET
#define MMU_PKTLINK19m_ECCf_SET BCM56800_A0_MMU_PKTLINK19m_ECCf_SET
#define MMU_PKTLINK19m_PARITYf_GET BCM56800_A0_MMU_PKTLINK19m_PARITYf_GET
#define MMU_PKTLINK19m_PARITYf_SET BCM56800_A0_MMU_PKTLINK19m_PARITYf_SET
#define MMU_PKTLINK19m_ECCPf_GET BCM56800_A0_MMU_PKTLINK19m_ECCPf_GET
#define MMU_PKTLINK19m_ECCPf_SET BCM56800_A0_MMU_PKTLINK19m_ECCPf_SET
#define READ_MMU_PKTLINK19m BCM56800_A0_READ_MMU_PKTLINK19m
#define WRITE_MMU_PKTLINK19m BCM56800_A0_WRITE_MMU_PKTLINK19m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK19m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK2
 * BLOCKS:   MMU
 * DESC:     PKTLINK2
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK2m 0x10d08000

#define BCM56800_A0_MMU_PKTLINK2m_MIN 0
#define BCM56800_A0_MMU_PKTLINK2m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK2m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK2m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK2.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK2m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink2[1];
	uint32_t _mmu_pktlink2;
} BCM56800_A0_MMU_PKTLINK2m_t;

#define BCM56800_A0_MMU_PKTLINK2m_CLR(r) (r).mmu_pktlink2[0] = 0
#define BCM56800_A0_MMU_PKTLINK2m_SET(r,d) (r).mmu_pktlink2[0] = d
#define BCM56800_A0_MMU_PKTLINK2m_GET(r) (r).mmu_pktlink2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK2m_NEXT_PKTf_GET(r) (((r).mmu_pktlink2[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK2m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink2[0]=(((r).mmu_pktlink2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK2m_ECCf_GET(r) ((((r).mmu_pktlink2[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK2m_ECCf_SET(r,f) (r).mmu_pktlink2[0]=(((r).mmu_pktlink2[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK2m_PARITYf_GET(r) ((((r).mmu_pktlink2[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK2m_PARITYf_SET(r,f) (r).mmu_pktlink2[0]=(((r).mmu_pktlink2[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK2m_ECCPf_GET(r) ((((r).mmu_pktlink2[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK2m_ECCPf_SET(r,f) (r).mmu_pktlink2[0]=(((r).mmu_pktlink2[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK2.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK2m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK2m,i,(m._mmu_pktlink2),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK2m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK2m,i,&(m._mmu_pktlink2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK2m BCM56800_A0_MMU_PKTLINK2m
#define MMU_PKTLINK2m_MIN BCM56800_A0_MMU_PKTLINK2m_MIN
#define MMU_PKTLINK2m_MAX BCM56800_A0_MMU_PKTLINK2m_MAX
#define MMU_PKTLINK2m_CMAX(u) BCM56800_A0_MMU_PKTLINK2m_CMAX(u)
#define MMU_PKTLINK2m_SIZE BCM56800_A0_MMU_PKTLINK2m_SIZE
typedef BCM56800_A0_MMU_PKTLINK2m_t MMU_PKTLINK2m_t;
#define MMU_PKTLINK2m_CLR BCM56800_A0_MMU_PKTLINK2m_CLR
#define MMU_PKTLINK2m_SET BCM56800_A0_MMU_PKTLINK2m_SET
#define MMU_PKTLINK2m_GET BCM56800_A0_MMU_PKTLINK2m_GET
#define MMU_PKTLINK2m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK2m_NEXT_PKTf_GET
#define MMU_PKTLINK2m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK2m_NEXT_PKTf_SET
#define MMU_PKTLINK2m_ECCf_GET BCM56800_A0_MMU_PKTLINK2m_ECCf_GET
#define MMU_PKTLINK2m_ECCf_SET BCM56800_A0_MMU_PKTLINK2m_ECCf_SET
#define MMU_PKTLINK2m_PARITYf_GET BCM56800_A0_MMU_PKTLINK2m_PARITYf_GET
#define MMU_PKTLINK2m_PARITYf_SET BCM56800_A0_MMU_PKTLINK2m_PARITYf_SET
#define MMU_PKTLINK2m_ECCPf_GET BCM56800_A0_MMU_PKTLINK2m_ECCPf_GET
#define MMU_PKTLINK2m_ECCPf_SET BCM56800_A0_MMU_PKTLINK2m_ECCPf_SET
#define READ_MMU_PKTLINK2m BCM56800_A0_READ_MMU_PKTLINK2m
#define WRITE_MMU_PKTLINK2m BCM56800_A0_WRITE_MMU_PKTLINK2m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK2m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK20
 * BLOCKS:   MMU
 * DESC:     PKTLINK20
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK20m 0x10d50000

#define BCM56800_A0_MMU_PKTLINK20m_MIN 0
#define BCM56800_A0_MMU_PKTLINK20m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK20m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK20m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK20.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK20m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink20[1];
	uint32_t _mmu_pktlink20;
} BCM56800_A0_MMU_PKTLINK20m_t;

#define BCM56800_A0_MMU_PKTLINK20m_CLR(r) (r).mmu_pktlink20[0] = 0
#define BCM56800_A0_MMU_PKTLINK20m_SET(r,d) (r).mmu_pktlink20[0] = d
#define BCM56800_A0_MMU_PKTLINK20m_GET(r) (r).mmu_pktlink20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK20m_NEXT_PKTf_GET(r) (((r).mmu_pktlink20[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK20m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink20[0]=(((r).mmu_pktlink20[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK20m_ECCf_GET(r) ((((r).mmu_pktlink20[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK20m_ECCf_SET(r,f) (r).mmu_pktlink20[0]=(((r).mmu_pktlink20[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK20m_PARITYf_GET(r) ((((r).mmu_pktlink20[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK20m_PARITYf_SET(r,f) (r).mmu_pktlink20[0]=(((r).mmu_pktlink20[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK20m_ECCPf_GET(r) ((((r).mmu_pktlink20[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK20m_ECCPf_SET(r,f) (r).mmu_pktlink20[0]=(((r).mmu_pktlink20[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK20.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK20m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK20m,i,(m._mmu_pktlink20),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK20m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK20m,i,&(m._mmu_pktlink20),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK20m BCM56800_A0_MMU_PKTLINK20m
#define MMU_PKTLINK20m_MIN BCM56800_A0_MMU_PKTLINK20m_MIN
#define MMU_PKTLINK20m_MAX BCM56800_A0_MMU_PKTLINK20m_MAX
#define MMU_PKTLINK20m_CMAX(u) BCM56800_A0_MMU_PKTLINK20m_CMAX(u)
#define MMU_PKTLINK20m_SIZE BCM56800_A0_MMU_PKTLINK20m_SIZE
typedef BCM56800_A0_MMU_PKTLINK20m_t MMU_PKTLINK20m_t;
#define MMU_PKTLINK20m_CLR BCM56800_A0_MMU_PKTLINK20m_CLR
#define MMU_PKTLINK20m_SET BCM56800_A0_MMU_PKTLINK20m_SET
#define MMU_PKTLINK20m_GET BCM56800_A0_MMU_PKTLINK20m_GET
#define MMU_PKTLINK20m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK20m_NEXT_PKTf_GET
#define MMU_PKTLINK20m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK20m_NEXT_PKTf_SET
#define MMU_PKTLINK20m_ECCf_GET BCM56800_A0_MMU_PKTLINK20m_ECCf_GET
#define MMU_PKTLINK20m_ECCf_SET BCM56800_A0_MMU_PKTLINK20m_ECCf_SET
#define MMU_PKTLINK20m_PARITYf_GET BCM56800_A0_MMU_PKTLINK20m_PARITYf_GET
#define MMU_PKTLINK20m_PARITYf_SET BCM56800_A0_MMU_PKTLINK20m_PARITYf_SET
#define MMU_PKTLINK20m_ECCPf_GET BCM56800_A0_MMU_PKTLINK20m_ECCPf_GET
#define MMU_PKTLINK20m_ECCPf_SET BCM56800_A0_MMU_PKTLINK20m_ECCPf_SET
#define READ_MMU_PKTLINK20m BCM56800_A0_READ_MMU_PKTLINK20m
#define WRITE_MMU_PKTLINK20m BCM56800_A0_WRITE_MMU_PKTLINK20m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK20m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK3
 * BLOCKS:   MMU
 * DESC:     PKTLINK3
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK3m 0x10d0c000

#define BCM56800_A0_MMU_PKTLINK3m_MIN 0
#define BCM56800_A0_MMU_PKTLINK3m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK3m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK3m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK3.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK3m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink3[1];
	uint32_t _mmu_pktlink3;
} BCM56800_A0_MMU_PKTLINK3m_t;

#define BCM56800_A0_MMU_PKTLINK3m_CLR(r) (r).mmu_pktlink3[0] = 0
#define BCM56800_A0_MMU_PKTLINK3m_SET(r,d) (r).mmu_pktlink3[0] = d
#define BCM56800_A0_MMU_PKTLINK3m_GET(r) (r).mmu_pktlink3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK3m_NEXT_PKTf_GET(r) (((r).mmu_pktlink3[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK3m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink3[0]=(((r).mmu_pktlink3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK3m_ECCf_GET(r) ((((r).mmu_pktlink3[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK3m_ECCf_SET(r,f) (r).mmu_pktlink3[0]=(((r).mmu_pktlink3[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK3m_PARITYf_GET(r) ((((r).mmu_pktlink3[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK3m_PARITYf_SET(r,f) (r).mmu_pktlink3[0]=(((r).mmu_pktlink3[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK3m_ECCPf_GET(r) ((((r).mmu_pktlink3[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK3m_ECCPf_SET(r,f) (r).mmu_pktlink3[0]=(((r).mmu_pktlink3[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK3.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK3m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK3m,i,(m._mmu_pktlink3),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK3m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK3m,i,&(m._mmu_pktlink3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK3m BCM56800_A0_MMU_PKTLINK3m
#define MMU_PKTLINK3m_MIN BCM56800_A0_MMU_PKTLINK3m_MIN
#define MMU_PKTLINK3m_MAX BCM56800_A0_MMU_PKTLINK3m_MAX
#define MMU_PKTLINK3m_CMAX(u) BCM56800_A0_MMU_PKTLINK3m_CMAX(u)
#define MMU_PKTLINK3m_SIZE BCM56800_A0_MMU_PKTLINK3m_SIZE
typedef BCM56800_A0_MMU_PKTLINK3m_t MMU_PKTLINK3m_t;
#define MMU_PKTLINK3m_CLR BCM56800_A0_MMU_PKTLINK3m_CLR
#define MMU_PKTLINK3m_SET BCM56800_A0_MMU_PKTLINK3m_SET
#define MMU_PKTLINK3m_GET BCM56800_A0_MMU_PKTLINK3m_GET
#define MMU_PKTLINK3m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK3m_NEXT_PKTf_GET
#define MMU_PKTLINK3m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK3m_NEXT_PKTf_SET
#define MMU_PKTLINK3m_ECCf_GET BCM56800_A0_MMU_PKTLINK3m_ECCf_GET
#define MMU_PKTLINK3m_ECCf_SET BCM56800_A0_MMU_PKTLINK3m_ECCf_SET
#define MMU_PKTLINK3m_PARITYf_GET BCM56800_A0_MMU_PKTLINK3m_PARITYf_GET
#define MMU_PKTLINK3m_PARITYf_SET BCM56800_A0_MMU_PKTLINK3m_PARITYf_SET
#define MMU_PKTLINK3m_ECCPf_GET BCM56800_A0_MMU_PKTLINK3m_ECCPf_GET
#define MMU_PKTLINK3m_ECCPf_SET BCM56800_A0_MMU_PKTLINK3m_ECCPf_SET
#define READ_MMU_PKTLINK3m BCM56800_A0_READ_MMU_PKTLINK3m
#define WRITE_MMU_PKTLINK3m BCM56800_A0_WRITE_MMU_PKTLINK3m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK3m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK4
 * BLOCKS:   MMU
 * DESC:     PKTLINK4
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK4m 0x10d10000

#define BCM56800_A0_MMU_PKTLINK4m_MIN 0
#define BCM56800_A0_MMU_PKTLINK4m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK4m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK4m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK4.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK4m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink4[1];
	uint32_t _mmu_pktlink4;
} BCM56800_A0_MMU_PKTLINK4m_t;

#define BCM56800_A0_MMU_PKTLINK4m_CLR(r) (r).mmu_pktlink4[0] = 0
#define BCM56800_A0_MMU_PKTLINK4m_SET(r,d) (r).mmu_pktlink4[0] = d
#define BCM56800_A0_MMU_PKTLINK4m_GET(r) (r).mmu_pktlink4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK4m_NEXT_PKTf_GET(r) (((r).mmu_pktlink4[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK4m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink4[0]=(((r).mmu_pktlink4[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK4m_ECCf_GET(r) ((((r).mmu_pktlink4[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK4m_ECCf_SET(r,f) (r).mmu_pktlink4[0]=(((r).mmu_pktlink4[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK4m_PARITYf_GET(r) ((((r).mmu_pktlink4[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK4m_PARITYf_SET(r,f) (r).mmu_pktlink4[0]=(((r).mmu_pktlink4[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK4m_ECCPf_GET(r) ((((r).mmu_pktlink4[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK4m_ECCPf_SET(r,f) (r).mmu_pktlink4[0]=(((r).mmu_pktlink4[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK4.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK4m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK4m,i,(m._mmu_pktlink4),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK4m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK4m,i,&(m._mmu_pktlink4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK4m BCM56800_A0_MMU_PKTLINK4m
#define MMU_PKTLINK4m_MIN BCM56800_A0_MMU_PKTLINK4m_MIN
#define MMU_PKTLINK4m_MAX BCM56800_A0_MMU_PKTLINK4m_MAX
#define MMU_PKTLINK4m_CMAX(u) BCM56800_A0_MMU_PKTLINK4m_CMAX(u)
#define MMU_PKTLINK4m_SIZE BCM56800_A0_MMU_PKTLINK4m_SIZE
typedef BCM56800_A0_MMU_PKTLINK4m_t MMU_PKTLINK4m_t;
#define MMU_PKTLINK4m_CLR BCM56800_A0_MMU_PKTLINK4m_CLR
#define MMU_PKTLINK4m_SET BCM56800_A0_MMU_PKTLINK4m_SET
#define MMU_PKTLINK4m_GET BCM56800_A0_MMU_PKTLINK4m_GET
#define MMU_PKTLINK4m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK4m_NEXT_PKTf_GET
#define MMU_PKTLINK4m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK4m_NEXT_PKTf_SET
#define MMU_PKTLINK4m_ECCf_GET BCM56800_A0_MMU_PKTLINK4m_ECCf_GET
#define MMU_PKTLINK4m_ECCf_SET BCM56800_A0_MMU_PKTLINK4m_ECCf_SET
#define MMU_PKTLINK4m_PARITYf_GET BCM56800_A0_MMU_PKTLINK4m_PARITYf_GET
#define MMU_PKTLINK4m_PARITYf_SET BCM56800_A0_MMU_PKTLINK4m_PARITYf_SET
#define MMU_PKTLINK4m_ECCPf_GET BCM56800_A0_MMU_PKTLINK4m_ECCPf_GET
#define MMU_PKTLINK4m_ECCPf_SET BCM56800_A0_MMU_PKTLINK4m_ECCPf_SET
#define READ_MMU_PKTLINK4m BCM56800_A0_READ_MMU_PKTLINK4m
#define WRITE_MMU_PKTLINK4m BCM56800_A0_WRITE_MMU_PKTLINK4m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK4m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK5
 * BLOCKS:   MMU
 * DESC:     PKTLINK5
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK5m 0x10d14000

#define BCM56800_A0_MMU_PKTLINK5m_MIN 0
#define BCM56800_A0_MMU_PKTLINK5m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK5m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK5m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK5.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK5m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink5[1];
	uint32_t _mmu_pktlink5;
} BCM56800_A0_MMU_PKTLINK5m_t;

#define BCM56800_A0_MMU_PKTLINK5m_CLR(r) (r).mmu_pktlink5[0] = 0
#define BCM56800_A0_MMU_PKTLINK5m_SET(r,d) (r).mmu_pktlink5[0] = d
#define BCM56800_A0_MMU_PKTLINK5m_GET(r) (r).mmu_pktlink5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK5m_NEXT_PKTf_GET(r) (((r).mmu_pktlink5[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK5m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink5[0]=(((r).mmu_pktlink5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK5m_ECCf_GET(r) ((((r).mmu_pktlink5[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK5m_ECCf_SET(r,f) (r).mmu_pktlink5[0]=(((r).mmu_pktlink5[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK5m_PARITYf_GET(r) ((((r).mmu_pktlink5[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK5m_PARITYf_SET(r,f) (r).mmu_pktlink5[0]=(((r).mmu_pktlink5[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK5m_ECCPf_GET(r) ((((r).mmu_pktlink5[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK5m_ECCPf_SET(r,f) (r).mmu_pktlink5[0]=(((r).mmu_pktlink5[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK5.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK5m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK5m,i,(m._mmu_pktlink5),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK5m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK5m,i,&(m._mmu_pktlink5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK5m BCM56800_A0_MMU_PKTLINK5m
#define MMU_PKTLINK5m_MIN BCM56800_A0_MMU_PKTLINK5m_MIN
#define MMU_PKTLINK5m_MAX BCM56800_A0_MMU_PKTLINK5m_MAX
#define MMU_PKTLINK5m_CMAX(u) BCM56800_A0_MMU_PKTLINK5m_CMAX(u)
#define MMU_PKTLINK5m_SIZE BCM56800_A0_MMU_PKTLINK5m_SIZE
typedef BCM56800_A0_MMU_PKTLINK5m_t MMU_PKTLINK5m_t;
#define MMU_PKTLINK5m_CLR BCM56800_A0_MMU_PKTLINK5m_CLR
#define MMU_PKTLINK5m_SET BCM56800_A0_MMU_PKTLINK5m_SET
#define MMU_PKTLINK5m_GET BCM56800_A0_MMU_PKTLINK5m_GET
#define MMU_PKTLINK5m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK5m_NEXT_PKTf_GET
#define MMU_PKTLINK5m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK5m_NEXT_PKTf_SET
#define MMU_PKTLINK5m_ECCf_GET BCM56800_A0_MMU_PKTLINK5m_ECCf_GET
#define MMU_PKTLINK5m_ECCf_SET BCM56800_A0_MMU_PKTLINK5m_ECCf_SET
#define MMU_PKTLINK5m_PARITYf_GET BCM56800_A0_MMU_PKTLINK5m_PARITYf_GET
#define MMU_PKTLINK5m_PARITYf_SET BCM56800_A0_MMU_PKTLINK5m_PARITYf_SET
#define MMU_PKTLINK5m_ECCPf_GET BCM56800_A0_MMU_PKTLINK5m_ECCPf_GET
#define MMU_PKTLINK5m_ECCPf_SET BCM56800_A0_MMU_PKTLINK5m_ECCPf_SET
#define READ_MMU_PKTLINK5m BCM56800_A0_READ_MMU_PKTLINK5m
#define WRITE_MMU_PKTLINK5m BCM56800_A0_WRITE_MMU_PKTLINK5m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK5m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK6
 * BLOCKS:   MMU
 * DESC:     PKTLINK6
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK6m 0x10d18000

#define BCM56800_A0_MMU_PKTLINK6m_MIN 0
#define BCM56800_A0_MMU_PKTLINK6m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK6m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK6m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK6.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK6m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink6[1];
	uint32_t _mmu_pktlink6;
} BCM56800_A0_MMU_PKTLINK6m_t;

#define BCM56800_A0_MMU_PKTLINK6m_CLR(r) (r).mmu_pktlink6[0] = 0
#define BCM56800_A0_MMU_PKTLINK6m_SET(r,d) (r).mmu_pktlink6[0] = d
#define BCM56800_A0_MMU_PKTLINK6m_GET(r) (r).mmu_pktlink6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK6m_NEXT_PKTf_GET(r) (((r).mmu_pktlink6[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK6m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink6[0]=(((r).mmu_pktlink6[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK6m_ECCf_GET(r) ((((r).mmu_pktlink6[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK6m_ECCf_SET(r,f) (r).mmu_pktlink6[0]=(((r).mmu_pktlink6[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK6m_PARITYf_GET(r) ((((r).mmu_pktlink6[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK6m_PARITYf_SET(r,f) (r).mmu_pktlink6[0]=(((r).mmu_pktlink6[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK6m_ECCPf_GET(r) ((((r).mmu_pktlink6[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK6m_ECCPf_SET(r,f) (r).mmu_pktlink6[0]=(((r).mmu_pktlink6[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK6.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK6m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK6m,i,(m._mmu_pktlink6),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK6m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK6m,i,&(m._mmu_pktlink6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK6m BCM56800_A0_MMU_PKTLINK6m
#define MMU_PKTLINK6m_MIN BCM56800_A0_MMU_PKTLINK6m_MIN
#define MMU_PKTLINK6m_MAX BCM56800_A0_MMU_PKTLINK6m_MAX
#define MMU_PKTLINK6m_CMAX(u) BCM56800_A0_MMU_PKTLINK6m_CMAX(u)
#define MMU_PKTLINK6m_SIZE BCM56800_A0_MMU_PKTLINK6m_SIZE
typedef BCM56800_A0_MMU_PKTLINK6m_t MMU_PKTLINK6m_t;
#define MMU_PKTLINK6m_CLR BCM56800_A0_MMU_PKTLINK6m_CLR
#define MMU_PKTLINK6m_SET BCM56800_A0_MMU_PKTLINK6m_SET
#define MMU_PKTLINK6m_GET BCM56800_A0_MMU_PKTLINK6m_GET
#define MMU_PKTLINK6m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK6m_NEXT_PKTf_GET
#define MMU_PKTLINK6m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK6m_NEXT_PKTf_SET
#define MMU_PKTLINK6m_ECCf_GET BCM56800_A0_MMU_PKTLINK6m_ECCf_GET
#define MMU_PKTLINK6m_ECCf_SET BCM56800_A0_MMU_PKTLINK6m_ECCf_SET
#define MMU_PKTLINK6m_PARITYf_GET BCM56800_A0_MMU_PKTLINK6m_PARITYf_GET
#define MMU_PKTLINK6m_PARITYf_SET BCM56800_A0_MMU_PKTLINK6m_PARITYf_SET
#define MMU_PKTLINK6m_ECCPf_GET BCM56800_A0_MMU_PKTLINK6m_ECCPf_GET
#define MMU_PKTLINK6m_ECCPf_SET BCM56800_A0_MMU_PKTLINK6m_ECCPf_SET
#define READ_MMU_PKTLINK6m BCM56800_A0_READ_MMU_PKTLINK6m
#define WRITE_MMU_PKTLINK6m BCM56800_A0_WRITE_MMU_PKTLINK6m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK6m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK7
 * BLOCKS:   MMU
 * DESC:     PKTLINK7
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK7m 0x10d1c000

#define BCM56800_A0_MMU_PKTLINK7m_MIN 0
#define BCM56800_A0_MMU_PKTLINK7m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK7m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK7m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK7.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK7m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink7[1];
	uint32_t _mmu_pktlink7;
} BCM56800_A0_MMU_PKTLINK7m_t;

#define BCM56800_A0_MMU_PKTLINK7m_CLR(r) (r).mmu_pktlink7[0] = 0
#define BCM56800_A0_MMU_PKTLINK7m_SET(r,d) (r).mmu_pktlink7[0] = d
#define BCM56800_A0_MMU_PKTLINK7m_GET(r) (r).mmu_pktlink7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK7m_NEXT_PKTf_GET(r) (((r).mmu_pktlink7[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK7m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink7[0]=(((r).mmu_pktlink7[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK7m_ECCf_GET(r) ((((r).mmu_pktlink7[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK7m_ECCf_SET(r,f) (r).mmu_pktlink7[0]=(((r).mmu_pktlink7[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK7m_PARITYf_GET(r) ((((r).mmu_pktlink7[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK7m_PARITYf_SET(r,f) (r).mmu_pktlink7[0]=(((r).mmu_pktlink7[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK7m_ECCPf_GET(r) ((((r).mmu_pktlink7[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK7m_ECCPf_SET(r,f) (r).mmu_pktlink7[0]=(((r).mmu_pktlink7[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK7.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK7m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK7m,i,(m._mmu_pktlink7),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK7m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK7m,i,&(m._mmu_pktlink7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK7m BCM56800_A0_MMU_PKTLINK7m
#define MMU_PKTLINK7m_MIN BCM56800_A0_MMU_PKTLINK7m_MIN
#define MMU_PKTLINK7m_MAX BCM56800_A0_MMU_PKTLINK7m_MAX
#define MMU_PKTLINK7m_CMAX(u) BCM56800_A0_MMU_PKTLINK7m_CMAX(u)
#define MMU_PKTLINK7m_SIZE BCM56800_A0_MMU_PKTLINK7m_SIZE
typedef BCM56800_A0_MMU_PKTLINK7m_t MMU_PKTLINK7m_t;
#define MMU_PKTLINK7m_CLR BCM56800_A0_MMU_PKTLINK7m_CLR
#define MMU_PKTLINK7m_SET BCM56800_A0_MMU_PKTLINK7m_SET
#define MMU_PKTLINK7m_GET BCM56800_A0_MMU_PKTLINK7m_GET
#define MMU_PKTLINK7m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK7m_NEXT_PKTf_GET
#define MMU_PKTLINK7m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK7m_NEXT_PKTf_SET
#define MMU_PKTLINK7m_ECCf_GET BCM56800_A0_MMU_PKTLINK7m_ECCf_GET
#define MMU_PKTLINK7m_ECCf_SET BCM56800_A0_MMU_PKTLINK7m_ECCf_SET
#define MMU_PKTLINK7m_PARITYf_GET BCM56800_A0_MMU_PKTLINK7m_PARITYf_GET
#define MMU_PKTLINK7m_PARITYf_SET BCM56800_A0_MMU_PKTLINK7m_PARITYf_SET
#define MMU_PKTLINK7m_ECCPf_GET BCM56800_A0_MMU_PKTLINK7m_ECCPf_GET
#define MMU_PKTLINK7m_ECCPf_SET BCM56800_A0_MMU_PKTLINK7m_ECCPf_SET
#define READ_MMU_PKTLINK7m BCM56800_A0_READ_MMU_PKTLINK7m
#define WRITE_MMU_PKTLINK7m BCM56800_A0_WRITE_MMU_PKTLINK7m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK7m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK8
 * BLOCKS:   MMU
 * DESC:     PKTLINK8
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK8m 0x10d20000

#define BCM56800_A0_MMU_PKTLINK8m_MIN 0
#define BCM56800_A0_MMU_PKTLINK8m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK8m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK8m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK8.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK8m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink8[1];
	uint32_t _mmu_pktlink8;
} BCM56800_A0_MMU_PKTLINK8m_t;

#define BCM56800_A0_MMU_PKTLINK8m_CLR(r) (r).mmu_pktlink8[0] = 0
#define BCM56800_A0_MMU_PKTLINK8m_SET(r,d) (r).mmu_pktlink8[0] = d
#define BCM56800_A0_MMU_PKTLINK8m_GET(r) (r).mmu_pktlink8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK8m_NEXT_PKTf_GET(r) (((r).mmu_pktlink8[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK8m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink8[0]=(((r).mmu_pktlink8[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK8m_ECCf_GET(r) ((((r).mmu_pktlink8[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK8m_ECCf_SET(r,f) (r).mmu_pktlink8[0]=(((r).mmu_pktlink8[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK8m_PARITYf_GET(r) ((((r).mmu_pktlink8[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK8m_PARITYf_SET(r,f) (r).mmu_pktlink8[0]=(((r).mmu_pktlink8[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK8m_ECCPf_GET(r) ((((r).mmu_pktlink8[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK8m_ECCPf_SET(r,f) (r).mmu_pktlink8[0]=(((r).mmu_pktlink8[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK8.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK8m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK8m,i,(m._mmu_pktlink8),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK8m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK8m,i,&(m._mmu_pktlink8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK8m BCM56800_A0_MMU_PKTLINK8m
#define MMU_PKTLINK8m_MIN BCM56800_A0_MMU_PKTLINK8m_MIN
#define MMU_PKTLINK8m_MAX BCM56800_A0_MMU_PKTLINK8m_MAX
#define MMU_PKTLINK8m_CMAX(u) BCM56800_A0_MMU_PKTLINK8m_CMAX(u)
#define MMU_PKTLINK8m_SIZE BCM56800_A0_MMU_PKTLINK8m_SIZE
typedef BCM56800_A0_MMU_PKTLINK8m_t MMU_PKTLINK8m_t;
#define MMU_PKTLINK8m_CLR BCM56800_A0_MMU_PKTLINK8m_CLR
#define MMU_PKTLINK8m_SET BCM56800_A0_MMU_PKTLINK8m_SET
#define MMU_PKTLINK8m_GET BCM56800_A0_MMU_PKTLINK8m_GET
#define MMU_PKTLINK8m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK8m_NEXT_PKTf_GET
#define MMU_PKTLINK8m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK8m_NEXT_PKTf_SET
#define MMU_PKTLINK8m_ECCf_GET BCM56800_A0_MMU_PKTLINK8m_ECCf_GET
#define MMU_PKTLINK8m_ECCf_SET BCM56800_A0_MMU_PKTLINK8m_ECCf_SET
#define MMU_PKTLINK8m_PARITYf_GET BCM56800_A0_MMU_PKTLINK8m_PARITYf_GET
#define MMU_PKTLINK8m_PARITYf_SET BCM56800_A0_MMU_PKTLINK8m_PARITYf_SET
#define MMU_PKTLINK8m_ECCPf_GET BCM56800_A0_MMU_PKTLINK8m_ECCPf_GET
#define MMU_PKTLINK8m_ECCPf_SET BCM56800_A0_MMU_PKTLINK8m_ECCPf_SET
#define READ_MMU_PKTLINK8m BCM56800_A0_READ_MMU_PKTLINK8m
#define WRITE_MMU_PKTLINK8m BCM56800_A0_WRITE_MMU_PKTLINK8m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK8m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MMU_PKTLINK9
 * BLOCKS:   MMU
 * DESC:     PKTLINK9
 * SIZE:     20
 * FIELDS:
 *     NEXT_PKT         Address pointer to next packet in queue
 *     ECC              ECC
 *     PARITY           Parity bit
 *     ECCP             Parity bit
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_PKTLINK9m 0x10d24000

#define BCM56800_A0_MMU_PKTLINK9m_MIN 0
#define BCM56800_A0_MMU_PKTLINK9m_MAX 12287
#define BCM56800_A0_MMU_PKTLINK9m_CMAX(u) 12287
#define BCM56800_A0_MMU_PKTLINK9m_SIZE 3

/*
 * This structure should be used to declare and program MMU_PKTLINK9.
 *
 */
typedef union BCM56800_A0_MMU_PKTLINK9m_s {
	uint32_t v[1];
	uint32_t mmu_pktlink9[1];
	uint32_t _mmu_pktlink9;
} BCM56800_A0_MMU_PKTLINK9m_t;

#define BCM56800_A0_MMU_PKTLINK9m_CLR(r) (r).mmu_pktlink9[0] = 0
#define BCM56800_A0_MMU_PKTLINK9m_SET(r,d) (r).mmu_pktlink9[0] = d
#define BCM56800_A0_MMU_PKTLINK9m_GET(r) (r).mmu_pktlink9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_PKTLINK9m_NEXT_PKTf_GET(r) (((r).mmu_pktlink9[0]) & 0x3fff)
#define BCM56800_A0_MMU_PKTLINK9m_NEXT_PKTf_SET(r,f) (r).mmu_pktlink9[0]=(((r).mmu_pktlink9[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_MMU_PKTLINK9m_ECCf_GET(r) ((((r).mmu_pktlink9[0]) >> 14) & 0x1f)
#define BCM56800_A0_MMU_PKTLINK9m_ECCf_SET(r,f) (r).mmu_pktlink9[0]=(((r).mmu_pktlink9[0] & ~((uint32_t)0x1f << 14)) | ((((uint32_t)f) & 0x1f) << 14))
#define BCM56800_A0_MMU_PKTLINK9m_PARITYf_GET(r) ((((r).mmu_pktlink9[0]) >> 19) & 0x1)
#define BCM56800_A0_MMU_PKTLINK9m_PARITYf_SET(r,f) (r).mmu_pktlink9[0]=(((r).mmu_pktlink9[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_MMU_PKTLINK9m_ECCPf_GET(r) ((((r).mmu_pktlink9[0]) >> 14) & 0x3f)
#define BCM56800_A0_MMU_PKTLINK9m_ECCPf_SET(r,f) (r).mmu_pktlink9[0]=(((r).mmu_pktlink9[0] & ~((uint32_t)0x3f << 14)) | ((((uint32_t)f) & 0x3f) << 14))

/*
 * These macros can be used to access MMU_PKTLINK9.
 *
 */
#define BCM56800_A0_READ_MMU_PKTLINK9m(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MMU_PKTLINK9m,i,(m._mmu_pktlink9),1)
#define BCM56800_A0_WRITE_MMU_PKTLINK9m(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MMU_PKTLINK9m,i,&(m._mmu_pktlink9),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_PKTLINK9m BCM56800_A0_MMU_PKTLINK9m
#define MMU_PKTLINK9m_MIN BCM56800_A0_MMU_PKTLINK9m_MIN
#define MMU_PKTLINK9m_MAX BCM56800_A0_MMU_PKTLINK9m_MAX
#define MMU_PKTLINK9m_CMAX(u) BCM56800_A0_MMU_PKTLINK9m_CMAX(u)
#define MMU_PKTLINK9m_SIZE BCM56800_A0_MMU_PKTLINK9m_SIZE
typedef BCM56800_A0_MMU_PKTLINK9m_t MMU_PKTLINK9m_t;
#define MMU_PKTLINK9m_CLR BCM56800_A0_MMU_PKTLINK9m_CLR
#define MMU_PKTLINK9m_SET BCM56800_A0_MMU_PKTLINK9m_SET
#define MMU_PKTLINK9m_GET BCM56800_A0_MMU_PKTLINK9m_GET
#define MMU_PKTLINK9m_NEXT_PKTf_GET BCM56800_A0_MMU_PKTLINK9m_NEXT_PKTf_GET
#define MMU_PKTLINK9m_NEXT_PKTf_SET BCM56800_A0_MMU_PKTLINK9m_NEXT_PKTf_SET
#define MMU_PKTLINK9m_ECCf_GET BCM56800_A0_MMU_PKTLINK9m_ECCf_GET
#define MMU_PKTLINK9m_ECCf_SET BCM56800_A0_MMU_PKTLINK9m_ECCf_SET
#define MMU_PKTLINK9m_PARITYf_GET BCM56800_A0_MMU_PKTLINK9m_PARITYf_GET
#define MMU_PKTLINK9m_PARITYf_SET BCM56800_A0_MMU_PKTLINK9m_PARITYf_SET
#define MMU_PKTLINK9m_ECCPf_GET BCM56800_A0_MMU_PKTLINK9m_ECCPf_GET
#define MMU_PKTLINK9m_ECCPf_SET BCM56800_A0_MMU_PKTLINK9m_ECCPf_SET
#define READ_MMU_PKTLINK9m BCM56800_A0_READ_MMU_PKTLINK9m
#define WRITE_MMU_PKTLINK9m BCM56800_A0_WRITE_MMU_PKTLINK9m

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_PKTLINK9m'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MMU_TO_XPORT_BKP
 * BLOCKS:   MMU
 * DESC:     MMU to XPORT BKP status
 * SIZE:     32
 * FIELDS:
 *     PRI0_BKP         Priority 0 BKP status
 *     PRI1_BKP         Priority 1 BKP status
 *     PRI2_BKP         Priority 2 BKP status
 *     PRI3_BKP         Priority 3 BKP status
 *     PRI4_BKP         Priority 4 BKP status
 *     PRI5_BKP         Priority 5 BKP status
 *     PRI6_BKP         Priority 6 BKP status
 *     PRI7_BKP         Priority 7 BKP status
 *     PRI8_BKP         Priority 8 BKP status
 *     PRI9_BKP         Priority 9 BKP status
 *     PRI10_BKP        Priority 10 BKP status
 *     PRI11_BKP        Priority 11 BKP status
 *     PRI12_BKP        Priority 12 BKP status
 *     PRI13_BKP        Priority 13 BKP status
 *     PRI14_BKP        Priority 14 BKP status
 *     PRI15_BKP        Priority 15 BKP status
 *     PAUSE            Pause status
 *
 ******************************************************************************/
#define BCM56800_A0_MMU_TO_XPORT_BKPr 0x0bd00010

#define BCM56800_A0_MMU_TO_XPORT_BKPr_SIZE 4

/*
 * This structure should be used to declare and program MMU_TO_XPORT_BKP.
 *
 */
typedef union BCM56800_A0_MMU_TO_XPORT_BKPr_s {
	uint32_t v[1];
	uint32_t mmu_to_xport_bkp[1];
	uint32_t _mmu_to_xport_bkp;
} BCM56800_A0_MMU_TO_XPORT_BKPr_t;

#define BCM56800_A0_MMU_TO_XPORT_BKPr_CLR(r) (r).mmu_to_xport_bkp[0] = 0
#define BCM56800_A0_MMU_TO_XPORT_BKPr_SET(r,d) (r).mmu_to_xport_bkp[0] = d
#define BCM56800_A0_MMU_TO_XPORT_BKPr_GET(r) (r).mmu_to_xport_bkp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI0_BKPf_GET(r) (((r).mmu_to_xport_bkp[0]) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI0_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI1_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 1) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI1_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI2_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 2) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI2_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI3_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 3) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI3_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI4_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 4) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI4_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI5_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 5) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI5_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI6_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 6) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI6_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI7_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 7) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI7_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI8_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 8) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI8_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI9_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 9) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI9_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI10_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 10) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI10_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI11_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 11) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI11_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI12_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 12) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI12_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI13_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 13) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI13_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI14_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 14) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI14_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI15_BKPf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 15) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PRI15_BKPf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PAUSEf_GET(r) ((((r).mmu_to_xport_bkp[0]) >> 16) & 0x1)
#define BCM56800_A0_MMU_TO_XPORT_BKPr_PAUSEf_SET(r,f) (r).mmu_to_xport_bkp[0]=(((r).mmu_to_xport_bkp[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access MMU_TO_XPORT_BKP.
 *
 */
#define BCM56800_A0_READ_MMU_TO_XPORT_BKPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_MMU_TO_XPORT_BKPr,(r._mmu_to_xport_bkp))
#define BCM56800_A0_WRITE_MMU_TO_XPORT_BKPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_MMU_TO_XPORT_BKPr,&(r._mmu_to_xport_bkp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MMU_TO_XPORT_BKPr BCM56800_A0_MMU_TO_XPORT_BKPr
#define MMU_TO_XPORT_BKPr_SIZE BCM56800_A0_MMU_TO_XPORT_BKPr_SIZE
typedef BCM56800_A0_MMU_TO_XPORT_BKPr_t MMU_TO_XPORT_BKPr_t;
#define MMU_TO_XPORT_BKPr_CLR BCM56800_A0_MMU_TO_XPORT_BKPr_CLR
#define MMU_TO_XPORT_BKPr_SET BCM56800_A0_MMU_TO_XPORT_BKPr_SET
#define MMU_TO_XPORT_BKPr_GET BCM56800_A0_MMU_TO_XPORT_BKPr_GET
#define MMU_TO_XPORT_BKPr_PRI0_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI0_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI0_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI0_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI1_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI1_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI1_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI1_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI2_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI2_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI2_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI2_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI3_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI3_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI3_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI3_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI4_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI4_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI4_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI4_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI5_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI5_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI5_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI5_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI6_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI6_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI6_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI6_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI7_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI7_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI7_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI7_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI8_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI8_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI8_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI8_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI9_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI9_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI9_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI9_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI10_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI10_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI10_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI10_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI11_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI11_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI11_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI11_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI12_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI12_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI12_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI12_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI13_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI13_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI13_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI13_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI14_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI14_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI14_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI14_BKPf_SET
#define MMU_TO_XPORT_BKPr_PRI15_BKPf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI15_BKPf_GET
#define MMU_TO_XPORT_BKPr_PRI15_BKPf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PRI15_BKPf_SET
#define MMU_TO_XPORT_BKPr_PAUSEf_GET BCM56800_A0_MMU_TO_XPORT_BKPr_PAUSEf_GET
#define MMU_TO_XPORT_BKPr_PAUSEf_SET BCM56800_A0_MMU_TO_XPORT_BKPr_PAUSEf_SET
#define READ_MMU_TO_XPORT_BKPr BCM56800_A0_READ_MMU_TO_XPORT_BKPr
#define WRITE_MMU_TO_XPORT_BKPr BCM56800_A0_WRITE_MMU_TO_XPORT_BKPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MMU_TO_XPORT_BKPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MODPORT_MAP
 * BLOCKS:   IPIPE
 * DESC:     Module Port Mapping Table - Writing this table writes all three physical copies
 * SIZE:     29
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *     HIGIG_TRUNK_OVERRIDE HiGig trunk override
 *
 ******************************************************************************/
#define BCM56800_A0_MODPORT_MAPm 0x0e1a5000

#define BCM56800_A0_MODPORT_MAPm_MIN 0
#define BCM56800_A0_MODPORT_MAPm_MAX 2687
#define BCM56800_A0_MODPORT_MAPm_CMAX(u) 2687
#define BCM56800_A0_MODPORT_MAPm_SIZE 4

/*
 * This structure should be used to declare and program MODPORT_MAP.
 *
 */
typedef union BCM56800_A0_MODPORT_MAPm_s {
	uint32_t v[1];
	uint32_t modport_map[1];
	uint32_t _modport_map;
} BCM56800_A0_MODPORT_MAPm_t;

#define BCM56800_A0_MODPORT_MAPm_CLR(r) (r).modport_map[0] = 0
#define BCM56800_A0_MODPORT_MAPm_SET(r,d) (r).modport_map[0] = d
#define BCM56800_A0_MODPORT_MAPm_GET(r) (r).modport_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map[0]) & 0x1fffff)
#define BCM56800_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map[0]=(((r).modport_map[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM56800_A0_MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).modport_map[0]) >> 21) & 0xff)
#define BCM56800_A0_MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).modport_map[0]=(((r).modport_map[0] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))

/*
 * These macros can be used to access MODPORT_MAP.
 *
 */
#define BCM56800_A0_READ_MODPORT_MAPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MODPORT_MAPm,i,(m._modport_map),1)
#define BCM56800_A0_WRITE_MODPORT_MAPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MODPORT_MAPm,i,&(m._modport_map),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAPm BCM56800_A0_MODPORT_MAPm
#define MODPORT_MAPm_MIN BCM56800_A0_MODPORT_MAPm_MIN
#define MODPORT_MAPm_MAX BCM56800_A0_MODPORT_MAPm_MAX
#define MODPORT_MAPm_CMAX(u) BCM56800_A0_MODPORT_MAPm_CMAX(u)
#define MODPORT_MAPm_SIZE BCM56800_A0_MODPORT_MAPm_SIZE
typedef BCM56800_A0_MODPORT_MAPm_t MODPORT_MAPm_t;
#define MODPORT_MAPm_CLR BCM56800_A0_MODPORT_MAPm_CLR
#define MODPORT_MAPm_SET BCM56800_A0_MODPORT_MAPm_SET
#define MODPORT_MAPm_GET BCM56800_A0_MODPORT_MAPm_GET
#define MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET BCM56800_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET BCM56800_A0_MODPORT_MAPm_HIGIG_PORT_BITMAPf_SET
#define MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_GET BCM56800_A0_MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_GET
#define MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_SET BCM56800_A0_MODPORT_MAPm_HIGIG_TRUNK_OVERRIDEf_SET
#define READ_MODPORT_MAPm BCM56800_A0_READ_MODPORT_MAPm
#define WRITE_MODPORT_MAPm BCM56800_A0_WRITE_MODPORT_MAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MODPORT_MAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MODPORT_MAP_EM
 * BLOCKS:   IPIPE
 * DESC:     Third physical copy of Module Port Mapping Table - used for mapping the egress mirrored copy of a packet
 * SIZE:     29
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *     HIGIG_TRUNK_OVERRIDE HiGig trunk override
 *
 ******************************************************************************/
#define BCM56800_A0_MODPORT_MAP_EMm 0x0e1b2000

#define BCM56800_A0_MODPORT_MAP_EMm_MIN 0
#define BCM56800_A0_MODPORT_MAP_EMm_MAX 2687
#define BCM56800_A0_MODPORT_MAP_EMm_CMAX(u) 2687
#define BCM56800_A0_MODPORT_MAP_EMm_SIZE 4

/*
 * This structure should be used to declare and program MODPORT_MAP_EM.
 *
 */
typedef union BCM56800_A0_MODPORT_MAP_EMm_s {
	uint32_t v[1];
	uint32_t modport_map_em[1];
	uint32_t _modport_map_em;
} BCM56800_A0_MODPORT_MAP_EMm_t;

#define BCM56800_A0_MODPORT_MAP_EMm_CLR(r) (r).modport_map_em[0] = 0
#define BCM56800_A0_MODPORT_MAP_EMm_SET(r,d) (r).modport_map_em[0] = d
#define BCM56800_A0_MODPORT_MAP_EMm_GET(r) (r).modport_map_em[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map_em[0]) & 0x1fffff)
#define BCM56800_A0_MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map_em[0]=(((r).modport_map_em[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM56800_A0_MODPORT_MAP_EMm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).modport_map_em[0]) >> 21) & 0xff)
#define BCM56800_A0_MODPORT_MAP_EMm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).modport_map_em[0]=(((r).modport_map_em[0] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))

/*
 * These macros can be used to access MODPORT_MAP_EM.
 *
 */
#define BCM56800_A0_READ_MODPORT_MAP_EMm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MODPORT_MAP_EMm,i,(m._modport_map_em),1)
#define BCM56800_A0_WRITE_MODPORT_MAP_EMm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MODPORT_MAP_EMm,i,&(m._modport_map_em),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAP_EMm BCM56800_A0_MODPORT_MAP_EMm
#define MODPORT_MAP_EMm_MIN BCM56800_A0_MODPORT_MAP_EMm_MIN
#define MODPORT_MAP_EMm_MAX BCM56800_A0_MODPORT_MAP_EMm_MAX
#define MODPORT_MAP_EMm_CMAX(u) BCM56800_A0_MODPORT_MAP_EMm_CMAX(u)
#define MODPORT_MAP_EMm_SIZE BCM56800_A0_MODPORT_MAP_EMm_SIZE
typedef BCM56800_A0_MODPORT_MAP_EMm_t MODPORT_MAP_EMm_t;
#define MODPORT_MAP_EMm_CLR BCM56800_A0_MODPORT_MAP_EMm_CLR
#define MODPORT_MAP_EMm_SET BCM56800_A0_MODPORT_MAP_EMm_SET
#define MODPORT_MAP_EMm_GET BCM56800_A0_MODPORT_MAP_EMm_GET
#define MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_GET BCM56800_A0_MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_SET BCM56800_A0_MODPORT_MAP_EMm_HIGIG_PORT_BITMAPf_SET
#define MODPORT_MAP_EMm_HIGIG_TRUNK_OVERRIDEf_GET BCM56800_A0_MODPORT_MAP_EMm_HIGIG_TRUNK_OVERRIDEf_GET
#define MODPORT_MAP_EMm_HIGIG_TRUNK_OVERRIDEf_SET BCM56800_A0_MODPORT_MAP_EMm_HIGIG_TRUNK_OVERRIDEf_SET
#define READ_MODPORT_MAP_EMm BCM56800_A0_READ_MODPORT_MAP_EMm
#define WRITE_MODPORT_MAP_EMm BCM56800_A0_WRITE_MODPORT_MAP_EMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MODPORT_MAP_EMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MODPORT_MAP_IM
 * BLOCKS:   IPIPE
 * DESC:     Second physical copy of Module Port Mapping Table - used for mapping the ingress mirrored copy of a packet
 * SIZE:     29
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *     HIGIG_TRUNK_OVERRIDE HiGig trunk override
 *
 ******************************************************************************/
#define BCM56800_A0_MODPORT_MAP_IMm 0x0e1b1000

#define BCM56800_A0_MODPORT_MAP_IMm_MIN 0
#define BCM56800_A0_MODPORT_MAP_IMm_MAX 2687
#define BCM56800_A0_MODPORT_MAP_IMm_CMAX(u) 2687
#define BCM56800_A0_MODPORT_MAP_IMm_SIZE 4

/*
 * This structure should be used to declare and program MODPORT_MAP_IM.
 *
 */
typedef union BCM56800_A0_MODPORT_MAP_IMm_s {
	uint32_t v[1];
	uint32_t modport_map_im[1];
	uint32_t _modport_map_im;
} BCM56800_A0_MODPORT_MAP_IMm_t;

#define BCM56800_A0_MODPORT_MAP_IMm_CLR(r) (r).modport_map_im[0] = 0
#define BCM56800_A0_MODPORT_MAP_IMm_SET(r,d) (r).modport_map_im[0] = d
#define BCM56800_A0_MODPORT_MAP_IMm_GET(r) (r).modport_map_im[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map_im[0]) & 0x1fffff)
#define BCM56800_A0_MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map_im[0]=(((r).modport_map_im[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM56800_A0_MODPORT_MAP_IMm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).modport_map_im[0]) >> 21) & 0xff)
#define BCM56800_A0_MODPORT_MAP_IMm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).modport_map_im[0]=(((r).modport_map_im[0] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))

/*
 * These macros can be used to access MODPORT_MAP_IM.
 *
 */
#define BCM56800_A0_READ_MODPORT_MAP_IMm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MODPORT_MAP_IMm,i,(m._modport_map_im),1)
#define BCM56800_A0_WRITE_MODPORT_MAP_IMm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MODPORT_MAP_IMm,i,&(m._modport_map_im),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAP_IMm BCM56800_A0_MODPORT_MAP_IMm
#define MODPORT_MAP_IMm_MIN BCM56800_A0_MODPORT_MAP_IMm_MIN
#define MODPORT_MAP_IMm_MAX BCM56800_A0_MODPORT_MAP_IMm_MAX
#define MODPORT_MAP_IMm_CMAX(u) BCM56800_A0_MODPORT_MAP_IMm_CMAX(u)
#define MODPORT_MAP_IMm_SIZE BCM56800_A0_MODPORT_MAP_IMm_SIZE
typedef BCM56800_A0_MODPORT_MAP_IMm_t MODPORT_MAP_IMm_t;
#define MODPORT_MAP_IMm_CLR BCM56800_A0_MODPORT_MAP_IMm_CLR
#define MODPORT_MAP_IMm_SET BCM56800_A0_MODPORT_MAP_IMm_SET
#define MODPORT_MAP_IMm_GET BCM56800_A0_MODPORT_MAP_IMm_GET
#define MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_GET BCM56800_A0_MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_SET BCM56800_A0_MODPORT_MAP_IMm_HIGIG_PORT_BITMAPf_SET
#define MODPORT_MAP_IMm_HIGIG_TRUNK_OVERRIDEf_GET BCM56800_A0_MODPORT_MAP_IMm_HIGIG_TRUNK_OVERRIDEf_GET
#define MODPORT_MAP_IMm_HIGIG_TRUNK_OVERRIDEf_SET BCM56800_A0_MODPORT_MAP_IMm_HIGIG_TRUNK_OVERRIDEf_SET
#define READ_MODPORT_MAP_IMm BCM56800_A0_READ_MODPORT_MAP_IMm
#define WRITE_MODPORT_MAP_IMm BCM56800_A0_WRITE_MODPORT_MAP_IMm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MODPORT_MAP_IMm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  MODPORT_MAP_SW
 * BLOCKS:   IPIPE
 * DESC:     First physical copy of Module Port Mapping Table - used for mapping the switched copy of a packet
 * SIZE:     29
 * FIELDS:
 *     HIGIG_PORT_BITMAP HiGig destination port bitmap
 *     HIGIG_TRUNK_OVERRIDE HiGig trunk override
 *
 ******************************************************************************/
#define BCM56800_A0_MODPORT_MAP_SWm 0x0e1b0000

#define BCM56800_A0_MODPORT_MAP_SWm_MIN 0
#define BCM56800_A0_MODPORT_MAP_SWm_MAX 2687
#define BCM56800_A0_MODPORT_MAP_SWm_CMAX(u) 2687
#define BCM56800_A0_MODPORT_MAP_SWm_SIZE 4

/*
 * This structure should be used to declare and program MODPORT_MAP_SW.
 *
 */
typedef union BCM56800_A0_MODPORT_MAP_SWm_s {
	uint32_t v[1];
	uint32_t modport_map_sw[1];
	uint32_t _modport_map_sw;
} BCM56800_A0_MODPORT_MAP_SWm_t;

#define BCM56800_A0_MODPORT_MAP_SWm_CLR(r) (r).modport_map_sw[0] = 0
#define BCM56800_A0_MODPORT_MAP_SWm_SET(r,d) (r).modport_map_sw[0] = d
#define BCM56800_A0_MODPORT_MAP_SWm_GET(r) (r).modport_map_sw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_GET(r) (((r).modport_map_sw[0]) & 0x1fffff)
#define BCM56800_A0_MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_SET(r,f) (r).modport_map_sw[0]=(((r).modport_map_sw[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM56800_A0_MODPORT_MAP_SWm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).modport_map_sw[0]) >> 21) & 0xff)
#define BCM56800_A0_MODPORT_MAP_SWm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).modport_map_sw[0]=(((r).modport_map_sw[0] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))

/*
 * These macros can be used to access MODPORT_MAP_SW.
 *
 */
#define BCM56800_A0_READ_MODPORT_MAP_SWm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_MODPORT_MAP_SWm,i,(m._modport_map_sw),1)
#define BCM56800_A0_WRITE_MODPORT_MAP_SWm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_MODPORT_MAP_SWm,i,&(m._modport_map_sw),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODPORT_MAP_SWm BCM56800_A0_MODPORT_MAP_SWm
#define MODPORT_MAP_SWm_MIN BCM56800_A0_MODPORT_MAP_SWm_MIN
#define MODPORT_MAP_SWm_MAX BCM56800_A0_MODPORT_MAP_SWm_MAX
#define MODPORT_MAP_SWm_CMAX(u) BCM56800_A0_MODPORT_MAP_SWm_CMAX(u)
#define MODPORT_MAP_SWm_SIZE BCM56800_A0_MODPORT_MAP_SWm_SIZE
typedef BCM56800_A0_MODPORT_MAP_SWm_t MODPORT_MAP_SWm_t;
#define MODPORT_MAP_SWm_CLR BCM56800_A0_MODPORT_MAP_SWm_CLR
#define MODPORT_MAP_SWm_SET BCM56800_A0_MODPORT_MAP_SWm_SET
#define MODPORT_MAP_SWm_GET BCM56800_A0_MODPORT_MAP_SWm_GET
#define MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_GET BCM56800_A0_MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_GET
#define MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_SET BCM56800_A0_MODPORT_MAP_SWm_HIGIG_PORT_BITMAPf_SET
#define MODPORT_MAP_SWm_HIGIG_TRUNK_OVERRIDEf_GET BCM56800_A0_MODPORT_MAP_SWm_HIGIG_TRUNK_OVERRIDEf_GET
#define MODPORT_MAP_SWm_HIGIG_TRUNK_OVERRIDEf_SET BCM56800_A0_MODPORT_MAP_SWm_HIGIG_TRUNK_OVERRIDEf_SET
#define READ_MODPORT_MAP_SWm BCM56800_A0_READ_MODPORT_MAP_SWm
#define WRITE_MODPORT_MAP_SWm BCM56800_A0_WRITE_MODPORT_MAP_SWm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MODPORT_MAP_SWm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MTRI_CONFIG
 * BLOCKS:   MMU
 * DESC:     Specifies control fields for MTRI bucket
 * SIZE:     32
 * FIELDS:
 *     PACKET_IFG_BYTES Number of Preamble and IFG bytes to be added to the MTRI bucket,whenever the cell is an eop (as indicated by ENQ).
 *     BKT_UPDATE_SEL_BMP This bitmap has a bit for each port. If the bit for a port is set, the metering bucket for that port will not be incremented when the Discard flag is set for that port.
 *
 ******************************************************************************/
#define BCM56800_A0_MTRI_CONFIGr 0x09d80002

#define BCM56800_A0_MTRI_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MTRI_CONFIG.
 *
 */
typedef union BCM56800_A0_MTRI_CONFIGr_s {
	uint32_t v[1];
	uint32_t mtri_config[1];
	uint32_t _mtri_config;
} BCM56800_A0_MTRI_CONFIGr_t;

#define BCM56800_A0_MTRI_CONFIGr_CLR(r) (r).mtri_config[0] = 0
#define BCM56800_A0_MTRI_CONFIGr_SET(r,d) (r).mtri_config[0] = d
#define BCM56800_A0_MTRI_CONFIGr_GET(r) (r).mtri_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MTRI_CONFIGr_PACKET_IFG_BYTESf_GET(r) (((r).mtri_config[0]) & 0x1f)
#define BCM56800_A0_MTRI_CONFIGr_PACKET_IFG_BYTESf_SET(r,f) (r).mtri_config[0]=(((r).mtri_config[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_MTRI_CONFIGr_BKT_UPDATE_SEL_BMPf_GET(r) ((((r).mtri_config[0]) >> 5) & 0x1fffff)
#define BCM56800_A0_MTRI_CONFIGr_BKT_UPDATE_SEL_BMPf_SET(r,f) (r).mtri_config[0]=(((r).mtri_config[0] & ~((uint32_t)0x1fffff << 5)) | ((((uint32_t)f) & 0x1fffff) << 5))

/*
 * These macros can be used to access MTRI_CONFIG.
 *
 */
#define BCM56800_A0_READ_MTRI_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MTRI_CONFIGr,(r._mtri_config))
#define BCM56800_A0_WRITE_MTRI_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MTRI_CONFIGr,&(r._mtri_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MTRI_CONFIGr BCM56800_A0_MTRI_CONFIGr
#define MTRI_CONFIGr_SIZE BCM56800_A0_MTRI_CONFIGr_SIZE
typedef BCM56800_A0_MTRI_CONFIGr_t MTRI_CONFIGr_t;
#define MTRI_CONFIGr_CLR BCM56800_A0_MTRI_CONFIGr_CLR
#define MTRI_CONFIGr_SET BCM56800_A0_MTRI_CONFIGr_SET
#define MTRI_CONFIGr_GET BCM56800_A0_MTRI_CONFIGr_GET
#define MTRI_CONFIGr_PACKET_IFG_BYTESf_GET BCM56800_A0_MTRI_CONFIGr_PACKET_IFG_BYTESf_GET
#define MTRI_CONFIGr_PACKET_IFG_BYTESf_SET BCM56800_A0_MTRI_CONFIGr_PACKET_IFG_BYTESf_SET
#define MTRI_CONFIGr_BKT_UPDATE_SEL_BMPf_GET BCM56800_A0_MTRI_CONFIGr_BKT_UPDATE_SEL_BMPf_GET
#define MTRI_CONFIGr_BKT_UPDATE_SEL_BMPf_SET BCM56800_A0_MTRI_CONFIGr_BKT_UPDATE_SEL_BMPf_SET
#define READ_MTRI_CONFIGr BCM56800_A0_READ_MTRI_CONFIGr
#define WRITE_MTRI_CONFIGr BCM56800_A0_WRITE_MTRI_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MTRI_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  MTRO_CONFIG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     AGGRESSIVE       Use aggressive setting for MTRO slot mechanism.
 *
 ******************************************************************************/
#define BCM56800_A0_MTRO_CONFIGr 0x0ad80028

#define BCM56800_A0_MTRO_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program MTRO_CONFIG.
 *
 */
typedef union BCM56800_A0_MTRO_CONFIGr_s {
	uint32_t v[1];
	uint32_t mtro_config[1];
	uint32_t _mtro_config;
} BCM56800_A0_MTRO_CONFIGr_t;

#define BCM56800_A0_MTRO_CONFIGr_CLR(r) (r).mtro_config[0] = 0
#define BCM56800_A0_MTRO_CONFIGr_SET(r,d) (r).mtro_config[0] = d
#define BCM56800_A0_MTRO_CONFIGr_GET(r) (r).mtro_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_MTRO_CONFIGr_AGGRESSIVEf_GET(r) (((r).mtro_config[0]) & 0x1)
#define BCM56800_A0_MTRO_CONFIGr_AGGRESSIVEf_SET(r,f) (r).mtro_config[0]=(((r).mtro_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access MTRO_CONFIG.
 *
 */
#define BCM56800_A0_READ_MTRO_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_MTRO_CONFIGr,(r._mtro_config))
#define BCM56800_A0_WRITE_MTRO_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_MTRO_CONFIGr,&(r._mtro_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MTRO_CONFIGr BCM56800_A0_MTRO_CONFIGr
#define MTRO_CONFIGr_SIZE BCM56800_A0_MTRO_CONFIGr_SIZE
typedef BCM56800_A0_MTRO_CONFIGr_t MTRO_CONFIGr_t;
#define MTRO_CONFIGr_CLR BCM56800_A0_MTRO_CONFIGr_CLR
#define MTRO_CONFIGr_SET BCM56800_A0_MTRO_CONFIGr_SET
#define MTRO_CONFIGr_GET BCM56800_A0_MTRO_CONFIGr_GET
#define MTRO_CONFIGr_AGGRESSIVEf_GET BCM56800_A0_MTRO_CONFIGr_AGGRESSIVEf_GET
#define MTRO_CONFIGr_AGGRESSIVEf_SET BCM56800_A0_MTRO_CONFIGr_AGGRESSIVEf_SET
#define READ_MTRO_CONFIGr BCM56800_A0_READ_MTRO_CONFIGr
#define WRITE_MTRO_CONFIGr BCM56800_A0_WRITE_MTRO_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_MTRO_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  NONUCAST_TRUNK_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Multicast and Broadcast Trunk Block Mask Table
 * SIZE:     21
 * FIELDS:
 *     BLOCK_MASK       Multicast/broadcast trunk block mask
 *
 ******************************************************************************/
#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm 0x0e166000

#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_MIN 0
#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_MAX 15
#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) 15
#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_SIZE 3

/*
 * This structure should be used to declare and program NONUCAST_TRUNK_BLOCK_MASK.
 *
 */
typedef union BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_s {
	uint32_t v[1];
	uint32_t nonucast_trunk_block_mask[1];
	uint32_t _nonucast_trunk_block_mask;
} BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_t;

#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_CLR(r) (r).nonucast_trunk_block_mask[0] = 0
#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_SET(r,d) (r).nonucast_trunk_block_mask[0] = d
#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_GET(r) (r).nonucast_trunk_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET(r) (((r).nonucast_trunk_block_mask[0]) & 0x1fffff)
#define BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET(r,f) (r).nonucast_trunk_block_mask[0]=(((r).nonucast_trunk_block_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access NONUCAST_TRUNK_BLOCK_MASK.
 *
 */
#define BCM56800_A0_READ_NONUCAST_TRUNK_BLOCK_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm,i,(m._nonucast_trunk_block_mask),1)
#define BCM56800_A0_WRITE_NONUCAST_TRUNK_BLOCK_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm,i,&(m._nonucast_trunk_block_mask),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NONUCAST_TRUNK_BLOCK_MASKm BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm
#define NONUCAST_TRUNK_BLOCK_MASKm_MIN BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_MIN
#define NONUCAST_TRUNK_BLOCK_MASKm_MAX BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_MAX
#define NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u) BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_CMAX(u)
#define NONUCAST_TRUNK_BLOCK_MASKm_SIZE BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_SIZE
typedef BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_t NONUCAST_TRUNK_BLOCK_MASKm_t;
#define NONUCAST_TRUNK_BLOCK_MASKm_CLR BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_CLR
#define NONUCAST_TRUNK_BLOCK_MASKm_SET BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_SET
#define NONUCAST_TRUNK_BLOCK_MASKm_GET BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_GET
#define NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm_BLOCK_MASKf_SET
#define READ_NONUCAST_TRUNK_BLOCK_MASKm BCM56800_A0_READ_NONUCAST_TRUNK_BLOCK_MASKm
#define WRITE_NONUCAST_TRUNK_BLOCK_MASKm BCM56800_A0_WRITE_NONUCAST_TRUNK_BLOCK_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_NONUCAST_TRUNK_BLOCK_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_BUFFER_SHARED_COUNT
 * BLOCKS:   MMU
 * DESC:     OP_BUFFER_SHARED_COUNT
 * SIZE:     32
 * FIELDS:
 *     OP_BUFFER_SHARED_COUNT the total number of "shared" cells currently used by all output ports and queues from the output port perspective.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_BUFFER_SHARED_COUNTr 0x03d80020

#define BCM56800_A0_OP_BUFFER_SHARED_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program OP_BUFFER_SHARED_COUNT.
 *
 */
typedef union BCM56800_A0_OP_BUFFER_SHARED_COUNTr_s {
	uint32_t v[1];
	uint32_t op_buffer_shared_count[1];
	uint32_t _op_buffer_shared_count;
} BCM56800_A0_OP_BUFFER_SHARED_COUNTr_t;

#define BCM56800_A0_OP_BUFFER_SHARED_COUNTr_CLR(r) (r).op_buffer_shared_count[0] = 0
#define BCM56800_A0_OP_BUFFER_SHARED_COUNTr_SET(r,d) (r).op_buffer_shared_count[0] = d
#define BCM56800_A0_OP_BUFFER_SHARED_COUNTr_GET(r) (r).op_buffer_shared_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_BUFFER_SHARED_COUNTr_OP_BUFFER_SHARED_COUNTf_GET(r) (((r).op_buffer_shared_count[0]) & 0x3fff)
#define BCM56800_A0_OP_BUFFER_SHARED_COUNTr_OP_BUFFER_SHARED_COUNTf_SET(r,f) (r).op_buffer_shared_count[0]=(((r).op_buffer_shared_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access OP_BUFFER_SHARED_COUNT.
 *
 */
#define BCM56800_A0_READ_OP_BUFFER_SHARED_COUNTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_OP_BUFFER_SHARED_COUNTr,(r._op_buffer_shared_count))
#define BCM56800_A0_WRITE_OP_BUFFER_SHARED_COUNTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_OP_BUFFER_SHARED_COUNTr,&(r._op_buffer_shared_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_BUFFER_SHARED_COUNTr BCM56800_A0_OP_BUFFER_SHARED_COUNTr
#define OP_BUFFER_SHARED_COUNTr_SIZE BCM56800_A0_OP_BUFFER_SHARED_COUNTr_SIZE
typedef BCM56800_A0_OP_BUFFER_SHARED_COUNTr_t OP_BUFFER_SHARED_COUNTr_t;
#define OP_BUFFER_SHARED_COUNTr_CLR BCM56800_A0_OP_BUFFER_SHARED_COUNTr_CLR
#define OP_BUFFER_SHARED_COUNTr_SET BCM56800_A0_OP_BUFFER_SHARED_COUNTr_SET
#define OP_BUFFER_SHARED_COUNTr_GET BCM56800_A0_OP_BUFFER_SHARED_COUNTr_GET
#define OP_BUFFER_SHARED_COUNTr_OP_BUFFER_SHARED_COUNTf_GET BCM56800_A0_OP_BUFFER_SHARED_COUNTr_OP_BUFFER_SHARED_COUNTf_GET
#define OP_BUFFER_SHARED_COUNTr_OP_BUFFER_SHARED_COUNTf_SET BCM56800_A0_OP_BUFFER_SHARED_COUNTr_OP_BUFFER_SHARED_COUNTf_SET
#define READ_OP_BUFFER_SHARED_COUNTr BCM56800_A0_READ_OP_BUFFER_SHARED_COUNTr
#define WRITE_OP_BUFFER_SHARED_COUNTr BCM56800_A0_WRITE_OP_BUFFER_SHARED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_BUFFER_SHARED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_BUFFER_SHARED_LIMIT
 * BLOCKS:   MMU
 * DESC:     OP_BUFFER_SHARED_LIMIT
 * SIZE:     32
 * FIELDS:
 *     OP_BUFFER_SHARED_LIMIT Programmed by software with the total shared cells available after taking out all the guaranteed minimum cellsassigned to all the queues and any holdback needed.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_BUFFER_SHARED_LIMITr 0x03d80000

#define BCM56800_A0_OP_BUFFER_SHARED_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program OP_BUFFER_SHARED_LIMIT.
 *
 */
typedef union BCM56800_A0_OP_BUFFER_SHARED_LIMITr_s {
	uint32_t v[1];
	uint32_t op_buffer_shared_limit[1];
	uint32_t _op_buffer_shared_limit;
} BCM56800_A0_OP_BUFFER_SHARED_LIMITr_t;

#define BCM56800_A0_OP_BUFFER_SHARED_LIMITr_CLR(r) (r).op_buffer_shared_limit[0] = 0
#define BCM56800_A0_OP_BUFFER_SHARED_LIMITr_SET(r,d) (r).op_buffer_shared_limit[0] = d
#define BCM56800_A0_OP_BUFFER_SHARED_LIMITr_GET(r) (r).op_buffer_shared_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_BUFFER_SHARED_LIMITr_OP_BUFFER_SHARED_LIMITf_GET(r) (((r).op_buffer_shared_limit[0]) & 0x3fff)
#define BCM56800_A0_OP_BUFFER_SHARED_LIMITr_OP_BUFFER_SHARED_LIMITf_SET(r,f) (r).op_buffer_shared_limit[0]=(((r).op_buffer_shared_limit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access OP_BUFFER_SHARED_LIMIT.
 *
 */
#define BCM56800_A0_READ_OP_BUFFER_SHARED_LIMITr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_OP_BUFFER_SHARED_LIMITr,(r._op_buffer_shared_limit))
#define BCM56800_A0_WRITE_OP_BUFFER_SHARED_LIMITr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_OP_BUFFER_SHARED_LIMITr,&(r._op_buffer_shared_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_BUFFER_SHARED_LIMITr BCM56800_A0_OP_BUFFER_SHARED_LIMITr
#define OP_BUFFER_SHARED_LIMITr_SIZE BCM56800_A0_OP_BUFFER_SHARED_LIMITr_SIZE
typedef BCM56800_A0_OP_BUFFER_SHARED_LIMITr_t OP_BUFFER_SHARED_LIMITr_t;
#define OP_BUFFER_SHARED_LIMITr_CLR BCM56800_A0_OP_BUFFER_SHARED_LIMITr_CLR
#define OP_BUFFER_SHARED_LIMITr_SET BCM56800_A0_OP_BUFFER_SHARED_LIMITr_SET
#define OP_BUFFER_SHARED_LIMITr_GET BCM56800_A0_OP_BUFFER_SHARED_LIMITr_GET
#define OP_BUFFER_SHARED_LIMITr_OP_BUFFER_SHARED_LIMITf_GET BCM56800_A0_OP_BUFFER_SHARED_LIMITr_OP_BUFFER_SHARED_LIMITf_GET
#define OP_BUFFER_SHARED_LIMITr_OP_BUFFER_SHARED_LIMITf_SET BCM56800_A0_OP_BUFFER_SHARED_LIMITr_OP_BUFFER_SHARED_LIMITf_SET
#define READ_OP_BUFFER_SHARED_LIMITr BCM56800_A0_READ_OP_BUFFER_SHARED_LIMITr
#define WRITE_OP_BUFFER_SHARED_LIMITr BCM56800_A0_WRITE_OP_BUFFER_SHARED_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_BUFFER_SHARED_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_BUFFER_TOTAL_COUNT
 * BLOCKS:   MMU
 * DESC:     OP_BUFFER_TOTAL_COUNT
 * SIZE:     32
 * FIELDS:
 *     OP_BUFFER_TOTAL_COUNT the total number of cells (both min and shared) currently used by all output ports and queues from the output port perspective. Value in cells. Reset to zero. This register is not used in any threshold calculation, but is provided as a diagnostic tool.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_BUFFER_TOTAL_COUNTr 0x03d80021

#define BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program OP_BUFFER_TOTAL_COUNT.
 *
 */
typedef union BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_s {
	uint32_t v[1];
	uint32_t op_buffer_total_count[1];
	uint32_t _op_buffer_total_count;
} BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_t;

#define BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_CLR(r) (r).op_buffer_total_count[0] = 0
#define BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_SET(r,d) (r).op_buffer_total_count[0] = d
#define BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_GET(r) (r).op_buffer_total_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_OP_BUFFER_TOTAL_COUNTf_GET(r) (((r).op_buffer_total_count[0]) & 0x3fff)
#define BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_OP_BUFFER_TOTAL_COUNTf_SET(r,f) (r).op_buffer_total_count[0]=(((r).op_buffer_total_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access OP_BUFFER_TOTAL_COUNT.
 *
 */
#define BCM56800_A0_READ_OP_BUFFER_TOTAL_COUNTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_OP_BUFFER_TOTAL_COUNTr,(r._op_buffer_total_count))
#define BCM56800_A0_WRITE_OP_BUFFER_TOTAL_COUNTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_OP_BUFFER_TOTAL_COUNTr,&(r._op_buffer_total_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_BUFFER_TOTAL_COUNTr BCM56800_A0_OP_BUFFER_TOTAL_COUNTr
#define OP_BUFFER_TOTAL_COUNTr_SIZE BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_SIZE
typedef BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_t OP_BUFFER_TOTAL_COUNTr_t;
#define OP_BUFFER_TOTAL_COUNTr_CLR BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_CLR
#define OP_BUFFER_TOTAL_COUNTr_SET BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_SET
#define OP_BUFFER_TOTAL_COUNTr_GET BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_GET
#define OP_BUFFER_TOTAL_COUNTr_OP_BUFFER_TOTAL_COUNTf_GET BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_OP_BUFFER_TOTAL_COUNTf_GET
#define OP_BUFFER_TOTAL_COUNTr_OP_BUFFER_TOTAL_COUNTf_SET BCM56800_A0_OP_BUFFER_TOTAL_COUNTr_OP_BUFFER_TOTAL_COUNTf_SET
#define READ_OP_BUFFER_TOTAL_COUNTr BCM56800_A0_READ_OP_BUFFER_TOTAL_COUNTr
#define WRITE_OP_BUFFER_TOTAL_COUNTr BCM56800_A0_WRITE_OP_BUFFER_TOTAL_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_BUFFER_TOTAL_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_PORT_CONFIG
 * BLOCKS:   MMU
 * DESC:     OP_PORT_CONFIG
 * SIZE:     32
 * FIELDS:
 *     OP_SHARED_LIMIT  initialed by software with a total limit on the number of shared cells allowed to be queued to each port (across all output queues of that port).
 *     OP_SHARED_RESET_VALUE This value should be less than the op_shared_limit. It provideshysteresis after reaching the op_shared_limit and before accepting new cells to any queue of the port.
 *     PORT_LIMIT_ENABLE Enable port limit: 0 = do not enforce; 1 = enable enforcement of op_shared_limit. When set to 1, the op_shared_limit must be a non-zero value.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_PORT_CONFIGr 0x03d00003

#define BCM56800_A0_OP_PORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program OP_PORT_CONFIG.
 *
 */
typedef union BCM56800_A0_OP_PORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t op_port_config[1];
	uint32_t _op_port_config;
} BCM56800_A0_OP_PORT_CONFIGr_t;

#define BCM56800_A0_OP_PORT_CONFIGr_CLR(r) (r).op_port_config[0] = 0
#define BCM56800_A0_OP_PORT_CONFIGr_SET(r,d) (r).op_port_config[0] = d
#define BCM56800_A0_OP_PORT_CONFIGr_GET(r) (r).op_port_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_PORT_CONFIGr_OP_SHARED_LIMITf_GET(r) (((r).op_port_config[0]) & 0x3fff)
#define BCM56800_A0_OP_PORT_CONFIGr_OP_SHARED_LIMITf_SET(r,f) (r).op_port_config[0]=(((r).op_port_config[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_OP_PORT_CONFIGr_OP_SHARED_RESET_VALUEf_GET(r) ((((r).op_port_config[0]) >> 14) & 0x3fff)
#define BCM56800_A0_OP_PORT_CONFIGr_OP_SHARED_RESET_VALUEf_SET(r,f) (r).op_port_config[0]=(((r).op_port_config[0] & ~((uint32_t)0x3fff << 14)) | ((((uint32_t)f) & 0x3fff) << 14))
#define BCM56800_A0_OP_PORT_CONFIGr_PORT_LIMIT_ENABLEf_GET(r) ((((r).op_port_config[0]) >> 28) & 0x1)
#define BCM56800_A0_OP_PORT_CONFIGr_PORT_LIMIT_ENABLEf_SET(r,f) (r).op_port_config[0]=(((r).op_port_config[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))

/*
 * These macros can be used to access OP_PORT_CONFIG.
 *
 */
#define BCM56800_A0_READ_OP_PORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_OP_PORT_CONFIGr,(r._op_port_config))
#define BCM56800_A0_WRITE_OP_PORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_OP_PORT_CONFIGr,&(r._op_port_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_PORT_CONFIGr BCM56800_A0_OP_PORT_CONFIGr
#define OP_PORT_CONFIGr_SIZE BCM56800_A0_OP_PORT_CONFIGr_SIZE
typedef BCM56800_A0_OP_PORT_CONFIGr_t OP_PORT_CONFIGr_t;
#define OP_PORT_CONFIGr_CLR BCM56800_A0_OP_PORT_CONFIGr_CLR
#define OP_PORT_CONFIGr_SET BCM56800_A0_OP_PORT_CONFIGr_SET
#define OP_PORT_CONFIGr_GET BCM56800_A0_OP_PORT_CONFIGr_GET
#define OP_PORT_CONFIGr_OP_SHARED_LIMITf_GET BCM56800_A0_OP_PORT_CONFIGr_OP_SHARED_LIMITf_GET
#define OP_PORT_CONFIGr_OP_SHARED_LIMITf_SET BCM56800_A0_OP_PORT_CONFIGr_OP_SHARED_LIMITf_SET
#define OP_PORT_CONFIGr_OP_SHARED_RESET_VALUEf_GET BCM56800_A0_OP_PORT_CONFIGr_OP_SHARED_RESET_VALUEf_GET
#define OP_PORT_CONFIGr_OP_SHARED_RESET_VALUEf_SET BCM56800_A0_OP_PORT_CONFIGr_OP_SHARED_RESET_VALUEf_SET
#define OP_PORT_CONFIGr_PORT_LIMIT_ENABLEf_GET BCM56800_A0_OP_PORT_CONFIGr_PORT_LIMIT_ENABLEf_GET
#define OP_PORT_CONFIGr_PORT_LIMIT_ENABLEf_SET BCM56800_A0_OP_PORT_CONFIGr_PORT_LIMIT_ENABLEf_SET
#define READ_OP_PORT_CONFIGr BCM56800_A0_READ_OP_PORT_CONFIGr
#define WRITE_OP_PORT_CONFIGr BCM56800_A0_WRITE_OP_PORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_PORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_PORT_DROP_STATE_BMP
 * BLOCKS:   MMU
 * DESC:     OP_PORT_DROP_STATE_BMP
 * SIZE:     32
 * FIELDS:
 *     OP_PORT_DROP_STATE_BMP drop_state. 0 = queue is accepting (under threshold), 1 = queue is dropping (reached threshold).
 *
 ******************************************************************************/
#define BCM56800_A0_OP_PORT_DROP_STATE_BMPr 0x03d80060

#define BCM56800_A0_OP_PORT_DROP_STATE_BMPr_SIZE 4

/*
 * This structure should be used to declare and program OP_PORT_DROP_STATE_BMP.
 *
 */
typedef union BCM56800_A0_OP_PORT_DROP_STATE_BMPr_s {
	uint32_t v[1];
	uint32_t op_port_drop_state_bmp[1];
	uint32_t _op_port_drop_state_bmp;
} BCM56800_A0_OP_PORT_DROP_STATE_BMPr_t;

#define BCM56800_A0_OP_PORT_DROP_STATE_BMPr_CLR(r) (r).op_port_drop_state_bmp[0] = 0
#define BCM56800_A0_OP_PORT_DROP_STATE_BMPr_SET(r,d) (r).op_port_drop_state_bmp[0] = d
#define BCM56800_A0_OP_PORT_DROP_STATE_BMPr_GET(r) (r).op_port_drop_state_bmp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_PORT_DROP_STATE_BMPr_OP_PORT_DROP_STATE_BMPf_GET(r) (((r).op_port_drop_state_bmp[0]) & 0x1fffff)
#define BCM56800_A0_OP_PORT_DROP_STATE_BMPr_OP_PORT_DROP_STATE_BMPf_SET(r,f) (r).op_port_drop_state_bmp[0]=(((r).op_port_drop_state_bmp[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access OP_PORT_DROP_STATE_BMP.
 *
 */
#define BCM56800_A0_READ_OP_PORT_DROP_STATE_BMPr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_OP_PORT_DROP_STATE_BMPr,(r._op_port_drop_state_bmp))
#define BCM56800_A0_WRITE_OP_PORT_DROP_STATE_BMPr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_OP_PORT_DROP_STATE_BMPr,&(r._op_port_drop_state_bmp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_PORT_DROP_STATE_BMPr BCM56800_A0_OP_PORT_DROP_STATE_BMPr
#define OP_PORT_DROP_STATE_BMPr_SIZE BCM56800_A0_OP_PORT_DROP_STATE_BMPr_SIZE
typedef BCM56800_A0_OP_PORT_DROP_STATE_BMPr_t OP_PORT_DROP_STATE_BMPr_t;
#define OP_PORT_DROP_STATE_BMPr_CLR BCM56800_A0_OP_PORT_DROP_STATE_BMPr_CLR
#define OP_PORT_DROP_STATE_BMPr_SET BCM56800_A0_OP_PORT_DROP_STATE_BMPr_SET
#define OP_PORT_DROP_STATE_BMPr_GET BCM56800_A0_OP_PORT_DROP_STATE_BMPr_GET
#define OP_PORT_DROP_STATE_BMPr_OP_PORT_DROP_STATE_BMPf_GET BCM56800_A0_OP_PORT_DROP_STATE_BMPr_OP_PORT_DROP_STATE_BMPf_GET
#define OP_PORT_DROP_STATE_BMPr_OP_PORT_DROP_STATE_BMPf_SET BCM56800_A0_OP_PORT_DROP_STATE_BMPr_OP_PORT_DROP_STATE_BMPf_SET
#define READ_OP_PORT_DROP_STATE_BMPr BCM56800_A0_READ_OP_PORT_DROP_STATE_BMPr
#define WRITE_OP_PORT_DROP_STATE_BMPr BCM56800_A0_WRITE_OP_PORT_DROP_STATE_BMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_PORT_DROP_STATE_BMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_PORT_SHARED_COUNT
 * BLOCKS:   MMU
 * DESC:     OP_PORT_SHARED_COUNT
 * SIZE:     32
 * FIELDS:
 *     OP_PORT_SHARED_COUNT the number of "shared" cells currently used by an output port across all of its CoS queues.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_PORT_SHARED_COUNTr 0x03d00022

#define BCM56800_A0_OP_PORT_SHARED_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program OP_PORT_SHARED_COUNT.
 *
 */
typedef union BCM56800_A0_OP_PORT_SHARED_COUNTr_s {
	uint32_t v[1];
	uint32_t op_port_shared_count[1];
	uint32_t _op_port_shared_count;
} BCM56800_A0_OP_PORT_SHARED_COUNTr_t;

#define BCM56800_A0_OP_PORT_SHARED_COUNTr_CLR(r) (r).op_port_shared_count[0] = 0
#define BCM56800_A0_OP_PORT_SHARED_COUNTr_SET(r,d) (r).op_port_shared_count[0] = d
#define BCM56800_A0_OP_PORT_SHARED_COUNTr_GET(r) (r).op_port_shared_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_PORT_SHARED_COUNTr_OP_PORT_SHARED_COUNTf_GET(r) (((r).op_port_shared_count[0]) & 0x3fff)
#define BCM56800_A0_OP_PORT_SHARED_COUNTr_OP_PORT_SHARED_COUNTf_SET(r,f) (r).op_port_shared_count[0]=(((r).op_port_shared_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access OP_PORT_SHARED_COUNT.
 *
 */
#define BCM56800_A0_READ_OP_PORT_SHARED_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_OP_PORT_SHARED_COUNTr,(r._op_port_shared_count))
#define BCM56800_A0_WRITE_OP_PORT_SHARED_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_OP_PORT_SHARED_COUNTr,&(r._op_port_shared_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_PORT_SHARED_COUNTr BCM56800_A0_OP_PORT_SHARED_COUNTr
#define OP_PORT_SHARED_COUNTr_SIZE BCM56800_A0_OP_PORT_SHARED_COUNTr_SIZE
typedef BCM56800_A0_OP_PORT_SHARED_COUNTr_t OP_PORT_SHARED_COUNTr_t;
#define OP_PORT_SHARED_COUNTr_CLR BCM56800_A0_OP_PORT_SHARED_COUNTr_CLR
#define OP_PORT_SHARED_COUNTr_SET BCM56800_A0_OP_PORT_SHARED_COUNTr_SET
#define OP_PORT_SHARED_COUNTr_GET BCM56800_A0_OP_PORT_SHARED_COUNTr_GET
#define OP_PORT_SHARED_COUNTr_OP_PORT_SHARED_COUNTf_GET BCM56800_A0_OP_PORT_SHARED_COUNTr_OP_PORT_SHARED_COUNTf_GET
#define OP_PORT_SHARED_COUNTr_OP_PORT_SHARED_COUNTf_SET BCM56800_A0_OP_PORT_SHARED_COUNTr_OP_PORT_SHARED_COUNTf_SET
#define READ_OP_PORT_SHARED_COUNTr BCM56800_A0_READ_OP_PORT_SHARED_COUNTr
#define WRITE_OP_PORT_SHARED_COUNTr BCM56800_A0_WRITE_OP_PORT_SHARED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_PORT_SHARED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_PORT_TOTAL_COUNT
 * BLOCKS:   MMU
 * DESC:     OP_PORT_TOTAL_COUNT
 * SIZE:     32
 * FIELDS:
 *     OP_PORT_TOTAL_COUNT the number of total cells currently used by an output port across all of its CoS queues.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_PORT_TOTAL_COUNTr 0x03d00023

#define BCM56800_A0_OP_PORT_TOTAL_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program OP_PORT_TOTAL_COUNT.
 *
 */
typedef union BCM56800_A0_OP_PORT_TOTAL_COUNTr_s {
	uint32_t v[1];
	uint32_t op_port_total_count[1];
	uint32_t _op_port_total_count;
} BCM56800_A0_OP_PORT_TOTAL_COUNTr_t;

#define BCM56800_A0_OP_PORT_TOTAL_COUNTr_CLR(r) (r).op_port_total_count[0] = 0
#define BCM56800_A0_OP_PORT_TOTAL_COUNTr_SET(r,d) (r).op_port_total_count[0] = d
#define BCM56800_A0_OP_PORT_TOTAL_COUNTr_GET(r) (r).op_port_total_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_PORT_TOTAL_COUNTr_OP_PORT_TOTAL_COUNTf_GET(r) (((r).op_port_total_count[0]) & 0x3fff)
#define BCM56800_A0_OP_PORT_TOTAL_COUNTr_OP_PORT_TOTAL_COUNTf_SET(r,f) (r).op_port_total_count[0]=(((r).op_port_total_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access OP_PORT_TOTAL_COUNT.
 *
 */
#define BCM56800_A0_READ_OP_PORT_TOTAL_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_OP_PORT_TOTAL_COUNTr,(r._op_port_total_count))
#define BCM56800_A0_WRITE_OP_PORT_TOTAL_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_OP_PORT_TOTAL_COUNTr,&(r._op_port_total_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_PORT_TOTAL_COUNTr BCM56800_A0_OP_PORT_TOTAL_COUNTr
#define OP_PORT_TOTAL_COUNTr_SIZE BCM56800_A0_OP_PORT_TOTAL_COUNTr_SIZE
typedef BCM56800_A0_OP_PORT_TOTAL_COUNTr_t OP_PORT_TOTAL_COUNTr_t;
#define OP_PORT_TOTAL_COUNTr_CLR BCM56800_A0_OP_PORT_TOTAL_COUNTr_CLR
#define OP_PORT_TOTAL_COUNTr_SET BCM56800_A0_OP_PORT_TOTAL_COUNTr_SET
#define OP_PORT_TOTAL_COUNTr_GET BCM56800_A0_OP_PORT_TOTAL_COUNTr_GET
#define OP_PORT_TOTAL_COUNTr_OP_PORT_TOTAL_COUNTf_GET BCM56800_A0_OP_PORT_TOTAL_COUNTr_OP_PORT_TOTAL_COUNTf_GET
#define OP_PORT_TOTAL_COUNTr_OP_PORT_TOTAL_COUNTf_SET BCM56800_A0_OP_PORT_TOTAL_COUNTr_OP_PORT_TOTAL_COUNTf_SET
#define READ_OP_PORT_TOTAL_COUNTr BCM56800_A0_READ_OP_PORT_TOTAL_COUNTr
#define WRITE_OP_PORT_TOTAL_COUNTr BCM56800_A0_WRITE_OP_PORT_TOTAL_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_PORT_TOTAL_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_QUEUE_CONFIG
 * BLOCKS:   MMU
 * DESC:     OP_QUEUE_CONFIG
 * SIZE:     32
 * FIELDS:
 *     Q_SHARED_LIMIT   Note: In MMU, there are 10 queues per output port. Packet Cos 7 to 0 uses Cos 7 to 0 queues, packet Cos 14 uses Cos 8 queue, and packet Cos 15 uses Cos 9 queue.  Packet Cos from 8 to 13 is illegal. Queue Limit: defines the number of shared cells allowed for each queue. It can be eitherStatic threshold is a value in cellsorIndex to the alpha value to use for dynamic threshold. When dynamic thresholds are enabled, the Q_Shared_limit[3:0] are used to select the "alpha" value for thequeue as shown in the following definitions: 0 : 1/321: 1/162: 1/83: 4: 5: 16: 27: 48: 89: 1610: 3211: 6412: 12813: 25614, 15: reserved.
 *     Q_RESET_SEL      This value is used to create the cell drop hysteresis as a percentage of the drop threshold.Values: 8=100%, 7=87.5% (7/8), 6=75% (6/8), 5=62.5% (5/8), 4=50% (4/8),3=37.5% (3/8), 2=25% (2/8) 1=12.5% (1/8), 0= 0% (values of 9-15 are illegal).
 *     Q_MIN            Minimum cells guaranteed for the queue. 
 *     Q_LIMIT_DYNAMIC  Dynamic Control bit0 = this queue uses static q_limit1 = this queue uses dynamic queue threshold
 *     Q_LIMIT_ENABLE   Enable queue discard thresholds. 0 == never drop, the queue will use shared space by default; 1 == use queue thresholds to discard.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_QUEUE_CONFIGr 0x03d00010

#define BCM56800_A0_OP_QUEUE_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program OP_QUEUE_CONFIG.
 *
 */
typedef union BCM56800_A0_OP_QUEUE_CONFIGr_s {
	uint32_t v[1];
	uint32_t op_queue_config[1];
	uint32_t _op_queue_config;
} BCM56800_A0_OP_QUEUE_CONFIGr_t;

#define BCM56800_A0_OP_QUEUE_CONFIGr_CLR(r) (r).op_queue_config[0] = 0
#define BCM56800_A0_OP_QUEUE_CONFIGr_SET(r,d) (r).op_queue_config[0] = d
#define BCM56800_A0_OP_QUEUE_CONFIGr_GET(r) (r).op_queue_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_SHARED_LIMITf_GET(r) (((r).op_queue_config[0]) & 0x3fff)
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_SHARED_LIMITf_SET(r,f) (r).op_queue_config[0]=(((r).op_queue_config[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_RESET_SELf_GET(r) ((((r).op_queue_config[0]) >> 16) & 0xf)
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_RESET_SELf_SET(r,f) (r).op_queue_config[0]=(((r).op_queue_config[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_MINf_GET(r) ((((r).op_queue_config[0]) >> 20) & 0x3ff)
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_MINf_SET(r,f) (r).op_queue_config[0]=(((r).op_queue_config[0] & ~((uint32_t)0x3ff << 20)) | ((((uint32_t)f) & 0x3ff) << 20))
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_LIMIT_DYNAMICf_GET(r) ((((r).op_queue_config[0]) >> 30) & 0x1)
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_LIMIT_DYNAMICf_SET(r,f) (r).op_queue_config[0]=(((r).op_queue_config[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_LIMIT_ENABLEf_GET(r) ((((r).op_queue_config[0]) >> 31) & 0x1)
#define BCM56800_A0_OP_QUEUE_CONFIGr_Q_LIMIT_ENABLEf_SET(r,f) (r).op_queue_config[0]=(((r).op_queue_config[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access OP_QUEUE_CONFIG.
 *
 */
#define BCM56800_A0_READ_OP_QUEUE_CONFIGr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_OP_QUEUE_CONFIGr+(i),(r._op_queue_config))
#define BCM56800_A0_WRITE_OP_QUEUE_CONFIGr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_OP_QUEUE_CONFIGr+(i),&(r._op_queue_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_QUEUE_CONFIGr BCM56800_A0_OP_QUEUE_CONFIGr
#define OP_QUEUE_CONFIGr_SIZE BCM56800_A0_OP_QUEUE_CONFIGr_SIZE
typedef BCM56800_A0_OP_QUEUE_CONFIGr_t OP_QUEUE_CONFIGr_t;
#define OP_QUEUE_CONFIGr_CLR BCM56800_A0_OP_QUEUE_CONFIGr_CLR
#define OP_QUEUE_CONFIGr_SET BCM56800_A0_OP_QUEUE_CONFIGr_SET
#define OP_QUEUE_CONFIGr_GET BCM56800_A0_OP_QUEUE_CONFIGr_GET
#define OP_QUEUE_CONFIGr_Q_SHARED_LIMITf_GET BCM56800_A0_OP_QUEUE_CONFIGr_Q_SHARED_LIMITf_GET
#define OP_QUEUE_CONFIGr_Q_SHARED_LIMITf_SET BCM56800_A0_OP_QUEUE_CONFIGr_Q_SHARED_LIMITf_SET
#define OP_QUEUE_CONFIGr_Q_RESET_SELf_GET BCM56800_A0_OP_QUEUE_CONFIGr_Q_RESET_SELf_GET
#define OP_QUEUE_CONFIGr_Q_RESET_SELf_SET BCM56800_A0_OP_QUEUE_CONFIGr_Q_RESET_SELf_SET
#define OP_QUEUE_CONFIGr_Q_MINf_GET BCM56800_A0_OP_QUEUE_CONFIGr_Q_MINf_GET
#define OP_QUEUE_CONFIGr_Q_MINf_SET BCM56800_A0_OP_QUEUE_CONFIGr_Q_MINf_SET
#define OP_QUEUE_CONFIGr_Q_LIMIT_DYNAMICf_GET BCM56800_A0_OP_QUEUE_CONFIGr_Q_LIMIT_DYNAMICf_GET
#define OP_QUEUE_CONFIGr_Q_LIMIT_DYNAMICf_SET BCM56800_A0_OP_QUEUE_CONFIGr_Q_LIMIT_DYNAMICf_SET
#define OP_QUEUE_CONFIGr_Q_LIMIT_ENABLEf_GET BCM56800_A0_OP_QUEUE_CONFIGr_Q_LIMIT_ENABLEf_GET
#define OP_QUEUE_CONFIGr_Q_LIMIT_ENABLEf_SET BCM56800_A0_OP_QUEUE_CONFIGr_Q_LIMIT_ENABLEf_SET
#define READ_OP_QUEUE_CONFIGr BCM56800_A0_READ_OP_QUEUE_CONFIGr
#define WRITE_OP_QUEUE_CONFIGr BCM56800_A0_WRITE_OP_QUEUE_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_QUEUE_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_QUEUE_MIN_COUNT
 * BLOCKS:   MMU
 * DESC:     OP_QUEUE_MIN_COUNT
 * SIZE:     32
 * FIELDS:
 *     Q_MIN_COUNT      the number of cells currently used by an output queue which are considered part of the queuesminimum guarantee.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_QUEUE_MIN_COUNTr 0x03d00030

#define BCM56800_A0_OP_QUEUE_MIN_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program OP_QUEUE_MIN_COUNT.
 *
 */
typedef union BCM56800_A0_OP_QUEUE_MIN_COUNTr_s {
	uint32_t v[1];
	uint32_t op_queue_min_count[1];
	uint32_t _op_queue_min_count;
} BCM56800_A0_OP_QUEUE_MIN_COUNTr_t;

#define BCM56800_A0_OP_QUEUE_MIN_COUNTr_CLR(r) (r).op_queue_min_count[0] = 0
#define BCM56800_A0_OP_QUEUE_MIN_COUNTr_SET(r,d) (r).op_queue_min_count[0] = d
#define BCM56800_A0_OP_QUEUE_MIN_COUNTr_GET(r) (r).op_queue_min_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_QUEUE_MIN_COUNTr_Q_MIN_COUNTf_GET(r) (((r).op_queue_min_count[0]) & 0x3ff)
#define BCM56800_A0_OP_QUEUE_MIN_COUNTr_Q_MIN_COUNTf_SET(r,f) (r).op_queue_min_count[0]=(((r).op_queue_min_count[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access OP_QUEUE_MIN_COUNT.
 *
 */
#define BCM56800_A0_READ_OP_QUEUE_MIN_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_OP_QUEUE_MIN_COUNTr+(i),(r._op_queue_min_count))
#define BCM56800_A0_WRITE_OP_QUEUE_MIN_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_OP_QUEUE_MIN_COUNTr+(i),&(r._op_queue_min_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_QUEUE_MIN_COUNTr BCM56800_A0_OP_QUEUE_MIN_COUNTr
#define OP_QUEUE_MIN_COUNTr_SIZE BCM56800_A0_OP_QUEUE_MIN_COUNTr_SIZE
typedef BCM56800_A0_OP_QUEUE_MIN_COUNTr_t OP_QUEUE_MIN_COUNTr_t;
#define OP_QUEUE_MIN_COUNTr_CLR BCM56800_A0_OP_QUEUE_MIN_COUNTr_CLR
#define OP_QUEUE_MIN_COUNTr_SET BCM56800_A0_OP_QUEUE_MIN_COUNTr_SET
#define OP_QUEUE_MIN_COUNTr_GET BCM56800_A0_OP_QUEUE_MIN_COUNTr_GET
#define OP_QUEUE_MIN_COUNTr_Q_MIN_COUNTf_GET BCM56800_A0_OP_QUEUE_MIN_COUNTr_Q_MIN_COUNTf_GET
#define OP_QUEUE_MIN_COUNTr_Q_MIN_COUNTf_SET BCM56800_A0_OP_QUEUE_MIN_COUNTr_Q_MIN_COUNTf_SET
#define READ_OP_QUEUE_MIN_COUNTr BCM56800_A0_READ_OP_QUEUE_MIN_COUNTr
#define WRITE_OP_QUEUE_MIN_COUNTr BCM56800_A0_WRITE_OP_QUEUE_MIN_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_QUEUE_MIN_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_QUEUE_RESET_VALUE
 * BLOCKS:   MMU
 * DESC:     OP_QUEUE_RESET_VALUE
 * SIZE:     32
 * FIELDS:
 *     Q_RESET_VALUE    Value (in cells) that q_cell_count needs to drop below to allow new cells (and packets) to be admitted. This providesthe "hysteresis" after the discard threshold is reached. This value is only valid when drop_state=1.
 *     Q_DROP_STATE     drop_state. 0 = queue is accepting (under threshold), 1 = queue is dropping (reached threshold).
 *
 ******************************************************************************/
#define BCM56800_A0_OP_QUEUE_RESET_VALUEr 0x03d00070

#define BCM56800_A0_OP_QUEUE_RESET_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program OP_QUEUE_RESET_VALUE.
 *
 */
typedef union BCM56800_A0_OP_QUEUE_RESET_VALUEr_s {
	uint32_t v[1];
	uint32_t op_queue_reset_value[1];
	uint32_t _op_queue_reset_value;
} BCM56800_A0_OP_QUEUE_RESET_VALUEr_t;

#define BCM56800_A0_OP_QUEUE_RESET_VALUEr_CLR(r) (r).op_queue_reset_value[0] = 0
#define BCM56800_A0_OP_QUEUE_RESET_VALUEr_SET(r,d) (r).op_queue_reset_value[0] = d
#define BCM56800_A0_OP_QUEUE_RESET_VALUEr_GET(r) (r).op_queue_reset_value[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_QUEUE_RESET_VALUEr_Q_RESET_VALUEf_GET(r) (((r).op_queue_reset_value[0]) & 0x3fff)
#define BCM56800_A0_OP_QUEUE_RESET_VALUEr_Q_RESET_VALUEf_SET(r,f) (r).op_queue_reset_value[0]=(((r).op_queue_reset_value[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_OP_QUEUE_RESET_VALUEr_Q_DROP_STATEf_GET(r) ((((r).op_queue_reset_value[0]) >> 14) & 0x1)
#define BCM56800_A0_OP_QUEUE_RESET_VALUEr_Q_DROP_STATEf_SET(r,f) (r).op_queue_reset_value[0]=(((r).op_queue_reset_value[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access OP_QUEUE_RESET_VALUE.
 *
 */
#define BCM56800_A0_READ_OP_QUEUE_RESET_VALUEr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_OP_QUEUE_RESET_VALUEr+(i),(r._op_queue_reset_value))
#define BCM56800_A0_WRITE_OP_QUEUE_RESET_VALUEr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_OP_QUEUE_RESET_VALUEr+(i),&(r._op_queue_reset_value))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_QUEUE_RESET_VALUEr BCM56800_A0_OP_QUEUE_RESET_VALUEr
#define OP_QUEUE_RESET_VALUEr_SIZE BCM56800_A0_OP_QUEUE_RESET_VALUEr_SIZE
typedef BCM56800_A0_OP_QUEUE_RESET_VALUEr_t OP_QUEUE_RESET_VALUEr_t;
#define OP_QUEUE_RESET_VALUEr_CLR BCM56800_A0_OP_QUEUE_RESET_VALUEr_CLR
#define OP_QUEUE_RESET_VALUEr_SET BCM56800_A0_OP_QUEUE_RESET_VALUEr_SET
#define OP_QUEUE_RESET_VALUEr_GET BCM56800_A0_OP_QUEUE_RESET_VALUEr_GET
#define OP_QUEUE_RESET_VALUEr_Q_RESET_VALUEf_GET BCM56800_A0_OP_QUEUE_RESET_VALUEr_Q_RESET_VALUEf_GET
#define OP_QUEUE_RESET_VALUEr_Q_RESET_VALUEf_SET BCM56800_A0_OP_QUEUE_RESET_VALUEr_Q_RESET_VALUEf_SET
#define OP_QUEUE_RESET_VALUEr_Q_DROP_STATEf_GET BCM56800_A0_OP_QUEUE_RESET_VALUEr_Q_DROP_STATEf_GET
#define OP_QUEUE_RESET_VALUEr_Q_DROP_STATEf_SET BCM56800_A0_OP_QUEUE_RESET_VALUEr_Q_DROP_STATEf_SET
#define READ_OP_QUEUE_RESET_VALUEr BCM56800_A0_READ_OP_QUEUE_RESET_VALUEr
#define WRITE_OP_QUEUE_RESET_VALUEr BCM56800_A0_WRITE_OP_QUEUE_RESET_VALUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_QUEUE_RESET_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_QUEUE_SHARED_COUNT
 * BLOCKS:   MMU
 * DESC:     OP_QUEUE_SHARED_COUNT
 * SIZE:     32
 * FIELDS:
 *     Q_SHARED_COUNT   the number of cells currently used by an output queue which are considered part of the output shared space.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_QUEUE_SHARED_COUNTr 0x03d00040

#define BCM56800_A0_OP_QUEUE_SHARED_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program OP_QUEUE_SHARED_COUNT.
 *
 */
typedef union BCM56800_A0_OP_QUEUE_SHARED_COUNTr_s {
	uint32_t v[1];
	uint32_t op_queue_shared_count[1];
	uint32_t _op_queue_shared_count;
} BCM56800_A0_OP_QUEUE_SHARED_COUNTr_t;

#define BCM56800_A0_OP_QUEUE_SHARED_COUNTr_CLR(r) (r).op_queue_shared_count[0] = 0
#define BCM56800_A0_OP_QUEUE_SHARED_COUNTr_SET(r,d) (r).op_queue_shared_count[0] = d
#define BCM56800_A0_OP_QUEUE_SHARED_COUNTr_GET(r) (r).op_queue_shared_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_QUEUE_SHARED_COUNTr_Q_SHARED_COUNTf_GET(r) (((r).op_queue_shared_count[0]) & 0x3fff)
#define BCM56800_A0_OP_QUEUE_SHARED_COUNTr_Q_SHARED_COUNTf_SET(r,f) (r).op_queue_shared_count[0]=(((r).op_queue_shared_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access OP_QUEUE_SHARED_COUNT.
 *
 */
#define BCM56800_A0_READ_OP_QUEUE_SHARED_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_OP_QUEUE_SHARED_COUNTr+(i),(r._op_queue_shared_count))
#define BCM56800_A0_WRITE_OP_QUEUE_SHARED_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_OP_QUEUE_SHARED_COUNTr+(i),&(r._op_queue_shared_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_QUEUE_SHARED_COUNTr BCM56800_A0_OP_QUEUE_SHARED_COUNTr
#define OP_QUEUE_SHARED_COUNTr_SIZE BCM56800_A0_OP_QUEUE_SHARED_COUNTr_SIZE
typedef BCM56800_A0_OP_QUEUE_SHARED_COUNTr_t OP_QUEUE_SHARED_COUNTr_t;
#define OP_QUEUE_SHARED_COUNTr_CLR BCM56800_A0_OP_QUEUE_SHARED_COUNTr_CLR
#define OP_QUEUE_SHARED_COUNTr_SET BCM56800_A0_OP_QUEUE_SHARED_COUNTr_SET
#define OP_QUEUE_SHARED_COUNTr_GET BCM56800_A0_OP_QUEUE_SHARED_COUNTr_GET
#define OP_QUEUE_SHARED_COUNTr_Q_SHARED_COUNTf_GET BCM56800_A0_OP_QUEUE_SHARED_COUNTr_Q_SHARED_COUNTf_GET
#define OP_QUEUE_SHARED_COUNTr_Q_SHARED_COUNTf_SET BCM56800_A0_OP_QUEUE_SHARED_COUNTr_Q_SHARED_COUNTf_SET
#define READ_OP_QUEUE_SHARED_COUNTr BCM56800_A0_READ_OP_QUEUE_SHARED_COUNTr
#define WRITE_OP_QUEUE_SHARED_COUNTr BCM56800_A0_WRITE_OP_QUEUE_SHARED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_QUEUE_SHARED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_QUEUE_TOTAL_COUNT
 * BLOCKS:   MMU
 * DESC:     OP_QUEUE_TOTAL_COUNT
 * SIZE:     32
 * FIELDS:
 *     Q_TOTAL_COUNT    the number of cells currently used by an output queue, both min and shared cells. Note that this counter is only updated at packet enqueue time.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_QUEUE_TOTAL_COUNTr 0x03d00050

#define BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program OP_QUEUE_TOTAL_COUNT.
 *
 */
typedef union BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_s {
	uint32_t v[1];
	uint32_t op_queue_total_count[1];
	uint32_t _op_queue_total_count;
} BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_t;

#define BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_CLR(r) (r).op_queue_total_count[0] = 0
#define BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_SET(r,d) (r).op_queue_total_count[0] = d
#define BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_GET(r) (r).op_queue_total_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_Q_TOTAL_COUNTf_GET(r) (((r).op_queue_total_count[0]) & 0x3fff)
#define BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_Q_TOTAL_COUNTf_SET(r,f) (r).op_queue_total_count[0]=(((r).op_queue_total_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access OP_QUEUE_TOTAL_COUNT.
 *
 */
#define BCM56800_A0_READ_OP_QUEUE_TOTAL_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_OP_QUEUE_TOTAL_COUNTr+(i),(r._op_queue_total_count))
#define BCM56800_A0_WRITE_OP_QUEUE_TOTAL_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_OP_QUEUE_TOTAL_COUNTr+(i),&(r._op_queue_total_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_QUEUE_TOTAL_COUNTr BCM56800_A0_OP_QUEUE_TOTAL_COUNTr
#define OP_QUEUE_TOTAL_COUNTr_SIZE BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_SIZE
typedef BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_t OP_QUEUE_TOTAL_COUNTr_t;
#define OP_QUEUE_TOTAL_COUNTr_CLR BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_CLR
#define OP_QUEUE_TOTAL_COUNTr_SET BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_SET
#define OP_QUEUE_TOTAL_COUNTr_GET BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_GET
#define OP_QUEUE_TOTAL_COUNTr_Q_TOTAL_COUNTf_GET BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_Q_TOTAL_COUNTf_GET
#define OP_QUEUE_TOTAL_COUNTr_Q_TOTAL_COUNTf_SET BCM56800_A0_OP_QUEUE_TOTAL_COUNTr_Q_TOTAL_COUNTf_SET
#define READ_OP_QUEUE_TOTAL_COUNTr BCM56800_A0_READ_OP_QUEUE_TOTAL_COUNTr
#define WRITE_OP_QUEUE_TOTAL_COUNTr BCM56800_A0_WRITE_OP_QUEUE_TOTAL_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_QUEUE_TOTAL_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OP_THR_CONFIG
 * BLOCKS:   MMU
 * DESC:     OP_THR_CONFIG
 * SIZE:     32
 * FIELDS:
 *     ASF_PKT_SIZE     ASF_pkt_size: value of the packet size (in cells) that must be received before enqueuing for ASF.This is necessary to avoid underruns; initial estimate is '3' cells should be sufficient.
 *     ASF_QUEUE_SIZE   Maximum value in cells that the queue size before allowing enqueueing for ASF.It is necessary to enqueue before the queue size reaches zero to maintain cut-through operation on small packetsat line rate. (initial estimate is '3' cells').
 *     ASF_ENABLE       ASF_enabled: 1= allow cut-through to occur; 0 = store and forward for all packets.
 *     MOP_POLICY       3 configuration bits which serves as options as to whether to discard a packet based on MOP conditions. See uArch document for details.
 *     SOP_POLICY       1 configuration bits which serves as options as to whether to discard a packet based on SOP conditions. See uArch document for details.
 *
 ******************************************************************************/
#define BCM56800_A0_OP_THR_CONFIGr 0x03d80002

#define BCM56800_A0_OP_THR_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program OP_THR_CONFIG.
 *
 */
typedef union BCM56800_A0_OP_THR_CONFIGr_s {
	uint32_t v[1];
	uint32_t op_thr_config[1];
	uint32_t _op_thr_config;
} BCM56800_A0_OP_THR_CONFIGr_t;

#define BCM56800_A0_OP_THR_CONFIGr_CLR(r) (r).op_thr_config[0] = 0
#define BCM56800_A0_OP_THR_CONFIGr_SET(r,d) (r).op_thr_config[0] = d
#define BCM56800_A0_OP_THR_CONFIGr_GET(r) (r).op_thr_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OP_THR_CONFIGr_ASF_PKT_SIZEf_GET(r) (((r).op_thr_config[0]) & 0xf)
#define BCM56800_A0_OP_THR_CONFIGr_ASF_PKT_SIZEf_SET(r,f) (r).op_thr_config[0]=(((r).op_thr_config[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_OP_THR_CONFIGr_ASF_QUEUE_SIZEf_GET(r) ((((r).op_thr_config[0]) >> 4) & 0xf)
#define BCM56800_A0_OP_THR_CONFIGr_ASF_QUEUE_SIZEf_SET(r,f) (r).op_thr_config[0]=(((r).op_thr_config[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_OP_THR_CONFIGr_ASF_ENABLEf_GET(r) ((((r).op_thr_config[0]) >> 8) & 0x1)
#define BCM56800_A0_OP_THR_CONFIGr_ASF_ENABLEf_SET(r,f) (r).op_thr_config[0]=(((r).op_thr_config[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_OP_THR_CONFIGr_MOP_POLICYf_GET(r) ((((r).op_thr_config[0]) >> 9) & 0x7)
#define BCM56800_A0_OP_THR_CONFIGr_MOP_POLICYf_SET(r,f) (r).op_thr_config[0]=(((r).op_thr_config[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56800_A0_OP_THR_CONFIGr_SOP_POLICYf_GET(r) ((((r).op_thr_config[0]) >> 12) & 0x1)
#define BCM56800_A0_OP_THR_CONFIGr_SOP_POLICYf_SET(r,f) (r).op_thr_config[0]=(((r).op_thr_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access OP_THR_CONFIG.
 *
 */
#define BCM56800_A0_READ_OP_THR_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_OP_THR_CONFIGr,(r._op_thr_config))
#define BCM56800_A0_WRITE_OP_THR_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_OP_THR_CONFIGr,&(r._op_thr_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OP_THR_CONFIGr BCM56800_A0_OP_THR_CONFIGr
#define OP_THR_CONFIGr_SIZE BCM56800_A0_OP_THR_CONFIGr_SIZE
typedef BCM56800_A0_OP_THR_CONFIGr_t OP_THR_CONFIGr_t;
#define OP_THR_CONFIGr_CLR BCM56800_A0_OP_THR_CONFIGr_CLR
#define OP_THR_CONFIGr_SET BCM56800_A0_OP_THR_CONFIGr_SET
#define OP_THR_CONFIGr_GET BCM56800_A0_OP_THR_CONFIGr_GET
#define OP_THR_CONFIGr_ASF_PKT_SIZEf_GET BCM56800_A0_OP_THR_CONFIGr_ASF_PKT_SIZEf_GET
#define OP_THR_CONFIGr_ASF_PKT_SIZEf_SET BCM56800_A0_OP_THR_CONFIGr_ASF_PKT_SIZEf_SET
#define OP_THR_CONFIGr_ASF_QUEUE_SIZEf_GET BCM56800_A0_OP_THR_CONFIGr_ASF_QUEUE_SIZEf_GET
#define OP_THR_CONFIGr_ASF_QUEUE_SIZEf_SET BCM56800_A0_OP_THR_CONFIGr_ASF_QUEUE_SIZEf_SET
#define OP_THR_CONFIGr_ASF_ENABLEf_GET BCM56800_A0_OP_THR_CONFIGr_ASF_ENABLEf_GET
#define OP_THR_CONFIGr_ASF_ENABLEf_SET BCM56800_A0_OP_THR_CONFIGr_ASF_ENABLEf_SET
#define OP_THR_CONFIGr_MOP_POLICYf_GET BCM56800_A0_OP_THR_CONFIGr_MOP_POLICYf_GET
#define OP_THR_CONFIGr_MOP_POLICYf_SET BCM56800_A0_OP_THR_CONFIGr_MOP_POLICYf_SET
#define OP_THR_CONFIGr_SOP_POLICYf_GET BCM56800_A0_OP_THR_CONFIGr_SOP_POLICYf_GET
#define OP_THR_CONFIGr_SOP_POLICYf_SET BCM56800_A0_OP_THR_CONFIGr_SOP_POLICYf_SET
#define READ_OP_THR_CONFIGr BCM56800_A0_READ_OP_THR_CONFIGr
#define WRITE_OP_THR_CONFIGr BCM56800_A0_WRITE_OP_THR_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OP_THR_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  OUTPUT_PORT_RX_ENABLE
 * BLOCKS:   MMU
 * DESC:     OUTPUT_PORT_RX_ENABLE
 * SIZE:     32
 * FIELDS:
 *     OUTPUT_PORT_RX_ENABLE Output Port Rx Enable BitmapThe bitmap will be masked by current es tdm slot mode,If current tdm mode is 8 tdm for pipe 0, then potr 8 & 9 enable will get masked out.If current tdm mode is 8 tdm for pipe 1, then potr 18 & 19 enable will get masked out.
 *
 ******************************************************************************/
#define BCM56800_A0_OUTPUT_PORT_RX_ENABLEr 0x06d80040

#define BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program OUTPUT_PORT_RX_ENABLE.
 *
 */
typedef union BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_s {
	uint32_t v[1];
	uint32_t output_port_rx_enable[1];
	uint32_t _output_port_rx_enable;
} BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_t;

#define BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_CLR(r) (r).output_port_rx_enable[0] = 0
#define BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_SET(r,d) (r).output_port_rx_enable[0] = d
#define BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_GET(r) (r).output_port_rx_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_OUTPUT_PORT_RX_ENABLEf_GET(r) (((r).output_port_rx_enable[0]) & 0x1fffff)
#define BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_OUTPUT_PORT_RX_ENABLEf_SET(r,f) (r).output_port_rx_enable[0]=(((r).output_port_rx_enable[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access OUTPUT_PORT_RX_ENABLE.
 *
 */
#define BCM56800_A0_READ_OUTPUT_PORT_RX_ENABLEr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_OUTPUT_PORT_RX_ENABLEr,(r._output_port_rx_enable))
#define BCM56800_A0_WRITE_OUTPUT_PORT_RX_ENABLEr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_OUTPUT_PORT_RX_ENABLEr,&(r._output_port_rx_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTPUT_PORT_RX_ENABLEr BCM56800_A0_OUTPUT_PORT_RX_ENABLEr
#define OUTPUT_PORT_RX_ENABLEr_SIZE BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_SIZE
typedef BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_t OUTPUT_PORT_RX_ENABLEr_t;
#define OUTPUT_PORT_RX_ENABLEr_CLR BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_CLR
#define OUTPUT_PORT_RX_ENABLEr_SET BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_SET
#define OUTPUT_PORT_RX_ENABLEr_GET BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_GET
#define OUTPUT_PORT_RX_ENABLEr_OUTPUT_PORT_RX_ENABLEf_GET BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_OUTPUT_PORT_RX_ENABLEf_GET
#define OUTPUT_PORT_RX_ENABLEr_OUTPUT_PORT_RX_ENABLEf_SET BCM56800_A0_OUTPUT_PORT_RX_ENABLEr_OUTPUT_PORT_RX_ENABLEf_SET
#define READ_OUTPUT_PORT_RX_ENABLEr BCM56800_A0_READ_OUTPUT_PORT_RX_ENABLEr
#define WRITE_OUTPUT_PORT_RX_ENABLEr BCM56800_A0_WRITE_OUTPUT_PORT_RX_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_OUTPUT_PORT_RX_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PARS_RAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     PARS_RAM_CONTROL
 * SIZE:     32
 * FIELDS:
 *     SRCTRUNKMAP_TM   Src trunk map RAM TM debug bits
 *     L3TUNNEL_TM      L3 tunnel RAM TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_PARS_RAM_DBGCTRLr 0x02180c19

#define BCM56800_A0_PARS_RAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program PARS_RAM_DBGCTRL.
 *
 */
typedef union BCM56800_A0_PARS_RAM_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t pars_ram_dbgctrl[1];
	uint32_t _pars_ram_dbgctrl;
} BCM56800_A0_PARS_RAM_DBGCTRLr_t;

#define BCM56800_A0_PARS_RAM_DBGCTRLr_CLR(r) (r).pars_ram_dbgctrl[0] = 0
#define BCM56800_A0_PARS_RAM_DBGCTRLr_SET(r,d) (r).pars_ram_dbgctrl[0] = d
#define BCM56800_A0_PARS_RAM_DBGCTRLr_GET(r) (r).pars_ram_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PARS_RAM_DBGCTRLr_SRCTRUNKMAP_TMf_GET(r) (((r).pars_ram_dbgctrl[0]) & 0xf)
#define BCM56800_A0_PARS_RAM_DBGCTRLr_SRCTRUNKMAP_TMf_SET(r,f) (r).pars_ram_dbgctrl[0]=(((r).pars_ram_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_PARS_RAM_DBGCTRLr_L3TUNNEL_TMf_GET(r) ((((r).pars_ram_dbgctrl[0]) >> 4) & 0xf)
#define BCM56800_A0_PARS_RAM_DBGCTRLr_L3TUNNEL_TMf_SET(r,f) (r).pars_ram_dbgctrl[0]=(((r).pars_ram_dbgctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PARS_RAM_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_PARS_RAM_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PARS_RAM_DBGCTRLr,(r._pars_ram_dbgctrl))
#define BCM56800_A0_WRITE_PARS_RAM_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PARS_RAM_DBGCTRLr,&(r._pars_ram_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PARS_RAM_DBGCTRLr BCM56800_A0_PARS_RAM_DBGCTRLr
#define PARS_RAM_DBGCTRLr_SIZE BCM56800_A0_PARS_RAM_DBGCTRLr_SIZE
typedef BCM56800_A0_PARS_RAM_DBGCTRLr_t PARS_RAM_DBGCTRLr_t;
#define PARS_RAM_DBGCTRLr_CLR BCM56800_A0_PARS_RAM_DBGCTRLr_CLR
#define PARS_RAM_DBGCTRLr_SET BCM56800_A0_PARS_RAM_DBGCTRLr_SET
#define PARS_RAM_DBGCTRLr_GET BCM56800_A0_PARS_RAM_DBGCTRLr_GET
#define PARS_RAM_DBGCTRLr_SRCTRUNKMAP_TMf_GET BCM56800_A0_PARS_RAM_DBGCTRLr_SRCTRUNKMAP_TMf_GET
#define PARS_RAM_DBGCTRLr_SRCTRUNKMAP_TMf_SET BCM56800_A0_PARS_RAM_DBGCTRLr_SRCTRUNKMAP_TMf_SET
#define PARS_RAM_DBGCTRLr_L3TUNNEL_TMf_GET BCM56800_A0_PARS_RAM_DBGCTRLr_L3TUNNEL_TMf_GET
#define PARS_RAM_DBGCTRLr_L3TUNNEL_TMf_SET BCM56800_A0_PARS_RAM_DBGCTRLr_L3TUNNEL_TMf_SET
#define READ_PARS_RAM_DBGCTRLr BCM56800_A0_READ_PARS_RAM_DBGCTRLr
#define WRITE_PARS_RAM_DBGCTRLr BCM56800_A0_WRITE_PARS_RAM_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PARS_RAM_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PAUSE_CONTROL
 * BLOCKS:   GXPORT
 * DESC:     PAUSE frame timer control register
 * SIZE:     32
 * FIELDS:
 *     VALUE            Each bit in this register represents 512 bit times independent of the port speed. Values of 0 and 1 are illegal.
 *     ENABLE           Enable Extra Pause Frames.
 *
 ******************************************************************************/
#define BCM56800_A0_PAUSE_CONTROLr 0x00f00302

#define BCM56800_A0_PAUSE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CONTROL.
 *
 */
typedef union BCM56800_A0_PAUSE_CONTROLr_s {
	uint32_t v[1];
	uint32_t pause_control[1];
	uint32_t _pause_control;
} BCM56800_A0_PAUSE_CONTROLr_t;

#define BCM56800_A0_PAUSE_CONTROLr_CLR(r) (r).pause_control[0] = 0
#define BCM56800_A0_PAUSE_CONTROLr_SET(r,d) (r).pause_control[0] = d
#define BCM56800_A0_PAUSE_CONTROLr_GET(r) (r).pause_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PAUSE_CONTROLr_VALUEf_GET(r) (((r).pause_control[0]) & 0x1ffff)
#define BCM56800_A0_PAUSE_CONTROLr_VALUEf_SET(r,f) (r).pause_control[0]=(((r).pause_control[0] & ~((uint32_t)0x1ffff)) | (((uint32_t)f) & 0x1ffff))
#define BCM56800_A0_PAUSE_CONTROLr_ENABLEf_GET(r) ((((r).pause_control[0]) >> 17) & 0x1)
#define BCM56800_A0_PAUSE_CONTROLr_ENABLEf_SET(r,f) (r).pause_control[0]=(((r).pause_control[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))

/*
 * These macros can be used to access PAUSE_CONTROL.
 *
 */
#define BCM56800_A0_READ_PAUSE_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PAUSE_CONTROLr,(r._pause_control))
#define BCM56800_A0_WRITE_PAUSE_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PAUSE_CONTROLr,&(r._pause_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CONTROLr BCM56800_A0_PAUSE_CONTROLr
#define PAUSE_CONTROLr_SIZE BCM56800_A0_PAUSE_CONTROLr_SIZE
typedef BCM56800_A0_PAUSE_CONTROLr_t PAUSE_CONTROLr_t;
#define PAUSE_CONTROLr_CLR BCM56800_A0_PAUSE_CONTROLr_CLR
#define PAUSE_CONTROLr_SET BCM56800_A0_PAUSE_CONTROLr_SET
#define PAUSE_CONTROLr_GET BCM56800_A0_PAUSE_CONTROLr_GET
#define PAUSE_CONTROLr_VALUEf_GET BCM56800_A0_PAUSE_CONTROLr_VALUEf_GET
#define PAUSE_CONTROLr_VALUEf_SET BCM56800_A0_PAUSE_CONTROLr_VALUEf_SET
#define PAUSE_CONTROLr_ENABLEf_GET BCM56800_A0_PAUSE_CONTROLr_ENABLEf_GET
#define PAUSE_CONTROLr_ENABLEf_SET BCM56800_A0_PAUSE_CONTROLr_ENABLEf_SET
#define READ_PAUSE_CONTROLr BCM56800_A0_READ_PAUSE_CONTROLr
#define WRITE_PAUSE_CONTROLr BCM56800_A0_WRITE_PAUSE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PAUSE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PERR_PTR_CTR
 * BLOCKS:   MMU
 * DESC:     CTR parity error pointer
 * SIZE:     32
 * FIELDS:
 *     PTR              Parity error pointer
 *
 ******************************************************************************/
#define BCM56800_A0_PERR_PTR_CTRr 0x0dd80005

#define BCM56800_A0_PERR_PTR_CTRr_SIZE 4

/*
 * This structure should be used to declare and program PERR_PTR_CTR.
 *
 */
typedef union BCM56800_A0_PERR_PTR_CTRr_s {
	uint32_t v[1];
	uint32_t perr_ptr_ctr[1];
	uint32_t _perr_ptr_ctr;
} BCM56800_A0_PERR_PTR_CTRr_t;

#define BCM56800_A0_PERR_PTR_CTRr_CLR(r) (r).perr_ptr_ctr[0] = 0
#define BCM56800_A0_PERR_PTR_CTRr_SET(r,d) (r).perr_ptr_ctr[0] = d
#define BCM56800_A0_PERR_PTR_CTRr_GET(r) (r).perr_ptr_ctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PERR_PTR_CTRr_PTRf_GET(r) (((r).perr_ptr_ctr[0]) & 0x7ff)
#define BCM56800_A0_PERR_PTR_CTRr_PTRf_SET(r,f) (r).perr_ptr_ctr[0]=(((r).perr_ptr_ctr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access PERR_PTR_CTR.
 *
 */
#define BCM56800_A0_READ_PERR_PTR_CTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PERR_PTR_CTRr,(r._perr_ptr_ctr))
#define BCM56800_A0_WRITE_PERR_PTR_CTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PERR_PTR_CTRr,&(r._perr_ptr_ctr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PERR_PTR_CTRr BCM56800_A0_PERR_PTR_CTRr
#define PERR_PTR_CTRr_SIZE BCM56800_A0_PERR_PTR_CTRr_SIZE
typedef BCM56800_A0_PERR_PTR_CTRr_t PERR_PTR_CTRr_t;
#define PERR_PTR_CTRr_CLR BCM56800_A0_PERR_PTR_CTRr_CLR
#define PERR_PTR_CTRr_SET BCM56800_A0_PERR_PTR_CTRr_SET
#define PERR_PTR_CTRr_GET BCM56800_A0_PERR_PTR_CTRr_GET
#define PERR_PTR_CTRr_PTRf_GET BCM56800_A0_PERR_PTR_CTRr_PTRf_GET
#define PERR_PTR_CTRr_PTRf_SET BCM56800_A0_PERR_PTR_CTRr_PTRf_SET
#define READ_PERR_PTR_CTRr BCM56800_A0_READ_PERR_PTR_CTRr
#define WRITE_PERR_PTR_CTRr BCM56800_A0_WRITE_PERR_PTR_CTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PERR_PTR_CTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PERR_PTR_EXP
 * BLOCKS:   MMU
 * DESC:     EXP parity error pointer
 * SIZE:     32
 * FIELDS:
 *     PTR              Parity error pointer
 *
 ******************************************************************************/
#define BCM56800_A0_PERR_PTR_EXPr 0x0dd80006

#define BCM56800_A0_PERR_PTR_EXPr_SIZE 4

/*
 * This structure should be used to declare and program PERR_PTR_EXP.
 *
 */
typedef union BCM56800_A0_PERR_PTR_EXPr_s {
	uint32_t v[1];
	uint32_t perr_ptr_exp[1];
	uint32_t _perr_ptr_exp;
} BCM56800_A0_PERR_PTR_EXPr_t;

#define BCM56800_A0_PERR_PTR_EXPr_CLR(r) (r).perr_ptr_exp[0] = 0
#define BCM56800_A0_PERR_PTR_EXPr_SET(r,d) (r).perr_ptr_exp[0] = d
#define BCM56800_A0_PERR_PTR_EXPr_GET(r) (r).perr_ptr_exp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PERR_PTR_EXPr_PTRf_GET(r) (((r).perr_ptr_exp[0]) & 0x7ff)
#define BCM56800_A0_PERR_PTR_EXPr_PTRf_SET(r,f) (r).perr_ptr_exp[0]=(((r).perr_ptr_exp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access PERR_PTR_EXP.
 *
 */
#define BCM56800_A0_READ_PERR_PTR_EXPr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PERR_PTR_EXPr,(r._perr_ptr_exp))
#define BCM56800_A0_WRITE_PERR_PTR_EXPr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PERR_PTR_EXPr,&(r._perr_ptr_exp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PERR_PTR_EXPr BCM56800_A0_PERR_PTR_EXPr
#define PERR_PTR_EXPr_SIZE BCM56800_A0_PERR_PTR_EXPr_SIZE
typedef BCM56800_A0_PERR_PTR_EXPr_t PERR_PTR_EXPr_t;
#define PERR_PTR_EXPr_CLR BCM56800_A0_PERR_PTR_EXPr_CLR
#define PERR_PTR_EXPr_SET BCM56800_A0_PERR_PTR_EXPr_SET
#define PERR_PTR_EXPr_GET BCM56800_A0_PERR_PTR_EXPr_GET
#define PERR_PTR_EXPr_PTRf_GET BCM56800_A0_PERR_PTR_EXPr_PTRf_GET
#define PERR_PTR_EXPr_PTRf_SET BCM56800_A0_PERR_PTR_EXPr_PTRf_SET
#define READ_PERR_PTR_EXPr BCM56800_A0_READ_PERR_PTR_EXPr
#define WRITE_PERR_PTR_EXPr BCM56800_A0_WRITE_PERR_PTR_EXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PERR_PTR_EXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PERR_STAT
 * BLOCKS:   MMU
 * DESC:     Parity error status
 * SIZE:     32
 * FIELDS:
 *     EXP_ERR          EXP parity error occurred
 *     CTR_ERR          CTR parity error occurred
 *
 ******************************************************************************/
#define BCM56800_A0_PERR_STATr 0x0dd80004

#define BCM56800_A0_PERR_STATr_SIZE 4

/*
 * This structure should be used to declare and program PERR_STAT.
 *
 */
typedef union BCM56800_A0_PERR_STATr_s {
	uint32_t v[1];
	uint32_t perr_stat[1];
	uint32_t _perr_stat;
} BCM56800_A0_PERR_STATr_t;

#define BCM56800_A0_PERR_STATr_CLR(r) (r).perr_stat[0] = 0
#define BCM56800_A0_PERR_STATr_SET(r,d) (r).perr_stat[0] = d
#define BCM56800_A0_PERR_STATr_GET(r) (r).perr_stat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PERR_STATr_EXP_ERRf_GET(r) (((r).perr_stat[0]) & 0x1)
#define BCM56800_A0_PERR_STATr_EXP_ERRf_SET(r,f) (r).perr_stat[0]=(((r).perr_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_PERR_STATr_CTR_ERRf_GET(r) ((((r).perr_stat[0]) >> 1) & 0x1)
#define BCM56800_A0_PERR_STATr_CTR_ERRf_SET(r,f) (r).perr_stat[0]=(((r).perr_stat[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access PERR_STAT.
 *
 */
#define BCM56800_A0_READ_PERR_STATr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PERR_STATr,(r._perr_stat))
#define BCM56800_A0_WRITE_PERR_STATr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PERR_STATr,&(r._perr_stat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PERR_STATr BCM56800_A0_PERR_STATr
#define PERR_STATr_SIZE BCM56800_A0_PERR_STATr_SIZE
typedef BCM56800_A0_PERR_STATr_t PERR_STATr_t;
#define PERR_STATr_CLR BCM56800_A0_PERR_STATr_CLR
#define PERR_STATr_SET BCM56800_A0_PERR_STATr_SET
#define PERR_STATr_GET BCM56800_A0_PERR_STATr_GET
#define PERR_STATr_EXP_ERRf_GET BCM56800_A0_PERR_STATr_EXP_ERRf_GET
#define PERR_STATr_EXP_ERRf_SET BCM56800_A0_PERR_STATr_EXP_ERRf_SET
#define PERR_STATr_CTR_ERRf_GET BCM56800_A0_PERR_STATr_CTR_ERRf_GET
#define PERR_STATr_CTR_ERRf_SET BCM56800_A0_PERR_STATr_CTR_ERRf_SET
#define READ_PERR_STATr BCM56800_A0_READ_PERR_STATr
#define WRITE_PERR_STATr BCM56800_A0_WRITE_PERR_STATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PERR_STATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PER_PORT_AGE_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Per Port Aging Control Register
 * SIZE:     32
 * FIELDS:
 *     TGID_PORT        trunk group or port number
 *     MODULE_ID        module id
 *     VLAN_ID          vlan id
 *     PPA_MODE         indicates selection criteria, deletion versus replacement
 *     EXCL_STATIC      exclude static entries from deletion and replacement
 *     START            initiate per port aging
 *     COMPLETE         signal per port aging is complete
 *
 ******************************************************************************/
#define BCM56800_A0_PER_PORT_AGE_CONTROLr 0x00180205

#define BCM56800_A0_PER_PORT_AGE_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PER_PORT_AGE_CONTROL.
 *
 */
typedef union BCM56800_A0_PER_PORT_AGE_CONTROLr_s {
	uint32_t v[1];
	uint32_t per_port_age_control[1];
	uint32_t _per_port_age_control;
} BCM56800_A0_PER_PORT_AGE_CONTROLr_t;

#define BCM56800_A0_PER_PORT_AGE_CONTROLr_CLR(r) (r).per_port_age_control[0] = 0
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_SET(r,d) (r).per_port_age_control[0] = d
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_GET(r) (r).per_port_age_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_GET(r) (((r).per_port_age_control[0]) & 0x3f)
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_GET(r) ((((r).per_port_age_control[0]) >> 6) & 0x7f)
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x7f << 6)) | ((((uint32_t)f) & 0x7f) << 6))
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_GET(r) ((((r).per_port_age_control[0]) >> 13) & 0xfff)
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0xfff << 13)) | ((((uint32_t)f) & 0xfff) << 13))
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_GET(r) ((((r).per_port_age_control[0]) >> 25) & 0x7)
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x7 << 25)) | ((((uint32_t)f) & 0x7) << 25))
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET(r) ((((r).per_port_age_control[0]) >> 28) & 0x1)
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_STARTf_GET(r) ((((r).per_port_age_control[0]) >> 29) & 0x1)
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_STARTf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_GET(r) ((((r).per_port_age_control[0]) >> 30) & 0x1)
#define BCM56800_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_SET(r,f) (r).per_port_age_control[0]=(((r).per_port_age_control[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))

/*
 * These macros can be used to access PER_PORT_AGE_CONTROL.
 *
 */
#define BCM56800_A0_READ_PER_PORT_AGE_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PER_PORT_AGE_CONTROLr,(r._per_port_age_control))
#define BCM56800_A0_WRITE_PER_PORT_AGE_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PER_PORT_AGE_CONTROLr,&(r._per_port_age_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PER_PORT_AGE_CONTROLr BCM56800_A0_PER_PORT_AGE_CONTROLr
#define PER_PORT_AGE_CONTROLr_SIZE BCM56800_A0_PER_PORT_AGE_CONTROLr_SIZE
typedef BCM56800_A0_PER_PORT_AGE_CONTROLr_t PER_PORT_AGE_CONTROLr_t;
#define PER_PORT_AGE_CONTROLr_CLR BCM56800_A0_PER_PORT_AGE_CONTROLr_CLR
#define PER_PORT_AGE_CONTROLr_SET BCM56800_A0_PER_PORT_AGE_CONTROLr_SET
#define PER_PORT_AGE_CONTROLr_GET BCM56800_A0_PER_PORT_AGE_CONTROLr_GET
#define PER_PORT_AGE_CONTROLr_TGID_PORTf_GET BCM56800_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_GET
#define PER_PORT_AGE_CONTROLr_TGID_PORTf_SET BCM56800_A0_PER_PORT_AGE_CONTROLr_TGID_PORTf_SET
#define PER_PORT_AGE_CONTROLr_MODULE_IDf_GET BCM56800_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_GET
#define PER_PORT_AGE_CONTROLr_MODULE_IDf_SET BCM56800_A0_PER_PORT_AGE_CONTROLr_MODULE_IDf_SET
#define PER_PORT_AGE_CONTROLr_VLAN_IDf_GET BCM56800_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_GET
#define PER_PORT_AGE_CONTROLr_VLAN_IDf_SET BCM56800_A0_PER_PORT_AGE_CONTROLr_VLAN_IDf_SET
#define PER_PORT_AGE_CONTROLr_PPA_MODEf_GET BCM56800_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_GET
#define PER_PORT_AGE_CONTROLr_PPA_MODEf_SET BCM56800_A0_PER_PORT_AGE_CONTROLr_PPA_MODEf_SET
#define PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET BCM56800_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_GET
#define PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET BCM56800_A0_PER_PORT_AGE_CONTROLr_EXCL_STATICf_SET
#define PER_PORT_AGE_CONTROLr_STARTf_GET BCM56800_A0_PER_PORT_AGE_CONTROLr_STARTf_GET
#define PER_PORT_AGE_CONTROLr_STARTf_SET BCM56800_A0_PER_PORT_AGE_CONTROLr_STARTf_SET
#define PER_PORT_AGE_CONTROLr_COMPLETEf_GET BCM56800_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_GET
#define PER_PORT_AGE_CONTROLr_COMPLETEf_SET BCM56800_A0_PER_PORT_AGE_CONTROLr_COMPLETEf_SET
#define READ_PER_PORT_AGE_CONTROLr BCM56800_A0_READ_PER_PORT_AGE_CONTROLr
#define WRITE_PER_PORT_AGE_CONTROLr BCM56800_A0_WRITE_PER_PORT_AGE_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PER_PORT_AGE_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PER_PORT_REPL_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Per-Port-Aging Replacement Register
 * SIZE:     32
 * FIELDS:
 *     PORT_TGID        Port_TGID value to be used in replacment.
 *     MODULE_ID        Module_Id value to be used in replacement.
 *
 ******************************************************************************/
#define BCM56800_A0_PER_PORT_REPL_CONTROLr 0x06180600

#define BCM56800_A0_PER_PORT_REPL_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PER_PORT_REPL_CONTROL.
 *
 */
typedef union BCM56800_A0_PER_PORT_REPL_CONTROLr_s {
	uint32_t v[1];
	uint32_t per_port_repl_control[1];
	uint32_t _per_port_repl_control;
} BCM56800_A0_PER_PORT_REPL_CONTROLr_t;

#define BCM56800_A0_PER_PORT_REPL_CONTROLr_CLR(r) (r).per_port_repl_control[0] = 0
#define BCM56800_A0_PER_PORT_REPL_CONTROLr_SET(r,d) (r).per_port_repl_control[0] = d
#define BCM56800_A0_PER_PORT_REPL_CONTROLr_GET(r) (r).per_port_repl_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET(r) (((r).per_port_repl_control[0]) & 0x3f)
#define BCM56800_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET(r,f) (r).per_port_repl_control[0]=(((r).per_port_repl_control[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM56800_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_GET(r) ((((r).per_port_repl_control[0]) >> 6) & 0x7f)
#define BCM56800_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_SET(r,f) (r).per_port_repl_control[0]=(((r).per_port_repl_control[0] & ~((uint32_t)0x7f << 6)) | ((((uint32_t)f) & 0x7f) << 6))

/*
 * These macros can be used to access PER_PORT_REPL_CONTROL.
 *
 */
#define BCM56800_A0_READ_PER_PORT_REPL_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PER_PORT_REPL_CONTROLr,(r._per_port_repl_control))
#define BCM56800_A0_WRITE_PER_PORT_REPL_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PER_PORT_REPL_CONTROLr,&(r._per_port_repl_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PER_PORT_REPL_CONTROLr BCM56800_A0_PER_PORT_REPL_CONTROLr
#define PER_PORT_REPL_CONTROLr_SIZE BCM56800_A0_PER_PORT_REPL_CONTROLr_SIZE
typedef BCM56800_A0_PER_PORT_REPL_CONTROLr_t PER_PORT_REPL_CONTROLr_t;
#define PER_PORT_REPL_CONTROLr_CLR BCM56800_A0_PER_PORT_REPL_CONTROLr_CLR
#define PER_PORT_REPL_CONTROLr_SET BCM56800_A0_PER_PORT_REPL_CONTROLr_SET
#define PER_PORT_REPL_CONTROLr_GET BCM56800_A0_PER_PORT_REPL_CONTROLr_GET
#define PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET BCM56800_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_GET
#define PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET BCM56800_A0_PER_PORT_REPL_CONTROLr_PORT_TGIDf_SET
#define PER_PORT_REPL_CONTROLr_MODULE_IDf_GET BCM56800_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_GET
#define PER_PORT_REPL_CONTROLr_MODULE_IDf_SET BCM56800_A0_PER_PORT_REPL_CONTROLr_MODULE_IDf_SET
#define READ_PER_PORT_REPL_CONTROLr BCM56800_A0_READ_PER_PORT_REPL_CONTROLr
#define WRITE_PER_PORT_REPL_CONTROLr BCM56800_A0_WRITE_PER_PORT_REPL_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PER_PORT_REPL_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_COUNT
 * BLOCKS:   MMU
 * DESC:     PG_COUNT
 * SIZE:     32
 * FIELDS:
 *     PG_COUNT         There are three PGx_count registers per input port. They initialize to zero and represent the number of cells used inthe buffer for each PG within the port. This is not used for threshold checks, but is provided as a diagnostic tool.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_COUNTr 0x02d0004a

#define BCM56800_A0_PG_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PG_COUNT.
 *
 */
typedef union BCM56800_A0_PG_COUNTr_s {
	uint32_t v[1];
	uint32_t pg_count[1];
	uint32_t _pg_count;
} BCM56800_A0_PG_COUNTr_t;

#define BCM56800_A0_PG_COUNTr_CLR(r) (r).pg_count[0] = 0
#define BCM56800_A0_PG_COUNTr_SET(r,d) (r).pg_count[0] = d
#define BCM56800_A0_PG_COUNTr_GET(r) (r).pg_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_COUNTr_PG_COUNTf_GET(r) (((r).pg_count[0]) & 0x3fff)
#define BCM56800_A0_PG_COUNTr_PG_COUNTf_SET(r,f) (r).pg_count[0]=(((r).pg_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PG_COUNT.
 *
 */
#define BCM56800_A0_READ_PG_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_COUNTr+(i),(r._pg_count))
#define BCM56800_A0_WRITE_PG_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_COUNTr+(i),&(r._pg_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_COUNTr BCM56800_A0_PG_COUNTr
#define PG_COUNTr_SIZE BCM56800_A0_PG_COUNTr_SIZE
typedef BCM56800_A0_PG_COUNTr_t PG_COUNTr_t;
#define PG_COUNTr_CLR BCM56800_A0_PG_COUNTr_CLR
#define PG_COUNTr_SET BCM56800_A0_PG_COUNTr_SET
#define PG_COUNTr_GET BCM56800_A0_PG_COUNTr_GET
#define PG_COUNTr_PG_COUNTf_GET BCM56800_A0_PG_COUNTr_PG_COUNTf_GET
#define PG_COUNTr_PG_COUNTf_SET BCM56800_A0_PG_COUNTr_PG_COUNTf_SET
#define READ_PG_COUNTr BCM56800_A0_READ_PG_COUNTr
#define WRITE_PG_COUNTr BCM56800_A0_WRITE_PG_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_GBL_HDRM_COUNT
 * BLOCKS:   MMU
 * DESC:     PG_GBL_HDRM_COUNT
 * SIZE:     32
 * FIELDS:
 *     PG_GBL_HDRM_COUNT The PGx_glb_hdrm_count registers are used to count the number of cells used from the global headroom space.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_GBL_HDRM_COUNTr 0x02d00059

#define BCM56800_A0_PG_GBL_HDRM_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PG_GBL_HDRM_COUNT.
 *
 */
typedef union BCM56800_A0_PG_GBL_HDRM_COUNTr_s {
	uint32_t v[1];
	uint32_t pg_gbl_hdrm_count[1];
	uint32_t _pg_gbl_hdrm_count;
} BCM56800_A0_PG_GBL_HDRM_COUNTr_t;

#define BCM56800_A0_PG_GBL_HDRM_COUNTr_CLR(r) (r).pg_gbl_hdrm_count[0] = 0
#define BCM56800_A0_PG_GBL_HDRM_COUNTr_SET(r,d) (r).pg_gbl_hdrm_count[0] = d
#define BCM56800_A0_PG_GBL_HDRM_COUNTr_GET(r) (r).pg_gbl_hdrm_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_GBL_HDRM_COUNTr_PG_GBL_HDRM_COUNTf_GET(r) (((r).pg_gbl_hdrm_count[0]) & 0xfff)
#define BCM56800_A0_PG_GBL_HDRM_COUNTr_PG_GBL_HDRM_COUNTf_SET(r,f) (r).pg_gbl_hdrm_count[0]=(((r).pg_gbl_hdrm_count[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access PG_GBL_HDRM_COUNT.
 *
 */
#define BCM56800_A0_READ_PG_GBL_HDRM_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_GBL_HDRM_COUNTr+(i),(r._pg_gbl_hdrm_count))
#define BCM56800_A0_WRITE_PG_GBL_HDRM_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_GBL_HDRM_COUNTr+(i),&(r._pg_gbl_hdrm_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_GBL_HDRM_COUNTr BCM56800_A0_PG_GBL_HDRM_COUNTr
#define PG_GBL_HDRM_COUNTr_SIZE BCM56800_A0_PG_GBL_HDRM_COUNTr_SIZE
typedef BCM56800_A0_PG_GBL_HDRM_COUNTr_t PG_GBL_HDRM_COUNTr_t;
#define PG_GBL_HDRM_COUNTr_CLR BCM56800_A0_PG_GBL_HDRM_COUNTr_CLR
#define PG_GBL_HDRM_COUNTr_SET BCM56800_A0_PG_GBL_HDRM_COUNTr_SET
#define PG_GBL_HDRM_COUNTr_GET BCM56800_A0_PG_GBL_HDRM_COUNTr_GET
#define PG_GBL_HDRM_COUNTr_PG_GBL_HDRM_COUNTf_GET BCM56800_A0_PG_GBL_HDRM_COUNTr_PG_GBL_HDRM_COUNTf_GET
#define PG_GBL_HDRM_COUNTr_PG_GBL_HDRM_COUNTf_SET BCM56800_A0_PG_GBL_HDRM_COUNTr_PG_GBL_HDRM_COUNTf_SET
#define READ_PG_GBL_HDRM_COUNTr BCM56800_A0_READ_PG_GBL_HDRM_COUNTr
#define WRITE_PG_GBL_HDRM_COUNTr BCM56800_A0_WRITE_PG_GBL_HDRM_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_GBL_HDRM_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_HDRM_COUNT
 * BLOCKS:   MMU
 * DESC:     PG_HDRM_COUNT
 * SIZE:     32
 * FIELDS:
 *     PG_HDRM_COUNT    The PGx_hdrm_count registers are used to count the number of cells used from the PGx_hdrm space.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_HDRM_COUNTr 0x02d00056

#define BCM56800_A0_PG_HDRM_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PG_HDRM_COUNT.
 *
 */
typedef union BCM56800_A0_PG_HDRM_COUNTr_s {
	uint32_t v[1];
	uint32_t pg_hdrm_count[1];
	uint32_t _pg_hdrm_count;
} BCM56800_A0_PG_HDRM_COUNTr_t;

#define BCM56800_A0_PG_HDRM_COUNTr_CLR(r) (r).pg_hdrm_count[0] = 0
#define BCM56800_A0_PG_HDRM_COUNTr_SET(r,d) (r).pg_hdrm_count[0] = d
#define BCM56800_A0_PG_HDRM_COUNTr_GET(r) (r).pg_hdrm_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_HDRM_COUNTr_PG_HDRM_COUNTf_GET(r) (((r).pg_hdrm_count[0]) & 0xfff)
#define BCM56800_A0_PG_HDRM_COUNTr_PG_HDRM_COUNTf_SET(r,f) (r).pg_hdrm_count[0]=(((r).pg_hdrm_count[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access PG_HDRM_COUNT.
 *
 */
#define BCM56800_A0_READ_PG_HDRM_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_HDRM_COUNTr+(i),(r._pg_hdrm_count))
#define BCM56800_A0_WRITE_PG_HDRM_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_HDRM_COUNTr+(i),&(r._pg_hdrm_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_HDRM_COUNTr BCM56800_A0_PG_HDRM_COUNTr
#define PG_HDRM_COUNTr_SIZE BCM56800_A0_PG_HDRM_COUNTr_SIZE
typedef BCM56800_A0_PG_HDRM_COUNTr_t PG_HDRM_COUNTr_t;
#define PG_HDRM_COUNTr_CLR BCM56800_A0_PG_HDRM_COUNTr_CLR
#define PG_HDRM_COUNTr_SET BCM56800_A0_PG_HDRM_COUNTr_SET
#define PG_HDRM_COUNTr_GET BCM56800_A0_PG_HDRM_COUNTr_GET
#define PG_HDRM_COUNTr_PG_HDRM_COUNTf_GET BCM56800_A0_PG_HDRM_COUNTr_PG_HDRM_COUNTf_GET
#define PG_HDRM_COUNTr_PG_HDRM_COUNTf_SET BCM56800_A0_PG_HDRM_COUNTr_PG_HDRM_COUNTf_SET
#define READ_PG_HDRM_COUNTr BCM56800_A0_READ_PG_HDRM_COUNTr
#define WRITE_PG_HDRM_COUNTr BCM56800_A0_WRITE_PG_HDRM_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_HDRM_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_HDRM_LIMIT
 * BLOCKS:   MMU
 * DESC:     PG_HDRM_LIMIT
 * SIZE:     32
 * FIELDS:
 *     PG_HDRM_LIMIT    The PGx_hdrm_limit is the reserved number of cells for each priority group of each port.The Pgx_hdrm_limit value is usually set to zero for BT PGs, and to the real RTT (in cells) needed for lossless behavior for GD PGs.
 *     PG_GE            The PGx_ge is the "global headroom enable" bit, one for each PG. When the PGx_ge is set, it allows the PG to make use of the global headroom buffer pool.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_HDRM_LIMITr 0x02d0002b

#define BCM56800_A0_PG_HDRM_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program PG_HDRM_LIMIT.
 *
 */
typedef union BCM56800_A0_PG_HDRM_LIMITr_s {
	uint32_t v[1];
	uint32_t pg_hdrm_limit[1];
	uint32_t _pg_hdrm_limit;
} BCM56800_A0_PG_HDRM_LIMITr_t;

#define BCM56800_A0_PG_HDRM_LIMITr_CLR(r) (r).pg_hdrm_limit[0] = 0
#define BCM56800_A0_PG_HDRM_LIMITr_SET(r,d) (r).pg_hdrm_limit[0] = d
#define BCM56800_A0_PG_HDRM_LIMITr_GET(r) (r).pg_hdrm_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_HDRM_LIMITr_PG_HDRM_LIMITf_GET(r) (((r).pg_hdrm_limit[0]) & 0xfff)
#define BCM56800_A0_PG_HDRM_LIMITr_PG_HDRM_LIMITf_SET(r,f) (r).pg_hdrm_limit[0]=(((r).pg_hdrm_limit[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_PG_HDRM_LIMITr_PG_GEf_GET(r) ((((r).pg_hdrm_limit[0]) >> 12) & 0x1)
#define BCM56800_A0_PG_HDRM_LIMITr_PG_GEf_SET(r,f) (r).pg_hdrm_limit[0]=(((r).pg_hdrm_limit[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))

/*
 * These macros can be used to access PG_HDRM_LIMIT.
 *
 */
#define BCM56800_A0_READ_PG_HDRM_LIMITr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_HDRM_LIMITr+(i),(r._pg_hdrm_limit))
#define BCM56800_A0_WRITE_PG_HDRM_LIMITr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_HDRM_LIMITr+(i),&(r._pg_hdrm_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_HDRM_LIMITr BCM56800_A0_PG_HDRM_LIMITr
#define PG_HDRM_LIMITr_SIZE BCM56800_A0_PG_HDRM_LIMITr_SIZE
typedef BCM56800_A0_PG_HDRM_LIMITr_t PG_HDRM_LIMITr_t;
#define PG_HDRM_LIMITr_CLR BCM56800_A0_PG_HDRM_LIMITr_CLR
#define PG_HDRM_LIMITr_SET BCM56800_A0_PG_HDRM_LIMITr_SET
#define PG_HDRM_LIMITr_GET BCM56800_A0_PG_HDRM_LIMITr_GET
#define PG_HDRM_LIMITr_PG_HDRM_LIMITf_GET BCM56800_A0_PG_HDRM_LIMITr_PG_HDRM_LIMITf_GET
#define PG_HDRM_LIMITr_PG_HDRM_LIMITf_SET BCM56800_A0_PG_HDRM_LIMITr_PG_HDRM_LIMITf_SET
#define PG_HDRM_LIMITr_PG_GEf_GET BCM56800_A0_PG_HDRM_LIMITr_PG_GEf_GET
#define PG_HDRM_LIMITr_PG_GEf_SET BCM56800_A0_PG_HDRM_LIMITr_PG_GEf_SET
#define READ_PG_HDRM_LIMITr BCM56800_A0_READ_PG_HDRM_LIMITr
#define WRITE_PG_HDRM_LIMITr BCM56800_A0_WRITE_PG_HDRM_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_HDRM_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_MIN
 * BLOCKS:   MMU
 * DESC:     PG_MIN
 * SIZE:     32
 * FIELDS:
 *     PG_MIN           The priority group minimum register holds the PG minimum guarantees for a single port.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_MINr 0x02d00028

#define BCM56800_A0_PG_MINr_SIZE 4

/*
 * This structure should be used to declare and program PG_MIN.
 *
 */
typedef union BCM56800_A0_PG_MINr_s {
	uint32_t v[1];
	uint32_t pg_min[1];
	uint32_t _pg_min;
} BCM56800_A0_PG_MINr_t;

#define BCM56800_A0_PG_MINr_CLR(r) (r).pg_min[0] = 0
#define BCM56800_A0_PG_MINr_SET(r,d) (r).pg_min[0] = d
#define BCM56800_A0_PG_MINr_GET(r) (r).pg_min[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_MINr_PG_MINf_GET(r) (((r).pg_min[0]) & 0x3ff)
#define BCM56800_A0_PG_MINr_PG_MINf_SET(r,f) (r).pg_min[0]=(((r).pg_min[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PG_MIN.
 *
 */
#define BCM56800_A0_READ_PG_MINr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_MINr+(i),(r._pg_min))
#define BCM56800_A0_WRITE_PG_MINr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_MINr+(i),&(r._pg_min))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_MINr BCM56800_A0_PG_MINr
#define PG_MINr_SIZE BCM56800_A0_PG_MINr_SIZE
typedef BCM56800_A0_PG_MINr_t PG_MINr_t;
#define PG_MINr_CLR BCM56800_A0_PG_MINr_CLR
#define PG_MINr_SET BCM56800_A0_PG_MINr_SET
#define PG_MINr_GET BCM56800_A0_PG_MINr_GET
#define PG_MINr_PG_MINf_GET BCM56800_A0_PG_MINr_PG_MINf_GET
#define PG_MINr_PG_MINf_SET BCM56800_A0_PG_MINr_PG_MINf_SET
#define READ_PG_MINr BCM56800_A0_READ_PG_MINr
#define WRITE_PG_MINr BCM56800_A0_WRITE_PG_MINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_MINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_MIN_COUNT
 * BLOCKS:   MMU
 * DESC:     PG_MIN_COUNT
 * SIZE:     32
 * FIELDS:
 *     PG_MIN_COUNT     The PGx_min_count registers are used to count the number of cells used from the PGx_min space.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_MIN_COUNTr 0x02d0004d

#define BCM56800_A0_PG_MIN_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PG_MIN_COUNT.
 *
 */
typedef union BCM56800_A0_PG_MIN_COUNTr_s {
	uint32_t v[1];
	uint32_t pg_min_count[1];
	uint32_t _pg_min_count;
} BCM56800_A0_PG_MIN_COUNTr_t;

#define BCM56800_A0_PG_MIN_COUNTr_CLR(r) (r).pg_min_count[0] = 0
#define BCM56800_A0_PG_MIN_COUNTr_SET(r,d) (r).pg_min_count[0] = d
#define BCM56800_A0_PG_MIN_COUNTr_GET(r) (r).pg_min_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_MIN_COUNTr_PG_MIN_COUNTf_GET(r) (((r).pg_min_count[0]) & 0x3ff)
#define BCM56800_A0_PG_MIN_COUNTr_PG_MIN_COUNTf_SET(r,f) (r).pg_min_count[0]=(((r).pg_min_count[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PG_MIN_COUNT.
 *
 */
#define BCM56800_A0_READ_PG_MIN_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_MIN_COUNTr+(i),(r._pg_min_count))
#define BCM56800_A0_WRITE_PG_MIN_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_MIN_COUNTr+(i),&(r._pg_min_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_MIN_COUNTr BCM56800_A0_PG_MIN_COUNTr
#define PG_MIN_COUNTr_SIZE BCM56800_A0_PG_MIN_COUNTr_SIZE
typedef BCM56800_A0_PG_MIN_COUNTr_t PG_MIN_COUNTr_t;
#define PG_MIN_COUNTr_CLR BCM56800_A0_PG_MIN_COUNTr_CLR
#define PG_MIN_COUNTr_SET BCM56800_A0_PG_MIN_COUNTr_SET
#define PG_MIN_COUNTr_GET BCM56800_A0_PG_MIN_COUNTr_GET
#define PG_MIN_COUNTr_PG_MIN_COUNTf_GET BCM56800_A0_PG_MIN_COUNTr_PG_MIN_COUNTf_GET
#define PG_MIN_COUNTr_PG_MIN_COUNTf_SET BCM56800_A0_PG_MIN_COUNTr_PG_MIN_COUNTf_SET
#define READ_PG_MIN_COUNTr BCM56800_A0_READ_PG_MIN_COUNTr
#define WRITE_PG_MIN_COUNTr BCM56800_A0_WRITE_PG_MIN_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_MIN_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_PORT_MIN_COUNT
 * BLOCKS:   MMU
 * DESC:     PG_PORT_MIN_COUNT
 * SIZE:     32
 * FIELDS:
 *     PG_PORT_MIN_COUNT The PGx_port_min_count registers are used to count the number of cells used from the Port_min space.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_PORT_MIN_COUNTr 0x02d00050

#define BCM56800_A0_PG_PORT_MIN_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PG_PORT_MIN_COUNT.
 *
 */
typedef union BCM56800_A0_PG_PORT_MIN_COUNTr_s {
	uint32_t v[1];
	uint32_t pg_port_min_count[1];
	uint32_t _pg_port_min_count;
} BCM56800_A0_PG_PORT_MIN_COUNTr_t;

#define BCM56800_A0_PG_PORT_MIN_COUNTr_CLR(r) (r).pg_port_min_count[0] = 0
#define BCM56800_A0_PG_PORT_MIN_COUNTr_SET(r,d) (r).pg_port_min_count[0] = d
#define BCM56800_A0_PG_PORT_MIN_COUNTr_GET(r) (r).pg_port_min_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_PORT_MIN_COUNTr_PG_PORT_MIN_COUNTf_GET(r) (((r).pg_port_min_count[0]) & 0xfff)
#define BCM56800_A0_PG_PORT_MIN_COUNTr_PG_PORT_MIN_COUNTf_SET(r,f) (r).pg_port_min_count[0]=(((r).pg_port_min_count[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access PG_PORT_MIN_COUNT.
 *
 */
#define BCM56800_A0_READ_PG_PORT_MIN_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_PORT_MIN_COUNTr+(i),(r._pg_port_min_count))
#define BCM56800_A0_WRITE_PG_PORT_MIN_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_PORT_MIN_COUNTr+(i),&(r._pg_port_min_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_PORT_MIN_COUNTr BCM56800_A0_PG_PORT_MIN_COUNTr
#define PG_PORT_MIN_COUNTr_SIZE BCM56800_A0_PG_PORT_MIN_COUNTr_SIZE
typedef BCM56800_A0_PG_PORT_MIN_COUNTr_t PG_PORT_MIN_COUNTr_t;
#define PG_PORT_MIN_COUNTr_CLR BCM56800_A0_PG_PORT_MIN_COUNTr_CLR
#define PG_PORT_MIN_COUNTr_SET BCM56800_A0_PG_PORT_MIN_COUNTr_SET
#define PG_PORT_MIN_COUNTr_GET BCM56800_A0_PG_PORT_MIN_COUNTr_GET
#define PG_PORT_MIN_COUNTr_PG_PORT_MIN_COUNTf_GET BCM56800_A0_PG_PORT_MIN_COUNTr_PG_PORT_MIN_COUNTf_GET
#define PG_PORT_MIN_COUNTr_PG_PORT_MIN_COUNTf_SET BCM56800_A0_PG_PORT_MIN_COUNTr_PG_PORT_MIN_COUNTf_SET
#define READ_PG_PORT_MIN_COUNTr BCM56800_A0_READ_PG_PORT_MIN_COUNTr
#define WRITE_PG_PORT_MIN_COUNTr BCM56800_A0_WRITE_PG_PORT_MIN_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_PORT_MIN_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_RESET_FLOOR
 * BLOCKS:   MMU
 * DESC:     PG_RESET_FLOOR
 * SIZE:     32
 * FIELDS:
 *     PG_RESET_FLOOR   
 *
 ******************************************************************************/
#define BCM56800_A0_PG_RESET_FLOORr 0x02d00025

#define BCM56800_A0_PG_RESET_FLOORr_SIZE 4

/*
 * This structure should be used to declare and program PG_RESET_FLOOR.
 *
 */
typedef union BCM56800_A0_PG_RESET_FLOORr_s {
	uint32_t v[1];
	uint32_t pg_reset_floor[1];
	uint32_t _pg_reset_floor;
} BCM56800_A0_PG_RESET_FLOORr_t;

#define BCM56800_A0_PG_RESET_FLOORr_CLR(r) (r).pg_reset_floor[0] = 0
#define BCM56800_A0_PG_RESET_FLOORr_SET(r,d) (r).pg_reset_floor[0] = d
#define BCM56800_A0_PG_RESET_FLOORr_GET(r) (r).pg_reset_floor[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_RESET_FLOORr_PG_RESET_FLOORf_GET(r) (((r).pg_reset_floor[0]) & 0x3ff)
#define BCM56800_A0_PG_RESET_FLOORr_PG_RESET_FLOORf_SET(r,f) (r).pg_reset_floor[0]=(((r).pg_reset_floor[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PG_RESET_FLOOR.
 *
 */
#define BCM56800_A0_READ_PG_RESET_FLOORr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_RESET_FLOORr+(i),(r._pg_reset_floor))
#define BCM56800_A0_WRITE_PG_RESET_FLOORr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_RESET_FLOORr+(i),&(r._pg_reset_floor))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_RESET_FLOORr BCM56800_A0_PG_RESET_FLOORr
#define PG_RESET_FLOORr_SIZE BCM56800_A0_PG_RESET_FLOORr_SIZE
typedef BCM56800_A0_PG_RESET_FLOORr_t PG_RESET_FLOORr_t;
#define PG_RESET_FLOORr_CLR BCM56800_A0_PG_RESET_FLOORr_CLR
#define PG_RESET_FLOORr_SET BCM56800_A0_PG_RESET_FLOORr_SET
#define PG_RESET_FLOORr_GET BCM56800_A0_PG_RESET_FLOORr_GET
#define PG_RESET_FLOORr_PG_RESET_FLOORf_GET BCM56800_A0_PG_RESET_FLOORr_PG_RESET_FLOORf_GET
#define PG_RESET_FLOORr_PG_RESET_FLOORf_SET BCM56800_A0_PG_RESET_FLOORr_PG_RESET_FLOORf_SET
#define READ_PG_RESET_FLOORr BCM56800_A0_READ_PG_RESET_FLOORr
#define WRITE_PG_RESET_FLOORr BCM56800_A0_WRITE_PG_RESET_FLOORr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_RESET_FLOORr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_RESET_SEL
 * BLOCKS:   MMU
 * DESC:     PG_RESET_SEL
 * SIZE:     32
 * FIELDS:
 *     PG0_RESET_SEL    PG2_reset_sel, PG1_reset_sel and PG0_reset_sel are selection indexes to the "reset" (or xon) percentage. It is used tocapture the xon value as a percentage of the xoff thresholds.Values: 7=87.5% (7/8), 6=75% (6/8), 5=62.5% (5/8), 4=50% (4/8), 3 = 37.5% (3/8) 2 = 25% (2/8), 1 = 12.5% (1/8), 0 = (all shared must be gone).If (pg2_reset_sel == 111), then pg2_xon = .875 * pg2_xoff_thresh, else if (pg2_reset_sel == 110), then pg2_on = .75 * pg2_xoff_thresh, etc....... The same computation takes place for PG1 and PG0 xon values.
 *     PG1_RESET_SEL    
 *     PG2_RESET_SEL    
 *
 ******************************************************************************/
#define BCM56800_A0_PG_RESET_SELr 0x02d00024

#define BCM56800_A0_PG_RESET_SELr_SIZE 4

/*
 * This structure should be used to declare and program PG_RESET_SEL.
 *
 */
typedef union BCM56800_A0_PG_RESET_SELr_s {
	uint32_t v[1];
	uint32_t pg_reset_sel[1];
	uint32_t _pg_reset_sel;
} BCM56800_A0_PG_RESET_SELr_t;

#define BCM56800_A0_PG_RESET_SELr_CLR(r) (r).pg_reset_sel[0] = 0
#define BCM56800_A0_PG_RESET_SELr_SET(r,d) (r).pg_reset_sel[0] = d
#define BCM56800_A0_PG_RESET_SELr_GET(r) (r).pg_reset_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_RESET_SELr_PG0_RESET_SELf_GET(r) (((r).pg_reset_sel[0]) & 0x7)
#define BCM56800_A0_PG_RESET_SELr_PG0_RESET_SELf_SET(r,f) (r).pg_reset_sel[0]=(((r).pg_reset_sel[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_PG_RESET_SELr_PG1_RESET_SELf_GET(r) ((((r).pg_reset_sel[0]) >> 4) & 0x7)
#define BCM56800_A0_PG_RESET_SELr_PG1_RESET_SELf_SET(r,f) (r).pg_reset_sel[0]=(((r).pg_reset_sel[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM56800_A0_PG_RESET_SELr_PG2_RESET_SELf_GET(r) ((((r).pg_reset_sel[0]) >> 8) & 0x7)
#define BCM56800_A0_PG_RESET_SELr_PG2_RESET_SELf_SET(r,f) (r).pg_reset_sel[0]=(((r).pg_reset_sel[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))

/*
 * These macros can be used to access PG_RESET_SEL.
 *
 */
#define BCM56800_A0_READ_PG_RESET_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_RESET_SELr,(r._pg_reset_sel))
#define BCM56800_A0_WRITE_PG_RESET_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_RESET_SELr,&(r._pg_reset_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_RESET_SELr BCM56800_A0_PG_RESET_SELr
#define PG_RESET_SELr_SIZE BCM56800_A0_PG_RESET_SELr_SIZE
typedef BCM56800_A0_PG_RESET_SELr_t PG_RESET_SELr_t;
#define PG_RESET_SELr_CLR BCM56800_A0_PG_RESET_SELr_CLR
#define PG_RESET_SELr_SET BCM56800_A0_PG_RESET_SELr_SET
#define PG_RESET_SELr_GET BCM56800_A0_PG_RESET_SELr_GET
#define PG_RESET_SELr_PG0_RESET_SELf_GET BCM56800_A0_PG_RESET_SELr_PG0_RESET_SELf_GET
#define PG_RESET_SELr_PG0_RESET_SELf_SET BCM56800_A0_PG_RESET_SELr_PG0_RESET_SELf_SET
#define PG_RESET_SELr_PG1_RESET_SELf_GET BCM56800_A0_PG_RESET_SELr_PG1_RESET_SELf_GET
#define PG_RESET_SELr_PG1_RESET_SELf_SET BCM56800_A0_PG_RESET_SELr_PG1_RESET_SELf_SET
#define PG_RESET_SELr_PG2_RESET_SELf_GET BCM56800_A0_PG_RESET_SELr_PG2_RESET_SELf_GET
#define PG_RESET_SELr_PG2_RESET_SELf_SET BCM56800_A0_PG_RESET_SELr_PG2_RESET_SELf_SET
#define READ_PG_RESET_SELr BCM56800_A0_READ_PG_RESET_SELr
#define WRITE_PG_RESET_SELr BCM56800_A0_WRITE_PG_RESET_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_RESET_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_RESET_VALUE
 * BLOCKS:   MMU
 * DESC:     PG_RESET_VALUE
 * SIZE:     32
 * FIELDS:
 *     PG_RESET_VALUE   This status register "captures" the xon value that is needed to for each PG to send an xon message. The value is in cells.It is computed as a percentage of the xoff threshold. Since the xoff can be a dynamic value, the xon is captured for the specific xoff value when it is crossed. The pg_reset_value is only valid when the pg_lm_st ==1 (in the above Status register).
 *     PG_LIMIT_STATE   When the PG's threshold is hit for a port (which can be a dynamic threshold), the PG is put into "limit state". When in limit state, the PG is not allowed to use cells from the shared pool, flow control is asserted, and any new cells received must use headroom space.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_RESET_VALUEr 0x02d00061

#define BCM56800_A0_PG_RESET_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program PG_RESET_VALUE.
 *
 */
typedef union BCM56800_A0_PG_RESET_VALUEr_s {
	uint32_t v[1];
	uint32_t pg_reset_value[1];
	uint32_t _pg_reset_value;
} BCM56800_A0_PG_RESET_VALUEr_t;

#define BCM56800_A0_PG_RESET_VALUEr_CLR(r) (r).pg_reset_value[0] = 0
#define BCM56800_A0_PG_RESET_VALUEr_SET(r,d) (r).pg_reset_value[0] = d
#define BCM56800_A0_PG_RESET_VALUEr_GET(r) (r).pg_reset_value[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_RESET_VALUEr_PG_RESET_VALUEf_GET(r) (((r).pg_reset_value[0]) & 0x3fff)
#define BCM56800_A0_PG_RESET_VALUEr_PG_RESET_VALUEf_SET(r,f) (r).pg_reset_value[0]=(((r).pg_reset_value[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_PG_RESET_VALUEr_PG_LIMIT_STATEf_GET(r) ((((r).pg_reset_value[0]) >> 15) & 0x1)
#define BCM56800_A0_PG_RESET_VALUEr_PG_LIMIT_STATEf_SET(r,f) (r).pg_reset_value[0]=(((r).pg_reset_value[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access PG_RESET_VALUE.
 *
 */
#define BCM56800_A0_READ_PG_RESET_VALUEr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_RESET_VALUEr+(i),(r._pg_reset_value))
#define BCM56800_A0_WRITE_PG_RESET_VALUEr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_RESET_VALUEr+(i),&(r._pg_reset_value))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_RESET_VALUEr BCM56800_A0_PG_RESET_VALUEr
#define PG_RESET_VALUEr_SIZE BCM56800_A0_PG_RESET_VALUEr_SIZE
typedef BCM56800_A0_PG_RESET_VALUEr_t PG_RESET_VALUEr_t;
#define PG_RESET_VALUEr_CLR BCM56800_A0_PG_RESET_VALUEr_CLR
#define PG_RESET_VALUEr_SET BCM56800_A0_PG_RESET_VALUEr_SET
#define PG_RESET_VALUEr_GET BCM56800_A0_PG_RESET_VALUEr_GET
#define PG_RESET_VALUEr_PG_RESET_VALUEf_GET BCM56800_A0_PG_RESET_VALUEr_PG_RESET_VALUEf_GET
#define PG_RESET_VALUEr_PG_RESET_VALUEf_SET BCM56800_A0_PG_RESET_VALUEr_PG_RESET_VALUEf_SET
#define PG_RESET_VALUEr_PG_LIMIT_STATEf_GET BCM56800_A0_PG_RESET_VALUEr_PG_LIMIT_STATEf_GET
#define PG_RESET_VALUEr_PG_LIMIT_STATEf_SET BCM56800_A0_PG_RESET_VALUEr_PG_LIMIT_STATEf_SET
#define READ_PG_RESET_VALUEr BCM56800_A0_READ_PG_RESET_VALUEr
#define WRITE_PG_RESET_VALUEr BCM56800_A0_WRITE_PG_RESET_VALUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_RESET_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_SHARED_COUNT
 * BLOCKS:   MMU
 * DESC:     PG_SHARED_COUNT
 * SIZE:     32
 * FIELDS:
 *     PG_SHARED_COUNT  The PGx_shared_count registers are used to count the number of cells used from the port's shared space.
 *
 ******************************************************************************/
#define BCM56800_A0_PG_SHARED_COUNTr 0x02d00053

#define BCM56800_A0_PG_SHARED_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PG_SHARED_COUNT.
 *
 */
typedef union BCM56800_A0_PG_SHARED_COUNTr_s {
	uint32_t v[1];
	uint32_t pg_shared_count[1];
	uint32_t _pg_shared_count;
} BCM56800_A0_PG_SHARED_COUNTr_t;

#define BCM56800_A0_PG_SHARED_COUNTr_CLR(r) (r).pg_shared_count[0] = 0
#define BCM56800_A0_PG_SHARED_COUNTr_SET(r,d) (r).pg_shared_count[0] = d
#define BCM56800_A0_PG_SHARED_COUNTr_GET(r) (r).pg_shared_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_SHARED_COUNTr_PG_SHARED_COUNTf_GET(r) (((r).pg_shared_count[0]) & 0x3fff)
#define BCM56800_A0_PG_SHARED_COUNTr_PG_SHARED_COUNTf_SET(r,f) (r).pg_shared_count[0]=(((r).pg_shared_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PG_SHARED_COUNT.
 *
 */
#define BCM56800_A0_READ_PG_SHARED_COUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_SHARED_COUNTr+(i),(r._pg_shared_count))
#define BCM56800_A0_WRITE_PG_SHARED_COUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_SHARED_COUNTr+(i),&(r._pg_shared_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_SHARED_COUNTr BCM56800_A0_PG_SHARED_COUNTr
#define PG_SHARED_COUNTr_SIZE BCM56800_A0_PG_SHARED_COUNTr_SIZE
typedef BCM56800_A0_PG_SHARED_COUNTr_t PG_SHARED_COUNTr_t;
#define PG_SHARED_COUNTr_CLR BCM56800_A0_PG_SHARED_COUNTr_CLR
#define PG_SHARED_COUNTr_SET BCM56800_A0_PG_SHARED_COUNTr_SET
#define PG_SHARED_COUNTr_GET BCM56800_A0_PG_SHARED_COUNTr_GET
#define PG_SHARED_COUNTr_PG_SHARED_COUNTf_GET BCM56800_A0_PG_SHARED_COUNTr_PG_SHARED_COUNTf_GET
#define PG_SHARED_COUNTr_PG_SHARED_COUNTf_SET BCM56800_A0_PG_SHARED_COUNTr_PG_SHARED_COUNTf_SET
#define READ_PG_SHARED_COUNTr BCM56800_A0_READ_PG_SHARED_COUNTr
#define WRITE_PG_SHARED_COUNTr BCM56800_A0_WRITE_PG_SHARED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_SHARED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PG_THRESH_SEL
 * BLOCKS:   MMU
 * DESC:     PG_THRESH_SEL
 * SIZE:     32
 * FIELDS:
 *     PG0_THRESH_SEL   PG1_thresh_sel and PG0_thresh_sel are selection indexes to the xoff percentage used to generate the pg1_xoff_threshand pg0_xoff_thresh (as a function of pg2_xoff_threshold which can be a dynamic value). The PG2_xoff_thresholdcan be programmed as a static number of cells (it equals the port_shared_limit, see above) or as a dynamic thresholdas a function of the total shared pool still available.Values: 8=100%, 7=87.5% (7/8), 6=75% (6/8), 5=62.5% (5/8), 4=50% (4/8),3=37.5% (3/8), 2=25% (2/8) 1=12.5% (1/8), 0= 0% (values of 9-15 are illegal).
 *     PG1_THRESH_SEL   
 *
 ******************************************************************************/
#define BCM56800_A0_PG_THRESH_SELr 0x02d00023

#define BCM56800_A0_PG_THRESH_SELr_SIZE 4

/*
 * This structure should be used to declare and program PG_THRESH_SEL.
 *
 */
typedef union BCM56800_A0_PG_THRESH_SELr_s {
	uint32_t v[1];
	uint32_t pg_thresh_sel[1];
	uint32_t _pg_thresh_sel;
} BCM56800_A0_PG_THRESH_SELr_t;

#define BCM56800_A0_PG_THRESH_SELr_CLR(r) (r).pg_thresh_sel[0] = 0
#define BCM56800_A0_PG_THRESH_SELr_SET(r,d) (r).pg_thresh_sel[0] = d
#define BCM56800_A0_PG_THRESH_SELr_GET(r) (r).pg_thresh_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PG_THRESH_SELr_PG0_THRESH_SELf_GET(r) (((r).pg_thresh_sel[0]) & 0xf)
#define BCM56800_A0_PG_THRESH_SELr_PG0_THRESH_SELf_SET(r,f) (r).pg_thresh_sel[0]=(((r).pg_thresh_sel[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_PG_THRESH_SELr_PG1_THRESH_SELf_GET(r) ((((r).pg_thresh_sel[0]) >> 4) & 0xf)
#define BCM56800_A0_PG_THRESH_SELr_PG1_THRESH_SELf_SET(r,f) (r).pg_thresh_sel[0]=(((r).pg_thresh_sel[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PG_THRESH_SEL.
 *
 */
#define BCM56800_A0_READ_PG_THRESH_SELr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PG_THRESH_SELr,(r._pg_thresh_sel))
#define BCM56800_A0_WRITE_PG_THRESH_SELr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PG_THRESH_SELr,&(r._pg_thresh_sel))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PG_THRESH_SELr BCM56800_A0_PG_THRESH_SELr
#define PG_THRESH_SELr_SIZE BCM56800_A0_PG_THRESH_SELr_SIZE
typedef BCM56800_A0_PG_THRESH_SELr_t PG_THRESH_SELr_t;
#define PG_THRESH_SELr_CLR BCM56800_A0_PG_THRESH_SELr_CLR
#define PG_THRESH_SELr_SET BCM56800_A0_PG_THRESH_SELr_SET
#define PG_THRESH_SELr_GET BCM56800_A0_PG_THRESH_SELr_GET
#define PG_THRESH_SELr_PG0_THRESH_SELf_GET BCM56800_A0_PG_THRESH_SELr_PG0_THRESH_SELf_GET
#define PG_THRESH_SELr_PG0_THRESH_SELf_SET BCM56800_A0_PG_THRESH_SELr_PG0_THRESH_SELf_SET
#define PG_THRESH_SELr_PG1_THRESH_SELf_GET BCM56800_A0_PG_THRESH_SELr_PG1_THRESH_SELf_GET
#define PG_THRESH_SELr_PG1_THRESH_SELf_SET BCM56800_A0_PG_THRESH_SELr_PG1_THRESH_SELf_SET
#define READ_PG_THRESH_SELr BCM56800_A0_READ_PG_THRESH_SELr
#define WRITE_PG_THRESH_SELr BCM56800_A0_WRITE_PG_THRESH_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PG_THRESH_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PKTAGINGLIMIT
 * BLOCKS:   MMU
 * DESC:     Initial COS limit aging values
 * SIZE:     32
 * FIELDS:
 *     AGINGLIMITCOS0   COS 0 limit; Caution: do not write 6 or 7
 *     AGINGLIMITCOS1   COS 1 limit; Caution: do not write 6 or 7
 *     AGINGLIMITCOS2   COS 2 limit; Caution: do not write 6 or 7
 *     AGINGLIMITCOS3   COS 3 limit; Caution: do not write 6 or 7
 *     AGINGLIMITCOS4   COS 4 limit; Caution: do not write 6 or 7
 *     AGINGLIMITCOS5   COS 5 limit; Caution: do not write 6 or 7
 *     AGINGLIMITCOS6   COS 6 limit; Caution: do not write 6 or 7
 *     AGINGLIMITCOS7   COS 7 limit; Caution: do not write 6 or 7
 *
 ******************************************************************************/
#define BCM56800_A0_PKTAGINGLIMITr 0x0dd80001

#define BCM56800_A0_PKTAGINGLIMITr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGLIMIT.
 *
 */
typedef union BCM56800_A0_PKTAGINGLIMITr_s {
	uint32_t v[1];
	uint32_t pktaginglimit[1];
	uint32_t _pktaginglimit;
} BCM56800_A0_PKTAGINGLIMITr_t;

#define BCM56800_A0_PKTAGINGLIMITr_CLR(r) (r).pktaginglimit[0] = 0
#define BCM56800_A0_PKTAGINGLIMITr_SET(r,d) (r).pktaginglimit[0] = d
#define BCM56800_A0_PKTAGINGLIMITr_GET(r) (r).pktaginglimit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_GET(r) (((r).pktaginglimit[0]) & 0x7)
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_GET(r) ((((r).pktaginglimit[0]) >> 3) & 0x7)
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_GET(r) ((((r).pktaginglimit[0]) >> 6) & 0x7)
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_GET(r) ((((r).pktaginglimit[0]) >> 9) & 0x7)
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_GET(r) ((((r).pktaginglimit[0]) >> 12) & 0x7)
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_GET(r) ((((r).pktaginglimit[0]) >> 15) & 0x7)
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_GET(r) ((((r).pktaginglimit[0]) >> 18) & 0x7)
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_GET(r) ((((r).pktaginglimit[0]) >> 21) & 0x7)
#define BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_SET(r,f) (r).pktaginglimit[0]=(((r).pktaginglimit[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))

/*
 * These macros can be used to access PKTAGINGLIMIT.
 *
 */
#define BCM56800_A0_READ_PKTAGINGLIMITr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PKTAGINGLIMITr,(r._pktaginglimit))
#define BCM56800_A0_WRITE_PKTAGINGLIMITr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PKTAGINGLIMITr,&(r._pktaginglimit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTAGINGLIMITr BCM56800_A0_PKTAGINGLIMITr
#define PKTAGINGLIMITr_SIZE BCM56800_A0_PKTAGINGLIMITr_SIZE
typedef BCM56800_A0_PKTAGINGLIMITr_t PKTAGINGLIMITr_t;
#define PKTAGINGLIMITr_CLR BCM56800_A0_PKTAGINGLIMITr_CLR
#define PKTAGINGLIMITr_SET BCM56800_A0_PKTAGINGLIMITr_SET
#define PKTAGINGLIMITr_GET BCM56800_A0_PKTAGINGLIMITr_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS0f_GET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS0f_SET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS0f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS1f_GET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS1f_SET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS1f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS2f_GET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS2f_SET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS2f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS3f_GET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS3f_SET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS3f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS4f_GET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS4f_SET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS4f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS5f_GET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS5f_SET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS5f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS6f_GET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS6f_SET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS6f_SET
#define PKTAGINGLIMITr_AGINGLIMITCOS7f_GET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_GET
#define PKTAGINGLIMITr_AGINGLIMITCOS7f_SET BCM56800_A0_PKTAGINGLIMITr_AGINGLIMITCOS7f_SET
#define READ_PKTAGINGLIMITr BCM56800_A0_READ_PKTAGINGLIMITr
#define WRITE_PKTAGINGLIMITr BCM56800_A0_WRITE_PKTAGINGLIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PKTAGINGLIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PKTAGINGTIMER
 * BLOCKS:   MMU
 * DESC:     Aging granularity
 * SIZE:     32
 * FIELDS:
 *     DURATIONSELECT   Tick count to start aging
 *     AGINGTICKSEL     Base tick select
 *
 ******************************************************************************/
#define BCM56800_A0_PKTAGINGTIMERr 0x0dd80000

#define BCM56800_A0_PKTAGINGTIMERr_SIZE 4

/*
 * This structure should be used to declare and program PKTAGINGTIMER.
 *
 */
typedef union BCM56800_A0_PKTAGINGTIMERr_s {
	uint32_t v[1];
	uint32_t pktagingtimer[1];
	uint32_t _pktagingtimer;
} BCM56800_A0_PKTAGINGTIMERr_t;

#define BCM56800_A0_PKTAGINGTIMERr_CLR(r) (r).pktagingtimer[0] = 0
#define BCM56800_A0_PKTAGINGTIMERr_SET(r,d) (r).pktagingtimer[0] = d
#define BCM56800_A0_PKTAGINGTIMERr_GET(r) (r).pktagingtimer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PKTAGINGTIMERr_DURATIONSELECTf_GET(r) (((r).pktagingtimer[0]) & 0x1fff)
#define BCM56800_A0_PKTAGINGTIMERr_DURATIONSELECTf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM56800_A0_PKTAGINGTIMERr_AGINGTICKSELf_GET(r) ((((r).pktagingtimer[0]) >> 13) & 0x1)
#define BCM56800_A0_PKTAGINGTIMERr_AGINGTICKSELf_SET(r,f) (r).pktagingtimer[0]=(((r).pktagingtimer[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access PKTAGINGTIMER.
 *
 */
#define BCM56800_A0_READ_PKTAGINGTIMERr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PKTAGINGTIMERr,(r._pktagingtimer))
#define BCM56800_A0_WRITE_PKTAGINGTIMERr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PKTAGINGTIMERr,&(r._pktagingtimer))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTAGINGTIMERr BCM56800_A0_PKTAGINGTIMERr
#define PKTAGINGTIMERr_SIZE BCM56800_A0_PKTAGINGTIMERr_SIZE
typedef BCM56800_A0_PKTAGINGTIMERr_t PKTAGINGTIMERr_t;
#define PKTAGINGTIMERr_CLR BCM56800_A0_PKTAGINGTIMERr_CLR
#define PKTAGINGTIMERr_SET BCM56800_A0_PKTAGINGTIMERr_SET
#define PKTAGINGTIMERr_GET BCM56800_A0_PKTAGINGTIMERr_GET
#define PKTAGINGTIMERr_DURATIONSELECTf_GET BCM56800_A0_PKTAGINGTIMERr_DURATIONSELECTf_GET
#define PKTAGINGTIMERr_DURATIONSELECTf_SET BCM56800_A0_PKTAGINGTIMERr_DURATIONSELECTf_SET
#define PKTAGINGTIMERr_AGINGTICKSELf_GET BCM56800_A0_PKTAGINGTIMERr_AGINGTICKSELf_GET
#define PKTAGINGTIMERr_AGINGTICKSELf_SET BCM56800_A0_PKTAGINGTIMERr_AGINGTICKSELf_SET
#define READ_PKTAGINGTIMERr BCM56800_A0_READ_PKTAGINGTIMERr
#define WRITE_PKTAGINGTIMERr BCM56800_A0_WRITE_PKTAGINGTIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PKTAGINGTIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PKTLINKMEMDEBUG
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     TM               tm registers.
 *
 ******************************************************************************/
#define BCM56800_A0_PKTLINKMEMDEBUGr 0x10d8000a

#define BCM56800_A0_PKTLINKMEMDEBUGr_SIZE 4

/*
 * This structure should be used to declare and program PKTLINKMEMDEBUG.
 *
 */
typedef union BCM56800_A0_PKTLINKMEMDEBUGr_s {
	uint32_t v[1];
	uint32_t pktlinkmemdebug[1];
	uint32_t _pktlinkmemdebug;
} BCM56800_A0_PKTLINKMEMDEBUGr_t;

#define BCM56800_A0_PKTLINKMEMDEBUGr_CLR(r) (r).pktlinkmemdebug[0] = 0
#define BCM56800_A0_PKTLINKMEMDEBUGr_SET(r,d) (r).pktlinkmemdebug[0] = d
#define BCM56800_A0_PKTLINKMEMDEBUGr_GET(r) (r).pktlinkmemdebug[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PKTLINKMEMDEBUGr_TMf_GET(r) (((r).pktlinkmemdebug[0]) & 0xff)
#define BCM56800_A0_PKTLINKMEMDEBUGr_TMf_SET(r,f) (r).pktlinkmemdebug[0]=(((r).pktlinkmemdebug[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PKTLINKMEMDEBUG.
 *
 */
#define BCM56800_A0_READ_PKTLINKMEMDEBUGr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_PKTLINKMEMDEBUGr+(i),(r._pktlinkmemdebug))
#define BCM56800_A0_WRITE_PKTLINKMEMDEBUGr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_PKTLINKMEMDEBUGr+(i),&(r._pktlinkmemdebug))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTLINKMEMDEBUGr BCM56800_A0_PKTLINKMEMDEBUGr
#define PKTLINKMEMDEBUGr_SIZE BCM56800_A0_PKTLINKMEMDEBUGr_SIZE
typedef BCM56800_A0_PKTLINKMEMDEBUGr_t PKTLINKMEMDEBUGr_t;
#define PKTLINKMEMDEBUGr_CLR BCM56800_A0_PKTLINKMEMDEBUGr_CLR
#define PKTLINKMEMDEBUGr_SET BCM56800_A0_PKTLINKMEMDEBUGr_SET
#define PKTLINKMEMDEBUGr_GET BCM56800_A0_PKTLINKMEMDEBUGr_GET
#define PKTLINKMEMDEBUGr_TMf_GET BCM56800_A0_PKTLINKMEMDEBUGr_TMf_GET
#define PKTLINKMEMDEBUGr_TMf_SET BCM56800_A0_PKTLINKMEMDEBUGr_TMf_SET
#define READ_PKTLINKMEMDEBUGr BCM56800_A0_READ_PKTLINKMEMDEBUGr
#define WRITE_PKTLINKMEMDEBUGr BCM56800_A0_WRITE_PKTLINKMEMDEBUGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PKTLINKMEMDEBUGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_BRIDGE_BMAP
 * BLOCKS:   IPIPE
 * DESC:     Bitmap of ports with port_bridge enabled
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Bitmap of all XGE ports with port_bridge enabled. DO NOT include HiGig ports
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_BRIDGE_BMAPr 0x0e18064b

#define BCM56800_A0_PORT_BRIDGE_BMAPr_SIZE 4

/*
 * This structure should be used to declare and program PORT_BRIDGE_BMAP.
 *
 */
typedef union BCM56800_A0_PORT_BRIDGE_BMAPr_s {
	uint32_t v[1];
	uint32_t port_bridge_bmap[1];
	uint32_t _port_bridge_bmap;
} BCM56800_A0_PORT_BRIDGE_BMAPr_t;

#define BCM56800_A0_PORT_BRIDGE_BMAPr_CLR(r) (r).port_bridge_bmap[0] = 0
#define BCM56800_A0_PORT_BRIDGE_BMAPr_SET(r,d) (r).port_bridge_bmap[0] = d
#define BCM56800_A0_PORT_BRIDGE_BMAPr_GET(r) (r).port_bridge_bmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_BRIDGE_BMAPr_BITMAPf_GET(r) (((r).port_bridge_bmap[0]) & 0x1fffff)
#define BCM56800_A0_PORT_BRIDGE_BMAPr_BITMAPf_SET(r,f) (r).port_bridge_bmap[0]=(((r).port_bridge_bmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access PORT_BRIDGE_BMAP.
 *
 */
#define BCM56800_A0_READ_PORT_BRIDGE_BMAPr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PORT_BRIDGE_BMAPr,(r._port_bridge_bmap))
#define BCM56800_A0_WRITE_PORT_BRIDGE_BMAPr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PORT_BRIDGE_BMAPr,&(r._port_bridge_bmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_BRIDGE_BMAPr BCM56800_A0_PORT_BRIDGE_BMAPr
#define PORT_BRIDGE_BMAPr_SIZE BCM56800_A0_PORT_BRIDGE_BMAPr_SIZE
typedef BCM56800_A0_PORT_BRIDGE_BMAPr_t PORT_BRIDGE_BMAPr_t;
#define PORT_BRIDGE_BMAPr_CLR BCM56800_A0_PORT_BRIDGE_BMAPr_CLR
#define PORT_BRIDGE_BMAPr_SET BCM56800_A0_PORT_BRIDGE_BMAPr_SET
#define PORT_BRIDGE_BMAPr_GET BCM56800_A0_PORT_BRIDGE_BMAPr_GET
#define PORT_BRIDGE_BMAPr_BITMAPf_GET BCM56800_A0_PORT_BRIDGE_BMAPr_BITMAPf_GET
#define PORT_BRIDGE_BMAPr_BITMAPf_SET BCM56800_A0_PORT_BRIDGE_BMAPr_BITMAPf_SET
#define READ_PORT_BRIDGE_BMAPr BCM56800_A0_READ_PORT_BRIDGE_BMAPr
#define WRITE_PORT_BRIDGE_BMAPr BCM56800_A0_WRITE_PORT_BRIDGE_BMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_BRIDGE_BMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_COUNT
 * BLOCKS:   MMU
 * DESC:     PORT_COUNT
 * SIZE:     32
 * FIELDS:
 *     PORT_COUNT       It represents the total number of cells currently used in the buffer for traffic from a given port. Its not used by any threshold logic, but is provided for diagnostic purposes.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_COUNTr 0x02d00043

#define BCM56800_A0_PORT_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PORT_COUNT.
 *
 */
typedef union BCM56800_A0_PORT_COUNTr_s {
	uint32_t v[1];
	uint32_t port_count[1];
	uint32_t _port_count;
} BCM56800_A0_PORT_COUNTr_t;

#define BCM56800_A0_PORT_COUNTr_CLR(r) (r).port_count[0] = 0
#define BCM56800_A0_PORT_COUNTr_SET(r,d) (r).port_count[0] = d
#define BCM56800_A0_PORT_COUNTr_GET(r) (r).port_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_COUNTr_PORT_COUNTf_GET(r) (((r).port_count[0]) & 0x3fff)
#define BCM56800_A0_PORT_COUNTr_PORT_COUNTf_SET(r,f) (r).port_count[0]=(((r).port_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PORT_COUNT.
 *
 */
#define BCM56800_A0_READ_PORT_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_COUNTr,(r._port_count))
#define BCM56800_A0_WRITE_PORT_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_COUNTr,&(r._port_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_COUNTr BCM56800_A0_PORT_COUNTr
#define PORT_COUNTr_SIZE BCM56800_A0_PORT_COUNTr_SIZE
typedef BCM56800_A0_PORT_COUNTr_t PORT_COUNTr_t;
#define PORT_COUNTr_CLR BCM56800_A0_PORT_COUNTr_CLR
#define PORT_COUNTr_SET BCM56800_A0_PORT_COUNTr_SET
#define PORT_COUNTr_GET BCM56800_A0_PORT_COUNTr_GET
#define PORT_COUNTr_PORT_COUNTf_GET BCM56800_A0_PORT_COUNTr_PORT_COUNTf_GET
#define PORT_COUNTr_PORT_COUNTf_SET BCM56800_A0_PORT_COUNTr_PORT_COUNTf_SET
#define READ_PORT_COUNTr BCM56800_A0_READ_PORT_COUNTr
#define WRITE_PORT_COUNTr BCM56800_A0_WRITE_PORT_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_FC_STATUS
 * BLOCKS:   MMU
 * DESC:     PORT_FC_STATUS
 * SIZE:     32
 * FIELDS:
 *     PRIORITY_IBP_DROP_STATE This bitmap is set when a PG uses all it's headroom. At this point, each bit is set for all the priorities of this PG (which propagates back to the IPsw2) so that all incoming packets at this priority can be discarded. Each bit is reset when the "xon reset value" is reached as cells depart.
 *     PORT_GBL_CELLS_NEEDED When "ug" is set, this counter is set to the number of cells "reserved" for this port from the global headroom pool.It decrements as cells are received, and when the END cell is received, this value is used to put back the reserved-butunused number back into the global headroom pool.
 *     PKT_SIZE_SO_FAR  This is a running counter that increments for each cell that is received in a packet.
 *     UG               A temporary flag to indicate a port is receiving a packet and has started using cells from the global headroom space.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_FC_STATUSr 0x02d00060

#define BCM56800_A0_PORT_FC_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program PORT_FC_STATUS.
 *
 */
typedef union BCM56800_A0_PORT_FC_STATUSr_s {
	uint32_t v[1];
	uint32_t port_fc_status[1];
	uint32_t _port_fc_status;
} BCM56800_A0_PORT_FC_STATUSr_t;

#define BCM56800_A0_PORT_FC_STATUSr_CLR(r) (r).port_fc_status[0] = 0
#define BCM56800_A0_PORT_FC_STATUSr_SET(r,d) (r).port_fc_status[0] = d
#define BCM56800_A0_PORT_FC_STATUSr_GET(r) (r).port_fc_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_FC_STATUSr_PRIORITY_IBP_DROP_STATEf_GET(r) (((r).port_fc_status[0]) & 0x3fff)
#define BCM56800_A0_PORT_FC_STATUSr_PRIORITY_IBP_DROP_STATEf_SET(r,f) (r).port_fc_status[0]=(((r).port_fc_status[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_PORT_FC_STATUSr_PORT_GBL_CELLS_NEEDEDf_GET(r) ((((r).port_fc_status[0]) >> 16) & 0x7f)
#define BCM56800_A0_PORT_FC_STATUSr_PORT_GBL_CELLS_NEEDEDf_SET(r,f) (r).port_fc_status[0]=(((r).port_fc_status[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define BCM56800_A0_PORT_FC_STATUSr_PKT_SIZE_SO_FARf_GET(r) ((((r).port_fc_status[0]) >> 24) & 0x7f)
#define BCM56800_A0_PORT_FC_STATUSr_PKT_SIZE_SO_FARf_SET(r,f) (r).port_fc_status[0]=(((r).port_fc_status[0] & ~((uint32_t)0x7f << 24)) | ((((uint32_t)f) & 0x7f) << 24))
#define BCM56800_A0_PORT_FC_STATUSr_UGf_GET(r) ((((r).port_fc_status[0]) >> 31) & 0x1)
#define BCM56800_A0_PORT_FC_STATUSr_UGf_SET(r,f) (r).port_fc_status[0]=(((r).port_fc_status[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PORT_FC_STATUS.
 *
 */
#define BCM56800_A0_READ_PORT_FC_STATUSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_FC_STATUSr,(r._port_fc_status))
#define BCM56800_A0_WRITE_PORT_FC_STATUSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_FC_STATUSr,&(r._port_fc_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_FC_STATUSr BCM56800_A0_PORT_FC_STATUSr
#define PORT_FC_STATUSr_SIZE BCM56800_A0_PORT_FC_STATUSr_SIZE
typedef BCM56800_A0_PORT_FC_STATUSr_t PORT_FC_STATUSr_t;
#define PORT_FC_STATUSr_CLR BCM56800_A0_PORT_FC_STATUSr_CLR
#define PORT_FC_STATUSr_SET BCM56800_A0_PORT_FC_STATUSr_SET
#define PORT_FC_STATUSr_GET BCM56800_A0_PORT_FC_STATUSr_GET
#define PORT_FC_STATUSr_PRIORITY_IBP_DROP_STATEf_GET BCM56800_A0_PORT_FC_STATUSr_PRIORITY_IBP_DROP_STATEf_GET
#define PORT_FC_STATUSr_PRIORITY_IBP_DROP_STATEf_SET BCM56800_A0_PORT_FC_STATUSr_PRIORITY_IBP_DROP_STATEf_SET
#define PORT_FC_STATUSr_PORT_GBL_CELLS_NEEDEDf_GET BCM56800_A0_PORT_FC_STATUSr_PORT_GBL_CELLS_NEEDEDf_GET
#define PORT_FC_STATUSr_PORT_GBL_CELLS_NEEDEDf_SET BCM56800_A0_PORT_FC_STATUSr_PORT_GBL_CELLS_NEEDEDf_SET
#define PORT_FC_STATUSr_PKT_SIZE_SO_FARf_GET BCM56800_A0_PORT_FC_STATUSr_PKT_SIZE_SO_FARf_GET
#define PORT_FC_STATUSr_PKT_SIZE_SO_FARf_SET BCM56800_A0_PORT_FC_STATUSr_PKT_SIZE_SO_FARf_SET
#define PORT_FC_STATUSr_UGf_GET BCM56800_A0_PORT_FC_STATUSr_UGf_GET
#define PORT_FC_STATUSr_UGf_SET BCM56800_A0_PORT_FC_STATUSr_UGf_SET
#define READ_PORT_FC_STATUSr BCM56800_A0_READ_PORT_FC_STATUSr
#define WRITE_PORT_FC_STATUSr BCM56800_A0_WRITE_PORT_FC_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_FC_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  PORT_LAG_FAILOVER_SET
 * BLOCKS:   IPIPE
 * DESC:     Port LAG Failover Set Table
 * SIZE:     102
 * FIELDS:
 *     PORT0            failover port 0
 *     MODULE0          failover module id 0
 *     PORT1            failover port 1
 *     MODULE1          failover module id 1
 *     PORT2            failover port 2
 *     MODULE2          failover module id 2
 *     PORT3            failover port 3
 *     MODULE3          failover module id 3
 *     PORT4            failover port 4
 *     MODULE4          failover module id 4
 *     PORT5            failover port 5
 *     MODULE5          failover module id 5
 *     PORT6            failover port 6
 *     MODULE6          failover module id 6
 *     PORT7            failover port 7
 *     MODULE7          failover module id 7
 *     RTAG             Supported RTAG values
 *     FAILOVER_SET_SIZE Port LAG failover set size. If set to 0, size=1. If set to 1, size=2, and so on.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm 0x0e10c000

#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MIN 0
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MAX 19
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_CMAX(u) 19
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_SIZE 13

/*
 * This structure should be used to declare and program PORT_LAG_FAILOVER_SET.
 *
 */
typedef union BCM56800_A0_PORT_LAG_FAILOVER_SETm_s {
	uint32_t v[4];
	uint32_t port_lag_failover_set[4];
	uint32_t _port_lag_failover_set;
} BCM56800_A0_PORT_LAG_FAILOVER_SETm_t;

#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_CLR(r) CDK_MEMSET(&((r)._port_lag_failover_set), 0, sizeof(BCM56800_A0_PORT_LAG_FAILOVER_SETm_t))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_SET(r,i,d) (r).port_lag_failover_set[i] = d
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_GET(r,i) (r).port_lag_failover_set[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT0f_GET(r) (((r).port_lag_failover_set[0]) & 0x1f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT0f_SET(r,f) (r).port_lag_failover_set[0]=(((r).port_lag_failover_set[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE0f_GET(r) ((((r).port_lag_failover_set[0]) >> 5) & 0x7f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE0f_SET(r,f) (r).port_lag_failover_set[0]=(((r).port_lag_failover_set[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT1f_GET(r) ((((r).port_lag_failover_set[0]) >> 12) & 0x1f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT1f_SET(r,f) (r).port_lag_failover_set[0]=(((r).port_lag_failover_set[0] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE1f_GET(r) ((((r).port_lag_failover_set[0]) >> 17) & 0x7f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE1f_SET(r,f) (r).port_lag_failover_set[0]=(((r).port_lag_failover_set[0] & ~((uint32_t)0x7f << 17)) | ((((uint32_t)f) & 0x7f) << 17))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT2f_GET(r) ((((r).port_lag_failover_set[0]) >> 24) & 0x1f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT2f_SET(r,f) (r).port_lag_failover_set[0]=(((r).port_lag_failover_set[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE2f_GET(r) cdk_field32_get((r).port_lag_failover_set,29,35)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE2f_SET(r,f) cdk_field32_set((r).port_lag_failover_set,29,35,f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT3f_GET(r) ((((r).port_lag_failover_set[1]) >> 4) & 0x1f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT3f_SET(r,f) (r).port_lag_failover_set[1]=(((r).port_lag_failover_set[1] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE3f_GET(r) ((((r).port_lag_failover_set[1]) >> 9) & 0x7f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE3f_SET(r,f) (r).port_lag_failover_set[1]=(((r).port_lag_failover_set[1] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT4f_GET(r) ((((r).port_lag_failover_set[1]) >> 16) & 0x1f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT4f_SET(r,f) (r).port_lag_failover_set[1]=(((r).port_lag_failover_set[1] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE4f_GET(r) ((((r).port_lag_failover_set[1]) >> 21) & 0x7f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE4f_SET(r,f) (r).port_lag_failover_set[1]=(((r).port_lag_failover_set[1] & ~((uint32_t)0x7f << 21)) | ((((uint32_t)f) & 0x7f) << 21))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT5f_GET(r) cdk_field32_get((r).port_lag_failover_set,60,64)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT5f_SET(r,f) cdk_field32_set((r).port_lag_failover_set,60,64,f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE5f_GET(r) ((((r).port_lag_failover_set[2]) >> 1) & 0x7f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE5f_SET(r,f) (r).port_lag_failover_set[2]=(((r).port_lag_failover_set[2] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT6f_GET(r) ((((r).port_lag_failover_set[2]) >> 8) & 0x1f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT6f_SET(r,f) (r).port_lag_failover_set[2]=(((r).port_lag_failover_set[2] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE6f_GET(r) ((((r).port_lag_failover_set[2]) >> 13) & 0x7f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE6f_SET(r,f) (r).port_lag_failover_set[2]=(((r).port_lag_failover_set[2] & ~((uint32_t)0x7f << 13)) | ((((uint32_t)f) & 0x7f) << 13))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT7f_GET(r) ((((r).port_lag_failover_set[2]) >> 20) & 0x1f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT7f_SET(r,f) (r).port_lag_failover_set[2]=(((r).port_lag_failover_set[2] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE7f_GET(r) ((((r).port_lag_failover_set[2]) >> 25) & 0x7f)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE7f_SET(r,f) (r).port_lag_failover_set[2]=(((r).port_lag_failover_set[2] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_RTAGf_GET(r) (((r).port_lag_failover_set[3]) & 0x7)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_RTAGf_SET(r,f) (r).port_lag_failover_set[3]=(((r).port_lag_failover_set[3] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_FAILOVER_SET_SIZEf_GET(r) ((((r).port_lag_failover_set[3]) >> 3) & 0x7)
#define BCM56800_A0_PORT_LAG_FAILOVER_SETm_FAILOVER_SET_SIZEf_SET(r,f) (r).port_lag_failover_set[3]=(((r).port_lag_failover_set[3] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))

/*
 * These macros can be used to access PORT_LAG_FAILOVER_SET.
 *
 */
#define BCM56800_A0_READ_PORT_LAG_FAILOVER_SETm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_PORT_LAG_FAILOVER_SETm,i,(m._port_lag_failover_set),4)
#define BCM56800_A0_WRITE_PORT_LAG_FAILOVER_SETm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_PORT_LAG_FAILOVER_SETm,i,&(m._port_lag_failover_set),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_LAG_FAILOVER_SETm BCM56800_A0_PORT_LAG_FAILOVER_SETm
#define PORT_LAG_FAILOVER_SETm_MIN BCM56800_A0_PORT_LAG_FAILOVER_SETm_MIN
#define PORT_LAG_FAILOVER_SETm_MAX BCM56800_A0_PORT_LAG_FAILOVER_SETm_MAX
#define PORT_LAG_FAILOVER_SETm_CMAX(u) BCM56800_A0_PORT_LAG_FAILOVER_SETm_CMAX(u)
#define PORT_LAG_FAILOVER_SETm_SIZE BCM56800_A0_PORT_LAG_FAILOVER_SETm_SIZE
typedef BCM56800_A0_PORT_LAG_FAILOVER_SETm_t PORT_LAG_FAILOVER_SETm_t;
#define PORT_LAG_FAILOVER_SETm_CLR BCM56800_A0_PORT_LAG_FAILOVER_SETm_CLR
#define PORT_LAG_FAILOVER_SETm_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_SET
#define PORT_LAG_FAILOVER_SETm_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_GET
#define PORT_LAG_FAILOVER_SETm_PORT0f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT0f_GET
#define PORT_LAG_FAILOVER_SETm_PORT0f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT0f_SET
#define PORT_LAG_FAILOVER_SETm_MODULE0f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE0f_GET
#define PORT_LAG_FAILOVER_SETm_MODULE0f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE0f_SET
#define PORT_LAG_FAILOVER_SETm_PORT1f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT1f_GET
#define PORT_LAG_FAILOVER_SETm_PORT1f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT1f_SET
#define PORT_LAG_FAILOVER_SETm_MODULE1f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE1f_GET
#define PORT_LAG_FAILOVER_SETm_MODULE1f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE1f_SET
#define PORT_LAG_FAILOVER_SETm_PORT2f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT2f_GET
#define PORT_LAG_FAILOVER_SETm_PORT2f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT2f_SET
#define PORT_LAG_FAILOVER_SETm_MODULE2f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE2f_GET
#define PORT_LAG_FAILOVER_SETm_MODULE2f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE2f_SET
#define PORT_LAG_FAILOVER_SETm_PORT3f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT3f_GET
#define PORT_LAG_FAILOVER_SETm_PORT3f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT3f_SET
#define PORT_LAG_FAILOVER_SETm_MODULE3f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE3f_GET
#define PORT_LAG_FAILOVER_SETm_MODULE3f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE3f_SET
#define PORT_LAG_FAILOVER_SETm_PORT4f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT4f_GET
#define PORT_LAG_FAILOVER_SETm_PORT4f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT4f_SET
#define PORT_LAG_FAILOVER_SETm_MODULE4f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE4f_GET
#define PORT_LAG_FAILOVER_SETm_MODULE4f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE4f_SET
#define PORT_LAG_FAILOVER_SETm_PORT5f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT5f_GET
#define PORT_LAG_FAILOVER_SETm_PORT5f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT5f_SET
#define PORT_LAG_FAILOVER_SETm_MODULE5f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE5f_GET
#define PORT_LAG_FAILOVER_SETm_MODULE5f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE5f_SET
#define PORT_LAG_FAILOVER_SETm_PORT6f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT6f_GET
#define PORT_LAG_FAILOVER_SETm_PORT6f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT6f_SET
#define PORT_LAG_FAILOVER_SETm_MODULE6f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE6f_GET
#define PORT_LAG_FAILOVER_SETm_MODULE6f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE6f_SET
#define PORT_LAG_FAILOVER_SETm_PORT7f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT7f_GET
#define PORT_LAG_FAILOVER_SETm_PORT7f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_PORT7f_SET
#define PORT_LAG_FAILOVER_SETm_MODULE7f_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE7f_GET
#define PORT_LAG_FAILOVER_SETm_MODULE7f_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_MODULE7f_SET
#define PORT_LAG_FAILOVER_SETm_RTAGf_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_RTAGf_GET
#define PORT_LAG_FAILOVER_SETm_RTAGf_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_RTAGf_SET
#define PORT_LAG_FAILOVER_SETm_FAILOVER_SET_SIZEf_GET BCM56800_A0_PORT_LAG_FAILOVER_SETm_FAILOVER_SET_SIZEf_GET
#define PORT_LAG_FAILOVER_SETm_FAILOVER_SET_SIZEf_SET BCM56800_A0_PORT_LAG_FAILOVER_SETm_FAILOVER_SET_SIZEf_SET
#define READ_PORT_LAG_FAILOVER_SETm BCM56800_A0_READ_PORT_LAG_FAILOVER_SETm
#define WRITE_PORT_LAG_FAILOVER_SETm BCM56800_A0_WRITE_PORT_LAG_FAILOVER_SETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_LAG_FAILOVER_SETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_MAX_PKT_SIZE
 * BLOCKS:   MMU
 * DESC:     PORT_MAX_PKT_SIZE
 * SIZE:     32
 * FIELDS:
 *     PORT_MAX_PKT_SIZE This is the maximum packet size for this input port (in cells). It is used when the global headroom is enabled, and the global headroom pool is tested to see if there are enough cells to receive the remaining portion of a partially received packet in case the packet turns out to be the largest size allowed.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_MAX_PKT_SIZEr 0x02d00021

#define BCM56800_A0_PORT_MAX_PKT_SIZEr_SIZE 4

/*
 * This structure should be used to declare and program PORT_MAX_PKT_SIZE.
 *
 */
typedef union BCM56800_A0_PORT_MAX_PKT_SIZEr_s {
	uint32_t v[1];
	uint32_t port_max_pkt_size[1];
	uint32_t _port_max_pkt_size;
} BCM56800_A0_PORT_MAX_PKT_SIZEr_t;

#define BCM56800_A0_PORT_MAX_PKT_SIZEr_CLR(r) (r).port_max_pkt_size[0] = 0
#define BCM56800_A0_PORT_MAX_PKT_SIZEr_SET(r,d) (r).port_max_pkt_size[0] = d
#define BCM56800_A0_PORT_MAX_PKT_SIZEr_GET(r) (r).port_max_pkt_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_MAX_PKT_SIZEr_PORT_MAX_PKT_SIZEf_GET(r) (((r).port_max_pkt_size[0]) & 0x7f)
#define BCM56800_A0_PORT_MAX_PKT_SIZEr_PORT_MAX_PKT_SIZEf_SET(r,f) (r).port_max_pkt_size[0]=(((r).port_max_pkt_size[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f))

/*
 * These macros can be used to access PORT_MAX_PKT_SIZE.
 *
 */
#define BCM56800_A0_READ_PORT_MAX_PKT_SIZEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_MAX_PKT_SIZEr,(r._port_max_pkt_size))
#define BCM56800_A0_WRITE_PORT_MAX_PKT_SIZEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_MAX_PKT_SIZEr,&(r._port_max_pkt_size))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_MAX_PKT_SIZEr BCM56800_A0_PORT_MAX_PKT_SIZEr
#define PORT_MAX_PKT_SIZEr_SIZE BCM56800_A0_PORT_MAX_PKT_SIZEr_SIZE
typedef BCM56800_A0_PORT_MAX_PKT_SIZEr_t PORT_MAX_PKT_SIZEr_t;
#define PORT_MAX_PKT_SIZEr_CLR BCM56800_A0_PORT_MAX_PKT_SIZEr_CLR
#define PORT_MAX_PKT_SIZEr_SET BCM56800_A0_PORT_MAX_PKT_SIZEr_SET
#define PORT_MAX_PKT_SIZEr_GET BCM56800_A0_PORT_MAX_PKT_SIZEr_GET
#define PORT_MAX_PKT_SIZEr_PORT_MAX_PKT_SIZEf_GET BCM56800_A0_PORT_MAX_PKT_SIZEr_PORT_MAX_PKT_SIZEf_GET
#define PORT_MAX_PKT_SIZEr_PORT_MAX_PKT_SIZEf_SET BCM56800_A0_PORT_MAX_PKT_SIZEr_PORT_MAX_PKT_SIZEf_SET
#define READ_PORT_MAX_PKT_SIZEr BCM56800_A0_READ_PORT_MAX_PKT_SIZEr
#define WRITE_PORT_MAX_PKT_SIZEr BCM56800_A0_WRITE_PORT_MAX_PKT_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_MAX_PKT_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_MIN
 * BLOCKS:   MMU
 * DESC:     PORT_MIN
 * SIZE:     32
 * FIELDS:
 *     PORT_MIN         Minimum cells guaranteed for the input port before using cells from the shared pool.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_MINr 0x02d00020

#define BCM56800_A0_PORT_MINr_SIZE 4

/*
 * This structure should be used to declare and program PORT_MIN.
 *
 */
typedef union BCM56800_A0_PORT_MINr_s {
	uint32_t v[1];
	uint32_t port_min[1];
	uint32_t _port_min;
} BCM56800_A0_PORT_MINr_t;

#define BCM56800_A0_PORT_MINr_CLR(r) (r).port_min[0] = 0
#define BCM56800_A0_PORT_MINr_SET(r,d) (r).port_min[0] = d
#define BCM56800_A0_PORT_MINr_GET(r) (r).port_min[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_MINr_PORT_MINf_GET(r) (((r).port_min[0]) & 0xfff)
#define BCM56800_A0_PORT_MINr_PORT_MINf_SET(r,f) (r).port_min[0]=(((r).port_min[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access PORT_MIN.
 *
 */
#define BCM56800_A0_READ_PORT_MINr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_MINr,(r._port_min))
#define BCM56800_A0_WRITE_PORT_MINr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_MINr,&(r._port_min))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_MINr BCM56800_A0_PORT_MINr
#define PORT_MINr_SIZE BCM56800_A0_PORT_MINr_SIZE
typedef BCM56800_A0_PORT_MINr_t PORT_MINr_t;
#define PORT_MINr_CLR BCM56800_A0_PORT_MINr_CLR
#define PORT_MINr_SET BCM56800_A0_PORT_MINr_SET
#define PORT_MINr_GET BCM56800_A0_PORT_MINr_GET
#define PORT_MINr_PORT_MINf_GET BCM56800_A0_PORT_MINr_PORT_MINf_GET
#define PORT_MINr_PORT_MINf_SET BCM56800_A0_PORT_MINr_PORT_MINf_SET
#define READ_PORT_MINr BCM56800_A0_READ_PORT_MINr
#define WRITE_PORT_MINr BCM56800_A0_WRITE_PORT_MINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_MINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_MIN_COUNT
 * BLOCKS:   MMU
 * DESC:     PORT_MIN_COUNT
 * SIZE:     32
 * FIELDS:
 *     PORT_MIN_COUNT   It represents the number of cells taken from the port's minimum guarantee space. at any point in time, not including and SC or QM cells.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_MIN_COUNTr 0x02d00044

#define BCM56800_A0_PORT_MIN_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PORT_MIN_COUNT.
 *
 */
typedef union BCM56800_A0_PORT_MIN_COUNTr_s {
	uint32_t v[1];
	uint32_t port_min_count[1];
	uint32_t _port_min_count;
} BCM56800_A0_PORT_MIN_COUNTr_t;

#define BCM56800_A0_PORT_MIN_COUNTr_CLR(r) (r).port_min_count[0] = 0
#define BCM56800_A0_PORT_MIN_COUNTr_SET(r,d) (r).port_min_count[0] = d
#define BCM56800_A0_PORT_MIN_COUNTr_GET(r) (r).port_min_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_MIN_COUNTr_PORT_MIN_COUNTf_GET(r) (((r).port_min_count[0]) & 0xfff)
#define BCM56800_A0_PORT_MIN_COUNTr_PORT_MIN_COUNTf_SET(r,f) (r).port_min_count[0]=(((r).port_min_count[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))

/*
 * These macros can be used to access PORT_MIN_COUNT.
 *
 */
#define BCM56800_A0_READ_PORT_MIN_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_MIN_COUNTr,(r._port_min_count))
#define BCM56800_A0_WRITE_PORT_MIN_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_MIN_COUNTr,&(r._port_min_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_MIN_COUNTr BCM56800_A0_PORT_MIN_COUNTr
#define PORT_MIN_COUNTr_SIZE BCM56800_A0_PORT_MIN_COUNTr_SIZE
typedef BCM56800_A0_PORT_MIN_COUNTr_t PORT_MIN_COUNTr_t;
#define PORT_MIN_COUNTr_CLR BCM56800_A0_PORT_MIN_COUNTr_CLR
#define PORT_MIN_COUNTr_SET BCM56800_A0_PORT_MIN_COUNTr_SET
#define PORT_MIN_COUNTr_GET BCM56800_A0_PORT_MIN_COUNTr_GET
#define PORT_MIN_COUNTr_PORT_MIN_COUNTf_GET BCM56800_A0_PORT_MIN_COUNTr_PORT_MIN_COUNTf_GET
#define PORT_MIN_COUNTr_PORT_MIN_COUNTf_SET BCM56800_A0_PORT_MIN_COUNTr_PORT_MIN_COUNTf_SET
#define READ_PORT_MIN_COUNTr BCM56800_A0_READ_PORT_MIN_COUNTr
#define WRITE_PORT_MIN_COUNTr BCM56800_A0_WRITE_PORT_MIN_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_MIN_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_PRI_GRP
 * BLOCKS:   MMU
 * DESC:     PORT_PRI_GRP
 * SIZE:     32
 * FIELDS:
 *     PG0_GRP          This register contains the mapping of input priority to priority group. It is also used by the hardware for the reversemapping of PG to priorit(ies). There is a separate register for each input port and it is initialized by software.Values: 2'b00=PG0, 2'b01=PG1, 2'b10=PG2, 2'b11=Illegal.
 *     PG1_GRP          
 *     PG2_GRP          
 *     PG3_GRP          
 *     PG4_GRP          
 *     PG5_GRP          
 *     PG6_GRP          
 *     PG7_GRP          
 *     PG8_GRP          
 *     PG9_GRP          
 *     PG10_GRP         
 *     PG11_GRP         
 *     PG12_GRP         
 *     PG13_GRP         
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_PRI_GRPr 0x02d0002e

#define BCM56800_A0_PORT_PRI_GRPr_SIZE 4

/*
 * This structure should be used to declare and program PORT_PRI_GRP.
 *
 */
typedef union BCM56800_A0_PORT_PRI_GRPr_s {
	uint32_t v[1];
	uint32_t port_pri_grp[1];
	uint32_t _port_pri_grp;
} BCM56800_A0_PORT_PRI_GRPr_t;

#define BCM56800_A0_PORT_PRI_GRPr_CLR(r) (r).port_pri_grp[0] = 0
#define BCM56800_A0_PORT_PRI_GRPr_SET(r,d) (r).port_pri_grp[0] = d
#define BCM56800_A0_PORT_PRI_GRPr_GET(r) (r).port_pri_grp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_PRI_GRPr_PG0_GRPf_GET(r) (((r).port_pri_grp[0]) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG0_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_PORT_PRI_GRPr_PG1_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 2) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG1_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_PORT_PRI_GRPr_PG2_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 4) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG2_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_PORT_PRI_GRPr_PG3_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 6) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG3_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_PORT_PRI_GRPr_PG4_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 8) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG4_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56800_A0_PORT_PRI_GRPr_PG5_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 10) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG5_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56800_A0_PORT_PRI_GRPr_PG6_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 12) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG6_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56800_A0_PORT_PRI_GRPr_PG7_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 14) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG7_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56800_A0_PORT_PRI_GRPr_PG8_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 16) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG8_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_PORT_PRI_GRPr_PG9_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 18) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG9_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56800_A0_PORT_PRI_GRPr_PG10_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 20) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG10_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56800_A0_PORT_PRI_GRPr_PG11_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 22) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG11_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56800_A0_PORT_PRI_GRPr_PG12_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 24) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG12_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56800_A0_PORT_PRI_GRPr_PG13_GRPf_GET(r) ((((r).port_pri_grp[0]) >> 26) & 0x3)
#define BCM56800_A0_PORT_PRI_GRPr_PG13_GRPf_SET(r,f) (r).port_pri_grp[0]=(((r).port_pri_grp[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))

/*
 * These macros can be used to access PORT_PRI_GRP.
 *
 */
#define BCM56800_A0_READ_PORT_PRI_GRPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_PRI_GRPr,(r._port_pri_grp))
#define BCM56800_A0_WRITE_PORT_PRI_GRPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_PRI_GRPr,&(r._port_pri_grp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_PRI_GRPr BCM56800_A0_PORT_PRI_GRPr
#define PORT_PRI_GRPr_SIZE BCM56800_A0_PORT_PRI_GRPr_SIZE
typedef BCM56800_A0_PORT_PRI_GRPr_t PORT_PRI_GRPr_t;
#define PORT_PRI_GRPr_CLR BCM56800_A0_PORT_PRI_GRPr_CLR
#define PORT_PRI_GRPr_SET BCM56800_A0_PORT_PRI_GRPr_SET
#define PORT_PRI_GRPr_GET BCM56800_A0_PORT_PRI_GRPr_GET
#define PORT_PRI_GRPr_PG0_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG0_GRPf_GET
#define PORT_PRI_GRPr_PG0_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG0_GRPf_SET
#define PORT_PRI_GRPr_PG1_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG1_GRPf_GET
#define PORT_PRI_GRPr_PG1_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG1_GRPf_SET
#define PORT_PRI_GRPr_PG2_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG2_GRPf_GET
#define PORT_PRI_GRPr_PG2_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG2_GRPf_SET
#define PORT_PRI_GRPr_PG3_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG3_GRPf_GET
#define PORT_PRI_GRPr_PG3_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG3_GRPf_SET
#define PORT_PRI_GRPr_PG4_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG4_GRPf_GET
#define PORT_PRI_GRPr_PG4_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG4_GRPf_SET
#define PORT_PRI_GRPr_PG5_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG5_GRPf_GET
#define PORT_PRI_GRPr_PG5_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG5_GRPf_SET
#define PORT_PRI_GRPr_PG6_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG6_GRPf_GET
#define PORT_PRI_GRPr_PG6_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG6_GRPf_SET
#define PORT_PRI_GRPr_PG7_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG7_GRPf_GET
#define PORT_PRI_GRPr_PG7_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG7_GRPf_SET
#define PORT_PRI_GRPr_PG8_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG8_GRPf_GET
#define PORT_PRI_GRPr_PG8_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG8_GRPf_SET
#define PORT_PRI_GRPr_PG9_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG9_GRPf_GET
#define PORT_PRI_GRPr_PG9_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG9_GRPf_SET
#define PORT_PRI_GRPr_PG10_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG10_GRPf_GET
#define PORT_PRI_GRPr_PG10_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG10_GRPf_SET
#define PORT_PRI_GRPr_PG11_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG11_GRPf_GET
#define PORT_PRI_GRPr_PG11_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG11_GRPf_SET
#define PORT_PRI_GRPr_PG12_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG12_GRPf_GET
#define PORT_PRI_GRPr_PG12_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG12_GRPf_SET
#define PORT_PRI_GRPr_PG13_GRPf_GET BCM56800_A0_PORT_PRI_GRPr_PG13_GRPf_GET
#define PORT_PRI_GRPr_PG13_GRPf_SET BCM56800_A0_PORT_PRI_GRPr_PG13_GRPf_SET
#define READ_PORT_PRI_GRPr BCM56800_A0_READ_PORT_PRI_GRPr
#define WRITE_PORT_PRI_GRPr BCM56800_A0_WRITE_PORT_PRI_GRPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_PRI_GRPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_PRI_XON_ENABLE
 * BLOCKS:   MMU
 * DESC:     PORT_PRI_XON_ENABLE
 * SIZE:     32
 * FIELDS:
 *     PORT_PRI_XON_ENABLE This is an enable per priority per port to enable the generation of XON and XOFF LLFC messagesfor that priority.
 *     PORT_PG2PAUSE_DISABLE This is the disable bit per port to disable the pg2_lm_st from going to gxport to generate pause frame.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_PRI_XON_ENABLEr 0x02d0002f

#define BCM56800_A0_PORT_PRI_XON_ENABLEr_SIZE 4

/*
 * This structure should be used to declare and program PORT_PRI_XON_ENABLE.
 *
 */
typedef union BCM56800_A0_PORT_PRI_XON_ENABLEr_s {
	uint32_t v[1];
	uint32_t port_pri_xon_enable[1];
	uint32_t _port_pri_xon_enable;
} BCM56800_A0_PORT_PRI_XON_ENABLEr_t;

#define BCM56800_A0_PORT_PRI_XON_ENABLEr_CLR(r) (r).port_pri_xon_enable[0] = 0
#define BCM56800_A0_PORT_PRI_XON_ENABLEr_SET(r,d) (r).port_pri_xon_enable[0] = d
#define BCM56800_A0_PORT_PRI_XON_ENABLEr_GET(r) (r).port_pri_xon_enable[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_PRI_XON_ENABLEr_PORT_PRI_XON_ENABLEf_GET(r) (((r).port_pri_xon_enable[0]) & 0x3fff)
#define BCM56800_A0_PORT_PRI_XON_ENABLEr_PORT_PRI_XON_ENABLEf_SET(r,f) (r).port_pri_xon_enable[0]=(((r).port_pri_xon_enable[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_PORT_PRI_XON_ENABLEr_PORT_PG2PAUSE_DISABLEf_GET(r) ((((r).port_pri_xon_enable[0]) >> 16) & 0x1)
#define BCM56800_A0_PORT_PRI_XON_ENABLEr_PORT_PG2PAUSE_DISABLEf_SET(r,f) (r).port_pri_xon_enable[0]=(((r).port_pri_xon_enable[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access PORT_PRI_XON_ENABLE.
 *
 */
#define BCM56800_A0_READ_PORT_PRI_XON_ENABLEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_PRI_XON_ENABLEr,(r._port_pri_xon_enable))
#define BCM56800_A0_WRITE_PORT_PRI_XON_ENABLEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_PRI_XON_ENABLEr,&(r._port_pri_xon_enable))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_PRI_XON_ENABLEr BCM56800_A0_PORT_PRI_XON_ENABLEr
#define PORT_PRI_XON_ENABLEr_SIZE BCM56800_A0_PORT_PRI_XON_ENABLEr_SIZE
typedef BCM56800_A0_PORT_PRI_XON_ENABLEr_t PORT_PRI_XON_ENABLEr_t;
#define PORT_PRI_XON_ENABLEr_CLR BCM56800_A0_PORT_PRI_XON_ENABLEr_CLR
#define PORT_PRI_XON_ENABLEr_SET BCM56800_A0_PORT_PRI_XON_ENABLEr_SET
#define PORT_PRI_XON_ENABLEr_GET BCM56800_A0_PORT_PRI_XON_ENABLEr_GET
#define PORT_PRI_XON_ENABLEr_PORT_PRI_XON_ENABLEf_GET BCM56800_A0_PORT_PRI_XON_ENABLEr_PORT_PRI_XON_ENABLEf_GET
#define PORT_PRI_XON_ENABLEr_PORT_PRI_XON_ENABLEf_SET BCM56800_A0_PORT_PRI_XON_ENABLEr_PORT_PRI_XON_ENABLEf_SET
#define PORT_PRI_XON_ENABLEr_PORT_PG2PAUSE_DISABLEf_GET BCM56800_A0_PORT_PRI_XON_ENABLEr_PORT_PG2PAUSE_DISABLEf_GET
#define PORT_PRI_XON_ENABLEr_PORT_PG2PAUSE_DISABLEf_SET BCM56800_A0_PORT_PRI_XON_ENABLEr_PORT_PG2PAUSE_DISABLEf_SET
#define READ_PORT_PRI_XON_ENABLEr BCM56800_A0_READ_PORT_PRI_XON_ENABLEr
#define WRITE_PORT_PRI_XON_ENABLEr BCM56800_A0_WRITE_PORT_PRI_XON_ENABLEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_PRI_XON_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_QM_MIN
 * BLOCKS:   MMU
 * DESC:     PORT_QM_MIN
 * SIZE:     32
 * FIELDS:
 *     PORT_QM_MIN      This register is the number of cells reserved for the QM-class traffic.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_QM_MINr 0x02d00031

#define BCM56800_A0_PORT_QM_MINr_SIZE 4

/*
 * This structure should be used to declare and program PORT_QM_MIN.
 *
 */
typedef union BCM56800_A0_PORT_QM_MINr_s {
	uint32_t v[1];
	uint32_t port_qm_min[1];
	uint32_t _port_qm_min;
} BCM56800_A0_PORT_QM_MINr_t;

#define BCM56800_A0_PORT_QM_MINr_CLR(r) (r).port_qm_min[0] = 0
#define BCM56800_A0_PORT_QM_MINr_SET(r,d) (r).port_qm_min[0] = d
#define BCM56800_A0_PORT_QM_MINr_GET(r) (r).port_qm_min[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_QM_MINr_PORT_QM_MINf_GET(r) (((r).port_qm_min[0]) & 0x3ff)
#define BCM56800_A0_PORT_QM_MINr_PORT_QM_MINf_SET(r,f) (r).port_qm_min[0]=(((r).port_qm_min[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PORT_QM_MIN.
 *
 */
#define BCM56800_A0_READ_PORT_QM_MINr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_QM_MINr,(r._port_qm_min))
#define BCM56800_A0_WRITE_PORT_QM_MINr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_QM_MINr,&(r._port_qm_min))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_QM_MINr BCM56800_A0_PORT_QM_MINr
#define PORT_QM_MINr_SIZE BCM56800_A0_PORT_QM_MINr_SIZE
typedef BCM56800_A0_PORT_QM_MINr_t PORT_QM_MINr_t;
#define PORT_QM_MINr_CLR BCM56800_A0_PORT_QM_MINr_CLR
#define PORT_QM_MINr_SET BCM56800_A0_PORT_QM_MINr_SET
#define PORT_QM_MINr_GET BCM56800_A0_PORT_QM_MINr_GET
#define PORT_QM_MINr_PORT_QM_MINf_GET BCM56800_A0_PORT_QM_MINr_PORT_QM_MINf_GET
#define PORT_QM_MINr_PORT_QM_MINf_SET BCM56800_A0_PORT_QM_MINr_PORT_QM_MINf_SET
#define READ_PORT_QM_MINr BCM56800_A0_READ_PORT_QM_MINr
#define WRITE_PORT_QM_MINr BCM56800_A0_WRITE_PORT_QM_MINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_QM_MINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_QM_MIN_COUNT
 * BLOCKS:   MMU
 * DESC:     PORT_QM_MIN_COUNT
 * SIZE:     32
 * FIELDS:
 *     PORT_QM_MIN_COUNT It represents the number of cells used for QM-class traffic by the input port from its min guarantee.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_QM_MIN_COUNTr 0x02d00046

#define BCM56800_A0_PORT_QM_MIN_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PORT_QM_MIN_COUNT.
 *
 */
typedef union BCM56800_A0_PORT_QM_MIN_COUNTr_s {
	uint32_t v[1];
	uint32_t port_qm_min_count[1];
	uint32_t _port_qm_min_count;
} BCM56800_A0_PORT_QM_MIN_COUNTr_t;

#define BCM56800_A0_PORT_QM_MIN_COUNTr_CLR(r) (r).port_qm_min_count[0] = 0
#define BCM56800_A0_PORT_QM_MIN_COUNTr_SET(r,d) (r).port_qm_min_count[0] = d
#define BCM56800_A0_PORT_QM_MIN_COUNTr_GET(r) (r).port_qm_min_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_QM_MIN_COUNTr_PORT_QM_MIN_COUNTf_GET(r) (((r).port_qm_min_count[0]) & 0x3ff)
#define BCM56800_A0_PORT_QM_MIN_COUNTr_PORT_QM_MIN_COUNTf_SET(r,f) (r).port_qm_min_count[0]=(((r).port_qm_min_count[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PORT_QM_MIN_COUNT.
 *
 */
#define BCM56800_A0_READ_PORT_QM_MIN_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_QM_MIN_COUNTr,(r._port_qm_min_count))
#define BCM56800_A0_WRITE_PORT_QM_MIN_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_QM_MIN_COUNTr,&(r._port_qm_min_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_QM_MIN_COUNTr BCM56800_A0_PORT_QM_MIN_COUNTr
#define PORT_QM_MIN_COUNTr_SIZE BCM56800_A0_PORT_QM_MIN_COUNTr_SIZE
typedef BCM56800_A0_PORT_QM_MIN_COUNTr_t PORT_QM_MIN_COUNTr_t;
#define PORT_QM_MIN_COUNTr_CLR BCM56800_A0_PORT_QM_MIN_COUNTr_CLR
#define PORT_QM_MIN_COUNTr_SET BCM56800_A0_PORT_QM_MIN_COUNTr_SET
#define PORT_QM_MIN_COUNTr_GET BCM56800_A0_PORT_QM_MIN_COUNTr_GET
#define PORT_QM_MIN_COUNTr_PORT_QM_MIN_COUNTf_GET BCM56800_A0_PORT_QM_MIN_COUNTr_PORT_QM_MIN_COUNTf_GET
#define PORT_QM_MIN_COUNTr_PORT_QM_MIN_COUNTf_SET BCM56800_A0_PORT_QM_MIN_COUNTr_PORT_QM_MIN_COUNTf_SET
#define READ_PORT_QM_MIN_COUNTr BCM56800_A0_READ_PORT_QM_MIN_COUNTr
#define WRITE_PORT_QM_MIN_COUNTr BCM56800_A0_WRITE_PORT_QM_MIN_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_QM_MIN_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_QM_SHARED_COUNT
 * BLOCKS:   MMU
 * DESC:     PORT_QM_SHARED_COUNT
 * SIZE:     32
 * FIELDS:
 *     PORT_QM_SHARED_COUNT It represents the number of cells used for QM-class traffic by the input port above its guarantee.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_QM_SHARED_COUNTr 0x02d00047

#define BCM56800_A0_PORT_QM_SHARED_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PORT_QM_SHARED_COUNT.
 *
 */
typedef union BCM56800_A0_PORT_QM_SHARED_COUNTr_s {
	uint32_t v[1];
	uint32_t port_qm_shared_count[1];
	uint32_t _port_qm_shared_count;
} BCM56800_A0_PORT_QM_SHARED_COUNTr_t;

#define BCM56800_A0_PORT_QM_SHARED_COUNTr_CLR(r) (r).port_qm_shared_count[0] = 0
#define BCM56800_A0_PORT_QM_SHARED_COUNTr_SET(r,d) (r).port_qm_shared_count[0] = d
#define BCM56800_A0_PORT_QM_SHARED_COUNTr_GET(r) (r).port_qm_shared_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_QM_SHARED_COUNTr_PORT_QM_SHARED_COUNTf_GET(r) (((r).port_qm_shared_count[0]) & 0x3fff)
#define BCM56800_A0_PORT_QM_SHARED_COUNTr_PORT_QM_SHARED_COUNTf_SET(r,f) (r).port_qm_shared_count[0]=(((r).port_qm_shared_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PORT_QM_SHARED_COUNT.
 *
 */
#define BCM56800_A0_READ_PORT_QM_SHARED_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_QM_SHARED_COUNTr,(r._port_qm_shared_count))
#define BCM56800_A0_WRITE_PORT_QM_SHARED_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_QM_SHARED_COUNTr,&(r._port_qm_shared_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_QM_SHARED_COUNTr BCM56800_A0_PORT_QM_SHARED_COUNTr
#define PORT_QM_SHARED_COUNTr_SIZE BCM56800_A0_PORT_QM_SHARED_COUNTr_SIZE
typedef BCM56800_A0_PORT_QM_SHARED_COUNTr_t PORT_QM_SHARED_COUNTr_t;
#define PORT_QM_SHARED_COUNTr_CLR BCM56800_A0_PORT_QM_SHARED_COUNTr_CLR
#define PORT_QM_SHARED_COUNTr_SET BCM56800_A0_PORT_QM_SHARED_COUNTr_SET
#define PORT_QM_SHARED_COUNTr_GET BCM56800_A0_PORT_QM_SHARED_COUNTr_GET
#define PORT_QM_SHARED_COUNTr_PORT_QM_SHARED_COUNTf_GET BCM56800_A0_PORT_QM_SHARED_COUNTr_PORT_QM_SHARED_COUNTf_GET
#define PORT_QM_SHARED_COUNTr_PORT_QM_SHARED_COUNTf_SET BCM56800_A0_PORT_QM_SHARED_COUNTr_PORT_QM_SHARED_COUNTf_SET
#define READ_PORT_QM_SHARED_COUNTr BCM56800_A0_READ_PORT_QM_SHARED_COUNTr
#define WRITE_PORT_QM_SHARED_COUNTr BCM56800_A0_WRITE_PORT_QM_SHARED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_QM_SHARED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_SC_MIN
 * BLOCKS:   MMU
 * DESC:     PORT_SC_MIN
 * SIZE:     32
 * FIELDS:
 *     PORT_SC_MIN      This register is the number of cells reserved for the SC-class traffic.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_SC_MINr 0x02d00030

#define BCM56800_A0_PORT_SC_MINr_SIZE 4

/*
 * This structure should be used to declare and program PORT_SC_MIN.
 *
 */
typedef union BCM56800_A0_PORT_SC_MINr_s {
	uint32_t v[1];
	uint32_t port_sc_min[1];
	uint32_t _port_sc_min;
} BCM56800_A0_PORT_SC_MINr_t;

#define BCM56800_A0_PORT_SC_MINr_CLR(r) (r).port_sc_min[0] = 0
#define BCM56800_A0_PORT_SC_MINr_SET(r,d) (r).port_sc_min[0] = d
#define BCM56800_A0_PORT_SC_MINr_GET(r) (r).port_sc_min[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_SC_MINr_PORT_SC_MINf_GET(r) (((r).port_sc_min[0]) & 0x3ff)
#define BCM56800_A0_PORT_SC_MINr_PORT_SC_MINf_SET(r,f) (r).port_sc_min[0]=(((r).port_sc_min[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PORT_SC_MIN.
 *
 */
#define BCM56800_A0_READ_PORT_SC_MINr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_SC_MINr,(r._port_sc_min))
#define BCM56800_A0_WRITE_PORT_SC_MINr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_SC_MINr,&(r._port_sc_min))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_SC_MINr BCM56800_A0_PORT_SC_MINr
#define PORT_SC_MINr_SIZE BCM56800_A0_PORT_SC_MINr_SIZE
typedef BCM56800_A0_PORT_SC_MINr_t PORT_SC_MINr_t;
#define PORT_SC_MINr_CLR BCM56800_A0_PORT_SC_MINr_CLR
#define PORT_SC_MINr_SET BCM56800_A0_PORT_SC_MINr_SET
#define PORT_SC_MINr_GET BCM56800_A0_PORT_SC_MINr_GET
#define PORT_SC_MINr_PORT_SC_MINf_GET BCM56800_A0_PORT_SC_MINr_PORT_SC_MINf_GET
#define PORT_SC_MINr_PORT_SC_MINf_SET BCM56800_A0_PORT_SC_MINr_PORT_SC_MINf_SET
#define READ_PORT_SC_MINr BCM56800_A0_READ_PORT_SC_MINr
#define WRITE_PORT_SC_MINr BCM56800_A0_WRITE_PORT_SC_MINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_SC_MINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_SC_MIN_COUNT
 * BLOCKS:   MMU
 * DESC:     PORT_SC_MIN_COUNT
 * SIZE:     32
 * FIELDS:
 *     PORT_SC_MIN_COUNT It represents the number of cells used for SC-class traffic by the input port from its min guarantee.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_SC_MIN_COUNTr 0x02d00048

#define BCM56800_A0_PORT_SC_MIN_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PORT_SC_MIN_COUNT.
 *
 */
typedef union BCM56800_A0_PORT_SC_MIN_COUNTr_s {
	uint32_t v[1];
	uint32_t port_sc_min_count[1];
	uint32_t _port_sc_min_count;
} BCM56800_A0_PORT_SC_MIN_COUNTr_t;

#define BCM56800_A0_PORT_SC_MIN_COUNTr_CLR(r) (r).port_sc_min_count[0] = 0
#define BCM56800_A0_PORT_SC_MIN_COUNTr_SET(r,d) (r).port_sc_min_count[0] = d
#define BCM56800_A0_PORT_SC_MIN_COUNTr_GET(r) (r).port_sc_min_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_SC_MIN_COUNTr_PORT_SC_MIN_COUNTf_GET(r) (((r).port_sc_min_count[0]) & 0x3ff)
#define BCM56800_A0_PORT_SC_MIN_COUNTr_PORT_SC_MIN_COUNTf_SET(r,f) (r).port_sc_min_count[0]=(((r).port_sc_min_count[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access PORT_SC_MIN_COUNT.
 *
 */
#define BCM56800_A0_READ_PORT_SC_MIN_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_SC_MIN_COUNTr,(r._port_sc_min_count))
#define BCM56800_A0_WRITE_PORT_SC_MIN_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_SC_MIN_COUNTr,&(r._port_sc_min_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_SC_MIN_COUNTr BCM56800_A0_PORT_SC_MIN_COUNTr
#define PORT_SC_MIN_COUNTr_SIZE BCM56800_A0_PORT_SC_MIN_COUNTr_SIZE
typedef BCM56800_A0_PORT_SC_MIN_COUNTr_t PORT_SC_MIN_COUNTr_t;
#define PORT_SC_MIN_COUNTr_CLR BCM56800_A0_PORT_SC_MIN_COUNTr_CLR
#define PORT_SC_MIN_COUNTr_SET BCM56800_A0_PORT_SC_MIN_COUNTr_SET
#define PORT_SC_MIN_COUNTr_GET BCM56800_A0_PORT_SC_MIN_COUNTr_GET
#define PORT_SC_MIN_COUNTr_PORT_SC_MIN_COUNTf_GET BCM56800_A0_PORT_SC_MIN_COUNTr_PORT_SC_MIN_COUNTf_GET
#define PORT_SC_MIN_COUNTr_PORT_SC_MIN_COUNTf_SET BCM56800_A0_PORT_SC_MIN_COUNTr_PORT_SC_MIN_COUNTf_SET
#define READ_PORT_SC_MIN_COUNTr BCM56800_A0_READ_PORT_SC_MIN_COUNTr
#define WRITE_PORT_SC_MIN_COUNTr BCM56800_A0_WRITE_PORT_SC_MIN_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_SC_MIN_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_SC_SHARED_COUNT
 * BLOCKS:   MMU
 * DESC:     PORT_SC_SHARED_COUNT
 * SIZE:     32
 * FIELDS:
 *     PORT_SC_SHARED_COUNT It represents the number of cells used for SC-class traffic by the input port above its guarantee.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_SC_SHARED_COUNTr 0x02d00049

#define BCM56800_A0_PORT_SC_SHARED_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PORT_SC_SHARED_COUNT.
 *
 */
typedef union BCM56800_A0_PORT_SC_SHARED_COUNTr_s {
	uint32_t v[1];
	uint32_t port_sc_shared_count[1];
	uint32_t _port_sc_shared_count;
} BCM56800_A0_PORT_SC_SHARED_COUNTr_t;

#define BCM56800_A0_PORT_SC_SHARED_COUNTr_CLR(r) (r).port_sc_shared_count[0] = 0
#define BCM56800_A0_PORT_SC_SHARED_COUNTr_SET(r,d) (r).port_sc_shared_count[0] = d
#define BCM56800_A0_PORT_SC_SHARED_COUNTr_GET(r) (r).port_sc_shared_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_SC_SHARED_COUNTr_PORT_SC_SHARED_COUNTf_GET(r) (((r).port_sc_shared_count[0]) & 0x3fff)
#define BCM56800_A0_PORT_SC_SHARED_COUNTr_PORT_SC_SHARED_COUNTf_SET(r,f) (r).port_sc_shared_count[0]=(((r).port_sc_shared_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PORT_SC_SHARED_COUNT.
 *
 */
#define BCM56800_A0_READ_PORT_SC_SHARED_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_SC_SHARED_COUNTr,(r._port_sc_shared_count))
#define BCM56800_A0_WRITE_PORT_SC_SHARED_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_SC_SHARED_COUNTr,&(r._port_sc_shared_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_SC_SHARED_COUNTr BCM56800_A0_PORT_SC_SHARED_COUNTr
#define PORT_SC_SHARED_COUNTr_SIZE BCM56800_A0_PORT_SC_SHARED_COUNTr_SIZE
typedef BCM56800_A0_PORT_SC_SHARED_COUNTr_t PORT_SC_SHARED_COUNTr_t;
#define PORT_SC_SHARED_COUNTr_CLR BCM56800_A0_PORT_SC_SHARED_COUNTr_CLR
#define PORT_SC_SHARED_COUNTr_SET BCM56800_A0_PORT_SC_SHARED_COUNTr_SET
#define PORT_SC_SHARED_COUNTr_GET BCM56800_A0_PORT_SC_SHARED_COUNTr_GET
#define PORT_SC_SHARED_COUNTr_PORT_SC_SHARED_COUNTf_GET BCM56800_A0_PORT_SC_SHARED_COUNTr_PORT_SC_SHARED_COUNTf_GET
#define PORT_SC_SHARED_COUNTr_PORT_SC_SHARED_COUNTf_SET BCM56800_A0_PORT_SC_SHARED_COUNTr_PORT_SC_SHARED_COUNTf_SET
#define READ_PORT_SC_SHARED_COUNTr BCM56800_A0_READ_PORT_SC_SHARED_COUNTr
#define WRITE_PORT_SC_SHARED_COUNTr BCM56800_A0_WRITE_PORT_SC_SHARED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_SC_SHARED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_SHARED_COUNT
 * BLOCKS:   MMU
 * DESC:     PORT_SHARED_COUNT
 * SIZE:     32
 * FIELDS:
 *     PORT_SHARED_COUNT It represents the number of cells taken from the shared pool at any point in time, not including and SC or QM cells.
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_SHARED_COUNTr 0x02d00045

#define BCM56800_A0_PORT_SHARED_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program PORT_SHARED_COUNT.
 *
 */
typedef union BCM56800_A0_PORT_SHARED_COUNTr_s {
	uint32_t v[1];
	uint32_t port_shared_count[1];
	uint32_t _port_shared_count;
} BCM56800_A0_PORT_SHARED_COUNTr_t;

#define BCM56800_A0_PORT_SHARED_COUNTr_CLR(r) (r).port_shared_count[0] = 0
#define BCM56800_A0_PORT_SHARED_COUNTr_SET(r,d) (r).port_shared_count[0] = d
#define BCM56800_A0_PORT_SHARED_COUNTr_GET(r) (r).port_shared_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_SHARED_COUNTr_PORT_SHARED_COUNTf_GET(r) (((r).port_shared_count[0]) & 0x3fff)
#define BCM56800_A0_PORT_SHARED_COUNTr_PORT_SHARED_COUNTf_SET(r,f) (r).port_shared_count[0]=(((r).port_shared_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access PORT_SHARED_COUNT.
 *
 */
#define BCM56800_A0_READ_PORT_SHARED_COUNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_SHARED_COUNTr,(r._port_shared_count))
#define BCM56800_A0_WRITE_PORT_SHARED_COUNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_SHARED_COUNTr,&(r._port_shared_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_SHARED_COUNTr BCM56800_A0_PORT_SHARED_COUNTr
#define PORT_SHARED_COUNTr_SIZE BCM56800_A0_PORT_SHARED_COUNTr_SIZE
typedef BCM56800_A0_PORT_SHARED_COUNTr_t PORT_SHARED_COUNTr_t;
#define PORT_SHARED_COUNTr_CLR BCM56800_A0_PORT_SHARED_COUNTr_CLR
#define PORT_SHARED_COUNTr_SET BCM56800_A0_PORT_SHARED_COUNTr_SET
#define PORT_SHARED_COUNTr_GET BCM56800_A0_PORT_SHARED_COUNTr_GET
#define PORT_SHARED_COUNTr_PORT_SHARED_COUNTf_GET BCM56800_A0_PORT_SHARED_COUNTr_PORT_SHARED_COUNTf_GET
#define PORT_SHARED_COUNTr_PORT_SHARED_COUNTf_SET BCM56800_A0_PORT_SHARED_COUNTr_PORT_SHARED_COUNTf_SET
#define READ_PORT_SHARED_COUNTr BCM56800_A0_READ_PORT_SHARED_COUNTr
#define WRITE_PORT_SHARED_COUNTr BCM56800_A0_WRITE_PORT_SHARED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_SHARED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PORT_SHARED_LIMIT
 * BLOCKS:   MMU
 * DESC:     PORT_SHARED_LIMIT
 * SIZE:     32
 * FIELDS:
 *     PORT_SHARED_LIMIT Shared Buffer Limit per input port. Can be either: static threshold: a value in cellsor dynamic threshold: used as an index to the alpha value to use for dynamic threshold.Port_Shared_limit[3:0] : alpha0 : 1/321: 1/162: 1/83: 4: 5: 16: 27: 48: 89: 1610: 3211: 6412: 12813: 25614, 15: reserved.Note: the port shared threshold is used as the pg2_xoff_threshold which is used to assert flow control on the highest priority group.
 *     PORT_SHARED_DYNAMIC Dynamic Control bit0 = this port uses static port_limit1 = this port uses dynamic queue threshold
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_SHARED_LIMITr 0x02d00022

#define BCM56800_A0_PORT_SHARED_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program PORT_SHARED_LIMIT.
 *
 */
typedef union BCM56800_A0_PORT_SHARED_LIMITr_s {
	uint32_t v[1];
	uint32_t port_shared_limit[1];
	uint32_t _port_shared_limit;
} BCM56800_A0_PORT_SHARED_LIMITr_t;

#define BCM56800_A0_PORT_SHARED_LIMITr_CLR(r) (r).port_shared_limit[0] = 0
#define BCM56800_A0_PORT_SHARED_LIMITr_SET(r,d) (r).port_shared_limit[0] = d
#define BCM56800_A0_PORT_SHARED_LIMITr_GET(r) (r).port_shared_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_SHARED_LIMITr_PORT_SHARED_LIMITf_GET(r) (((r).port_shared_limit[0]) & 0x3fff)
#define BCM56800_A0_PORT_SHARED_LIMITr_PORT_SHARED_LIMITf_SET(r,f) (r).port_shared_limit[0]=(((r).port_shared_limit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_PORT_SHARED_LIMITr_PORT_SHARED_DYNAMICf_GET(r) ((((r).port_shared_limit[0]) >> 14) & 0x1)
#define BCM56800_A0_PORT_SHARED_LIMITr_PORT_SHARED_DYNAMICf_SET(r,f) (r).port_shared_limit[0]=(((r).port_shared_limit[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))

/*
 * These macros can be used to access PORT_SHARED_LIMIT.
 *
 */
#define BCM56800_A0_READ_PORT_SHARED_LIMITr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PORT_SHARED_LIMITr,(r._port_shared_limit))
#define BCM56800_A0_WRITE_PORT_SHARED_LIMITr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PORT_SHARED_LIMITr,&(r._port_shared_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_SHARED_LIMITr BCM56800_A0_PORT_SHARED_LIMITr
#define PORT_SHARED_LIMITr_SIZE BCM56800_A0_PORT_SHARED_LIMITr_SIZE
typedef BCM56800_A0_PORT_SHARED_LIMITr_t PORT_SHARED_LIMITr_t;
#define PORT_SHARED_LIMITr_CLR BCM56800_A0_PORT_SHARED_LIMITr_CLR
#define PORT_SHARED_LIMITr_SET BCM56800_A0_PORT_SHARED_LIMITr_SET
#define PORT_SHARED_LIMITr_GET BCM56800_A0_PORT_SHARED_LIMITr_GET
#define PORT_SHARED_LIMITr_PORT_SHARED_LIMITf_GET BCM56800_A0_PORT_SHARED_LIMITr_PORT_SHARED_LIMITf_GET
#define PORT_SHARED_LIMITr_PORT_SHARED_LIMITf_SET BCM56800_A0_PORT_SHARED_LIMITr_PORT_SHARED_LIMITf_SET
#define PORT_SHARED_LIMITr_PORT_SHARED_DYNAMICf_GET BCM56800_A0_PORT_SHARED_LIMITr_PORT_SHARED_DYNAMICf_GET
#define PORT_SHARED_LIMITr_PORT_SHARED_DYNAMICf_SET BCM56800_A0_PORT_SHARED_LIMITr_PORT_SHARED_DYNAMICf_SET
#define READ_PORT_SHARED_LIMITr BCM56800_A0_READ_PORT_SHARED_LIMITr
#define WRITE_PORT_SHARED_LIMITr BCM56800_A0_WRITE_PORT_SHARED_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_SHARED_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  PORT_TAB
 * BLOCKS:   IPIPE
 * DESC:     Port Table, FeatureSpecific-Ethernet
 * SIZE:     86
 * FIELDS:
 *     FILTER_ENABLE    Enable Filtering
 *     VT_MISS_DROP     VLAN translation miss drop
 *     VT_ENABLE        VLAN translation enable
 *     TRUST_DSCP_V4    Ingress port is trusted port, trust incoming IPv4 DSCP
 *     TRUST_DSCP_V6    Ingress port is trusted port, trust incoming IPv6 DSCP
 *     EN_IFILTER       Enable ingress filtering
 *     MIRROR           Mirror enable
 *     CML              CPU managed learning
 *     PORT_PRI         Port default priority?
 *     IPMC_DO_VLAN     Unknown
 *     V6IPMC_ENABLE    IPv6 IPMC enable
 *     V4IPMC_ENABLE    IPv4 IPMC enable
 *     V6L3_ENABLE      IPv6 L3 enable
 *     V4L3_ENABLE      IPv4 L3 enable
 *     DROP_BPDU        when set, ingress drops BPDUs
 *     PORT_DIS_TAG     Drop all tagged packets
 *     PORT_DIS_UNTAG   Drop all untagged packets
 *     PASS_CONTROL_FRAMES Pass pause frames through without dropping
 *     SUBNET_BASED_VID_ENABLE Enable subnet-based VLANs
 *     MAC_BASED_VID_ENABLE Enable MAC-based VLANs
 *     PORT_VID         Port VLAN
 *     HIGIG_PACKET     Port is HiGig port
 *     NNI_PORT         Port is NNI port if set to 1, otherwise UNI port
 *     MAP_TAG_PKT_PRIORITY Map the incoming packet priority
 *     MY_MODID         Stacking module ID for this module
 *     OUTER_TPID       Outer (switching) VLAN
 *     VLAN_PRECEDENCE  Determine the priorities for selecting VLAN (MAC-based, subnet-based VLANs)
 *     PORT_BRIDGE      Allows L2 bridging to the incoming port
 *     IGNORE_IPMC_L2_BITMAP Set this bit to disable L2 bridging of IPMC pkts on this port
 *     IGNORE_IPMC_L3_BITMAP Set this bit to disable L3 routing of IPMC pkts on this port
 *     HIGIG_TRUNK      Set this bit if the port is a member if a higig trunkIf set, then HIGIG_PACKET must also be set.
 *     HIGIG_TRUNK_ID   If HIGIG_TRUNK=1, then this is the trunk ID
 *     HIGIG2           If HIGIG_PACKET=1, then this bit indicates if the port is in HiGig2 mode (if HIGIG2=1) or in HiGig mode (if HIGIG2=0)
 *     ALLOW_SRC_MOD    When set, packets whose source modid is equal to my_modid are not dropped
 *     LOCAL_SW_DISABLE When set, local switching is disabled.
 *     RTAG7_PORT_LBN   Per port configurable LBN (Load Balancing Number) for traffic splitting.
 *     RTAG7_HASH_CFG_SEL_TRUNK Selects one of the two sets of hash bits selection configuration for Trunking (LAG). Value 0: Selects config 1 set. Value 1: Selects config2 set.
 *     RTAG7_HASH_CFG_SEL_HIGIG_TRUNK Selects one of the two sets of hash bits selection configuration for HiGig Trunking. Value 0: Selects config 1 set. Value 1: Selects config2 set.
 *     RTAG7_HASH_CFG_SEL_ECMP Selects one of the two sets of hash bits selection configuration for ECMP. Value 0: Selects config 1 set. Value 1: Selects config2 set.
 *     RTAG7_HASH_CFG_SEL_LBID Selects one of the two sets of hash bits selection configuration for LBID to be populated in HiGig2 header. Value 0: Selects config 1 set. Value 1: Selects config2 set.
 *     REMOVE_HG_HDR_SRC_PORT If set to 1, do not forward the pkt to the non-trunk (i.e., not LAG) source port in module header when the MH.SRC_MODID is same as ING_CONFIG.MY_MODID. NOTE: If module header's source port is a trunk (LAG) port, the pkts are not forwarded to its LAG members irrespective of this control bit
 *     RESERVED         Reserved (spare) bits in the PORT_TABLE
 *
 ******************************************************************************/
#define BCM56800_A0_PORT_TABm 0x01100000

#define BCM56800_A0_PORT_TABm_MIN 0
#define BCM56800_A0_PORT_TABm_MAX 20
#define BCM56800_A0_PORT_TABm_CMAX(u) 20
#define BCM56800_A0_PORT_TABm_SIZE 11

/*
 * This structure should be used to declare and program PORT_TAB.
 *
 */
typedef union BCM56800_A0_PORT_TABm_s {
	uint32_t v[3];
	uint32_t port_tab[3];
	uint32_t _port_tab;
} BCM56800_A0_PORT_TABm_t;

#define BCM56800_A0_PORT_TABm_CLR(r) CDK_MEMSET(&((r)._port_tab), 0, sizeof(BCM56800_A0_PORT_TABm_t))
#define BCM56800_A0_PORT_TABm_SET(r,i,d) (r).port_tab[i] = d
#define BCM56800_A0_PORT_TABm_GET(r,i) (r).port_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PORT_TABm_FILTER_ENABLEf_GET(r) (((r).port_tab[0]) & 0x1)
#define BCM56800_A0_PORT_TABm_FILTER_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_PORT_TABm_VT_MISS_DROPf_GET(r) ((((r).port_tab[0]) >> 1) & 0x1)
#define BCM56800_A0_PORT_TABm_VT_MISS_DROPf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_PORT_TABm_VT_ENABLEf_GET(r) ((((r).port_tab[0]) >> 2) & 0x1)
#define BCM56800_A0_PORT_TABm_VT_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_PORT_TABm_TRUST_DSCP_V4f_GET(r) ((((r).port_tab[0]) >> 3) & 0x1)
#define BCM56800_A0_PORT_TABm_TRUST_DSCP_V4f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_PORT_TABm_TRUST_DSCP_V6f_GET(r) ((((r).port_tab[0]) >> 4) & 0x1)
#define BCM56800_A0_PORT_TABm_TRUST_DSCP_V6f_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_PORT_TABm_EN_IFILTERf_GET(r) ((((r).port_tab[0]) >> 5) & 0x1)
#define BCM56800_A0_PORT_TABm_EN_IFILTERf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_PORT_TABm_MIRRORf_GET(r) ((((r).port_tab[0]) >> 6) & 0x1)
#define BCM56800_A0_PORT_TABm_MIRRORf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_PORT_TABm_CMLf_GET(r) ((((r).port_tab[0]) >> 7) & 0x7)
#define BCM56800_A0_PORT_TABm_CMLf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56800_A0_PORT_TABm_PORT_PRIf_GET(r) ((((r).port_tab[0]) >> 10) & 0x7)
#define BCM56800_A0_PORT_TABm_PORT_PRIf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56800_A0_PORT_TABm_IPMC_DO_VLANf_GET(r) ((((r).port_tab[0]) >> 13) & 0x1)
#define BCM56800_A0_PORT_TABm_IPMC_DO_VLANf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_PORT_TABm_V6IPMC_ENABLEf_GET(r) ((((r).port_tab[0]) >> 14) & 0x1)
#define BCM56800_A0_PORT_TABm_V6IPMC_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_PORT_TABm_V4IPMC_ENABLEf_GET(r) ((((r).port_tab[0]) >> 15) & 0x1)
#define BCM56800_A0_PORT_TABm_V4IPMC_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_PORT_TABm_V6L3_ENABLEf_GET(r) ((((r).port_tab[0]) >> 16) & 0x1)
#define BCM56800_A0_PORT_TABm_V6L3_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_PORT_TABm_V4L3_ENABLEf_GET(r) ((((r).port_tab[0]) >> 17) & 0x1)
#define BCM56800_A0_PORT_TABm_V4L3_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_PORT_TABm_DROP_BPDUf_GET(r) ((((r).port_tab[0]) >> 18) & 0x1)
#define BCM56800_A0_PORT_TABm_DROP_BPDUf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_PORT_TABm_PORT_DIS_TAGf_GET(r) ((((r).port_tab[0]) >> 19) & 0x1)
#define BCM56800_A0_PORT_TABm_PORT_DIS_TAGf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_PORT_TABm_PORT_DIS_UNTAGf_GET(r) ((((r).port_tab[0]) >> 20) & 0x1)
#define BCM56800_A0_PORT_TABm_PORT_DIS_UNTAGf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_PORT_TABm_PASS_CONTROL_FRAMESf_GET(r) ((((r).port_tab[0]) >> 21) & 0x1)
#define BCM56800_A0_PORT_TABm_PASS_CONTROL_FRAMESf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET(r) ((((r).port_tab[0]) >> 22) & 0x1)
#define BCM56800_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_GET(r) ((((r).port_tab[0]) >> 23) & 0x1)
#define BCM56800_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_SET(r,f) (r).port_tab[0]=(((r).port_tab[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_PORT_TABm_PORT_VIDf_GET(r) cdk_field32_get((r).port_tab,24,35)
#define BCM56800_A0_PORT_TABm_PORT_VIDf_SET(r,f) cdk_field32_set((r).port_tab,24,35,f)
#define BCM56800_A0_PORT_TABm_HIGIG_PACKETf_GET(r) ((((r).port_tab[1]) >> 4) & 0x1)
#define BCM56800_A0_PORT_TABm_HIGIG_PACKETf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_PORT_TABm_NNI_PORTf_GET(r) ((((r).port_tab[1]) >> 5) & 0x1)
#define BCM56800_A0_PORT_TABm_NNI_PORTf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET(r) ((((r).port_tab[1]) >> 6) & 0x1)
#define BCM56800_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_PORT_TABm_MY_MODIDf_GET(r) ((((r).port_tab[1]) >> 7) & 0x7f)
#define BCM56800_A0_PORT_TABm_MY_MODIDf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7))
#define BCM56800_A0_PORT_TABm_OUTER_TPIDf_GET(r) ((((r).port_tab[1]) >> 14) & 0xffff)
#define BCM56800_A0_PORT_TABm_OUTER_TPIDf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0xffff << 14)) | ((((uint32_t)f) & 0xffff) << 14))
#define BCM56800_A0_PORT_TABm_VLAN_PRECEDENCEf_GET(r) ((((r).port_tab[1]) >> 30) & 0x1)
#define BCM56800_A0_PORT_TABm_VLAN_PRECEDENCEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM56800_A0_PORT_TABm_PORT_BRIDGEf_GET(r) ((((r).port_tab[1]) >> 31) & 0x1)
#define BCM56800_A0_PORT_TABm_PORT_BRIDGEf_SET(r,f) (r).port_tab[1]=(((r).port_tab[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_PORT_TABm_IGNORE_IPMC_L2_BITMAPf_GET(r) (((r).port_tab[2]) & 0x1)
#define BCM56800_A0_PORT_TABm_IGNORE_IPMC_L2_BITMAPf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_PORT_TABm_IGNORE_IPMC_L3_BITMAPf_GET(r) ((((r).port_tab[2]) >> 1) & 0x1)
#define BCM56800_A0_PORT_TABm_IGNORE_IPMC_L3_BITMAPf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_PORT_TABm_HIGIG_TRUNKf_GET(r) ((((r).port_tab[2]) >> 2) & 0x1)
#define BCM56800_A0_PORT_TABm_HIGIG_TRUNKf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_PORT_TABm_HIGIG_TRUNK_IDf_GET(r) ((((r).port_tab[2]) >> 3) & 0x7)
#define BCM56800_A0_PORT_TABm_HIGIG_TRUNK_IDf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM56800_A0_PORT_TABm_HIGIG2f_GET(r) ((((r).port_tab[2]) >> 6) & 0x1)
#define BCM56800_A0_PORT_TABm_HIGIG2f_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_PORT_TABm_ALLOW_SRC_MODf_GET(r) ((((r).port_tab[2]) >> 7) & 0x1)
#define BCM56800_A0_PORT_TABm_ALLOW_SRC_MODf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_PORT_TABm_LOCAL_SW_DISABLEf_GET(r) ((((r).port_tab[2]) >> 8) & 0x1)
#define BCM56800_A0_PORT_TABm_LOCAL_SW_DISABLEf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_PORT_TABm_RTAG7_PORT_LBNf_GET(r) ((((r).port_tab[2]) >> 9) & 0xf)
#define BCM56800_A0_PORT_TABm_RTAG7_PORT_LBNf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_TRUNKf_GET(r) ((((r).port_tab[2]) >> 13) & 0x1)
#define BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_TRUNKf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_GET(r) ((((r).port_tab[2]) >> 14) & 0x1)
#define BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_ECMPf_GET(r) ((((r).port_tab[2]) >> 15) & 0x1)
#define BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_ECMPf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_LBIDf_GET(r) ((((r).port_tab[2]) >> 16) & 0x1)
#define BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_LBIDf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET(r) ((((r).port_tab[2]) >> 17) & 0x1)
#define BCM56800_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_PORT_TABm_RESERVEDf_GET(r) ((((r).port_tab[2]) >> 18) & 0xf)
#define BCM56800_A0_PORT_TABm_RESERVEDf_SET(r,f) (r).port_tab[2]=(((r).port_tab[2] & ~((uint32_t)0xf << 18)) | ((((uint32_t)f) & 0xf) << 18))

/*
 * These macros can be used to access PORT_TAB.
 *
 */
#define BCM56800_A0_READ_PORT_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_PORT_TABm,i,(m._port_tab),3)
#define BCM56800_A0_WRITE_PORT_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_PORT_TABm,i,&(m._port_tab),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_TABm BCM56800_A0_PORT_TABm
#define PORT_TABm_MIN BCM56800_A0_PORT_TABm_MIN
#define PORT_TABm_MAX BCM56800_A0_PORT_TABm_MAX
#define PORT_TABm_CMAX(u) BCM56800_A0_PORT_TABm_CMAX(u)
#define PORT_TABm_SIZE BCM56800_A0_PORT_TABm_SIZE
typedef BCM56800_A0_PORT_TABm_t PORT_TABm_t;
#define PORT_TABm_CLR BCM56800_A0_PORT_TABm_CLR
#define PORT_TABm_SET BCM56800_A0_PORT_TABm_SET
#define PORT_TABm_GET BCM56800_A0_PORT_TABm_GET
#define PORT_TABm_FILTER_ENABLEf_GET BCM56800_A0_PORT_TABm_FILTER_ENABLEf_GET
#define PORT_TABm_FILTER_ENABLEf_SET BCM56800_A0_PORT_TABm_FILTER_ENABLEf_SET
#define PORT_TABm_VT_MISS_DROPf_GET BCM56800_A0_PORT_TABm_VT_MISS_DROPf_GET
#define PORT_TABm_VT_MISS_DROPf_SET BCM56800_A0_PORT_TABm_VT_MISS_DROPf_SET
#define PORT_TABm_VT_ENABLEf_GET BCM56800_A0_PORT_TABm_VT_ENABLEf_GET
#define PORT_TABm_VT_ENABLEf_SET BCM56800_A0_PORT_TABm_VT_ENABLEf_SET
#define PORT_TABm_TRUST_DSCP_V4f_GET BCM56800_A0_PORT_TABm_TRUST_DSCP_V4f_GET
#define PORT_TABm_TRUST_DSCP_V4f_SET BCM56800_A0_PORT_TABm_TRUST_DSCP_V4f_SET
#define PORT_TABm_TRUST_DSCP_V6f_GET BCM56800_A0_PORT_TABm_TRUST_DSCP_V6f_GET
#define PORT_TABm_TRUST_DSCP_V6f_SET BCM56800_A0_PORT_TABm_TRUST_DSCP_V6f_SET
#define PORT_TABm_EN_IFILTERf_GET BCM56800_A0_PORT_TABm_EN_IFILTERf_GET
#define PORT_TABm_EN_IFILTERf_SET BCM56800_A0_PORT_TABm_EN_IFILTERf_SET
#define PORT_TABm_MIRRORf_GET BCM56800_A0_PORT_TABm_MIRRORf_GET
#define PORT_TABm_MIRRORf_SET BCM56800_A0_PORT_TABm_MIRRORf_SET
#define PORT_TABm_CMLf_GET BCM56800_A0_PORT_TABm_CMLf_GET
#define PORT_TABm_CMLf_SET BCM56800_A0_PORT_TABm_CMLf_SET
#define PORT_TABm_PORT_PRIf_GET BCM56800_A0_PORT_TABm_PORT_PRIf_GET
#define PORT_TABm_PORT_PRIf_SET BCM56800_A0_PORT_TABm_PORT_PRIf_SET
#define PORT_TABm_IPMC_DO_VLANf_GET BCM56800_A0_PORT_TABm_IPMC_DO_VLANf_GET
#define PORT_TABm_IPMC_DO_VLANf_SET BCM56800_A0_PORT_TABm_IPMC_DO_VLANf_SET
#define PORT_TABm_V6IPMC_ENABLEf_GET BCM56800_A0_PORT_TABm_V6IPMC_ENABLEf_GET
#define PORT_TABm_V6IPMC_ENABLEf_SET BCM56800_A0_PORT_TABm_V6IPMC_ENABLEf_SET
#define PORT_TABm_V4IPMC_ENABLEf_GET BCM56800_A0_PORT_TABm_V4IPMC_ENABLEf_GET
#define PORT_TABm_V4IPMC_ENABLEf_SET BCM56800_A0_PORT_TABm_V4IPMC_ENABLEf_SET
#define PORT_TABm_V6L3_ENABLEf_GET BCM56800_A0_PORT_TABm_V6L3_ENABLEf_GET
#define PORT_TABm_V6L3_ENABLEf_SET BCM56800_A0_PORT_TABm_V6L3_ENABLEf_SET
#define PORT_TABm_V4L3_ENABLEf_GET BCM56800_A0_PORT_TABm_V4L3_ENABLEf_GET
#define PORT_TABm_V4L3_ENABLEf_SET BCM56800_A0_PORT_TABm_V4L3_ENABLEf_SET
#define PORT_TABm_DROP_BPDUf_GET BCM56800_A0_PORT_TABm_DROP_BPDUf_GET
#define PORT_TABm_DROP_BPDUf_SET BCM56800_A0_PORT_TABm_DROP_BPDUf_SET
#define PORT_TABm_PORT_DIS_TAGf_GET BCM56800_A0_PORT_TABm_PORT_DIS_TAGf_GET
#define PORT_TABm_PORT_DIS_TAGf_SET BCM56800_A0_PORT_TABm_PORT_DIS_TAGf_SET
#define PORT_TABm_PORT_DIS_UNTAGf_GET BCM56800_A0_PORT_TABm_PORT_DIS_UNTAGf_GET
#define PORT_TABm_PORT_DIS_UNTAGf_SET BCM56800_A0_PORT_TABm_PORT_DIS_UNTAGf_SET
#define PORT_TABm_PASS_CONTROL_FRAMESf_GET BCM56800_A0_PORT_TABm_PASS_CONTROL_FRAMESf_GET
#define PORT_TABm_PASS_CONTROL_FRAMESf_SET BCM56800_A0_PORT_TABm_PASS_CONTROL_FRAMESf_SET
#define PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET BCM56800_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_GET
#define PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET BCM56800_A0_PORT_TABm_SUBNET_BASED_VID_ENABLEf_SET
#define PORT_TABm_MAC_BASED_VID_ENABLEf_GET BCM56800_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_GET
#define PORT_TABm_MAC_BASED_VID_ENABLEf_SET BCM56800_A0_PORT_TABm_MAC_BASED_VID_ENABLEf_SET
#define PORT_TABm_PORT_VIDf_GET BCM56800_A0_PORT_TABm_PORT_VIDf_GET
#define PORT_TABm_PORT_VIDf_SET BCM56800_A0_PORT_TABm_PORT_VIDf_SET
#define PORT_TABm_HIGIG_PACKETf_GET BCM56800_A0_PORT_TABm_HIGIG_PACKETf_GET
#define PORT_TABm_HIGIG_PACKETf_SET BCM56800_A0_PORT_TABm_HIGIG_PACKETf_SET
#define PORT_TABm_NNI_PORTf_GET BCM56800_A0_PORT_TABm_NNI_PORTf_GET
#define PORT_TABm_NNI_PORTf_SET BCM56800_A0_PORT_TABm_NNI_PORTf_SET
#define PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET BCM56800_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_GET
#define PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET BCM56800_A0_PORT_TABm_MAP_TAG_PKT_PRIORITYf_SET
#define PORT_TABm_MY_MODIDf_GET BCM56800_A0_PORT_TABm_MY_MODIDf_GET
#define PORT_TABm_MY_MODIDf_SET BCM56800_A0_PORT_TABm_MY_MODIDf_SET
#define PORT_TABm_OUTER_TPIDf_GET BCM56800_A0_PORT_TABm_OUTER_TPIDf_GET
#define PORT_TABm_OUTER_TPIDf_SET BCM56800_A0_PORT_TABm_OUTER_TPIDf_SET
#define PORT_TABm_VLAN_PRECEDENCEf_GET BCM56800_A0_PORT_TABm_VLAN_PRECEDENCEf_GET
#define PORT_TABm_VLAN_PRECEDENCEf_SET BCM56800_A0_PORT_TABm_VLAN_PRECEDENCEf_SET
#define PORT_TABm_PORT_BRIDGEf_GET BCM56800_A0_PORT_TABm_PORT_BRIDGEf_GET
#define PORT_TABm_PORT_BRIDGEf_SET BCM56800_A0_PORT_TABm_PORT_BRIDGEf_SET
#define PORT_TABm_IGNORE_IPMC_L2_BITMAPf_GET BCM56800_A0_PORT_TABm_IGNORE_IPMC_L2_BITMAPf_GET
#define PORT_TABm_IGNORE_IPMC_L2_BITMAPf_SET BCM56800_A0_PORT_TABm_IGNORE_IPMC_L2_BITMAPf_SET
#define PORT_TABm_IGNORE_IPMC_L3_BITMAPf_GET BCM56800_A0_PORT_TABm_IGNORE_IPMC_L3_BITMAPf_GET
#define PORT_TABm_IGNORE_IPMC_L3_BITMAPf_SET BCM56800_A0_PORT_TABm_IGNORE_IPMC_L3_BITMAPf_SET
#define PORT_TABm_HIGIG_TRUNKf_GET BCM56800_A0_PORT_TABm_HIGIG_TRUNKf_GET
#define PORT_TABm_HIGIG_TRUNKf_SET BCM56800_A0_PORT_TABm_HIGIG_TRUNKf_SET
#define PORT_TABm_HIGIG_TRUNK_IDf_GET BCM56800_A0_PORT_TABm_HIGIG_TRUNK_IDf_GET
#define PORT_TABm_HIGIG_TRUNK_IDf_SET BCM56800_A0_PORT_TABm_HIGIG_TRUNK_IDf_SET
#define PORT_TABm_HIGIG2f_GET BCM56800_A0_PORT_TABm_HIGIG2f_GET
#define PORT_TABm_HIGIG2f_SET BCM56800_A0_PORT_TABm_HIGIG2f_SET
#define PORT_TABm_ALLOW_SRC_MODf_GET BCM56800_A0_PORT_TABm_ALLOW_SRC_MODf_GET
#define PORT_TABm_ALLOW_SRC_MODf_SET BCM56800_A0_PORT_TABm_ALLOW_SRC_MODf_SET
#define PORT_TABm_LOCAL_SW_DISABLEf_GET BCM56800_A0_PORT_TABm_LOCAL_SW_DISABLEf_GET
#define PORT_TABm_LOCAL_SW_DISABLEf_SET BCM56800_A0_PORT_TABm_LOCAL_SW_DISABLEf_SET
#define PORT_TABm_RTAG7_PORT_LBNf_GET BCM56800_A0_PORT_TABm_RTAG7_PORT_LBNf_GET
#define PORT_TABm_RTAG7_PORT_LBNf_SET BCM56800_A0_PORT_TABm_RTAG7_PORT_LBNf_SET
#define PORT_TABm_RTAG7_HASH_CFG_SEL_TRUNKf_GET BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_TRUNKf_GET
#define PORT_TABm_RTAG7_HASH_CFG_SEL_TRUNKf_SET BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_TRUNKf_SET
#define PORT_TABm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_GET BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_GET
#define PORT_TABm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_SET BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf_SET
#define PORT_TABm_RTAG7_HASH_CFG_SEL_ECMPf_GET BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_ECMPf_GET
#define PORT_TABm_RTAG7_HASH_CFG_SEL_ECMPf_SET BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_ECMPf_SET
#define PORT_TABm_RTAG7_HASH_CFG_SEL_LBIDf_GET BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_LBIDf_GET
#define PORT_TABm_RTAG7_HASH_CFG_SEL_LBIDf_SET BCM56800_A0_PORT_TABm_RTAG7_HASH_CFG_SEL_LBIDf_SET
#define PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET BCM56800_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_GET
#define PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET BCM56800_A0_PORT_TABm_REMOVE_HG_HDR_SRC_PORTf_SET
#define PORT_TABm_RESERVEDf_GET BCM56800_A0_PORT_TABm_RESERVEDf_GET
#define PORT_TABm_RESERVEDf_SET BCM56800_A0_PORT_TABm_RESERVEDf_SET
#define READ_PORT_TABm BCM56800_A0_READ_PORT_TABm
#define WRITE_PORT_TABm BCM56800_A0_WRITE_PORT_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PORT_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PRI2COS
 * BLOCKS:   MMU
 * DESC:     Priority (0 to 7) to COS value lookup for FC report
from XPORTs through MMU to ES0/1

 * SIZE:     32
 * FIELDS:
 *     COS0             COS value for priority 0
 *     COS1             COS value for priority 1
 *     COS2             COS value for priority 2
 *     COS3             COS value for priority 3
 *     COS4             COS value for priority 4
 *     COS5             COS value for priority 5
 *     COS6             COS value for priority 6
 *     COS7             COS value for priority 7
 *
 ******************************************************************************/
#define BCM56800_A0_PRI2COSr 0x0bd80004

#define BCM56800_A0_PRI2COSr_SIZE 4

/*
 * This structure should be used to declare and program PRI2COS.
 *
 */
typedef union BCM56800_A0_PRI2COSr_s {
	uint32_t v[1];
	uint32_t pri2cos[1];
	uint32_t _pri2cos;
} BCM56800_A0_PRI2COSr_t;

#define BCM56800_A0_PRI2COSr_CLR(r) (r).pri2cos[0] = 0
#define BCM56800_A0_PRI2COSr_SET(r,d) (r).pri2cos[0] = d
#define BCM56800_A0_PRI2COSr_GET(r) (r).pri2cos[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PRI2COSr_COS0f_GET(r) (((r).pri2cos[0]) & 0xf)
#define BCM56800_A0_PRI2COSr_COS0f_SET(r,f) (r).pri2cos[0]=(((r).pri2cos[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_PRI2COSr_COS1f_GET(r) ((((r).pri2cos[0]) >> 4) & 0xf)
#define BCM56800_A0_PRI2COSr_COS1f_SET(r,f) (r).pri2cos[0]=(((r).pri2cos[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_PRI2COSr_COS2f_GET(r) ((((r).pri2cos[0]) >> 8) & 0xf)
#define BCM56800_A0_PRI2COSr_COS2f_SET(r,f) (r).pri2cos[0]=(((r).pri2cos[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_PRI2COSr_COS3f_GET(r) ((((r).pri2cos[0]) >> 12) & 0xf)
#define BCM56800_A0_PRI2COSr_COS3f_SET(r,f) (r).pri2cos[0]=(((r).pri2cos[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_PRI2COSr_COS4f_GET(r) ((((r).pri2cos[0]) >> 16) & 0xf)
#define BCM56800_A0_PRI2COSr_COS4f_SET(r,f) (r).pri2cos[0]=(((r).pri2cos[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_PRI2COSr_COS5f_GET(r) ((((r).pri2cos[0]) >> 20) & 0xf)
#define BCM56800_A0_PRI2COSr_COS5f_SET(r,f) (r).pri2cos[0]=(((r).pri2cos[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_PRI2COSr_COS6f_GET(r) ((((r).pri2cos[0]) >> 24) & 0xf)
#define BCM56800_A0_PRI2COSr_COS6f_SET(r,f) (r).pri2cos[0]=(((r).pri2cos[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_PRI2COSr_COS7f_GET(r) ((((r).pri2cos[0]) >> 28) & 0xf)
#define BCM56800_A0_PRI2COSr_COS7f_SET(r,f) (r).pri2cos[0]=(((r).pri2cos[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access PRI2COS.
 *
 */
#define BCM56800_A0_READ_PRI2COSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PRI2COSr,(r._pri2cos))
#define BCM56800_A0_WRITE_PRI2COSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PRI2COSr,&(r._pri2cos))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRI2COSr BCM56800_A0_PRI2COSr
#define PRI2COSr_SIZE BCM56800_A0_PRI2COSr_SIZE
typedef BCM56800_A0_PRI2COSr_t PRI2COSr_t;
#define PRI2COSr_CLR BCM56800_A0_PRI2COSr_CLR
#define PRI2COSr_SET BCM56800_A0_PRI2COSr_SET
#define PRI2COSr_GET BCM56800_A0_PRI2COSr_GET
#define PRI2COSr_COS0f_GET BCM56800_A0_PRI2COSr_COS0f_GET
#define PRI2COSr_COS0f_SET BCM56800_A0_PRI2COSr_COS0f_SET
#define PRI2COSr_COS1f_GET BCM56800_A0_PRI2COSr_COS1f_GET
#define PRI2COSr_COS1f_SET BCM56800_A0_PRI2COSr_COS1f_SET
#define PRI2COSr_COS2f_GET BCM56800_A0_PRI2COSr_COS2f_GET
#define PRI2COSr_COS2f_SET BCM56800_A0_PRI2COSr_COS2f_SET
#define PRI2COSr_COS3f_GET BCM56800_A0_PRI2COSr_COS3f_GET
#define PRI2COSr_COS3f_SET BCM56800_A0_PRI2COSr_COS3f_SET
#define PRI2COSr_COS4f_GET BCM56800_A0_PRI2COSr_COS4f_GET
#define PRI2COSr_COS4f_SET BCM56800_A0_PRI2COSr_COS4f_SET
#define PRI2COSr_COS5f_GET BCM56800_A0_PRI2COSr_COS5f_GET
#define PRI2COSr_COS5f_SET BCM56800_A0_PRI2COSr_COS5f_SET
#define PRI2COSr_COS6f_GET BCM56800_A0_PRI2COSr_COS6f_GET
#define PRI2COSr_COS6f_SET BCM56800_A0_PRI2COSr_COS6f_SET
#define PRI2COSr_COS7f_GET BCM56800_A0_PRI2COSr_COS7f_GET
#define PRI2COSr_COS7f_SET BCM56800_A0_PRI2COSr_COS7f_SET
#define READ_PRI2COSr BCM56800_A0_READ_PRI2COSr
#define WRITE_PRI2COSr BCM56800_A0_WRITE_PRI2COSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PRI2COSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PRI2COS_2
 * BLOCKS:   MMU
 * DESC:     Priority (8 to 15) to COS value lookup for FC report
from XPORTs through MMU to ES0/1

 * SIZE:     32
 * FIELDS:
 *     COS8             COS value for priority 8
 *     COS9             COS value for priority 9
 *     COS10            COS value for priority 10
 *     COS11            COS value for priority 11
 *     COS12            COS value for priority 12
 *     COS13            COS value for priority 13
 *     COS14            COS value for priority 14
 *     COS15            COS value for priority 15
 *
 ******************************************************************************/
#define BCM56800_A0_PRI2COS_2r 0x0bd80005

#define BCM56800_A0_PRI2COS_2r_SIZE 4

/*
 * This structure should be used to declare and program PRI2COS_2.
 *
 */
typedef union BCM56800_A0_PRI2COS_2r_s {
	uint32_t v[1];
	uint32_t pri2cos_2[1];
	uint32_t _pri2cos_2;
} BCM56800_A0_PRI2COS_2r_t;

#define BCM56800_A0_PRI2COS_2r_CLR(r) (r).pri2cos_2[0] = 0
#define BCM56800_A0_PRI2COS_2r_SET(r,d) (r).pri2cos_2[0] = d
#define BCM56800_A0_PRI2COS_2r_GET(r) (r).pri2cos_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PRI2COS_2r_COS8f_GET(r) (((r).pri2cos_2[0]) & 0xf)
#define BCM56800_A0_PRI2COS_2r_COS8f_SET(r,f) (r).pri2cos_2[0]=(((r).pri2cos_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_PRI2COS_2r_COS9f_GET(r) ((((r).pri2cos_2[0]) >> 4) & 0xf)
#define BCM56800_A0_PRI2COS_2r_COS9f_SET(r,f) (r).pri2cos_2[0]=(((r).pri2cos_2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_PRI2COS_2r_COS10f_GET(r) ((((r).pri2cos_2[0]) >> 8) & 0xf)
#define BCM56800_A0_PRI2COS_2r_COS10f_SET(r,f) (r).pri2cos_2[0]=(((r).pri2cos_2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_PRI2COS_2r_COS11f_GET(r) ((((r).pri2cos_2[0]) >> 12) & 0xf)
#define BCM56800_A0_PRI2COS_2r_COS11f_SET(r,f) (r).pri2cos_2[0]=(((r).pri2cos_2[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_PRI2COS_2r_COS12f_GET(r) ((((r).pri2cos_2[0]) >> 16) & 0xf)
#define BCM56800_A0_PRI2COS_2r_COS12f_SET(r,f) (r).pri2cos_2[0]=(((r).pri2cos_2[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_PRI2COS_2r_COS13f_GET(r) ((((r).pri2cos_2[0]) >> 20) & 0xf)
#define BCM56800_A0_PRI2COS_2r_COS13f_SET(r,f) (r).pri2cos_2[0]=(((r).pri2cos_2[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_PRI2COS_2r_COS14f_GET(r) ((((r).pri2cos_2[0]) >> 24) & 0xf)
#define BCM56800_A0_PRI2COS_2r_COS14f_SET(r,f) (r).pri2cos_2[0]=(((r).pri2cos_2[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_PRI2COS_2r_COS15f_GET(r) ((((r).pri2cos_2[0]) >> 28) & 0xf)
#define BCM56800_A0_PRI2COS_2r_COS15f_SET(r,f) (r).pri2cos_2[0]=(((r).pri2cos_2[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access PRI2COS_2.
 *
 */
#define BCM56800_A0_READ_PRI2COS_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PRI2COS_2r,(r._pri2cos_2))
#define BCM56800_A0_WRITE_PRI2COS_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PRI2COS_2r,&(r._pri2cos_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRI2COS_2r BCM56800_A0_PRI2COS_2r
#define PRI2COS_2r_SIZE BCM56800_A0_PRI2COS_2r_SIZE
typedef BCM56800_A0_PRI2COS_2r_t PRI2COS_2r_t;
#define PRI2COS_2r_CLR BCM56800_A0_PRI2COS_2r_CLR
#define PRI2COS_2r_SET BCM56800_A0_PRI2COS_2r_SET
#define PRI2COS_2r_GET BCM56800_A0_PRI2COS_2r_GET
#define PRI2COS_2r_COS8f_GET BCM56800_A0_PRI2COS_2r_COS8f_GET
#define PRI2COS_2r_COS8f_SET BCM56800_A0_PRI2COS_2r_COS8f_SET
#define PRI2COS_2r_COS9f_GET BCM56800_A0_PRI2COS_2r_COS9f_GET
#define PRI2COS_2r_COS9f_SET BCM56800_A0_PRI2COS_2r_COS9f_SET
#define PRI2COS_2r_COS10f_GET BCM56800_A0_PRI2COS_2r_COS10f_GET
#define PRI2COS_2r_COS10f_SET BCM56800_A0_PRI2COS_2r_COS10f_SET
#define PRI2COS_2r_COS11f_GET BCM56800_A0_PRI2COS_2r_COS11f_GET
#define PRI2COS_2r_COS11f_SET BCM56800_A0_PRI2COS_2r_COS11f_SET
#define PRI2COS_2r_COS12f_GET BCM56800_A0_PRI2COS_2r_COS12f_GET
#define PRI2COS_2r_COS12f_SET BCM56800_A0_PRI2COS_2r_COS12f_SET
#define PRI2COS_2r_COS13f_GET BCM56800_A0_PRI2COS_2r_COS13f_GET
#define PRI2COS_2r_COS13f_SET BCM56800_A0_PRI2COS_2r_COS13f_SET
#define PRI2COS_2r_COS14f_GET BCM56800_A0_PRI2COS_2r_COS14f_GET
#define PRI2COS_2r_COS14f_SET BCM56800_A0_PRI2COS_2r_COS14f_SET
#define PRI2COS_2r_COS15f_GET BCM56800_A0_PRI2COS_2r_COS15f_GET
#define PRI2COS_2r_COS15f_SET BCM56800_A0_PRI2COS_2r_COS15f_SET
#define READ_PRI2COS_2r BCM56800_A0_READ_PRI2COS_2r
#define WRITE_PRI2COS_2r BCM56800_A0_WRITE_PRI2COS_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PRI2COS_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PRIORITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Register that controls the generation of various priorities
 * SIZE:     32
 * FIELDS:
 *     USE_QM_FOR_COS_SEL If set, use QM priority (15) for HiGig+ E2EFC and E2ECC packets as input into the COS_SEL mapping function.
 *     USE_SC_FOR_COS_SEL If set, use SC priority (14) for HiGig+ opcode=CONTROL packets as input into the COS_SEL mapping function.
 *     USE_QM_FOR_MH_PRI If set, use QM priority (15) for HiGig+ E2EFC and E2ECC packets as PBI.MH_PRIORITY.
 *     USE_SC_FOR_MH_PRI If set, use SC priority (14) for HiGig+ opcode=CONTROL packets as PBI.MH_PRIORITY.
 *     SC_CPU_PRI_MODE  Specifies how the CPU priority of HiGig+ and HiGig2 system control packets will be generated.
 *     ALWAYS_APPLY_CPU_PRI_SEL If set, the internal priority of both the unicast and non-unicast packets will go through CPU_PRI_SEL mapping. If not set, the internal priority of only the non-unicast packets will go through CPU_PRI_SEL mapping.
 *
 ******************************************************************************/
#define BCM56800_A0_PRIORITY_CONTROLr 0x0e180649

#define BCM56800_A0_PRIORITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PRIORITY_CONTROL.
 *
 */
typedef union BCM56800_A0_PRIORITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t priority_control[1];
	uint32_t _priority_control;
} BCM56800_A0_PRIORITY_CONTROLr_t;

#define BCM56800_A0_PRIORITY_CONTROLr_CLR(r) (r).priority_control[0] = 0
#define BCM56800_A0_PRIORITY_CONTROLr_SET(r,d) (r).priority_control[0] = d
#define BCM56800_A0_PRIORITY_CONTROLr_GET(r) (r).priority_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PRIORITY_CONTROLr_USE_QM_FOR_COS_SELf_GET(r) (((r).priority_control[0]) & 0x1)
#define BCM56800_A0_PRIORITY_CONTROLr_USE_QM_FOR_COS_SELf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_PRIORITY_CONTROLr_USE_SC_FOR_COS_SELf_GET(r) ((((r).priority_control[0]) >> 1) & 0x1)
#define BCM56800_A0_PRIORITY_CONTROLr_USE_SC_FOR_COS_SELf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_PRIORITY_CONTROLr_USE_QM_FOR_MH_PRIf_GET(r) ((((r).priority_control[0]) >> 2) & 0x1)
#define BCM56800_A0_PRIORITY_CONTROLr_USE_QM_FOR_MH_PRIf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_PRIORITY_CONTROLr_USE_SC_FOR_MH_PRIf_GET(r) ((((r).priority_control[0]) >> 3) & 0x1)
#define BCM56800_A0_PRIORITY_CONTROLr_USE_SC_FOR_MH_PRIf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET(r) ((((r).priority_control[0]) >> 4) & 0x1)
#define BCM56800_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET(r) ((((r).priority_control[0]) >> 5) & 0x1)
#define BCM56800_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET(r,f) (r).priority_control[0]=(((r).priority_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * These macros can be used to access PRIORITY_CONTROL.
 *
 */
#define BCM56800_A0_READ_PRIORITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_PRIORITY_CONTROLr,(r._priority_control))
#define BCM56800_A0_WRITE_PRIORITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_PRIORITY_CONTROLr,&(r._priority_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRIORITY_CONTROLr BCM56800_A0_PRIORITY_CONTROLr
#define PRIORITY_CONTROLr_SIZE BCM56800_A0_PRIORITY_CONTROLr_SIZE
typedef BCM56800_A0_PRIORITY_CONTROLr_t PRIORITY_CONTROLr_t;
#define PRIORITY_CONTROLr_CLR BCM56800_A0_PRIORITY_CONTROLr_CLR
#define PRIORITY_CONTROLr_SET BCM56800_A0_PRIORITY_CONTROLr_SET
#define PRIORITY_CONTROLr_GET BCM56800_A0_PRIORITY_CONTROLr_GET
#define PRIORITY_CONTROLr_USE_QM_FOR_COS_SELf_GET BCM56800_A0_PRIORITY_CONTROLr_USE_QM_FOR_COS_SELf_GET
#define PRIORITY_CONTROLr_USE_QM_FOR_COS_SELf_SET BCM56800_A0_PRIORITY_CONTROLr_USE_QM_FOR_COS_SELf_SET
#define PRIORITY_CONTROLr_USE_SC_FOR_COS_SELf_GET BCM56800_A0_PRIORITY_CONTROLr_USE_SC_FOR_COS_SELf_GET
#define PRIORITY_CONTROLr_USE_SC_FOR_COS_SELf_SET BCM56800_A0_PRIORITY_CONTROLr_USE_SC_FOR_COS_SELf_SET
#define PRIORITY_CONTROLr_USE_QM_FOR_MH_PRIf_GET BCM56800_A0_PRIORITY_CONTROLr_USE_QM_FOR_MH_PRIf_GET
#define PRIORITY_CONTROLr_USE_QM_FOR_MH_PRIf_SET BCM56800_A0_PRIORITY_CONTROLr_USE_QM_FOR_MH_PRIf_SET
#define PRIORITY_CONTROLr_USE_SC_FOR_MH_PRIf_GET BCM56800_A0_PRIORITY_CONTROLr_USE_SC_FOR_MH_PRIf_GET
#define PRIORITY_CONTROLr_USE_SC_FOR_MH_PRIf_SET BCM56800_A0_PRIORITY_CONTROLr_USE_SC_FOR_MH_PRIf_SET
#define PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET BCM56800_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_GET
#define PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET BCM56800_A0_PRIORITY_CONTROLr_SC_CPU_PRI_MODEf_SET
#define PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET BCM56800_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_GET
#define PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET BCM56800_A0_PRIORITY_CONTROLr_ALWAYS_APPLY_CPU_PRI_SELf_SET
#define READ_PRIORITY_CONTROLr BCM56800_A0_READ_PRIORITY_CONTROLr
#define WRITE_PRIORITY_CONTROLr BCM56800_A0_WRITE_PRIORITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PRIORITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PROTOCOL_PKT_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Protocol Packet Control Register
 * SIZE:     32
 * FIELDS:
 *     DHCP_PKT_TO_CPU  Send DHCP Packets to the CPU
 *     DHCP_PKT_DROP    Drop DHCP Packets
 *     IPV6_RESVD_MC_PKT_TO_CPU Send IPv6 reserved multicast packets to the CPU
 *     IPV6_RESVD_MC_PKT_DROP Drop IPv6 reserved multicast packets
 *     IPV4_RESVD_MC_PKT_TO_CPU Send IPv4 reserved multicast packets to the CPU
 *     IPV4_RESVD_MC_PKT_DROP Drop IPv4 reserved multicast packets
 *     MLD_PKT_TO_CPU   Send MLD Packets to the CPU
 *     MLD_PKT_DROP     Drop MLD Packets
 *     IGMP_PKT_TO_CPU  Send IGMP Packets to the CPU
 *     IGMP_PKT_DROP    Drop IGMP Packets
 *     ND_PKT_TO_CPU    Send ND Packets to the CPU
 *     ND_PKT_DROP      Drop ND Packets
 *     ARP_REQUEST_TO_CPU Send ARP Request Packets to the CPU
 *     ARP_REQUEST_DROP Drop ARP Request Packets
 *     ARP_REPLY_TO_CPU Send ARP Reply Packets to the CPU
 *     ARP_REPLY_DROP   Drop ARP Reply Packets
 *
 ******************************************************************************/
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr 0x0b100006

#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program PROTOCOL_PKT_CONTROL.
 *
 */
typedef union BCM56800_A0_PROTOCOL_PKT_CONTROLr_s {
	uint32_t v[1];
	uint32_t protocol_pkt_control[1];
	uint32_t _protocol_pkt_control;
} BCM56800_A0_PROTOCOL_PKT_CONTROLr_t;

#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_CLR(r) (r).protocol_pkt_control[0] = 0
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_SET(r,d) (r).protocol_pkt_control[0] = d
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_GET(r) (r).protocol_pkt_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET(r) (((r).protocol_pkt_control[0]) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 1) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 2) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 3) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 4) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 5) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 6) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 7) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 8) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 9) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 10) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 11) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 12) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 13) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET(r) ((((r).protocol_pkt_control[0]) >> 14) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET(r) ((((r).protocol_pkt_control[0]) >> 15) & 0x1)
#define BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET(r,f) (r).protocol_pkt_control[0]=(((r).protocol_pkt_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access PROTOCOL_PKT_CONTROL.
 *
 */
#define BCM56800_A0_READ_PROTOCOL_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PROTOCOL_PKT_CONTROLr,(r._protocol_pkt_control))
#define BCM56800_A0_WRITE_PROTOCOL_PKT_CONTROLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PROTOCOL_PKT_CONTROLr,&(r._protocol_pkt_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTOCOL_PKT_CONTROLr BCM56800_A0_PROTOCOL_PKT_CONTROLr
#define PROTOCOL_PKT_CONTROLr_SIZE BCM56800_A0_PROTOCOL_PKT_CONTROLr_SIZE
typedef BCM56800_A0_PROTOCOL_PKT_CONTROLr_t PROTOCOL_PKT_CONTROLr_t;
#define PROTOCOL_PKT_CONTROLr_CLR BCM56800_A0_PROTOCOL_PKT_CONTROLr_CLR
#define PROTOCOL_PKT_CONTROLr_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_SET
#define PROTOCOL_PKT_CONTROLr_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_DHCP_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV6_RESVD_MC_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IPV4_RESVD_MC_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_MLD_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_IGMP_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ND_PKT_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REQUEST_DROPf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_TO_CPUf_SET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_GET
#define PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET BCM56800_A0_PROTOCOL_PKT_CONTROLr_ARP_REPLY_DROPf_SET
#define READ_PROTOCOL_PKT_CONTROLr BCM56800_A0_READ_PROTOCOL_PKT_CONTROLr
#define WRITE_PROTOCOL_PKT_CONTROLr BCM56800_A0_WRITE_PROTOCOL_PKT_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PROTOCOL_PKT_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  PURGE_PKT_CNT
 * BLOCKS:   MMU
 * DESC:     Purge packet counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Purge packet count
 *
 ******************************************************************************/
#define BCM56800_A0_PURGE_PKT_CNTr 0x0ed00032

#define BCM56800_A0_PURGE_PKT_CNTr_SIZE 4

/*
 * This structure should be used to declare and program PURGE_PKT_CNT.
 *
 */
typedef union BCM56800_A0_PURGE_PKT_CNTr_s {
	uint32_t v[1];
	uint32_t purge_pkt_cnt[1];
	uint32_t _purge_pkt_cnt;
} BCM56800_A0_PURGE_PKT_CNTr_t;

#define BCM56800_A0_PURGE_PKT_CNTr_CLR(r) (r).purge_pkt_cnt[0] = 0
#define BCM56800_A0_PURGE_PKT_CNTr_SET(r,d) (r).purge_pkt_cnt[0] = d
#define BCM56800_A0_PURGE_PKT_CNTr_GET(r) (r).purge_pkt_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_PURGE_PKT_CNTr_COUNTf_GET(r) ((r).purge_pkt_cnt[0])
#define BCM56800_A0_PURGE_PKT_CNTr_COUNTf_SET(r,f) (r).purge_pkt_cnt[0]=((uint32_t)f)

/*
 * These macros can be used to access PURGE_PKT_CNT.
 *
 */
#define BCM56800_A0_READ_PURGE_PKT_CNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_PURGE_PKT_CNTr,(r._purge_pkt_cnt))
#define BCM56800_A0_WRITE_PURGE_PKT_CNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_PURGE_PKT_CNTr,&(r._purge_pkt_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PURGE_PKT_CNTr BCM56800_A0_PURGE_PKT_CNTr
#define PURGE_PKT_CNTr_SIZE BCM56800_A0_PURGE_PKT_CNTr_SIZE
typedef BCM56800_A0_PURGE_PKT_CNTr_t PURGE_PKT_CNTr_t;
#define PURGE_PKT_CNTr_CLR BCM56800_A0_PURGE_PKT_CNTr_CLR
#define PURGE_PKT_CNTr_SET BCM56800_A0_PURGE_PKT_CNTr_SET
#define PURGE_PKT_CNTr_GET BCM56800_A0_PURGE_PKT_CNTr_GET
#define PURGE_PKT_CNTr_COUNTf_GET BCM56800_A0_PURGE_PKT_CNTr_COUNTf_GET
#define PURGE_PKT_CNTr_COUNTf_SET BCM56800_A0_PURGE_PKT_CNTr_COUNTf_SET
#define READ_PURGE_PKT_CNTr BCM56800_A0_READ_PURGE_PKT_CNTr
#define WRITE_PURGE_PKT_CNTr BCM56800_A0_WRITE_PURGE_PKT_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_PURGE_PKT_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC0
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #0
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC0r 0x0e10000b

#define BCM56800_A0_RDBGC0r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC0.
 *
 */
typedef union BCM56800_A0_RDBGC0r_s {
	uint32_t v[1];
	uint32_t rdbgc0[1];
	uint32_t _rdbgc0;
} BCM56800_A0_RDBGC0r_t;

#define BCM56800_A0_RDBGC0r_CLR(r) (r).rdbgc0[0] = 0
#define BCM56800_A0_RDBGC0r_SET(r,d) (r).rdbgc0[0] = d
#define BCM56800_A0_RDBGC0r_GET(r) (r).rdbgc0[0]


/*
 * These macros can be used to access RDBGC0.
 *
 */
#define BCM56800_A0_READ_RDBGC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC0r,(r._rdbgc0))
#define BCM56800_A0_WRITE_RDBGC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC0r,&(r._rdbgc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC0r BCM56800_A0_RDBGC0r
#define RDBGC0r_SIZE BCM56800_A0_RDBGC0r_SIZE
typedef BCM56800_A0_RDBGC0r_t RDBGC0r_t;
#define RDBGC0r_CLR BCM56800_A0_RDBGC0r_CLR
#define RDBGC0r_SET BCM56800_A0_RDBGC0r_SET
#define RDBGC0r_GET BCM56800_A0_RDBGC0r_GET
#define READ_RDBGC0r BCM56800_A0_READ_RDBGC0r
#define WRITE_RDBGC0r BCM56800_A0_WRITE_RDBGC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC0_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #0 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC0_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC0_SELECTr 0x0e18060a

#define BCM56800_A0_RDBGC0_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC0_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC0_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc0_select[1];
	uint32_t _rdbgc0_select;
} BCM56800_A0_RDBGC0_SELECTr_t;

#define BCM56800_A0_RDBGC0_SELECTr_CLR(r) (r).rdbgc0_select[0] = 0
#define BCM56800_A0_RDBGC0_SELECTr_SET(r,d) (r).rdbgc0_select[0] = d
#define BCM56800_A0_RDBGC0_SELECTr_GET(r) (r).rdbgc0_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC0_SELECTr_BITMAPf_GET(r) ((r).rdbgc0_select[0])
#define BCM56800_A0_RDBGC0_SELECTr_BITMAPf_SET(r,f) (r).rdbgc0_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC0_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC0_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC0_SELECTr,(r._rdbgc0_select))
#define BCM56800_A0_WRITE_RDBGC0_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC0_SELECTr,&(r._rdbgc0_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC0_SELECTr BCM56800_A0_RDBGC0_SELECTr
#define RDBGC0_SELECTr_SIZE BCM56800_A0_RDBGC0_SELECTr_SIZE
typedef BCM56800_A0_RDBGC0_SELECTr_t RDBGC0_SELECTr_t;
#define RDBGC0_SELECTr_CLR BCM56800_A0_RDBGC0_SELECTr_CLR
#define RDBGC0_SELECTr_SET BCM56800_A0_RDBGC0_SELECTr_SET
#define RDBGC0_SELECTr_GET BCM56800_A0_RDBGC0_SELECTr_GET
#define RDBGC0_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC0_SELECTr_BITMAPf_GET
#define RDBGC0_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC0_SELECTr_BITMAPf_SET
#define READ_RDBGC0_SELECTr BCM56800_A0_READ_RDBGC0_SELECTr
#define WRITE_RDBGC0_SELECTr BCM56800_A0_WRITE_RDBGC0_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC0_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC1
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #1
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC1r 0x0e10000c

#define BCM56800_A0_RDBGC1r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC1.
 *
 */
typedef union BCM56800_A0_RDBGC1r_s {
	uint32_t v[1];
	uint32_t rdbgc1[1];
	uint32_t _rdbgc1;
} BCM56800_A0_RDBGC1r_t;

#define BCM56800_A0_RDBGC1r_CLR(r) (r).rdbgc1[0] = 0
#define BCM56800_A0_RDBGC1r_SET(r,d) (r).rdbgc1[0] = d
#define BCM56800_A0_RDBGC1r_GET(r) (r).rdbgc1[0]


/*
 * These macros can be used to access RDBGC1.
 *
 */
#define BCM56800_A0_READ_RDBGC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC1r,(r._rdbgc1))
#define BCM56800_A0_WRITE_RDBGC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC1r,&(r._rdbgc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC1r BCM56800_A0_RDBGC1r
#define RDBGC1r_SIZE BCM56800_A0_RDBGC1r_SIZE
typedef BCM56800_A0_RDBGC1r_t RDBGC1r_t;
#define RDBGC1r_CLR BCM56800_A0_RDBGC1r_CLR
#define RDBGC1r_SET BCM56800_A0_RDBGC1r_SET
#define RDBGC1r_GET BCM56800_A0_RDBGC1r_GET
#define READ_RDBGC1r BCM56800_A0_READ_RDBGC1r
#define WRITE_RDBGC1r BCM56800_A0_WRITE_RDBGC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC1_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #1 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC1_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC1_SELECTr 0x0e18060b

#define BCM56800_A0_RDBGC1_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC1_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC1_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc1_select[1];
	uint32_t _rdbgc1_select;
} BCM56800_A0_RDBGC1_SELECTr_t;

#define BCM56800_A0_RDBGC1_SELECTr_CLR(r) (r).rdbgc1_select[0] = 0
#define BCM56800_A0_RDBGC1_SELECTr_SET(r,d) (r).rdbgc1_select[0] = d
#define BCM56800_A0_RDBGC1_SELECTr_GET(r) (r).rdbgc1_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC1_SELECTr_BITMAPf_GET(r) ((r).rdbgc1_select[0])
#define BCM56800_A0_RDBGC1_SELECTr_BITMAPf_SET(r,f) (r).rdbgc1_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC1_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC1_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC1_SELECTr,(r._rdbgc1_select))
#define BCM56800_A0_WRITE_RDBGC1_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC1_SELECTr,&(r._rdbgc1_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC1_SELECTr BCM56800_A0_RDBGC1_SELECTr
#define RDBGC1_SELECTr_SIZE BCM56800_A0_RDBGC1_SELECTr_SIZE
typedef BCM56800_A0_RDBGC1_SELECTr_t RDBGC1_SELECTr_t;
#define RDBGC1_SELECTr_CLR BCM56800_A0_RDBGC1_SELECTr_CLR
#define RDBGC1_SELECTr_SET BCM56800_A0_RDBGC1_SELECTr_SET
#define RDBGC1_SELECTr_GET BCM56800_A0_RDBGC1_SELECTr_GET
#define RDBGC1_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC1_SELECTr_BITMAPf_GET
#define RDBGC1_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC1_SELECTr_BITMAPf_SET
#define READ_RDBGC1_SELECTr BCM56800_A0_READ_RDBGC1_SELECTr
#define WRITE_RDBGC1_SELECTr BCM56800_A0_WRITE_RDBGC1_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC1_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC2
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #2
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC2r 0x0e10000d

#define BCM56800_A0_RDBGC2r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC2.
 *
 */
typedef union BCM56800_A0_RDBGC2r_s {
	uint32_t v[1];
	uint32_t rdbgc2[1];
	uint32_t _rdbgc2;
} BCM56800_A0_RDBGC2r_t;

#define BCM56800_A0_RDBGC2r_CLR(r) (r).rdbgc2[0] = 0
#define BCM56800_A0_RDBGC2r_SET(r,d) (r).rdbgc2[0] = d
#define BCM56800_A0_RDBGC2r_GET(r) (r).rdbgc2[0]


/*
 * These macros can be used to access RDBGC2.
 *
 */
#define BCM56800_A0_READ_RDBGC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC2r,(r._rdbgc2))
#define BCM56800_A0_WRITE_RDBGC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC2r,&(r._rdbgc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC2r BCM56800_A0_RDBGC2r
#define RDBGC2r_SIZE BCM56800_A0_RDBGC2r_SIZE
typedef BCM56800_A0_RDBGC2r_t RDBGC2r_t;
#define RDBGC2r_CLR BCM56800_A0_RDBGC2r_CLR
#define RDBGC2r_SET BCM56800_A0_RDBGC2r_SET
#define RDBGC2r_GET BCM56800_A0_RDBGC2r_GET
#define READ_RDBGC2r BCM56800_A0_READ_RDBGC2r
#define WRITE_RDBGC2r BCM56800_A0_WRITE_RDBGC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC2_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #2 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC2_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC2_SELECTr 0x0e18060c

#define BCM56800_A0_RDBGC2_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC2_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC2_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc2_select[1];
	uint32_t _rdbgc2_select;
} BCM56800_A0_RDBGC2_SELECTr_t;

#define BCM56800_A0_RDBGC2_SELECTr_CLR(r) (r).rdbgc2_select[0] = 0
#define BCM56800_A0_RDBGC2_SELECTr_SET(r,d) (r).rdbgc2_select[0] = d
#define BCM56800_A0_RDBGC2_SELECTr_GET(r) (r).rdbgc2_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC2_SELECTr_BITMAPf_GET(r) ((r).rdbgc2_select[0])
#define BCM56800_A0_RDBGC2_SELECTr_BITMAPf_SET(r,f) (r).rdbgc2_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC2_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC2_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC2_SELECTr,(r._rdbgc2_select))
#define BCM56800_A0_WRITE_RDBGC2_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC2_SELECTr,&(r._rdbgc2_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC2_SELECTr BCM56800_A0_RDBGC2_SELECTr
#define RDBGC2_SELECTr_SIZE BCM56800_A0_RDBGC2_SELECTr_SIZE
typedef BCM56800_A0_RDBGC2_SELECTr_t RDBGC2_SELECTr_t;
#define RDBGC2_SELECTr_CLR BCM56800_A0_RDBGC2_SELECTr_CLR
#define RDBGC2_SELECTr_SET BCM56800_A0_RDBGC2_SELECTr_SET
#define RDBGC2_SELECTr_GET BCM56800_A0_RDBGC2_SELECTr_GET
#define RDBGC2_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC2_SELECTr_BITMAPf_GET
#define RDBGC2_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC2_SELECTr_BITMAPf_SET
#define READ_RDBGC2_SELECTr BCM56800_A0_READ_RDBGC2_SELECTr
#define WRITE_RDBGC2_SELECTr BCM56800_A0_WRITE_RDBGC2_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC2_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC3
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #3
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC3r 0x0e10000e

#define BCM56800_A0_RDBGC3r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC3.
 *
 */
typedef union BCM56800_A0_RDBGC3r_s {
	uint32_t v[1];
	uint32_t rdbgc3[1];
	uint32_t _rdbgc3;
} BCM56800_A0_RDBGC3r_t;

#define BCM56800_A0_RDBGC3r_CLR(r) (r).rdbgc3[0] = 0
#define BCM56800_A0_RDBGC3r_SET(r,d) (r).rdbgc3[0] = d
#define BCM56800_A0_RDBGC3r_GET(r) (r).rdbgc3[0]


/*
 * These macros can be used to access RDBGC3.
 *
 */
#define BCM56800_A0_READ_RDBGC3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC3r,(r._rdbgc3))
#define BCM56800_A0_WRITE_RDBGC3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC3r,&(r._rdbgc3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC3r BCM56800_A0_RDBGC3r
#define RDBGC3r_SIZE BCM56800_A0_RDBGC3r_SIZE
typedef BCM56800_A0_RDBGC3r_t RDBGC3r_t;
#define RDBGC3r_CLR BCM56800_A0_RDBGC3r_CLR
#define RDBGC3r_SET BCM56800_A0_RDBGC3r_SET
#define RDBGC3r_GET BCM56800_A0_RDBGC3r_GET
#define READ_RDBGC3r BCM56800_A0_READ_RDBGC3r
#define WRITE_RDBGC3r BCM56800_A0_WRITE_RDBGC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC3_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #3 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC3_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC3_SELECTr 0x0e18060d

#define BCM56800_A0_RDBGC3_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC3_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC3_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc3_select[1];
	uint32_t _rdbgc3_select;
} BCM56800_A0_RDBGC3_SELECTr_t;

#define BCM56800_A0_RDBGC3_SELECTr_CLR(r) (r).rdbgc3_select[0] = 0
#define BCM56800_A0_RDBGC3_SELECTr_SET(r,d) (r).rdbgc3_select[0] = d
#define BCM56800_A0_RDBGC3_SELECTr_GET(r) (r).rdbgc3_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC3_SELECTr_BITMAPf_GET(r) ((r).rdbgc3_select[0])
#define BCM56800_A0_RDBGC3_SELECTr_BITMAPf_SET(r,f) (r).rdbgc3_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC3_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC3_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC3_SELECTr,(r._rdbgc3_select))
#define BCM56800_A0_WRITE_RDBGC3_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC3_SELECTr,&(r._rdbgc3_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC3_SELECTr BCM56800_A0_RDBGC3_SELECTr
#define RDBGC3_SELECTr_SIZE BCM56800_A0_RDBGC3_SELECTr_SIZE
typedef BCM56800_A0_RDBGC3_SELECTr_t RDBGC3_SELECTr_t;
#define RDBGC3_SELECTr_CLR BCM56800_A0_RDBGC3_SELECTr_CLR
#define RDBGC3_SELECTr_SET BCM56800_A0_RDBGC3_SELECTr_SET
#define RDBGC3_SELECTr_GET BCM56800_A0_RDBGC3_SELECTr_GET
#define RDBGC3_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC3_SELECTr_BITMAPf_GET
#define RDBGC3_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC3_SELECTr_BITMAPf_SET
#define READ_RDBGC3_SELECTr BCM56800_A0_READ_RDBGC3_SELECTr
#define WRITE_RDBGC3_SELECTr BCM56800_A0_WRITE_RDBGC3_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC3_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC4
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #4
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC4r 0x0e10000f

#define BCM56800_A0_RDBGC4r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC4.
 *
 */
typedef union BCM56800_A0_RDBGC4r_s {
	uint32_t v[1];
	uint32_t rdbgc4[1];
	uint32_t _rdbgc4;
} BCM56800_A0_RDBGC4r_t;

#define BCM56800_A0_RDBGC4r_CLR(r) (r).rdbgc4[0] = 0
#define BCM56800_A0_RDBGC4r_SET(r,d) (r).rdbgc4[0] = d
#define BCM56800_A0_RDBGC4r_GET(r) (r).rdbgc4[0]


/*
 * These macros can be used to access RDBGC4.
 *
 */
#define BCM56800_A0_READ_RDBGC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC4r,(r._rdbgc4))
#define BCM56800_A0_WRITE_RDBGC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC4r,&(r._rdbgc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC4r BCM56800_A0_RDBGC4r
#define RDBGC4r_SIZE BCM56800_A0_RDBGC4r_SIZE
typedef BCM56800_A0_RDBGC4r_t RDBGC4r_t;
#define RDBGC4r_CLR BCM56800_A0_RDBGC4r_CLR
#define RDBGC4r_SET BCM56800_A0_RDBGC4r_SET
#define RDBGC4r_GET BCM56800_A0_RDBGC4r_GET
#define READ_RDBGC4r BCM56800_A0_READ_RDBGC4r
#define WRITE_RDBGC4r BCM56800_A0_WRITE_RDBGC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC4_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #4 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC4_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC4_SELECTr 0x0e18060e

#define BCM56800_A0_RDBGC4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC4_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC4_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc4_select[1];
	uint32_t _rdbgc4_select;
} BCM56800_A0_RDBGC4_SELECTr_t;

#define BCM56800_A0_RDBGC4_SELECTr_CLR(r) (r).rdbgc4_select[0] = 0
#define BCM56800_A0_RDBGC4_SELECTr_SET(r,d) (r).rdbgc4_select[0] = d
#define BCM56800_A0_RDBGC4_SELECTr_GET(r) (r).rdbgc4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC4_SELECTr_BITMAPf_GET(r) ((r).rdbgc4_select[0])
#define BCM56800_A0_RDBGC4_SELECTr_BITMAPf_SET(r,f) (r).rdbgc4_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC4_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC4_SELECTr,(r._rdbgc4_select))
#define BCM56800_A0_WRITE_RDBGC4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC4_SELECTr,&(r._rdbgc4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC4_SELECTr BCM56800_A0_RDBGC4_SELECTr
#define RDBGC4_SELECTr_SIZE BCM56800_A0_RDBGC4_SELECTr_SIZE
typedef BCM56800_A0_RDBGC4_SELECTr_t RDBGC4_SELECTr_t;
#define RDBGC4_SELECTr_CLR BCM56800_A0_RDBGC4_SELECTr_CLR
#define RDBGC4_SELECTr_SET BCM56800_A0_RDBGC4_SELECTr_SET
#define RDBGC4_SELECTr_GET BCM56800_A0_RDBGC4_SELECTr_GET
#define RDBGC4_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC4_SELECTr_BITMAPf_GET
#define RDBGC4_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC4_SELECTr_BITMAPf_SET
#define READ_RDBGC4_SELECTr BCM56800_A0_READ_RDBGC4_SELECTr
#define WRITE_RDBGC4_SELECTr BCM56800_A0_WRITE_RDBGC4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC5
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #5
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC5r 0x0e100018

#define BCM56800_A0_RDBGC5r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC5.
 *
 */
typedef union BCM56800_A0_RDBGC5r_s {
	uint32_t v[1];
	uint32_t rdbgc5[1];
	uint32_t _rdbgc5;
} BCM56800_A0_RDBGC5r_t;

#define BCM56800_A0_RDBGC5r_CLR(r) (r).rdbgc5[0] = 0
#define BCM56800_A0_RDBGC5r_SET(r,d) (r).rdbgc5[0] = d
#define BCM56800_A0_RDBGC5r_GET(r) (r).rdbgc5[0]


/*
 * These macros can be used to access RDBGC5.
 *
 */
#define BCM56800_A0_READ_RDBGC5r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC5r,(r._rdbgc5))
#define BCM56800_A0_WRITE_RDBGC5r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC5r,&(r._rdbgc5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC5r BCM56800_A0_RDBGC5r
#define RDBGC5r_SIZE BCM56800_A0_RDBGC5r_SIZE
typedef BCM56800_A0_RDBGC5r_t RDBGC5r_t;
#define RDBGC5r_CLR BCM56800_A0_RDBGC5r_CLR
#define RDBGC5r_SET BCM56800_A0_RDBGC5r_SET
#define RDBGC5r_GET BCM56800_A0_RDBGC5r_GET
#define READ_RDBGC5r BCM56800_A0_READ_RDBGC5r
#define WRITE_RDBGC5r BCM56800_A0_WRITE_RDBGC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC5_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #5 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC5_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC5_SELECTr 0x0e18060f

#define BCM56800_A0_RDBGC5_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC5_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC5_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc5_select[1];
	uint32_t _rdbgc5_select;
} BCM56800_A0_RDBGC5_SELECTr_t;

#define BCM56800_A0_RDBGC5_SELECTr_CLR(r) (r).rdbgc5_select[0] = 0
#define BCM56800_A0_RDBGC5_SELECTr_SET(r,d) (r).rdbgc5_select[0] = d
#define BCM56800_A0_RDBGC5_SELECTr_GET(r) (r).rdbgc5_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC5_SELECTr_BITMAPf_GET(r) ((r).rdbgc5_select[0])
#define BCM56800_A0_RDBGC5_SELECTr_BITMAPf_SET(r,f) (r).rdbgc5_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC5_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC5_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC5_SELECTr,(r._rdbgc5_select))
#define BCM56800_A0_WRITE_RDBGC5_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC5_SELECTr,&(r._rdbgc5_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC5_SELECTr BCM56800_A0_RDBGC5_SELECTr
#define RDBGC5_SELECTr_SIZE BCM56800_A0_RDBGC5_SELECTr_SIZE
typedef BCM56800_A0_RDBGC5_SELECTr_t RDBGC5_SELECTr_t;
#define RDBGC5_SELECTr_CLR BCM56800_A0_RDBGC5_SELECTr_CLR
#define RDBGC5_SELECTr_SET BCM56800_A0_RDBGC5_SELECTr_SET
#define RDBGC5_SELECTr_GET BCM56800_A0_RDBGC5_SELECTr_GET
#define RDBGC5_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC5_SELECTr_BITMAPf_GET
#define RDBGC5_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC5_SELECTr_BITMAPf_SET
#define READ_RDBGC5_SELECTr BCM56800_A0_READ_RDBGC5_SELECTr
#define WRITE_RDBGC5_SELECTr BCM56800_A0_WRITE_RDBGC5_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC5_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC6
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #6
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC6r 0x0e100019

#define BCM56800_A0_RDBGC6r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC6.
 *
 */
typedef union BCM56800_A0_RDBGC6r_s {
	uint32_t v[1];
	uint32_t rdbgc6[1];
	uint32_t _rdbgc6;
} BCM56800_A0_RDBGC6r_t;

#define BCM56800_A0_RDBGC6r_CLR(r) (r).rdbgc6[0] = 0
#define BCM56800_A0_RDBGC6r_SET(r,d) (r).rdbgc6[0] = d
#define BCM56800_A0_RDBGC6r_GET(r) (r).rdbgc6[0]


/*
 * These macros can be used to access RDBGC6.
 *
 */
#define BCM56800_A0_READ_RDBGC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC6r,(r._rdbgc6))
#define BCM56800_A0_WRITE_RDBGC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC6r,&(r._rdbgc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC6r BCM56800_A0_RDBGC6r
#define RDBGC6r_SIZE BCM56800_A0_RDBGC6r_SIZE
typedef BCM56800_A0_RDBGC6r_t RDBGC6r_t;
#define RDBGC6r_CLR BCM56800_A0_RDBGC6r_CLR
#define RDBGC6r_SET BCM56800_A0_RDBGC6r_SET
#define RDBGC6r_GET BCM56800_A0_RDBGC6r_GET
#define READ_RDBGC6r BCM56800_A0_READ_RDBGC6r
#define WRITE_RDBGC6r BCM56800_A0_WRITE_RDBGC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC6_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #6 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC6_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC6_SELECTr 0x0e180610

#define BCM56800_A0_RDBGC6_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC6_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC6_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc6_select[1];
	uint32_t _rdbgc6_select;
} BCM56800_A0_RDBGC6_SELECTr_t;

#define BCM56800_A0_RDBGC6_SELECTr_CLR(r) (r).rdbgc6_select[0] = 0
#define BCM56800_A0_RDBGC6_SELECTr_SET(r,d) (r).rdbgc6_select[0] = d
#define BCM56800_A0_RDBGC6_SELECTr_GET(r) (r).rdbgc6_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC6_SELECTr_BITMAPf_GET(r) ((r).rdbgc6_select[0])
#define BCM56800_A0_RDBGC6_SELECTr_BITMAPf_SET(r,f) (r).rdbgc6_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC6_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC6_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC6_SELECTr,(r._rdbgc6_select))
#define BCM56800_A0_WRITE_RDBGC6_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC6_SELECTr,&(r._rdbgc6_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC6_SELECTr BCM56800_A0_RDBGC6_SELECTr
#define RDBGC6_SELECTr_SIZE BCM56800_A0_RDBGC6_SELECTr_SIZE
typedef BCM56800_A0_RDBGC6_SELECTr_t RDBGC6_SELECTr_t;
#define RDBGC6_SELECTr_CLR BCM56800_A0_RDBGC6_SELECTr_CLR
#define RDBGC6_SELECTr_SET BCM56800_A0_RDBGC6_SELECTr_SET
#define RDBGC6_SELECTr_GET BCM56800_A0_RDBGC6_SELECTr_GET
#define RDBGC6_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC6_SELECTr_BITMAPf_GET
#define RDBGC6_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC6_SELECTr_BITMAPf_SET
#define READ_RDBGC6_SELECTr BCM56800_A0_READ_RDBGC6_SELECTr
#define WRITE_RDBGC6_SELECTr BCM56800_A0_WRITE_RDBGC6_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC6_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC7
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #7
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC7r 0x0e10001a

#define BCM56800_A0_RDBGC7r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC7.
 *
 */
typedef union BCM56800_A0_RDBGC7r_s {
	uint32_t v[1];
	uint32_t rdbgc7[1];
	uint32_t _rdbgc7;
} BCM56800_A0_RDBGC7r_t;

#define BCM56800_A0_RDBGC7r_CLR(r) (r).rdbgc7[0] = 0
#define BCM56800_A0_RDBGC7r_SET(r,d) (r).rdbgc7[0] = d
#define BCM56800_A0_RDBGC7r_GET(r) (r).rdbgc7[0]


/*
 * These macros can be used to access RDBGC7.
 *
 */
#define BCM56800_A0_READ_RDBGC7r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC7r,(r._rdbgc7))
#define BCM56800_A0_WRITE_RDBGC7r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC7r,&(r._rdbgc7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC7r BCM56800_A0_RDBGC7r
#define RDBGC7r_SIZE BCM56800_A0_RDBGC7r_SIZE
typedef BCM56800_A0_RDBGC7r_t RDBGC7r_t;
#define RDBGC7r_CLR BCM56800_A0_RDBGC7r_CLR
#define RDBGC7r_SET BCM56800_A0_RDBGC7r_SET
#define RDBGC7r_GET BCM56800_A0_RDBGC7r_GET
#define READ_RDBGC7r BCM56800_A0_READ_RDBGC7r
#define WRITE_RDBGC7r BCM56800_A0_WRITE_RDBGC7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC7_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #7 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC7_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC7_SELECTr 0x0e180611

#define BCM56800_A0_RDBGC7_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC7_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC7_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc7_select[1];
	uint32_t _rdbgc7_select;
} BCM56800_A0_RDBGC7_SELECTr_t;

#define BCM56800_A0_RDBGC7_SELECTr_CLR(r) (r).rdbgc7_select[0] = 0
#define BCM56800_A0_RDBGC7_SELECTr_SET(r,d) (r).rdbgc7_select[0] = d
#define BCM56800_A0_RDBGC7_SELECTr_GET(r) (r).rdbgc7_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC7_SELECTr_BITMAPf_GET(r) ((r).rdbgc7_select[0])
#define BCM56800_A0_RDBGC7_SELECTr_BITMAPf_SET(r,f) (r).rdbgc7_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC7_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC7_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC7_SELECTr,(r._rdbgc7_select))
#define BCM56800_A0_WRITE_RDBGC7_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC7_SELECTr,&(r._rdbgc7_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC7_SELECTr BCM56800_A0_RDBGC7_SELECTr
#define RDBGC7_SELECTr_SIZE BCM56800_A0_RDBGC7_SELECTr_SIZE
typedef BCM56800_A0_RDBGC7_SELECTr_t RDBGC7_SELECTr_t;
#define RDBGC7_SELECTr_CLR BCM56800_A0_RDBGC7_SELECTr_CLR
#define RDBGC7_SELECTr_SET BCM56800_A0_RDBGC7_SELECTr_SET
#define RDBGC7_SELECTr_GET BCM56800_A0_RDBGC7_SELECTr_GET
#define RDBGC7_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC7_SELECTr_BITMAPf_GET
#define RDBGC7_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC7_SELECTr_BITMAPf_SET
#define READ_RDBGC7_SELECTr BCM56800_A0_READ_RDBGC7_SELECTr
#define WRITE_RDBGC7_SELECTr BCM56800_A0_WRITE_RDBGC7_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC7_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC8
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #8
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC8r 0x0e10001b

#define BCM56800_A0_RDBGC8r_SIZE 4

/*
 * This structure should be used to declare and program RDBGC8.
 *
 */
typedef union BCM56800_A0_RDBGC8r_s {
	uint32_t v[1];
	uint32_t rdbgc8[1];
	uint32_t _rdbgc8;
} BCM56800_A0_RDBGC8r_t;

#define BCM56800_A0_RDBGC8r_CLR(r) (r).rdbgc8[0] = 0
#define BCM56800_A0_RDBGC8r_SET(r,d) (r).rdbgc8[0] = d
#define BCM56800_A0_RDBGC8r_GET(r) (r).rdbgc8[0]


/*
 * These macros can be used to access RDBGC8.
 *
 */
#define BCM56800_A0_READ_RDBGC8r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDBGC8r,(r._rdbgc8))
#define BCM56800_A0_WRITE_RDBGC8r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDBGC8r,&(r._rdbgc8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC8r BCM56800_A0_RDBGC8r
#define RDBGC8r_SIZE BCM56800_A0_RDBGC8r_SIZE
typedef BCM56800_A0_RDBGC8r_t RDBGC8r_t;
#define RDBGC8r_CLR BCM56800_A0_RDBGC8r_CLR
#define RDBGC8r_SET BCM56800_A0_RDBGC8r_SET
#define RDBGC8r_GET BCM56800_A0_RDBGC8r_GET
#define READ_RDBGC8r BCM56800_A0_READ_RDBGC8r
#define WRITE_RDBGC8r BCM56800_A0_WRITE_RDBGC8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDBGC8_SELECT
 * BLOCKS:   IPIPE
 * DESC:     Receive debug counter #8 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The RDBGC8_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_RDBGC8_SELECTr 0x0e180612

#define BCM56800_A0_RDBGC8_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program RDBGC8_SELECT.
 *
 */
typedef union BCM56800_A0_RDBGC8_SELECTr_s {
	uint32_t v[1];
	uint32_t rdbgc8_select[1];
	uint32_t _rdbgc8_select;
} BCM56800_A0_RDBGC8_SELECTr_t;

#define BCM56800_A0_RDBGC8_SELECTr_CLR(r) (r).rdbgc8_select[0] = 0
#define BCM56800_A0_RDBGC8_SELECTr_SET(r,d) (r).rdbgc8_select[0] = d
#define BCM56800_A0_RDBGC8_SELECTr_GET(r) (r).rdbgc8_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RDBGC8_SELECTr_BITMAPf_GET(r) ((r).rdbgc8_select[0])
#define BCM56800_A0_RDBGC8_SELECTr_BITMAPf_SET(r,f) (r).rdbgc8_select[0]=((uint32_t)f)

/*
 * These macros can be used to access RDBGC8_SELECT.
 *
 */
#define BCM56800_A0_READ_RDBGC8_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RDBGC8_SELECTr,(r._rdbgc8_select))
#define BCM56800_A0_WRITE_RDBGC8_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RDBGC8_SELECTr,&(r._rdbgc8_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDBGC8_SELECTr BCM56800_A0_RDBGC8_SELECTr
#define RDBGC8_SELECTr_SIZE BCM56800_A0_RDBGC8_SELECTr_SIZE
typedef BCM56800_A0_RDBGC8_SELECTr_t RDBGC8_SELECTr_t;
#define RDBGC8_SELECTr_CLR BCM56800_A0_RDBGC8_SELECTr_CLR
#define RDBGC8_SELECTr_SET BCM56800_A0_RDBGC8_SELECTr_SET
#define RDBGC8_SELECTr_GET BCM56800_A0_RDBGC8_SELECTr_GET
#define RDBGC8_SELECTr_BITMAPf_GET BCM56800_A0_RDBGC8_SELECTr_BITMAPf_GET
#define RDBGC8_SELECTr_BITMAPf_SET BCM56800_A0_RDBGC8_SELECTr_BITMAPf_SET
#define READ_RDBGC8_SELECTr BCM56800_A0_READ_RDBGC8_SELECTr
#define WRITE_RDBGC8_SELECTr BCM56800_A0_WRITE_RDBGC8_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDBGC8_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RDISC
 * BLOCKS:   IPIPE
 * DESC:     Receive Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RDISCr 0x0e100008

#define BCM56800_A0_RDISCr_SIZE 4

/*
 * This structure should be used to declare and program RDISC.
 *
 */
typedef union BCM56800_A0_RDISCr_s {
	uint32_t v[1];
	uint32_t rdisc[1];
	uint32_t _rdisc;
} BCM56800_A0_RDISCr_t;

#define BCM56800_A0_RDISCr_CLR(r) (r).rdisc[0] = 0
#define BCM56800_A0_RDISCr_SET(r,d) (r).rdisc[0] = d
#define BCM56800_A0_RDISCr_GET(r) (r).rdisc[0]


/*
 * These macros can be used to access RDISC.
 *
 */
#define BCM56800_A0_READ_RDISCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RDISCr,(r._rdisc))
#define BCM56800_A0_WRITE_RDISCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RDISCr,&(r._rdisc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RDISCr BCM56800_A0_RDISCr
#define RDISCr_SIZE BCM56800_A0_RDISCr_SIZE
typedef BCM56800_A0_RDISCr_t RDISCr_t;
#define RDISCr_CLR BCM56800_A0_RDISCr_CLR
#define RDISCr_SET BCM56800_A0_RDISCr_SET
#define RDISCr_GET BCM56800_A0_RDISCr_GET
#define READ_RDISCr BCM56800_A0_READ_RDISCr
#define WRITE_RDISCr BCM56800_A0_WRITE_RDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  REVCD
 * BLOCKS:   GXPORT
 * DESC:     Revision Info
 * SIZE:     32
 * FIELDS:
 *     REV              Revision Number
 *     MONTH            Revision Month
 *     YEAR             Revision Year
 *
 ******************************************************************************/
#define BCM56800_A0_REVCDr 0x00f0010b

#define BCM56800_A0_REVCDr_SIZE 4

/*
 * This structure should be used to declare and program REVCD.
 *
 */
typedef union BCM56800_A0_REVCDr_s {
	uint32_t v[1];
	uint32_t revcd[1];
	uint32_t _revcd;
} BCM56800_A0_REVCDr_t;

#define BCM56800_A0_REVCDr_CLR(r) (r).revcd[0] = 0
#define BCM56800_A0_REVCDr_SET(r,d) (r).revcd[0] = d
#define BCM56800_A0_REVCDr_GET(r) (r).revcd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_REVCDr_REVf_GET(r) (((r).revcd[0]) & 0xf)
#define BCM56800_A0_REVCDr_REVf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_REVCDr_MONTHf_GET(r) ((((r).revcd[0]) >> 4) & 0xf)
#define BCM56800_A0_REVCDr_MONTHf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_REVCDr_YEARf_GET(r) ((((r).revcd[0]) >> 8) & 0xff)
#define BCM56800_A0_REVCDr_YEARf_SET(r,f) (r).revcd[0]=(((r).revcd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access REVCD.
 *
 */
#define BCM56800_A0_READ_REVCDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_REVCDr,(r._revcd))
#define BCM56800_A0_WRITE_REVCDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_REVCDr,&(r._revcd))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define REVCDr BCM56800_A0_REVCDr
#define REVCDr_SIZE BCM56800_A0_REVCDr_SIZE
typedef BCM56800_A0_REVCDr_t REVCDr_t;
#define REVCDr_CLR BCM56800_A0_REVCDr_CLR
#define REVCDr_SET BCM56800_A0_REVCDr_SET
#define REVCDr_GET BCM56800_A0_REVCDr_GET
#define REVCDr_REVf_GET BCM56800_A0_REVCDr_REVf_GET
#define REVCDr_REVf_SET BCM56800_A0_REVCDr_REVf_SET
#define REVCDr_MONTHf_GET BCM56800_A0_REVCDr_MONTHf_GET
#define REVCDr_MONTHf_SET BCM56800_A0_REVCDr_MONTHf_SET
#define REVCDr_YEARf_GET BCM56800_A0_REVCDr_YEARf_GET
#define REVCDr_YEARf_SET BCM56800_A0_REVCDr_YEARf_SET
#define READ_REVCDr BCM56800_A0_READ_REVCDr
#define WRITE_REVCDr BCM56800_A0_WRITE_REVCDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_REVCDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RIPC4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 Unicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RIPC4r 0x0e100001

#define BCM56800_A0_RIPC4r_SIZE 4

/*
 * This structure should be used to declare and program RIPC4.
 *
 */
typedef union BCM56800_A0_RIPC4r_s {
	uint32_t v[1];
	uint32_t ripc4[1];
	uint32_t _ripc4;
} BCM56800_A0_RIPC4r_t;

#define BCM56800_A0_RIPC4r_CLR(r) (r).ripc4[0] = 0
#define BCM56800_A0_RIPC4r_SET(r,d) (r).ripc4[0] = d
#define BCM56800_A0_RIPC4r_GET(r) (r).ripc4[0]


/*
 * These macros can be used to access RIPC4.
 *
 */
#define BCM56800_A0_READ_RIPC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RIPC4r,(r._ripc4))
#define BCM56800_A0_WRITE_RIPC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RIPC4r,&(r._ripc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPC4r BCM56800_A0_RIPC4r
#define RIPC4r_SIZE BCM56800_A0_RIPC4r_SIZE
typedef BCM56800_A0_RIPC4r_t RIPC4r_t;
#define RIPC4r_CLR BCM56800_A0_RIPC4r_CLR
#define RIPC4r_SET BCM56800_A0_RIPC4r_SET
#define RIPC4r_GET BCM56800_A0_RIPC4r_GET
#define READ_RIPC4r BCM56800_A0_READ_RIPC4r
#define WRITE_RIPC4r BCM56800_A0_WRITE_RIPC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RIPC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RIPC6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 Unicast Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RIPC6r 0x0e100005

#define BCM56800_A0_RIPC6r_SIZE 4

/*
 * This structure should be used to declare and program RIPC6.
 *
 */
typedef union BCM56800_A0_RIPC6r_s {
	uint32_t v[1];
	uint32_t ripc6[1];
	uint32_t _ripc6;
} BCM56800_A0_RIPC6r_t;

#define BCM56800_A0_RIPC6r_CLR(r) (r).ripc6[0] = 0
#define BCM56800_A0_RIPC6r_SET(r,d) (r).ripc6[0] = d
#define BCM56800_A0_RIPC6r_GET(r) (r).ripc6[0]


/*
 * These macros can be used to access RIPC6.
 *
 */
#define BCM56800_A0_READ_RIPC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RIPC6r,(r._ripc6))
#define BCM56800_A0_WRITE_RIPC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RIPC6r,&(r._ripc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPC6r BCM56800_A0_RIPC6r
#define RIPC6r_SIZE BCM56800_A0_RIPC6r_SIZE
typedef BCM56800_A0_RIPC6r_t RIPC6r_t;
#define RIPC6r_CLR BCM56800_A0_RIPC6r_CLR
#define RIPC6r_SET BCM56800_A0_RIPC6r_SET
#define RIPC6r_GET BCM56800_A0_RIPC6r_GET
#define READ_RIPC6r BCM56800_A0_READ_RIPC6r
#define WRITE_RIPC6r BCM56800_A0_WRITE_RIPC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RIPC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RIPD4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RIPD4r 0x0e100000

#define BCM56800_A0_RIPD4r_SIZE 4

/*
 * This structure should be used to declare and program RIPD4.
 *
 */
typedef union BCM56800_A0_RIPD4r_s {
	uint32_t v[1];
	uint32_t ripd4[1];
	uint32_t _ripd4;
} BCM56800_A0_RIPD4r_t;

#define BCM56800_A0_RIPD4r_CLR(r) (r).ripd4[0] = 0
#define BCM56800_A0_RIPD4r_SET(r,d) (r).ripd4[0] = d
#define BCM56800_A0_RIPD4r_GET(r) (r).ripd4[0]


/*
 * These macros can be used to access RIPD4.
 *
 */
#define BCM56800_A0_READ_RIPD4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RIPD4r,(r._ripd4))
#define BCM56800_A0_WRITE_RIPD4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RIPD4r,&(r._ripd4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPD4r BCM56800_A0_RIPD4r
#define RIPD4r_SIZE BCM56800_A0_RIPD4r_SIZE
typedef BCM56800_A0_RIPD4r_t RIPD4r_t;
#define RIPD4r_CLR BCM56800_A0_RIPD4r_CLR
#define RIPD4r_SET BCM56800_A0_RIPD4r_SET
#define RIPD4r_GET BCM56800_A0_RIPD4r_GET
#define READ_RIPD4r BCM56800_A0_READ_RIPD4r
#define WRITE_RIPD4r BCM56800_A0_WRITE_RIPD4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RIPD4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RIPD6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 Discard Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RIPD6r 0x0e100004

#define BCM56800_A0_RIPD6r_SIZE 4

/*
 * This structure should be used to declare and program RIPD6.
 *
 */
typedef union BCM56800_A0_RIPD6r_s {
	uint32_t v[1];
	uint32_t ripd6[1];
	uint32_t _ripd6;
} BCM56800_A0_RIPD6r_t;

#define BCM56800_A0_RIPD6r_CLR(r) (r).ripd6[0] = 0
#define BCM56800_A0_RIPD6r_SET(r,d) (r).ripd6[0] = d
#define BCM56800_A0_RIPD6r_GET(r) (r).ripd6[0]


/*
 * These macros can be used to access RIPD6.
 *
 */
#define BCM56800_A0_READ_RIPD6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RIPD6r,(r._ripd6))
#define BCM56800_A0_WRITE_RIPD6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RIPD6r,&(r._ripd6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPD6r BCM56800_A0_RIPD6r
#define RIPD6r_SIZE BCM56800_A0_RIPD6r_SIZE
typedef BCM56800_A0_RIPD6r_t RIPD6r_t;
#define RIPD6r_CLR BCM56800_A0_RIPD6r_CLR
#define RIPD6r_SET BCM56800_A0_RIPD6r_SET
#define RIPD6r_GET BCM56800_A0_RIPD6r_GET
#define READ_RIPD6r BCM56800_A0_READ_RIPD6r
#define WRITE_RIPD6r BCM56800_A0_WRITE_RIPD6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RIPD6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RIPHE4
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv4 L3 IP Header Error Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RIPHE4r 0x0e100002

#define BCM56800_A0_RIPHE4r_SIZE 4

/*
 * This structure should be used to declare and program RIPHE4.
 *
 */
typedef union BCM56800_A0_RIPHE4r_s {
	uint32_t v[1];
	uint32_t riphe4[1];
	uint32_t _riphe4;
} BCM56800_A0_RIPHE4r_t;

#define BCM56800_A0_RIPHE4r_CLR(r) (r).riphe4[0] = 0
#define BCM56800_A0_RIPHE4r_SET(r,d) (r).riphe4[0] = d
#define BCM56800_A0_RIPHE4r_GET(r) (r).riphe4[0]


/*
 * These macros can be used to access RIPHE4.
 *
 */
#define BCM56800_A0_READ_RIPHE4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RIPHE4r,(r._riphe4))
#define BCM56800_A0_WRITE_RIPHE4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RIPHE4r,&(r._riphe4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPHE4r BCM56800_A0_RIPHE4r
#define RIPHE4r_SIZE BCM56800_A0_RIPHE4r_SIZE
typedef BCM56800_A0_RIPHE4r_t RIPHE4r_t;
#define RIPHE4r_CLR BCM56800_A0_RIPHE4r_CLR
#define RIPHE4r_SET BCM56800_A0_RIPHE4r_SET
#define RIPHE4r_GET BCM56800_A0_RIPHE4r_GET
#define READ_RIPHE4r BCM56800_A0_READ_RIPHE4r
#define WRITE_RIPHE4r BCM56800_A0_WRITE_RIPHE4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RIPHE4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RIPHE6
 * BLOCKS:   IPIPE
 * DESC:     Receive IPv6 L3 IP Header Error Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RIPHE6r 0x0e100006

#define BCM56800_A0_RIPHE6r_SIZE 4

/*
 * This structure should be used to declare and program RIPHE6.
 *
 */
typedef union BCM56800_A0_RIPHE6r_s {
	uint32_t v[1];
	uint32_t riphe6[1];
	uint32_t _riphe6;
} BCM56800_A0_RIPHE6r_t;

#define BCM56800_A0_RIPHE6r_CLR(r) (r).riphe6[0] = 0
#define BCM56800_A0_RIPHE6r_SET(r,d) (r).riphe6[0] = d
#define BCM56800_A0_RIPHE6r_GET(r) (r).riphe6[0]


/*
 * These macros can be used to access RIPHE6.
 *
 */
#define BCM56800_A0_READ_RIPHE6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RIPHE6r,(r._riphe6))
#define BCM56800_A0_WRITE_RIPHE6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RIPHE6r,&(r._riphe6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RIPHE6r BCM56800_A0_RIPHE6r
#define RIPHE6r_SIZE BCM56800_A0_RIPHE6r_SIZE
typedef BCM56800_A0_RIPHE6r_t RIPHE6r_t;
#define RIPHE6r_CLR BCM56800_A0_RIPHE6r_CLR
#define RIPHE6r_SET BCM56800_A0_RIPHE6r_SET
#define RIPHE6r_GET BCM56800_A0_RIPHE6r_GET
#define READ_RIPHE6r BCM56800_A0_READ_RIPHE6r
#define WRITE_RIPHE6r BCM56800_A0_WRITE_RIPHE6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RIPHE6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RPORTD
 * BLOCKS:   IPIPE
 * DESC:     PortInDiscard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RPORTDr 0x0e10000a

#define BCM56800_A0_RPORTDr_SIZE 4

/*
 * This structure should be used to declare and program RPORTD.
 *
 */
typedef union BCM56800_A0_RPORTDr_s {
	uint32_t v[1];
	uint32_t rportd[1];
	uint32_t _rportd;
} BCM56800_A0_RPORTDr_t;

#define BCM56800_A0_RPORTDr_CLR(r) (r).rportd[0] = 0
#define BCM56800_A0_RPORTDr_SET(r,d) (r).rportd[0] = d
#define BCM56800_A0_RPORTDr_GET(r) (r).rportd[0]


/*
 * These macros can be used to access RPORTD.
 *
 */
#define BCM56800_A0_READ_RPORTDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RPORTDr,(r._rportd))
#define BCM56800_A0_WRITE_RPORTDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RPORTDr,&(r._rportd))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RPORTDr BCM56800_A0_RPORTDr
#define RPORTDr_SIZE BCM56800_A0_RPORTDr_SIZE
typedef BCM56800_A0_RPORTDr_t RPORTDr_t;
#define RPORTDr_CLR BCM56800_A0_RPORTDr_CLR
#define RPORTDr_SET BCM56800_A0_RPORTDr_SET
#define RPORTDr_GET BCM56800_A0_RPORTDr_GET
#define READ_RPORTDr BCM56800_A0_READ_RPORTDr
#define WRITE_RPORTDr BCM56800_A0_WRITE_RPORTDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RPORTDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RRBYT
 * BLOCKS:   GXPORT
 * DESC:     Receive Runt Byte Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RRBYTr 0x00f00063

#define BCM56800_A0_RRBYTr_SIZE 4

/*
 * This structure should be used to declare and program RRBYT.
 *
 */
typedef union BCM56800_A0_RRBYTr_s {
	uint32_t v[1];
	uint32_t rrbyt[1];
	uint32_t _rrbyt;
} BCM56800_A0_RRBYTr_t;

#define BCM56800_A0_RRBYTr_CLR(r) (r).rrbyt[0] = 0
#define BCM56800_A0_RRBYTr_SET(r,d) (r).rrbyt[0] = d
#define BCM56800_A0_RRBYTr_GET(r) (r).rrbyt[0]


/*
 * These macros can be used to access RRBYT.
 *
 */
#define BCM56800_A0_READ_RRBYTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RRBYTr,(r._rrbyt))
#define BCM56800_A0_WRITE_RRBYTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RRBYTr,&(r._rrbyt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RRBYTr BCM56800_A0_RRBYTr
#define RRBYTr_SIZE BCM56800_A0_RRBYTr_SIZE
typedef BCM56800_A0_RRBYTr_t RRBYTr_t;
#define RRBYTr_CLR BCM56800_A0_RRBYTr_CLR
#define RRBYTr_SET BCM56800_A0_RRBYTr_SET
#define RRBYTr_GET BCM56800_A0_RRBYTr_GET
#define READ_RRBYTr BCM56800_A0_READ_RRBYTr
#define WRITE_RRBYTr BCM56800_A0_WRITE_RRBYTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RRBYTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RRPKT
 * BLOCKS:   GXPORT
 * DESC:     Receive RUNT Frame Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RRPKTr 0x00f00060

#define BCM56800_A0_RRPKTr_SIZE 4

/*
 * This structure should be used to declare and program RRPKT.
 *
 */
typedef union BCM56800_A0_RRPKTr_s {
	uint32_t v[1];
	uint32_t rrpkt[1];
	uint32_t _rrpkt;
} BCM56800_A0_RRPKTr_t;

#define BCM56800_A0_RRPKTr_CLR(r) (r).rrpkt[0] = 0
#define BCM56800_A0_RRPKTr_SET(r,d) (r).rrpkt[0] = d
#define BCM56800_A0_RRPKTr_GET(r) (r).rrpkt[0]


/*
 * These macros can be used to access RRPKT.
 *
 */
#define BCM56800_A0_READ_RRPKTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RRPKTr,(r._rrpkt))
#define BCM56800_A0_WRITE_RRPKTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RRPKTr,&(r._rrpkt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RRPKTr BCM56800_A0_RRPKTr
#define RRPKTr_SIZE BCM56800_A0_RRPKTr_SIZE
typedef BCM56800_A0_RRPKTr_t RRPKTr_t;
#define RRPKTr_CLR BCM56800_A0_RRPKTr_CLR
#define RRPKTr_SET BCM56800_A0_RRPKTr_SET
#define RRPKTr_GET BCM56800_A0_RRPKTr_GET
#define READ_RRPKTr BCM56800_A0_READ_RRPKTr
#define WRITE_RRPKTr BCM56800_A0_WRITE_RRPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RRPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RSV_READ
 * BLOCKS:   GXPORT
 * DESC:     MAC RSV (Receive Status Vector) debug register
 * SIZE:     32
 * FIELDS:
 *     ENABLE           Debug register, this provides a copy of the most recent RSV from the MAC to the core.
 *
 ******************************************************************************/
#define BCM56800_A0_RSV_READr 0x00f00304

#define BCM56800_A0_RSV_READr_SIZE 4

/*
 * This structure should be used to declare and program RSV_READ.
 *
 */
typedef union BCM56800_A0_RSV_READr_s {
	uint32_t v[1];
	uint32_t rsv_read[1];
	uint32_t _rsv_read;
} BCM56800_A0_RSV_READr_t;

#define BCM56800_A0_RSV_READr_CLR(r) (r).rsv_read[0] = 0
#define BCM56800_A0_RSV_READr_SET(r,d) (r).rsv_read[0] = d
#define BCM56800_A0_RSV_READr_GET(r) (r).rsv_read[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RSV_READr_ENABLEf_GET(r) (((r).rsv_read[0]) & 0x7fffffff)
#define BCM56800_A0_RSV_READr_ENABLEf_SET(r,f) (r).rsv_read[0]=(((r).rsv_read[0] & ~((uint32_t)0x7fffffff)) | (((uint32_t)f) & 0x7fffffff))

/*
 * These macros can be used to access RSV_READ.
 *
 */
#define BCM56800_A0_READ_RSV_READr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RSV_READr,(r._rsv_read))
#define BCM56800_A0_WRITE_RSV_READr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RSV_READr,&(r._rsv_read))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RSV_READr BCM56800_A0_RSV_READr
#define RSV_READr_SIZE BCM56800_A0_RSV_READr_SIZE
typedef BCM56800_A0_RSV_READr_t RSV_READr_t;
#define RSV_READr_CLR BCM56800_A0_RSV_READr_CLR
#define RSV_READr_SET BCM56800_A0_RSV_READr_SET
#define RSV_READr_GET BCM56800_A0_RSV_READr_GET
#define RSV_READr_ENABLEf_GET BCM56800_A0_RSV_READr_ENABLEf_GET
#define RSV_READr_ENABLEf_SET BCM56800_A0_RSV_READr_ENABLEf_SET
#define READ_RSV_READr BCM56800_A0_READ_RSV_READr
#define WRITE_RSV_READr BCM56800_A0_WRITE_RSV_READr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RSV_READr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Rtag7 hashing control register
 * SIZE:     32
 * FIELDS:
 *     HASH_MODE_A      Hash mode for Rtag7 hash A
 *     DISABLE_HASH_IPV4_A When set, hash selection for IPv4 pkts will default to Ethernet pkts for Rtag hash A.
 *     DISABLE_HASH_IPV6_A When set, hash selection for IPv6 pkts will default to Ethernet pkts for Rtag hash A.
 *     DISABLE_HASH_MPLS_A When set, hash selection for MPLS pkts will default to Ethernet pkts for Rtag hash A.
 *     DISABLE_HASH_INNER_IPV4_OVER_IPV4_A If set, disable hashing based on inner IPv4 pkt header for IPv4 over IPv4 pkts (outer ip.protocol = 4) for hash A.
 *     DISABLE_HASH_INNER_IPV6_OVER_IPV4_A If set, disable hashing based on inner IPv6 pkt header for IPv6 over IPv4 pkts (outer ip.protocol = 41) for hash A.
 *     DISABLE_HASH_INNER_IPV4_OVER_GRE_A If set, disable hashing based on inner IPv4 pkt header for IPv4 over GRE pkts (outer ip.protocol = 47) for hash A.
 *     DISABLE_HASH_INNER_IPV6_OVER_GRE_A If set, disable hashing based on inner IPv6 pkt header for IPv6 over GRE pkts (outer ip.protocol = 47) for hash A.
 *     HASH_MODE_B      Hash mode for Rtag7 hash B
 *     DISABLE_HASH_IPV4_B When set, hash selection for IPv4 pkts will default to Ethernet pkts for Rtag hash B.
 *     DISABLE_HASH_IPV6_B When set, hash selection for IPv6 pkts will default to Ethernet pkts for Rtag hash B.
 *     DISABLE_HASH_MPLS_B When set, hash selection for MPLS pkts will default to Ethernet pkts for Rtag hash B.
 *     DISABLE_HASH_INNER_IPV4_OVER_IPV4_B If set, disable hashing based on inner IPv4 pkt header for IPv4 over IPv4 pkts (outer ip.protocol = 4) for hash B.
 *     DISABLE_HASH_INNER_IPV6_OVER_IPV4_B If set, disable hashing based on inner IPv6 pkt header for IPv6 over IPv4 pkts (outer ip.protocol = 41) for hash B.
 *     DISABLE_HASH_INNER_IPV4_OVER_GRE_B If set, disable hashing based on inner IPv4 pkt header for IPv4 over GRE pkts (outer ip.protocol = 47) for hash B.
 *     DISABLE_HASH_INNER_IPV6_OVER_GRE_B If set, disable hashing based on inner IPv6 pkt header for IPv6 over GRE pkts (outer ip.protocol = 47) for hash B.
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_CONTROLr 0x0218062b

#define BCM56800_A0_RTAG7_HASH_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_CONTROL.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_CONTROLr_s {
	uint32_t v[1];
	uint32_t rtag7_hash_control[1];
	uint32_t _rtag7_hash_control;
} BCM56800_A0_RTAG7_HASH_CONTROLr_t;

#define BCM56800_A0_RTAG7_HASH_CONTROLr_CLR(r) (r).rtag7_hash_control[0] = 0
#define BCM56800_A0_RTAG7_HASH_CONTROLr_SET(r,d) (r).rtag7_hash_control[0] = d
#define BCM56800_A0_RTAG7_HASH_CONTROLr_GET(r) (r).rtag7_hash_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_CONTROLr_HASH_MODE_Af_GET(r) (((r).rtag7_hash_control[0]) & 0x7)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_HASH_MODE_Af_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Af_GET(r) ((((r).rtag7_hash_control[0]) >> 3) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Af_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Af_GET(r) ((((r).rtag7_hash_control[0]) >> 4) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Af_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Af_GET(r) ((((r).rtag7_hash_control[0]) >> 5) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Af_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Af_GET(r) ((((r).rtag7_hash_control[0]) >> 6) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Af_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Af_GET(r) ((((r).rtag7_hash_control[0]) >> 7) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Af_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Af_GET(r) ((((r).rtag7_hash_control[0]) >> 8) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Af_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Af_GET(r) ((((r).rtag7_hash_control[0]) >> 9) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Af_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_HASH_MODE_Bf_GET(r) ((((r).rtag7_hash_control[0]) >> 10) & 0x7)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_HASH_MODE_Bf_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Bf_GET(r) ((((r).rtag7_hash_control[0]) >> 13) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Bf_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Bf_GET(r) ((((r).rtag7_hash_control[0]) >> 14) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Bf_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Bf_GET(r) ((((r).rtag7_hash_control[0]) >> 15) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Bf_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Bf_GET(r) ((((r).rtag7_hash_control[0]) >> 16) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Bf_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Bf_GET(r) ((((r).rtag7_hash_control[0]) >> 17) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Bf_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Bf_GET(r) ((((r).rtag7_hash_control[0]) >> 18) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Bf_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Bf_GET(r) ((((r).rtag7_hash_control[0]) >> 19) & 0x1)
#define BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Bf_SET(r,f) (r).rtag7_hash_control[0]=(((r).rtag7_hash_control[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access RTAG7_HASH_CONTROL.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_CONTROLr,(r._rtag7_hash_control))
#define BCM56800_A0_WRITE_RTAG7_HASH_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_CONTROLr,&(r._rtag7_hash_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_CONTROLr BCM56800_A0_RTAG7_HASH_CONTROLr
#define RTAG7_HASH_CONTROLr_SIZE BCM56800_A0_RTAG7_HASH_CONTROLr_SIZE
typedef BCM56800_A0_RTAG7_HASH_CONTROLr_t RTAG7_HASH_CONTROLr_t;
#define RTAG7_HASH_CONTROLr_CLR BCM56800_A0_RTAG7_HASH_CONTROLr_CLR
#define RTAG7_HASH_CONTROLr_SET BCM56800_A0_RTAG7_HASH_CONTROLr_SET
#define RTAG7_HASH_CONTROLr_GET BCM56800_A0_RTAG7_HASH_CONTROLr_GET
#define RTAG7_HASH_CONTROLr_HASH_MODE_Af_GET BCM56800_A0_RTAG7_HASH_CONTROLr_HASH_MODE_Af_GET
#define RTAG7_HASH_CONTROLr_HASH_MODE_Af_SET BCM56800_A0_RTAG7_HASH_CONTROLr_HASH_MODE_Af_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Af_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Af_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Af_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Af_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Af_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Af_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Af_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Af_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Af_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Af_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Af_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Af_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Af_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Af_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Af_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Af_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Af_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Af_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Af_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Af_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Af_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Af_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Af_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Af_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Af_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Af_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Af_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Af_SET
#define RTAG7_HASH_CONTROLr_HASH_MODE_Bf_GET BCM56800_A0_RTAG7_HASH_CONTROLr_HASH_MODE_Bf_GET
#define RTAG7_HASH_CONTROLr_HASH_MODE_Bf_SET BCM56800_A0_RTAG7_HASH_CONTROLr_HASH_MODE_Bf_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Bf_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Bf_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Bf_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV4_Bf_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Bf_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Bf_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Bf_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_IPV6_Bf_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Bf_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Bf_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Bf_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_MPLS_Bf_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Bf_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Bf_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Bf_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_IPV4_Bf_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Bf_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Bf_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Bf_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_IPV4_Bf_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Bf_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Bf_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Bf_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV4_OVER_GRE_Bf_SET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Bf_GET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Bf_GET
#define RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Bf_SET BCM56800_A0_RTAG7_HASH_CONTROLr_DISABLE_HASH_INNER_IPV6_OVER_GRE_Bf_SET
#define READ_RTAG7_HASH_CONTROLr BCM56800_A0_READ_RTAG7_HASH_CONTROLr
#define WRITE_RTAG7_HASH_CONTROLr BCM56800_A0_WRITE_RTAG7_HASH_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_ECMP
 * BLOCKS:   IPIPE
 * DESC:     RTAG7 hash control register for ECMP
 * SIZE:     32
 * FIELDS:
 *     SUB_SEL          Hash subset selection for rtag7.
 *     OFFSET           Offset of LSB for picking the hash value from the subset selected.
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_ECMPr 0x0d180602

#define BCM56800_A0_RTAG7_HASH_ECMPr_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_ECMP.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_ECMPr_s {
	uint32_t v[1];
	uint32_t rtag7_hash_ecmp[1];
	uint32_t _rtag7_hash_ecmp;
} BCM56800_A0_RTAG7_HASH_ECMPr_t;

#define BCM56800_A0_RTAG7_HASH_ECMPr_CLR(r) (r).rtag7_hash_ecmp[0] = 0
#define BCM56800_A0_RTAG7_HASH_ECMPr_SET(r,d) (r).rtag7_hash_ecmp[0] = d
#define BCM56800_A0_RTAG7_HASH_ECMPr_GET(r) (r).rtag7_hash_ecmp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_ECMPr_SUB_SELf_GET(r) (((r).rtag7_hash_ecmp[0]) & 0x7)
#define BCM56800_A0_RTAG7_HASH_ECMPr_SUB_SELf_SET(r,f) (r).rtag7_hash_ecmp[0]=(((r).rtag7_hash_ecmp[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_RTAG7_HASH_ECMPr_OFFSETf_GET(r) ((((r).rtag7_hash_ecmp[0]) >> 3) & 0xf)
#define BCM56800_A0_RTAG7_HASH_ECMPr_OFFSETf_SET(r,f) (r).rtag7_hash_ecmp[0]=(((r).rtag7_hash_ecmp[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))

/*
 * These macros can be used to access RTAG7_HASH_ECMP.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_ECMPr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_ECMPr+(i),(r._rtag7_hash_ecmp))
#define BCM56800_A0_WRITE_RTAG7_HASH_ECMPr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_ECMPr+(i),&(r._rtag7_hash_ecmp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_ECMPr BCM56800_A0_RTAG7_HASH_ECMPr
#define RTAG7_HASH_ECMPr_SIZE BCM56800_A0_RTAG7_HASH_ECMPr_SIZE
typedef BCM56800_A0_RTAG7_HASH_ECMPr_t RTAG7_HASH_ECMPr_t;
#define RTAG7_HASH_ECMPr_CLR BCM56800_A0_RTAG7_HASH_ECMPr_CLR
#define RTAG7_HASH_ECMPr_SET BCM56800_A0_RTAG7_HASH_ECMPr_SET
#define RTAG7_HASH_ECMPr_GET BCM56800_A0_RTAG7_HASH_ECMPr_GET
#define RTAG7_HASH_ECMPr_SUB_SELf_GET BCM56800_A0_RTAG7_HASH_ECMPr_SUB_SELf_GET
#define RTAG7_HASH_ECMPr_SUB_SELf_SET BCM56800_A0_RTAG7_HASH_ECMPr_SUB_SELf_SET
#define RTAG7_HASH_ECMPr_OFFSETf_GET BCM56800_A0_RTAG7_HASH_ECMPr_OFFSETf_GET
#define RTAG7_HASH_ECMPr_OFFSETf_SET BCM56800_A0_RTAG7_HASH_ECMPr_OFFSETf_SET
#define READ_RTAG7_HASH_ECMPr BCM56800_A0_READ_RTAG7_HASH_ECMPr
#define WRITE_RTAG7_HASH_ECMPr BCM56800_A0_WRITE_RTAG7_HASH_ECMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_ECMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_FIELD_BMAP_1
 * BLOCKS:   IPIPE
 * DESC:     Rtag7 hashing field selection bitmap register1
 * SIZE:     32
 * FIELDS:
 *     IPV4_FIELD_BITMAP_A Hash field selection for IPv4 pkts for hash A
 *     IPV4_FIELD_BITMAP_B Hash field selection for IPv4 pkts for hash B
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r 0x02180624

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_FIELD_BMAP_1.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_s {
	uint32_t v[1];
	uint32_t rtag7_hash_field_bmap_1[1];
	uint32_t _rtag7_hash_field_bmap_1;
} BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_t;

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_CLR(r) (r).rtag7_hash_field_bmap_1[0] = 0
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_SET(r,d) (r).rtag7_hash_field_bmap_1[0] = d
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_GET(r) (r).rtag7_hash_field_bmap_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Af_GET(r) (((r).rtag7_hash_field_bmap_1[0]) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Af_SET(r,f) (r).rtag7_hash_field_bmap_1[0]=(((r).rtag7_hash_field_bmap_1[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Bf_GET(r) ((((r).rtag7_hash_field_bmap_1[0]) >> 12) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Bf_SET(r,f) (r).rtag7_hash_field_bmap_1[0]=(((r).rtag7_hash_field_bmap_1[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access RTAG7_HASH_FIELD_BMAP_1.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r,(r._rtag7_hash_field_bmap_1))
#define BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r,&(r._rtag7_hash_field_bmap_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_FIELD_BMAP_1r BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r
#define RTAG7_HASH_FIELD_BMAP_1r_SIZE BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_SIZE
typedef BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_t RTAG7_HASH_FIELD_BMAP_1r_t;
#define RTAG7_HASH_FIELD_BMAP_1r_CLR BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_CLR
#define RTAG7_HASH_FIELD_BMAP_1r_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_SET
#define RTAG7_HASH_FIELD_BMAP_1r_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_GET
#define RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Af_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Af_GET
#define RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Af_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Af_SET
#define RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Bf_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Bf_GET
#define RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Bf_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r_IPV4_FIELD_BITMAP_Bf_SET
#define READ_RTAG7_HASH_FIELD_BMAP_1r BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_1r
#define WRITE_RTAG7_HASH_FIELD_BMAP_1r BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_FIELD_BMAP_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_FIELD_BMAP_2
 * BLOCKS:   IPIPE
 * DESC:     Rtag7 hashing field selection bitmap register2
 * SIZE:     32
 * FIELDS:
 *     IPV6_FIELD_BITMAP_A Hash field selection for IPv6 pkts for hash A
 *     IPV6_FIELD_BITMAP_B Hash field selection for IPv6 pkts for hash B
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r 0x02180625

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_FIELD_BMAP_2.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_s {
	uint32_t v[1];
	uint32_t rtag7_hash_field_bmap_2[1];
	uint32_t _rtag7_hash_field_bmap_2;
} BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_t;

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_CLR(r) (r).rtag7_hash_field_bmap_2[0] = 0
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_SET(r,d) (r).rtag7_hash_field_bmap_2[0] = d
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_GET(r) (r).rtag7_hash_field_bmap_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Af_GET(r) (((r).rtag7_hash_field_bmap_2[0]) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Af_SET(r,f) (r).rtag7_hash_field_bmap_2[0]=(((r).rtag7_hash_field_bmap_2[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Bf_GET(r) ((((r).rtag7_hash_field_bmap_2[0]) >> 12) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Bf_SET(r,f) (r).rtag7_hash_field_bmap_2[0]=(((r).rtag7_hash_field_bmap_2[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access RTAG7_HASH_FIELD_BMAP_2.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r,(r._rtag7_hash_field_bmap_2))
#define BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r,&(r._rtag7_hash_field_bmap_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_FIELD_BMAP_2r BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r
#define RTAG7_HASH_FIELD_BMAP_2r_SIZE BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_SIZE
typedef BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_t RTAG7_HASH_FIELD_BMAP_2r_t;
#define RTAG7_HASH_FIELD_BMAP_2r_CLR BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_CLR
#define RTAG7_HASH_FIELD_BMAP_2r_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_SET
#define RTAG7_HASH_FIELD_BMAP_2r_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_GET
#define RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Af_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Af_GET
#define RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Af_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Af_SET
#define RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Bf_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Bf_GET
#define RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Bf_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r_IPV6_FIELD_BITMAP_Bf_SET
#define READ_RTAG7_HASH_FIELD_BMAP_2r BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_2r
#define WRITE_RTAG7_HASH_FIELD_BMAP_2r BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_FIELD_BMAP_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_FIELD_BMAP_3
 * BLOCKS:   IPIPE
 * DESC:     Rtag7 hashing field selection bitmap register3
 * SIZE:     32
 * FIELDS:
 *     L2_FIELD_BITMAP_A Hash field selection for non-IP L2 pkts for hash A
 *     L2_FIELD_BITMAP_B Hash field selection for non-IP L2 pkts for hash B
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r 0x02180626

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_FIELD_BMAP_3.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_s {
	uint32_t v[1];
	uint32_t rtag7_hash_field_bmap_3[1];
	uint32_t _rtag7_hash_field_bmap_3;
} BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_t;

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_CLR(r) (r).rtag7_hash_field_bmap_3[0] = 0
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_SET(r,d) (r).rtag7_hash_field_bmap_3[0] = d
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_GET(r) (r).rtag7_hash_field_bmap_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Af_GET(r) (((r).rtag7_hash_field_bmap_3[0]) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Af_SET(r,f) (r).rtag7_hash_field_bmap_3[0]=(((r).rtag7_hash_field_bmap_3[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Bf_GET(r) ((((r).rtag7_hash_field_bmap_3[0]) >> 12) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Bf_SET(r,f) (r).rtag7_hash_field_bmap_3[0]=(((r).rtag7_hash_field_bmap_3[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access RTAG7_HASH_FIELD_BMAP_3.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_3r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r,(r._rtag7_hash_field_bmap_3))
#define BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_3r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r,&(r._rtag7_hash_field_bmap_3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_FIELD_BMAP_3r BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r
#define RTAG7_HASH_FIELD_BMAP_3r_SIZE BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_SIZE
typedef BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_t RTAG7_HASH_FIELD_BMAP_3r_t;
#define RTAG7_HASH_FIELD_BMAP_3r_CLR BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_CLR
#define RTAG7_HASH_FIELD_BMAP_3r_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_SET
#define RTAG7_HASH_FIELD_BMAP_3r_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_GET
#define RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Af_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Af_GET
#define RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Af_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Af_SET
#define RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Bf_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Bf_GET
#define RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Bf_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r_L2_FIELD_BITMAP_Bf_SET
#define READ_RTAG7_HASH_FIELD_BMAP_3r BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_3r
#define WRITE_RTAG7_HASH_FIELD_BMAP_3r BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_FIELD_BMAP_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_FIELD_BMAP_4
 * BLOCKS:   IPIPE
 * DESC:     Rtag7 hashing field selection bitmap register4
 * SIZE:     32
 * FIELDS:
 *     MPLS_FIELD_BITMAP_A Hash field selection for MPLS pkts for hash A
 *     MPLS_FIELD_BITMAP_B Hash field selection for MPLS pkts for hash B
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r 0x02180627

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_FIELD_BMAP_4.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_s {
	uint32_t v[1];
	uint32_t rtag7_hash_field_bmap_4[1];
	uint32_t _rtag7_hash_field_bmap_4;
} BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_t;

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_CLR(r) (r).rtag7_hash_field_bmap_4[0] = 0
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_SET(r,d) (r).rtag7_hash_field_bmap_4[0] = d
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_GET(r) (r).rtag7_hash_field_bmap_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Af_GET(r) (((r).rtag7_hash_field_bmap_4[0]) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Af_SET(r,f) (r).rtag7_hash_field_bmap_4[0]=(((r).rtag7_hash_field_bmap_4[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Bf_GET(r) ((((r).rtag7_hash_field_bmap_4[0]) >> 12) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Bf_SET(r,f) (r).rtag7_hash_field_bmap_4[0]=(((r).rtag7_hash_field_bmap_4[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access RTAG7_HASH_FIELD_BMAP_4.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_4r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r,(r._rtag7_hash_field_bmap_4))
#define BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_4r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r,&(r._rtag7_hash_field_bmap_4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_FIELD_BMAP_4r BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r
#define RTAG7_HASH_FIELD_BMAP_4r_SIZE BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_SIZE
typedef BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_t RTAG7_HASH_FIELD_BMAP_4r_t;
#define RTAG7_HASH_FIELD_BMAP_4r_CLR BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_CLR
#define RTAG7_HASH_FIELD_BMAP_4r_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_SET
#define RTAG7_HASH_FIELD_BMAP_4r_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_GET
#define RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Af_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Af_GET
#define RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Af_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Af_SET
#define RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Bf_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Bf_GET
#define RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Bf_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r_MPLS_FIELD_BITMAP_Bf_SET
#define READ_RTAG7_HASH_FIELD_BMAP_4r BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_4r
#define WRITE_RTAG7_HASH_FIELD_BMAP_4r BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_FIELD_BMAP_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_FIELD_BMAP_5
 * BLOCKS:   IPIPE
 * DESC:     Rtag7 hashing field selection bitmap register5
 * SIZE:     32
 * FIELDS:
 *     UNKNOWN_PPD_FIELD_BITMAP_A Hash field selection for HiGig2 pkts with unkonwn PPD type (unknown hdr type) for hash A
 *     UNKNOWN_PPD_FIELD_BITMAP_B Hash field selection for HiGig2 pkts with unkonwn PPD type (unknown hdr type) for hash B
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r 0x02180628

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_FIELD_BMAP_5.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_s {
	uint32_t v[1];
	uint32_t rtag7_hash_field_bmap_5[1];
	uint32_t _rtag7_hash_field_bmap_5;
} BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_t;

#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_CLR(r) (r).rtag7_hash_field_bmap_5[0] = 0
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_SET(r,d) (r).rtag7_hash_field_bmap_5[0] = d
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_GET(r) (r).rtag7_hash_field_bmap_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Af_GET(r) (((r).rtag7_hash_field_bmap_5[0]) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Af_SET(r,f) (r).rtag7_hash_field_bmap_5[0]=(((r).rtag7_hash_field_bmap_5[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Bf_GET(r) ((((r).rtag7_hash_field_bmap_5[0]) >> 12) & 0xfff)
#define BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Bf_SET(r,f) (r).rtag7_hash_field_bmap_5[0]=(((r).rtag7_hash_field_bmap_5[0] & ~((uint32_t)0xfff << 12)) | ((((uint32_t)f) & 0xfff) << 12))

/*
 * These macros can be used to access RTAG7_HASH_FIELD_BMAP_5.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_5r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r,(r._rtag7_hash_field_bmap_5))
#define BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_5r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r,&(r._rtag7_hash_field_bmap_5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_FIELD_BMAP_5r BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r
#define RTAG7_HASH_FIELD_BMAP_5r_SIZE BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_SIZE
typedef BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_t RTAG7_HASH_FIELD_BMAP_5r_t;
#define RTAG7_HASH_FIELD_BMAP_5r_CLR BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_CLR
#define RTAG7_HASH_FIELD_BMAP_5r_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_SET
#define RTAG7_HASH_FIELD_BMAP_5r_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_GET
#define RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Af_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Af_GET
#define RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Af_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Af_SET
#define RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Bf_GET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Bf_GET
#define RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Bf_SET BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r_UNKNOWN_PPD_FIELD_BITMAP_Bf_SET
#define READ_RTAG7_HASH_FIELD_BMAP_5r BCM56800_A0_READ_RTAG7_HASH_FIELD_BMAP_5r
#define WRITE_RTAG7_HASH_FIELD_BMAP_5r BCM56800_A0_WRITE_RTAG7_HASH_FIELD_BMAP_5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_FIELD_BMAP_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_HG_TRUNK
 * BLOCKS:   IPIPE
 * DESC:     RTAG7 hash control register for Higig trunking
 * SIZE:     32
 * FIELDS:
 *     SUB_SEL_UC       Hash subfield selector for unicast HiGig trunking
 *     OFFSET_UC        The offset of the hash value for unicast HiGig trunking.
 *     SUB_SEL_NONUC    Hash subfield selector for non-unicast HiGig trunking
 *     OFFSET_NONUC     The offset of the hash value for non-unicast HiGig trunking.
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr 0x0e18063c

#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_HG_TRUNK.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_HG_TRUNKr_s {
	uint32_t v[1];
	uint32_t rtag7_hash_hg_trunk[1];
	uint32_t _rtag7_hash_hg_trunk;
} BCM56800_A0_RTAG7_HASH_HG_TRUNKr_t;

#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_CLR(r) (r).rtag7_hash_hg_trunk[0] = 0
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SET(r,d) (r).rtag7_hash_hg_trunk[0] = d
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_GET(r) (r).rtag7_hash_hg_trunk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SUB_SEL_UCf_GET(r) (((r).rtag7_hash_hg_trunk[0]) & 0x7)
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SUB_SEL_UCf_SET(r,f) (r).rtag7_hash_hg_trunk[0]=(((r).rtag7_hash_hg_trunk[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_OFFSET_UCf_GET(r) ((((r).rtag7_hash_hg_trunk[0]) >> 3) & 0xf)
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_OFFSET_UCf_SET(r,f) (r).rtag7_hash_hg_trunk[0]=(((r).rtag7_hash_hg_trunk[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SUB_SEL_NONUCf_GET(r) ((((r).rtag7_hash_hg_trunk[0]) >> 7) & 0x7)
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SUB_SEL_NONUCf_SET(r,f) (r).rtag7_hash_hg_trunk[0]=(((r).rtag7_hash_hg_trunk[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_OFFSET_NONUCf_GET(r) ((((r).rtag7_hash_hg_trunk[0]) >> 10) & 0xf)
#define BCM56800_A0_RTAG7_HASH_HG_TRUNKr_OFFSET_NONUCf_SET(r,f) (r).rtag7_hash_hg_trunk[0]=(((r).rtag7_hash_hg_trunk[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))

/*
 * These macros can be used to access RTAG7_HASH_HG_TRUNK.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_HG_TRUNKr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_HG_TRUNKr+(i),(r._rtag7_hash_hg_trunk))
#define BCM56800_A0_WRITE_RTAG7_HASH_HG_TRUNKr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_HG_TRUNKr+(i),&(r._rtag7_hash_hg_trunk))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_HG_TRUNKr BCM56800_A0_RTAG7_HASH_HG_TRUNKr
#define RTAG7_HASH_HG_TRUNKr_SIZE BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SIZE
typedef BCM56800_A0_RTAG7_HASH_HG_TRUNKr_t RTAG7_HASH_HG_TRUNKr_t;
#define RTAG7_HASH_HG_TRUNKr_CLR BCM56800_A0_RTAG7_HASH_HG_TRUNKr_CLR
#define RTAG7_HASH_HG_TRUNKr_SET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SET
#define RTAG7_HASH_HG_TRUNKr_GET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_GET
#define RTAG7_HASH_HG_TRUNKr_SUB_SEL_UCf_GET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SUB_SEL_UCf_GET
#define RTAG7_HASH_HG_TRUNKr_SUB_SEL_UCf_SET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SUB_SEL_UCf_SET
#define RTAG7_HASH_HG_TRUNKr_OFFSET_UCf_GET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_OFFSET_UCf_GET
#define RTAG7_HASH_HG_TRUNKr_OFFSET_UCf_SET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_OFFSET_UCf_SET
#define RTAG7_HASH_HG_TRUNKr_SUB_SEL_NONUCf_GET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SUB_SEL_NONUCf_GET
#define RTAG7_HASH_HG_TRUNKr_SUB_SEL_NONUCf_SET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_SUB_SEL_NONUCf_SET
#define RTAG7_HASH_HG_TRUNKr_OFFSET_NONUCf_GET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_OFFSET_NONUCf_GET
#define RTAG7_HASH_HG_TRUNKr_OFFSET_NONUCf_SET BCM56800_A0_RTAG7_HASH_HG_TRUNKr_OFFSET_NONUCf_SET
#define READ_RTAG7_HASH_HG_TRUNKr BCM56800_A0_READ_RTAG7_HASH_HG_TRUNKr
#define WRITE_RTAG7_HASH_HG_TRUNKr BCM56800_A0_WRITE_RTAG7_HASH_HG_TRUNKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_HG_TRUNKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_HG_TRUNK_FAILOVER
 * BLOCKS:   IPIPE
 * DESC:     RTAG7 hash control register for Higig trunk failover
 * SIZE:     32
 * FIELDS:
 *     SUB_SEL          Hash subfield selector
 *     OFFSET           The offset of the hash value for Higig trunk failover.
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr 0x0e18063f

#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_HG_TRUNK_FAILOVER.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_s {
	uint32_t v[1];
	uint32_t rtag7_hash_hg_trunk_failover[1];
	uint32_t _rtag7_hash_hg_trunk_failover;
} BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_t;

#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_CLR(r) (r).rtag7_hash_hg_trunk_failover[0] = 0
#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_SET(r,d) (r).rtag7_hash_hg_trunk_failover[0] = d
#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_GET(r) (r).rtag7_hash_hg_trunk_failover[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_SUB_SELf_GET(r) (((r).rtag7_hash_hg_trunk_failover[0]) & 0x7)
#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_SUB_SELf_SET(r,f) (r).rtag7_hash_hg_trunk_failover[0]=(((r).rtag7_hash_hg_trunk_failover[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_OFFSETf_GET(r) ((((r).rtag7_hash_hg_trunk_failover[0]) >> 3) & 0xf)
#define BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_OFFSETf_SET(r,f) (r).rtag7_hash_hg_trunk_failover[0]=(((r).rtag7_hash_hg_trunk_failover[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))

/*
 * These macros can be used to access RTAG7_HASH_HG_TRUNK_FAILOVER.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_HG_TRUNK_FAILOVERr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr,(r._rtag7_hash_hg_trunk_failover))
#define BCM56800_A0_WRITE_RTAG7_HASH_HG_TRUNK_FAILOVERr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr,&(r._rtag7_hash_hg_trunk_failover))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_HG_TRUNK_FAILOVERr BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr
#define RTAG7_HASH_HG_TRUNK_FAILOVERr_SIZE BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_SIZE
typedef BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_t RTAG7_HASH_HG_TRUNK_FAILOVERr_t;
#define RTAG7_HASH_HG_TRUNK_FAILOVERr_CLR BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_CLR
#define RTAG7_HASH_HG_TRUNK_FAILOVERr_SET BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_SET
#define RTAG7_HASH_HG_TRUNK_FAILOVERr_GET BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_GET
#define RTAG7_HASH_HG_TRUNK_FAILOVERr_SUB_SELf_GET BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_SUB_SELf_GET
#define RTAG7_HASH_HG_TRUNK_FAILOVERr_SUB_SELf_SET BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_SUB_SELf_SET
#define RTAG7_HASH_HG_TRUNK_FAILOVERr_OFFSETf_GET BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_OFFSETf_GET
#define RTAG7_HASH_HG_TRUNK_FAILOVERr_OFFSETf_SET BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr_OFFSETf_SET
#define READ_RTAG7_HASH_HG_TRUNK_FAILOVERr BCM56800_A0_READ_RTAG7_HASH_HG_TRUNK_FAILOVERr
#define WRITE_RTAG7_HASH_HG_TRUNK_FAILOVERr BCM56800_A0_WRITE_RTAG7_HASH_HG_TRUNK_FAILOVERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_HG_TRUNK_FAILOVERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_LBID
 * BLOCKS:   IPIPE
 * DESC:     RTAG7 hash control register for LBID selection
 * SIZE:     32
 * FIELDS:
 *     SUB_SEL_UC       Hash subset selection rtag7 for unicast pkts.
 *     OFFSET_UC        Offset of LSB for picking the hash value, for unicast pkts, from the subset selected
 *     SUB_SEL_NONUC    Hash subset selection rtag7 for non-unicast pkts
 *     OFFSET_NONUC     Offset of LSB for picking the hash value, for non-unicast pkts, from the subset selected
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_LBIDr 0x0b18060a

#define BCM56800_A0_RTAG7_HASH_LBIDr_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_LBID.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_LBIDr_s {
	uint32_t v[1];
	uint32_t rtag7_hash_lbid[1];
	uint32_t _rtag7_hash_lbid;
} BCM56800_A0_RTAG7_HASH_LBIDr_t;

#define BCM56800_A0_RTAG7_HASH_LBIDr_CLR(r) (r).rtag7_hash_lbid[0] = 0
#define BCM56800_A0_RTAG7_HASH_LBIDr_SET(r,d) (r).rtag7_hash_lbid[0] = d
#define BCM56800_A0_RTAG7_HASH_LBIDr_GET(r) (r).rtag7_hash_lbid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_LBIDr_SUB_SEL_UCf_GET(r) (((r).rtag7_hash_lbid[0]) & 0x7)
#define BCM56800_A0_RTAG7_HASH_LBIDr_SUB_SEL_UCf_SET(r,f) (r).rtag7_hash_lbid[0]=(((r).rtag7_hash_lbid[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_RTAG7_HASH_LBIDr_OFFSET_UCf_GET(r) ((((r).rtag7_hash_lbid[0]) >> 3) & 0xf)
#define BCM56800_A0_RTAG7_HASH_LBIDr_OFFSET_UCf_SET(r,f) (r).rtag7_hash_lbid[0]=(((r).rtag7_hash_lbid[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM56800_A0_RTAG7_HASH_LBIDr_SUB_SEL_NONUCf_GET(r) ((((r).rtag7_hash_lbid[0]) >> 7) & 0x7)
#define BCM56800_A0_RTAG7_HASH_LBIDr_SUB_SEL_NONUCf_SET(r,f) (r).rtag7_hash_lbid[0]=(((r).rtag7_hash_lbid[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56800_A0_RTAG7_HASH_LBIDr_OFFSET_NONUCf_GET(r) ((((r).rtag7_hash_lbid[0]) >> 10) & 0xf)
#define BCM56800_A0_RTAG7_HASH_LBIDr_OFFSET_NONUCf_SET(r,f) (r).rtag7_hash_lbid[0]=(((r).rtag7_hash_lbid[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))

/*
 * These macros can be used to access RTAG7_HASH_LBID.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_LBIDr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_LBIDr+(i),(r._rtag7_hash_lbid))
#define BCM56800_A0_WRITE_RTAG7_HASH_LBIDr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_LBIDr+(i),&(r._rtag7_hash_lbid))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_LBIDr BCM56800_A0_RTAG7_HASH_LBIDr
#define RTAG7_HASH_LBIDr_SIZE BCM56800_A0_RTAG7_HASH_LBIDr_SIZE
typedef BCM56800_A0_RTAG7_HASH_LBIDr_t RTAG7_HASH_LBIDr_t;
#define RTAG7_HASH_LBIDr_CLR BCM56800_A0_RTAG7_HASH_LBIDr_CLR
#define RTAG7_HASH_LBIDr_SET BCM56800_A0_RTAG7_HASH_LBIDr_SET
#define RTAG7_HASH_LBIDr_GET BCM56800_A0_RTAG7_HASH_LBIDr_GET
#define RTAG7_HASH_LBIDr_SUB_SEL_UCf_GET BCM56800_A0_RTAG7_HASH_LBIDr_SUB_SEL_UCf_GET
#define RTAG7_HASH_LBIDr_SUB_SEL_UCf_SET BCM56800_A0_RTAG7_HASH_LBIDr_SUB_SEL_UCf_SET
#define RTAG7_HASH_LBIDr_OFFSET_UCf_GET BCM56800_A0_RTAG7_HASH_LBIDr_OFFSET_UCf_GET
#define RTAG7_HASH_LBIDr_OFFSET_UCf_SET BCM56800_A0_RTAG7_HASH_LBIDr_OFFSET_UCf_SET
#define RTAG7_HASH_LBIDr_SUB_SEL_NONUCf_GET BCM56800_A0_RTAG7_HASH_LBIDr_SUB_SEL_NONUCf_GET
#define RTAG7_HASH_LBIDr_SUB_SEL_NONUCf_SET BCM56800_A0_RTAG7_HASH_LBIDr_SUB_SEL_NONUCf_SET
#define RTAG7_HASH_LBIDr_OFFSET_NONUCf_GET BCM56800_A0_RTAG7_HASH_LBIDr_OFFSET_NONUCf_GET
#define RTAG7_HASH_LBIDr_OFFSET_NONUCf_SET BCM56800_A0_RTAG7_HASH_LBIDr_OFFSET_NONUCf_SET
#define READ_RTAG7_HASH_LBIDr BCM56800_A0_READ_RTAG7_HASH_LBIDr
#define WRITE_RTAG7_HASH_LBIDr BCM56800_A0_WRITE_RTAG7_HASH_LBIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_LBIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_PLFS
 * BLOCKS:   IPIPE
 * DESC:     RTAG7 hash control register for LAG failover
 * SIZE:     32
 * FIELDS:
 *     SUB_SEL          Hash subfield selector
 *     OFFSET           The offset of the hash value for LAG failover.
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_PLFSr 0x0e18063e

#define BCM56800_A0_RTAG7_HASH_PLFSr_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_PLFS.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_PLFSr_s {
	uint32_t v[1];
	uint32_t rtag7_hash_plfs[1];
	uint32_t _rtag7_hash_plfs;
} BCM56800_A0_RTAG7_HASH_PLFSr_t;

#define BCM56800_A0_RTAG7_HASH_PLFSr_CLR(r) (r).rtag7_hash_plfs[0] = 0
#define BCM56800_A0_RTAG7_HASH_PLFSr_SET(r,d) (r).rtag7_hash_plfs[0] = d
#define BCM56800_A0_RTAG7_HASH_PLFSr_GET(r) (r).rtag7_hash_plfs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_PLFSr_SUB_SELf_GET(r) (((r).rtag7_hash_plfs[0]) & 0x7)
#define BCM56800_A0_RTAG7_HASH_PLFSr_SUB_SELf_SET(r,f) (r).rtag7_hash_plfs[0]=(((r).rtag7_hash_plfs[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_RTAG7_HASH_PLFSr_OFFSETf_GET(r) ((((r).rtag7_hash_plfs[0]) >> 3) & 0xf)
#define BCM56800_A0_RTAG7_HASH_PLFSr_OFFSETf_SET(r,f) (r).rtag7_hash_plfs[0]=(((r).rtag7_hash_plfs[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))

/*
 * These macros can be used to access RTAG7_HASH_PLFS.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_PLFSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_PLFSr,(r._rtag7_hash_plfs))
#define BCM56800_A0_WRITE_RTAG7_HASH_PLFSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_PLFSr,&(r._rtag7_hash_plfs))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_PLFSr BCM56800_A0_RTAG7_HASH_PLFSr
#define RTAG7_HASH_PLFSr_SIZE BCM56800_A0_RTAG7_HASH_PLFSr_SIZE
typedef BCM56800_A0_RTAG7_HASH_PLFSr_t RTAG7_HASH_PLFSr_t;
#define RTAG7_HASH_PLFSr_CLR BCM56800_A0_RTAG7_HASH_PLFSr_CLR
#define RTAG7_HASH_PLFSr_SET BCM56800_A0_RTAG7_HASH_PLFSr_SET
#define RTAG7_HASH_PLFSr_GET BCM56800_A0_RTAG7_HASH_PLFSr_GET
#define RTAG7_HASH_PLFSr_SUB_SELf_GET BCM56800_A0_RTAG7_HASH_PLFSr_SUB_SELf_GET
#define RTAG7_HASH_PLFSr_SUB_SELf_SET BCM56800_A0_RTAG7_HASH_PLFSr_SUB_SELf_SET
#define RTAG7_HASH_PLFSr_OFFSETf_GET BCM56800_A0_RTAG7_HASH_PLFSr_OFFSETf_GET
#define RTAG7_HASH_PLFSr_OFFSETf_SET BCM56800_A0_RTAG7_HASH_PLFSr_OFFSETf_SET
#define READ_RTAG7_HASH_PLFSr BCM56800_A0_READ_RTAG7_HASH_PLFSr
#define WRITE_RTAG7_HASH_PLFSr BCM56800_A0_WRITE_RTAG7_HASH_PLFSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_PLFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_SEED_A
 * BLOCKS:   IPIPE
 * DESC:     Hash Seed for Rtag7 hashing
 * SIZE:     32
 * FIELDS:
 *     HASH_SEED_A      Hash seed for Rtag7 hash A
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_SEED_Ar 0x02180629

#define BCM56800_A0_RTAG7_HASH_SEED_Ar_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_SEED_A.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_SEED_Ar_s {
	uint32_t v[1];
	uint32_t rtag7_hash_seed_a[1];
	uint32_t _rtag7_hash_seed_a;
} BCM56800_A0_RTAG7_HASH_SEED_Ar_t;

#define BCM56800_A0_RTAG7_HASH_SEED_Ar_CLR(r) (r).rtag7_hash_seed_a[0] = 0
#define BCM56800_A0_RTAG7_HASH_SEED_Ar_SET(r,d) (r).rtag7_hash_seed_a[0] = d
#define BCM56800_A0_RTAG7_HASH_SEED_Ar_GET(r) (r).rtag7_hash_seed_a[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_SEED_Ar_HASH_SEED_Af_GET(r) ((r).rtag7_hash_seed_a[0])
#define BCM56800_A0_RTAG7_HASH_SEED_Ar_HASH_SEED_Af_SET(r,f) (r).rtag7_hash_seed_a[0]=((uint32_t)f)

/*
 * These macros can be used to access RTAG7_HASH_SEED_A.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_SEED_Ar(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_SEED_Ar,(r._rtag7_hash_seed_a))
#define BCM56800_A0_WRITE_RTAG7_HASH_SEED_Ar(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_SEED_Ar,&(r._rtag7_hash_seed_a))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_SEED_Ar BCM56800_A0_RTAG7_HASH_SEED_Ar
#define RTAG7_HASH_SEED_Ar_SIZE BCM56800_A0_RTAG7_HASH_SEED_Ar_SIZE
typedef BCM56800_A0_RTAG7_HASH_SEED_Ar_t RTAG7_HASH_SEED_Ar_t;
#define RTAG7_HASH_SEED_Ar_CLR BCM56800_A0_RTAG7_HASH_SEED_Ar_CLR
#define RTAG7_HASH_SEED_Ar_SET BCM56800_A0_RTAG7_HASH_SEED_Ar_SET
#define RTAG7_HASH_SEED_Ar_GET BCM56800_A0_RTAG7_HASH_SEED_Ar_GET
#define RTAG7_HASH_SEED_Ar_HASH_SEED_Af_GET BCM56800_A0_RTAG7_HASH_SEED_Ar_HASH_SEED_Af_GET
#define RTAG7_HASH_SEED_Ar_HASH_SEED_Af_SET BCM56800_A0_RTAG7_HASH_SEED_Ar_HASH_SEED_Af_SET
#define READ_RTAG7_HASH_SEED_Ar BCM56800_A0_READ_RTAG7_HASH_SEED_Ar
#define WRITE_RTAG7_HASH_SEED_Ar BCM56800_A0_WRITE_RTAG7_HASH_SEED_Ar

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_SEED_Ar'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_SEED_B
 * BLOCKS:   IPIPE
 * DESC:     Hash Seed for Rtag7 hashing
 * SIZE:     32
 * FIELDS:
 *     HASH_SEED_B      Hash seed for Rtag7 hash B
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_SEED_Br 0x0218062a

#define BCM56800_A0_RTAG7_HASH_SEED_Br_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_SEED_B.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_SEED_Br_s {
	uint32_t v[1];
	uint32_t rtag7_hash_seed_b[1];
	uint32_t _rtag7_hash_seed_b;
} BCM56800_A0_RTAG7_HASH_SEED_Br_t;

#define BCM56800_A0_RTAG7_HASH_SEED_Br_CLR(r) (r).rtag7_hash_seed_b[0] = 0
#define BCM56800_A0_RTAG7_HASH_SEED_Br_SET(r,d) (r).rtag7_hash_seed_b[0] = d
#define BCM56800_A0_RTAG7_HASH_SEED_Br_GET(r) (r).rtag7_hash_seed_b[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_SEED_Br_HASH_SEED_Bf_GET(r) ((r).rtag7_hash_seed_b[0])
#define BCM56800_A0_RTAG7_HASH_SEED_Br_HASH_SEED_Bf_SET(r,f) (r).rtag7_hash_seed_b[0]=((uint32_t)f)

/*
 * These macros can be used to access RTAG7_HASH_SEED_B.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_SEED_Br(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_SEED_Br,(r._rtag7_hash_seed_b))
#define BCM56800_A0_WRITE_RTAG7_HASH_SEED_Br(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_SEED_Br,&(r._rtag7_hash_seed_b))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_SEED_Br BCM56800_A0_RTAG7_HASH_SEED_Br
#define RTAG7_HASH_SEED_Br_SIZE BCM56800_A0_RTAG7_HASH_SEED_Br_SIZE
typedef BCM56800_A0_RTAG7_HASH_SEED_Br_t RTAG7_HASH_SEED_Br_t;
#define RTAG7_HASH_SEED_Br_CLR BCM56800_A0_RTAG7_HASH_SEED_Br_CLR
#define RTAG7_HASH_SEED_Br_SET BCM56800_A0_RTAG7_HASH_SEED_Br_SET
#define RTAG7_HASH_SEED_Br_GET BCM56800_A0_RTAG7_HASH_SEED_Br_GET
#define RTAG7_HASH_SEED_Br_HASH_SEED_Bf_GET BCM56800_A0_RTAG7_HASH_SEED_Br_HASH_SEED_Bf_GET
#define RTAG7_HASH_SEED_Br_HASH_SEED_Bf_SET BCM56800_A0_RTAG7_HASH_SEED_Br_HASH_SEED_Bf_SET
#define READ_RTAG7_HASH_SEED_Br BCM56800_A0_READ_RTAG7_HASH_SEED_Br
#define WRITE_RTAG7_HASH_SEED_Br BCM56800_A0_WRITE_RTAG7_HASH_SEED_Br

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_SEED_Br'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RTAG7_HASH_TRUNK
 * BLOCKS:   IPIPE
 * DESC:     RTAG7 hash control register for trunking
 * SIZE:     32
 * FIELDS:
 *     SUB_SEL_UC       Hash subfield selector for unicast trunking
 *     OFFSET_UC        The offset of the hash value for unicast trunking.
 *     SUB_SEL_NONUC    Hash subfield selector for non-unicast trunking
 *     OFFSET_NONUC     The offset of the hash value for non-unicast trunking.
 *
 ******************************************************************************/
#define BCM56800_A0_RTAG7_HASH_TRUNKr 0x0e18063a

#define BCM56800_A0_RTAG7_HASH_TRUNKr_SIZE 4

/*
 * This structure should be used to declare and program RTAG7_HASH_TRUNK.
 *
 */
typedef union BCM56800_A0_RTAG7_HASH_TRUNKr_s {
	uint32_t v[1];
	uint32_t rtag7_hash_trunk[1];
	uint32_t _rtag7_hash_trunk;
} BCM56800_A0_RTAG7_HASH_TRUNKr_t;

#define BCM56800_A0_RTAG7_HASH_TRUNKr_CLR(r) (r).rtag7_hash_trunk[0] = 0
#define BCM56800_A0_RTAG7_HASH_TRUNKr_SET(r,d) (r).rtag7_hash_trunk[0] = d
#define BCM56800_A0_RTAG7_HASH_TRUNKr_GET(r) (r).rtag7_hash_trunk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RTAG7_HASH_TRUNKr_SUB_SEL_UCf_GET(r) (((r).rtag7_hash_trunk[0]) & 0x7)
#define BCM56800_A0_RTAG7_HASH_TRUNKr_SUB_SEL_UCf_SET(r,f) (r).rtag7_hash_trunk[0]=(((r).rtag7_hash_trunk[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_RTAG7_HASH_TRUNKr_OFFSET_UCf_GET(r) ((((r).rtag7_hash_trunk[0]) >> 3) & 0xf)
#define BCM56800_A0_RTAG7_HASH_TRUNKr_OFFSET_UCf_SET(r,f) (r).rtag7_hash_trunk[0]=(((r).rtag7_hash_trunk[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3))
#define BCM56800_A0_RTAG7_HASH_TRUNKr_SUB_SEL_NONUCf_GET(r) ((((r).rtag7_hash_trunk[0]) >> 7) & 0x7)
#define BCM56800_A0_RTAG7_HASH_TRUNKr_SUB_SEL_NONUCf_SET(r,f) (r).rtag7_hash_trunk[0]=(((r).rtag7_hash_trunk[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM56800_A0_RTAG7_HASH_TRUNKr_OFFSET_NONUCf_GET(r) ((((r).rtag7_hash_trunk[0]) >> 10) & 0xf)
#define BCM56800_A0_RTAG7_HASH_TRUNKr_OFFSET_NONUCf_SET(r,f) (r).rtag7_hash_trunk[0]=(((r).rtag7_hash_trunk[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10))

/*
 * These macros can be used to access RTAG7_HASH_TRUNK.
 *
 */
#define BCM56800_A0_READ_RTAG7_HASH_TRUNKr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_RTAG7_HASH_TRUNKr+(i),(r._rtag7_hash_trunk))
#define BCM56800_A0_WRITE_RTAG7_HASH_TRUNKr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_RTAG7_HASH_TRUNKr+(i),&(r._rtag7_hash_trunk))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RTAG7_HASH_TRUNKr BCM56800_A0_RTAG7_HASH_TRUNKr
#define RTAG7_HASH_TRUNKr_SIZE BCM56800_A0_RTAG7_HASH_TRUNKr_SIZE
typedef BCM56800_A0_RTAG7_HASH_TRUNKr_t RTAG7_HASH_TRUNKr_t;
#define RTAG7_HASH_TRUNKr_CLR BCM56800_A0_RTAG7_HASH_TRUNKr_CLR
#define RTAG7_HASH_TRUNKr_SET BCM56800_A0_RTAG7_HASH_TRUNKr_SET
#define RTAG7_HASH_TRUNKr_GET BCM56800_A0_RTAG7_HASH_TRUNKr_GET
#define RTAG7_HASH_TRUNKr_SUB_SEL_UCf_GET BCM56800_A0_RTAG7_HASH_TRUNKr_SUB_SEL_UCf_GET
#define RTAG7_HASH_TRUNKr_SUB_SEL_UCf_SET BCM56800_A0_RTAG7_HASH_TRUNKr_SUB_SEL_UCf_SET
#define RTAG7_HASH_TRUNKr_OFFSET_UCf_GET BCM56800_A0_RTAG7_HASH_TRUNKr_OFFSET_UCf_GET
#define RTAG7_HASH_TRUNKr_OFFSET_UCf_SET BCM56800_A0_RTAG7_HASH_TRUNKr_OFFSET_UCf_SET
#define RTAG7_HASH_TRUNKr_SUB_SEL_NONUCf_GET BCM56800_A0_RTAG7_HASH_TRUNKr_SUB_SEL_NONUCf_GET
#define RTAG7_HASH_TRUNKr_SUB_SEL_NONUCf_SET BCM56800_A0_RTAG7_HASH_TRUNKr_SUB_SEL_NONUCf_SET
#define RTAG7_HASH_TRUNKr_OFFSET_NONUCf_GET BCM56800_A0_RTAG7_HASH_TRUNKr_OFFSET_NONUCf_GET
#define RTAG7_HASH_TRUNKr_OFFSET_NONUCf_SET BCM56800_A0_RTAG7_HASH_TRUNKr_OFFSET_NONUCf_SET
#define READ_RTAG7_HASH_TRUNKr BCM56800_A0_READ_RTAG7_HASH_TRUNKr
#define WRITE_RTAG7_HASH_TRUNKr BCM56800_A0_WRITE_RTAG7_HASH_TRUNKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RTAG7_HASH_TRUNKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  RUC
 * BLOCKS:   IPIPE
 * DESC:     Receive Unicast Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_RUCr 0x0e100009

#define BCM56800_A0_RUCr_SIZE 4

/*
 * This structure should be used to declare and program RUC.
 *
 */
typedef union BCM56800_A0_RUCr_s {
	uint32_t v[1];
	uint32_t ruc[1];
	uint32_t _ruc;
} BCM56800_A0_RUCr_t;

#define BCM56800_A0_RUCr_CLR(r) (r).ruc[0] = 0
#define BCM56800_A0_RUCr_SET(r,d) (r).ruc[0] = d
#define BCM56800_A0_RUCr_GET(r) (r).ruc[0]


/*
 * These macros can be used to access RUC.
 *
 */
#define BCM56800_A0_READ_RUCr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_RUCr,(r._ruc))
#define BCM56800_A0_WRITE_RUCr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_RUCr,&(r._ruc))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RUCr BCM56800_A0_RUCr
#define RUCr_SIZE BCM56800_A0_RUCr_SIZE
typedef BCM56800_A0_RUCr_t RUCr_t;
#define RUCr_CLR BCM56800_A0_RUCr_CLR
#define RUCr_SET BCM56800_A0_RUCr_SET
#define RUCr_GET BCM56800_A0_RUCr_GET
#define READ_RUCr BCM56800_A0_READ_RUCr
#define WRITE_RUCr BCM56800_A0_WRITE_RUCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RUCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * SWFORMAT:  RX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     352
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     END_BIT          Descriptor is for last (or only) packet fragment.
 *     START_BIT        Descriptor is for first (or only) packet fragment.
 *     ERROR            Internal RX error encountered.
 *     DONE             Descriptor done.
 *     NHOP_INDEX       Next Hop index.
 *     PKT_WAS_UNTAGGED Packet ingressed untagged on an Ethernet (non-HiGig) port.
 *     REGEN_CRC        Packet was modified and CRC is no longer valid.
 *     SWITCH           Switched packet (as opposed to mirrored packet.)
 *     SRC_HG           Source is HiGig.
 *     PURGE_CELL       Packet is marked for purging.
 *     PKT_AGED         Packet is aged.
 *     L3UC             Packet is a L3 unicast packet.
 *     L3ONLY           Packet is for L3 IPMC only.
 *     MATCHED_RULE     Matched Field Processor rule.
 *     OUTER_VID        Outer VLAN ID of the packet.
 *     OUTER_CFI        Outer CFI assigned to the packet.
 *     OUTER_PRI        Outer priority assigned to the packet.
 *     DSCP             New DCSP value computed by the switch chip.
 *     DECAP_IPTUNNEL   IP tunnel encapsulation was stripped from packet.
 *     SRC_PORT         Source port number.
 *     ECN              New ECN value.
 *     REASON           CPU opcode, reason the packet was copied to the CPU. Bit 24 - Multicast index error  Bit 23 - HiGig Header error  Bit 22 - L3 MTU check fail to CPU  Bit 21 - Parity error on IP tables  Bit 20 - L3 slow path CPU processed packets  Bit 19 - ICMP redirect copy to CPU  Bit 18 - L2 MTU check fail to CPU  Bit 17 - Tunnel error trap to CPU  Bit 16 - Martian address trap to CPU  Bit 15 - DOS attack trap to CPU  Bit 14 - Protocol packet  Bit 13 - L3 header  - IP options, TTL=0, !IPv4 etc."  Bit 12 - FP action - copy to CPU  Bit 11 - IPMC miss - {SIP, DIP} miss or DIP miss"  Bit 10 - Multicast miss   Bit 9  - Station movement - L3  Bit 8  - L3 DIP miss  Bit 7  - L3 SIP miss  Bit 6  - sFlow - Dst  Bit 5  - sFlow - Src  Bit 4  - L2_table - copy to CPU  Bit 3  - Station movement - L2  Bit 2  - Destination lookup failure  Bit 1  - Source lookup failure  Bit 0  - Learning enabled in port table and SA is learnt; Unknown VLAN ID; VLAN ID = 0xfff  
 *     MTP_INDEX        Mirror-to-Port index.
 *     COS              Queue number used internally for non-CPU ports.
 *     CPU_COS          Queue number used internally for the CPU port.
 *     IPMC_INTF_NUM    Index to L3 table for IPMC packets.
 *     L3IPMC           L3 IP multicast packet
 *     IMIRROR          Ingress mirror packet.
 *     EMIRROR          Egress mirror packet.
 *     CHANGE_DSCP      DSCP value was changed.
 *     CELL_ERROR       Packet cell had CRC or parity error.
 *     BPDU             BPDU packet
 *     ADD_VID          VLAN ID was added.
 *     DO_NOT_CHANGE_TTL TTL was not changed by Field Processor (L3 unicast packets.)
 *     HGI              HiGig interface format (valid for HiGig+ only.)
 *     SRC_HIGIG_TYPE   0: HiGig+ packet1: HiGig2 packetValid only if the SRC_HG bit is also set.
 *     MODULE_HEADER    Valid only if the SRC_HG bit is set to 1 in this descriptor.
 *     BYTE_COUNT       Maximum number of bytes for this transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet may continue in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     ADDR             Physical memory address for the transfer.
 *
 ******************************************************************************/
#define BCM56800_A0_RX_DCB 0x00000000

#define BCM56800_A0_RX_DCB_SIZE 44

/*
 * This structure should be used to declare and program RX_DCB.
 *
 */
typedef union BCM56800_A0_RX_DCB_s {
	uint32_t v[11];
	uint32_t rx_dcb[11];
	uint32_t _rx_dcb;
} BCM56800_A0_RX_DCB_t;

#define BCM56800_A0_RX_DCB_CLR(r) CDK_MEMSET(&((r)._rx_dcb), 0, sizeof(BCM56800_A0_RX_DCB_t))
#define BCM56800_A0_RX_DCB_SET(r,i,d) (r).rx_dcb[i] = d
#define BCM56800_A0_RX_DCB_GET(r,i) (r).rx_dcb[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_RX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).rx_dcb[10]) & 0xffff)
#define BCM56800_A0_RX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_RX_DCB_END_BITf_GET(r) ((((r).rx_dcb[10]) >> 16) & 0x1)
#define BCM56800_A0_RX_DCB_END_BITf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_RX_DCB_START_BITf_GET(r) ((((r).rx_dcb[10]) >> 17) & 0x1)
#define BCM56800_A0_RX_DCB_START_BITf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_RX_DCB_ERRORf_GET(r) ((((r).rx_dcb[10]) >> 18) & 0x1)
#define BCM56800_A0_RX_DCB_ERRORf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_RX_DCB_DONEf_GET(r) ((((r).rx_dcb[10]) >> 31) & 0x1)
#define BCM56800_A0_RX_DCB_DONEf_SET(r,f) (r).rx_dcb[10]=(((r).rx_dcb[10] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_RX_DCB_NHOP_INDEXf_GET(r) (((r).rx_dcb[9]) & 0x1fff)
#define BCM56800_A0_RX_DCB_NHOP_INDEXf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM56800_A0_RX_DCB_PKT_WAS_UNTAGGEDf_GET(r) ((((r).rx_dcb[9]) >> 13) & 0x1)
#define BCM56800_A0_RX_DCB_PKT_WAS_UNTAGGEDf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_RX_DCB_REGEN_CRCf_GET(r) ((((r).rx_dcb[9]) >> 14) & 0x1)
#define BCM56800_A0_RX_DCB_REGEN_CRCf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_RX_DCB_SWITCHf_GET(r) ((((r).rx_dcb[9]) >> 15) & 0x1)
#define BCM56800_A0_RX_DCB_SWITCHf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_RX_DCB_SRC_HGf_GET(r) ((((r).rx_dcb[9]) >> 16) & 0x1)
#define BCM56800_A0_RX_DCB_SRC_HGf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_RX_DCB_PURGE_CELLf_GET(r) ((((r).rx_dcb[9]) >> 17) & 0x1)
#define BCM56800_A0_RX_DCB_PURGE_CELLf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_RX_DCB_PKT_AGEDf_GET(r) ((((r).rx_dcb[9]) >> 18) & 0x1)
#define BCM56800_A0_RX_DCB_PKT_AGEDf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_RX_DCB_L3UCf_GET(r) ((((r).rx_dcb[9]) >> 19) & 0x1)
#define BCM56800_A0_RX_DCB_L3UCf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_RX_DCB_L3ONLYf_GET(r) ((((r).rx_dcb[9]) >> 20) & 0x1)
#define BCM56800_A0_RX_DCB_L3ONLYf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_RX_DCB_MATCHED_RULEf_GET(r) ((((r).rx_dcb[9]) >> 21) & 0x7ff)
#define BCM56800_A0_RX_DCB_MATCHED_RULEf_SET(r,f) (r).rx_dcb[9]=(((r).rx_dcb[9] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))
#define BCM56800_A0_RX_DCB_OUTER_VIDf_GET(r) (((r).rx_dcb[8]) & 0xfff)
#define BCM56800_A0_RX_DCB_OUTER_VIDf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_RX_DCB_OUTER_CFIf_GET(r) ((((r).rx_dcb[8]) >> 12) & 0x1)
#define BCM56800_A0_RX_DCB_OUTER_CFIf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_RX_DCB_OUTER_PRIf_GET(r) ((((r).rx_dcb[8]) >> 13) & 0x7)
#define BCM56800_A0_RX_DCB_OUTER_PRIf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM56800_A0_RX_DCB_DSCPf_GET(r) ((((r).rx_dcb[8]) >> 16) & 0xff)
#define BCM56800_A0_RX_DCB_DSCPf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM56800_A0_RX_DCB_DECAP_IPTUNNELf_GET(r) ((((r).rx_dcb[8]) >> 24) & 0x1)
#define BCM56800_A0_RX_DCB_DECAP_IPTUNNELf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_RX_DCB_SRC_PORTf_GET(r) ((((r).rx_dcb[8]) >> 25) & 0x1f)
#define BCM56800_A0_RX_DCB_SRC_PORTf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM56800_A0_RX_DCB_ECNf_GET(r) ((((r).rx_dcb[8]) >> 30) & 0x3)
#define BCM56800_A0_RX_DCB_ECNf_SET(r,f) (r).rx_dcb[8]=(((r).rx_dcb[8] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56800_A0_RX_DCB_REASONf_GET(r) (((r).rx_dcb[7]) & 0x1ffffff)
#define BCM56800_A0_RX_DCB_REASONf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))
#define BCM56800_A0_RX_DCB_MTP_INDEXf_GET(r) ((((r).rx_dcb[7]) >> 25) & 0x7f)
#define BCM56800_A0_RX_DCB_MTP_INDEXf_SET(r,f) (r).rx_dcb[7]=(((r).rx_dcb[7] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))
#define BCM56800_A0_RX_DCB_COSf_GET(r) (((r).rx_dcb[6]) & 0xf)
#define BCM56800_A0_RX_DCB_COSf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_RX_DCB_CPU_COSf_GET(r) ((((r).rx_dcb[6]) >> 4) & 0xf)
#define BCM56800_A0_RX_DCB_CPU_COSf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_RX_DCB_IPMC_INTF_NUMf_GET(r) ((((r).rx_dcb[6]) >> 8) & 0xfff)
#define BCM56800_A0_RX_DCB_IPMC_INTF_NUMf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM56800_A0_RX_DCB_L3IPMCf_GET(r) ((((r).rx_dcb[6]) >> 20) & 0x1)
#define BCM56800_A0_RX_DCB_L3IPMCf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM56800_A0_RX_DCB_IMIRRORf_GET(r) ((((r).rx_dcb[6]) >> 21) & 0x1)
#define BCM56800_A0_RX_DCB_IMIRRORf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_RX_DCB_EMIRRORf_GET(r) ((((r).rx_dcb[6]) >> 22) & 0x1)
#define BCM56800_A0_RX_DCB_EMIRRORf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_RX_DCB_CHANGE_DSCPf_GET(r) ((((r).rx_dcb[6]) >> 23) & 0x1)
#define BCM56800_A0_RX_DCB_CHANGE_DSCPf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_RX_DCB_CELL_ERRORf_GET(r) ((((r).rx_dcb[6]) >> 24) & 0x1)
#define BCM56800_A0_RX_DCB_CELL_ERRORf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM56800_A0_RX_DCB_BPDUf_GET(r) ((((r).rx_dcb[6]) >> 25) & 0x1)
#define BCM56800_A0_RX_DCB_BPDUf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM56800_A0_RX_DCB_ADD_VIDf_GET(r) ((((r).rx_dcb[6]) >> 26) & 0x1)
#define BCM56800_A0_RX_DCB_ADD_VIDf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM56800_A0_RX_DCB_DO_NOT_CHANGE_TTLf_GET(r) ((((r).rx_dcb[6]) >> 27) & 0x1)
#define BCM56800_A0_RX_DCB_DO_NOT_CHANGE_TTLf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM56800_A0_RX_DCB_HGIf_GET(r) ((((r).rx_dcb[6]) >> 28) & 0x3)
#define BCM56800_A0_RX_DCB_HGIf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56800_A0_RX_DCB_SRC_HIGIG_TYPEf_GET(r) ((((r).rx_dcb[6]) >> 31) & 0x1)
#define BCM56800_A0_RX_DCB_SRC_HIGIG_TYPEf_SET(r,f) (r).rx_dcb[6]=(((r).rx_dcb[6] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_RX_DCB_MODULE_HEADERf_GET(r,a) cdk_field_be_get((r).rx_dcb,11,160,287,a)
#define BCM56800_A0_RX_DCB_MODULE_HEADERf_SET(r,a) cdk_field_be_set((r).rx_dcb,11,160,287,a)
#define BCM56800_A0_RX_DCB_MODULE_HEADERf_PTR(r) ((void*)&(r).rx_dcb[2])
#define BCM56800_A0_RX_DCB_BYTE_COUNTf_GET(r) (((r).rx_dcb[1]) & 0xffff)
#define BCM56800_A0_RX_DCB_BYTE_COUNTf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_RX_DCB_CHAINf_GET(r) ((((r).rx_dcb[1]) >> 16) & 0x1)
#define BCM56800_A0_RX_DCB_CHAINf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_RX_DCB_SGf_GET(r) ((((r).rx_dcb[1]) >> 17) & 0x1)
#define BCM56800_A0_RX_DCB_SGf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_RX_DCB_RELOADf_GET(r) ((((r).rx_dcb[1]) >> 18) & 0x1)
#define BCM56800_A0_RX_DCB_RELOADf_SET(r,f) (r).rx_dcb[1]=(((r).rx_dcb[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_RX_DCB_ADDRf_GET(r) ((r).rx_dcb[0])
#define BCM56800_A0_RX_DCB_ADDRf_SET(r,f) (r).rx_dcb[0]=((uint32_t)f)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_DCB BCM56800_A0_RX_DCB
#define RX_DCB_SIZE BCM56800_A0_RX_DCB_SIZE
typedef BCM56800_A0_RX_DCB_t RX_DCB_t;
#define RX_DCB_CLR BCM56800_A0_RX_DCB_CLR
#define RX_DCB_SET BCM56800_A0_RX_DCB_SET
#define RX_DCB_GET BCM56800_A0_RX_DCB_GET
#define RX_DCB_BYTES_TRANSFERREDf_GET BCM56800_A0_RX_DCB_BYTES_TRANSFERREDf_GET
#define RX_DCB_BYTES_TRANSFERREDf_SET BCM56800_A0_RX_DCB_BYTES_TRANSFERREDf_SET
#define RX_DCB_END_BITf_GET BCM56800_A0_RX_DCB_END_BITf_GET
#define RX_DCB_END_BITf_SET BCM56800_A0_RX_DCB_END_BITf_SET
#define RX_DCB_START_BITf_GET BCM56800_A0_RX_DCB_START_BITf_GET
#define RX_DCB_START_BITf_SET BCM56800_A0_RX_DCB_START_BITf_SET
#define RX_DCB_ERRORf_GET BCM56800_A0_RX_DCB_ERRORf_GET
#define RX_DCB_ERRORf_SET BCM56800_A0_RX_DCB_ERRORf_SET
#define RX_DCB_DONEf_GET BCM56800_A0_RX_DCB_DONEf_GET
#define RX_DCB_DONEf_SET BCM56800_A0_RX_DCB_DONEf_SET
#define RX_DCB_NHOP_INDEXf_GET BCM56800_A0_RX_DCB_NHOP_INDEXf_GET
#define RX_DCB_NHOP_INDEXf_SET BCM56800_A0_RX_DCB_NHOP_INDEXf_SET
#define RX_DCB_PKT_WAS_UNTAGGEDf_GET BCM56800_A0_RX_DCB_PKT_WAS_UNTAGGEDf_GET
#define RX_DCB_PKT_WAS_UNTAGGEDf_SET BCM56800_A0_RX_DCB_PKT_WAS_UNTAGGEDf_SET
#define RX_DCB_REGEN_CRCf_GET BCM56800_A0_RX_DCB_REGEN_CRCf_GET
#define RX_DCB_REGEN_CRCf_SET BCM56800_A0_RX_DCB_REGEN_CRCf_SET
#define RX_DCB_SWITCHf_GET BCM56800_A0_RX_DCB_SWITCHf_GET
#define RX_DCB_SWITCHf_SET BCM56800_A0_RX_DCB_SWITCHf_SET
#define RX_DCB_SRC_HGf_GET BCM56800_A0_RX_DCB_SRC_HGf_GET
#define RX_DCB_SRC_HGf_SET BCM56800_A0_RX_DCB_SRC_HGf_SET
#define RX_DCB_PURGE_CELLf_GET BCM56800_A0_RX_DCB_PURGE_CELLf_GET
#define RX_DCB_PURGE_CELLf_SET BCM56800_A0_RX_DCB_PURGE_CELLf_SET
#define RX_DCB_PKT_AGEDf_GET BCM56800_A0_RX_DCB_PKT_AGEDf_GET
#define RX_DCB_PKT_AGEDf_SET BCM56800_A0_RX_DCB_PKT_AGEDf_SET
#define RX_DCB_L3UCf_GET BCM56800_A0_RX_DCB_L3UCf_GET
#define RX_DCB_L3UCf_SET BCM56800_A0_RX_DCB_L3UCf_SET
#define RX_DCB_L3ONLYf_GET BCM56800_A0_RX_DCB_L3ONLYf_GET
#define RX_DCB_L3ONLYf_SET BCM56800_A0_RX_DCB_L3ONLYf_SET
#define RX_DCB_MATCHED_RULEf_GET BCM56800_A0_RX_DCB_MATCHED_RULEf_GET
#define RX_DCB_MATCHED_RULEf_SET BCM56800_A0_RX_DCB_MATCHED_RULEf_SET
#define RX_DCB_OUTER_VIDf_GET BCM56800_A0_RX_DCB_OUTER_VIDf_GET
#define RX_DCB_OUTER_VIDf_SET BCM56800_A0_RX_DCB_OUTER_VIDf_SET
#define RX_DCB_OUTER_CFIf_GET BCM56800_A0_RX_DCB_OUTER_CFIf_GET
#define RX_DCB_OUTER_CFIf_SET BCM56800_A0_RX_DCB_OUTER_CFIf_SET
#define RX_DCB_OUTER_PRIf_GET BCM56800_A0_RX_DCB_OUTER_PRIf_GET
#define RX_DCB_OUTER_PRIf_SET BCM56800_A0_RX_DCB_OUTER_PRIf_SET
#define RX_DCB_DSCPf_GET BCM56800_A0_RX_DCB_DSCPf_GET
#define RX_DCB_DSCPf_SET BCM56800_A0_RX_DCB_DSCPf_SET
#define RX_DCB_DECAP_IPTUNNELf_GET BCM56800_A0_RX_DCB_DECAP_IPTUNNELf_GET
#define RX_DCB_DECAP_IPTUNNELf_SET BCM56800_A0_RX_DCB_DECAP_IPTUNNELf_SET
#define RX_DCB_SRC_PORTf_GET BCM56800_A0_RX_DCB_SRC_PORTf_GET
#define RX_DCB_SRC_PORTf_SET BCM56800_A0_RX_DCB_SRC_PORTf_SET
#define RX_DCB_ECNf_GET BCM56800_A0_RX_DCB_ECNf_GET
#define RX_DCB_ECNf_SET BCM56800_A0_RX_DCB_ECNf_SET
#define RX_DCB_REASONf_GET BCM56800_A0_RX_DCB_REASONf_GET
#define RX_DCB_REASONf_SET BCM56800_A0_RX_DCB_REASONf_SET
#define RX_DCB_MTP_INDEXf_GET BCM56800_A0_RX_DCB_MTP_INDEXf_GET
#define RX_DCB_MTP_INDEXf_SET BCM56800_A0_RX_DCB_MTP_INDEXf_SET
#define RX_DCB_COSf_GET BCM56800_A0_RX_DCB_COSf_GET
#define RX_DCB_COSf_SET BCM56800_A0_RX_DCB_COSf_SET
#define RX_DCB_CPU_COSf_GET BCM56800_A0_RX_DCB_CPU_COSf_GET
#define RX_DCB_CPU_COSf_SET BCM56800_A0_RX_DCB_CPU_COSf_SET
#define RX_DCB_IPMC_INTF_NUMf_GET BCM56800_A0_RX_DCB_IPMC_INTF_NUMf_GET
#define RX_DCB_IPMC_INTF_NUMf_SET BCM56800_A0_RX_DCB_IPMC_INTF_NUMf_SET
#define RX_DCB_L3IPMCf_GET BCM56800_A0_RX_DCB_L3IPMCf_GET
#define RX_DCB_L3IPMCf_SET BCM56800_A0_RX_DCB_L3IPMCf_SET
#define RX_DCB_IMIRRORf_GET BCM56800_A0_RX_DCB_IMIRRORf_GET
#define RX_DCB_IMIRRORf_SET BCM56800_A0_RX_DCB_IMIRRORf_SET
#define RX_DCB_EMIRRORf_GET BCM56800_A0_RX_DCB_EMIRRORf_GET
#define RX_DCB_EMIRRORf_SET BCM56800_A0_RX_DCB_EMIRRORf_SET
#define RX_DCB_CHANGE_DSCPf_GET BCM56800_A0_RX_DCB_CHANGE_DSCPf_GET
#define RX_DCB_CHANGE_DSCPf_SET BCM56800_A0_RX_DCB_CHANGE_DSCPf_SET
#define RX_DCB_CELL_ERRORf_GET BCM56800_A0_RX_DCB_CELL_ERRORf_GET
#define RX_DCB_CELL_ERRORf_SET BCM56800_A0_RX_DCB_CELL_ERRORf_SET
#define RX_DCB_BPDUf_GET BCM56800_A0_RX_DCB_BPDUf_GET
#define RX_DCB_BPDUf_SET BCM56800_A0_RX_DCB_BPDUf_SET
#define RX_DCB_ADD_VIDf_GET BCM56800_A0_RX_DCB_ADD_VIDf_GET
#define RX_DCB_ADD_VIDf_SET BCM56800_A0_RX_DCB_ADD_VIDf_SET
#define RX_DCB_DO_NOT_CHANGE_TTLf_GET BCM56800_A0_RX_DCB_DO_NOT_CHANGE_TTLf_GET
#define RX_DCB_DO_NOT_CHANGE_TTLf_SET BCM56800_A0_RX_DCB_DO_NOT_CHANGE_TTLf_SET
#define RX_DCB_HGIf_GET BCM56800_A0_RX_DCB_HGIf_GET
#define RX_DCB_HGIf_SET BCM56800_A0_RX_DCB_HGIf_SET
#define RX_DCB_SRC_HIGIG_TYPEf_GET BCM56800_A0_RX_DCB_SRC_HIGIG_TYPEf_GET
#define RX_DCB_SRC_HIGIG_TYPEf_SET BCM56800_A0_RX_DCB_SRC_HIGIG_TYPEf_SET
#define RX_DCB_MODULE_HEADERf_GET BCM56800_A0_RX_DCB_MODULE_HEADERf_GET
#define RX_DCB_MODULE_HEADERf_SET BCM56800_A0_RX_DCB_MODULE_HEADERf_SET
#define RX_DCB_MODULE_HEADERf_PTR BCM56800_A0_RX_DCB_MODULE_HEADERf_PTR
#define RX_DCB_BYTE_COUNTf_GET BCM56800_A0_RX_DCB_BYTE_COUNTf_GET
#define RX_DCB_BYTE_COUNTf_SET BCM56800_A0_RX_DCB_BYTE_COUNTf_SET
#define RX_DCB_CHAINf_GET BCM56800_A0_RX_DCB_CHAINf_GET
#define RX_DCB_CHAINf_SET BCM56800_A0_RX_DCB_CHAINf_SET
#define RX_DCB_SGf_GET BCM56800_A0_RX_DCB_SGf_GET
#define RX_DCB_SGf_SET BCM56800_A0_RX_DCB_SGf_SET
#define RX_DCB_RELOADf_GET BCM56800_A0_RX_DCB_RELOADf_GET
#define RX_DCB_RELOADf_SET BCM56800_A0_RX_DCB_RELOADf_SET
#define RX_DCB_ADDRf_GET BCM56800_A0_RX_DCB_ADDRf_GET
#define RX_DCB_ADDRf_SET BCM56800_A0_RX_DCB_ADDRf_SET
#define READ_RX_DCB BCM56800_A0_READ_RX_DCB
#define WRITE_RX_DCB BCM56800_A0_WRITE_RX_DCB

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_RX_DCB'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SBS_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     IP main arbiter control register for number of ports
 * SIZE:     32
 * FIELDS:
 *     PIPE_SELECT      To select IPX or IPY for shadow register reads and access type 6 write and read.
 *
 ******************************************************************************/
#define BCM56800_A0_SBS_CONTROLr 0x0f180600

#define BCM56800_A0_SBS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SBS_CONTROL.
 *
 */
typedef union BCM56800_A0_SBS_CONTROLr_s {
	uint32_t v[1];
	uint32_t sbs_control[1];
	uint32_t _sbs_control;
} BCM56800_A0_SBS_CONTROLr_t;

#define BCM56800_A0_SBS_CONTROLr_CLR(r) (r).sbs_control[0] = 0
#define BCM56800_A0_SBS_CONTROLr_SET(r,d) (r).sbs_control[0] = d
#define BCM56800_A0_SBS_CONTROLr_GET(r) (r).sbs_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SBS_CONTROLr_PIPE_SELECTf_GET(r) (((r).sbs_control[0]) & 0x1)
#define BCM56800_A0_SBS_CONTROLr_PIPE_SELECTf_SET(r,f) (r).sbs_control[0]=(((r).sbs_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access SBS_CONTROL.
 *
 */
#define BCM56800_A0_READ_SBS_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_SBS_CONTROLr,(r._sbs_control))
#define BCM56800_A0_WRITE_SBS_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_SBS_CONTROLr,&(r._sbs_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SBS_CONTROLr BCM56800_A0_SBS_CONTROLr
#define SBS_CONTROLr_SIZE BCM56800_A0_SBS_CONTROLr_SIZE
typedef BCM56800_A0_SBS_CONTROLr_t SBS_CONTROLr_t;
#define SBS_CONTROLr_CLR BCM56800_A0_SBS_CONTROLr_CLR
#define SBS_CONTROLr_SET BCM56800_A0_SBS_CONTROLr_SET
#define SBS_CONTROLr_GET BCM56800_A0_SBS_CONTROLr_GET
#define SBS_CONTROLr_PIPE_SELECTf_GET BCM56800_A0_SBS_CONTROLr_PIPE_SELECTf_GET
#define SBS_CONTROLr_PIPE_SELECTf_SET BCM56800_A0_SBS_CONTROLr_PIPE_SELECTf_SET
#define READ_SBS_CONTROLr BCM56800_A0_READ_SBS_CONTROLr
#define WRITE_SBS_CONTROLr BCM56800_A0_WRITE_SBS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SBS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SFLOW_EGR_RAND_SEED
 * BLOCKS:   IPIPE
 * DESC:     sFlow Egress Random Number Generator Seed Register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     SEED             Seed for sFlow Egress Random Number Generator
 *
 ******************************************************************************/
#define BCM56800_A0_SFLOW_EGR_RAND_SEEDr 0x0e180621

#define BCM56800_A0_SFLOW_EGR_RAND_SEEDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_EGR_RAND_SEED.
 *
 */
typedef union BCM56800_A0_SFLOW_EGR_RAND_SEEDr_s {
	uint32_t v[1];
	uint32_t sflow_egr_rand_seed[1];
	uint32_t _sflow_egr_rand_seed;
} BCM56800_A0_SFLOW_EGR_RAND_SEEDr_t;

#define BCM56800_A0_SFLOW_EGR_RAND_SEEDr_CLR(r) (r).sflow_egr_rand_seed[0] = 0
#define BCM56800_A0_SFLOW_EGR_RAND_SEEDr_SET(r,d) (r).sflow_egr_rand_seed[0] = d
#define BCM56800_A0_SFLOW_EGR_RAND_SEEDr_GET(r) (r).sflow_egr_rand_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_GET(r) (((r).sflow_egr_rand_seed[0]) & 0x1ffffff)
#define BCM56800_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_SET(r,f) (r).sflow_egr_rand_seed[0]=(((r).sflow_egr_rand_seed[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SFLOW_EGR_RAND_SEED.
 *
 */
#define BCM56800_A0_READ_SFLOW_EGR_RAND_SEEDr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_SFLOW_EGR_RAND_SEEDr,(r._sflow_egr_rand_seed))
#define BCM56800_A0_WRITE_SFLOW_EGR_RAND_SEEDr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_SFLOW_EGR_RAND_SEEDr,&(r._sflow_egr_rand_seed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_EGR_RAND_SEEDr BCM56800_A0_SFLOW_EGR_RAND_SEEDr
#define SFLOW_EGR_RAND_SEEDr_SIZE BCM56800_A0_SFLOW_EGR_RAND_SEEDr_SIZE
typedef BCM56800_A0_SFLOW_EGR_RAND_SEEDr_t SFLOW_EGR_RAND_SEEDr_t;
#define SFLOW_EGR_RAND_SEEDr_CLR BCM56800_A0_SFLOW_EGR_RAND_SEEDr_CLR
#define SFLOW_EGR_RAND_SEEDr_SET BCM56800_A0_SFLOW_EGR_RAND_SEEDr_SET
#define SFLOW_EGR_RAND_SEEDr_GET BCM56800_A0_SFLOW_EGR_RAND_SEEDr_GET
#define SFLOW_EGR_RAND_SEEDr_SEEDf_GET BCM56800_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_GET
#define SFLOW_EGR_RAND_SEEDr_SEEDf_SET BCM56800_A0_SFLOW_EGR_RAND_SEEDr_SEEDf_SET
#define READ_SFLOW_EGR_RAND_SEEDr BCM56800_A0_READ_SFLOW_EGR_RAND_SEEDr
#define WRITE_SFLOW_EGR_RAND_SEEDr BCM56800_A0_WRITE_SFLOW_EGR_RAND_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SFLOW_EGR_RAND_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SFLOW_EGR_THRESHOLD
 * BLOCKS:   IPIPE
 * DESC:     sFlow Egress Threshold Register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        sFlow Egress Threshold Value
 *     ENABLE           Enable sFlow Egress
 *
 ******************************************************************************/
#define BCM56800_A0_SFLOW_EGR_THRESHOLDr 0x0e100661

#define BCM56800_A0_SFLOW_EGR_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_EGR_THRESHOLD.
 *
 */
typedef union BCM56800_A0_SFLOW_EGR_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t sflow_egr_threshold[1];
	uint32_t _sflow_egr_threshold;
} BCM56800_A0_SFLOW_EGR_THRESHOLDr_t;

#define BCM56800_A0_SFLOW_EGR_THRESHOLDr_CLR(r) (r).sflow_egr_threshold[0] = 0
#define BCM56800_A0_SFLOW_EGR_THRESHOLDr_SET(r,d) (r).sflow_egr_threshold[0] = d
#define BCM56800_A0_SFLOW_EGR_THRESHOLDr_GET(r) (r).sflow_egr_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET(r) (((r).sflow_egr_threshold[0]) & 0xffff)
#define BCM56800_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET(r,f) (r).sflow_egr_threshold[0]=(((r).sflow_egr_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_GET(r) ((((r).sflow_egr_threshold[0]) >> 16) & 0x1)
#define BCM56800_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_SET(r,f) (r).sflow_egr_threshold[0]=(((r).sflow_egr_threshold[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access SFLOW_EGR_THRESHOLD.
 *
 */
#define BCM56800_A0_READ_SFLOW_EGR_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_SFLOW_EGR_THRESHOLDr,(r._sflow_egr_threshold))
#define BCM56800_A0_WRITE_SFLOW_EGR_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_SFLOW_EGR_THRESHOLDr,&(r._sflow_egr_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_EGR_THRESHOLDr BCM56800_A0_SFLOW_EGR_THRESHOLDr
#define SFLOW_EGR_THRESHOLDr_SIZE BCM56800_A0_SFLOW_EGR_THRESHOLDr_SIZE
typedef BCM56800_A0_SFLOW_EGR_THRESHOLDr_t SFLOW_EGR_THRESHOLDr_t;
#define SFLOW_EGR_THRESHOLDr_CLR BCM56800_A0_SFLOW_EGR_THRESHOLDr_CLR
#define SFLOW_EGR_THRESHOLDr_SET BCM56800_A0_SFLOW_EGR_THRESHOLDr_SET
#define SFLOW_EGR_THRESHOLDr_GET BCM56800_A0_SFLOW_EGR_THRESHOLDr_GET
#define SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET BCM56800_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_GET
#define SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET BCM56800_A0_SFLOW_EGR_THRESHOLDr_THRESHOLDf_SET
#define SFLOW_EGR_THRESHOLDr_ENABLEf_GET BCM56800_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_GET
#define SFLOW_EGR_THRESHOLDr_ENABLEf_SET BCM56800_A0_SFLOW_EGR_THRESHOLDr_ENABLEf_SET
#define READ_SFLOW_EGR_THRESHOLDr BCM56800_A0_READ_SFLOW_EGR_THRESHOLDr
#define WRITE_SFLOW_EGR_THRESHOLDr BCM56800_A0_WRITE_SFLOW_EGR_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SFLOW_EGR_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SFLOW_ING_RAND_SEED
 * BLOCKS:   IPIPE
 * DESC:     sFlow Ingress Random Number Generator Seed Register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     SEED             Seed for sFlow Ingress Random Number Generator
 *
 ******************************************************************************/
#define BCM56800_A0_SFLOW_ING_RAND_SEEDr 0x0e180620

#define BCM56800_A0_SFLOW_ING_RAND_SEEDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_ING_RAND_SEED.
 *
 */
typedef union BCM56800_A0_SFLOW_ING_RAND_SEEDr_s {
	uint32_t v[1];
	uint32_t sflow_ing_rand_seed[1];
	uint32_t _sflow_ing_rand_seed;
} BCM56800_A0_SFLOW_ING_RAND_SEEDr_t;

#define BCM56800_A0_SFLOW_ING_RAND_SEEDr_CLR(r) (r).sflow_ing_rand_seed[0] = 0
#define BCM56800_A0_SFLOW_ING_RAND_SEEDr_SET(r,d) (r).sflow_ing_rand_seed[0] = d
#define BCM56800_A0_SFLOW_ING_RAND_SEEDr_GET(r) (r).sflow_ing_rand_seed[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SFLOW_ING_RAND_SEEDr_SEEDf_GET(r) (((r).sflow_ing_rand_seed[0]) & 0x1ffffff)
#define BCM56800_A0_SFLOW_ING_RAND_SEEDr_SEEDf_SET(r,f) (r).sflow_ing_rand_seed[0]=(((r).sflow_ing_rand_seed[0] & ~((uint32_t)0x1ffffff)) | (((uint32_t)f) & 0x1ffffff))

/*
 * These macros can be used to access SFLOW_ING_RAND_SEED.
 *
 */
#define BCM56800_A0_READ_SFLOW_ING_RAND_SEEDr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_SFLOW_ING_RAND_SEEDr,(r._sflow_ing_rand_seed))
#define BCM56800_A0_WRITE_SFLOW_ING_RAND_SEEDr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_SFLOW_ING_RAND_SEEDr,&(r._sflow_ing_rand_seed))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_ING_RAND_SEEDr BCM56800_A0_SFLOW_ING_RAND_SEEDr
#define SFLOW_ING_RAND_SEEDr_SIZE BCM56800_A0_SFLOW_ING_RAND_SEEDr_SIZE
typedef BCM56800_A0_SFLOW_ING_RAND_SEEDr_t SFLOW_ING_RAND_SEEDr_t;
#define SFLOW_ING_RAND_SEEDr_CLR BCM56800_A0_SFLOW_ING_RAND_SEEDr_CLR
#define SFLOW_ING_RAND_SEEDr_SET BCM56800_A0_SFLOW_ING_RAND_SEEDr_SET
#define SFLOW_ING_RAND_SEEDr_GET BCM56800_A0_SFLOW_ING_RAND_SEEDr_GET
#define SFLOW_ING_RAND_SEEDr_SEEDf_GET BCM56800_A0_SFLOW_ING_RAND_SEEDr_SEEDf_GET
#define SFLOW_ING_RAND_SEEDr_SEEDf_SET BCM56800_A0_SFLOW_ING_RAND_SEEDr_SEEDf_SET
#define READ_SFLOW_ING_RAND_SEEDr BCM56800_A0_READ_SFLOW_ING_RAND_SEEDr
#define WRITE_SFLOW_ING_RAND_SEEDr BCM56800_A0_WRITE_SFLOW_ING_RAND_SEEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SFLOW_ING_RAND_SEEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SFLOW_ING_THRESHOLD
 * BLOCKS:   IPIPE
 * DESC:     sFlow Ingress Threshold Register, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     THRESHOLD        sFlow Ingress Threshold Value
 *     ENABLE           Enable sFlow Ingress
 *
 ******************************************************************************/
#define BCM56800_A0_SFLOW_ING_THRESHOLDr 0x0e100060

#define BCM56800_A0_SFLOW_ING_THRESHOLDr_SIZE 4

/*
 * This structure should be used to declare and program SFLOW_ING_THRESHOLD.
 *
 */
typedef union BCM56800_A0_SFLOW_ING_THRESHOLDr_s {
	uint32_t v[1];
	uint32_t sflow_ing_threshold[1];
	uint32_t _sflow_ing_threshold;
} BCM56800_A0_SFLOW_ING_THRESHOLDr_t;

#define BCM56800_A0_SFLOW_ING_THRESHOLDr_CLR(r) (r).sflow_ing_threshold[0] = 0
#define BCM56800_A0_SFLOW_ING_THRESHOLDr_SET(r,d) (r).sflow_ing_threshold[0] = d
#define BCM56800_A0_SFLOW_ING_THRESHOLDr_GET(r) (r).sflow_ing_threshold[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_GET(r) (((r).sflow_ing_threshold[0]) & 0xffff)
#define BCM56800_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_SET(r,f) (r).sflow_ing_threshold[0]=(((r).sflow_ing_threshold[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_SFLOW_ING_THRESHOLDr_ENABLEf_GET(r) ((((r).sflow_ing_threshold[0]) >> 16) & 0x1)
#define BCM56800_A0_SFLOW_ING_THRESHOLDr_ENABLEf_SET(r,f) (r).sflow_ing_threshold[0]=(((r).sflow_ing_threshold[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access SFLOW_ING_THRESHOLD.
 *
 */
#define BCM56800_A0_READ_SFLOW_ING_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_SFLOW_ING_THRESHOLDr,(r._sflow_ing_threshold))
#define BCM56800_A0_WRITE_SFLOW_ING_THRESHOLDr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_SFLOW_ING_THRESHOLDr,&(r._sflow_ing_threshold))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFLOW_ING_THRESHOLDr BCM56800_A0_SFLOW_ING_THRESHOLDr
#define SFLOW_ING_THRESHOLDr_SIZE BCM56800_A0_SFLOW_ING_THRESHOLDr_SIZE
typedef BCM56800_A0_SFLOW_ING_THRESHOLDr_t SFLOW_ING_THRESHOLDr_t;
#define SFLOW_ING_THRESHOLDr_CLR BCM56800_A0_SFLOW_ING_THRESHOLDr_CLR
#define SFLOW_ING_THRESHOLDr_SET BCM56800_A0_SFLOW_ING_THRESHOLDr_SET
#define SFLOW_ING_THRESHOLDr_GET BCM56800_A0_SFLOW_ING_THRESHOLDr_GET
#define SFLOW_ING_THRESHOLDr_THRESHOLDf_GET BCM56800_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_GET
#define SFLOW_ING_THRESHOLDr_THRESHOLDf_SET BCM56800_A0_SFLOW_ING_THRESHOLDr_THRESHOLDf_SET
#define SFLOW_ING_THRESHOLDr_ENABLEf_GET BCM56800_A0_SFLOW_ING_THRESHOLDr_ENABLEf_GET
#define SFLOW_ING_THRESHOLDr_ENABLEf_SET BCM56800_A0_SFLOW_ING_THRESHOLDr_ENABLEf_SET
#define READ_SFLOW_ING_THRESHOLDr BCM56800_A0_READ_SFLOW_ING_THRESHOLDr
#define WRITE_SFLOW_ING_THRESHOLDr BCM56800_A0_WRITE_SFLOW_ING_THRESHOLDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SFLOW_ING_THRESHOLDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     6
 * FIELDS:
 *     BSAFE            Software Block Flag for BSAFE
 *     CMIC             Software Block Flag for CMIC
 *     EPIPE            Software Block Flag for EPIPE
 *     GXPORT           Software Block Flag for GXPORT
 *     IPIPE            Software Block Flag for IPIPE
 *     MMU              Software Block Flag for MMU
 *
 ******************************************************************************/
#define BCM56800_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM56800_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM56800_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM56800_A0_SOFTWARE_BLOCKMAP_t;

#define BCM56800_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM56800_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM56800_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SOFTWARE_BLOCKMAP_BSAFEf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM56800_A0_SOFTWARE_BLOCKMAP_BSAFEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_SOFTWARE_BLOCKMAP_CMICf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM56800_A0_SOFTWARE_BLOCKMAP_CMICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_SOFTWARE_BLOCKMAP_EPIPEf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM56800_A0_SOFTWARE_BLOCKMAP_EPIPEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_SOFTWARE_BLOCKMAP_GXPORTf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM56800_A0_SOFTWARE_BLOCKMAP_GXPORTf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_SOFTWARE_BLOCKMAP_IPIPEf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM56800_A0_SOFTWARE_BLOCKMAP_IPIPEf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_SOFTWARE_BLOCKMAP_MMUf_GET(r) ((((r).software_blockmap[0]) >> 5) & 0x1)
#define BCM56800_A0_SOFTWARE_BLOCKMAP_MMUf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM56800_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM56800_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM56800_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM56800_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM56800_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM56800_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_BSAFEf_GET BCM56800_A0_SOFTWARE_BLOCKMAP_BSAFEf_GET
#define SOFTWARE_BLOCKMAP_BSAFEf_SET BCM56800_A0_SOFTWARE_BLOCKMAP_BSAFEf_SET
#define SOFTWARE_BLOCKMAP_CMICf_GET BCM56800_A0_SOFTWARE_BLOCKMAP_CMICf_GET
#define SOFTWARE_BLOCKMAP_CMICf_SET BCM56800_A0_SOFTWARE_BLOCKMAP_CMICf_SET
#define SOFTWARE_BLOCKMAP_EPIPEf_GET BCM56800_A0_SOFTWARE_BLOCKMAP_EPIPEf_GET
#define SOFTWARE_BLOCKMAP_EPIPEf_SET BCM56800_A0_SOFTWARE_BLOCKMAP_EPIPEf_SET
#define SOFTWARE_BLOCKMAP_GXPORTf_GET BCM56800_A0_SOFTWARE_BLOCKMAP_GXPORTf_GET
#define SOFTWARE_BLOCKMAP_GXPORTf_SET BCM56800_A0_SOFTWARE_BLOCKMAP_GXPORTf_SET
#define SOFTWARE_BLOCKMAP_IPIPEf_GET BCM56800_A0_SOFTWARE_BLOCKMAP_IPIPEf_GET
#define SOFTWARE_BLOCKMAP_IPIPEf_SET BCM56800_A0_SOFTWARE_BLOCKMAP_IPIPEf_SET
#define SOFTWARE_BLOCKMAP_MMUf_GET BCM56800_A0_SOFTWARE_BLOCKMAP_MMUf_GET
#define SOFTWARE_BLOCKMAP_MMUf_SET BCM56800_A0_SOFTWARE_BLOCKMAP_MMUf_SET
#define READ_SOFTWARE_BLOCKMAP BCM56800_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM56800_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  SOURCE_TRUNK_MAP_TABLE
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Map Table
 * SIZE:     9
 * FIELDS:
 *     PORT_TYPE        Indicates source port type
 *     TGID             Source port TGID
 *
 ******************************************************************************/
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm 0x02161000

#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_MIN 0
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_MAX 4095
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_CMAX(u) 4095
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_SIZE 2

/*
 * This structure should be used to declare and program SOURCE_TRUNK_MAP_TABLE.
 *
 */
typedef union BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_s {
	uint32_t v[1];
	uint32_t source_trunk_map_table[1];
	uint32_t _source_trunk_map_table;
} BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_t;

#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_CLR(r) (r).source_trunk_map_table[0] = 0
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_SET(r,d) (r).source_trunk_map_table[0] = d
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_GET(r) (r).source_trunk_map_table[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET(r) (((r).source_trunk_map_table[0]) & 0x3)
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET(r,f) (r).source_trunk_map_table[0]=(((r).source_trunk_map_table[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET(r) ((((r).source_trunk_map_table[0]) >> 2) & 0x7f)
#define BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET(r,f) (r).source_trunk_map_table[0]=(((r).source_trunk_map_table[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2))

/*
 * These macros can be used to access SOURCE_TRUNK_MAP_TABLE.
 *
 */
#define BCM56800_A0_READ_SOURCE_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm,i,(m._source_trunk_map_table),1)
#define BCM56800_A0_WRITE_SOURCE_TRUNK_MAP_TABLEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm,i,&(m._source_trunk_map_table),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOURCE_TRUNK_MAP_TABLEm BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm
#define SOURCE_TRUNK_MAP_TABLEm_MIN BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_MIN
#define SOURCE_TRUNK_MAP_TABLEm_MAX BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_MAX
#define SOURCE_TRUNK_MAP_TABLEm_CMAX(u) BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_CMAX(u)
#define SOURCE_TRUNK_MAP_TABLEm_SIZE BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_SIZE
typedef BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_t SOURCE_TRUNK_MAP_TABLEm_t;
#define SOURCE_TRUNK_MAP_TABLEm_CLR BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_CLR
#define SOURCE_TRUNK_MAP_TABLEm_SET BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_SET
#define SOURCE_TRUNK_MAP_TABLEm_GET BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_GET
#define SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_GET
#define SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_PORT_TYPEf_SET
#define SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_GET
#define SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm_TGIDf_SET
#define READ_SOURCE_TRUNK_MAP_TABLEm BCM56800_A0_READ_SOURCE_TRUNK_MAP_TABLEm
#define WRITE_SOURCE_TRUNK_MAP_TABLEm BCM56800_A0_WRITE_SOURCE_TRUNK_MAP_TABLEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SOURCE_TRUNK_MAP_TABLEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  SRC_MODID_BLOCK
 * BLOCKS:   IPIPE
 * DESC:     Source Modid based blocking mask table
 * SIZE:     21
 * FIELDS:
 *     HIGIG_XGE_PORT_BLOCK_MASK Block MASK for HiGig ports
 *     CPU_PORT_BLOCK_MASK Block Mask for CPU port
 *
 ******************************************************************************/
#define BCM56800_A0_SRC_MODID_BLOCKm 0x0e1aa000

#define BCM56800_A0_SRC_MODID_BLOCKm_MIN 0
#define BCM56800_A0_SRC_MODID_BLOCKm_MAX 2687
#define BCM56800_A0_SRC_MODID_BLOCKm_CMAX(u) 2687
#define BCM56800_A0_SRC_MODID_BLOCKm_SIZE 3

/*
 * This structure should be used to declare and program SRC_MODID_BLOCK.
 *
 */
typedef union BCM56800_A0_SRC_MODID_BLOCKm_s {
	uint32_t v[1];
	uint32_t src_modid_block[1];
	uint32_t _src_modid_block;
} BCM56800_A0_SRC_MODID_BLOCKm_t;

#define BCM56800_A0_SRC_MODID_BLOCKm_CLR(r) (r).src_modid_block[0] = 0
#define BCM56800_A0_SRC_MODID_BLOCKm_SET(r,d) (r).src_modid_block[0] = d
#define BCM56800_A0_SRC_MODID_BLOCKm_GET(r) (r).src_modid_block[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_GET(r) (((r).src_modid_block[0]) & 0xfffff)
#define BCM56800_A0_SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_SET(r,f) (r).src_modid_block[0]=(((r).src_modid_block[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM56800_A0_SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_GET(r) ((((r).src_modid_block[0]) >> 20) & 0x1)
#define BCM56800_A0_SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_SET(r,f) (r).src_modid_block[0]=(((r).src_modid_block[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access SRC_MODID_BLOCK.
 *
 */
#define BCM56800_A0_READ_SRC_MODID_BLOCKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_SRC_MODID_BLOCKm,i,(m._src_modid_block),1)
#define BCM56800_A0_WRITE_SRC_MODID_BLOCKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_SRC_MODID_BLOCKm,i,&(m._src_modid_block),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRC_MODID_BLOCKm BCM56800_A0_SRC_MODID_BLOCKm
#define SRC_MODID_BLOCKm_MIN BCM56800_A0_SRC_MODID_BLOCKm_MIN
#define SRC_MODID_BLOCKm_MAX BCM56800_A0_SRC_MODID_BLOCKm_MAX
#define SRC_MODID_BLOCKm_CMAX(u) BCM56800_A0_SRC_MODID_BLOCKm_CMAX(u)
#define SRC_MODID_BLOCKm_SIZE BCM56800_A0_SRC_MODID_BLOCKm_SIZE
typedef BCM56800_A0_SRC_MODID_BLOCKm_t SRC_MODID_BLOCKm_t;
#define SRC_MODID_BLOCKm_CLR BCM56800_A0_SRC_MODID_BLOCKm_CLR
#define SRC_MODID_BLOCKm_SET BCM56800_A0_SRC_MODID_BLOCKm_SET
#define SRC_MODID_BLOCKm_GET BCM56800_A0_SRC_MODID_BLOCKm_GET
#define SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_GET BCM56800_A0_SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_GET
#define SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_SET BCM56800_A0_SRC_MODID_BLOCKm_HIGIG_XGE_PORT_BLOCK_MASKf_SET
#define SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_GET BCM56800_A0_SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_GET
#define SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_SET BCM56800_A0_SRC_MODID_BLOCKm_CPU_PORT_BLOCK_MASKf_SET
#define READ_SRC_MODID_BLOCKm BCM56800_A0_READ_SRC_MODID_BLOCKm
#define WRITE_SRC_MODID_BLOCKm BCM56800_A0_WRITE_SRC_MODID_BLOCKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SRC_MODID_BLOCKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  STG_TAB
 * BLOCKS:   IPIPE
 * DESC:     Spanning Tree Group state table, FeatureSpecific-Ethernet
 * SIZE:     40
 * FIELDS:
 *     SP_TREE_PORT0    Spanning Tree State for port 0
 *     SP_TREE_PORT1    Spanning Tree State for port 1
 *     SP_TREE_PORT2    Spanning Tree State for port 2
 *     SP_TREE_PORT3    Spanning Tree State for port 3
 *     SP_TREE_PORT4    Spanning Tree State for port 4
 *     SP_TREE_PORT5    Spanning Tree State for port 5
 *     SP_TREE_PORT6    Spanning Tree State for port 6
 *     SP_TREE_PORT7    Spanning Tree State for port 7
 *     SP_TREE_PORT8    Spanning Tree State for port 8
 *     SP_TREE_PORT9    Spanning Tree State for port 9
 *     SP_TREE_PORT10   Spanning Tree State for port 10
 *     SP_TREE_PORT11   Spanning Tree State for port 11
 *     SP_TREE_PORT12   Spanning Tree State for port 12
 *     SP_TREE_PORT13   Spanning Tree State for port 13
 *     SP_TREE_PORT14   Spanning Tree State for port 14
 *     SP_TREE_PORT15   Spanning Tree State for port 15
 *     SP_TREE_PORT16   Spanning Tree State for port 16
 *     SP_TREE_PORT17   Spanning Tree State for port 17
 *     SP_TREE_PORT18   Spanning Tree State for port 18
 *     SP_TREE_PORT19   Spanning Tree State for port 19
 *
 ******************************************************************************/
#define BCM56800_A0_STG_TABm 0x05161000

#define BCM56800_A0_STG_TABm_MIN 0
#define BCM56800_A0_STG_TABm_MAX 255
#define BCM56800_A0_STG_TABm_CMAX(u) 255
#define BCM56800_A0_STG_TABm_SIZE 5

/*
 * This structure should be used to declare and program STG_TAB.
 *
 */
typedef union BCM56800_A0_STG_TABm_s {
	uint32_t v[2];
	uint32_t stg_tab[2];
	uint32_t _stg_tab;
} BCM56800_A0_STG_TABm_t;

#define BCM56800_A0_STG_TABm_CLR(r) CDK_MEMSET(&((r)._stg_tab), 0, sizeof(BCM56800_A0_STG_TABm_t))
#define BCM56800_A0_STG_TABm_SET(r,i,d) (r).stg_tab[i] = d
#define BCM56800_A0_STG_TABm_GET(r,i) (r).stg_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_STG_TABm_SP_TREE_PORT0f_GET(r) (((r).stg_tab[0]) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT0f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT1f_GET(r) ((((r).stg_tab[0]) >> 2) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT1f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT2f_GET(r) ((((r).stg_tab[0]) >> 4) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT2f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT3f_GET(r) ((((r).stg_tab[0]) >> 6) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT3f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT4f_GET(r) ((((r).stg_tab[0]) >> 8) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT4f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT5f_GET(r) ((((r).stg_tab[0]) >> 10) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT5f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT6f_GET(r) ((((r).stg_tab[0]) >> 12) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT6f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT7f_GET(r) ((((r).stg_tab[0]) >> 14) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT7f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT8f_GET(r) ((((r).stg_tab[0]) >> 16) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT8f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT9f_GET(r) ((((r).stg_tab[0]) >> 18) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT9f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT10f_GET(r) ((((r).stg_tab[0]) >> 20) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT10f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 20)) | ((((uint32_t)f) & 0x3) << 20))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT11f_GET(r) ((((r).stg_tab[0]) >> 22) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT11f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 22)) | ((((uint32_t)f) & 0x3) << 22))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT12f_GET(r) ((((r).stg_tab[0]) >> 24) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT12f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT13f_GET(r) ((((r).stg_tab[0]) >> 26) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT13f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT14f_GET(r) ((((r).stg_tab[0]) >> 28) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT14f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 28)) | ((((uint32_t)f) & 0x3) << 28))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT15f_GET(r) ((((r).stg_tab[0]) >> 30) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT15f_SET(r,f) (r).stg_tab[0]=(((r).stg_tab[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT16f_GET(r) (((r).stg_tab[1]) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT16f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT17f_GET(r) ((((r).stg_tab[1]) >> 2) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT17f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT18f_GET(r) ((((r).stg_tab[1]) >> 4) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT18f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM56800_A0_STG_TABm_SP_TREE_PORT19f_GET(r) ((((r).stg_tab[1]) >> 6) & 0x3)
#define BCM56800_A0_STG_TABm_SP_TREE_PORT19f_SET(r,f) (r).stg_tab[1]=(((r).stg_tab[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access STG_TAB.
 *
 */
#define BCM56800_A0_READ_STG_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_STG_TABm,i,(m._stg_tab),2)
#define BCM56800_A0_WRITE_STG_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_STG_TABm,i,&(m._stg_tab),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STG_TABm BCM56800_A0_STG_TABm
#define STG_TABm_MIN BCM56800_A0_STG_TABm_MIN
#define STG_TABm_MAX BCM56800_A0_STG_TABm_MAX
#define STG_TABm_CMAX(u) BCM56800_A0_STG_TABm_CMAX(u)
#define STG_TABm_SIZE BCM56800_A0_STG_TABm_SIZE
typedef BCM56800_A0_STG_TABm_t STG_TABm_t;
#define STG_TABm_CLR BCM56800_A0_STG_TABm_CLR
#define STG_TABm_SET BCM56800_A0_STG_TABm_SET
#define STG_TABm_GET BCM56800_A0_STG_TABm_GET
#define STG_TABm_SP_TREE_PORT0f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT0f_GET
#define STG_TABm_SP_TREE_PORT0f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT0f_SET
#define STG_TABm_SP_TREE_PORT1f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT1f_GET
#define STG_TABm_SP_TREE_PORT1f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT1f_SET
#define STG_TABm_SP_TREE_PORT2f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT2f_GET
#define STG_TABm_SP_TREE_PORT2f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT2f_SET
#define STG_TABm_SP_TREE_PORT3f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT3f_GET
#define STG_TABm_SP_TREE_PORT3f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT3f_SET
#define STG_TABm_SP_TREE_PORT4f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT4f_GET
#define STG_TABm_SP_TREE_PORT4f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT4f_SET
#define STG_TABm_SP_TREE_PORT5f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT5f_GET
#define STG_TABm_SP_TREE_PORT5f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT5f_SET
#define STG_TABm_SP_TREE_PORT6f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT6f_GET
#define STG_TABm_SP_TREE_PORT6f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT6f_SET
#define STG_TABm_SP_TREE_PORT7f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT7f_GET
#define STG_TABm_SP_TREE_PORT7f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT7f_SET
#define STG_TABm_SP_TREE_PORT8f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT8f_GET
#define STG_TABm_SP_TREE_PORT8f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT8f_SET
#define STG_TABm_SP_TREE_PORT9f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT9f_GET
#define STG_TABm_SP_TREE_PORT9f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT9f_SET
#define STG_TABm_SP_TREE_PORT10f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT10f_GET
#define STG_TABm_SP_TREE_PORT10f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT10f_SET
#define STG_TABm_SP_TREE_PORT11f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT11f_GET
#define STG_TABm_SP_TREE_PORT11f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT11f_SET
#define STG_TABm_SP_TREE_PORT12f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT12f_GET
#define STG_TABm_SP_TREE_PORT12f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT12f_SET
#define STG_TABm_SP_TREE_PORT13f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT13f_GET
#define STG_TABm_SP_TREE_PORT13f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT13f_SET
#define STG_TABm_SP_TREE_PORT14f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT14f_GET
#define STG_TABm_SP_TREE_PORT14f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT14f_SET
#define STG_TABm_SP_TREE_PORT15f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT15f_GET
#define STG_TABm_SP_TREE_PORT15f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT15f_SET
#define STG_TABm_SP_TREE_PORT16f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT16f_GET
#define STG_TABm_SP_TREE_PORT16f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT16f_SET
#define STG_TABm_SP_TREE_PORT17f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT17f_GET
#define STG_TABm_SP_TREE_PORT17f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT17f_SET
#define STG_TABm_SP_TREE_PORT18f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT18f_GET
#define STG_TABm_SP_TREE_PORT18f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT18f_SET
#define STG_TABm_SP_TREE_PORT19f_GET BCM56800_A0_STG_TABm_SP_TREE_PORT19f_GET
#define STG_TABm_SP_TREE_PORT19f_SET BCM56800_A0_STG_TABm_SP_TREE_PORT19f_SET
#define READ_STG_TABm BCM56800_A0_READ_STG_TABm
#define WRITE_STG_TABm BCM56800_A0_WRITE_STG_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_STG_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SW2_HW_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     Sw2 Control for Hardware functions
 * SIZE:     32
 * FIELDS:
 *     HOL_STAT_UPDATE_ENABLE Enables status updates of HOL_STAT_BMAP registers via the CPU (for testing purposes).  When not enabled, this status register is updated continuously by hardware with data from the MMU, and any write by CPU will be over-written immediately.
 *     LINK_STATUS_UPDATE_ENABLE Enables status updates of LINK_STATUS register via the CPU (for testing purposes).  When not enabled, this status register is updated continuously by hardward with data directly from the GXPort, and any write by CPU will be over-written immediately.
 *     BKP_DISC_PRIORITY_UPDATE_ENABLE Enables status updates of BKP_DISC_PRIORITY register via the CPU (for testing purposes).  When not enabled, this status register is updated continuously by hardward with data directly from the MMU, and any write by CPU will be over-written immediately.
 *
 ******************************************************************************/
#define BCM56800_A0_SW2_HW_CONTROLr 0x0e180652

#define BCM56800_A0_SW2_HW_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SW2_HW_CONTROL.
 *
 */
typedef union BCM56800_A0_SW2_HW_CONTROLr_s {
	uint32_t v[1];
	uint32_t sw2_hw_control[1];
	uint32_t _sw2_hw_control;
} BCM56800_A0_SW2_HW_CONTROLr_t;

#define BCM56800_A0_SW2_HW_CONTROLr_CLR(r) (r).sw2_hw_control[0] = 0
#define BCM56800_A0_SW2_HW_CONTROLr_SET(r,d) (r).sw2_hw_control[0] = d
#define BCM56800_A0_SW2_HW_CONTROLr_GET(r) (r).sw2_hw_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SW2_HW_CONTROLr_HOL_STAT_UPDATE_ENABLEf_GET(r) (((r).sw2_hw_control[0]) & 0x1)
#define BCM56800_A0_SW2_HW_CONTROLr_HOL_STAT_UPDATE_ENABLEf_SET(r,f) (r).sw2_hw_control[0]=(((r).sw2_hw_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_SW2_HW_CONTROLr_LINK_STATUS_UPDATE_ENABLEf_GET(r) ((((r).sw2_hw_control[0]) >> 1) & 0x1)
#define BCM56800_A0_SW2_HW_CONTROLr_LINK_STATUS_UPDATE_ENABLEf_SET(r,f) (r).sw2_hw_control[0]=(((r).sw2_hw_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_SW2_HW_CONTROLr_BKP_DISC_PRIORITY_UPDATE_ENABLEf_GET(r) ((((r).sw2_hw_control[0]) >> 2) & 0x1)
#define BCM56800_A0_SW2_HW_CONTROLr_BKP_DISC_PRIORITY_UPDATE_ENABLEf_SET(r,f) (r).sw2_hw_control[0]=(((r).sw2_hw_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access SW2_HW_CONTROL.
 *
 */
#define BCM56800_A0_READ_SW2_HW_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_SW2_HW_CONTROLr,(r._sw2_hw_control))
#define BCM56800_A0_WRITE_SW2_HW_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_SW2_HW_CONTROLr,&(r._sw2_hw_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SW2_HW_CONTROLr BCM56800_A0_SW2_HW_CONTROLr
#define SW2_HW_CONTROLr_SIZE BCM56800_A0_SW2_HW_CONTROLr_SIZE
typedef BCM56800_A0_SW2_HW_CONTROLr_t SW2_HW_CONTROLr_t;
#define SW2_HW_CONTROLr_CLR BCM56800_A0_SW2_HW_CONTROLr_CLR
#define SW2_HW_CONTROLr_SET BCM56800_A0_SW2_HW_CONTROLr_SET
#define SW2_HW_CONTROLr_GET BCM56800_A0_SW2_HW_CONTROLr_GET
#define SW2_HW_CONTROLr_HOL_STAT_UPDATE_ENABLEf_GET BCM56800_A0_SW2_HW_CONTROLr_HOL_STAT_UPDATE_ENABLEf_GET
#define SW2_HW_CONTROLr_HOL_STAT_UPDATE_ENABLEf_SET BCM56800_A0_SW2_HW_CONTROLr_HOL_STAT_UPDATE_ENABLEf_SET
#define SW2_HW_CONTROLr_LINK_STATUS_UPDATE_ENABLEf_GET BCM56800_A0_SW2_HW_CONTROLr_LINK_STATUS_UPDATE_ENABLEf_GET
#define SW2_HW_CONTROLr_LINK_STATUS_UPDATE_ENABLEf_SET BCM56800_A0_SW2_HW_CONTROLr_LINK_STATUS_UPDATE_ENABLEf_SET
#define SW2_HW_CONTROLr_BKP_DISC_PRIORITY_UPDATE_ENABLEf_GET BCM56800_A0_SW2_HW_CONTROLr_BKP_DISC_PRIORITY_UPDATE_ENABLEf_GET
#define SW2_HW_CONTROLr_BKP_DISC_PRIORITY_UPDATE_ENABLEf_SET BCM56800_A0_SW2_HW_CONTROLr_BKP_DISC_PRIORITY_UPDATE_ENABLEf_SET
#define READ_SW2_HW_CONTROLr BCM56800_A0_READ_SW2_HW_CONTROLr
#define WRITE_SW2_HW_CONTROLr BCM56800_A0_WRITE_SW2_HW_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SW2_HW_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SW2_RAM_CONTROL_1
 * BLOCKS:   IPIPE
 * DESC:     Debug Register to drive the TM inputs of internal rams
 * SIZE:     32
 * FIELDS:
 *     TRUNK_BITMAP_TM  
 *     TRUNK_EGR_MASK_TM 
 *     ALTERNATE_EMIRROR_BITMAP_TM 
 *     TRUNK_GROUP_TM   
 *     EGR_MASK_TM      
 *     SRC_MODID_BLOCK_TM 
 *     MODPORT_MAP_SW_TM 
 *     MODPORT_MAP_IM_TM 
 *
 ******************************************************************************/
#define BCM56800_A0_SW2_RAM_CONTROL_1r 0x0e180c50

#define BCM56800_A0_SW2_RAM_CONTROL_1r_SIZE 4

/*
 * This structure should be used to declare and program SW2_RAM_CONTROL_1.
 *
 */
typedef union BCM56800_A0_SW2_RAM_CONTROL_1r_s {
	uint32_t v[1];
	uint32_t sw2_ram_control_1[1];
	uint32_t _sw2_ram_control_1;
} BCM56800_A0_SW2_RAM_CONTROL_1r_t;

#define BCM56800_A0_SW2_RAM_CONTROL_1r_CLR(r) (r).sw2_ram_control_1[0] = 0
#define BCM56800_A0_SW2_RAM_CONTROL_1r_SET(r,d) (r).sw2_ram_control_1[0] = d
#define BCM56800_A0_SW2_RAM_CONTROL_1r_GET(r) (r).sw2_ram_control_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_BITMAP_TMf_GET(r) (((r).sw2_ram_control_1[0]) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_BITMAP_TMf_SET(r,f) (r).sw2_ram_control_1[0]=(((r).sw2_ram_control_1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_EGR_MASK_TMf_GET(r) ((((r).sw2_ram_control_1[0]) >> 4) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_EGR_MASK_TMf_SET(r,f) (r).sw2_ram_control_1[0]=(((r).sw2_ram_control_1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM56800_A0_SW2_RAM_CONTROL_1r_ALTERNATE_EMIRROR_BITMAP_TMf_GET(r) ((((r).sw2_ram_control_1[0]) >> 8) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_1r_ALTERNATE_EMIRROR_BITMAP_TMf_SET(r,f) (r).sw2_ram_control_1[0]=(((r).sw2_ram_control_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_GROUP_TMf_GET(r) ((((r).sw2_ram_control_1[0]) >> 12) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_GROUP_TMf_SET(r,f) (r).sw2_ram_control_1[0]=(((r).sw2_ram_control_1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM56800_A0_SW2_RAM_CONTROL_1r_EGR_MASK_TMf_GET(r) ((((r).sw2_ram_control_1[0]) >> 16) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_1r_EGR_MASK_TMf_SET(r,f) (r).sw2_ram_control_1[0]=(((r).sw2_ram_control_1[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM56800_A0_SW2_RAM_CONTROL_1r_SRC_MODID_BLOCK_TMf_GET(r) ((((r).sw2_ram_control_1[0]) >> 20) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_1r_SRC_MODID_BLOCK_TMf_SET(r,f) (r).sw2_ram_control_1[0]=(((r).sw2_ram_control_1[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM56800_A0_SW2_RAM_CONTROL_1r_MODPORT_MAP_SW_TMf_GET(r) ((((r).sw2_ram_control_1[0]) >> 24) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_1r_MODPORT_MAP_SW_TMf_SET(r,f) (r).sw2_ram_control_1[0]=(((r).sw2_ram_control_1[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM56800_A0_SW2_RAM_CONTROL_1r_MODPORT_MAP_IM_TMf_GET(r) ((((r).sw2_ram_control_1[0]) >> 28) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_1r_MODPORT_MAP_IM_TMf_SET(r,f) (r).sw2_ram_control_1[0]=(((r).sw2_ram_control_1[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access SW2_RAM_CONTROL_1.
 *
 */
#define BCM56800_A0_READ_SW2_RAM_CONTROL_1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_SW2_RAM_CONTROL_1r,(r._sw2_ram_control_1))
#define BCM56800_A0_WRITE_SW2_RAM_CONTROL_1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_SW2_RAM_CONTROL_1r,&(r._sw2_ram_control_1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SW2_RAM_CONTROL_1r BCM56800_A0_SW2_RAM_CONTROL_1r
#define SW2_RAM_CONTROL_1r_SIZE BCM56800_A0_SW2_RAM_CONTROL_1r_SIZE
typedef BCM56800_A0_SW2_RAM_CONTROL_1r_t SW2_RAM_CONTROL_1r_t;
#define SW2_RAM_CONTROL_1r_CLR BCM56800_A0_SW2_RAM_CONTROL_1r_CLR
#define SW2_RAM_CONTROL_1r_SET BCM56800_A0_SW2_RAM_CONTROL_1r_SET
#define SW2_RAM_CONTROL_1r_GET BCM56800_A0_SW2_RAM_CONTROL_1r_GET
#define SW2_RAM_CONTROL_1r_TRUNK_BITMAP_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_BITMAP_TMf_GET
#define SW2_RAM_CONTROL_1r_TRUNK_BITMAP_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_BITMAP_TMf_SET
#define SW2_RAM_CONTROL_1r_TRUNK_EGR_MASK_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_EGR_MASK_TMf_GET
#define SW2_RAM_CONTROL_1r_TRUNK_EGR_MASK_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_EGR_MASK_TMf_SET
#define SW2_RAM_CONTROL_1r_ALTERNATE_EMIRROR_BITMAP_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_1r_ALTERNATE_EMIRROR_BITMAP_TMf_GET
#define SW2_RAM_CONTROL_1r_ALTERNATE_EMIRROR_BITMAP_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_1r_ALTERNATE_EMIRROR_BITMAP_TMf_SET
#define SW2_RAM_CONTROL_1r_TRUNK_GROUP_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_GROUP_TMf_GET
#define SW2_RAM_CONTROL_1r_TRUNK_GROUP_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_1r_TRUNK_GROUP_TMf_SET
#define SW2_RAM_CONTROL_1r_EGR_MASK_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_1r_EGR_MASK_TMf_GET
#define SW2_RAM_CONTROL_1r_EGR_MASK_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_1r_EGR_MASK_TMf_SET
#define SW2_RAM_CONTROL_1r_SRC_MODID_BLOCK_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_1r_SRC_MODID_BLOCK_TMf_GET
#define SW2_RAM_CONTROL_1r_SRC_MODID_BLOCK_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_1r_SRC_MODID_BLOCK_TMf_SET
#define SW2_RAM_CONTROL_1r_MODPORT_MAP_SW_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_1r_MODPORT_MAP_SW_TMf_GET
#define SW2_RAM_CONTROL_1r_MODPORT_MAP_SW_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_1r_MODPORT_MAP_SW_TMf_SET
#define SW2_RAM_CONTROL_1r_MODPORT_MAP_IM_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_1r_MODPORT_MAP_IM_TMf_GET
#define SW2_RAM_CONTROL_1r_MODPORT_MAP_IM_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_1r_MODPORT_MAP_IM_TMf_SET
#define READ_SW2_RAM_CONTROL_1r BCM56800_A0_READ_SW2_RAM_CONTROL_1r
#define WRITE_SW2_RAM_CONTROL_1r BCM56800_A0_WRITE_SW2_RAM_CONTROL_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SW2_RAM_CONTROL_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SW2_RAM_CONTROL_2
 * BLOCKS:   IPIPE
 * DESC:     Debug Register to drive the TM inputs of internal rams
 * SIZE:     32
 * FIELDS:
 *     MODPORT_MAP_EM_TM 
 *     E2E_HOL_STATUS_TM E2E_HOL_STATUS is implemented using two physical dual port rams that are shared between IPX and IPY.  This register has two instances, one in each pipe.  The E2E_HOL_STATUS_TM field of the register in the IPX drives the TM input bits of the ram with data bits [127:0], and this field of the register in IPY drives the TM input bits of the ram with data bits [255:128].
 *
 ******************************************************************************/
#define BCM56800_A0_SW2_RAM_CONTROL_2r 0x0e180c51

#define BCM56800_A0_SW2_RAM_CONTROL_2r_SIZE 4

/*
 * This structure should be used to declare and program SW2_RAM_CONTROL_2.
 *
 */
typedef union BCM56800_A0_SW2_RAM_CONTROL_2r_s {
	uint32_t v[1];
	uint32_t sw2_ram_control_2[1];
	uint32_t _sw2_ram_control_2;
} BCM56800_A0_SW2_RAM_CONTROL_2r_t;

#define BCM56800_A0_SW2_RAM_CONTROL_2r_CLR(r) (r).sw2_ram_control_2[0] = 0
#define BCM56800_A0_SW2_RAM_CONTROL_2r_SET(r,d) (r).sw2_ram_control_2[0] = d
#define BCM56800_A0_SW2_RAM_CONTROL_2r_GET(r) (r).sw2_ram_control_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SW2_RAM_CONTROL_2r_MODPORT_MAP_EM_TMf_GET(r) (((r).sw2_ram_control_2[0]) & 0xf)
#define BCM56800_A0_SW2_RAM_CONTROL_2r_MODPORT_MAP_EM_TMf_SET(r,f) (r).sw2_ram_control_2[0]=(((r).sw2_ram_control_2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_SW2_RAM_CONTROL_2r_E2E_HOL_STATUS_TMf_GET(r) ((((r).sw2_ram_control_2[0]) >> 4) & 0xff)
#define BCM56800_A0_SW2_RAM_CONTROL_2r_E2E_HOL_STATUS_TMf_SET(r,f) (r).sw2_ram_control_2[0]=(((r).sw2_ram_control_2[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4))

/*
 * These macros can be used to access SW2_RAM_CONTROL_2.
 *
 */
#define BCM56800_A0_READ_SW2_RAM_CONTROL_2r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_SW2_RAM_CONTROL_2r,(r._sw2_ram_control_2))
#define BCM56800_A0_WRITE_SW2_RAM_CONTROL_2r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_SW2_RAM_CONTROL_2r,&(r._sw2_ram_control_2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SW2_RAM_CONTROL_2r BCM56800_A0_SW2_RAM_CONTROL_2r
#define SW2_RAM_CONTROL_2r_SIZE BCM56800_A0_SW2_RAM_CONTROL_2r_SIZE
typedef BCM56800_A0_SW2_RAM_CONTROL_2r_t SW2_RAM_CONTROL_2r_t;
#define SW2_RAM_CONTROL_2r_CLR BCM56800_A0_SW2_RAM_CONTROL_2r_CLR
#define SW2_RAM_CONTROL_2r_SET BCM56800_A0_SW2_RAM_CONTROL_2r_SET
#define SW2_RAM_CONTROL_2r_GET BCM56800_A0_SW2_RAM_CONTROL_2r_GET
#define SW2_RAM_CONTROL_2r_MODPORT_MAP_EM_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_2r_MODPORT_MAP_EM_TMf_GET
#define SW2_RAM_CONTROL_2r_MODPORT_MAP_EM_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_2r_MODPORT_MAP_EM_TMf_SET
#define SW2_RAM_CONTROL_2r_E2E_HOL_STATUS_TMf_GET BCM56800_A0_SW2_RAM_CONTROL_2r_E2E_HOL_STATUS_TMf_GET
#define SW2_RAM_CONTROL_2r_E2E_HOL_STATUS_TMf_SET BCM56800_A0_SW2_RAM_CONTROL_2r_E2E_HOL_STATUS_TMf_SET
#define READ_SW2_RAM_CONTROL_2r BCM56800_A0_READ_SW2_RAM_CONTROL_2r
#define WRITE_SW2_RAM_CONTROL_2r BCM56800_A0_WRITE_SW2_RAM_CONTROL_2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SW2_RAM_CONTROL_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  SYS_CONTROL
 * BLOCKS:   MMU
 * DESC:     CTR control
 * SIZE:     32
 * FIELDS:
 *     RESET_CNT        Reset all counters in CTR
 *
 ******************************************************************************/
#define BCM56800_A0_SYS_CONTROLr 0x0ed80000

#define BCM56800_A0_SYS_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program SYS_CONTROL.
 *
 */
typedef union BCM56800_A0_SYS_CONTROLr_s {
	uint32_t v[1];
	uint32_t sys_control[1];
	uint32_t _sys_control;
} BCM56800_A0_SYS_CONTROLr_t;

#define BCM56800_A0_SYS_CONTROLr_CLR(r) (r).sys_control[0] = 0
#define BCM56800_A0_SYS_CONTROLr_SET(r,d) (r).sys_control[0] = d
#define BCM56800_A0_SYS_CONTROLr_GET(r) (r).sys_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_SYS_CONTROLr_RESET_CNTf_GET(r) (((r).sys_control[0]) & 0x1)
#define BCM56800_A0_SYS_CONTROLr_RESET_CNTf_SET(r,f) (r).sys_control[0]=(((r).sys_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access SYS_CONTROL.
 *
 */
#define BCM56800_A0_READ_SYS_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_SYS_CONTROLr,(r._sys_control))
#define BCM56800_A0_WRITE_SYS_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_SYS_CONTROLr,&(r._sys_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SYS_CONTROLr BCM56800_A0_SYS_CONTROLr
#define SYS_CONTROLr_SIZE BCM56800_A0_SYS_CONTROLr_SIZE
typedef BCM56800_A0_SYS_CONTROLr_t SYS_CONTROLr_t;
#define SYS_CONTROLr_CLR BCM56800_A0_SYS_CONTROLr_CLR
#define SYS_CONTROLr_SET BCM56800_A0_SYS_CONTROLr_SET
#define SYS_CONTROLr_GET BCM56800_A0_SYS_CONTROLr_GET
#define SYS_CONTROLr_RESET_CNTf_GET BCM56800_A0_SYS_CONTROLr_RESET_CNTf_GET
#define SYS_CONTROLr_RESET_CNTf_SET BCM56800_A0_SYS_CONTROLr_RESET_CNTf_SET
#define READ_SYS_CONTROLr BCM56800_A0_READ_SYS_CONTROLr
#define WRITE_SYS_CONTROLr BCM56800_A0_WRITE_SYS_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_SYS_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC0
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #0
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC0r 0x0a400000

#define BCM56800_A0_TDBGC0r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC0.
 *
 */
typedef union BCM56800_A0_TDBGC0r_s {
	uint32_t v[1];
	uint32_t tdbgc0[1];
	uint32_t _tdbgc0;
} BCM56800_A0_TDBGC0r_t;

#define BCM56800_A0_TDBGC0r_CLR(r) (r).tdbgc0[0] = 0
#define BCM56800_A0_TDBGC0r_SET(r,d) (r).tdbgc0[0] = d
#define BCM56800_A0_TDBGC0r_GET(r) (r).tdbgc0[0]


/*
 * These macros can be used to access TDBGC0.
 *
 */
#define BCM56800_A0_READ_TDBGC0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC0r,(r._tdbgc0))
#define BCM56800_A0_WRITE_TDBGC0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC0r,&(r._tdbgc0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC0r BCM56800_A0_TDBGC0r
#define TDBGC0r_SIZE BCM56800_A0_TDBGC0r_SIZE
typedef BCM56800_A0_TDBGC0r_t TDBGC0r_t;
#define TDBGC0r_CLR BCM56800_A0_TDBGC0r_CLR
#define TDBGC0r_SET BCM56800_A0_TDBGC0r_SET
#define TDBGC0r_GET BCM56800_A0_TDBGC0r_GET
#define READ_TDBGC0r BCM56800_A0_READ_TDBGC0r
#define WRITE_TDBGC0r BCM56800_A0_WRITE_TDBGC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC0_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #0 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC0_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC0_SELECTr 0x0a480620

#define BCM56800_A0_TDBGC0_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC0_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC0_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc0_select[1];
	uint32_t _tdbgc0_select;
} BCM56800_A0_TDBGC0_SELECTr_t;

#define BCM56800_A0_TDBGC0_SELECTr_CLR(r) (r).tdbgc0_select[0] = 0
#define BCM56800_A0_TDBGC0_SELECTr_SET(r,d) (r).tdbgc0_select[0] = d
#define BCM56800_A0_TDBGC0_SELECTr_GET(r) (r).tdbgc0_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC0_SELECTr_BITMAPf_GET(r) (((r).tdbgc0_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC0_SELECTr_BITMAPf_SET(r,f) (r).tdbgc0_select[0]=(((r).tdbgc0_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC0_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC0_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC0_SELECTr,(r._tdbgc0_select))
#define BCM56800_A0_WRITE_TDBGC0_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC0_SELECTr,&(r._tdbgc0_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC0_SELECTr BCM56800_A0_TDBGC0_SELECTr
#define TDBGC0_SELECTr_SIZE BCM56800_A0_TDBGC0_SELECTr_SIZE
typedef BCM56800_A0_TDBGC0_SELECTr_t TDBGC0_SELECTr_t;
#define TDBGC0_SELECTr_CLR BCM56800_A0_TDBGC0_SELECTr_CLR
#define TDBGC0_SELECTr_SET BCM56800_A0_TDBGC0_SELECTr_SET
#define TDBGC0_SELECTr_GET BCM56800_A0_TDBGC0_SELECTr_GET
#define TDBGC0_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC0_SELECTr_BITMAPf_GET
#define TDBGC0_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC0_SELECTr_BITMAPf_SET
#define READ_TDBGC0_SELECTr BCM56800_A0_READ_TDBGC0_SELECTr
#define WRITE_TDBGC0_SELECTr BCM56800_A0_WRITE_TDBGC0_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC0_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC1
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #1
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC1r 0x0a400001

#define BCM56800_A0_TDBGC1r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC1.
 *
 */
typedef union BCM56800_A0_TDBGC1r_s {
	uint32_t v[1];
	uint32_t tdbgc1[1];
	uint32_t _tdbgc1;
} BCM56800_A0_TDBGC1r_t;

#define BCM56800_A0_TDBGC1r_CLR(r) (r).tdbgc1[0] = 0
#define BCM56800_A0_TDBGC1r_SET(r,d) (r).tdbgc1[0] = d
#define BCM56800_A0_TDBGC1r_GET(r) (r).tdbgc1[0]


/*
 * These macros can be used to access TDBGC1.
 *
 */
#define BCM56800_A0_READ_TDBGC1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC1r,(r._tdbgc1))
#define BCM56800_A0_WRITE_TDBGC1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC1r,&(r._tdbgc1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC1r BCM56800_A0_TDBGC1r
#define TDBGC1r_SIZE BCM56800_A0_TDBGC1r_SIZE
typedef BCM56800_A0_TDBGC1r_t TDBGC1r_t;
#define TDBGC1r_CLR BCM56800_A0_TDBGC1r_CLR
#define TDBGC1r_SET BCM56800_A0_TDBGC1r_SET
#define TDBGC1r_GET BCM56800_A0_TDBGC1r_GET
#define READ_TDBGC1r BCM56800_A0_READ_TDBGC1r
#define WRITE_TDBGC1r BCM56800_A0_WRITE_TDBGC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC10
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #10
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC10r 0x0a40000a

#define BCM56800_A0_TDBGC10r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC10.
 *
 */
typedef union BCM56800_A0_TDBGC10r_s {
	uint32_t v[1];
	uint32_t tdbgc10[1];
	uint32_t _tdbgc10;
} BCM56800_A0_TDBGC10r_t;

#define BCM56800_A0_TDBGC10r_CLR(r) (r).tdbgc10[0] = 0
#define BCM56800_A0_TDBGC10r_SET(r,d) (r).tdbgc10[0] = d
#define BCM56800_A0_TDBGC10r_GET(r) (r).tdbgc10[0]


/*
 * These macros can be used to access TDBGC10.
 *
 */
#define BCM56800_A0_READ_TDBGC10r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC10r,(r._tdbgc10))
#define BCM56800_A0_WRITE_TDBGC10r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC10r,&(r._tdbgc10))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC10r BCM56800_A0_TDBGC10r
#define TDBGC10r_SIZE BCM56800_A0_TDBGC10r_SIZE
typedef BCM56800_A0_TDBGC10r_t TDBGC10r_t;
#define TDBGC10r_CLR BCM56800_A0_TDBGC10r_CLR
#define TDBGC10r_SET BCM56800_A0_TDBGC10r_SET
#define TDBGC10r_GET BCM56800_A0_TDBGC10r_GET
#define READ_TDBGC10r BCM56800_A0_READ_TDBGC10r
#define WRITE_TDBGC10r BCM56800_A0_WRITE_TDBGC10r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC10_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #10 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC10_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC10_SELECTr 0x0a48062a

#define BCM56800_A0_TDBGC10_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC10_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC10_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc10_select[1];
	uint32_t _tdbgc10_select;
} BCM56800_A0_TDBGC10_SELECTr_t;

#define BCM56800_A0_TDBGC10_SELECTr_CLR(r) (r).tdbgc10_select[0] = 0
#define BCM56800_A0_TDBGC10_SELECTr_SET(r,d) (r).tdbgc10_select[0] = d
#define BCM56800_A0_TDBGC10_SELECTr_GET(r) (r).tdbgc10_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC10_SELECTr_BITMAPf_GET(r) (((r).tdbgc10_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC10_SELECTr_BITMAPf_SET(r,f) (r).tdbgc10_select[0]=(((r).tdbgc10_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC10_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC10_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC10_SELECTr,(r._tdbgc10_select))
#define BCM56800_A0_WRITE_TDBGC10_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC10_SELECTr,&(r._tdbgc10_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC10_SELECTr BCM56800_A0_TDBGC10_SELECTr
#define TDBGC10_SELECTr_SIZE BCM56800_A0_TDBGC10_SELECTr_SIZE
typedef BCM56800_A0_TDBGC10_SELECTr_t TDBGC10_SELECTr_t;
#define TDBGC10_SELECTr_CLR BCM56800_A0_TDBGC10_SELECTr_CLR
#define TDBGC10_SELECTr_SET BCM56800_A0_TDBGC10_SELECTr_SET
#define TDBGC10_SELECTr_GET BCM56800_A0_TDBGC10_SELECTr_GET
#define TDBGC10_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC10_SELECTr_BITMAPf_GET
#define TDBGC10_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC10_SELECTr_BITMAPf_SET
#define READ_TDBGC10_SELECTr BCM56800_A0_READ_TDBGC10_SELECTr
#define WRITE_TDBGC10_SELECTr BCM56800_A0_WRITE_TDBGC10_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC10_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC11
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #11
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC11r 0x0a40000b

#define BCM56800_A0_TDBGC11r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC11.
 *
 */
typedef union BCM56800_A0_TDBGC11r_s {
	uint32_t v[1];
	uint32_t tdbgc11[1];
	uint32_t _tdbgc11;
} BCM56800_A0_TDBGC11r_t;

#define BCM56800_A0_TDBGC11r_CLR(r) (r).tdbgc11[0] = 0
#define BCM56800_A0_TDBGC11r_SET(r,d) (r).tdbgc11[0] = d
#define BCM56800_A0_TDBGC11r_GET(r) (r).tdbgc11[0]


/*
 * These macros can be used to access TDBGC11.
 *
 */
#define BCM56800_A0_READ_TDBGC11r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC11r,(r._tdbgc11))
#define BCM56800_A0_WRITE_TDBGC11r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC11r,&(r._tdbgc11))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC11r BCM56800_A0_TDBGC11r
#define TDBGC11r_SIZE BCM56800_A0_TDBGC11r_SIZE
typedef BCM56800_A0_TDBGC11r_t TDBGC11r_t;
#define TDBGC11r_CLR BCM56800_A0_TDBGC11r_CLR
#define TDBGC11r_SET BCM56800_A0_TDBGC11r_SET
#define TDBGC11r_GET BCM56800_A0_TDBGC11r_GET
#define READ_TDBGC11r BCM56800_A0_READ_TDBGC11r
#define WRITE_TDBGC11r BCM56800_A0_WRITE_TDBGC11r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC11_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #11 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC11_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC11_SELECTr 0x0a48062b

#define BCM56800_A0_TDBGC11_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC11_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC11_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc11_select[1];
	uint32_t _tdbgc11_select;
} BCM56800_A0_TDBGC11_SELECTr_t;

#define BCM56800_A0_TDBGC11_SELECTr_CLR(r) (r).tdbgc11_select[0] = 0
#define BCM56800_A0_TDBGC11_SELECTr_SET(r,d) (r).tdbgc11_select[0] = d
#define BCM56800_A0_TDBGC11_SELECTr_GET(r) (r).tdbgc11_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC11_SELECTr_BITMAPf_GET(r) (((r).tdbgc11_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC11_SELECTr_BITMAPf_SET(r,f) (r).tdbgc11_select[0]=(((r).tdbgc11_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC11_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC11_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC11_SELECTr,(r._tdbgc11_select))
#define BCM56800_A0_WRITE_TDBGC11_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC11_SELECTr,&(r._tdbgc11_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC11_SELECTr BCM56800_A0_TDBGC11_SELECTr
#define TDBGC11_SELECTr_SIZE BCM56800_A0_TDBGC11_SELECTr_SIZE
typedef BCM56800_A0_TDBGC11_SELECTr_t TDBGC11_SELECTr_t;
#define TDBGC11_SELECTr_CLR BCM56800_A0_TDBGC11_SELECTr_CLR
#define TDBGC11_SELECTr_SET BCM56800_A0_TDBGC11_SELECTr_SET
#define TDBGC11_SELECTr_GET BCM56800_A0_TDBGC11_SELECTr_GET
#define TDBGC11_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC11_SELECTr_BITMAPf_GET
#define TDBGC11_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC11_SELECTr_BITMAPf_SET
#define READ_TDBGC11_SELECTr BCM56800_A0_READ_TDBGC11_SELECTr
#define WRITE_TDBGC11_SELECTr BCM56800_A0_WRITE_TDBGC11_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC11_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC1_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #1 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC1_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC1_SELECTr 0x0a480621

#define BCM56800_A0_TDBGC1_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC1_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC1_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc1_select[1];
	uint32_t _tdbgc1_select;
} BCM56800_A0_TDBGC1_SELECTr_t;

#define BCM56800_A0_TDBGC1_SELECTr_CLR(r) (r).tdbgc1_select[0] = 0
#define BCM56800_A0_TDBGC1_SELECTr_SET(r,d) (r).tdbgc1_select[0] = d
#define BCM56800_A0_TDBGC1_SELECTr_GET(r) (r).tdbgc1_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC1_SELECTr_BITMAPf_GET(r) (((r).tdbgc1_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC1_SELECTr_BITMAPf_SET(r,f) (r).tdbgc1_select[0]=(((r).tdbgc1_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC1_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC1_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC1_SELECTr,(r._tdbgc1_select))
#define BCM56800_A0_WRITE_TDBGC1_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC1_SELECTr,&(r._tdbgc1_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC1_SELECTr BCM56800_A0_TDBGC1_SELECTr
#define TDBGC1_SELECTr_SIZE BCM56800_A0_TDBGC1_SELECTr_SIZE
typedef BCM56800_A0_TDBGC1_SELECTr_t TDBGC1_SELECTr_t;
#define TDBGC1_SELECTr_CLR BCM56800_A0_TDBGC1_SELECTr_CLR
#define TDBGC1_SELECTr_SET BCM56800_A0_TDBGC1_SELECTr_SET
#define TDBGC1_SELECTr_GET BCM56800_A0_TDBGC1_SELECTr_GET
#define TDBGC1_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC1_SELECTr_BITMAPf_GET
#define TDBGC1_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC1_SELECTr_BITMAPf_SET
#define READ_TDBGC1_SELECTr BCM56800_A0_READ_TDBGC1_SELECTr
#define WRITE_TDBGC1_SELECTr BCM56800_A0_WRITE_TDBGC1_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC1_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC2
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #2
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC2r 0x0a400002

#define BCM56800_A0_TDBGC2r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC2.
 *
 */
typedef union BCM56800_A0_TDBGC2r_s {
	uint32_t v[1];
	uint32_t tdbgc2[1];
	uint32_t _tdbgc2;
} BCM56800_A0_TDBGC2r_t;

#define BCM56800_A0_TDBGC2r_CLR(r) (r).tdbgc2[0] = 0
#define BCM56800_A0_TDBGC2r_SET(r,d) (r).tdbgc2[0] = d
#define BCM56800_A0_TDBGC2r_GET(r) (r).tdbgc2[0]


/*
 * These macros can be used to access TDBGC2.
 *
 */
#define BCM56800_A0_READ_TDBGC2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC2r,(r._tdbgc2))
#define BCM56800_A0_WRITE_TDBGC2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC2r,&(r._tdbgc2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC2r BCM56800_A0_TDBGC2r
#define TDBGC2r_SIZE BCM56800_A0_TDBGC2r_SIZE
typedef BCM56800_A0_TDBGC2r_t TDBGC2r_t;
#define TDBGC2r_CLR BCM56800_A0_TDBGC2r_CLR
#define TDBGC2r_SET BCM56800_A0_TDBGC2r_SET
#define TDBGC2r_GET BCM56800_A0_TDBGC2r_GET
#define READ_TDBGC2r BCM56800_A0_READ_TDBGC2r
#define WRITE_TDBGC2r BCM56800_A0_WRITE_TDBGC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC2_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #2 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC2_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC2_SELECTr 0x0a480622

#define BCM56800_A0_TDBGC2_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC2_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC2_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc2_select[1];
	uint32_t _tdbgc2_select;
} BCM56800_A0_TDBGC2_SELECTr_t;

#define BCM56800_A0_TDBGC2_SELECTr_CLR(r) (r).tdbgc2_select[0] = 0
#define BCM56800_A0_TDBGC2_SELECTr_SET(r,d) (r).tdbgc2_select[0] = d
#define BCM56800_A0_TDBGC2_SELECTr_GET(r) (r).tdbgc2_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC2_SELECTr_BITMAPf_GET(r) (((r).tdbgc2_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC2_SELECTr_BITMAPf_SET(r,f) (r).tdbgc2_select[0]=(((r).tdbgc2_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC2_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC2_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC2_SELECTr,(r._tdbgc2_select))
#define BCM56800_A0_WRITE_TDBGC2_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC2_SELECTr,&(r._tdbgc2_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC2_SELECTr BCM56800_A0_TDBGC2_SELECTr
#define TDBGC2_SELECTr_SIZE BCM56800_A0_TDBGC2_SELECTr_SIZE
typedef BCM56800_A0_TDBGC2_SELECTr_t TDBGC2_SELECTr_t;
#define TDBGC2_SELECTr_CLR BCM56800_A0_TDBGC2_SELECTr_CLR
#define TDBGC2_SELECTr_SET BCM56800_A0_TDBGC2_SELECTr_SET
#define TDBGC2_SELECTr_GET BCM56800_A0_TDBGC2_SELECTr_GET
#define TDBGC2_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC2_SELECTr_BITMAPf_GET
#define TDBGC2_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC2_SELECTr_BITMAPf_SET
#define READ_TDBGC2_SELECTr BCM56800_A0_READ_TDBGC2_SELECTr
#define WRITE_TDBGC2_SELECTr BCM56800_A0_WRITE_TDBGC2_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC2_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC3
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #3
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC3r 0x0a400003

#define BCM56800_A0_TDBGC3r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC3.
 *
 */
typedef union BCM56800_A0_TDBGC3r_s {
	uint32_t v[1];
	uint32_t tdbgc3[1];
	uint32_t _tdbgc3;
} BCM56800_A0_TDBGC3r_t;

#define BCM56800_A0_TDBGC3r_CLR(r) (r).tdbgc3[0] = 0
#define BCM56800_A0_TDBGC3r_SET(r,d) (r).tdbgc3[0] = d
#define BCM56800_A0_TDBGC3r_GET(r) (r).tdbgc3[0]


/*
 * These macros can be used to access TDBGC3.
 *
 */
#define BCM56800_A0_READ_TDBGC3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC3r,(r._tdbgc3))
#define BCM56800_A0_WRITE_TDBGC3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC3r,&(r._tdbgc3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC3r BCM56800_A0_TDBGC3r
#define TDBGC3r_SIZE BCM56800_A0_TDBGC3r_SIZE
typedef BCM56800_A0_TDBGC3r_t TDBGC3r_t;
#define TDBGC3r_CLR BCM56800_A0_TDBGC3r_CLR
#define TDBGC3r_SET BCM56800_A0_TDBGC3r_SET
#define TDBGC3r_GET BCM56800_A0_TDBGC3r_GET
#define READ_TDBGC3r BCM56800_A0_READ_TDBGC3r
#define WRITE_TDBGC3r BCM56800_A0_WRITE_TDBGC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC3_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #3 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC3_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC3_SELECTr 0x0a480623

#define BCM56800_A0_TDBGC3_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC3_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC3_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc3_select[1];
	uint32_t _tdbgc3_select;
} BCM56800_A0_TDBGC3_SELECTr_t;

#define BCM56800_A0_TDBGC3_SELECTr_CLR(r) (r).tdbgc3_select[0] = 0
#define BCM56800_A0_TDBGC3_SELECTr_SET(r,d) (r).tdbgc3_select[0] = d
#define BCM56800_A0_TDBGC3_SELECTr_GET(r) (r).tdbgc3_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC3_SELECTr_BITMAPf_GET(r) (((r).tdbgc3_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC3_SELECTr_BITMAPf_SET(r,f) (r).tdbgc3_select[0]=(((r).tdbgc3_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC3_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC3_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC3_SELECTr,(r._tdbgc3_select))
#define BCM56800_A0_WRITE_TDBGC3_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC3_SELECTr,&(r._tdbgc3_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC3_SELECTr BCM56800_A0_TDBGC3_SELECTr
#define TDBGC3_SELECTr_SIZE BCM56800_A0_TDBGC3_SELECTr_SIZE
typedef BCM56800_A0_TDBGC3_SELECTr_t TDBGC3_SELECTr_t;
#define TDBGC3_SELECTr_CLR BCM56800_A0_TDBGC3_SELECTr_CLR
#define TDBGC3_SELECTr_SET BCM56800_A0_TDBGC3_SELECTr_SET
#define TDBGC3_SELECTr_GET BCM56800_A0_TDBGC3_SELECTr_GET
#define TDBGC3_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC3_SELECTr_BITMAPf_GET
#define TDBGC3_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC3_SELECTr_BITMAPf_SET
#define READ_TDBGC3_SELECTr BCM56800_A0_READ_TDBGC3_SELECTr
#define WRITE_TDBGC3_SELECTr BCM56800_A0_WRITE_TDBGC3_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC3_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC4
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #4
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC4r 0x0a400004

#define BCM56800_A0_TDBGC4r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC4.
 *
 */
typedef union BCM56800_A0_TDBGC4r_s {
	uint32_t v[1];
	uint32_t tdbgc4[1];
	uint32_t _tdbgc4;
} BCM56800_A0_TDBGC4r_t;

#define BCM56800_A0_TDBGC4r_CLR(r) (r).tdbgc4[0] = 0
#define BCM56800_A0_TDBGC4r_SET(r,d) (r).tdbgc4[0] = d
#define BCM56800_A0_TDBGC4r_GET(r) (r).tdbgc4[0]


/*
 * These macros can be used to access TDBGC4.
 *
 */
#define BCM56800_A0_READ_TDBGC4r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC4r,(r._tdbgc4))
#define BCM56800_A0_WRITE_TDBGC4r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC4r,&(r._tdbgc4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC4r BCM56800_A0_TDBGC4r
#define TDBGC4r_SIZE BCM56800_A0_TDBGC4r_SIZE
typedef BCM56800_A0_TDBGC4r_t TDBGC4r_t;
#define TDBGC4r_CLR BCM56800_A0_TDBGC4r_CLR
#define TDBGC4r_SET BCM56800_A0_TDBGC4r_SET
#define TDBGC4r_GET BCM56800_A0_TDBGC4r_GET
#define READ_TDBGC4r BCM56800_A0_READ_TDBGC4r
#define WRITE_TDBGC4r BCM56800_A0_WRITE_TDBGC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC4_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #4 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC4_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC4_SELECTr 0x0a480624

#define BCM56800_A0_TDBGC4_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC4_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC4_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc4_select[1];
	uint32_t _tdbgc4_select;
} BCM56800_A0_TDBGC4_SELECTr_t;

#define BCM56800_A0_TDBGC4_SELECTr_CLR(r) (r).tdbgc4_select[0] = 0
#define BCM56800_A0_TDBGC4_SELECTr_SET(r,d) (r).tdbgc4_select[0] = d
#define BCM56800_A0_TDBGC4_SELECTr_GET(r) (r).tdbgc4_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC4_SELECTr_BITMAPf_GET(r) (((r).tdbgc4_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC4_SELECTr_BITMAPf_SET(r,f) (r).tdbgc4_select[0]=(((r).tdbgc4_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC4_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC4_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC4_SELECTr,(r._tdbgc4_select))
#define BCM56800_A0_WRITE_TDBGC4_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC4_SELECTr,&(r._tdbgc4_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC4_SELECTr BCM56800_A0_TDBGC4_SELECTr
#define TDBGC4_SELECTr_SIZE BCM56800_A0_TDBGC4_SELECTr_SIZE
typedef BCM56800_A0_TDBGC4_SELECTr_t TDBGC4_SELECTr_t;
#define TDBGC4_SELECTr_CLR BCM56800_A0_TDBGC4_SELECTr_CLR
#define TDBGC4_SELECTr_SET BCM56800_A0_TDBGC4_SELECTr_SET
#define TDBGC4_SELECTr_GET BCM56800_A0_TDBGC4_SELECTr_GET
#define TDBGC4_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC4_SELECTr_BITMAPf_GET
#define TDBGC4_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC4_SELECTr_BITMAPf_SET
#define READ_TDBGC4_SELECTr BCM56800_A0_READ_TDBGC4_SELECTr
#define WRITE_TDBGC4_SELECTr BCM56800_A0_WRITE_TDBGC4_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC4_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC5
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #5
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC5r 0x0a400005

#define BCM56800_A0_TDBGC5r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC5.
 *
 */
typedef union BCM56800_A0_TDBGC5r_s {
	uint32_t v[1];
	uint32_t tdbgc5[1];
	uint32_t _tdbgc5;
} BCM56800_A0_TDBGC5r_t;

#define BCM56800_A0_TDBGC5r_CLR(r) (r).tdbgc5[0] = 0
#define BCM56800_A0_TDBGC5r_SET(r,d) (r).tdbgc5[0] = d
#define BCM56800_A0_TDBGC5r_GET(r) (r).tdbgc5[0]


/*
 * These macros can be used to access TDBGC5.
 *
 */
#define BCM56800_A0_READ_TDBGC5r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC5r,(r._tdbgc5))
#define BCM56800_A0_WRITE_TDBGC5r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC5r,&(r._tdbgc5))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC5r BCM56800_A0_TDBGC5r
#define TDBGC5r_SIZE BCM56800_A0_TDBGC5r_SIZE
typedef BCM56800_A0_TDBGC5r_t TDBGC5r_t;
#define TDBGC5r_CLR BCM56800_A0_TDBGC5r_CLR
#define TDBGC5r_SET BCM56800_A0_TDBGC5r_SET
#define TDBGC5r_GET BCM56800_A0_TDBGC5r_GET
#define READ_TDBGC5r BCM56800_A0_READ_TDBGC5r
#define WRITE_TDBGC5r BCM56800_A0_WRITE_TDBGC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC5_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #5 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC5_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC5_SELECTr 0x0a480625

#define BCM56800_A0_TDBGC5_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC5_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC5_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc5_select[1];
	uint32_t _tdbgc5_select;
} BCM56800_A0_TDBGC5_SELECTr_t;

#define BCM56800_A0_TDBGC5_SELECTr_CLR(r) (r).tdbgc5_select[0] = 0
#define BCM56800_A0_TDBGC5_SELECTr_SET(r,d) (r).tdbgc5_select[0] = d
#define BCM56800_A0_TDBGC5_SELECTr_GET(r) (r).tdbgc5_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC5_SELECTr_BITMAPf_GET(r) (((r).tdbgc5_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC5_SELECTr_BITMAPf_SET(r,f) (r).tdbgc5_select[0]=(((r).tdbgc5_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC5_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC5_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC5_SELECTr,(r._tdbgc5_select))
#define BCM56800_A0_WRITE_TDBGC5_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC5_SELECTr,&(r._tdbgc5_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC5_SELECTr BCM56800_A0_TDBGC5_SELECTr
#define TDBGC5_SELECTr_SIZE BCM56800_A0_TDBGC5_SELECTr_SIZE
typedef BCM56800_A0_TDBGC5_SELECTr_t TDBGC5_SELECTr_t;
#define TDBGC5_SELECTr_CLR BCM56800_A0_TDBGC5_SELECTr_CLR
#define TDBGC5_SELECTr_SET BCM56800_A0_TDBGC5_SELECTr_SET
#define TDBGC5_SELECTr_GET BCM56800_A0_TDBGC5_SELECTr_GET
#define TDBGC5_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC5_SELECTr_BITMAPf_GET
#define TDBGC5_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC5_SELECTr_BITMAPf_SET
#define READ_TDBGC5_SELECTr BCM56800_A0_READ_TDBGC5_SELECTr
#define WRITE_TDBGC5_SELECTr BCM56800_A0_WRITE_TDBGC5_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC5_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC6
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #6
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC6r 0x0a400006

#define BCM56800_A0_TDBGC6r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC6.
 *
 */
typedef union BCM56800_A0_TDBGC6r_s {
	uint32_t v[1];
	uint32_t tdbgc6[1];
	uint32_t _tdbgc6;
} BCM56800_A0_TDBGC6r_t;

#define BCM56800_A0_TDBGC6r_CLR(r) (r).tdbgc6[0] = 0
#define BCM56800_A0_TDBGC6r_SET(r,d) (r).tdbgc6[0] = d
#define BCM56800_A0_TDBGC6r_GET(r) (r).tdbgc6[0]


/*
 * These macros can be used to access TDBGC6.
 *
 */
#define BCM56800_A0_READ_TDBGC6r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC6r,(r._tdbgc6))
#define BCM56800_A0_WRITE_TDBGC6r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC6r,&(r._tdbgc6))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC6r BCM56800_A0_TDBGC6r
#define TDBGC6r_SIZE BCM56800_A0_TDBGC6r_SIZE
typedef BCM56800_A0_TDBGC6r_t TDBGC6r_t;
#define TDBGC6r_CLR BCM56800_A0_TDBGC6r_CLR
#define TDBGC6r_SET BCM56800_A0_TDBGC6r_SET
#define TDBGC6r_GET BCM56800_A0_TDBGC6r_GET
#define READ_TDBGC6r BCM56800_A0_READ_TDBGC6r
#define WRITE_TDBGC6r BCM56800_A0_WRITE_TDBGC6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC6_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #6 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC6_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC6_SELECTr 0x0a480626

#define BCM56800_A0_TDBGC6_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC6_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC6_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc6_select[1];
	uint32_t _tdbgc6_select;
} BCM56800_A0_TDBGC6_SELECTr_t;

#define BCM56800_A0_TDBGC6_SELECTr_CLR(r) (r).tdbgc6_select[0] = 0
#define BCM56800_A0_TDBGC6_SELECTr_SET(r,d) (r).tdbgc6_select[0] = d
#define BCM56800_A0_TDBGC6_SELECTr_GET(r) (r).tdbgc6_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC6_SELECTr_BITMAPf_GET(r) (((r).tdbgc6_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC6_SELECTr_BITMAPf_SET(r,f) (r).tdbgc6_select[0]=(((r).tdbgc6_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC6_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC6_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC6_SELECTr,(r._tdbgc6_select))
#define BCM56800_A0_WRITE_TDBGC6_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC6_SELECTr,&(r._tdbgc6_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC6_SELECTr BCM56800_A0_TDBGC6_SELECTr
#define TDBGC6_SELECTr_SIZE BCM56800_A0_TDBGC6_SELECTr_SIZE
typedef BCM56800_A0_TDBGC6_SELECTr_t TDBGC6_SELECTr_t;
#define TDBGC6_SELECTr_CLR BCM56800_A0_TDBGC6_SELECTr_CLR
#define TDBGC6_SELECTr_SET BCM56800_A0_TDBGC6_SELECTr_SET
#define TDBGC6_SELECTr_GET BCM56800_A0_TDBGC6_SELECTr_GET
#define TDBGC6_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC6_SELECTr_BITMAPf_GET
#define TDBGC6_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC6_SELECTr_BITMAPf_SET
#define READ_TDBGC6_SELECTr BCM56800_A0_READ_TDBGC6_SELECTr
#define WRITE_TDBGC6_SELECTr BCM56800_A0_WRITE_TDBGC6_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC6_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC7
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #7
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC7r 0x0a400007

#define BCM56800_A0_TDBGC7r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC7.
 *
 */
typedef union BCM56800_A0_TDBGC7r_s {
	uint32_t v[1];
	uint32_t tdbgc7[1];
	uint32_t _tdbgc7;
} BCM56800_A0_TDBGC7r_t;

#define BCM56800_A0_TDBGC7r_CLR(r) (r).tdbgc7[0] = 0
#define BCM56800_A0_TDBGC7r_SET(r,d) (r).tdbgc7[0] = d
#define BCM56800_A0_TDBGC7r_GET(r) (r).tdbgc7[0]


/*
 * These macros can be used to access TDBGC7.
 *
 */
#define BCM56800_A0_READ_TDBGC7r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC7r,(r._tdbgc7))
#define BCM56800_A0_WRITE_TDBGC7r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC7r,&(r._tdbgc7))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC7r BCM56800_A0_TDBGC7r
#define TDBGC7r_SIZE BCM56800_A0_TDBGC7r_SIZE
typedef BCM56800_A0_TDBGC7r_t TDBGC7r_t;
#define TDBGC7r_CLR BCM56800_A0_TDBGC7r_CLR
#define TDBGC7r_SET BCM56800_A0_TDBGC7r_SET
#define TDBGC7r_GET BCM56800_A0_TDBGC7r_GET
#define READ_TDBGC7r BCM56800_A0_READ_TDBGC7r
#define WRITE_TDBGC7r BCM56800_A0_WRITE_TDBGC7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC7_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #7 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC7_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC7_SELECTr 0x0a480627

#define BCM56800_A0_TDBGC7_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC7_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC7_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc7_select[1];
	uint32_t _tdbgc7_select;
} BCM56800_A0_TDBGC7_SELECTr_t;

#define BCM56800_A0_TDBGC7_SELECTr_CLR(r) (r).tdbgc7_select[0] = 0
#define BCM56800_A0_TDBGC7_SELECTr_SET(r,d) (r).tdbgc7_select[0] = d
#define BCM56800_A0_TDBGC7_SELECTr_GET(r) (r).tdbgc7_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC7_SELECTr_BITMAPf_GET(r) (((r).tdbgc7_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC7_SELECTr_BITMAPf_SET(r,f) (r).tdbgc7_select[0]=(((r).tdbgc7_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC7_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC7_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC7_SELECTr,(r._tdbgc7_select))
#define BCM56800_A0_WRITE_TDBGC7_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC7_SELECTr,&(r._tdbgc7_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC7_SELECTr BCM56800_A0_TDBGC7_SELECTr
#define TDBGC7_SELECTr_SIZE BCM56800_A0_TDBGC7_SELECTr_SIZE
typedef BCM56800_A0_TDBGC7_SELECTr_t TDBGC7_SELECTr_t;
#define TDBGC7_SELECTr_CLR BCM56800_A0_TDBGC7_SELECTr_CLR
#define TDBGC7_SELECTr_SET BCM56800_A0_TDBGC7_SELECTr_SET
#define TDBGC7_SELECTr_GET BCM56800_A0_TDBGC7_SELECTr_GET
#define TDBGC7_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC7_SELECTr_BITMAPf_GET
#define TDBGC7_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC7_SELECTr_BITMAPf_SET
#define READ_TDBGC7_SELECTr BCM56800_A0_READ_TDBGC7_SELECTr
#define WRITE_TDBGC7_SELECTr BCM56800_A0_WRITE_TDBGC7_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC7_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC8
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #8
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC8r 0x0a400008

#define BCM56800_A0_TDBGC8r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC8.
 *
 */
typedef union BCM56800_A0_TDBGC8r_s {
	uint32_t v[1];
	uint32_t tdbgc8[1];
	uint32_t _tdbgc8;
} BCM56800_A0_TDBGC8r_t;

#define BCM56800_A0_TDBGC8r_CLR(r) (r).tdbgc8[0] = 0
#define BCM56800_A0_TDBGC8r_SET(r,d) (r).tdbgc8[0] = d
#define BCM56800_A0_TDBGC8r_GET(r) (r).tdbgc8[0]


/*
 * These macros can be used to access TDBGC8.
 *
 */
#define BCM56800_A0_READ_TDBGC8r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC8r,(r._tdbgc8))
#define BCM56800_A0_WRITE_TDBGC8r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC8r,&(r._tdbgc8))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC8r BCM56800_A0_TDBGC8r
#define TDBGC8r_SIZE BCM56800_A0_TDBGC8r_SIZE
typedef BCM56800_A0_TDBGC8r_t TDBGC8r_t;
#define TDBGC8r_CLR BCM56800_A0_TDBGC8r_CLR
#define TDBGC8r_SET BCM56800_A0_TDBGC8r_SET
#define TDBGC8r_GET BCM56800_A0_TDBGC8r_GET
#define READ_TDBGC8r BCM56800_A0_READ_TDBGC8r
#define WRITE_TDBGC8r BCM56800_A0_WRITE_TDBGC8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC8_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #8 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC8_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC8_SELECTr 0x0a480628

#define BCM56800_A0_TDBGC8_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC8_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC8_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc8_select[1];
	uint32_t _tdbgc8_select;
} BCM56800_A0_TDBGC8_SELECTr_t;

#define BCM56800_A0_TDBGC8_SELECTr_CLR(r) (r).tdbgc8_select[0] = 0
#define BCM56800_A0_TDBGC8_SELECTr_SET(r,d) (r).tdbgc8_select[0] = d
#define BCM56800_A0_TDBGC8_SELECTr_GET(r) (r).tdbgc8_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC8_SELECTr_BITMAPf_GET(r) (((r).tdbgc8_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC8_SELECTr_BITMAPf_SET(r,f) (r).tdbgc8_select[0]=(((r).tdbgc8_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC8_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC8_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC8_SELECTr,(r._tdbgc8_select))
#define BCM56800_A0_WRITE_TDBGC8_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC8_SELECTr,&(r._tdbgc8_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC8_SELECTr BCM56800_A0_TDBGC8_SELECTr
#define TDBGC8_SELECTr_SIZE BCM56800_A0_TDBGC8_SELECTr_SIZE
typedef BCM56800_A0_TDBGC8_SELECTr_t TDBGC8_SELECTr_t;
#define TDBGC8_SELECTr_CLR BCM56800_A0_TDBGC8_SELECTr_CLR
#define TDBGC8_SELECTr_SET BCM56800_A0_TDBGC8_SELECTr_SET
#define TDBGC8_SELECTr_GET BCM56800_A0_TDBGC8_SELECTr_GET
#define TDBGC8_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC8_SELECTr_BITMAPf_GET
#define TDBGC8_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC8_SELECTr_BITMAPf_SET
#define READ_TDBGC8_SELECTr BCM56800_A0_READ_TDBGC8_SELECTr
#define WRITE_TDBGC8_SELECTr BCM56800_A0_WRITE_TDBGC8_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC8_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC9
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #9
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC9r 0x0a400009

#define BCM56800_A0_TDBGC9r_SIZE 4

/*
 * This structure should be used to declare and program TDBGC9.
 *
 */
typedef union BCM56800_A0_TDBGC9r_s {
	uint32_t v[1];
	uint32_t tdbgc9[1];
	uint32_t _tdbgc9;
} BCM56800_A0_TDBGC9r_t;

#define BCM56800_A0_TDBGC9r_CLR(r) (r).tdbgc9[0] = 0
#define BCM56800_A0_TDBGC9r_SET(r,d) (r).tdbgc9[0] = d
#define BCM56800_A0_TDBGC9r_GET(r) (r).tdbgc9[0]


/*
 * These macros can be used to access TDBGC9.
 *
 */
#define BCM56800_A0_READ_TDBGC9r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TDBGC9r,(r._tdbgc9))
#define BCM56800_A0_WRITE_TDBGC9r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TDBGC9r,&(r._tdbgc9))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC9r BCM56800_A0_TDBGC9r
#define TDBGC9r_SIZE BCM56800_A0_TDBGC9r_SIZE
typedef BCM56800_A0_TDBGC9r_t TDBGC9r_t;
#define TDBGC9r_CLR BCM56800_A0_TDBGC9r_CLR
#define TDBGC9r_SET BCM56800_A0_TDBGC9r_SET
#define TDBGC9r_GET BCM56800_A0_TDBGC9r_GET
#define READ_TDBGC9r BCM56800_A0_READ_TDBGC9r
#define WRITE_TDBGC9r BCM56800_A0_WRITE_TDBGC9r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TDBGC9_SELECT
 * BLOCKS:   EPIPE
 * DESC:     Transmit debug counter #9 Trigger Select Register
 * SIZE:     32
 * FIELDS:
 *     BITMAP           The TDBGC9_SELECT register is programmed to select which triggers increment this counter.
 *
 ******************************************************************************/
#define BCM56800_A0_TDBGC9_SELECTr 0x0a480629

#define BCM56800_A0_TDBGC9_SELECTr_SIZE 4

/*
 * This structure should be used to declare and program TDBGC9_SELECT.
 *
 */
typedef union BCM56800_A0_TDBGC9_SELECTr_s {
	uint32_t v[1];
	uint32_t tdbgc9_select[1];
	uint32_t _tdbgc9_select;
} BCM56800_A0_TDBGC9_SELECTr_t;

#define BCM56800_A0_TDBGC9_SELECTr_CLR(r) (r).tdbgc9_select[0] = 0
#define BCM56800_A0_TDBGC9_SELECTr_SET(r,d) (r).tdbgc9_select[0] = d
#define BCM56800_A0_TDBGC9_SELECTr_GET(r) (r).tdbgc9_select[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TDBGC9_SELECTr_BITMAPf_GET(r) (((r).tdbgc9_select[0]) & 0xfffffff)
#define BCM56800_A0_TDBGC9_SELECTr_BITMAPf_SET(r,f) (r).tdbgc9_select[0]=(((r).tdbgc9_select[0] & ~((uint32_t)0xfffffff)) | (((uint32_t)f) & 0xfffffff))

/*
 * These macros can be used to access TDBGC9_SELECT.
 *
 */
#define BCM56800_A0_READ_TDBGC9_SELECTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TDBGC9_SELECTr,(r._tdbgc9_select))
#define BCM56800_A0_WRITE_TDBGC9_SELECTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TDBGC9_SELECTr,&(r._tdbgc9_select))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TDBGC9_SELECTr BCM56800_A0_TDBGC9_SELECTr
#define TDBGC9_SELECTr_SIZE BCM56800_A0_TDBGC9_SELECTr_SIZE
typedef BCM56800_A0_TDBGC9_SELECTr_t TDBGC9_SELECTr_t;
#define TDBGC9_SELECTr_CLR BCM56800_A0_TDBGC9_SELECTr_CLR
#define TDBGC9_SELECTr_SET BCM56800_A0_TDBGC9_SELECTr_SET
#define TDBGC9_SELECTr_GET BCM56800_A0_TDBGC9_SELECTr_GET
#define TDBGC9_SELECTr_BITMAPf_GET BCM56800_A0_TDBGC9_SELECTr_BITMAPf_GET
#define TDBGC9_SELECTr_BITMAPf_SET BCM56800_A0_TDBGC9_SELECTr_BITMAPf_SET
#define READ_TDBGC9_SELECTr BCM56800_A0_READ_TDBGC9_SELECTr
#define WRITE_TDBGC9_SELECTr BCM56800_A0_WRITE_TDBGC9_SELECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TDBGC9_SELECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TEST2
 * BLOCKS:   GXPORT
 * DESC:     Test control
 * SIZE:     32
 * FIELDS:
 *     SPQCT            Shortcut Pause Quanta Counter
 *     TPAUSE           Test Pause
 *
 ******************************************************************************/
#define BCM56800_A0_TEST2r 0x00f00119

#define BCM56800_A0_TEST2r_SIZE 4

/*
 * This structure should be used to declare and program TEST2.
 *
 */
typedef union BCM56800_A0_TEST2r_s {
	uint32_t v[1];
	uint32_t test2[1];
	uint32_t _test2;
} BCM56800_A0_TEST2r_t;

#define BCM56800_A0_TEST2r_CLR(r) (r).test2[0] = 0
#define BCM56800_A0_TEST2r_SET(r,d) (r).test2[0] = d
#define BCM56800_A0_TEST2r_GET(r) (r).test2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TEST2r_SPQCTf_GET(r) (((r).test2[0]) & 0x1)
#define BCM56800_A0_TEST2r_SPQCTf_SET(r,f) (r).test2[0]=(((r).test2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_TEST2r_TPAUSEf_GET(r) ((((r).test2[0]) >> 1) & 0x1)
#define BCM56800_A0_TEST2r_TPAUSEf_SET(r,f) (r).test2[0]=(((r).test2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access TEST2.
 *
 */
#define BCM56800_A0_READ_TEST2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TEST2r,(r._test2))
#define BCM56800_A0_WRITE_TEST2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TEST2r,&(r._test2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEST2r BCM56800_A0_TEST2r
#define TEST2r_SIZE BCM56800_A0_TEST2r_SIZE
typedef BCM56800_A0_TEST2r_t TEST2r_t;
#define TEST2r_CLR BCM56800_A0_TEST2r_CLR
#define TEST2r_SET BCM56800_A0_TEST2r_SET
#define TEST2r_GET BCM56800_A0_TEST2r_GET
#define TEST2r_SPQCTf_GET BCM56800_A0_TEST2r_SPQCTf_GET
#define TEST2r_SPQCTf_SET BCM56800_A0_TEST2r_SPQCTf_SET
#define TEST2r_TPAUSEf_GET BCM56800_A0_TEST2r_TPAUSEf_GET
#define TEST2r_TPAUSEf_SET BCM56800_A0_TEST2r_TPAUSEf_SET
#define READ_TEST2r BCM56800_A0_READ_TEST2r
#define WRITE_TEST2r BCM56800_A0_WRITE_TEST2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TEST2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  THDI_BYPASS
 * BLOCKS:   MMU
 * DESC:     THDI_BYPASS
 * SIZE:     32
 * FIELDS:
 *     INPUT_THRESHOLD_BYPASS Bypass input port threshold checking, never discard any cells. Debug only.
 *
 ******************************************************************************/
#define BCM56800_A0_THDI_BYPASSr 0x02d80002

#define BCM56800_A0_THDI_BYPASSr_SIZE 4

/*
 * This structure should be used to declare and program THDI_BYPASS.
 *
 */
typedef union BCM56800_A0_THDI_BYPASSr_s {
	uint32_t v[1];
	uint32_t thdi_bypass[1];
	uint32_t _thdi_bypass;
} BCM56800_A0_THDI_BYPASSr_t;

#define BCM56800_A0_THDI_BYPASSr_CLR(r) (r).thdi_bypass[0] = 0
#define BCM56800_A0_THDI_BYPASSr_SET(r,d) (r).thdi_bypass[0] = d
#define BCM56800_A0_THDI_BYPASSr_GET(r) (r).thdi_bypass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_THDI_BYPASSr_INPUT_THRESHOLD_BYPASSf_GET(r) (((r).thdi_bypass[0]) & 0x1)
#define BCM56800_A0_THDI_BYPASSr_INPUT_THRESHOLD_BYPASSf_SET(r,f) (r).thdi_bypass[0]=(((r).thdi_bypass[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access THDI_BYPASS.
 *
 */
#define BCM56800_A0_READ_THDI_BYPASSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_THDI_BYPASSr,(r._thdi_bypass))
#define BCM56800_A0_WRITE_THDI_BYPASSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_THDI_BYPASSr,&(r._thdi_bypass))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define THDI_BYPASSr BCM56800_A0_THDI_BYPASSr
#define THDI_BYPASSr_SIZE BCM56800_A0_THDI_BYPASSr_SIZE
typedef BCM56800_A0_THDI_BYPASSr_t THDI_BYPASSr_t;
#define THDI_BYPASSr_CLR BCM56800_A0_THDI_BYPASSr_CLR
#define THDI_BYPASSr_SET BCM56800_A0_THDI_BYPASSr_SET
#define THDI_BYPASSr_GET BCM56800_A0_THDI_BYPASSr_GET
#define THDI_BYPASSr_INPUT_THRESHOLD_BYPASSf_GET BCM56800_A0_THDI_BYPASSr_INPUT_THRESHOLD_BYPASSf_GET
#define THDI_BYPASSr_INPUT_THRESHOLD_BYPASSf_SET BCM56800_A0_THDI_BYPASSr_INPUT_THRESHOLD_BYPASSf_SET
#define READ_THDI_BYPASSr BCM56800_A0_READ_THDI_BYPASSr
#define WRITE_THDI_BYPASSr BCM56800_A0_WRITE_THDI_BYPASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_THDI_BYPASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  THDO_BYPASS
 * BLOCKS:   MMU
 * DESC:     THDO_BYPASS
 * SIZE:     32
 * FIELDS:
 *     OUTPUT_THRESHOLD_BYPASS Bypass output queue threshold checking, never discard any cells. Debug use only.
 *
 ******************************************************************************/
#define BCM56800_A0_THDO_BYPASSr 0x03d80001

#define BCM56800_A0_THDO_BYPASSr_SIZE 4

/*
 * This structure should be used to declare and program THDO_BYPASS.
 *
 */
typedef union BCM56800_A0_THDO_BYPASSr_s {
	uint32_t v[1];
	uint32_t thdo_bypass[1];
	uint32_t _thdo_bypass;
} BCM56800_A0_THDO_BYPASSr_t;

#define BCM56800_A0_THDO_BYPASSr_CLR(r) (r).thdo_bypass[0] = 0
#define BCM56800_A0_THDO_BYPASSr_SET(r,d) (r).thdo_bypass[0] = d
#define BCM56800_A0_THDO_BYPASSr_GET(r) (r).thdo_bypass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_THDO_BYPASSr_OUTPUT_THRESHOLD_BYPASSf_GET(r) (((r).thdo_bypass[0]) & 0x1)
#define BCM56800_A0_THDO_BYPASSr_OUTPUT_THRESHOLD_BYPASSf_SET(r,f) (r).thdo_bypass[0]=(((r).thdo_bypass[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access THDO_BYPASS.
 *
 */
#define BCM56800_A0_READ_THDO_BYPASSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_THDO_BYPASSr,(r._thdo_bypass))
#define BCM56800_A0_WRITE_THDO_BYPASSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_THDO_BYPASSr,&(r._thdo_bypass))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define THDO_BYPASSr BCM56800_A0_THDO_BYPASSr
#define THDO_BYPASSr_SIZE BCM56800_A0_THDO_BYPASSr_SIZE
typedef BCM56800_A0_THDO_BYPASSr_t THDO_BYPASSr_t;
#define THDO_BYPASSr_CLR BCM56800_A0_THDO_BYPASSr_CLR
#define THDO_BYPASSr_SET BCM56800_A0_THDO_BYPASSr_SET
#define THDO_BYPASSr_GET BCM56800_A0_THDO_BYPASSr_GET
#define THDO_BYPASSr_OUTPUT_THRESHOLD_BYPASSf_GET BCM56800_A0_THDO_BYPASSr_OUTPUT_THRESHOLD_BYPASSf_GET
#define THDO_BYPASSr_OUTPUT_THRESHOLD_BYPASSf_SET BCM56800_A0_THDO_BYPASSr_OUTPUT_THRESHOLD_BYPASSf_SET
#define READ_THDO_BYPASSr BCM56800_A0_READ_THDO_BYPASSr
#define WRITE_THDO_BYPASSr BCM56800_A0_WRITE_THDO_BYPASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_THDO_BYPASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQEMPTY
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     COS0             COS0 has no entries for this port
 *     COS1             COS1 has no entries for this port
 *     COS2             COS2 has no entries for this port
 *     COS3             COS3 has no entries for this port
 *     COS4             COS4 has no entries for this port
 *     COS5             COS5 has no entries for this port
 *     COS6             COS6 has no entries for this port
 *     COS7             COS7 has no entries for this port
 *     SC               SC has no entries for this port
 *     QM               QM has no entries for this port
 *     PQ               Purge Queue has no entries for this port
 *
 ******************************************************************************/
#define BCM56800_A0_TOQEMPTYr 0x04d00047

#define BCM56800_A0_TOQEMPTYr_SIZE 4

/*
 * This structure should be used to declare and program TOQEMPTY.
 *
 */
typedef union BCM56800_A0_TOQEMPTYr_s {
	uint32_t v[1];
	uint32_t toqempty[1];
	uint32_t _toqempty;
} BCM56800_A0_TOQEMPTYr_t;

#define BCM56800_A0_TOQEMPTYr_CLR(r) (r).toqempty[0] = 0
#define BCM56800_A0_TOQEMPTYr_SET(r,d) (r).toqempty[0] = d
#define BCM56800_A0_TOQEMPTYr_GET(r) (r).toqempty[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQEMPTYr_COS0f_GET(r) (((r).toqempty[0]) & 0x1)
#define BCM56800_A0_TOQEMPTYr_COS0f_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_TOQEMPTYr_COS1f_GET(r) ((((r).toqempty[0]) >> 1) & 0x1)
#define BCM56800_A0_TOQEMPTYr_COS1f_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_TOQEMPTYr_COS2f_GET(r) ((((r).toqempty[0]) >> 2) & 0x1)
#define BCM56800_A0_TOQEMPTYr_COS2f_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_TOQEMPTYr_COS3f_GET(r) ((((r).toqempty[0]) >> 3) & 0x1)
#define BCM56800_A0_TOQEMPTYr_COS3f_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_TOQEMPTYr_COS4f_GET(r) ((((r).toqempty[0]) >> 4) & 0x1)
#define BCM56800_A0_TOQEMPTYr_COS4f_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_TOQEMPTYr_COS5f_GET(r) ((((r).toqempty[0]) >> 5) & 0x1)
#define BCM56800_A0_TOQEMPTYr_COS5f_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_TOQEMPTYr_COS6f_GET(r) ((((r).toqempty[0]) >> 6) & 0x1)
#define BCM56800_A0_TOQEMPTYr_COS6f_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_TOQEMPTYr_COS7f_GET(r) ((((r).toqempty[0]) >> 7) & 0x1)
#define BCM56800_A0_TOQEMPTYr_COS7f_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_TOQEMPTYr_SCf_GET(r) ((((r).toqempty[0]) >> 8) & 0x1)
#define BCM56800_A0_TOQEMPTYr_SCf_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_TOQEMPTYr_QMf_GET(r) ((((r).toqempty[0]) >> 9) & 0x1)
#define BCM56800_A0_TOQEMPTYr_QMf_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM56800_A0_TOQEMPTYr_PQf_GET(r) ((((r).toqempty[0]) >> 10) & 0x1)
#define BCM56800_A0_TOQEMPTYr_PQf_SET(r,f) (r).toqempty[0]=(((r).toqempty[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))

/*
 * These macros can be used to access TOQEMPTY.
 *
 */
#define BCM56800_A0_READ_TOQEMPTYr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TOQEMPTYr,(r._toqempty))
#define BCM56800_A0_WRITE_TOQEMPTYr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TOQEMPTYr,&(r._toqempty))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQEMPTYr BCM56800_A0_TOQEMPTYr
#define TOQEMPTYr_SIZE BCM56800_A0_TOQEMPTYr_SIZE
typedef BCM56800_A0_TOQEMPTYr_t TOQEMPTYr_t;
#define TOQEMPTYr_CLR BCM56800_A0_TOQEMPTYr_CLR
#define TOQEMPTYr_SET BCM56800_A0_TOQEMPTYr_SET
#define TOQEMPTYr_GET BCM56800_A0_TOQEMPTYr_GET
#define TOQEMPTYr_COS0f_GET BCM56800_A0_TOQEMPTYr_COS0f_GET
#define TOQEMPTYr_COS0f_SET BCM56800_A0_TOQEMPTYr_COS0f_SET
#define TOQEMPTYr_COS1f_GET BCM56800_A0_TOQEMPTYr_COS1f_GET
#define TOQEMPTYr_COS1f_SET BCM56800_A0_TOQEMPTYr_COS1f_SET
#define TOQEMPTYr_COS2f_GET BCM56800_A0_TOQEMPTYr_COS2f_GET
#define TOQEMPTYr_COS2f_SET BCM56800_A0_TOQEMPTYr_COS2f_SET
#define TOQEMPTYr_COS3f_GET BCM56800_A0_TOQEMPTYr_COS3f_GET
#define TOQEMPTYr_COS3f_SET BCM56800_A0_TOQEMPTYr_COS3f_SET
#define TOQEMPTYr_COS4f_GET BCM56800_A0_TOQEMPTYr_COS4f_GET
#define TOQEMPTYr_COS4f_SET BCM56800_A0_TOQEMPTYr_COS4f_SET
#define TOQEMPTYr_COS5f_GET BCM56800_A0_TOQEMPTYr_COS5f_GET
#define TOQEMPTYr_COS5f_SET BCM56800_A0_TOQEMPTYr_COS5f_SET
#define TOQEMPTYr_COS6f_GET BCM56800_A0_TOQEMPTYr_COS6f_GET
#define TOQEMPTYr_COS6f_SET BCM56800_A0_TOQEMPTYr_COS6f_SET
#define TOQEMPTYr_COS7f_GET BCM56800_A0_TOQEMPTYr_COS7f_GET
#define TOQEMPTYr_COS7f_SET BCM56800_A0_TOQEMPTYr_COS7f_SET
#define TOQEMPTYr_SCf_GET BCM56800_A0_TOQEMPTYr_SCf_GET
#define TOQEMPTYr_SCf_SET BCM56800_A0_TOQEMPTYr_SCf_SET
#define TOQEMPTYr_QMf_GET BCM56800_A0_TOQEMPTYr_QMf_GET
#define TOQEMPTYr_QMf_SET BCM56800_A0_TOQEMPTYr_QMf_SET
#define TOQEMPTYr_PQf_GET BCM56800_A0_TOQEMPTYr_PQf_GET
#define TOQEMPTYr_PQf_SET BCM56800_A0_TOQEMPTYr_PQf_SET
#define READ_TOQEMPTYr BCM56800_A0_READ_TOQEMPTYr
#define WRITE_TOQEMPTYr BCM56800_A0_WRITE_TOQEMPTYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQEMPTYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_ACTIVATEQ
 * BLOCKS:   MMU
 * DESC:     Activate inactive queue
 * SIZE:     32
 * FIELDS:
 *     QUEUESTAT        Aactivate per port output queue state:write logic high will activate on inactive output queuewrite logic low has no affect to output queue state.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_ACTIVATEQr 0x04d00032

#define BCM56800_A0_TOQ_ACTIVATEQr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_ACTIVATEQ.
 *
 */
typedef union BCM56800_A0_TOQ_ACTIVATEQr_s {
	uint32_t v[1];
	uint32_t toq_activateq[1];
	uint32_t _toq_activateq;
} BCM56800_A0_TOQ_ACTIVATEQr_t;

#define BCM56800_A0_TOQ_ACTIVATEQr_CLR(r) (r).toq_activateq[0] = 0
#define BCM56800_A0_TOQ_ACTIVATEQr_SET(r,d) (r).toq_activateq[0] = d
#define BCM56800_A0_TOQ_ACTIVATEQr_GET(r) (r).toq_activateq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_ACTIVATEQr_QUEUESTATf_GET(r) (((r).toq_activateq[0]) & 0x7ff)
#define BCM56800_A0_TOQ_ACTIVATEQr_QUEUESTATf_SET(r,f) (r).toq_activateq[0]=(((r).toq_activateq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access TOQ_ACTIVATEQ.
 *
 */
#define BCM56800_A0_READ_TOQ_ACTIVATEQr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TOQ_ACTIVATEQr,(r._toq_activateq))
#define BCM56800_A0_WRITE_TOQ_ACTIVATEQr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TOQ_ACTIVATEQr,&(r._toq_activateq))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_ACTIVATEQr BCM56800_A0_TOQ_ACTIVATEQr
#define TOQ_ACTIVATEQr_SIZE BCM56800_A0_TOQ_ACTIVATEQr_SIZE
typedef BCM56800_A0_TOQ_ACTIVATEQr_t TOQ_ACTIVATEQr_t;
#define TOQ_ACTIVATEQr_CLR BCM56800_A0_TOQ_ACTIVATEQr_CLR
#define TOQ_ACTIVATEQr_SET BCM56800_A0_TOQ_ACTIVATEQr_SET
#define TOQ_ACTIVATEQr_GET BCM56800_A0_TOQ_ACTIVATEQr_GET
#define TOQ_ACTIVATEQr_QUEUESTATf_GET BCM56800_A0_TOQ_ACTIVATEQr_QUEUESTATf_GET
#define TOQ_ACTIVATEQr_QUEUESTATf_SET BCM56800_A0_TOQ_ACTIVATEQr_QUEUESTATf_SET
#define READ_TOQ_ACTIVATEQr BCM56800_A0_READ_TOQ_ACTIVATEQr
#define WRITE_TOQ_ACTIVATEQr BCM56800_A0_WRITE_TOQ_ACTIVATEQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_ACTIVATEQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_CELLHDRERRPTR
 * BLOCKS:   MMU
 * DESC:     Captutred CELL HDR pointer address
 * SIZE:     32
 * FIELDS:
 *     CHERRORPOINTER   Cell Header Memory parity error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_CELLHDRERRPTRr 0x04d80004

#define BCM56800_A0_TOQ_CELLHDRERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_CELLHDRERRPTR.
 *
 */
typedef union BCM56800_A0_TOQ_CELLHDRERRPTRr_s {
	uint32_t v[1];
	uint32_t toq_cellhdrerrptr[1];
	uint32_t _toq_cellhdrerrptr;
} BCM56800_A0_TOQ_CELLHDRERRPTRr_t;

#define BCM56800_A0_TOQ_CELLHDRERRPTRr_CLR(r) (r).toq_cellhdrerrptr[0] = 0
#define BCM56800_A0_TOQ_CELLHDRERRPTRr_SET(r,d) (r).toq_cellhdrerrptr[0] = d
#define BCM56800_A0_TOQ_CELLHDRERRPTRr_GET(r) (r).toq_cellhdrerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_CELLHDRERRPTRr_CHERRORPOINTERf_GET(r) (((r).toq_cellhdrerrptr[0]) & 0x3fff)
#define BCM56800_A0_TOQ_CELLHDRERRPTRr_CHERRORPOINTERf_SET(r,f) (r).toq_cellhdrerrptr[0]=(((r).toq_cellhdrerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TOQ_CELLHDRERRPTR.
 *
 */
#define BCM56800_A0_READ_TOQ_CELLHDRERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOQ_CELLHDRERRPTRr,(r._toq_cellhdrerrptr))
#define BCM56800_A0_WRITE_TOQ_CELLHDRERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOQ_CELLHDRERRPTRr,&(r._toq_cellhdrerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_CELLHDRERRPTRr BCM56800_A0_TOQ_CELLHDRERRPTRr
#define TOQ_CELLHDRERRPTRr_SIZE BCM56800_A0_TOQ_CELLHDRERRPTRr_SIZE
typedef BCM56800_A0_TOQ_CELLHDRERRPTRr_t TOQ_CELLHDRERRPTRr_t;
#define TOQ_CELLHDRERRPTRr_CLR BCM56800_A0_TOQ_CELLHDRERRPTRr_CLR
#define TOQ_CELLHDRERRPTRr_SET BCM56800_A0_TOQ_CELLHDRERRPTRr_SET
#define TOQ_CELLHDRERRPTRr_GET BCM56800_A0_TOQ_CELLHDRERRPTRr_GET
#define TOQ_CELLHDRERRPTRr_CHERRORPOINTERf_GET BCM56800_A0_TOQ_CELLHDRERRPTRr_CHERRORPOINTERf_GET
#define TOQ_CELLHDRERRPTRr_CHERRORPOINTERf_SET BCM56800_A0_TOQ_CELLHDRERRPTRr_CHERRORPOINTERf_SET
#define READ_TOQ_CELLHDRERRPTRr BCM56800_A0_READ_TOQ_CELLHDRERRPTRr
#define WRITE_TOQ_CELLHDRERRPTRr BCM56800_A0_WRITE_TOQ_CELLHDRERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_CELLHDRERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_CELLLINKERRPTR
 * BLOCKS:   MMU
 * DESC:     Captutred CELL LINK pointer address
 * SIZE:     32
 * FIELDS:
 *     CLERRORPOINTER   Cell Link Memory ECC error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_CELLLINKERRPTRr 0x04d80003

#define BCM56800_A0_TOQ_CELLLINKERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_CELLLINKERRPTR.
 *
 */
typedef union BCM56800_A0_TOQ_CELLLINKERRPTRr_s {
	uint32_t v[1];
	uint32_t toq_celllinkerrptr[1];
	uint32_t _toq_celllinkerrptr;
} BCM56800_A0_TOQ_CELLLINKERRPTRr_t;

#define BCM56800_A0_TOQ_CELLLINKERRPTRr_CLR(r) (r).toq_celllinkerrptr[0] = 0
#define BCM56800_A0_TOQ_CELLLINKERRPTRr_SET(r,d) (r).toq_celllinkerrptr[0] = d
#define BCM56800_A0_TOQ_CELLLINKERRPTRr_GET(r) (r).toq_celllinkerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_CELLLINKERRPTRr_CLERRORPOINTERf_GET(r) (((r).toq_celllinkerrptr[0]) & 0x3fff)
#define BCM56800_A0_TOQ_CELLLINKERRPTRr_CLERRORPOINTERf_SET(r,f) (r).toq_celllinkerrptr[0]=(((r).toq_celllinkerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TOQ_CELLLINKERRPTR.
 *
 */
#define BCM56800_A0_READ_TOQ_CELLLINKERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOQ_CELLLINKERRPTRr,(r._toq_celllinkerrptr))
#define BCM56800_A0_WRITE_TOQ_CELLLINKERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOQ_CELLLINKERRPTRr,&(r._toq_celllinkerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_CELLLINKERRPTRr BCM56800_A0_TOQ_CELLLINKERRPTRr
#define TOQ_CELLLINKERRPTRr_SIZE BCM56800_A0_TOQ_CELLLINKERRPTRr_SIZE
typedef BCM56800_A0_TOQ_CELLLINKERRPTRr_t TOQ_CELLLINKERRPTRr_t;
#define TOQ_CELLLINKERRPTRr_CLR BCM56800_A0_TOQ_CELLLINKERRPTRr_CLR
#define TOQ_CELLLINKERRPTRr_SET BCM56800_A0_TOQ_CELLLINKERRPTRr_SET
#define TOQ_CELLLINKERRPTRr_GET BCM56800_A0_TOQ_CELLLINKERRPTRr_GET
#define TOQ_CELLLINKERRPTRr_CLERRORPOINTERf_GET BCM56800_A0_TOQ_CELLLINKERRPTRr_CLERRORPOINTERf_GET
#define TOQ_CELLLINKERRPTRr_CLERRORPOINTERf_SET BCM56800_A0_TOQ_CELLLINKERRPTRr_CLERRORPOINTERf_SET
#define READ_TOQ_CELLLINKERRPTRr BCM56800_A0_READ_TOQ_CELLLINKERRPTRr
#define WRITE_TOQ_CELLLINKERRPTRr BCM56800_A0_WRITE_TOQ_CELLLINKERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_CELLLINKERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_CONFIG
 * BLOCKS:   MMU
 * DESC:     Controls packet replication functions in the TOQ
 * SIZE:     32
 * FIELDS:
 *     HG_GE_PORT       For ports 0-19, 1 indicates XGE port and 0 indicates HG port
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_CONFIGr 0x04d80000

#define BCM56800_A0_TOQ_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_CONFIG.
 *
 */
typedef union BCM56800_A0_TOQ_CONFIGr_s {
	uint32_t v[1];
	uint32_t toq_config[1];
	uint32_t _toq_config;
} BCM56800_A0_TOQ_CONFIGr_t;

#define BCM56800_A0_TOQ_CONFIGr_CLR(r) (r).toq_config[0] = 0
#define BCM56800_A0_TOQ_CONFIGr_SET(r,d) (r).toq_config[0] = d
#define BCM56800_A0_TOQ_CONFIGr_GET(r) (r).toq_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_CONFIGr_HG_GE_PORTf_GET(r) (((r).toq_config[0]) & 0xfffff)
#define BCM56800_A0_TOQ_CONFIGr_HG_GE_PORTf_SET(r,f) (r).toq_config[0]=(((r).toq_config[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))

/*
 * These macros can be used to access TOQ_CONFIG.
 *
 */
#define BCM56800_A0_READ_TOQ_CONFIGr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOQ_CONFIGr,(r._toq_config))
#define BCM56800_A0_WRITE_TOQ_CONFIGr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOQ_CONFIGr,&(r._toq_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_CONFIGr BCM56800_A0_TOQ_CONFIGr
#define TOQ_CONFIGr_SIZE BCM56800_A0_TOQ_CONFIGr_SIZE
typedef BCM56800_A0_TOQ_CONFIGr_t TOQ_CONFIGr_t;
#define TOQ_CONFIGr_CLR BCM56800_A0_TOQ_CONFIGr_CLR
#define TOQ_CONFIGr_SET BCM56800_A0_TOQ_CONFIGr_SET
#define TOQ_CONFIGr_GET BCM56800_A0_TOQ_CONFIGr_GET
#define TOQ_CONFIGr_HG_GE_PORTf_GET BCM56800_A0_TOQ_CONFIGr_HG_GE_PORTf_GET
#define TOQ_CONFIGr_HG_GE_PORTf_SET BCM56800_A0_TOQ_CONFIGr_HG_GE_PORTf_SET
#define READ_TOQ_CONFIGr BCM56800_A0_READ_TOQ_CONFIGr
#define WRITE_TOQ_CONFIGr BCM56800_A0_WRITE_TOQ_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_ERRINTR
 * BLOCKS:   MMU
 * DESC:     TOQ memory soft error interrupt
 * SIZE:     32
 * FIELDS:
 *     PLEERR           Packet Link Memory ECC error interrupt
 *     IGPERR0          IPMC Group Memory 0 parity error interrupt
 *     IGPERR1          IPMC Group Memory 1 parity error interrupt
 *     IVPERR0          IPMC VLAN Memory 0 parity error interrupt
 *     IVPERR1          IPMC VLAN Memory 1 parity error interrupt
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_ERRINTRr 0x04d80001

#define BCM56800_A0_TOQ_ERRINTRr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_ERRINTR.
 *
 */
typedef union BCM56800_A0_TOQ_ERRINTRr_s {
	uint32_t v[1];
	uint32_t toq_errintr[1];
	uint32_t _toq_errintr;
} BCM56800_A0_TOQ_ERRINTRr_t;

#define BCM56800_A0_TOQ_ERRINTRr_CLR(r) (r).toq_errintr[0] = 0
#define BCM56800_A0_TOQ_ERRINTRr_SET(r,d) (r).toq_errintr[0] = d
#define BCM56800_A0_TOQ_ERRINTRr_GET(r) (r).toq_errintr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_ERRINTRr_PLEERRf_GET(r) (((r).toq_errintr[0]) & 0x1fffff)
#define BCM56800_A0_TOQ_ERRINTRr_PLEERRf_SET(r,f) (r).toq_errintr[0]=(((r).toq_errintr[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM56800_A0_TOQ_ERRINTRr_IGPERR0f_GET(r) ((((r).toq_errintr[0]) >> 21) & 0x1)
#define BCM56800_A0_TOQ_ERRINTRr_IGPERR0f_SET(r,f) (r).toq_errintr[0]=(((r).toq_errintr[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM56800_A0_TOQ_ERRINTRr_IGPERR1f_GET(r) ((((r).toq_errintr[0]) >> 22) & 0x1)
#define BCM56800_A0_TOQ_ERRINTRr_IGPERR1f_SET(r,f) (r).toq_errintr[0]=(((r).toq_errintr[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_TOQ_ERRINTRr_IVPERR0f_GET(r) ((((r).toq_errintr[0]) >> 23) & 0x1)
#define BCM56800_A0_TOQ_ERRINTRr_IVPERR0f_SET(r,f) (r).toq_errintr[0]=(((r).toq_errintr[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM56800_A0_TOQ_ERRINTRr_IVPERR1f_GET(r) ((((r).toq_errintr[0]) >> 24) & 0x1)
#define BCM56800_A0_TOQ_ERRINTRr_IVPERR1f_SET(r,f) (r).toq_errintr[0]=(((r).toq_errintr[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access TOQ_ERRINTR.
 *
 */
#define BCM56800_A0_READ_TOQ_ERRINTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOQ_ERRINTRr,(r._toq_errintr))
#define BCM56800_A0_WRITE_TOQ_ERRINTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOQ_ERRINTRr,&(r._toq_errintr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_ERRINTRr BCM56800_A0_TOQ_ERRINTRr
#define TOQ_ERRINTRr_SIZE BCM56800_A0_TOQ_ERRINTRr_SIZE
typedef BCM56800_A0_TOQ_ERRINTRr_t TOQ_ERRINTRr_t;
#define TOQ_ERRINTRr_CLR BCM56800_A0_TOQ_ERRINTRr_CLR
#define TOQ_ERRINTRr_SET BCM56800_A0_TOQ_ERRINTRr_SET
#define TOQ_ERRINTRr_GET BCM56800_A0_TOQ_ERRINTRr_GET
#define TOQ_ERRINTRr_PLEERRf_GET BCM56800_A0_TOQ_ERRINTRr_PLEERRf_GET
#define TOQ_ERRINTRr_PLEERRf_SET BCM56800_A0_TOQ_ERRINTRr_PLEERRf_SET
#define TOQ_ERRINTRr_IGPERR0f_GET BCM56800_A0_TOQ_ERRINTRr_IGPERR0f_GET
#define TOQ_ERRINTRr_IGPERR0f_SET BCM56800_A0_TOQ_ERRINTRr_IGPERR0f_SET
#define TOQ_ERRINTRr_IGPERR1f_GET BCM56800_A0_TOQ_ERRINTRr_IGPERR1f_GET
#define TOQ_ERRINTRr_IGPERR1f_SET BCM56800_A0_TOQ_ERRINTRr_IGPERR1f_SET
#define TOQ_ERRINTRr_IVPERR0f_GET BCM56800_A0_TOQ_ERRINTRr_IVPERR0f_GET
#define TOQ_ERRINTRr_IVPERR0f_SET BCM56800_A0_TOQ_ERRINTRr_IVPERR0f_SET
#define TOQ_ERRINTRr_IVPERR1f_GET BCM56800_A0_TOQ_ERRINTRr_IVPERR1f_GET
#define TOQ_ERRINTRr_IVPERR1f_SET BCM56800_A0_TOQ_ERRINTRr_IVPERR1f_SET
#define READ_TOQ_ERRINTRr BCM56800_A0_READ_TOQ_ERRINTRr
#define WRITE_TOQ_ERRINTRr BCM56800_A0_WRITE_TOQ_ERRINTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_ERRINTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_IPMCGRPERRPTR0
 * BLOCKS:   MMU
 * DESC:     Captutred IPMC GROUP 0 pointer address
 * SIZE:     32
 * FIELDS:
 *     IGERRORPOINTER   IPMC GROUP Memory 0 parity error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_IPMCGRPERRPTR0r 0x04d80006

#define BCM56800_A0_TOQ_IPMCGRPERRPTR0r_SIZE 4

/*
 * This structure should be used to declare and program TOQ_IPMCGRPERRPTR0.
 *
 */
typedef union BCM56800_A0_TOQ_IPMCGRPERRPTR0r_s {
	uint32_t v[1];
	uint32_t toq_ipmcgrperrptr0[1];
	uint32_t _toq_ipmcgrperrptr0;
} BCM56800_A0_TOQ_IPMCGRPERRPTR0r_t;

#define BCM56800_A0_TOQ_IPMCGRPERRPTR0r_CLR(r) (r).toq_ipmcgrperrptr0[0] = 0
#define BCM56800_A0_TOQ_IPMCGRPERRPTR0r_SET(r,d) (r).toq_ipmcgrperrptr0[0] = d
#define BCM56800_A0_TOQ_IPMCGRPERRPTR0r_GET(r) (r).toq_ipmcgrperrptr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_IPMCGRPERRPTR0r_IGERRORPOINTERf_GET(r) (((r).toq_ipmcgrperrptr0[0]) & 0x3ff)
#define BCM56800_A0_TOQ_IPMCGRPERRPTR0r_IGERRORPOINTERf_SET(r,f) (r).toq_ipmcgrperrptr0[0]=(((r).toq_ipmcgrperrptr0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access TOQ_IPMCGRPERRPTR0.
 *
 */
#define BCM56800_A0_READ_TOQ_IPMCGRPERRPTR0r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOQ_IPMCGRPERRPTR0r,(r._toq_ipmcgrperrptr0))
#define BCM56800_A0_WRITE_TOQ_IPMCGRPERRPTR0r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOQ_IPMCGRPERRPTR0r,&(r._toq_ipmcgrperrptr0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_IPMCGRPERRPTR0r BCM56800_A0_TOQ_IPMCGRPERRPTR0r
#define TOQ_IPMCGRPERRPTR0r_SIZE BCM56800_A0_TOQ_IPMCGRPERRPTR0r_SIZE
typedef BCM56800_A0_TOQ_IPMCGRPERRPTR0r_t TOQ_IPMCGRPERRPTR0r_t;
#define TOQ_IPMCGRPERRPTR0r_CLR BCM56800_A0_TOQ_IPMCGRPERRPTR0r_CLR
#define TOQ_IPMCGRPERRPTR0r_SET BCM56800_A0_TOQ_IPMCGRPERRPTR0r_SET
#define TOQ_IPMCGRPERRPTR0r_GET BCM56800_A0_TOQ_IPMCGRPERRPTR0r_GET
#define TOQ_IPMCGRPERRPTR0r_IGERRORPOINTERf_GET BCM56800_A0_TOQ_IPMCGRPERRPTR0r_IGERRORPOINTERf_GET
#define TOQ_IPMCGRPERRPTR0r_IGERRORPOINTERf_SET BCM56800_A0_TOQ_IPMCGRPERRPTR0r_IGERRORPOINTERf_SET
#define READ_TOQ_IPMCGRPERRPTR0r BCM56800_A0_READ_TOQ_IPMCGRPERRPTR0r
#define WRITE_TOQ_IPMCGRPERRPTR0r BCM56800_A0_WRITE_TOQ_IPMCGRPERRPTR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_IPMCGRPERRPTR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_IPMCGRPERRPTR1
 * BLOCKS:   MMU
 * DESC:     Captutred IPMC GROUP 1 pointer address
 * SIZE:     32
 * FIELDS:
 *     IGERRORPOINTER   IPMC GROUP Memory 1 parity error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_IPMCGRPERRPTR1r 0x04d80007

#define BCM56800_A0_TOQ_IPMCGRPERRPTR1r_SIZE 4

/*
 * This structure should be used to declare and program TOQ_IPMCGRPERRPTR1.
 *
 */
typedef union BCM56800_A0_TOQ_IPMCGRPERRPTR1r_s {
	uint32_t v[1];
	uint32_t toq_ipmcgrperrptr1[1];
	uint32_t _toq_ipmcgrperrptr1;
} BCM56800_A0_TOQ_IPMCGRPERRPTR1r_t;

#define BCM56800_A0_TOQ_IPMCGRPERRPTR1r_CLR(r) (r).toq_ipmcgrperrptr1[0] = 0
#define BCM56800_A0_TOQ_IPMCGRPERRPTR1r_SET(r,d) (r).toq_ipmcgrperrptr1[0] = d
#define BCM56800_A0_TOQ_IPMCGRPERRPTR1r_GET(r) (r).toq_ipmcgrperrptr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_IPMCGRPERRPTR1r_IGERRORPOINTERf_GET(r) (((r).toq_ipmcgrperrptr1[0]) & 0x3ff)
#define BCM56800_A0_TOQ_IPMCGRPERRPTR1r_IGERRORPOINTERf_SET(r,f) (r).toq_ipmcgrperrptr1[0]=(((r).toq_ipmcgrperrptr1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))

/*
 * These macros can be used to access TOQ_IPMCGRPERRPTR1.
 *
 */
#define BCM56800_A0_READ_TOQ_IPMCGRPERRPTR1r(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOQ_IPMCGRPERRPTR1r,(r._toq_ipmcgrperrptr1))
#define BCM56800_A0_WRITE_TOQ_IPMCGRPERRPTR1r(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOQ_IPMCGRPERRPTR1r,&(r._toq_ipmcgrperrptr1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_IPMCGRPERRPTR1r BCM56800_A0_TOQ_IPMCGRPERRPTR1r
#define TOQ_IPMCGRPERRPTR1r_SIZE BCM56800_A0_TOQ_IPMCGRPERRPTR1r_SIZE
typedef BCM56800_A0_TOQ_IPMCGRPERRPTR1r_t TOQ_IPMCGRPERRPTR1r_t;
#define TOQ_IPMCGRPERRPTR1r_CLR BCM56800_A0_TOQ_IPMCGRPERRPTR1r_CLR
#define TOQ_IPMCGRPERRPTR1r_SET BCM56800_A0_TOQ_IPMCGRPERRPTR1r_SET
#define TOQ_IPMCGRPERRPTR1r_GET BCM56800_A0_TOQ_IPMCGRPERRPTR1r_GET
#define TOQ_IPMCGRPERRPTR1r_IGERRORPOINTERf_GET BCM56800_A0_TOQ_IPMCGRPERRPTR1r_IGERRORPOINTERf_GET
#define TOQ_IPMCGRPERRPTR1r_IGERRORPOINTERf_SET BCM56800_A0_TOQ_IPMCGRPERRPTR1r_IGERRORPOINTERf_SET
#define READ_TOQ_IPMCGRPERRPTR1r BCM56800_A0_READ_TOQ_IPMCGRPERRPTR1r
#define WRITE_TOQ_IPMCGRPERRPTR1r BCM56800_A0_WRITE_TOQ_IPMCGRPERRPTR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_IPMCGRPERRPTR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_IPMCVLANERRPTR
 * BLOCKS:   MMU
 * DESC:     Captutred IPMC VLAN pointer address
 * SIZE:     32
 * FIELDS:
 *     IVERRORPOINTER   IPMC VLAN Memory parity error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_IPMCVLANERRPTRr 0x04d80002

#define BCM56800_A0_TOQ_IPMCVLANERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_IPMCVLANERRPTR.
 *
 */
typedef union BCM56800_A0_TOQ_IPMCVLANERRPTRr_s {
	uint32_t v[1];
	uint32_t toq_ipmcvlanerrptr[1];
	uint32_t _toq_ipmcvlanerrptr;
} BCM56800_A0_TOQ_IPMCVLANERRPTRr_t;

#define BCM56800_A0_TOQ_IPMCVLANERRPTRr_CLR(r) (r).toq_ipmcvlanerrptr[0] = 0
#define BCM56800_A0_TOQ_IPMCVLANERRPTRr_SET(r,d) (r).toq_ipmcvlanerrptr[0] = d
#define BCM56800_A0_TOQ_IPMCVLANERRPTRr_GET(r) (r).toq_ipmcvlanerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_IPMCVLANERRPTRr_IVERRORPOINTERf_GET(r) (((r).toq_ipmcvlanerrptr[0]) & 0x7ff)
#define BCM56800_A0_TOQ_IPMCVLANERRPTRr_IVERRORPOINTERf_SET(r,f) (r).toq_ipmcvlanerrptr[0]=(((r).toq_ipmcvlanerrptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access TOQ_IPMCVLANERRPTR.
 *
 */
#define BCM56800_A0_READ_TOQ_IPMCVLANERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOQ_IPMCVLANERRPTRr,(r._toq_ipmcvlanerrptr))
#define BCM56800_A0_WRITE_TOQ_IPMCVLANERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOQ_IPMCVLANERRPTRr,&(r._toq_ipmcvlanerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_IPMCVLANERRPTRr BCM56800_A0_TOQ_IPMCVLANERRPTRr
#define TOQ_IPMCVLANERRPTRr_SIZE BCM56800_A0_TOQ_IPMCVLANERRPTRr_SIZE
typedef BCM56800_A0_TOQ_IPMCVLANERRPTRr_t TOQ_IPMCVLANERRPTRr_t;
#define TOQ_IPMCVLANERRPTRr_CLR BCM56800_A0_TOQ_IPMCVLANERRPTRr_CLR
#define TOQ_IPMCVLANERRPTRr_SET BCM56800_A0_TOQ_IPMCVLANERRPTRr_SET
#define TOQ_IPMCVLANERRPTRr_GET BCM56800_A0_TOQ_IPMCVLANERRPTRr_GET
#define TOQ_IPMCVLANERRPTRr_IVERRORPOINTERf_GET BCM56800_A0_TOQ_IPMCVLANERRPTRr_IVERRORPOINTERf_GET
#define TOQ_IPMCVLANERRPTRr_IVERRORPOINTERf_SET BCM56800_A0_TOQ_IPMCVLANERRPTRr_IVERRORPOINTERf_SET
#define READ_TOQ_IPMCVLANERRPTRr BCM56800_A0_READ_TOQ_IPMCVLANERRPTRr
#define WRITE_TOQ_IPMCVLANERRPTRr BCM56800_A0_WRITE_TOQ_IPMCVLANERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_IPMCVLANERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_PKTHDR1ERRPTR
 * BLOCKS:   MMU
 * DESC:     Captutred PKT HDR 1 pointer address
 * SIZE:     32
 * FIELDS:
 *     PH1ERRORPOINTER  Packet Header 1 Memory parity error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_PKTHDR1ERRPTRr 0x04d80005

#define BCM56800_A0_TOQ_PKTHDR1ERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_PKTHDR1ERRPTR.
 *
 */
typedef union BCM56800_A0_TOQ_PKTHDR1ERRPTRr_s {
	uint32_t v[1];
	uint32_t toq_pkthdr1errptr[1];
	uint32_t _toq_pkthdr1errptr;
} BCM56800_A0_TOQ_PKTHDR1ERRPTRr_t;

#define BCM56800_A0_TOQ_PKTHDR1ERRPTRr_CLR(r) (r).toq_pkthdr1errptr[0] = 0
#define BCM56800_A0_TOQ_PKTHDR1ERRPTRr_SET(r,d) (r).toq_pkthdr1errptr[0] = d
#define BCM56800_A0_TOQ_PKTHDR1ERRPTRr_GET(r) (r).toq_pkthdr1errptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_PKTHDR1ERRPTRr_PH1ERRORPOINTERf_GET(r) (((r).toq_pkthdr1errptr[0]) & 0x3fff)
#define BCM56800_A0_TOQ_PKTHDR1ERRPTRr_PH1ERRORPOINTERf_SET(r,f) (r).toq_pkthdr1errptr[0]=(((r).toq_pkthdr1errptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TOQ_PKTHDR1ERRPTR.
 *
 */
#define BCM56800_A0_READ_TOQ_PKTHDR1ERRPTRr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOQ_PKTHDR1ERRPTRr,(r._toq_pkthdr1errptr))
#define BCM56800_A0_WRITE_TOQ_PKTHDR1ERRPTRr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOQ_PKTHDR1ERRPTRr,&(r._toq_pkthdr1errptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_PKTHDR1ERRPTRr BCM56800_A0_TOQ_PKTHDR1ERRPTRr
#define TOQ_PKTHDR1ERRPTRr_SIZE BCM56800_A0_TOQ_PKTHDR1ERRPTRr_SIZE
typedef BCM56800_A0_TOQ_PKTHDR1ERRPTRr_t TOQ_PKTHDR1ERRPTRr_t;
#define TOQ_PKTHDR1ERRPTRr_CLR BCM56800_A0_TOQ_PKTHDR1ERRPTRr_CLR
#define TOQ_PKTHDR1ERRPTRr_SET BCM56800_A0_TOQ_PKTHDR1ERRPTRr_SET
#define TOQ_PKTHDR1ERRPTRr_GET BCM56800_A0_TOQ_PKTHDR1ERRPTRr_GET
#define TOQ_PKTHDR1ERRPTRr_PH1ERRORPOINTERf_GET BCM56800_A0_TOQ_PKTHDR1ERRPTRr_PH1ERRORPOINTERf_GET
#define TOQ_PKTHDR1ERRPTRr_PH1ERRORPOINTERf_SET BCM56800_A0_TOQ_PKTHDR1ERRPTRr_PH1ERRORPOINTERf_SET
#define READ_TOQ_PKTHDR1ERRPTRr BCM56800_A0_READ_TOQ_PKTHDR1ERRPTRr
#define WRITE_TOQ_PKTHDR1ERRPTRr BCM56800_A0_WRITE_TOQ_PKTHDR1ERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_PKTHDR1ERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_PKTLINKERRPTR
 * BLOCKS:   MMU
 * DESC:     Captutred PKT LINK pointer address
 * SIZE:     32
 * FIELDS:
 *     PLERRORPOINTER   Per port Packet Link Memory ECC error pointer tells first failured memory entry.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_PKTLINKERRPTRr 0x04d00008

#define BCM56800_A0_TOQ_PKTLINKERRPTRr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_PKTLINKERRPTR.
 *
 */
typedef union BCM56800_A0_TOQ_PKTLINKERRPTRr_s {
	uint32_t v[1];
	uint32_t toq_pktlinkerrptr[1];
	uint32_t _toq_pktlinkerrptr;
} BCM56800_A0_TOQ_PKTLINKERRPTRr_t;

#define BCM56800_A0_TOQ_PKTLINKERRPTRr_CLR(r) (r).toq_pktlinkerrptr[0] = 0
#define BCM56800_A0_TOQ_PKTLINKERRPTRr_SET(r,d) (r).toq_pktlinkerrptr[0] = d
#define BCM56800_A0_TOQ_PKTLINKERRPTRr_GET(r) (r).toq_pktlinkerrptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_PKTLINKERRPTRr_PLERRORPOINTERf_GET(r) (((r).toq_pktlinkerrptr[0]) & 0x3fff)
#define BCM56800_A0_TOQ_PKTLINKERRPTRr_PLERRORPOINTERf_SET(r,f) (r).toq_pktlinkerrptr[0]=(((r).toq_pktlinkerrptr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TOQ_PKTLINKERRPTR.
 *
 */
#define BCM56800_A0_READ_TOQ_PKTLINKERRPTRr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TOQ_PKTLINKERRPTRr,(r._toq_pktlinkerrptr))
#define BCM56800_A0_WRITE_TOQ_PKTLINKERRPTRr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TOQ_PKTLINKERRPTRr,&(r._toq_pktlinkerrptr))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_PKTLINKERRPTRr BCM56800_A0_TOQ_PKTLINKERRPTRr
#define TOQ_PKTLINKERRPTRr_SIZE BCM56800_A0_TOQ_PKTLINKERRPTRr_SIZE
typedef BCM56800_A0_TOQ_PKTLINKERRPTRr_t TOQ_PKTLINKERRPTRr_t;
#define TOQ_PKTLINKERRPTRr_CLR BCM56800_A0_TOQ_PKTLINKERRPTRr_CLR
#define TOQ_PKTLINKERRPTRr_SET BCM56800_A0_TOQ_PKTLINKERRPTRr_SET
#define TOQ_PKTLINKERRPTRr_GET BCM56800_A0_TOQ_PKTLINKERRPTRr_GET
#define TOQ_PKTLINKERRPTRr_PLERRORPOINTERf_GET BCM56800_A0_TOQ_PKTLINKERRPTRr_PLERRORPOINTERf_GET
#define TOQ_PKTLINKERRPTRr_PLERRORPOINTERf_SET BCM56800_A0_TOQ_PKTLINKERRPTRr_PLERRORPOINTERf_SET
#define READ_TOQ_PKTLINKERRPTRr BCM56800_A0_READ_TOQ_PKTLINKERRPTRr
#define WRITE_TOQ_PKTLINKERRPTRr BCM56800_A0_WRITE_TOQ_PKTLINKERRPTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_PKTLINKERRPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOQ_QUEUESTAT
 * BLOCKS:   MMU
 * DESC:     Queue inactive status
 * SIZE:     32
 * FIELDS:
 *     QUEUESTAT        Per port output queue status:logic high means output queue is in inactive state,logic low means output queue is in normal active state.
 *
 ******************************************************************************/
#define BCM56800_A0_TOQ_QUEUESTATr 0x04d0001d

#define BCM56800_A0_TOQ_QUEUESTATr_SIZE 4

/*
 * This structure should be used to declare and program TOQ_QUEUESTAT.
 *
 */
typedef union BCM56800_A0_TOQ_QUEUESTATr_s {
	uint32_t v[1];
	uint32_t toq_queuestat[1];
	uint32_t _toq_queuestat;
} BCM56800_A0_TOQ_QUEUESTATr_t;

#define BCM56800_A0_TOQ_QUEUESTATr_CLR(r) (r).toq_queuestat[0] = 0
#define BCM56800_A0_TOQ_QUEUESTATr_SET(r,d) (r).toq_queuestat[0] = d
#define BCM56800_A0_TOQ_QUEUESTATr_GET(r) (r).toq_queuestat[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOQ_QUEUESTATr_QUEUESTATf_GET(r) (((r).toq_queuestat[0]) & 0x7ff)
#define BCM56800_A0_TOQ_QUEUESTATr_QUEUESTATf_SET(r,f) (r).toq_queuestat[0]=(((r).toq_queuestat[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access TOQ_QUEUESTAT.
 *
 */
#define BCM56800_A0_READ_TOQ_QUEUESTATr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TOQ_QUEUESTATr,(r._toq_queuestat))
#define BCM56800_A0_WRITE_TOQ_QUEUESTATr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TOQ_QUEUESTATr,&(r._toq_queuestat))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOQ_QUEUESTATr BCM56800_A0_TOQ_QUEUESTATr
#define TOQ_QUEUESTATr_SIZE BCM56800_A0_TOQ_QUEUESTATr_SIZE
typedef BCM56800_A0_TOQ_QUEUESTATr_t TOQ_QUEUESTATr_t;
#define TOQ_QUEUESTATr_CLR BCM56800_A0_TOQ_QUEUESTATr_CLR
#define TOQ_QUEUESTATr_SET BCM56800_A0_TOQ_QUEUESTATr_SET
#define TOQ_QUEUESTATr_GET BCM56800_A0_TOQ_QUEUESTATr_GET
#define TOQ_QUEUESTATr_QUEUESTATf_GET BCM56800_A0_TOQ_QUEUESTATr_QUEUESTATf_GET
#define TOQ_QUEUESTATr_QUEUESTATf_SET BCM56800_A0_TOQ_QUEUESTATr_QUEUESTATf_SET
#define READ_TOQ_QUEUESTATr BCM56800_A0_READ_TOQ_QUEUESTATr
#define WRITE_TOQ_QUEUESTATr BCM56800_A0_WRITE_TOQ_QUEUESTATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOQ_QUEUESTATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOTAL_BUFFER_COUNT
 * BLOCKS:   MMU
 * DESC:     TOTAL_BUFFER_COUNT
 * SIZE:     32
 * FIELDS:
 *     TOTAL_BUFFER_COUNT It represents the total number of all cells currently in use by all ports. This is not used for any threshold checking, but is provided as a diagnostic tool.
 *
 ******************************************************************************/
#define BCM56800_A0_TOTAL_BUFFER_COUNTr 0x02d80040

#define BCM56800_A0_TOTAL_BUFFER_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program TOTAL_BUFFER_COUNT.
 *
 */
typedef union BCM56800_A0_TOTAL_BUFFER_COUNTr_s {
	uint32_t v[1];
	uint32_t total_buffer_count[1];
	uint32_t _total_buffer_count;
} BCM56800_A0_TOTAL_BUFFER_COUNTr_t;

#define BCM56800_A0_TOTAL_BUFFER_COUNTr_CLR(r) (r).total_buffer_count[0] = 0
#define BCM56800_A0_TOTAL_BUFFER_COUNTr_SET(r,d) (r).total_buffer_count[0] = d
#define BCM56800_A0_TOTAL_BUFFER_COUNTr_GET(r) (r).total_buffer_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOTAL_BUFFER_COUNTr_TOTAL_BUFFER_COUNTf_GET(r) (((r).total_buffer_count[0]) & 0x3fff)
#define BCM56800_A0_TOTAL_BUFFER_COUNTr_TOTAL_BUFFER_COUNTf_SET(r,f) (r).total_buffer_count[0]=(((r).total_buffer_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TOTAL_BUFFER_COUNT.
 *
 */
#define BCM56800_A0_READ_TOTAL_BUFFER_COUNTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOTAL_BUFFER_COUNTr,(r._total_buffer_count))
#define BCM56800_A0_WRITE_TOTAL_BUFFER_COUNTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOTAL_BUFFER_COUNTr,&(r._total_buffer_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_BUFFER_COUNTr BCM56800_A0_TOTAL_BUFFER_COUNTr
#define TOTAL_BUFFER_COUNTr_SIZE BCM56800_A0_TOTAL_BUFFER_COUNTr_SIZE
typedef BCM56800_A0_TOTAL_BUFFER_COUNTr_t TOTAL_BUFFER_COUNTr_t;
#define TOTAL_BUFFER_COUNTr_CLR BCM56800_A0_TOTAL_BUFFER_COUNTr_CLR
#define TOTAL_BUFFER_COUNTr_SET BCM56800_A0_TOTAL_BUFFER_COUNTr_SET
#define TOTAL_BUFFER_COUNTr_GET BCM56800_A0_TOTAL_BUFFER_COUNTr_GET
#define TOTAL_BUFFER_COUNTr_TOTAL_BUFFER_COUNTf_GET BCM56800_A0_TOTAL_BUFFER_COUNTr_TOTAL_BUFFER_COUNTf_GET
#define TOTAL_BUFFER_COUNTr_TOTAL_BUFFER_COUNTf_SET BCM56800_A0_TOTAL_BUFFER_COUNTr_TOTAL_BUFFER_COUNTf_SET
#define READ_TOTAL_BUFFER_COUNTr BCM56800_A0_READ_TOTAL_BUFFER_COUNTr
#define WRITE_TOTAL_BUFFER_COUNTr BCM56800_A0_WRITE_TOTAL_BUFFER_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOTAL_BUFFER_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOTAL_SHARED_COUNT
 * BLOCKS:   MMU
 * DESC:     TOTAL_SHARED_COUNT
 * SIZE:     32
 * FIELDS:
 *     TOTAL_SHARED_COUNT It represents the total number of "shared" cells in use by all input ports. It is used to calculate the number of shared cells available.
 *
 ******************************************************************************/
#define BCM56800_A0_TOTAL_SHARED_COUNTr 0x02d80041

#define BCM56800_A0_TOTAL_SHARED_COUNTr_SIZE 4

/*
 * This structure should be used to declare and program TOTAL_SHARED_COUNT.
 *
 */
typedef union BCM56800_A0_TOTAL_SHARED_COUNTr_s {
	uint32_t v[1];
	uint32_t total_shared_count[1];
	uint32_t _total_shared_count;
} BCM56800_A0_TOTAL_SHARED_COUNTr_t;

#define BCM56800_A0_TOTAL_SHARED_COUNTr_CLR(r) (r).total_shared_count[0] = 0
#define BCM56800_A0_TOTAL_SHARED_COUNTr_SET(r,d) (r).total_shared_count[0] = d
#define BCM56800_A0_TOTAL_SHARED_COUNTr_GET(r) (r).total_shared_count[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOTAL_SHARED_COUNTr_TOTAL_SHARED_COUNTf_GET(r) (((r).total_shared_count[0]) & 0x3fff)
#define BCM56800_A0_TOTAL_SHARED_COUNTr_TOTAL_SHARED_COUNTf_SET(r,f) (r).total_shared_count[0]=(((r).total_shared_count[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TOTAL_SHARED_COUNT.
 *
 */
#define BCM56800_A0_READ_TOTAL_SHARED_COUNTr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOTAL_SHARED_COUNTr,(r._total_shared_count))
#define BCM56800_A0_WRITE_TOTAL_SHARED_COUNTr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOTAL_SHARED_COUNTr,&(r._total_shared_count))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_SHARED_COUNTr BCM56800_A0_TOTAL_SHARED_COUNTr
#define TOTAL_SHARED_COUNTr_SIZE BCM56800_A0_TOTAL_SHARED_COUNTr_SIZE
typedef BCM56800_A0_TOTAL_SHARED_COUNTr_t TOTAL_SHARED_COUNTr_t;
#define TOTAL_SHARED_COUNTr_CLR BCM56800_A0_TOTAL_SHARED_COUNTr_CLR
#define TOTAL_SHARED_COUNTr_SET BCM56800_A0_TOTAL_SHARED_COUNTr_SET
#define TOTAL_SHARED_COUNTr_GET BCM56800_A0_TOTAL_SHARED_COUNTr_GET
#define TOTAL_SHARED_COUNTr_TOTAL_SHARED_COUNTf_GET BCM56800_A0_TOTAL_SHARED_COUNTr_TOTAL_SHARED_COUNTf_GET
#define TOTAL_SHARED_COUNTr_TOTAL_SHARED_COUNTf_SET BCM56800_A0_TOTAL_SHARED_COUNTr_TOTAL_SHARED_COUNTf_SET
#define READ_TOTAL_SHARED_COUNTr BCM56800_A0_READ_TOTAL_SHARED_COUNTr
#define WRITE_TOTAL_SHARED_COUNTr BCM56800_A0_WRITE_TOTAL_SHARED_COUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOTAL_SHARED_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TOTAL_SHARED_LIMIT
 * BLOCKS:   MMU
 * DESC:     TOTAL_SHARED_LIMIT
 * SIZE:     32
 * FIELDS:
 *     TOTAL_SHARED_LIMIT Initialized by software to the total 'shared' cells allocated.
 *
 ******************************************************************************/
#define BCM56800_A0_TOTAL_SHARED_LIMITr 0x02d80000

#define BCM56800_A0_TOTAL_SHARED_LIMITr_SIZE 4

/*
 * This structure should be used to declare and program TOTAL_SHARED_LIMIT.
 *
 */
typedef union BCM56800_A0_TOTAL_SHARED_LIMITr_s {
	uint32_t v[1];
	uint32_t total_shared_limit[1];
	uint32_t _total_shared_limit;
} BCM56800_A0_TOTAL_SHARED_LIMITr_t;

#define BCM56800_A0_TOTAL_SHARED_LIMITr_CLR(r) (r).total_shared_limit[0] = 0
#define BCM56800_A0_TOTAL_SHARED_LIMITr_SET(r,d) (r).total_shared_limit[0] = d
#define BCM56800_A0_TOTAL_SHARED_LIMITr_GET(r) (r).total_shared_limit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TOTAL_SHARED_LIMITr_TOTAL_SHARED_LIMITf_GET(r) (((r).total_shared_limit[0]) & 0x3fff)
#define BCM56800_A0_TOTAL_SHARED_LIMITr_TOTAL_SHARED_LIMITf_SET(r,f) (r).total_shared_limit[0]=(((r).total_shared_limit[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))

/*
 * These macros can be used to access TOTAL_SHARED_LIMIT.
 *
 */
#define BCM56800_A0_READ_TOTAL_SHARED_LIMITr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_TOTAL_SHARED_LIMITr,(r._total_shared_limit))
#define BCM56800_A0_WRITE_TOTAL_SHARED_LIMITr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_TOTAL_SHARED_LIMITr,&(r._total_shared_limit))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TOTAL_SHARED_LIMITr BCM56800_A0_TOTAL_SHARED_LIMITr
#define TOTAL_SHARED_LIMITr_SIZE BCM56800_A0_TOTAL_SHARED_LIMITr_SIZE
typedef BCM56800_A0_TOTAL_SHARED_LIMITr_t TOTAL_SHARED_LIMITr_t;
#define TOTAL_SHARED_LIMITr_CLR BCM56800_A0_TOTAL_SHARED_LIMITr_CLR
#define TOTAL_SHARED_LIMITr_SET BCM56800_A0_TOTAL_SHARED_LIMITr_SET
#define TOTAL_SHARED_LIMITr_GET BCM56800_A0_TOTAL_SHARED_LIMITr_GET
#define TOTAL_SHARED_LIMITr_TOTAL_SHARED_LIMITf_GET BCM56800_A0_TOTAL_SHARED_LIMITr_TOTAL_SHARED_LIMITf_GET
#define TOTAL_SHARED_LIMITr_TOTAL_SHARED_LIMITf_SET BCM56800_A0_TOTAL_SHARED_LIMITr_TOTAL_SHARED_LIMITf_SET
#define READ_TOTAL_SHARED_LIMITr BCM56800_A0_READ_TOTAL_SHARED_LIMITr
#define WRITE_TOTAL_SHARED_LIMITr BCM56800_A0_WRITE_TOTAL_SHARED_LIMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TOTAL_SHARED_LIMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TPCE
 * BLOCKS:   EPIPE
 * DESC:     Egress Purge and Cell Error Drop Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM56800_A0_TPCEr 0x0a40000c

#define BCM56800_A0_TPCEr_SIZE 4

/*
 * This structure should be used to declare and program TPCE.
 *
 */
typedef union BCM56800_A0_TPCEr_s {
	uint32_t v[1];
	uint32_t tpce[1];
	uint32_t _tpce;
} BCM56800_A0_TPCEr_t;

#define BCM56800_A0_TPCEr_CLR(r) (r).tpce[0] = 0
#define BCM56800_A0_TPCEr_SET(r,d) (r).tpce[0] = d
#define BCM56800_A0_TPCEr_GET(r) (r).tpce[0]


/*
 * These macros can be used to access TPCE.
 *
 */
#define BCM56800_A0_READ_TPCEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_TPCEr,(r._tpce))
#define BCM56800_A0_WRITE_TPCEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_TPCEr,&(r._tpce))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TPCEr BCM56800_A0_TPCEr
#define TPCEr_SIZE BCM56800_A0_TPCEr_SIZE
typedef BCM56800_A0_TPCEr_t TPCEr_t;
#define TPCEr_CLR BCM56800_A0_TPCEr_CLR
#define TPCEr_SET BCM56800_A0_TPCEr_SET
#define TPCEr_GET BCM56800_A0_TPCEr_GET
#define READ_TPCEr BCM56800_A0_READ_TPCEr
#define WRITE_TPCEr BCM56800_A0_WRITE_TPCEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TPCEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  TRUNK_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Source Trunk Bitmap Table
 * SIZE:     21
 * FIELDS:
 *     TRUNK_BITMAP     Source Trunk Bitmap Table
 *
 ******************************************************************************/
#define BCM56800_A0_TRUNK_BITMAPm 0x0e163000

#define BCM56800_A0_TRUNK_BITMAPm_MIN 0
#define BCM56800_A0_TRUNK_BITMAPm_MAX 127
#define BCM56800_A0_TRUNK_BITMAPm_CMAX(u) 127
#define BCM56800_A0_TRUNK_BITMAPm_SIZE 3

/*
 * This structure should be used to declare and program TRUNK_BITMAP.
 *
 */
typedef union BCM56800_A0_TRUNK_BITMAPm_s {
	uint32_t v[1];
	uint32_t trunk_bitmap[1];
	uint32_t _trunk_bitmap;
} BCM56800_A0_TRUNK_BITMAPm_t;

#define BCM56800_A0_TRUNK_BITMAPm_CLR(r) (r).trunk_bitmap[0] = 0
#define BCM56800_A0_TRUNK_BITMAPm_SET(r,d) (r).trunk_bitmap[0] = d
#define BCM56800_A0_TRUNK_BITMAPm_GET(r) (r).trunk_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_GET(r) (((r).trunk_bitmap[0]) & 0x1fffff)
#define BCM56800_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_SET(r,f) (r).trunk_bitmap[0]=(((r).trunk_bitmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TRUNK_BITMAP.
 *
 */
#define BCM56800_A0_READ_TRUNK_BITMAPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_TRUNK_BITMAPm,i,(m._trunk_bitmap),1)
#define BCM56800_A0_WRITE_TRUNK_BITMAPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_TRUNK_BITMAPm,i,&(m._trunk_bitmap),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_BITMAPm BCM56800_A0_TRUNK_BITMAPm
#define TRUNK_BITMAPm_MIN BCM56800_A0_TRUNK_BITMAPm_MIN
#define TRUNK_BITMAPm_MAX BCM56800_A0_TRUNK_BITMAPm_MAX
#define TRUNK_BITMAPm_CMAX(u) BCM56800_A0_TRUNK_BITMAPm_CMAX(u)
#define TRUNK_BITMAPm_SIZE BCM56800_A0_TRUNK_BITMAPm_SIZE
typedef BCM56800_A0_TRUNK_BITMAPm_t TRUNK_BITMAPm_t;
#define TRUNK_BITMAPm_CLR BCM56800_A0_TRUNK_BITMAPm_CLR
#define TRUNK_BITMAPm_SET BCM56800_A0_TRUNK_BITMAPm_SET
#define TRUNK_BITMAPm_GET BCM56800_A0_TRUNK_BITMAPm_GET
#define TRUNK_BITMAPm_TRUNK_BITMAPf_GET BCM56800_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_GET
#define TRUNK_BITMAPm_TRUNK_BITMAPf_SET BCM56800_A0_TRUNK_BITMAPm_TRUNK_BITMAPf_SET
#define READ_TRUNK_BITMAPm BCM56800_A0_READ_TRUNK_BITMAPm
#define WRITE_TRUNK_BITMAPm BCM56800_A0_WRITE_TRUNK_BITMAPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TRUNK_BITMAPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  TRUNK_EGR_MASK
 * BLOCKS:   IPIPE
 * DESC:     Trunk Egress Block Mask Table
 * SIZE:     21
 * FIELDS:
 *     TRUNK_EGRESS_MASK Egress block mask for trunk group
 *
 ******************************************************************************/
#define BCM56800_A0_TRUNK_EGR_MASKm 0x0e161000

#define BCM56800_A0_TRUNK_EGR_MASKm_MIN 0
#define BCM56800_A0_TRUNK_EGR_MASKm_MAX 127
#define BCM56800_A0_TRUNK_EGR_MASKm_CMAX(u) 127
#define BCM56800_A0_TRUNK_EGR_MASKm_SIZE 3

/*
 * This structure should be used to declare and program TRUNK_EGR_MASK.
 *
 */
typedef union BCM56800_A0_TRUNK_EGR_MASKm_s {
	uint32_t v[1];
	uint32_t trunk_egr_mask[1];
	uint32_t _trunk_egr_mask;
} BCM56800_A0_TRUNK_EGR_MASKm_t;

#define BCM56800_A0_TRUNK_EGR_MASKm_CLR(r) (r).trunk_egr_mask[0] = 0
#define BCM56800_A0_TRUNK_EGR_MASKm_SET(r,d) (r).trunk_egr_mask[0] = d
#define BCM56800_A0_TRUNK_EGR_MASKm_GET(r) (r).trunk_egr_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_GET(r) (((r).trunk_egr_mask[0]) & 0x1fffff)
#define BCM56800_A0_TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_SET(r,f) (r).trunk_egr_mask[0]=(((r).trunk_egr_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access TRUNK_EGR_MASK.
 *
 */
#define BCM56800_A0_READ_TRUNK_EGR_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_TRUNK_EGR_MASKm,i,(m._trunk_egr_mask),1)
#define BCM56800_A0_WRITE_TRUNK_EGR_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_TRUNK_EGR_MASKm,i,&(m._trunk_egr_mask),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_EGR_MASKm BCM56800_A0_TRUNK_EGR_MASKm
#define TRUNK_EGR_MASKm_MIN BCM56800_A0_TRUNK_EGR_MASKm_MIN
#define TRUNK_EGR_MASKm_MAX BCM56800_A0_TRUNK_EGR_MASKm_MAX
#define TRUNK_EGR_MASKm_CMAX(u) BCM56800_A0_TRUNK_EGR_MASKm_CMAX(u)
#define TRUNK_EGR_MASKm_SIZE BCM56800_A0_TRUNK_EGR_MASKm_SIZE
typedef BCM56800_A0_TRUNK_EGR_MASKm_t TRUNK_EGR_MASKm_t;
#define TRUNK_EGR_MASKm_CLR BCM56800_A0_TRUNK_EGR_MASKm_CLR
#define TRUNK_EGR_MASKm_SET BCM56800_A0_TRUNK_EGR_MASKm_SET
#define TRUNK_EGR_MASKm_GET BCM56800_A0_TRUNK_EGR_MASKm_GET
#define TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_GET BCM56800_A0_TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_GET
#define TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_SET BCM56800_A0_TRUNK_EGR_MASKm_TRUNK_EGRESS_MASKf_SET
#define READ_TRUNK_EGR_MASKm BCM56800_A0_READ_TRUNK_EGR_MASKm
#define WRITE_TRUNK_EGR_MASKm BCM56800_A0_WRITE_TRUNK_EGR_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TRUNK_EGR_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  TRUNK_GROUP
 * BLOCKS:   IPIPE
 * DESC:     Egress Mask Table
 * SIZE:     102
 * FIELDS:
 *     PORT0            trunk port 0
 *     MODULE0          module id 0
 *     PORT1            trunk port 1
 *     MODULE1          module id 1
 *     PORT2            trunk port 2
 *     MODULE2          module id 2
 *     PORT3            trunk port 3
 *     MODULE3          module id 3
 *     PORT4            trunk port 4
 *     MODULE4          module id 4
 *     PORT5            trunk port 5
 *     MODULE5          module id 5
 *     PORT6            trunk port 6
 *     MODULE6          module id 6
 *     PORT7            trunk port 7
 *     MODULE7          module id 7
 *     RTAG             Supported RTAG values
 *     TG_SIZE          Trunk group size. If set to 0, trunk group size is 1. If set to 1, trunk group size is 2, and so on.
 *
 ******************************************************************************/
#define BCM56800_A0_TRUNK_GROUPm 0x0e162000

#define BCM56800_A0_TRUNK_GROUPm_MIN 0
#define BCM56800_A0_TRUNK_GROUPm_MAX 127
#define BCM56800_A0_TRUNK_GROUPm_CMAX(u) 127
#define BCM56800_A0_TRUNK_GROUPm_SIZE 13

/*
 * This structure should be used to declare and program TRUNK_GROUP.
 *
 */
typedef union BCM56800_A0_TRUNK_GROUPm_s {
	uint32_t v[4];
	uint32_t trunk_group[4];
	uint32_t _trunk_group;
} BCM56800_A0_TRUNK_GROUPm_t;

#define BCM56800_A0_TRUNK_GROUPm_CLR(r) CDK_MEMSET(&((r)._trunk_group), 0, sizeof(BCM56800_A0_TRUNK_GROUPm_t))
#define BCM56800_A0_TRUNK_GROUPm_SET(r,i,d) (r).trunk_group[i] = d
#define BCM56800_A0_TRUNK_GROUPm_GET(r,i) (r).trunk_group[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TRUNK_GROUPm_PORT0f_GET(r) (((r).trunk_group[0]) & 0x1f)
#define BCM56800_A0_TRUNK_GROUPm_PORT0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM56800_A0_TRUNK_GROUPm_MODULE0f_GET(r) ((((r).trunk_group[0]) >> 5) & 0x7f)
#define BCM56800_A0_TRUNK_GROUPm_MODULE0f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))
#define BCM56800_A0_TRUNK_GROUPm_PORT1f_GET(r) ((((r).trunk_group[0]) >> 12) & 0x1f)
#define BCM56800_A0_TRUNK_GROUPm_PORT1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x1f << 12)) | ((((uint32_t)f) & 0x1f) << 12))
#define BCM56800_A0_TRUNK_GROUPm_MODULE1f_GET(r) ((((r).trunk_group[0]) >> 17) & 0x7f)
#define BCM56800_A0_TRUNK_GROUPm_MODULE1f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x7f << 17)) | ((((uint32_t)f) & 0x7f) << 17))
#define BCM56800_A0_TRUNK_GROUPm_PORT2f_GET(r) ((((r).trunk_group[0]) >> 24) & 0x1f)
#define BCM56800_A0_TRUNK_GROUPm_PORT2f_SET(r,f) (r).trunk_group[0]=(((r).trunk_group[0] & ~((uint32_t)0x1f << 24)) | ((((uint32_t)f) & 0x1f) << 24))
#define BCM56800_A0_TRUNK_GROUPm_MODULE2f_GET(r) cdk_field32_get((r).trunk_group,29,35)
#define BCM56800_A0_TRUNK_GROUPm_MODULE2f_SET(r,f) cdk_field32_set((r).trunk_group,29,35,f)
#define BCM56800_A0_TRUNK_GROUPm_PORT3f_GET(r) ((((r).trunk_group[1]) >> 4) & 0x1f)
#define BCM56800_A0_TRUNK_GROUPm_PORT3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM56800_A0_TRUNK_GROUPm_MODULE3f_GET(r) ((((r).trunk_group[1]) >> 9) & 0x7f)
#define BCM56800_A0_TRUNK_GROUPm_MODULE3f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM56800_A0_TRUNK_GROUPm_PORT4f_GET(r) ((((r).trunk_group[1]) >> 16) & 0x1f)
#define BCM56800_A0_TRUNK_GROUPm_PORT4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x1f << 16)) | ((((uint32_t)f) & 0x1f) << 16))
#define BCM56800_A0_TRUNK_GROUPm_MODULE4f_GET(r) ((((r).trunk_group[1]) >> 21) & 0x7f)
#define BCM56800_A0_TRUNK_GROUPm_MODULE4f_SET(r,f) (r).trunk_group[1]=(((r).trunk_group[1] & ~((uint32_t)0x7f << 21)) | ((((uint32_t)f) & 0x7f) << 21))
#define BCM56800_A0_TRUNK_GROUPm_PORT5f_GET(r) cdk_field32_get((r).trunk_group,60,64)
#define BCM56800_A0_TRUNK_GROUPm_PORT5f_SET(r,f) cdk_field32_set((r).trunk_group,60,64,f)
#define BCM56800_A0_TRUNK_GROUPm_MODULE5f_GET(r) ((((r).trunk_group[2]) >> 1) & 0x7f)
#define BCM56800_A0_TRUNK_GROUPm_MODULE5f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))
#define BCM56800_A0_TRUNK_GROUPm_PORT6f_GET(r) ((((r).trunk_group[2]) >> 8) & 0x1f)
#define BCM56800_A0_TRUNK_GROUPm_PORT6f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8))
#define BCM56800_A0_TRUNK_GROUPm_MODULE6f_GET(r) ((((r).trunk_group[2]) >> 13) & 0x7f)
#define BCM56800_A0_TRUNK_GROUPm_MODULE6f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x7f << 13)) | ((((uint32_t)f) & 0x7f) << 13))
#define BCM56800_A0_TRUNK_GROUPm_PORT7f_GET(r) ((((r).trunk_group[2]) >> 20) & 0x1f)
#define BCM56800_A0_TRUNK_GROUPm_PORT7f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM56800_A0_TRUNK_GROUPm_MODULE7f_GET(r) ((((r).trunk_group[2]) >> 25) & 0x7f)
#define BCM56800_A0_TRUNK_GROUPm_MODULE7f_SET(r,f) (r).trunk_group[2]=(((r).trunk_group[2] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))
#define BCM56800_A0_TRUNK_GROUPm_RTAGf_GET(r) (((r).trunk_group[3]) & 0x7)
#define BCM56800_A0_TRUNK_GROUPm_RTAGf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_TRUNK_GROUPm_TG_SIZEf_GET(r) ((((r).trunk_group[3]) >> 3) & 0x7)
#define BCM56800_A0_TRUNK_GROUPm_TG_SIZEf_SET(r,f) (r).trunk_group[3]=(((r).trunk_group[3] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))

/*
 * These macros can be used to access TRUNK_GROUP.
 *
 */
#define BCM56800_A0_READ_TRUNK_GROUPm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_TRUNK_GROUPm,i,(m._trunk_group),4)
#define BCM56800_A0_WRITE_TRUNK_GROUPm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_TRUNK_GROUPm,i,&(m._trunk_group),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GROUPm BCM56800_A0_TRUNK_GROUPm
#define TRUNK_GROUPm_MIN BCM56800_A0_TRUNK_GROUPm_MIN
#define TRUNK_GROUPm_MAX BCM56800_A0_TRUNK_GROUPm_MAX
#define TRUNK_GROUPm_CMAX(u) BCM56800_A0_TRUNK_GROUPm_CMAX(u)
#define TRUNK_GROUPm_SIZE BCM56800_A0_TRUNK_GROUPm_SIZE
typedef BCM56800_A0_TRUNK_GROUPm_t TRUNK_GROUPm_t;
#define TRUNK_GROUPm_CLR BCM56800_A0_TRUNK_GROUPm_CLR
#define TRUNK_GROUPm_SET BCM56800_A0_TRUNK_GROUPm_SET
#define TRUNK_GROUPm_GET BCM56800_A0_TRUNK_GROUPm_GET
#define TRUNK_GROUPm_PORT0f_GET BCM56800_A0_TRUNK_GROUPm_PORT0f_GET
#define TRUNK_GROUPm_PORT0f_SET BCM56800_A0_TRUNK_GROUPm_PORT0f_SET
#define TRUNK_GROUPm_MODULE0f_GET BCM56800_A0_TRUNK_GROUPm_MODULE0f_GET
#define TRUNK_GROUPm_MODULE0f_SET BCM56800_A0_TRUNK_GROUPm_MODULE0f_SET
#define TRUNK_GROUPm_PORT1f_GET BCM56800_A0_TRUNK_GROUPm_PORT1f_GET
#define TRUNK_GROUPm_PORT1f_SET BCM56800_A0_TRUNK_GROUPm_PORT1f_SET
#define TRUNK_GROUPm_MODULE1f_GET BCM56800_A0_TRUNK_GROUPm_MODULE1f_GET
#define TRUNK_GROUPm_MODULE1f_SET BCM56800_A0_TRUNK_GROUPm_MODULE1f_SET
#define TRUNK_GROUPm_PORT2f_GET BCM56800_A0_TRUNK_GROUPm_PORT2f_GET
#define TRUNK_GROUPm_PORT2f_SET BCM56800_A0_TRUNK_GROUPm_PORT2f_SET
#define TRUNK_GROUPm_MODULE2f_GET BCM56800_A0_TRUNK_GROUPm_MODULE2f_GET
#define TRUNK_GROUPm_MODULE2f_SET BCM56800_A0_TRUNK_GROUPm_MODULE2f_SET
#define TRUNK_GROUPm_PORT3f_GET BCM56800_A0_TRUNK_GROUPm_PORT3f_GET
#define TRUNK_GROUPm_PORT3f_SET BCM56800_A0_TRUNK_GROUPm_PORT3f_SET
#define TRUNK_GROUPm_MODULE3f_GET BCM56800_A0_TRUNK_GROUPm_MODULE3f_GET
#define TRUNK_GROUPm_MODULE3f_SET BCM56800_A0_TRUNK_GROUPm_MODULE3f_SET
#define TRUNK_GROUPm_PORT4f_GET BCM56800_A0_TRUNK_GROUPm_PORT4f_GET
#define TRUNK_GROUPm_PORT4f_SET BCM56800_A0_TRUNK_GROUPm_PORT4f_SET
#define TRUNK_GROUPm_MODULE4f_GET BCM56800_A0_TRUNK_GROUPm_MODULE4f_GET
#define TRUNK_GROUPm_MODULE4f_SET BCM56800_A0_TRUNK_GROUPm_MODULE4f_SET
#define TRUNK_GROUPm_PORT5f_GET BCM56800_A0_TRUNK_GROUPm_PORT5f_GET
#define TRUNK_GROUPm_PORT5f_SET BCM56800_A0_TRUNK_GROUPm_PORT5f_SET
#define TRUNK_GROUPm_MODULE5f_GET BCM56800_A0_TRUNK_GROUPm_MODULE5f_GET
#define TRUNK_GROUPm_MODULE5f_SET BCM56800_A0_TRUNK_GROUPm_MODULE5f_SET
#define TRUNK_GROUPm_PORT6f_GET BCM56800_A0_TRUNK_GROUPm_PORT6f_GET
#define TRUNK_GROUPm_PORT6f_SET BCM56800_A0_TRUNK_GROUPm_PORT6f_SET
#define TRUNK_GROUPm_MODULE6f_GET BCM56800_A0_TRUNK_GROUPm_MODULE6f_GET
#define TRUNK_GROUPm_MODULE6f_SET BCM56800_A0_TRUNK_GROUPm_MODULE6f_SET
#define TRUNK_GROUPm_PORT7f_GET BCM56800_A0_TRUNK_GROUPm_PORT7f_GET
#define TRUNK_GROUPm_PORT7f_SET BCM56800_A0_TRUNK_GROUPm_PORT7f_SET
#define TRUNK_GROUPm_MODULE7f_GET BCM56800_A0_TRUNK_GROUPm_MODULE7f_GET
#define TRUNK_GROUPm_MODULE7f_SET BCM56800_A0_TRUNK_GROUPm_MODULE7f_SET
#define TRUNK_GROUPm_RTAGf_GET BCM56800_A0_TRUNK_GROUPm_RTAGf_GET
#define TRUNK_GROUPm_RTAGf_SET BCM56800_A0_TRUNK_GROUPm_RTAGf_SET
#define TRUNK_GROUPm_TG_SIZEf_GET BCM56800_A0_TRUNK_GROUPm_TG_SIZEf_GET
#define TRUNK_GROUPm_TG_SIZEf_SET BCM56800_A0_TRUNK_GROUPm_TG_SIZEf_SET
#define READ_TRUNK_GROUPm BCM56800_A0_READ_TRUNK_GROUPm
#define WRITE_TRUNK_GROUPm BCM56800_A0_WRITE_TRUNK_GROUPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TRUNK_GROUPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TX_CNT_CONFIG
 * BLOCKS:   MMU
 * DESC:     TX packet counter configuration
 * SIZE:     32
 * FIELDS:
 *     TYPE             Configuration type
 *     SRC_PORT         Source port
 *     DST_PORT         Destination port
 *     COS_PRI          COS or priority value
 *
 ******************************************************************************/
#define BCM56800_A0_TX_CNT_CONFIGr 0x0ed80010

#define BCM56800_A0_TX_CNT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program TX_CNT_CONFIG.
 *
 */
typedef union BCM56800_A0_TX_CNT_CONFIGr_s {
	uint32_t v[1];
	uint32_t tx_cnt_config[1];
	uint32_t _tx_cnt_config;
} BCM56800_A0_TX_CNT_CONFIGr_t;

#define BCM56800_A0_TX_CNT_CONFIGr_CLR(r) (r).tx_cnt_config[0] = 0
#define BCM56800_A0_TX_CNT_CONFIGr_SET(r,d) (r).tx_cnt_config[0] = d
#define BCM56800_A0_TX_CNT_CONFIGr_GET(r) (r).tx_cnt_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TX_CNT_CONFIGr_TYPEf_GET(r) (((r).tx_cnt_config[0]) & 0xf)
#define BCM56800_A0_TX_CNT_CONFIGr_TYPEf_SET(r,f) (r).tx_cnt_config[0]=(((r).tx_cnt_config[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM56800_A0_TX_CNT_CONFIGr_SRC_PORTf_GET(r) ((((r).tx_cnt_config[0]) >> 4) & 0x1f)
#define BCM56800_A0_TX_CNT_CONFIGr_SRC_PORTf_SET(r,f) (r).tx_cnt_config[0]=(((r).tx_cnt_config[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM56800_A0_TX_CNT_CONFIGr_DST_PORTf_GET(r) ((((r).tx_cnt_config[0]) >> 9) & 0x1f)
#define BCM56800_A0_TX_CNT_CONFIGr_DST_PORTf_SET(r,f) (r).tx_cnt_config[0]=(((r).tx_cnt_config[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9))
#define BCM56800_A0_TX_CNT_CONFIGr_COS_PRIf_GET(r) ((((r).tx_cnt_config[0]) >> 14) & 0xf)
#define BCM56800_A0_TX_CNT_CONFIGr_COS_PRIf_SET(r,f) (r).tx_cnt_config[0]=(((r).tx_cnt_config[0] & ~((uint32_t)0xf << 14)) | ((((uint32_t)f) & 0xf) << 14))

/*
 * These macros can be used to access TX_CNT_CONFIG.
 *
 */
#define BCM56800_A0_READ_TX_CNT_CONFIGr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_TX_CNT_CONFIGr+(i),(r._tx_cnt_config))
#define BCM56800_A0_WRITE_TX_CNT_CONFIGr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_TX_CNT_CONFIGr+(i),&(r._tx_cnt_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_CNT_CONFIGr BCM56800_A0_TX_CNT_CONFIGr
#define TX_CNT_CONFIGr_SIZE BCM56800_A0_TX_CNT_CONFIGr_SIZE
typedef BCM56800_A0_TX_CNT_CONFIGr_t TX_CNT_CONFIGr_t;
#define TX_CNT_CONFIGr_CLR BCM56800_A0_TX_CNT_CONFIGr_CLR
#define TX_CNT_CONFIGr_SET BCM56800_A0_TX_CNT_CONFIGr_SET
#define TX_CNT_CONFIGr_GET BCM56800_A0_TX_CNT_CONFIGr_GET
#define TX_CNT_CONFIGr_TYPEf_GET BCM56800_A0_TX_CNT_CONFIGr_TYPEf_GET
#define TX_CNT_CONFIGr_TYPEf_SET BCM56800_A0_TX_CNT_CONFIGr_TYPEf_SET
#define TX_CNT_CONFIGr_SRC_PORTf_GET BCM56800_A0_TX_CNT_CONFIGr_SRC_PORTf_GET
#define TX_CNT_CONFIGr_SRC_PORTf_SET BCM56800_A0_TX_CNT_CONFIGr_SRC_PORTf_SET
#define TX_CNT_CONFIGr_DST_PORTf_GET BCM56800_A0_TX_CNT_CONFIGr_DST_PORTf_GET
#define TX_CNT_CONFIGr_DST_PORTf_SET BCM56800_A0_TX_CNT_CONFIGr_DST_PORTf_SET
#define TX_CNT_CONFIGr_COS_PRIf_GET BCM56800_A0_TX_CNT_CONFIGr_COS_PRIf_GET
#define TX_CNT_CONFIGr_COS_PRIf_SET BCM56800_A0_TX_CNT_CONFIGr_COS_PRIf_SET
#define READ_TX_CNT_CONFIGr BCM56800_A0_READ_TX_CNT_CONFIGr
#define WRITE_TX_CNT_CONFIGr BCM56800_A0_WRITE_TX_CNT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TX_CNT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * SWFORMAT:  TX_DCB
 * BLOCKS:  
 * DESC:     Packet DMA descriptor.
 * SIZE:     352
 * FIELDS:
 *     BYTES_TRANSFERRED Number of bytes transferred.
 *     DONE             Descriptor done.
 *     MODULE_HEADER    Valid only if the HG bit is set to 1 in this descriptor.
 *     BYTE_COUNT       Byte count for the transfer.
 *     CHAIN            Indicates that next sequential descriptor is valid.
 *     SG               Scatter/Gather - packet continues in the next DMA descriptor.
 *     RELOAD           Load next descriptor from address in ADDR field.
 *     HG               Specifies whether the current packet is in HiGig format.0=Regular Ethernet format, 1=HiGig format
 *     PURGE            Set to indicate that packets should be purged.
 *     ADDR             Physical memory address for the transfer.
 *
 ******************************************************************************/
#define BCM56800_A0_TX_DCB 0x00000000

#define BCM56800_A0_TX_DCB_SIZE 44

/*
 * This structure should be used to declare and program TX_DCB.
 *
 */
typedef union BCM56800_A0_TX_DCB_s {
	uint32_t v[11];
	uint32_t tx_dcb[11];
	uint32_t _tx_dcb;
} BCM56800_A0_TX_DCB_t;

#define BCM56800_A0_TX_DCB_CLR(r) CDK_MEMSET(&((r)._tx_dcb), 0, sizeof(BCM56800_A0_TX_DCB_t))
#define BCM56800_A0_TX_DCB_SET(r,i,d) (r).tx_dcb[i] = d
#define BCM56800_A0_TX_DCB_GET(r,i) (r).tx_dcb[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TX_DCB_BYTES_TRANSFERREDf_GET(r) (((r).tx_dcb[10]) & 0xffff)
#define BCM56800_A0_TX_DCB_BYTES_TRANSFERREDf_SET(r,f) (r).tx_dcb[10]=(((r).tx_dcb[10] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_TX_DCB_DONEf_GET(r) ((((r).tx_dcb[10]) >> 31) & 0x1)
#define BCM56800_A0_TX_DCB_DONEf_SET(r,f) (r).tx_dcb[10]=(((r).tx_dcb[10] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM56800_A0_TX_DCB_MODULE_HEADERf_GET(r,a) cdk_field_be_get((r).tx_dcb,11,160,287,a)
#define BCM56800_A0_TX_DCB_MODULE_HEADERf_SET(r,a) cdk_field_be_set((r).tx_dcb,11,160,287,a)
#define BCM56800_A0_TX_DCB_MODULE_HEADERf_PTR(r) ((void*)&(r).tx_dcb[2])
#define BCM56800_A0_TX_DCB_BYTE_COUNTf_GET(r) (((r).tx_dcb[1]) & 0xffff)
#define BCM56800_A0_TX_DCB_BYTE_COUNTf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_TX_DCB_CHAINf_GET(r) ((((r).tx_dcb[1]) >> 16) & 0x1)
#define BCM56800_A0_TX_DCB_CHAINf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_TX_DCB_SGf_GET(r) ((((r).tx_dcb[1]) >> 17) & 0x1)
#define BCM56800_A0_TX_DCB_SGf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_TX_DCB_RELOADf_GET(r) ((((r).tx_dcb[1]) >> 18) & 0x1)
#define BCM56800_A0_TX_DCB_RELOADf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_TX_DCB_HGf_GET(r) ((((r).tx_dcb[1]) >> 19) & 0x1)
#define BCM56800_A0_TX_DCB_HGf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_TX_DCB_PURGEf_GET(r) ((((r).tx_dcb[1]) >> 22) & 0x1)
#define BCM56800_A0_TX_DCB_PURGEf_SET(r,f) (r).tx_dcb[1]=(((r).tx_dcb[1] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM56800_A0_TX_DCB_ADDRf_GET(r) ((r).tx_dcb[0])
#define BCM56800_A0_TX_DCB_ADDRf_SET(r,f) (r).tx_dcb[0]=((uint32_t)f)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_DCB BCM56800_A0_TX_DCB
#define TX_DCB_SIZE BCM56800_A0_TX_DCB_SIZE
typedef BCM56800_A0_TX_DCB_t TX_DCB_t;
#define TX_DCB_CLR BCM56800_A0_TX_DCB_CLR
#define TX_DCB_SET BCM56800_A0_TX_DCB_SET
#define TX_DCB_GET BCM56800_A0_TX_DCB_GET
#define TX_DCB_BYTES_TRANSFERREDf_GET BCM56800_A0_TX_DCB_BYTES_TRANSFERREDf_GET
#define TX_DCB_BYTES_TRANSFERREDf_SET BCM56800_A0_TX_DCB_BYTES_TRANSFERREDf_SET
#define TX_DCB_DONEf_GET BCM56800_A0_TX_DCB_DONEf_GET
#define TX_DCB_DONEf_SET BCM56800_A0_TX_DCB_DONEf_SET
#define TX_DCB_MODULE_HEADERf_GET BCM56800_A0_TX_DCB_MODULE_HEADERf_GET
#define TX_DCB_MODULE_HEADERf_SET BCM56800_A0_TX_DCB_MODULE_HEADERf_SET
#define TX_DCB_MODULE_HEADERf_PTR BCM56800_A0_TX_DCB_MODULE_HEADERf_PTR
#define TX_DCB_BYTE_COUNTf_GET BCM56800_A0_TX_DCB_BYTE_COUNTf_GET
#define TX_DCB_BYTE_COUNTf_SET BCM56800_A0_TX_DCB_BYTE_COUNTf_SET
#define TX_DCB_CHAINf_GET BCM56800_A0_TX_DCB_CHAINf_GET
#define TX_DCB_CHAINf_SET BCM56800_A0_TX_DCB_CHAINf_SET
#define TX_DCB_SGf_GET BCM56800_A0_TX_DCB_SGf_GET
#define TX_DCB_SGf_SET BCM56800_A0_TX_DCB_SGf_SET
#define TX_DCB_RELOADf_GET BCM56800_A0_TX_DCB_RELOADf_GET
#define TX_DCB_RELOADf_SET BCM56800_A0_TX_DCB_RELOADf_SET
#define TX_DCB_HGf_GET BCM56800_A0_TX_DCB_HGf_GET
#define TX_DCB_HGf_SET BCM56800_A0_TX_DCB_HGf_SET
#define TX_DCB_PURGEf_GET BCM56800_A0_TX_DCB_PURGEf_GET
#define TX_DCB_PURGEf_SET BCM56800_A0_TX_DCB_PURGEf_SET
#define TX_DCB_ADDRf_GET BCM56800_A0_TX_DCB_ADDRf_GET
#define TX_DCB_ADDRf_SET BCM56800_A0_TX_DCB_ADDRf_SET
#define READ_TX_DCB BCM56800_A0_READ_TX_DCB
#define WRITE_TX_DCB BCM56800_A0_WRITE_TX_DCB

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TX_DCB'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  TX_PKT_CNT
 * BLOCKS:   MMU
 * DESC:     TX packet counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            TX packet count
 *
 ******************************************************************************/
#define BCM56800_A0_TX_PKT_CNTr 0x0ed80020

#define BCM56800_A0_TX_PKT_CNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_PKT_CNT.
 *
 */
typedef union BCM56800_A0_TX_PKT_CNTr_s {
	uint32_t v[1];
	uint32_t tx_pkt_cnt[1];
	uint32_t _tx_pkt_cnt;
} BCM56800_A0_TX_PKT_CNTr_t;

#define BCM56800_A0_TX_PKT_CNTr_CLR(r) (r).tx_pkt_cnt[0] = 0
#define BCM56800_A0_TX_PKT_CNTr_SET(r,d) (r).tx_pkt_cnt[0] = d
#define BCM56800_A0_TX_PKT_CNTr_GET(r) (r).tx_pkt_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_TX_PKT_CNTr_COUNTf_GET(r) ((r).tx_pkt_cnt[0])
#define BCM56800_A0_TX_PKT_CNTr_COUNTf_SET(r,f) (r).tx_pkt_cnt[0]=((uint32_t)f)

/*
 * These macros can be used to access TX_PKT_CNT.
 *
 */
#define BCM56800_A0_READ_TX_PKT_CNTr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_TX_PKT_CNTr+(i),(r._tx_pkt_cnt))
#define BCM56800_A0_WRITE_TX_PKT_CNTr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_TX_PKT_CNTr+(i),&(r._tx_pkt_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PKT_CNTr BCM56800_A0_TX_PKT_CNTr
#define TX_PKT_CNTr_SIZE BCM56800_A0_TX_PKT_CNTr_SIZE
typedef BCM56800_A0_TX_PKT_CNTr_t TX_PKT_CNTr_t;
#define TX_PKT_CNTr_CLR BCM56800_A0_TX_PKT_CNTr_CLR
#define TX_PKT_CNTr_SET BCM56800_A0_TX_PKT_CNTr_SET
#define TX_PKT_CNTr_GET BCM56800_A0_TX_PKT_CNTr_GET
#define TX_PKT_CNTr_COUNTf_GET BCM56800_A0_TX_PKT_CNTr_COUNTf_GET
#define TX_PKT_CNTr_COUNTf_SET BCM56800_A0_TX_PKT_CNTr_COUNTf_SET
#define READ_TX_PKT_CNTr BCM56800_A0_READ_TX_PKT_CNTr
#define WRITE_TX_PKT_CNTr BCM56800_A0_WRITE_TX_PKT_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_TX_PKT_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  UDF_ETHERTYPE_MATCH
 * BLOCKS:   IPIPE
 * DESC:     UDF Ethertype Match Register (used to select unique UDF offsets for different EtherTypes
 * SIZE:     32
 * FIELDS:
 *     ETHERTYPE        Programmable ethertype to match for UDF ethertype match
 *     RESERVED0        Unused bit
 *     L2_PACKET_FORMAT L2 packet format to match for UDF ethertype match
 *     ENABLE           Enables UDF ethertype match
 *
 ******************************************************************************/
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr 0x0218061a

#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_SIZE 4

/*
 * This structure should be used to declare and program UDF_ETHERTYPE_MATCH.
 *
 */
typedef union BCM56800_A0_UDF_ETHERTYPE_MATCHr_s {
	uint32_t v[1];
	uint32_t udf_ethertype_match[1];
	uint32_t _udf_ethertype_match;
} BCM56800_A0_UDF_ETHERTYPE_MATCHr_t;

#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_CLR(r) (r).udf_ethertype_match[0] = 0
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_SET(r,d) (r).udf_ethertype_match[0] = d
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_GET(r) (r).udf_ethertype_match[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET(r) (((r).udf_ethertype_match[0]) & 0xffff)
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_GET(r) ((((r).udf_ethertype_match[0]) >> 16) & 0x1)
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET(r) ((((r).udf_ethertype_match[0]) >> 17) & 0x3)
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_GET(r) ((((r).udf_ethertype_match[0]) >> 19) & 0x1)
#define BCM56800_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_SET(r,f) (r).udf_ethertype_match[0]=(((r).udf_ethertype_match[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access UDF_ETHERTYPE_MATCH.
 *
 */
#define BCM56800_A0_READ_UDF_ETHERTYPE_MATCHr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_UDF_ETHERTYPE_MATCHr+(i),(r._udf_ethertype_match))
#define BCM56800_A0_WRITE_UDF_ETHERTYPE_MATCHr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_UDF_ETHERTYPE_MATCHr+(i),&(r._udf_ethertype_match))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_ETHERTYPE_MATCHr BCM56800_A0_UDF_ETHERTYPE_MATCHr
#define UDF_ETHERTYPE_MATCHr_SIZE BCM56800_A0_UDF_ETHERTYPE_MATCHr_SIZE
typedef BCM56800_A0_UDF_ETHERTYPE_MATCHr_t UDF_ETHERTYPE_MATCHr_t;
#define UDF_ETHERTYPE_MATCHr_CLR BCM56800_A0_UDF_ETHERTYPE_MATCHr_CLR
#define UDF_ETHERTYPE_MATCHr_SET BCM56800_A0_UDF_ETHERTYPE_MATCHr_SET
#define UDF_ETHERTYPE_MATCHr_GET BCM56800_A0_UDF_ETHERTYPE_MATCHr_GET
#define UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET BCM56800_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_GET
#define UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET BCM56800_A0_UDF_ETHERTYPE_MATCHr_ETHERTYPEf_SET
#define UDF_ETHERTYPE_MATCHr_RESERVED0f_GET BCM56800_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_GET
#define UDF_ETHERTYPE_MATCHr_RESERVED0f_SET BCM56800_A0_UDF_ETHERTYPE_MATCHr_RESERVED0f_SET
#define UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET BCM56800_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_GET
#define UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET BCM56800_A0_UDF_ETHERTYPE_MATCHr_L2_PACKET_FORMATf_SET
#define UDF_ETHERTYPE_MATCHr_ENABLEf_GET BCM56800_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_GET
#define UDF_ETHERTYPE_MATCHr_ENABLEf_SET BCM56800_A0_UDF_ETHERTYPE_MATCHr_ENABLEf_SET
#define READ_UDF_ETHERTYPE_MATCHr BCM56800_A0_READ_UDF_ETHERTYPE_MATCHr
#define WRITE_UDF_ETHERTYPE_MATCHr BCM56800_A0_WRITE_UDF_ETHERTYPE_MATCHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_UDF_ETHERTYPE_MATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  UDF_IPPROTO_MATCH
 * BLOCKS:   IPIPE
 * DESC:     UDF IP Protocol Matching Register (select unique UDF offsets for different IP protocols)
 * SIZE:     32
 * FIELDS:
 *     PROTOCOL         IP protocol to match
 *     IPV6ENABLE       Enable this UDF matching mechanism for IPv6
 *     IPV4ENABLE       Enable this UDF matching mechanism for IPv4
 *
 ******************************************************************************/
#define BCM56800_A0_UDF_IPPROTO_MATCHr 0x02180622

#define BCM56800_A0_UDF_IPPROTO_MATCHr_SIZE 4

/*
 * This structure should be used to declare and program UDF_IPPROTO_MATCH.
 *
 */
typedef union BCM56800_A0_UDF_IPPROTO_MATCHr_s {
	uint32_t v[1];
	uint32_t udf_ipproto_match[1];
	uint32_t _udf_ipproto_match;
} BCM56800_A0_UDF_IPPROTO_MATCHr_t;

#define BCM56800_A0_UDF_IPPROTO_MATCHr_CLR(r) (r).udf_ipproto_match[0] = 0
#define BCM56800_A0_UDF_IPPROTO_MATCHr_SET(r,d) (r).udf_ipproto_match[0] = d
#define BCM56800_A0_UDF_IPPROTO_MATCHr_GET(r) (r).udf_ipproto_match[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_GET(r) (((r).udf_ipproto_match[0]) & 0xff)
#define BCM56800_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM56800_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET(r) ((((r).udf_ipproto_match[0]) >> 8) & 0x1)
#define BCM56800_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET(r) ((((r).udf_ipproto_match[0]) >> 9) & 0x1)
#define BCM56800_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET(r,f) (r).udf_ipproto_match[0]=(((r).udf_ipproto_match[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access UDF_IPPROTO_MATCH.
 *
 */
#define BCM56800_A0_READ_UDF_IPPROTO_MATCHr(u,i,r) cdk_xgs_reg32_read(u,BCM56800_A0_UDF_IPPROTO_MATCHr+(i),(r._udf_ipproto_match))
#define BCM56800_A0_WRITE_UDF_IPPROTO_MATCHr(u,i,r) cdk_xgs_reg32_write(u,BCM56800_A0_UDF_IPPROTO_MATCHr+(i),&(r._udf_ipproto_match))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_IPPROTO_MATCHr BCM56800_A0_UDF_IPPROTO_MATCHr
#define UDF_IPPROTO_MATCHr_SIZE BCM56800_A0_UDF_IPPROTO_MATCHr_SIZE
typedef BCM56800_A0_UDF_IPPROTO_MATCHr_t UDF_IPPROTO_MATCHr_t;
#define UDF_IPPROTO_MATCHr_CLR BCM56800_A0_UDF_IPPROTO_MATCHr_CLR
#define UDF_IPPROTO_MATCHr_SET BCM56800_A0_UDF_IPPROTO_MATCHr_SET
#define UDF_IPPROTO_MATCHr_GET BCM56800_A0_UDF_IPPROTO_MATCHr_GET
#define UDF_IPPROTO_MATCHr_PROTOCOLf_GET BCM56800_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_GET
#define UDF_IPPROTO_MATCHr_PROTOCOLf_SET BCM56800_A0_UDF_IPPROTO_MATCHr_PROTOCOLf_SET
#define UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET BCM56800_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_GET
#define UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET BCM56800_A0_UDF_IPPROTO_MATCHr_IPV6ENABLEf_SET
#define UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET BCM56800_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_GET
#define UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET BCM56800_A0_UDF_IPPROTO_MATCHr_IPV4ENABLEf_SET
#define READ_UDF_IPPROTO_MATCHr BCM56800_A0_READ_UDF_IPPROTO_MATCHr
#define WRITE_UDF_IPPROTO_MATCHr BCM56800_A0_WRITE_UDF_IPPROTO_MATCHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_UDF_IPPROTO_MATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  UNKNOWN_HGI_BITMAP
 * BLOCKS:   IPIPE
 * DESC:     Forwarding bitmap for unknown HGI
 * SIZE:     32
 * FIELDS:
 *     BITMAP           Forwarding bitmap for HiGig+ pkts with unknown HGI.
 *
 ******************************************************************************/
#define BCM56800_A0_UNKNOWN_HGI_BITMAPr 0x0110000b

#define BCM56800_A0_UNKNOWN_HGI_BITMAPr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_HGI_BITMAP.
 *
 */
typedef union BCM56800_A0_UNKNOWN_HGI_BITMAPr_s {
	uint32_t v[1];
	uint32_t unknown_hgi_bitmap[1];
	uint32_t _unknown_hgi_bitmap;
} BCM56800_A0_UNKNOWN_HGI_BITMAPr_t;

#define BCM56800_A0_UNKNOWN_HGI_BITMAPr_CLR(r) (r).unknown_hgi_bitmap[0] = 0
#define BCM56800_A0_UNKNOWN_HGI_BITMAPr_SET(r,d) (r).unknown_hgi_bitmap[0] = d
#define BCM56800_A0_UNKNOWN_HGI_BITMAPr_GET(r) (r).unknown_hgi_bitmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_UNKNOWN_HGI_BITMAPr_BITMAPf_GET(r) (((r).unknown_hgi_bitmap[0]) & 0x1fffff)
#define BCM56800_A0_UNKNOWN_HGI_BITMAPr_BITMAPf_SET(r,f) (r).unknown_hgi_bitmap[0]=(((r).unknown_hgi_bitmap[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access UNKNOWN_HGI_BITMAP.
 *
 */
#define BCM56800_A0_READ_UNKNOWN_HGI_BITMAPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_UNKNOWN_HGI_BITMAPr,(r._unknown_hgi_bitmap))
#define BCM56800_A0_WRITE_UNKNOWN_HGI_BITMAPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_UNKNOWN_HGI_BITMAPr,&(r._unknown_hgi_bitmap))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_HGI_BITMAPr BCM56800_A0_UNKNOWN_HGI_BITMAPr
#define UNKNOWN_HGI_BITMAPr_SIZE BCM56800_A0_UNKNOWN_HGI_BITMAPr_SIZE
typedef BCM56800_A0_UNKNOWN_HGI_BITMAPr_t UNKNOWN_HGI_BITMAPr_t;
#define UNKNOWN_HGI_BITMAPr_CLR BCM56800_A0_UNKNOWN_HGI_BITMAPr_CLR
#define UNKNOWN_HGI_BITMAPr_SET BCM56800_A0_UNKNOWN_HGI_BITMAPr_SET
#define UNKNOWN_HGI_BITMAPr_GET BCM56800_A0_UNKNOWN_HGI_BITMAPr_GET
#define UNKNOWN_HGI_BITMAPr_BITMAPf_GET BCM56800_A0_UNKNOWN_HGI_BITMAPr_BITMAPf_GET
#define UNKNOWN_HGI_BITMAPr_BITMAPf_SET BCM56800_A0_UNKNOWN_HGI_BITMAPr_BITMAPf_SET
#define READ_UNKNOWN_HGI_BITMAPr BCM56800_A0_READ_UNKNOWN_HGI_BITMAPr
#define WRITE_UNKNOWN_HGI_BITMAPr BCM56800_A0_WRITE_UNKNOWN_HGI_BITMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_UNKNOWN_HGI_BITMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  UNKNOWN_MCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Multicast Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr 0x0e100041

#define BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_MCAST_BLOCK_MASK.
 *
 */
typedef union BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t unknown_mcast_block_mask[1];
	uint32_t _unknown_mcast_block_mask;
} BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_t;

#define BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_CLR(r) (r).unknown_mcast_block_mask[0] = 0
#define BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_SET(r,d) (r).unknown_mcast_block_mask[0] = d
#define BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_GET(r) (r).unknown_mcast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).unknown_mcast_block_mask[0]) & 0x1fffff)
#define BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).unknown_mcast_block_mask[0]=(((r).unknown_mcast_block_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access UNKNOWN_MCAST_BLOCK_MASK.
 *
 */
#define BCM56800_A0_READ_UNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr,(r._unknown_mcast_block_mask))
#define BCM56800_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr,&(r._unknown_mcast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_MCAST_BLOCK_MASKr BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr
#define UNKNOWN_MCAST_BLOCK_MASKr_SIZE BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_SIZE
typedef BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_t UNKNOWN_MCAST_BLOCK_MASKr_t;
#define UNKNOWN_MCAST_BLOCK_MASKr_CLR BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_CLR
#define UNKNOWN_MCAST_BLOCK_MASKr_SET BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_SET
#define UNKNOWN_MCAST_BLOCK_MASKr_GET BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_GET
#define UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_UNKNOWN_MCAST_BLOCK_MASKr BCM56800_A0_READ_UNKNOWN_MCAST_BLOCK_MASKr
#define WRITE_UNKNOWN_MCAST_BLOCK_MASKr BCM56800_A0_WRITE_UNKNOWN_MCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_UNKNOWN_MCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  UNKNOWN_UCAST_BLOCK_MASK
 * BLOCKS:   IPIPE
 * DESC:     Unknown Unicast Block Mask, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BLK_BITMAP       Bitmap of ports to be blocked
 *
 ******************************************************************************/
#define BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr 0x0e100040

#define BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_SIZE 4

/*
 * This structure should be used to declare and program UNKNOWN_UCAST_BLOCK_MASK.
 *
 */
typedef union BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_s {
	uint32_t v[1];
	uint32_t unknown_ucast_block_mask[1];
	uint32_t _unknown_ucast_block_mask;
} BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_t;

#define BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_CLR(r) (r).unknown_ucast_block_mask[0] = 0
#define BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_SET(r,d) (r).unknown_ucast_block_mask[0] = d
#define BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_GET(r) (r).unknown_ucast_block_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET(r) (((r).unknown_ucast_block_mask[0]) & 0x1fffff)
#define BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET(r,f) (r).unknown_ucast_block_mask[0]=(((r).unknown_ucast_block_mask[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))

/*
 * These macros can be used to access UNKNOWN_UCAST_BLOCK_MASK.
 *
 */
#define BCM56800_A0_READ_UNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr,(r._unknown_ucast_block_mask))
#define BCM56800_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASKr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr,&(r._unknown_ucast_block_mask))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UNKNOWN_UCAST_BLOCK_MASKr BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr
#define UNKNOWN_UCAST_BLOCK_MASKr_SIZE BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_SIZE
typedef BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_t UNKNOWN_UCAST_BLOCK_MASKr_t;
#define UNKNOWN_UCAST_BLOCK_MASKr_CLR BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_CLR
#define UNKNOWN_UCAST_BLOCK_MASKr_SET BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_SET
#define UNKNOWN_UCAST_BLOCK_MASKr_GET BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_GET
#define UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_GET
#define UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr_BLK_BITMAPf_SET
#define READ_UNKNOWN_UCAST_BLOCK_MASKr BCM56800_A0_READ_UNKNOWN_UCAST_BLOCK_MASKr
#define WRITE_UNKNOWN_UCAST_BLOCK_MASKr BCM56800_A0_WRITE_UNKNOWN_UCAST_BLOCK_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_UNKNOWN_UCAST_BLOCK_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_CTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN Control Register #1
 * SIZE:     32
 * FIELDS:
 *     LEARN_VID        LEARN_VID for ARL learning
 *     USE_LEARN_VID    USE LEARN_VID field from this register for ARL learning
 *     INNER_TPID       TPID for inner VLAN, used for double tagging modes only
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_CTRLr 0x01180603

#define BCM56800_A0_VLAN_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_CTRL.
 *
 */
typedef union BCM56800_A0_VLAN_CTRLr_s {
	uint32_t v[1];
	uint32_t vlan_ctrl[1];
	uint32_t _vlan_ctrl;
} BCM56800_A0_VLAN_CTRLr_t;

#define BCM56800_A0_VLAN_CTRLr_CLR(r) (r).vlan_ctrl[0] = 0
#define BCM56800_A0_VLAN_CTRLr_SET(r,d) (r).vlan_ctrl[0] = d
#define BCM56800_A0_VLAN_CTRLr_GET(r) (r).vlan_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_CTRLr_LEARN_VIDf_GET(r) (((r).vlan_ctrl[0]) & 0xfff)
#define BCM56800_A0_VLAN_CTRLr_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM56800_A0_VLAN_CTRLr_USE_LEARN_VIDf_GET(r) ((((r).vlan_ctrl[0]) >> 12) & 0x1)
#define BCM56800_A0_VLAN_CTRLr_USE_LEARN_VIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_VLAN_CTRLr_INNER_TPIDf_GET(r) ((((r).vlan_ctrl[0]) >> 13) & 0xffff)
#define BCM56800_A0_VLAN_CTRLr_INNER_TPIDf_SET(r,f) (r).vlan_ctrl[0]=(((r).vlan_ctrl[0] & ~((uint32_t)0xffff << 13)) | ((((uint32_t)f) & 0xffff) << 13))

/*
 * These macros can be used to access VLAN_CTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_CTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_CTRLr,(r._vlan_ctrl))
#define BCM56800_A0_WRITE_VLAN_CTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_CTRLr,&(r._vlan_ctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRLr BCM56800_A0_VLAN_CTRLr
#define VLAN_CTRLr_SIZE BCM56800_A0_VLAN_CTRLr_SIZE
typedef BCM56800_A0_VLAN_CTRLr_t VLAN_CTRLr_t;
#define VLAN_CTRLr_CLR BCM56800_A0_VLAN_CTRLr_CLR
#define VLAN_CTRLr_SET BCM56800_A0_VLAN_CTRLr_SET
#define VLAN_CTRLr_GET BCM56800_A0_VLAN_CTRLr_GET
#define VLAN_CTRLr_LEARN_VIDf_GET BCM56800_A0_VLAN_CTRLr_LEARN_VIDf_GET
#define VLAN_CTRLr_LEARN_VIDf_SET BCM56800_A0_VLAN_CTRLr_LEARN_VIDf_SET
#define VLAN_CTRLr_USE_LEARN_VIDf_GET BCM56800_A0_VLAN_CTRLr_USE_LEARN_VIDf_GET
#define VLAN_CTRLr_USE_LEARN_VIDf_SET BCM56800_A0_VLAN_CTRLr_USE_LEARN_VIDf_SET
#define VLAN_CTRLr_INNER_TPIDf_GET BCM56800_A0_VLAN_CTRLr_INNER_TPIDf_GET
#define VLAN_CTRLr_INNER_TPIDf_SET BCM56800_A0_VLAN_CTRLr_INNER_TPIDf_SET
#define READ_VLAN_CTRLr BCM56800_A0_READ_VLAN_CTRLr
#define WRITE_VLAN_CTRLr BCM56800_A0_WRITE_VLAN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_CONTROL
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_DBGCTRLr 0x05180c00

#define BCM56800_A0_VLAN_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_DBGCTRL.
 *
 */
typedef union BCM56800_A0_VLAN_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t vlan_dbgctrl[1];
	uint32_t _vlan_dbgctrl;
} BCM56800_A0_VLAN_DBGCTRLr_t;

#define BCM56800_A0_VLAN_DBGCTRLr_CLR(r) (r).vlan_dbgctrl[0] = 0
#define BCM56800_A0_VLAN_DBGCTRLr_SET(r,d) (r).vlan_dbgctrl[0] = d
#define BCM56800_A0_VLAN_DBGCTRLr_GET(r) (r).vlan_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_DBGCTRLr_TMf_GET(r) (((r).vlan_dbgctrl[0]) & 0xf)
#define BCM56800_A0_VLAN_DBGCTRLr_TMf_SET(r,f) (r).vlan_dbgctrl[0]=(((r).vlan_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access VLAN_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_DBGCTRLr,(r._vlan_dbgctrl))
#define BCM56800_A0_WRITE_VLAN_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_DBGCTRLr,&(r._vlan_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_DBGCTRLr BCM56800_A0_VLAN_DBGCTRLr
#define VLAN_DBGCTRLr_SIZE BCM56800_A0_VLAN_DBGCTRLr_SIZE
typedef BCM56800_A0_VLAN_DBGCTRLr_t VLAN_DBGCTRLr_t;
#define VLAN_DBGCTRLr_CLR BCM56800_A0_VLAN_DBGCTRLr_CLR
#define VLAN_DBGCTRLr_SET BCM56800_A0_VLAN_DBGCTRLr_SET
#define VLAN_DBGCTRLr_GET BCM56800_A0_VLAN_DBGCTRLr_GET
#define VLAN_DBGCTRLr_TMf_GET BCM56800_A0_VLAN_DBGCTRLr_TMf_GET
#define VLAN_DBGCTRLr_TMf_SET BCM56800_A0_VLAN_DBGCTRLr_TMf_SET
#define READ_VLAN_DBGCTRLr BCM56800_A0_READ_VLAN_DBGCTRLr
#define WRITE_VLAN_DBGCTRLr BCM56800_A0_WRITE_VLAN_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_MAC
 * BLOCKS:   IPIPE
 * DESC:     Holds key & data for MAC-based VLAN substitution, FeatureSpecific-Ethernet
 * SIZE:     64
 * FIELDS:
 *     MAC_ADDR         MAC address key
 *     VLAN_ID          VLAN ID
 *     PRI              Priority
 *     VALID            VLAN ID
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_MACm 0x04165000

#define BCM56800_A0_VLAN_MACm_MIN 0
#define BCM56800_A0_VLAN_MACm_MAX 1023
#define BCM56800_A0_VLAN_MACm_CMAX(u) 1023
#define BCM56800_A0_VLAN_MACm_SIZE 8

/*
 * This structure should be used to declare and program VLAN_MAC.
 *
 */
typedef union BCM56800_A0_VLAN_MACm_s {
	uint32_t v[2];
	uint32_t vlan_mac[2];
	uint32_t _vlan_mac;
} BCM56800_A0_VLAN_MACm_t;

#define BCM56800_A0_VLAN_MACm_CLR(r) CDK_MEMSET(&((r)._vlan_mac), 0, sizeof(BCM56800_A0_VLAN_MACm_t))
#define BCM56800_A0_VLAN_MACm_SET(r,i,d) (r).vlan_mac[i] = d
#define BCM56800_A0_VLAN_MACm_GET(r,i) (r).vlan_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_MACm_MAC_ADDRf_GET(r,a) cdk_field_get((r).vlan_mac,0,47,a)
#define BCM56800_A0_VLAN_MACm_MAC_ADDRf_SET(r,a) cdk_field_set((r).vlan_mac,0,47,a)
#define BCM56800_A0_VLAN_MACm_VLAN_IDf_GET(r) ((((r).vlan_mac[1]) >> 16) & 0xfff)
#define BCM56800_A0_VLAN_MACm_VLAN_IDf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM56800_A0_VLAN_MACm_PRIf_GET(r) ((((r).vlan_mac[1]) >> 28) & 0x7)
#define BCM56800_A0_VLAN_MACm_PRIf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM56800_A0_VLAN_MACm_VALIDf_GET(r) ((((r).vlan_mac[1]) >> 31) & 0x1)
#define BCM56800_A0_VLAN_MACm_VALIDf_SET(r,f) (r).vlan_mac[1]=(((r).vlan_mac[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access VLAN_MAC.
 *
 */
#define BCM56800_A0_READ_VLAN_MACm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_MACm,i,(m._vlan_mac),2)
#define BCM56800_A0_WRITE_VLAN_MACm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_MACm,i,&(m._vlan_mac),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MACm BCM56800_A0_VLAN_MACm
#define VLAN_MACm_MIN BCM56800_A0_VLAN_MACm_MIN
#define VLAN_MACm_MAX BCM56800_A0_VLAN_MACm_MAX
#define VLAN_MACm_CMAX(u) BCM56800_A0_VLAN_MACm_CMAX(u)
#define VLAN_MACm_SIZE BCM56800_A0_VLAN_MACm_SIZE
typedef BCM56800_A0_VLAN_MACm_t VLAN_MACm_t;
#define VLAN_MACm_CLR BCM56800_A0_VLAN_MACm_CLR
#define VLAN_MACm_SET BCM56800_A0_VLAN_MACm_SET
#define VLAN_MACm_GET BCM56800_A0_VLAN_MACm_GET
#define VLAN_MACm_MAC_ADDRf_GET BCM56800_A0_VLAN_MACm_MAC_ADDRf_GET
#define VLAN_MACm_MAC_ADDRf_SET BCM56800_A0_VLAN_MACm_MAC_ADDRf_SET
#define VLAN_MACm_VLAN_IDf_GET BCM56800_A0_VLAN_MACm_VLAN_IDf_GET
#define VLAN_MACm_VLAN_IDf_SET BCM56800_A0_VLAN_MACm_VLAN_IDf_SET
#define VLAN_MACm_PRIf_GET BCM56800_A0_VLAN_MACm_PRIf_GET
#define VLAN_MACm_PRIf_SET BCM56800_A0_VLAN_MACm_PRIf_SET
#define VLAN_MACm_VALIDf_GET BCM56800_A0_VLAN_MACm_VALIDf_GET
#define VLAN_MACm_VALIDf_SET BCM56800_A0_VLAN_MACm_VALIDf_SET
#define READ_VLAN_MACm BCM56800_A0_READ_VLAN_MACm
#define WRITE_VLAN_MACm BCM56800_A0_WRITE_VLAN_MACm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_MACm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_MAC_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_MAC_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_MAC_DBGCTRLr 0x04180c11

#define BCM56800_A0_VLAN_MAC_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_MAC_DBGCTRL.
 *
 */
typedef union BCM56800_A0_VLAN_MAC_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t vlan_mac_dbgctrl[1];
	uint32_t _vlan_mac_dbgctrl;
} BCM56800_A0_VLAN_MAC_DBGCTRLr_t;

#define BCM56800_A0_VLAN_MAC_DBGCTRLr_CLR(r) (r).vlan_mac_dbgctrl[0] = 0
#define BCM56800_A0_VLAN_MAC_DBGCTRLr_SET(r,d) (r).vlan_mac_dbgctrl[0] = d
#define BCM56800_A0_VLAN_MAC_DBGCTRLr_GET(r) (r).vlan_mac_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_MAC_DBGCTRLr_TMf_GET(r) (((r).vlan_mac_dbgctrl[0]) & 0xf)
#define BCM56800_A0_VLAN_MAC_DBGCTRLr_TMf_SET(r,f) (r).vlan_mac_dbgctrl[0]=(((r).vlan_mac_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access VLAN_MAC_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_MAC_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_MAC_DBGCTRLr,(r._vlan_mac_dbgctrl))
#define BCM56800_A0_WRITE_VLAN_MAC_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_MAC_DBGCTRLr,&(r._vlan_mac_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MAC_DBGCTRLr BCM56800_A0_VLAN_MAC_DBGCTRLr
#define VLAN_MAC_DBGCTRLr_SIZE BCM56800_A0_VLAN_MAC_DBGCTRLr_SIZE
typedef BCM56800_A0_VLAN_MAC_DBGCTRLr_t VLAN_MAC_DBGCTRLr_t;
#define VLAN_MAC_DBGCTRLr_CLR BCM56800_A0_VLAN_MAC_DBGCTRLr_CLR
#define VLAN_MAC_DBGCTRLr_SET BCM56800_A0_VLAN_MAC_DBGCTRLr_SET
#define VLAN_MAC_DBGCTRLr_GET BCM56800_A0_VLAN_MAC_DBGCTRLr_GET
#define VLAN_MAC_DBGCTRLr_TMf_GET BCM56800_A0_VLAN_MAC_DBGCTRLr_TMf_GET
#define VLAN_MAC_DBGCTRLr_TMf_SET BCM56800_A0_VLAN_MAC_DBGCTRLr_TMf_SET
#define READ_VLAN_MAC_DBGCTRLr BCM56800_A0_READ_VLAN_MAC_DBGCTRLr
#define WRITE_VLAN_MAC_DBGCTRLr BCM56800_A0_WRITE_VLAN_MAC_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_MAC_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_PARITY_CONTROL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_PARITY_CONTROL
 * SIZE:     32
 * FIELDS:
 *     PARITY_IRQ_EN    This bit is AND'd with the PARITY_ERR bit of the PARITY_STATUS register to generate the parity irq.  The PARITY_ERR and ENTRY_IDX are sticky while this bit is set.  Clearing this bit clears the PARITY_ERR bit.
 *     PARITY_EN        This bit enables parity checking for the VLAN table.
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_PARITY_CONTROLr 0x05180c02

#define BCM56800_A0_VLAN_PARITY_CONTROLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_PARITY_CONTROL.
 *
 */
typedef union BCM56800_A0_VLAN_PARITY_CONTROLr_s {
	uint32_t v[1];
	uint32_t vlan_parity_control[1];
	uint32_t _vlan_parity_control;
} BCM56800_A0_VLAN_PARITY_CONTROLr_t;

#define BCM56800_A0_VLAN_PARITY_CONTROLr_CLR(r) (r).vlan_parity_control[0] = 0
#define BCM56800_A0_VLAN_PARITY_CONTROLr_SET(r,d) (r).vlan_parity_control[0] = d
#define BCM56800_A0_VLAN_PARITY_CONTROLr_GET(r) (r).vlan_parity_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET(r) (((r).vlan_parity_control[0]) & 0x1)
#define BCM56800_A0_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET(r,f) (r).vlan_parity_control[0]=(((r).vlan_parity_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_PARITY_CONTROLr_PARITY_ENf_GET(r) ((((r).vlan_parity_control[0]) >> 1) & 0x1)
#define BCM56800_A0_VLAN_PARITY_CONTROLr_PARITY_ENf_SET(r,f) (r).vlan_parity_control[0]=(((r).vlan_parity_control[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_PARITY_CONTROL.
 *
 */
#define BCM56800_A0_READ_VLAN_PARITY_CONTROLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_PARITY_CONTROLr,(r._vlan_parity_control))
#define BCM56800_A0_WRITE_VLAN_PARITY_CONTROLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_PARITY_CONTROLr,&(r._vlan_parity_control))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PARITY_CONTROLr BCM56800_A0_VLAN_PARITY_CONTROLr
#define VLAN_PARITY_CONTROLr_SIZE BCM56800_A0_VLAN_PARITY_CONTROLr_SIZE
typedef BCM56800_A0_VLAN_PARITY_CONTROLr_t VLAN_PARITY_CONTROLr_t;
#define VLAN_PARITY_CONTROLr_CLR BCM56800_A0_VLAN_PARITY_CONTROLr_CLR
#define VLAN_PARITY_CONTROLr_SET BCM56800_A0_VLAN_PARITY_CONTROLr_SET
#define VLAN_PARITY_CONTROLr_GET BCM56800_A0_VLAN_PARITY_CONTROLr_GET
#define VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET BCM56800_A0_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_GET
#define VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET BCM56800_A0_VLAN_PARITY_CONTROLr_PARITY_IRQ_ENf_SET
#define VLAN_PARITY_CONTROLr_PARITY_ENf_GET BCM56800_A0_VLAN_PARITY_CONTROLr_PARITY_ENf_GET
#define VLAN_PARITY_CONTROLr_PARITY_ENf_SET BCM56800_A0_VLAN_PARITY_CONTROLr_PARITY_ENf_SET
#define READ_VLAN_PARITY_CONTROLr BCM56800_A0_READ_VLAN_PARITY_CONTROLr
#define WRITE_VLAN_PARITY_CONTROLr BCM56800_A0_WRITE_VLAN_PARITY_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_PARITY_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_PARITY_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_PARITY_STATUS
 * SIZE:     32
 * FIELDS:
 *     PARITY_ERR       This bit when set indicates that a parity error has been detected.
 *     ENTRY_IDX        This field indicates the index to the entry in which the parity error was detected.
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_PARITY_STATUSr 0x05180c03

#define BCM56800_A0_VLAN_PARITY_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_PARITY_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_PARITY_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_parity_status[1];
	uint32_t _vlan_parity_status;
} BCM56800_A0_VLAN_PARITY_STATUSr_t;

#define BCM56800_A0_VLAN_PARITY_STATUSr_CLR(r) (r).vlan_parity_status[0] = 0
#define BCM56800_A0_VLAN_PARITY_STATUSr_SET(r,d) (r).vlan_parity_status[0] = d
#define BCM56800_A0_VLAN_PARITY_STATUSr_GET(r) (r).vlan_parity_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_PARITY_STATUSr_PARITY_ERRf_GET(r) (((r).vlan_parity_status[0]) & 0x1)
#define BCM56800_A0_VLAN_PARITY_STATUSr_PARITY_ERRf_SET(r,f) (r).vlan_parity_status[0]=(((r).vlan_parity_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_PARITY_STATUSr_ENTRY_IDXf_GET(r) ((((r).vlan_parity_status[0]) >> 1) & 0xfff)
#define BCM56800_A0_VLAN_PARITY_STATUSr_ENTRY_IDXf_SET(r,f) (r).vlan_parity_status[0]=(((r).vlan_parity_status[0] & ~((uint32_t)0xfff << 1)) | ((((uint32_t)f) & 0xfff) << 1))

/*
 * These macros can be used to access VLAN_PARITY_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_PARITY_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_PARITY_STATUSr,(r._vlan_parity_status))
#define BCM56800_A0_WRITE_VLAN_PARITY_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_PARITY_STATUSr,&(r._vlan_parity_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PARITY_STATUSr BCM56800_A0_VLAN_PARITY_STATUSr
#define VLAN_PARITY_STATUSr_SIZE BCM56800_A0_VLAN_PARITY_STATUSr_SIZE
typedef BCM56800_A0_VLAN_PARITY_STATUSr_t VLAN_PARITY_STATUSr_t;
#define VLAN_PARITY_STATUSr_CLR BCM56800_A0_VLAN_PARITY_STATUSr_CLR
#define VLAN_PARITY_STATUSr_SET BCM56800_A0_VLAN_PARITY_STATUSr_SET
#define VLAN_PARITY_STATUSr_GET BCM56800_A0_VLAN_PARITY_STATUSr_GET
#define VLAN_PARITY_STATUSr_PARITY_ERRf_GET BCM56800_A0_VLAN_PARITY_STATUSr_PARITY_ERRf_GET
#define VLAN_PARITY_STATUSr_PARITY_ERRf_SET BCM56800_A0_VLAN_PARITY_STATUSr_PARITY_ERRf_SET
#define VLAN_PARITY_STATUSr_ENTRY_IDXf_GET BCM56800_A0_VLAN_PARITY_STATUSr_ENTRY_IDXf_GET
#define VLAN_PARITY_STATUSr_ENTRY_IDXf_SET BCM56800_A0_VLAN_PARITY_STATUSr_ENTRY_IDXf_SET
#define READ_VLAN_PARITY_STATUSr BCM56800_A0_READ_VLAN_PARITY_STATUSr
#define WRITE_VLAN_PARITY_STATUSr BCM56800_A0_WRITE_VLAN_PARITY_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_PARITY_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_PROTOCOL
 * BLOCKS:   IPIPE
 * DESC:     Holds data for Protocol-based VLAN substitution.  Just the VLAN_PROTOCOL RAM. FeatureSpecific-Ethernet
 * SIZE:     21
 * FIELDS:
 *     ETHERTYPE        Ethertype field
 *     LLC              LLC type pkt
 *     SNAP             SNAP type pkt
 *     ETHERII          Ethernet 2 type pkt
 *     MATCHLOWER       Match lower
 *     MATCHUPPER       Match upper
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_PROTOCOLm 0x04160000

#define BCM56800_A0_VLAN_PROTOCOLm_MIN 0
#define BCM56800_A0_VLAN_PROTOCOLm_MAX 15
#define BCM56800_A0_VLAN_PROTOCOLm_CMAX(u) 15
#define BCM56800_A0_VLAN_PROTOCOLm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_PROTOCOL.
 *
 */
typedef union BCM56800_A0_VLAN_PROTOCOLm_s {
	uint32_t v[1];
	uint32_t vlan_protocol[1];
	uint32_t _vlan_protocol;
} BCM56800_A0_VLAN_PROTOCOLm_t;

#define BCM56800_A0_VLAN_PROTOCOLm_CLR(r) (r).vlan_protocol[0] = 0
#define BCM56800_A0_VLAN_PROTOCOLm_SET(r,d) (r).vlan_protocol[0] = d
#define BCM56800_A0_VLAN_PROTOCOLm_GET(r) (r).vlan_protocol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_PROTOCOLm_ETHERTYPEf_GET(r) (((r).vlan_protocol[0]) & 0xffff)
#define BCM56800_A0_VLAN_PROTOCOLm_ETHERTYPEf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM56800_A0_VLAN_PROTOCOLm_LLCf_GET(r) ((((r).vlan_protocol[0]) >> 16) & 0x1)
#define BCM56800_A0_VLAN_PROTOCOLm_LLCf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_VLAN_PROTOCOLm_SNAPf_GET(r) ((((r).vlan_protocol[0]) >> 17) & 0x1)
#define BCM56800_A0_VLAN_PROTOCOLm_SNAPf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM56800_A0_VLAN_PROTOCOLm_ETHERIIf_GET(r) ((((r).vlan_protocol[0]) >> 18) & 0x1)
#define BCM56800_A0_VLAN_PROTOCOLm_ETHERIIf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_VLAN_PROTOCOLm_MATCHLOWERf_GET(r) ((((r).vlan_protocol[0]) >> 19) & 0x1)
#define BCM56800_A0_VLAN_PROTOCOLm_MATCHLOWERf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM56800_A0_VLAN_PROTOCOLm_MATCHUPPERf_GET(r) ((((r).vlan_protocol[0]) >> 20) & 0x1)
#define BCM56800_A0_VLAN_PROTOCOLm_MATCHUPPERf_SET(r,f) (r).vlan_protocol[0]=(((r).vlan_protocol[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access VLAN_PROTOCOL.
 *
 */
#define BCM56800_A0_READ_VLAN_PROTOCOLm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_PROTOCOLm,i,(m._vlan_protocol),1)
#define BCM56800_A0_WRITE_VLAN_PROTOCOLm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_PROTOCOLm,i,&(m._vlan_protocol),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOLm BCM56800_A0_VLAN_PROTOCOLm
#define VLAN_PROTOCOLm_MIN BCM56800_A0_VLAN_PROTOCOLm_MIN
#define VLAN_PROTOCOLm_MAX BCM56800_A0_VLAN_PROTOCOLm_MAX
#define VLAN_PROTOCOLm_CMAX(u) BCM56800_A0_VLAN_PROTOCOLm_CMAX(u)
#define VLAN_PROTOCOLm_SIZE BCM56800_A0_VLAN_PROTOCOLm_SIZE
typedef BCM56800_A0_VLAN_PROTOCOLm_t VLAN_PROTOCOLm_t;
#define VLAN_PROTOCOLm_CLR BCM56800_A0_VLAN_PROTOCOLm_CLR
#define VLAN_PROTOCOLm_SET BCM56800_A0_VLAN_PROTOCOLm_SET
#define VLAN_PROTOCOLm_GET BCM56800_A0_VLAN_PROTOCOLm_GET
#define VLAN_PROTOCOLm_ETHERTYPEf_GET BCM56800_A0_VLAN_PROTOCOLm_ETHERTYPEf_GET
#define VLAN_PROTOCOLm_ETHERTYPEf_SET BCM56800_A0_VLAN_PROTOCOLm_ETHERTYPEf_SET
#define VLAN_PROTOCOLm_LLCf_GET BCM56800_A0_VLAN_PROTOCOLm_LLCf_GET
#define VLAN_PROTOCOLm_LLCf_SET BCM56800_A0_VLAN_PROTOCOLm_LLCf_SET
#define VLAN_PROTOCOLm_SNAPf_GET BCM56800_A0_VLAN_PROTOCOLm_SNAPf_GET
#define VLAN_PROTOCOLm_SNAPf_SET BCM56800_A0_VLAN_PROTOCOLm_SNAPf_SET
#define VLAN_PROTOCOLm_ETHERIIf_GET BCM56800_A0_VLAN_PROTOCOLm_ETHERIIf_GET
#define VLAN_PROTOCOLm_ETHERIIf_SET BCM56800_A0_VLAN_PROTOCOLm_ETHERIIf_SET
#define VLAN_PROTOCOLm_MATCHLOWERf_GET BCM56800_A0_VLAN_PROTOCOLm_MATCHLOWERf_GET
#define VLAN_PROTOCOLm_MATCHLOWERf_SET BCM56800_A0_VLAN_PROTOCOLm_MATCHLOWERf_SET
#define VLAN_PROTOCOLm_MATCHUPPERf_GET BCM56800_A0_VLAN_PROTOCOLm_MATCHUPPERf_GET
#define VLAN_PROTOCOLm_MATCHUPPERf_SET BCM56800_A0_VLAN_PROTOCOLm_MATCHUPPERf_SET
#define READ_VLAN_PROTOCOLm BCM56800_A0_READ_VLAN_PROTOCOLm
#define WRITE_VLAN_PROTOCOLm BCM56800_A0_WRITE_VLAN_PROTOCOLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_PROTOCOLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_PROTOCOL_DATA
 * BLOCKS:   IPIPE
 * DESC:     Holds data for Protocol-based VLAN substitution, FeatureSpecific-Ethernet
 * SIZE:     15
 * FIELDS:
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_PROTOCOL_DATAm 0x04161000

#define BCM56800_A0_VLAN_PROTOCOL_DATAm_MIN 0
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_MAX 335
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_CMAX(u) 335
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_SIZE 2

/*
 * This structure should be used to declare and program VLAN_PROTOCOL_DATA.
 *
 */
typedef union BCM56800_A0_VLAN_PROTOCOL_DATAm_s {
	uint32_t v[1];
	uint32_t vlan_protocol_data[1];
	uint32_t _vlan_protocol_data;
} BCM56800_A0_VLAN_PROTOCOL_DATAm_t;

#define BCM56800_A0_VLAN_PROTOCOL_DATAm_CLR(r) (r).vlan_protocol_data[0] = 0
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_SET(r,d) (r).vlan_protocol_data[0] = d
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_GET(r) (r).vlan_protocol_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_PRIf_GET(r) (((r).vlan_protocol_data[0]) & 0x7)
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_PRIf_SET(r,f) (r).vlan_protocol_data[0]=(((r).vlan_protocol_data[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_GET(r) ((((r).vlan_protocol_data[0]) >> 3) & 0xfff)
#define BCM56800_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_SET(r,f) (r).vlan_protocol_data[0]=(((r).vlan_protocol_data[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access VLAN_PROTOCOL_DATA.
 *
 */
#define BCM56800_A0_READ_VLAN_PROTOCOL_DATAm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_PROTOCOL_DATAm,i,(m._vlan_protocol_data),1)
#define BCM56800_A0_WRITE_VLAN_PROTOCOL_DATAm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_PROTOCOL_DATAm,i,&(m._vlan_protocol_data),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOL_DATAm BCM56800_A0_VLAN_PROTOCOL_DATAm
#define VLAN_PROTOCOL_DATAm_MIN BCM56800_A0_VLAN_PROTOCOL_DATAm_MIN
#define VLAN_PROTOCOL_DATAm_MAX BCM56800_A0_VLAN_PROTOCOL_DATAm_MAX
#define VLAN_PROTOCOL_DATAm_CMAX(u) BCM56800_A0_VLAN_PROTOCOL_DATAm_CMAX(u)
#define VLAN_PROTOCOL_DATAm_SIZE BCM56800_A0_VLAN_PROTOCOL_DATAm_SIZE
typedef BCM56800_A0_VLAN_PROTOCOL_DATAm_t VLAN_PROTOCOL_DATAm_t;
#define VLAN_PROTOCOL_DATAm_CLR BCM56800_A0_VLAN_PROTOCOL_DATAm_CLR
#define VLAN_PROTOCOL_DATAm_SET BCM56800_A0_VLAN_PROTOCOL_DATAm_SET
#define VLAN_PROTOCOL_DATAm_GET BCM56800_A0_VLAN_PROTOCOL_DATAm_GET
#define VLAN_PROTOCOL_DATAm_PRIf_GET BCM56800_A0_VLAN_PROTOCOL_DATAm_PRIf_GET
#define VLAN_PROTOCOL_DATAm_PRIf_SET BCM56800_A0_VLAN_PROTOCOL_DATAm_PRIf_SET
#define VLAN_PROTOCOL_DATAm_VLAN_IDf_GET BCM56800_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_GET
#define VLAN_PROTOCOL_DATAm_VLAN_IDf_SET BCM56800_A0_VLAN_PROTOCOL_DATAm_VLAN_IDf_SET
#define READ_VLAN_PROTOCOL_DATAm BCM56800_A0_READ_VLAN_PROTOCOL_DATAm
#define WRITE_VLAN_PROTOCOL_DATAm BCM56800_A0_WRITE_VLAN_PROTOCOL_DATAm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_PROTOCOL_DATAm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_PROTOCOL_DATA_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_PROTOCOL_DATA_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr 0x04180c12

#define BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_PROTOCOL_DATA_DBGCTRL.
 *
 */
typedef union BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t vlan_protocol_data_dbgctrl[1];
	uint32_t _vlan_protocol_data_dbgctrl;
} BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_t;

#define BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_CLR(r) (r).vlan_protocol_data_dbgctrl[0] = 0
#define BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_SET(r,d) (r).vlan_protocol_data_dbgctrl[0] = d
#define BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_GET(r) (r).vlan_protocol_data_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_TMf_GET(r) (((r).vlan_protocol_data_dbgctrl[0]) & 0xf)
#define BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_TMf_SET(r,f) (r).vlan_protocol_data_dbgctrl[0]=(((r).vlan_protocol_data_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access VLAN_PROTOCOL_DATA_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_PROTOCOL_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr,(r._vlan_protocol_data_dbgctrl))
#define BCM56800_A0_WRITE_VLAN_PROTOCOL_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr,&(r._vlan_protocol_data_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_PROTOCOL_DATA_DBGCTRLr BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr
#define VLAN_PROTOCOL_DATA_DBGCTRLr_SIZE BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_SIZE
typedef BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_t VLAN_PROTOCOL_DATA_DBGCTRLr_t;
#define VLAN_PROTOCOL_DATA_DBGCTRLr_CLR BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_CLR
#define VLAN_PROTOCOL_DATA_DBGCTRLr_SET BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_SET
#define VLAN_PROTOCOL_DATA_DBGCTRLr_GET BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_GET
#define VLAN_PROTOCOL_DATA_DBGCTRLr_TMf_GET BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_TMf_GET
#define VLAN_PROTOCOL_DATA_DBGCTRLr_TMf_SET BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr_TMf_SET
#define READ_VLAN_PROTOCOL_DATA_DBGCTRLr BCM56800_A0_READ_VLAN_PROTOCOL_DATA_DBGCTRLr
#define WRITE_VLAN_PROTOCOL_DATA_DBGCTRLr BCM56800_A0_WRITE_VLAN_PROTOCOL_DATA_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_PROTOCOL_DATA_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_STG_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_STG_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_STG_DBGCTRLr 0x05180c01

#define BCM56800_A0_VLAN_STG_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_STG_DBGCTRL.
 *
 */
typedef union BCM56800_A0_VLAN_STG_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t vlan_stg_dbgctrl[1];
	uint32_t _vlan_stg_dbgctrl;
} BCM56800_A0_VLAN_STG_DBGCTRLr_t;

#define BCM56800_A0_VLAN_STG_DBGCTRLr_CLR(r) (r).vlan_stg_dbgctrl[0] = 0
#define BCM56800_A0_VLAN_STG_DBGCTRLr_SET(r,d) (r).vlan_stg_dbgctrl[0] = d
#define BCM56800_A0_VLAN_STG_DBGCTRLr_GET(r) (r).vlan_stg_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_STG_DBGCTRLr_TMf_GET(r) (((r).vlan_stg_dbgctrl[0]) & 0xf)
#define BCM56800_A0_VLAN_STG_DBGCTRLr_TMf_SET(r,f) (r).vlan_stg_dbgctrl[0]=(((r).vlan_stg_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access VLAN_STG_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_STG_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_STG_DBGCTRLr,(r._vlan_stg_dbgctrl))
#define BCM56800_A0_WRITE_VLAN_STG_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_STG_DBGCTRLr,&(r._vlan_stg_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_STG_DBGCTRLr BCM56800_A0_VLAN_STG_DBGCTRLr
#define VLAN_STG_DBGCTRLr_SIZE BCM56800_A0_VLAN_STG_DBGCTRLr_SIZE
typedef BCM56800_A0_VLAN_STG_DBGCTRLr_t VLAN_STG_DBGCTRLr_t;
#define VLAN_STG_DBGCTRLr_CLR BCM56800_A0_VLAN_STG_DBGCTRLr_CLR
#define VLAN_STG_DBGCTRLr_SET BCM56800_A0_VLAN_STG_DBGCTRLr_SET
#define VLAN_STG_DBGCTRLr_GET BCM56800_A0_VLAN_STG_DBGCTRLr_GET
#define VLAN_STG_DBGCTRLr_TMf_GET BCM56800_A0_VLAN_STG_DBGCTRLr_TMf_GET
#define VLAN_STG_DBGCTRLr_TMf_SET BCM56800_A0_VLAN_STG_DBGCTRLr_TMf_SET
#define READ_VLAN_STG_DBGCTRLr BCM56800_A0_READ_VLAN_STG_DBGCTRLr
#define WRITE_VLAN_STG_DBGCTRLr BCM56800_A0_WRITE_VLAN_STG_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_STG_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_SUBNET
 * BLOCKS:   IPIPE
 * DESC:     TCAM for IP subnet based VLAN substitution, FeatureSpecific-Ethernet
 * SIZE:     144
 * FIELDS:
 *     VALID            IP Subnet mask
 *     IP_ADDR          IP Address key
 *     MASK             IP Subnet mask
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNETm 0x04162000

#define BCM56800_A0_VLAN_SUBNETm_MIN 0
#define BCM56800_A0_VLAN_SUBNETm_MAX 255
#define BCM56800_A0_VLAN_SUBNETm_CMAX(u) 255
#define BCM56800_A0_VLAN_SUBNETm_SIZE 18

/*
 * This structure should be used to declare and program VLAN_SUBNET.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNETm_s {
	uint32_t v[5];
	uint32_t vlan_subnet[5];
	uint32_t _vlan_subnet;
} BCM56800_A0_VLAN_SUBNETm_t;

#define BCM56800_A0_VLAN_SUBNETm_CLR(r) CDK_MEMSET(&((r)._vlan_subnet), 0, sizeof(BCM56800_A0_VLAN_SUBNETm_t))
#define BCM56800_A0_VLAN_SUBNETm_SET(r,i,d) (r).vlan_subnet[i] = d
#define BCM56800_A0_VLAN_SUBNETm_GET(r,i) (r).vlan_subnet[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNETm_VALIDf_GET(r) (((r).vlan_subnet[0]) & 0x1)
#define BCM56800_A0_VLAN_SUBNETm_VALIDf_SET(r,f) (r).vlan_subnet[0]=(((r).vlan_subnet[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_SUBNETm_IP_ADDRf_GET(r,a) cdk_field_get((r).vlan_subnet,1,64,a)
#define BCM56800_A0_VLAN_SUBNETm_IP_ADDRf_SET(r,a) cdk_field_set((r).vlan_subnet,1,64,a)
#define BCM56800_A0_VLAN_SUBNETm_MASKf_GET(r,a) cdk_field_get((r).vlan_subnet,65,128,a)
#define BCM56800_A0_VLAN_SUBNETm_MASKf_SET(r,a) cdk_field_set((r).vlan_subnet,65,128,a)
#define BCM56800_A0_VLAN_SUBNETm_PRIf_GET(r) ((((r).vlan_subnet[4]) >> 1) & 0x7)
#define BCM56800_A0_VLAN_SUBNETm_PRIf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56800_A0_VLAN_SUBNETm_VLAN_IDf_GET(r) ((((r).vlan_subnet[4]) >> 4) & 0xfff)
#define BCM56800_A0_VLAN_SUBNETm_VLAN_IDf_SET(r,f) (r).vlan_subnet[4]=(((r).vlan_subnet[4] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access VLAN_SUBNET.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNETm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_SUBNETm,i,(m._vlan_subnet),5)
#define BCM56800_A0_WRITE_VLAN_SUBNETm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_SUBNETm,i,&(m._vlan_subnet),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNETm BCM56800_A0_VLAN_SUBNETm
#define VLAN_SUBNETm_MIN BCM56800_A0_VLAN_SUBNETm_MIN
#define VLAN_SUBNETm_MAX BCM56800_A0_VLAN_SUBNETm_MAX
#define VLAN_SUBNETm_CMAX(u) BCM56800_A0_VLAN_SUBNETm_CMAX(u)
#define VLAN_SUBNETm_SIZE BCM56800_A0_VLAN_SUBNETm_SIZE
typedef BCM56800_A0_VLAN_SUBNETm_t VLAN_SUBNETm_t;
#define VLAN_SUBNETm_CLR BCM56800_A0_VLAN_SUBNETm_CLR
#define VLAN_SUBNETm_SET BCM56800_A0_VLAN_SUBNETm_SET
#define VLAN_SUBNETm_GET BCM56800_A0_VLAN_SUBNETm_GET
#define VLAN_SUBNETm_VALIDf_GET BCM56800_A0_VLAN_SUBNETm_VALIDf_GET
#define VLAN_SUBNETm_VALIDf_SET BCM56800_A0_VLAN_SUBNETm_VALIDf_SET
#define VLAN_SUBNETm_IP_ADDRf_GET BCM56800_A0_VLAN_SUBNETm_IP_ADDRf_GET
#define VLAN_SUBNETm_IP_ADDRf_SET BCM56800_A0_VLAN_SUBNETm_IP_ADDRf_SET
#define VLAN_SUBNETm_MASKf_GET BCM56800_A0_VLAN_SUBNETm_MASKf_GET
#define VLAN_SUBNETm_MASKf_SET BCM56800_A0_VLAN_SUBNETm_MASKf_SET
#define VLAN_SUBNETm_PRIf_GET BCM56800_A0_VLAN_SUBNETm_PRIf_GET
#define VLAN_SUBNETm_PRIf_SET BCM56800_A0_VLAN_SUBNETm_PRIf_SET
#define VLAN_SUBNETm_VLAN_IDf_GET BCM56800_A0_VLAN_SUBNETm_VLAN_IDf_GET
#define VLAN_SUBNETm_VLAN_IDf_SET BCM56800_A0_VLAN_SUBNETm_VLAN_IDf_SET
#define READ_VLAN_SUBNETm BCM56800_A0_READ_VLAN_SUBNETm
#define WRITE_VLAN_SUBNETm BCM56800_A0_WRITE_VLAN_SUBNETm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNETm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S10_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S10_STATUS       S10_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr 0x04180c07

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s10_status[1];
	uint32_t _vlan_subnet_cam_bist_s10_status;
} BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_t;

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s10_status[0] = 0
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s10_status[0] = d
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s10_status[0]) & 0xff)
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s10_status[0]=(((r).vlan_subnet_cam_bist_s10_status[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr,(r._vlan_subnet_cam_bist_s10_status))
#define BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr,&(r._vlan_subnet_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_t VLAN_SUBNET_CAM_BIST_S10_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr_S10_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S10_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S2_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S2_STATUS        VLAN_SUBNET_CAM_BIST_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr 0x04180c02

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s2_status[1];
	uint32_t _vlan_subnet_cam_bist_s2_status;
} BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_t;

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s2_status[0] = 0
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s2_status[0] = d
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s2_status[0]) & 0x7fff)
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s2_status[0]=(((r).vlan_subnet_cam_bist_s2_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr,(r._vlan_subnet_cam_bist_s2_status))
#define BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr,&(r._vlan_subnet_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_t VLAN_SUBNET_CAM_BIST_S2_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr_S2_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S2_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S3_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S3_STATUS        S3_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr 0x04180c03

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s3_status[1];
	uint32_t _vlan_subnet_cam_bist_s3_status;
} BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_t;

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s3_status[0] = 0
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s3_status[0] = d
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s3_status[0]) & 0xffff)
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s3_status[0]=(((r).vlan_subnet_cam_bist_s3_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr,(r._vlan_subnet_cam_bist_s3_status))
#define BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr,&(r._vlan_subnet_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_t VLAN_SUBNET_CAM_BIST_S3_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr_S3_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S3_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S5_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S5_STATUS        S5_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr 0x04180c04

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s5_status[1];
	uint32_t _vlan_subnet_cam_bist_s5_status;
} BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_t;

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s5_status[0] = 0
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s5_status[0] = d
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s5_status[0]) & 0x7fff)
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s5_status[0]=(((r).vlan_subnet_cam_bist_s5_status[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr,(r._vlan_subnet_cam_bist_s5_status))
#define BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr,&(r._vlan_subnet_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_t VLAN_SUBNET_CAM_BIST_S5_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr_S5_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S5_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S6_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S6_STATUS        S6_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr 0x04180c05

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s6_status[1];
	uint32_t _vlan_subnet_cam_bist_s6_status;
} BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_t;

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s6_status[0] = 0
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s6_status[0] = d
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s6_status[0]) & 0xffff)
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s6_status[0]=(((r).vlan_subnet_cam_bist_s6_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr,(r._vlan_subnet_cam_bist_s6_status))
#define BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr,&(r._vlan_subnet_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_t VLAN_SUBNET_CAM_BIST_S6_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr_S6_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S6_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_S8_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S8_STATUS        S8_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr 0x04180c06

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_s8_status[1];
	uint32_t _vlan_subnet_cam_bist_s8_status;
} BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_t;

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_s8_status[0] = 0
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_s8_status[0] = d
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET(r) (r).vlan_subnet_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_GET(r) (((r).vlan_subnet_cam_bist_s8_status[0]) & 0xffff)
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_SET(r,f) (r).vlan_subnet_cam_bist_s8_status[0]=(((r).vlan_subnet_cam_bist_s8_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr,(r._vlan_subnet_cam_bist_s8_status))
#define BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr,&(r._vlan_subnet_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_t VLAN_SUBNET_CAM_BIST_S8_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_GET
#define VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr_S8_STATUSf_SET
#define READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_S8_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_BIST_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr 0x04180c01

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_BIST_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_bist_status[1];
	uint32_t _vlan_subnet_cam_bist_status;
} BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_t;

#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_CLR(r) (r).vlan_subnet_cam_bist_status[0] = 0
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SET(r,d) (r).vlan_subnet_cam_bist_status[0] = d
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_GET(r) (r).vlan_subnet_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).vlan_subnet_cam_bist_status[0]) & 0x1)
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).vlan_subnet_cam_bist_status[0]=(((r).vlan_subnet_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).vlan_subnet_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).vlan_subnet_cam_bist_status[0]=(((r).vlan_subnet_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_BIST_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr,(r._vlan_subnet_cam_bist_status))
#define BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr,&(r._vlan_subnet_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_BIST_STATUSr BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr
#define VLAN_SUBNET_CAM_BIST_STATUSr_SIZE BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_t VLAN_SUBNET_CAM_BIST_STATUSr_t;
#define VLAN_SUBNET_CAM_BIST_STATUSr_CLR BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_CLR
#define VLAN_SUBNET_CAM_BIST_STATUSr_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_SET
#define VLAN_SUBNET_CAM_BIST_STATUSr_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_GOf_SET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_GET
#define VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_VLAN_SUBNET_CAM_BIST_STATUSr BCM56800_A0_READ_VLAN_SUBNET_CAM_BIST_STATUSr
#define WRITE_VLAN_SUBNET_CAM_BIST_STATUSr BCM56800_A0_WRITE_VLAN_SUBNET_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_CAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_CAM_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_EN0         BIST enable for CAM0
 *     BIST_EN1         BIST enable for CAM1
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr 0x04180c00

#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_CAM_DBGCTRL.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_cam_dbgctrl[1];
	uint32_t _vlan_subnet_cam_dbgctrl;
} BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_t;

#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_CLR(r) (r).vlan_subnet_cam_dbgctrl[0] = 0
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_SET(r,d) (r).vlan_subnet_cam_dbgctrl[0] = d
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_GET(r) (r).vlan_subnet_cam_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN0f_GET(r) (((r).vlan_subnet_cam_dbgctrl[0]) & 0x1)
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN0f_SET(r,f) (r).vlan_subnet_cam_dbgctrl[0]=(((r).vlan_subnet_cam_dbgctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN1f_GET(r) ((((r).vlan_subnet_cam_dbgctrl[0]) >> 1) & 0x1)
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN1f_SET(r,f) (r).vlan_subnet_cam_dbgctrl[0]=(((r).vlan_subnet_cam_dbgctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_TMf_GET(r) ((((r).vlan_subnet_cam_dbgctrl[0]) >> 2) & 0x7ff)
#define BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_TMf_SET(r,f) (r).vlan_subnet_cam_dbgctrl[0]=(((r).vlan_subnet_cam_dbgctrl[0] & ~((uint32_t)0x7ff << 2)) | ((((uint32_t)f) & 0x7ff) << 2))

/*
 * These macros can be used to access VLAN_SUBNET_CAM_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_CAM_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr,(r._vlan_subnet_cam_dbgctrl))
#define BCM56800_A0_WRITE_VLAN_SUBNET_CAM_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr,&(r._vlan_subnet_cam_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_CAM_DBGCTRLr BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr
#define VLAN_SUBNET_CAM_DBGCTRLr_SIZE BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_t VLAN_SUBNET_CAM_DBGCTRLr_t;
#define VLAN_SUBNET_CAM_DBGCTRLr_CLR BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_CLR
#define VLAN_SUBNET_CAM_DBGCTRLr_SET BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_SET
#define VLAN_SUBNET_CAM_DBGCTRLr_GET BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_GET
#define VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN0f_GET BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN0f_GET
#define VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN0f_SET BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN0f_SET
#define VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN1f_GET BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN1f_GET
#define VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN1f_SET BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_BIST_EN1f_SET
#define VLAN_SUBNET_CAM_DBGCTRLr_TMf_GET BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_TMf_GET
#define VLAN_SUBNET_CAM_DBGCTRLr_TMf_SET BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr_TMf_SET
#define READ_VLAN_SUBNET_CAM_DBGCTRLr BCM56800_A0_READ_VLAN_SUBNET_CAM_DBGCTRLr
#define WRITE_VLAN_SUBNET_CAM_DBGCTRLr BCM56800_A0_WRITE_VLAN_SUBNET_CAM_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_CAM_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_SUBNET_DATA_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_SUBNET_DATA_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr 0x04180c10

#define BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_SUBNET_DATA_DBGCTRL.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t vlan_subnet_data_dbgctrl[1];
	uint32_t _vlan_subnet_data_dbgctrl;
} BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_t;

#define BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_CLR(r) (r).vlan_subnet_data_dbgctrl[0] = 0
#define BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_SET(r,d) (r).vlan_subnet_data_dbgctrl[0] = d
#define BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_GET(r) (r).vlan_subnet_data_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_TMf_GET(r) (((r).vlan_subnet_data_dbgctrl[0]) & 0xf)
#define BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_TMf_SET(r,f) (r).vlan_subnet_data_dbgctrl[0]=(((r).vlan_subnet_data_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access VLAN_SUBNET_DATA_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr,(r._vlan_subnet_data_dbgctrl))
#define BCM56800_A0_WRITE_VLAN_SUBNET_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr,&(r._vlan_subnet_data_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_DATA_DBGCTRLr BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr
#define VLAN_SUBNET_DATA_DBGCTRLr_SIZE BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_SIZE
typedef BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_t VLAN_SUBNET_DATA_DBGCTRLr_t;
#define VLAN_SUBNET_DATA_DBGCTRLr_CLR BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_CLR
#define VLAN_SUBNET_DATA_DBGCTRLr_SET BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_SET
#define VLAN_SUBNET_DATA_DBGCTRLr_GET BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_GET
#define VLAN_SUBNET_DATA_DBGCTRLr_TMf_GET BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_TMf_GET
#define VLAN_SUBNET_DATA_DBGCTRLr_TMf_SET BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr_TMf_SET
#define READ_VLAN_SUBNET_DATA_DBGCTRLr BCM56800_A0_READ_VLAN_SUBNET_DATA_DBGCTRLr
#define WRITE_VLAN_SUBNET_DATA_DBGCTRLr BCM56800_A0_WRITE_VLAN_SUBNET_DATA_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_DATA_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_SUBNET_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     Holds data for IP Subnet-based VLAN substitution, FeatureSpecific-Ethernet
 * SIZE:     15
 * FIELDS:
 *     PRI              Priority field
 *     VLAN_ID          VLAN ID
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm 0x04164000

#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_MIN 0
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_MAX 255
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_CMAX(u) 255
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_SIZE 2

/*
 * This structure should be used to declare and program VLAN_SUBNET_DATA_ONLY.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t vlan_subnet_data_only[1];
	uint32_t _vlan_subnet_data_only;
} BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_t;

#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_CLR(r) (r).vlan_subnet_data_only[0] = 0
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_SET(r,d) (r).vlan_subnet_data_only[0] = d
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_GET(r) (r).vlan_subnet_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_GET(r) (((r).vlan_subnet_data_only[0]) & 0x7)
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_SET(r,f) (r).vlan_subnet_data_only[0]=(((r).vlan_subnet_data_only[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET(r) ((((r).vlan_subnet_data_only[0]) >> 3) & 0xfff)
#define BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET(r,f) (r).vlan_subnet_data_only[0]=(((r).vlan_subnet_data_only[0] & ~((uint32_t)0xfff << 3)) | ((((uint32_t)f) & 0xfff) << 3))

/*
 * These macros can be used to access VLAN_SUBNET_DATA_ONLY.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_SUBNET_DATA_ONLYm,i,(m._vlan_subnet_data_only),1)
#define BCM56800_A0_WRITE_VLAN_SUBNET_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_SUBNET_DATA_ONLYm,i,&(m._vlan_subnet_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_DATA_ONLYm BCM56800_A0_VLAN_SUBNET_DATA_ONLYm
#define VLAN_SUBNET_DATA_ONLYm_MIN BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_MIN
#define VLAN_SUBNET_DATA_ONLYm_MAX BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_MAX
#define VLAN_SUBNET_DATA_ONLYm_CMAX(u) BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_CMAX(u)
#define VLAN_SUBNET_DATA_ONLYm_SIZE BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_SIZE
typedef BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_t VLAN_SUBNET_DATA_ONLYm_t;
#define VLAN_SUBNET_DATA_ONLYm_CLR BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_CLR
#define VLAN_SUBNET_DATA_ONLYm_SET BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_SET
#define VLAN_SUBNET_DATA_ONLYm_GET BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_GET
#define VLAN_SUBNET_DATA_ONLYm_PRIf_GET BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_GET
#define VLAN_SUBNET_DATA_ONLYm_PRIf_SET BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_PRIf_SET
#define VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_GET
#define VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET BCM56800_A0_VLAN_SUBNET_DATA_ONLYm_VLAN_IDf_SET
#define READ_VLAN_SUBNET_DATA_ONLYm BCM56800_A0_READ_VLAN_SUBNET_DATA_ONLYm
#define WRITE_VLAN_SUBNET_DATA_ONLYm BCM56800_A0_WRITE_VLAN_SUBNET_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_SUBNET_ONLY
 * BLOCKS:   IPIPE
 * DESC:     TCAM for IP subnet based VLAN substitution, FeatureSpecific-Ethernet
 * SIZE:     129
 * FIELDS:
 *     VALID            IP Subnet mask
 *     IP_ADDR          IP Address key
 *     MASK             IP Subnet mask
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_SUBNET_ONLYm 0x04163000

#define BCM56800_A0_VLAN_SUBNET_ONLYm_MIN 0
#define BCM56800_A0_VLAN_SUBNET_ONLYm_MAX 255
#define BCM56800_A0_VLAN_SUBNET_ONLYm_CMAX(u) 255
#define BCM56800_A0_VLAN_SUBNET_ONLYm_SIZE 17

/*
 * This structure should be used to declare and program VLAN_SUBNET_ONLY.
 *
 */
typedef union BCM56800_A0_VLAN_SUBNET_ONLYm_s {
	uint32_t v[5];
	uint32_t vlan_subnet_only[5];
	uint32_t _vlan_subnet_only;
} BCM56800_A0_VLAN_SUBNET_ONLYm_t;

#define BCM56800_A0_VLAN_SUBNET_ONLYm_CLR(r) CDK_MEMSET(&((r)._vlan_subnet_only), 0, sizeof(BCM56800_A0_VLAN_SUBNET_ONLYm_t))
#define BCM56800_A0_VLAN_SUBNET_ONLYm_SET(r,i,d) (r).vlan_subnet_only[i] = d
#define BCM56800_A0_VLAN_SUBNET_ONLYm_GET(r,i) (r).vlan_subnet_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_SUBNET_ONLYm_VALIDf_GET(r) (((r).vlan_subnet_only[0]) & 0x1)
#define BCM56800_A0_VLAN_SUBNET_ONLYm_VALIDf_SET(r,f) (r).vlan_subnet_only[0]=(((r).vlan_subnet_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_GET(r,a) cdk_field_get((r).vlan_subnet_only,1,64,a)
#define BCM56800_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_SET(r,a) cdk_field_set((r).vlan_subnet_only,1,64,a)
#define BCM56800_A0_VLAN_SUBNET_ONLYm_MASKf_GET(r,a) cdk_field_get((r).vlan_subnet_only,65,128,a)
#define BCM56800_A0_VLAN_SUBNET_ONLYm_MASKf_SET(r,a) cdk_field_set((r).vlan_subnet_only,65,128,a)

/*
 * These macros can be used to access VLAN_SUBNET_ONLY.
 *
 */
#define BCM56800_A0_READ_VLAN_SUBNET_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_SUBNET_ONLYm,i,(m._vlan_subnet_only),5)
#define BCM56800_A0_WRITE_VLAN_SUBNET_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_SUBNET_ONLYm,i,&(m._vlan_subnet_only),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_SUBNET_ONLYm BCM56800_A0_VLAN_SUBNET_ONLYm
#define VLAN_SUBNET_ONLYm_MIN BCM56800_A0_VLAN_SUBNET_ONLYm_MIN
#define VLAN_SUBNET_ONLYm_MAX BCM56800_A0_VLAN_SUBNET_ONLYm_MAX
#define VLAN_SUBNET_ONLYm_CMAX(u) BCM56800_A0_VLAN_SUBNET_ONLYm_CMAX(u)
#define VLAN_SUBNET_ONLYm_SIZE BCM56800_A0_VLAN_SUBNET_ONLYm_SIZE
typedef BCM56800_A0_VLAN_SUBNET_ONLYm_t VLAN_SUBNET_ONLYm_t;
#define VLAN_SUBNET_ONLYm_CLR BCM56800_A0_VLAN_SUBNET_ONLYm_CLR
#define VLAN_SUBNET_ONLYm_SET BCM56800_A0_VLAN_SUBNET_ONLYm_SET
#define VLAN_SUBNET_ONLYm_GET BCM56800_A0_VLAN_SUBNET_ONLYm_GET
#define VLAN_SUBNET_ONLYm_VALIDf_GET BCM56800_A0_VLAN_SUBNET_ONLYm_VALIDf_GET
#define VLAN_SUBNET_ONLYm_VALIDf_SET BCM56800_A0_VLAN_SUBNET_ONLYm_VALIDf_SET
#define VLAN_SUBNET_ONLYm_IP_ADDRf_GET BCM56800_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_GET
#define VLAN_SUBNET_ONLYm_IP_ADDRf_SET BCM56800_A0_VLAN_SUBNET_ONLYm_IP_ADDRf_SET
#define VLAN_SUBNET_ONLYm_MASKf_GET BCM56800_A0_VLAN_SUBNET_ONLYm_MASKf_GET
#define VLAN_SUBNET_ONLYm_MASKf_SET BCM56800_A0_VLAN_SUBNET_ONLYm_MASKf_SET
#define READ_VLAN_SUBNET_ONLYm BCM56800_A0_READ_VLAN_SUBNET_ONLYm
#define WRITE_VLAN_SUBNET_ONLYm BCM56800_A0_WRITE_VLAN_SUBNET_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_SUBNET_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_TAB
 * BLOCKS:   IPIPE
 * DESC:     Contains cntrls assoc with the 4K VLANs.
 * SIZE:     53
 * FIELDS:
 *     PORT_BITMAP      VLAN port membership bitmap
 *     HIGIG_TRUNK_OVERRIDE Add the VLAN ID
 *     VALID            Valid VLAN ID
 *     STG              Spanning Tree Group ID
 *     PFM              Port Filtering Mode
 *     FID_ID           Forwarding database ID
 *     EVEN_PARITY      Even parity for the  VLAN RAM
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_TABm 0x05160000

#define BCM56800_A0_VLAN_TABm_MIN 0
#define BCM56800_A0_VLAN_TABm_MAX 4095
#define BCM56800_A0_VLAN_TABm_CMAX(u) 4095
#define BCM56800_A0_VLAN_TABm_SIZE 7

/*
 * This structure should be used to declare and program VLAN_TAB.
 *
 */
typedef union BCM56800_A0_VLAN_TABm_s {
	uint32_t v[2];
	uint32_t vlan_tab[2];
	uint32_t _vlan_tab;
} BCM56800_A0_VLAN_TABm_t;

#define BCM56800_A0_VLAN_TABm_CLR(r) CDK_MEMSET(&((r)._vlan_tab), 0, sizeof(BCM56800_A0_VLAN_TABm_t))
#define BCM56800_A0_VLAN_TABm_SET(r,i,d) (r).vlan_tab[i] = d
#define BCM56800_A0_VLAN_TABm_GET(r,i) (r).vlan_tab[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_TABm_PORT_BITMAPf_GET(r) (((r).vlan_tab[0]) & 0x1fffff)
#define BCM56800_A0_VLAN_TABm_PORT_BITMAPf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x1fffff)) | (((uint32_t)f) & 0x1fffff))
#define BCM56800_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET(r) ((((r).vlan_tab[0]) >> 21) & 0xff)
#define BCM56800_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0xff << 21)) | ((((uint32_t)f) & 0xff) << 21))
#define BCM56800_A0_VLAN_TABm_VALIDf_GET(r) ((((r).vlan_tab[0]) >> 29) & 0x1)
#define BCM56800_A0_VLAN_TABm_VALIDf_SET(r,f) (r).vlan_tab[0]=(((r).vlan_tab[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM56800_A0_VLAN_TABm_STGf_GET(r) cdk_field32_get((r).vlan_tab,30,37)
#define BCM56800_A0_VLAN_TABm_STGf_SET(r,f) cdk_field32_set((r).vlan_tab,30,37,f)
#define BCM56800_A0_VLAN_TABm_PFMf_GET(r) ((((r).vlan_tab[1]) >> 6) & 0x3)
#define BCM56800_A0_VLAN_TABm_PFMf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM56800_A0_VLAN_TABm_FID_IDf_GET(r) ((((r).vlan_tab[1]) >> 8) & 0xfff)
#define BCM56800_A0_VLAN_TABm_FID_IDf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0xfff << 8)) | ((((uint32_t)f) & 0xfff) << 8))
#define BCM56800_A0_VLAN_TABm_EVEN_PARITYf_GET(r) ((((r).vlan_tab[1]) >> 20) & 0x1)
#define BCM56800_A0_VLAN_TABm_EVEN_PARITYf_SET(r,f) (r).vlan_tab[1]=(((r).vlan_tab[1] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))

/*
 * These macros can be used to access VLAN_TAB.
 *
 */
#define BCM56800_A0_READ_VLAN_TABm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_TABm,i,(m._vlan_tab),2)
#define BCM56800_A0_WRITE_VLAN_TABm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_TABm,i,&(m._vlan_tab),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_TABm BCM56800_A0_VLAN_TABm
#define VLAN_TABm_MIN BCM56800_A0_VLAN_TABm_MIN
#define VLAN_TABm_MAX BCM56800_A0_VLAN_TABm_MAX
#define VLAN_TABm_CMAX(u) BCM56800_A0_VLAN_TABm_CMAX(u)
#define VLAN_TABm_SIZE BCM56800_A0_VLAN_TABm_SIZE
typedef BCM56800_A0_VLAN_TABm_t VLAN_TABm_t;
#define VLAN_TABm_CLR BCM56800_A0_VLAN_TABm_CLR
#define VLAN_TABm_SET BCM56800_A0_VLAN_TABm_SET
#define VLAN_TABm_GET BCM56800_A0_VLAN_TABm_GET
#define VLAN_TABm_PORT_BITMAPf_GET BCM56800_A0_VLAN_TABm_PORT_BITMAPf_GET
#define VLAN_TABm_PORT_BITMAPf_SET BCM56800_A0_VLAN_TABm_PORT_BITMAPf_SET
#define VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET BCM56800_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_GET
#define VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET BCM56800_A0_VLAN_TABm_HIGIG_TRUNK_OVERRIDEf_SET
#define VLAN_TABm_VALIDf_GET BCM56800_A0_VLAN_TABm_VALIDf_GET
#define VLAN_TABm_VALIDf_SET BCM56800_A0_VLAN_TABm_VALIDf_SET
#define VLAN_TABm_STGf_GET BCM56800_A0_VLAN_TABm_STGf_GET
#define VLAN_TABm_STGf_SET BCM56800_A0_VLAN_TABm_STGf_SET
#define VLAN_TABm_PFMf_GET BCM56800_A0_VLAN_TABm_PFMf_GET
#define VLAN_TABm_PFMf_SET BCM56800_A0_VLAN_TABm_PFMf_SET
#define VLAN_TABm_FID_IDf_GET BCM56800_A0_VLAN_TABm_FID_IDf_GET
#define VLAN_TABm_FID_IDf_SET BCM56800_A0_VLAN_TABm_FID_IDf_SET
#define VLAN_TABm_EVEN_PARITYf_GET BCM56800_A0_VLAN_TABm_EVEN_PARITYf_GET
#define VLAN_TABm_EVEN_PARITYf_SET BCM56800_A0_VLAN_TABm_EVEN_PARITYf_SET
#define READ_VLAN_TABm BCM56800_A0_READ_VLAN_TABm
#define WRITE_VLAN_TABm BCM56800_A0_WRITE_VLAN_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_XLATE
 * BLOCKS:   IPIPE
 * DESC:     View of CAM and RAM, with the mask bits hardwired to 1s for rds and wrs. FeatureSpecific-Ethernet
 * SIZE:     35
 * FIELDS:
 *     VALID            Indicates that the entry is valid.
 *     INGRESS_PORT     Source port part of the key
 *     VLAN_ID          VLAN ID part of the key
 *     RPE              RPE bit
 *     PRI              Priority to be assigned
 *     NEW_VLAN_ID      VLAN ID to be assigned
 *     ADD_VID          Add the VLAN ID
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATEm 0x04166000

#define BCM56800_A0_VLAN_XLATEm_MIN 0
#define BCM56800_A0_VLAN_XLATEm_MAX 767
#define BCM56800_A0_VLAN_XLATEm_CMAX(u) 767
#define BCM56800_A0_VLAN_XLATEm_SIZE 5

/*
 * This structure should be used to declare and program VLAN_XLATE.
 *
 */
typedef union BCM56800_A0_VLAN_XLATEm_s {
	uint32_t v[2];
	uint32_t vlan_xlate[2];
	uint32_t _vlan_xlate;
} BCM56800_A0_VLAN_XLATEm_t;

#define BCM56800_A0_VLAN_XLATEm_CLR(r) CDK_MEMSET(&((r)._vlan_xlate), 0, sizeof(BCM56800_A0_VLAN_XLATEm_t))
#define BCM56800_A0_VLAN_XLATEm_SET(r,i,d) (r).vlan_xlate[i] = d
#define BCM56800_A0_VLAN_XLATEm_GET(r,i) (r).vlan_xlate[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATEm_VALIDf_GET(r) (((r).vlan_xlate[0]) & 0x1)
#define BCM56800_A0_VLAN_XLATEm_VALIDf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_XLATEm_INGRESS_PORTf_GET(r) ((((r).vlan_xlate[0]) >> 1) & 0x1f)
#define BCM56800_A0_VLAN_XLATEm_INGRESS_PORTf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56800_A0_VLAN_XLATEm_VLAN_IDf_GET(r) ((((r).vlan_xlate[0]) >> 6) & 0xfff)
#define BCM56800_A0_VLAN_XLATEm_VLAN_IDf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM56800_A0_VLAN_XLATEm_RPEf_GET(r) ((((r).vlan_xlate[0]) >> 18) & 0x1)
#define BCM56800_A0_VLAN_XLATEm_RPEf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM56800_A0_VLAN_XLATEm_PRIf_GET(r) ((((r).vlan_xlate[0]) >> 19) & 0x7)
#define BCM56800_A0_VLAN_XLATEm_PRIf_SET(r,f) (r).vlan_xlate[0]=(((r).vlan_xlate[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM56800_A0_VLAN_XLATEm_NEW_VLAN_IDf_GET(r) cdk_field32_get((r).vlan_xlate,22,33)
#define BCM56800_A0_VLAN_XLATEm_NEW_VLAN_IDf_SET(r,f) cdk_field32_set((r).vlan_xlate,22,33,f)
#define BCM56800_A0_VLAN_XLATEm_ADD_VIDf_GET(r) ((((r).vlan_xlate[1]) >> 2) & 0x1)
#define BCM56800_A0_VLAN_XLATEm_ADD_VIDf_SET(r,f) (r).vlan_xlate[1]=(((r).vlan_xlate[1] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))

/*
 * These macros can be used to access VLAN_XLATE.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATEm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_XLATEm,i,(m._vlan_xlate),2)
#define BCM56800_A0_WRITE_VLAN_XLATEm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_XLATEm,i,&(m._vlan_xlate),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATEm BCM56800_A0_VLAN_XLATEm
#define VLAN_XLATEm_MIN BCM56800_A0_VLAN_XLATEm_MIN
#define VLAN_XLATEm_MAX BCM56800_A0_VLAN_XLATEm_MAX
#define VLAN_XLATEm_CMAX(u) BCM56800_A0_VLAN_XLATEm_CMAX(u)
#define VLAN_XLATEm_SIZE BCM56800_A0_VLAN_XLATEm_SIZE
typedef BCM56800_A0_VLAN_XLATEm_t VLAN_XLATEm_t;
#define VLAN_XLATEm_CLR BCM56800_A0_VLAN_XLATEm_CLR
#define VLAN_XLATEm_SET BCM56800_A0_VLAN_XLATEm_SET
#define VLAN_XLATEm_GET BCM56800_A0_VLAN_XLATEm_GET
#define VLAN_XLATEm_VALIDf_GET BCM56800_A0_VLAN_XLATEm_VALIDf_GET
#define VLAN_XLATEm_VALIDf_SET BCM56800_A0_VLAN_XLATEm_VALIDf_SET
#define VLAN_XLATEm_INGRESS_PORTf_GET BCM56800_A0_VLAN_XLATEm_INGRESS_PORTf_GET
#define VLAN_XLATEm_INGRESS_PORTf_SET BCM56800_A0_VLAN_XLATEm_INGRESS_PORTf_SET
#define VLAN_XLATEm_VLAN_IDf_GET BCM56800_A0_VLAN_XLATEm_VLAN_IDf_GET
#define VLAN_XLATEm_VLAN_IDf_SET BCM56800_A0_VLAN_XLATEm_VLAN_IDf_SET
#define VLAN_XLATEm_RPEf_GET BCM56800_A0_VLAN_XLATEm_RPEf_GET
#define VLAN_XLATEm_RPEf_SET BCM56800_A0_VLAN_XLATEm_RPEf_SET
#define VLAN_XLATEm_PRIf_GET BCM56800_A0_VLAN_XLATEm_PRIf_GET
#define VLAN_XLATEm_PRIf_SET BCM56800_A0_VLAN_XLATEm_PRIf_SET
#define VLAN_XLATEm_NEW_VLAN_IDf_GET BCM56800_A0_VLAN_XLATEm_NEW_VLAN_IDf_GET
#define VLAN_XLATEm_NEW_VLAN_IDf_SET BCM56800_A0_VLAN_XLATEm_NEW_VLAN_IDf_SET
#define VLAN_XLATEm_ADD_VIDf_GET BCM56800_A0_VLAN_XLATEm_ADD_VIDf_GET
#define VLAN_XLATEm_ADD_VIDf_SET BCM56800_A0_VLAN_XLATEm_ADD_VIDf_SET
#define READ_VLAN_XLATEm BCM56800_A0_READ_VLAN_XLATEm
#define WRITE_VLAN_XLATEm BCM56800_A0_WRITE_VLAN_XLATEm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATEm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S10_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S10_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S10_STATUS       S10_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr 0x04180c0f

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S10_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s10_status[1];
	uint32_t _vlan_xlate_cam_bist_s10_status;
} BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_t;

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s10_status[0] = 0
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s10_status[0] = d
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s10_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_S10_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s10_status[0]) & 0x7ff)
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_S10_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s10_status[0]=(((r).vlan_xlate_cam_bist_s10_status[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S10_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr,(r._vlan_xlate_cam_bist_s10_status))
#define BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S10_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr,&(r._vlan_xlate_cam_bist_s10_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S10_STATUSr BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr
#define VLAN_XLATE_CAM_BIST_S10_STATUSr_SIZE BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_SIZE
typedef BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_t VLAN_XLATE_CAM_BIST_S10_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S10_STATUSr_CLR BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S10_STATUSr_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S10_STATUSr_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S10_STATUSr_S10_STATUSf_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_S10_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S10_STATUSr_S10_STATUSf_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr_S10_STATUSf_SET
#define READ_VLAN_XLATE_CAM_BIST_S10_STATUSr BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S10_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S10_STATUSr BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S10_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_CAM_BIST_S10_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S2_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S2_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S2_STATUS        VLAN_XLATE_CAM_BIST_BIST_S2_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr 0x04180c0a

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S2_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s2_status[1];
	uint32_t _vlan_xlate_cam_bist_s2_status;
} BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_t;

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s2_status[0] = 0
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s2_status[0] = d
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s2_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_S2_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s2_status[0]) & 0xffff)
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_S2_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s2_status[0]=(((r).vlan_xlate_cam_bist_s2_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S2_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr,(r._vlan_xlate_cam_bist_s2_status))
#define BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S2_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr,&(r._vlan_xlate_cam_bist_s2_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S2_STATUSr BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_SIZE BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_SIZE
typedef BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_t VLAN_XLATE_CAM_BIST_S2_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_CLR BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_S2_STATUSf_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_S2_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S2_STATUSr_S2_STATUSf_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr_S2_STATUSf_SET
#define READ_VLAN_XLATE_CAM_BIST_S2_STATUSr BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S2_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S2_STATUSr BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S2_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_CAM_BIST_S2_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S3_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S3_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S3_STATUS        S3_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr 0x04180c0b

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S3_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s3_status[1];
	uint32_t _vlan_xlate_cam_bist_s3_status;
} BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_t;

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s3_status[0] = 0
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s3_status[0] = d
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s3_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_S3_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s3_status[0]) & 0x3fffff)
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_S3_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s3_status[0]=(((r).vlan_xlate_cam_bist_s3_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S3_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr,(r._vlan_xlate_cam_bist_s3_status))
#define BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S3_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr,&(r._vlan_xlate_cam_bist_s3_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S3_STATUSr BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_SIZE BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_SIZE
typedef BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_t VLAN_XLATE_CAM_BIST_S3_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_CLR BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_S3_STATUSf_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_S3_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S3_STATUSr_S3_STATUSf_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr_S3_STATUSf_SET
#define READ_VLAN_XLATE_CAM_BIST_S3_STATUSr BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S3_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S3_STATUSr BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S3_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_CAM_BIST_S3_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S5_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S5_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S5_STATUS        S5_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr 0x04180c0c

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S5_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s5_status[1];
	uint32_t _vlan_xlate_cam_bist_s5_status;
} BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_t;

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s5_status[0] = 0
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s5_status[0] = d
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s5_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_S5_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s5_status[0]) & 0xffff)
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_S5_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s5_status[0]=(((r).vlan_xlate_cam_bist_s5_status[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S5_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr,(r._vlan_xlate_cam_bist_s5_status))
#define BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S5_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr,&(r._vlan_xlate_cam_bist_s5_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S5_STATUSr BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_SIZE BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_SIZE
typedef BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_t VLAN_XLATE_CAM_BIST_S5_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_CLR BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_S5_STATUSf_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_S5_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S5_STATUSr_S5_STATUSf_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr_S5_STATUSf_SET
#define READ_VLAN_XLATE_CAM_BIST_S5_STATUSr BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S5_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S5_STATUSr BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S5_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_CAM_BIST_S5_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S6_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S6_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S6_STATUS        S6_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr 0x04180c0d

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S6_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s6_status[1];
	uint32_t _vlan_xlate_cam_bist_s6_status;
} BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_t;

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s6_status[0] = 0
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s6_status[0] = d
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s6_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_S6_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s6_status[0]) & 0x3fffff)
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_S6_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s6_status[0]=(((r).vlan_xlate_cam_bist_s6_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S6_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr,(r._vlan_xlate_cam_bist_s6_status))
#define BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S6_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr,&(r._vlan_xlate_cam_bist_s6_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S6_STATUSr BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_SIZE BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_SIZE
typedef BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_t VLAN_XLATE_CAM_BIST_S6_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_CLR BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_S6_STATUSf_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_S6_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S6_STATUSr_S6_STATUSf_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr_S6_STATUSf_SET
#define READ_VLAN_XLATE_CAM_BIST_S6_STATUSr BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S6_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S6_STATUSr BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S6_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_CAM_BIST_S6_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_S8_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_S8_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     S8_STATUS        S8_STATUS
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr 0x04180c0e

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_S8_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_s8_status[1];
	uint32_t _vlan_xlate_cam_bist_s8_status;
} BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_t;

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_s8_status[0] = 0
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_s8_status[0] = d
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_GET(r) (r).vlan_xlate_cam_bist_s8_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_S8_STATUSf_GET(r) (((r).vlan_xlate_cam_bist_s8_status[0]) & 0x3fffff)
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_S8_STATUSf_SET(r,f) (r).vlan_xlate_cam_bist_s8_status[0]=(((r).vlan_xlate_cam_bist_s8_status[0] & ~((uint32_t)0x3fffff)) | (((uint32_t)f) & 0x3fffff))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_S8_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr,(r._vlan_xlate_cam_bist_s8_status))
#define BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S8_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr,&(r._vlan_xlate_cam_bist_s8_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_S8_STATUSr BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_SIZE BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_SIZE
typedef BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_t VLAN_XLATE_CAM_BIST_S8_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_CLR BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_S8_STATUSf_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_S8_STATUSf_GET
#define VLAN_XLATE_CAM_BIST_S8_STATUSr_S8_STATUSf_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr_S8_STATUSf_SET
#define READ_VLAN_XLATE_CAM_BIST_S8_STATUSr BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_S8_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_S8_STATUSr BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_S8_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_CAM_BIST_S8_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_CAM_BIST_STATUS
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_BIST_STATUS, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_GO          BIST pass/fail flag (1->pass)
 *     BIST_DONE        Inicates if the BIST has completed
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr 0x04180c09

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_BIST_STATUS.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_bist_status[1];
	uint32_t _vlan_xlate_cam_bist_status;
} BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_t;

#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_CLR(r) (r).vlan_xlate_cam_bist_status[0] = 0
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_SET(r,d) (r).vlan_xlate_cam_bist_status[0] = d
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_GET(r) (r).vlan_xlate_cam_bist_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_GET(r) (((r).vlan_xlate_cam_bist_status[0]) & 0x1)
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_SET(r,f) (r).vlan_xlate_cam_bist_status[0]=(((r).vlan_xlate_cam_bist_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_GET(r) ((((r).vlan_xlate_cam_bist_status[0]) >> 1) & 0x1)
#define BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_SET(r,f) (r).vlan_xlate_cam_bist_status[0]=(((r).vlan_xlate_cam_bist_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access VLAN_XLATE_CAM_BIST_STATUS.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr,(r._vlan_xlate_cam_bist_status))
#define BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_STATUSr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr,&(r._vlan_xlate_cam_bist_status))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_BIST_STATUSr BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr
#define VLAN_XLATE_CAM_BIST_STATUSr_SIZE BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_SIZE
typedef BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_t VLAN_XLATE_CAM_BIST_STATUSr_t;
#define VLAN_XLATE_CAM_BIST_STATUSr_CLR BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_CLR
#define VLAN_XLATE_CAM_BIST_STATUSr_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_SET
#define VLAN_XLATE_CAM_BIST_STATUSr_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_GET
#define VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_GET
#define VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_GOf_SET
#define VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_GET BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_GET
#define VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_SET BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr_BIST_DONEf_SET
#define READ_VLAN_XLATE_CAM_BIST_STATUSr BCM56800_A0_READ_VLAN_XLATE_CAM_BIST_STATUSr
#define WRITE_VLAN_XLATE_CAM_BIST_STATUSr BCM56800_A0_WRITE_VLAN_XLATE_CAM_BIST_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_CAM_BIST_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_CAM_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_CAM_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     BIST_EN          BIST enable
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr 0x04180c08

#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_CAM_DBGCTRL.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_cam_dbgctrl[1];
	uint32_t _vlan_xlate_cam_dbgctrl;
} BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_t;

#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_CLR(r) (r).vlan_xlate_cam_dbgctrl[0] = 0
#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_SET(r,d) (r).vlan_xlate_cam_dbgctrl[0] = d
#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_GET(r) (r).vlan_xlate_cam_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_BIST_ENf_GET(r) (((r).vlan_xlate_cam_dbgctrl[0]) & 0x1)
#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_BIST_ENf_SET(r,f) (r).vlan_xlate_cam_dbgctrl[0]=(((r).vlan_xlate_cam_dbgctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_TMf_GET(r) ((((r).vlan_xlate_cam_dbgctrl[0]) >> 1) & 0x7ff)
#define BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_TMf_SET(r,f) (r).vlan_xlate_cam_dbgctrl[0]=(((r).vlan_xlate_cam_dbgctrl[0] & ~((uint32_t)0x7ff << 1)) | ((((uint32_t)f) & 0x7ff) << 1))

/*
 * These macros can be used to access VLAN_XLATE_CAM_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_CAM_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr,(r._vlan_xlate_cam_dbgctrl))
#define BCM56800_A0_WRITE_VLAN_XLATE_CAM_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr,&(r._vlan_xlate_cam_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_CAM_DBGCTRLr BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr
#define VLAN_XLATE_CAM_DBGCTRLr_SIZE BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_SIZE
typedef BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_t VLAN_XLATE_CAM_DBGCTRLr_t;
#define VLAN_XLATE_CAM_DBGCTRLr_CLR BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_CLR
#define VLAN_XLATE_CAM_DBGCTRLr_SET BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_SET
#define VLAN_XLATE_CAM_DBGCTRLr_GET BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_GET
#define VLAN_XLATE_CAM_DBGCTRLr_BIST_ENf_GET BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_BIST_ENf_GET
#define VLAN_XLATE_CAM_DBGCTRLr_BIST_ENf_SET BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_BIST_ENf_SET
#define VLAN_XLATE_CAM_DBGCTRLr_TMf_GET BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_TMf_GET
#define VLAN_XLATE_CAM_DBGCTRLr_TMf_SET BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr_TMf_SET
#define READ_VLAN_XLATE_CAM_DBGCTRLr BCM56800_A0_READ_VLAN_XLATE_CAM_DBGCTRLr
#define WRITE_VLAN_XLATE_CAM_DBGCTRLr BCM56800_A0_WRITE_VLAN_XLATE_CAM_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_CAM_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  VLAN_XLATE_DATA_DBGCTRL
 * BLOCKS:   IPIPE
 * DESC:     VLAN_XLATE_DATA_CONTROL, FeatureSpecific-Ethernet
 * SIZE:     32
 * FIELDS:
 *     TM               TM debug bits
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr 0x04180c13

#define BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_SIZE 4

/*
 * This structure should be used to declare and program VLAN_XLATE_DATA_DBGCTRL.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_s {
	uint32_t v[1];
	uint32_t vlan_xlate_data_dbgctrl[1];
	uint32_t _vlan_xlate_data_dbgctrl;
} BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_t;

#define BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_CLR(r) (r).vlan_xlate_data_dbgctrl[0] = 0
#define BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_SET(r,d) (r).vlan_xlate_data_dbgctrl[0] = d
#define BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_GET(r) (r).vlan_xlate_data_dbgctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_TMf_GET(r) (((r).vlan_xlate_data_dbgctrl[0]) & 0xf)
#define BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_TMf_SET(r,f) (r).vlan_xlate_data_dbgctrl[0]=(((r).vlan_xlate_data_dbgctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access VLAN_XLATE_DATA_DBGCTRL.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_read(u,BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr,(r._vlan_xlate_data_dbgctrl))
#define BCM56800_A0_WRITE_VLAN_XLATE_DATA_DBGCTRLr(u,r) cdk_xgs_reg32_write(u,BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr,&(r._vlan_xlate_data_dbgctrl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_DATA_DBGCTRLr BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr
#define VLAN_XLATE_DATA_DBGCTRLr_SIZE BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_SIZE
typedef BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_t VLAN_XLATE_DATA_DBGCTRLr_t;
#define VLAN_XLATE_DATA_DBGCTRLr_CLR BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_CLR
#define VLAN_XLATE_DATA_DBGCTRLr_SET BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_SET
#define VLAN_XLATE_DATA_DBGCTRLr_GET BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_GET
#define VLAN_XLATE_DATA_DBGCTRLr_TMf_GET BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_TMf_GET
#define VLAN_XLATE_DATA_DBGCTRLr_TMf_SET BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr_TMf_SET
#define READ_VLAN_XLATE_DATA_DBGCTRLr BCM56800_A0_READ_VLAN_XLATE_DATA_DBGCTRLr
#define WRITE_VLAN_XLATE_DATA_DBGCTRLr BCM56800_A0_WRITE_VLAN_XLATE_DATA_DBGCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_DATA_DBGCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_XLATE_DATA_ONLY
 * BLOCKS:   IPIPE
 * DESC:     View of just the Data SRAM for VLAN_XLATE table. FeatureSpecific-Ethernet
 * SIZE:     17
 * FIELDS:
 *     RPE              RPE bit
 *     PRI              Priority to be assigned
 *     NEW_VLAN_ID      VLAN ID to be assigned
 *     ADD_VID          Add the VLAN ID
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm 0x04169000

#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_MIN 0
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_MAX 767
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_CMAX(u) 767
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_XLATE_DATA_ONLY.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_DATA_ONLYm_s {
	uint32_t v[1];
	uint32_t vlan_xlate_data_only[1];
	uint32_t _vlan_xlate_data_only;
} BCM56800_A0_VLAN_XLATE_DATA_ONLYm_t;

#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_CLR(r) (r).vlan_xlate_data_only[0] = 0
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_SET(r,d) (r).vlan_xlate_data_only[0] = d
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_GET(r) (r).vlan_xlate_data_only[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_RPEf_GET(r) (((r).vlan_xlate_data_only[0]) & 0x1)
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_RPEf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_PRIf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 1) & 0x7)
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_PRIf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 4) & 0xfff)
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET(r) ((((r).vlan_xlate_data_only[0]) >> 16) & 0x1)
#define BCM56800_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET(r,f) (r).vlan_xlate_data_only[0]=(((r).vlan_xlate_data_only[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access VLAN_XLATE_DATA_ONLY.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_XLATE_DATA_ONLYm,i,(m._vlan_xlate_data_only),1)
#define BCM56800_A0_WRITE_VLAN_XLATE_DATA_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_XLATE_DATA_ONLYm,i,&(m._vlan_xlate_data_only),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_DATA_ONLYm BCM56800_A0_VLAN_XLATE_DATA_ONLYm
#define VLAN_XLATE_DATA_ONLYm_MIN BCM56800_A0_VLAN_XLATE_DATA_ONLYm_MIN
#define VLAN_XLATE_DATA_ONLYm_MAX BCM56800_A0_VLAN_XLATE_DATA_ONLYm_MAX
#define VLAN_XLATE_DATA_ONLYm_CMAX(u) BCM56800_A0_VLAN_XLATE_DATA_ONLYm_CMAX(u)
#define VLAN_XLATE_DATA_ONLYm_SIZE BCM56800_A0_VLAN_XLATE_DATA_ONLYm_SIZE
typedef BCM56800_A0_VLAN_XLATE_DATA_ONLYm_t VLAN_XLATE_DATA_ONLYm_t;
#define VLAN_XLATE_DATA_ONLYm_CLR BCM56800_A0_VLAN_XLATE_DATA_ONLYm_CLR
#define VLAN_XLATE_DATA_ONLYm_SET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_SET
#define VLAN_XLATE_DATA_ONLYm_GET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_GET
#define VLAN_XLATE_DATA_ONLYm_RPEf_GET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_RPEf_GET
#define VLAN_XLATE_DATA_ONLYm_RPEf_SET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_RPEf_SET
#define VLAN_XLATE_DATA_ONLYm_PRIf_GET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_PRIf_GET
#define VLAN_XLATE_DATA_ONLYm_PRIf_SET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_PRIf_SET
#define VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_GET
#define VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_NEW_VLAN_IDf_SET
#define VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_GET
#define VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET BCM56800_A0_VLAN_XLATE_DATA_ONLYm_ADD_VIDf_SET
#define READ_VLAN_XLATE_DATA_ONLYm BCM56800_A0_READ_VLAN_XLATE_DATA_ONLYm
#define WRITE_VLAN_XLATE_DATA_ONLYm BCM56800_A0_WRITE_VLAN_XLATE_DATA_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_DATA_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_XLATE_MASK
 * BLOCKS:   IPIPE
 * DESC:     View of CAM and RAM, with the mask bits visible and readable and writable. FeatureSpecific-Ethernet
 * SIZE:     52
 * FIELDS:
 *     VALID            Indicates that the entry is valid.
 *     INGRESS_PORT     Source port part of the key
 *     VLAN_ID          VLAN ID part of the key
 *     MASK             Mask for the {VLAN_ID, INGRESS_PORT}, should be set to all 1s
 *     RPE              RPE bit
 *     PRI              Priority to be assigned
 *     NEW_VLAN_ID      VLAN ID to be assigned
 *     ADD_VID          Add the VLAN ID
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_MASKm 0x04167000

#define BCM56800_A0_VLAN_XLATE_MASKm_MIN 0
#define BCM56800_A0_VLAN_XLATE_MASKm_MAX 767
#define BCM56800_A0_VLAN_XLATE_MASKm_CMAX(u) 767
#define BCM56800_A0_VLAN_XLATE_MASKm_SIZE 7

/*
 * This structure should be used to declare and program VLAN_XLATE_MASK.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_MASKm_s {
	uint32_t v[2];
	uint32_t vlan_xlate_mask[2];
	uint32_t _vlan_xlate_mask;
} BCM56800_A0_VLAN_XLATE_MASKm_t;

#define BCM56800_A0_VLAN_XLATE_MASKm_CLR(r) CDK_MEMSET(&((r)._vlan_xlate_mask), 0, sizeof(BCM56800_A0_VLAN_XLATE_MASKm_t))
#define BCM56800_A0_VLAN_XLATE_MASKm_SET(r,i,d) (r).vlan_xlate_mask[i] = d
#define BCM56800_A0_VLAN_XLATE_MASKm_GET(r,i) (r).vlan_xlate_mask[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_MASKm_VALIDf_GET(r) (((r).vlan_xlate_mask[0]) & 0x1)
#define BCM56800_A0_VLAN_XLATE_MASKm_VALIDf_SET(r,f) (r).vlan_xlate_mask[0]=(((r).vlan_xlate_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_XLATE_MASKm_INGRESS_PORTf_GET(r) ((((r).vlan_xlate_mask[0]) >> 1) & 0x1f)
#define BCM56800_A0_VLAN_XLATE_MASKm_INGRESS_PORTf_SET(r,f) (r).vlan_xlate_mask[0]=(((r).vlan_xlate_mask[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56800_A0_VLAN_XLATE_MASKm_VLAN_IDf_GET(r) ((((r).vlan_xlate_mask[0]) >> 6) & 0xfff)
#define BCM56800_A0_VLAN_XLATE_MASKm_VLAN_IDf_SET(r,f) (r).vlan_xlate_mask[0]=(((r).vlan_xlate_mask[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM56800_A0_VLAN_XLATE_MASKm_MASKf_GET(r) cdk_field32_get((r).vlan_xlate_mask,18,34)
#define BCM56800_A0_VLAN_XLATE_MASKm_MASKf_SET(r,f) cdk_field32_set((r).vlan_xlate_mask,18,34,f)
#define BCM56800_A0_VLAN_XLATE_MASKm_RPEf_GET(r) ((((r).vlan_xlate_mask[1]) >> 3) & 0x1)
#define BCM56800_A0_VLAN_XLATE_MASKm_RPEf_SET(r,f) (r).vlan_xlate_mask[1]=(((r).vlan_xlate_mask[1] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_VLAN_XLATE_MASKm_PRIf_GET(r) ((((r).vlan_xlate_mask[1]) >> 4) & 0x7)
#define BCM56800_A0_VLAN_XLATE_MASKm_PRIf_SET(r,f) (r).vlan_xlate_mask[1]=(((r).vlan_xlate_mask[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM56800_A0_VLAN_XLATE_MASKm_NEW_VLAN_IDf_GET(r) ((((r).vlan_xlate_mask[1]) >> 7) & 0xfff)
#define BCM56800_A0_VLAN_XLATE_MASKm_NEW_VLAN_IDf_SET(r,f) (r).vlan_xlate_mask[1]=(((r).vlan_xlate_mask[1] & ~((uint32_t)0xfff << 7)) | ((((uint32_t)f) & 0xfff) << 7))
#define BCM56800_A0_VLAN_XLATE_MASKm_ADD_VIDf_GET(r) ((((r).vlan_xlate_mask[1]) >> 19) & 0x1)
#define BCM56800_A0_VLAN_XLATE_MASKm_ADD_VIDf_SET(r,f) (r).vlan_xlate_mask[1]=(((r).vlan_xlate_mask[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))

/*
 * These macros can be used to access VLAN_XLATE_MASK.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_MASKm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_XLATE_MASKm,i,(m._vlan_xlate_mask),2)
#define BCM56800_A0_WRITE_VLAN_XLATE_MASKm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_XLATE_MASKm,i,&(m._vlan_xlate_mask),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_MASKm BCM56800_A0_VLAN_XLATE_MASKm
#define VLAN_XLATE_MASKm_MIN BCM56800_A0_VLAN_XLATE_MASKm_MIN
#define VLAN_XLATE_MASKm_MAX BCM56800_A0_VLAN_XLATE_MASKm_MAX
#define VLAN_XLATE_MASKm_CMAX(u) BCM56800_A0_VLAN_XLATE_MASKm_CMAX(u)
#define VLAN_XLATE_MASKm_SIZE BCM56800_A0_VLAN_XLATE_MASKm_SIZE
typedef BCM56800_A0_VLAN_XLATE_MASKm_t VLAN_XLATE_MASKm_t;
#define VLAN_XLATE_MASKm_CLR BCM56800_A0_VLAN_XLATE_MASKm_CLR
#define VLAN_XLATE_MASKm_SET BCM56800_A0_VLAN_XLATE_MASKm_SET
#define VLAN_XLATE_MASKm_GET BCM56800_A0_VLAN_XLATE_MASKm_GET
#define VLAN_XLATE_MASKm_VALIDf_GET BCM56800_A0_VLAN_XLATE_MASKm_VALIDf_GET
#define VLAN_XLATE_MASKm_VALIDf_SET BCM56800_A0_VLAN_XLATE_MASKm_VALIDf_SET
#define VLAN_XLATE_MASKm_INGRESS_PORTf_GET BCM56800_A0_VLAN_XLATE_MASKm_INGRESS_PORTf_GET
#define VLAN_XLATE_MASKm_INGRESS_PORTf_SET BCM56800_A0_VLAN_XLATE_MASKm_INGRESS_PORTf_SET
#define VLAN_XLATE_MASKm_VLAN_IDf_GET BCM56800_A0_VLAN_XLATE_MASKm_VLAN_IDf_GET
#define VLAN_XLATE_MASKm_VLAN_IDf_SET BCM56800_A0_VLAN_XLATE_MASKm_VLAN_IDf_SET
#define VLAN_XLATE_MASKm_MASKf_GET BCM56800_A0_VLAN_XLATE_MASKm_MASKf_GET
#define VLAN_XLATE_MASKm_MASKf_SET BCM56800_A0_VLAN_XLATE_MASKm_MASKf_SET
#define VLAN_XLATE_MASKm_RPEf_GET BCM56800_A0_VLAN_XLATE_MASKm_RPEf_GET
#define VLAN_XLATE_MASKm_RPEf_SET BCM56800_A0_VLAN_XLATE_MASKm_RPEf_SET
#define VLAN_XLATE_MASKm_PRIf_GET BCM56800_A0_VLAN_XLATE_MASKm_PRIf_GET
#define VLAN_XLATE_MASKm_PRIf_SET BCM56800_A0_VLAN_XLATE_MASKm_PRIf_SET
#define VLAN_XLATE_MASKm_NEW_VLAN_IDf_GET BCM56800_A0_VLAN_XLATE_MASKm_NEW_VLAN_IDf_GET
#define VLAN_XLATE_MASKm_NEW_VLAN_IDf_SET BCM56800_A0_VLAN_XLATE_MASKm_NEW_VLAN_IDf_SET
#define VLAN_XLATE_MASKm_ADD_VIDf_GET BCM56800_A0_VLAN_XLATE_MASKm_ADD_VIDf_GET
#define VLAN_XLATE_MASKm_ADD_VIDf_SET BCM56800_A0_VLAN_XLATE_MASKm_ADD_VIDf_SET
#define READ_VLAN_XLATE_MASKm BCM56800_A0_READ_VLAN_XLATE_MASKm
#define WRITE_VLAN_XLATE_MASKm BCM56800_A0_WRITE_VLAN_XLATE_MASKm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_MASKm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * MEMORY:  VLAN_XLATE_ONLY
 * BLOCKS:   IPIPE
 * DESC:     View of the CAM only with the mask bits visible and readable/writable. FeatureSpecific-Ethernet
 * SIZE:     35
 * FIELDS:
 *     VALID            Indicates that the entry is valid.
 *     INGRESS_PORT     Source port part of the key
 *     VLAN_ID          VLAN ID part of the key
 *     MASK             Mask for the {VLAN_ID, INGRESS_PORT}, should be set to all 1s
 *
 ******************************************************************************/
#define BCM56800_A0_VLAN_XLATE_ONLYm 0x04168000

#define BCM56800_A0_VLAN_XLATE_ONLYm_MIN 0
#define BCM56800_A0_VLAN_XLATE_ONLYm_MAX 767
#define BCM56800_A0_VLAN_XLATE_ONLYm_CMAX(u) 767
#define BCM56800_A0_VLAN_XLATE_ONLYm_SIZE 5

/*
 * This structure should be used to declare and program VLAN_XLATE_ONLY.
 *
 */
typedef union BCM56800_A0_VLAN_XLATE_ONLYm_s {
	uint32_t v[2];
	uint32_t vlan_xlate_only[2];
	uint32_t _vlan_xlate_only;
} BCM56800_A0_VLAN_XLATE_ONLYm_t;

#define BCM56800_A0_VLAN_XLATE_ONLYm_CLR(r) CDK_MEMSET(&((r)._vlan_xlate_only), 0, sizeof(BCM56800_A0_VLAN_XLATE_ONLYm_t))
#define BCM56800_A0_VLAN_XLATE_ONLYm_SET(r,i,d) (r).vlan_xlate_only[i] = d
#define BCM56800_A0_VLAN_XLATE_ONLYm_GET(r,i) (r).vlan_xlate_only[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_VLAN_XLATE_ONLYm_VALIDf_GET(r) (((r).vlan_xlate_only[0]) & 0x1)
#define BCM56800_A0_VLAN_XLATE_ONLYm_VALIDf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_GET(r) ((((r).vlan_xlate_only[0]) >> 1) & 0x1f)
#define BCM56800_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM56800_A0_VLAN_XLATE_ONLYm_VLAN_IDf_GET(r) ((((r).vlan_xlate_only[0]) >> 6) & 0xfff)
#define BCM56800_A0_VLAN_XLATE_ONLYm_VLAN_IDf_SET(r,f) (r).vlan_xlate_only[0]=(((r).vlan_xlate_only[0] & ~((uint32_t)0xfff << 6)) | ((((uint32_t)f) & 0xfff) << 6))
#define BCM56800_A0_VLAN_XLATE_ONLYm_MASKf_GET(r) cdk_field32_get((r).vlan_xlate_only,18,34)
#define BCM56800_A0_VLAN_XLATE_ONLYm_MASKf_SET(r,f) cdk_field32_set((r).vlan_xlate_only,18,34,f)

/*
 * These macros can be used to access VLAN_XLATE_ONLY.
 *
 */
#define BCM56800_A0_READ_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_read(u,BCM56800_A0_VLAN_XLATE_ONLYm,i,(m._vlan_xlate_only),2)
#define BCM56800_A0_WRITE_VLAN_XLATE_ONLYm(u,i,m) cdk_xgs_mem_write(u,BCM56800_A0_VLAN_XLATE_ONLYm,i,&(m._vlan_xlate_only),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_XLATE_ONLYm BCM56800_A0_VLAN_XLATE_ONLYm
#define VLAN_XLATE_ONLYm_MIN BCM56800_A0_VLAN_XLATE_ONLYm_MIN
#define VLAN_XLATE_ONLYm_MAX BCM56800_A0_VLAN_XLATE_ONLYm_MAX
#define VLAN_XLATE_ONLYm_CMAX(u) BCM56800_A0_VLAN_XLATE_ONLYm_CMAX(u)
#define VLAN_XLATE_ONLYm_SIZE BCM56800_A0_VLAN_XLATE_ONLYm_SIZE
typedef BCM56800_A0_VLAN_XLATE_ONLYm_t VLAN_XLATE_ONLYm_t;
#define VLAN_XLATE_ONLYm_CLR BCM56800_A0_VLAN_XLATE_ONLYm_CLR
#define VLAN_XLATE_ONLYm_SET BCM56800_A0_VLAN_XLATE_ONLYm_SET
#define VLAN_XLATE_ONLYm_GET BCM56800_A0_VLAN_XLATE_ONLYm_GET
#define VLAN_XLATE_ONLYm_VALIDf_GET BCM56800_A0_VLAN_XLATE_ONLYm_VALIDf_GET
#define VLAN_XLATE_ONLYm_VALIDf_SET BCM56800_A0_VLAN_XLATE_ONLYm_VALIDf_SET
#define VLAN_XLATE_ONLYm_INGRESS_PORTf_GET BCM56800_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_GET
#define VLAN_XLATE_ONLYm_INGRESS_PORTf_SET BCM56800_A0_VLAN_XLATE_ONLYm_INGRESS_PORTf_SET
#define VLAN_XLATE_ONLYm_VLAN_IDf_GET BCM56800_A0_VLAN_XLATE_ONLYm_VLAN_IDf_GET
#define VLAN_XLATE_ONLYm_VLAN_IDf_SET BCM56800_A0_VLAN_XLATE_ONLYm_VLAN_IDf_SET
#define VLAN_XLATE_ONLYm_MASKf_GET BCM56800_A0_VLAN_XLATE_ONLYm_MASKf_GET
#define VLAN_XLATE_ONLYm_MASKf_SET BCM56800_A0_VLAN_XLATE_ONLYm_MASKf_SET
#define READ_VLAN_XLATE_ONLYm BCM56800_A0_READ_VLAN_XLATE_ONLYm
#define WRITE_VLAN_XLATE_ONLYm BCM56800_A0_WRITE_VLAN_XLATE_ONLYm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_VLAN_XLATE_ONLYm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  WDRRCOUNT
 * BLOCKS:   MMU
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *     WDRR_CREDIT      WDRRCREDITWDRR credit counts all the 128-byte cells transmit out  for this queue
 *     WDRR_RESIDUE     WDRRRESIDUEWDRR residue counts all the residue bytes transmit out for this queue.
 *     WDRR_RESIDUE_SIGN WDRRRESIDUESIGNWDRR residue sign shows current residue is oversent or under seent.
 *
 ******************************************************************************/
#define BCM56800_A0_WDRRCOUNTr 0x06d00060

#define BCM56800_A0_WDRRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program WDRRCOUNT.
 *
 */
typedef union BCM56800_A0_WDRRCOUNTr_s {
	uint32_t v[1];
	uint32_t wdrrcount[1];
	uint32_t _wdrrcount;
} BCM56800_A0_WDRRCOUNTr_t;

#define BCM56800_A0_WDRRCOUNTr_CLR(r) (r).wdrrcount[0] = 0
#define BCM56800_A0_WDRRCOUNTr_SET(r,d) (r).wdrrcount[0] = d
#define BCM56800_A0_WDRRCOUNTr_GET(r) (r).wdrrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_WDRRCOUNTr_WDRR_CREDITf_GET(r) (((r).wdrrcount[0]) & 0x3fff)
#define BCM56800_A0_WDRRCOUNTr_WDRR_CREDITf_SET(r,f) (r).wdrrcount[0]=(((r).wdrrcount[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM56800_A0_WDRRCOUNTr_WDRR_RESIDUEf_GET(r) ((((r).wdrrcount[0]) >> 14) & 0x3ff)
#define BCM56800_A0_WDRRCOUNTr_WDRR_RESIDUEf_SET(r,f) (r).wdrrcount[0]=(((r).wdrrcount[0] & ~((uint32_t)0x3ff << 14)) | ((((uint32_t)f) & 0x3ff) << 14))
#define BCM56800_A0_WDRRCOUNTr_WDRR_RESIDUE_SIGNf_GET(r) ((((r).wdrrcount[0]) >> 24) & 0x1)
#define BCM56800_A0_WDRRCOUNTr_WDRR_RESIDUE_SIGNf_SET(r,f) (r).wdrrcount[0]=(((r).wdrrcount[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))

/*
 * These macros can be used to access WDRRCOUNT.
 *
 */
#define BCM56800_A0_READ_WDRRCOUNTr(u,p,i,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_WDRRCOUNTr+(i),(r._wdrrcount))
#define BCM56800_A0_WRITE_WDRRCOUNTr(u,p,i,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_WDRRCOUNTr+(i),&(r._wdrrcount))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WDRRCOUNTr BCM56800_A0_WDRRCOUNTr
#define WDRRCOUNTr_SIZE BCM56800_A0_WDRRCOUNTr_SIZE
typedef BCM56800_A0_WDRRCOUNTr_t WDRRCOUNTr_t;
#define WDRRCOUNTr_CLR BCM56800_A0_WDRRCOUNTr_CLR
#define WDRRCOUNTr_SET BCM56800_A0_WDRRCOUNTr_SET
#define WDRRCOUNTr_GET BCM56800_A0_WDRRCOUNTr_GET
#define WDRRCOUNTr_WDRR_CREDITf_GET BCM56800_A0_WDRRCOUNTr_WDRR_CREDITf_GET
#define WDRRCOUNTr_WDRR_CREDITf_SET BCM56800_A0_WDRRCOUNTr_WDRR_CREDITf_SET
#define WDRRCOUNTr_WDRR_RESIDUEf_GET BCM56800_A0_WDRRCOUNTr_WDRR_RESIDUEf_GET
#define WDRRCOUNTr_WDRR_RESIDUEf_SET BCM56800_A0_WDRRCOUNTr_WDRR_RESIDUEf_SET
#define WDRRCOUNTr_WDRR_RESIDUE_SIGNf_GET BCM56800_A0_WDRRCOUNTr_WDRR_RESIDUE_SIGNf_GET
#define WDRRCOUNTr_WDRR_RESIDUE_SIGNf_SET BCM56800_A0_WDRRCOUNTr_WDRR_RESIDUE_SIGNf_SET
#define READ_WDRRCOUNTr BCM56800_A0_READ_WDRRCOUNTr
#define WRITE_WDRRCOUNTr BCM56800_A0_WRITE_WDRRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_WDRRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XBOD_OVRFLW
 * BLOCKS:   GXPORT
 * DESC:     XBOD overflow status register
 * SIZE:     32
 * FIELDS:
 *     OVRFLW           XBOD FIFO overflow flag
 *
 ******************************************************************************/
#define BCM56800_A0_XBOD_OVRFLWr 0x00f00823

#define BCM56800_A0_XBOD_OVRFLWr_SIZE 4

/*
 * This structure should be used to declare and program XBOD_OVRFLW.
 *
 */
typedef union BCM56800_A0_XBOD_OVRFLWr_s {
	uint32_t v[1];
	uint32_t xbod_ovrflw[1];
	uint32_t _xbod_ovrflw;
} BCM56800_A0_XBOD_OVRFLWr_t;

#define BCM56800_A0_XBOD_OVRFLWr_CLR(r) (r).xbod_ovrflw[0] = 0
#define BCM56800_A0_XBOD_OVRFLWr_SET(r,d) (r).xbod_ovrflw[0] = d
#define BCM56800_A0_XBOD_OVRFLWr_GET(r) (r).xbod_ovrflw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XBOD_OVRFLWr_OVRFLWf_GET(r) (((r).xbod_ovrflw[0]) & 0x1)
#define BCM56800_A0_XBOD_OVRFLWr_OVRFLWf_SET(r,f) (r).xbod_ovrflw[0]=(((r).xbod_ovrflw[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XBOD_OVRFLW.
 *
 */
#define BCM56800_A0_READ_XBOD_OVRFLWr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XBOD_OVRFLWr,(r._xbod_ovrflw))
#define BCM56800_A0_WRITE_XBOD_OVRFLWr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XBOD_OVRFLWr,&(r._xbod_ovrflw))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XBOD_OVRFLWr BCM56800_A0_XBOD_OVRFLWr
#define XBOD_OVRFLWr_SIZE BCM56800_A0_XBOD_OVRFLWr_SIZE
typedef BCM56800_A0_XBOD_OVRFLWr_t XBOD_OVRFLWr_t;
#define XBOD_OVRFLWr_CLR BCM56800_A0_XBOD_OVRFLWr_CLR
#define XBOD_OVRFLWr_SET BCM56800_A0_XBOD_OVRFLWr_SET
#define XBOD_OVRFLWr_GET BCM56800_A0_XBOD_OVRFLWr_GET
#define XBOD_OVRFLWr_OVRFLWf_GET BCM56800_A0_XBOD_OVRFLWr_OVRFLWf_GET
#define XBOD_OVRFLWr_OVRFLWf_SET BCM56800_A0_XBOD_OVRFLWr_OVRFLWf_SET
#define READ_XBOD_OVRFLWr BCM56800_A0_READ_XBOD_OVRFLWr
#define WRITE_XBOD_OVRFLWr BCM56800_A0_WRITE_XBOD_OVRFLWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XBOD_OVRFLWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XHOL_D0
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E HOL Data 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_0_3   XPORT E2E HOL Data 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XHOL_D0r 0x00f00810

#define BCM56800_A0_XHOL_D0r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_D0.
 *
 */
typedef union BCM56800_A0_XHOL_D0r_s {
	uint32_t v[1];
	uint32_t xhol_d0[1];
	uint32_t _xhol_d0;
} BCM56800_A0_XHOL_D0r_t;

#define BCM56800_A0_XHOL_D0r_CLR(r) (r).xhol_d0[0] = 0
#define BCM56800_A0_XHOL_D0r_SET(r,d) (r).xhol_d0[0] = d
#define BCM56800_A0_XHOL_D0r_GET(r) (r).xhol_d0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XHOL_D0r_DATA_BYTES_0_3f_GET(r) ((r).xhol_d0[0])
#define BCM56800_A0_XHOL_D0r_DATA_BYTES_0_3f_SET(r,f) (r).xhol_d0[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_D0.
 *
 */
#define BCM56800_A0_READ_XHOL_D0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XHOL_D0r,(r._xhol_d0))
#define BCM56800_A0_WRITE_XHOL_D0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XHOL_D0r,&(r._xhol_d0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_D0r BCM56800_A0_XHOL_D0r
#define XHOL_D0r_SIZE BCM56800_A0_XHOL_D0r_SIZE
typedef BCM56800_A0_XHOL_D0r_t XHOL_D0r_t;
#define XHOL_D0r_CLR BCM56800_A0_XHOL_D0r_CLR
#define XHOL_D0r_SET BCM56800_A0_XHOL_D0r_SET
#define XHOL_D0r_GET BCM56800_A0_XHOL_D0r_GET
#define XHOL_D0r_DATA_BYTES_0_3f_GET BCM56800_A0_XHOL_D0r_DATA_BYTES_0_3f_GET
#define XHOL_D0r_DATA_BYTES_0_3f_SET BCM56800_A0_XHOL_D0r_DATA_BYTES_0_3f_SET
#define READ_XHOL_D0r BCM56800_A0_READ_XHOL_D0r
#define WRITE_XHOL_D0r BCM56800_A0_WRITE_XHOL_D0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XHOL_D0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XHOL_D1
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E HOL Data 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_4_7   XPORT E2E HOL Data 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XHOL_D1r 0x00f00811

#define BCM56800_A0_XHOL_D1r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_D1.
 *
 */
typedef union BCM56800_A0_XHOL_D1r_s {
	uint32_t v[1];
	uint32_t xhol_d1[1];
	uint32_t _xhol_d1;
} BCM56800_A0_XHOL_D1r_t;

#define BCM56800_A0_XHOL_D1r_CLR(r) (r).xhol_d1[0] = 0
#define BCM56800_A0_XHOL_D1r_SET(r,d) (r).xhol_d1[0] = d
#define BCM56800_A0_XHOL_D1r_GET(r) (r).xhol_d1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XHOL_D1r_DATA_BYTES_4_7f_GET(r) ((r).xhol_d1[0])
#define BCM56800_A0_XHOL_D1r_DATA_BYTES_4_7f_SET(r,f) (r).xhol_d1[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_D1.
 *
 */
#define BCM56800_A0_READ_XHOL_D1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XHOL_D1r,(r._xhol_d1))
#define BCM56800_A0_WRITE_XHOL_D1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XHOL_D1r,&(r._xhol_d1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_D1r BCM56800_A0_XHOL_D1r
#define XHOL_D1r_SIZE BCM56800_A0_XHOL_D1r_SIZE
typedef BCM56800_A0_XHOL_D1r_t XHOL_D1r_t;
#define XHOL_D1r_CLR BCM56800_A0_XHOL_D1r_CLR
#define XHOL_D1r_SET BCM56800_A0_XHOL_D1r_SET
#define XHOL_D1r_GET BCM56800_A0_XHOL_D1r_GET
#define XHOL_D1r_DATA_BYTES_4_7f_GET BCM56800_A0_XHOL_D1r_DATA_BYTES_4_7f_GET
#define XHOL_D1r_DATA_BYTES_4_7f_SET BCM56800_A0_XHOL_D1r_DATA_BYTES_4_7f_SET
#define READ_XHOL_D1r BCM56800_A0_READ_XHOL_D1r
#define WRITE_XHOL_D1r BCM56800_A0_WRITE_XHOL_D1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XHOL_D1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XHOL_D2
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E HOL Data 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_8_11  XPORT E2E HOL Data 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XHOL_D2r 0x00f00812

#define BCM56800_A0_XHOL_D2r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_D2.
 *
 */
typedef union BCM56800_A0_XHOL_D2r_s {
	uint32_t v[1];
	uint32_t xhol_d2[1];
	uint32_t _xhol_d2;
} BCM56800_A0_XHOL_D2r_t;

#define BCM56800_A0_XHOL_D2r_CLR(r) (r).xhol_d2[0] = 0
#define BCM56800_A0_XHOL_D2r_SET(r,d) (r).xhol_d2[0] = d
#define BCM56800_A0_XHOL_D2r_GET(r) (r).xhol_d2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XHOL_D2r_DATA_BYTES_8_11f_GET(r) ((r).xhol_d2[0])
#define BCM56800_A0_XHOL_D2r_DATA_BYTES_8_11f_SET(r,f) (r).xhol_d2[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_D2.
 *
 */
#define BCM56800_A0_READ_XHOL_D2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XHOL_D2r,(r._xhol_d2))
#define BCM56800_A0_WRITE_XHOL_D2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XHOL_D2r,&(r._xhol_d2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_D2r BCM56800_A0_XHOL_D2r
#define XHOL_D2r_SIZE BCM56800_A0_XHOL_D2r_SIZE
typedef BCM56800_A0_XHOL_D2r_t XHOL_D2r_t;
#define XHOL_D2r_CLR BCM56800_A0_XHOL_D2r_CLR
#define XHOL_D2r_SET BCM56800_A0_XHOL_D2r_SET
#define XHOL_D2r_GET BCM56800_A0_XHOL_D2r_GET
#define XHOL_D2r_DATA_BYTES_8_11f_GET BCM56800_A0_XHOL_D2r_DATA_BYTES_8_11f_GET
#define XHOL_D2r_DATA_BYTES_8_11f_SET BCM56800_A0_XHOL_D2r_DATA_BYTES_8_11f_SET
#define READ_XHOL_D2r BCM56800_A0_READ_XHOL_D2r
#define WRITE_XHOL_D2r BCM56800_A0_WRITE_XHOL_D2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XHOL_D2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XHOL_D3
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E HOL Data 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     D_BYTES_12_15    XPORT E2E HOL Data 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XHOL_D3r 0x00f00813

#define BCM56800_A0_XHOL_D3r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_D3.
 *
 */
typedef union BCM56800_A0_XHOL_D3r_s {
	uint32_t v[1];
	uint32_t xhol_d3[1];
	uint32_t _xhol_d3;
} BCM56800_A0_XHOL_D3r_t;

#define BCM56800_A0_XHOL_D3r_CLR(r) (r).xhol_d3[0] = 0
#define BCM56800_A0_XHOL_D3r_SET(r,d) (r).xhol_d3[0] = d
#define BCM56800_A0_XHOL_D3r_GET(r) (r).xhol_d3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XHOL_D3r_D_BYTES_12_15f_GET(r) ((r).xhol_d3[0])
#define BCM56800_A0_XHOL_D3r_D_BYTES_12_15f_SET(r,f) (r).xhol_d3[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_D3.
 *
 */
#define BCM56800_A0_READ_XHOL_D3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XHOL_D3r,(r._xhol_d3))
#define BCM56800_A0_WRITE_XHOL_D3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XHOL_D3r,&(r._xhol_d3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_D3r BCM56800_A0_XHOL_D3r
#define XHOL_D3r_SIZE BCM56800_A0_XHOL_D3r_SIZE
typedef BCM56800_A0_XHOL_D3r_t XHOL_D3r_t;
#define XHOL_D3r_CLR BCM56800_A0_XHOL_D3r_CLR
#define XHOL_D3r_SET BCM56800_A0_XHOL_D3r_SET
#define XHOL_D3r_GET BCM56800_A0_XHOL_D3r_GET
#define XHOL_D3r_D_BYTES_12_15f_GET BCM56800_A0_XHOL_D3r_D_BYTES_12_15f_GET
#define XHOL_D3r_D_BYTES_12_15f_SET BCM56800_A0_XHOL_D3r_D_BYTES_12_15f_SET
#define READ_XHOL_D3r BCM56800_A0_READ_XHOL_D3r
#define WRITE_XHOL_D3r BCM56800_A0_WRITE_XHOL_D3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XHOL_D3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XHOL_MH0
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E HOL pkt MH 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_0_3     XPORT E2E HOL pkt MH 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XHOL_MH0r 0x00f0080c

#define BCM56800_A0_XHOL_MH0r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_MH0.
 *
 */
typedef union BCM56800_A0_XHOL_MH0r_s {
	uint32_t v[1];
	uint32_t xhol_mh0[1];
	uint32_t _xhol_mh0;
} BCM56800_A0_XHOL_MH0r_t;

#define BCM56800_A0_XHOL_MH0r_CLR(r) (r).xhol_mh0[0] = 0
#define BCM56800_A0_XHOL_MH0r_SET(r,d) (r).xhol_mh0[0] = d
#define BCM56800_A0_XHOL_MH0r_GET(r) (r).xhol_mh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XHOL_MH0r_MH_BYTES_0_3f_GET(r) ((r).xhol_mh0[0])
#define BCM56800_A0_XHOL_MH0r_MH_BYTES_0_3f_SET(r,f) (r).xhol_mh0[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_MH0.
 *
 */
#define BCM56800_A0_READ_XHOL_MH0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XHOL_MH0r,(r._xhol_mh0))
#define BCM56800_A0_WRITE_XHOL_MH0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XHOL_MH0r,&(r._xhol_mh0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_MH0r BCM56800_A0_XHOL_MH0r
#define XHOL_MH0r_SIZE BCM56800_A0_XHOL_MH0r_SIZE
typedef BCM56800_A0_XHOL_MH0r_t XHOL_MH0r_t;
#define XHOL_MH0r_CLR BCM56800_A0_XHOL_MH0r_CLR
#define XHOL_MH0r_SET BCM56800_A0_XHOL_MH0r_SET
#define XHOL_MH0r_GET BCM56800_A0_XHOL_MH0r_GET
#define XHOL_MH0r_MH_BYTES_0_3f_GET BCM56800_A0_XHOL_MH0r_MH_BYTES_0_3f_GET
#define XHOL_MH0r_MH_BYTES_0_3f_SET BCM56800_A0_XHOL_MH0r_MH_BYTES_0_3f_SET
#define READ_XHOL_MH0r BCM56800_A0_READ_XHOL_MH0r
#define WRITE_XHOL_MH0r BCM56800_A0_WRITE_XHOL_MH0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XHOL_MH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XHOL_MH1
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E HOL pkt MH 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_4_7     XPORT E2E HOL pkt MH 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XHOL_MH1r 0x00f0080d

#define BCM56800_A0_XHOL_MH1r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_MH1.
 *
 */
typedef union BCM56800_A0_XHOL_MH1r_s {
	uint32_t v[1];
	uint32_t xhol_mh1[1];
	uint32_t _xhol_mh1;
} BCM56800_A0_XHOL_MH1r_t;

#define BCM56800_A0_XHOL_MH1r_CLR(r) (r).xhol_mh1[0] = 0
#define BCM56800_A0_XHOL_MH1r_SET(r,d) (r).xhol_mh1[0] = d
#define BCM56800_A0_XHOL_MH1r_GET(r) (r).xhol_mh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XHOL_MH1r_MH_BYTES_4_7f_GET(r) ((r).xhol_mh1[0])
#define BCM56800_A0_XHOL_MH1r_MH_BYTES_4_7f_SET(r,f) (r).xhol_mh1[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_MH1.
 *
 */
#define BCM56800_A0_READ_XHOL_MH1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XHOL_MH1r,(r._xhol_mh1))
#define BCM56800_A0_WRITE_XHOL_MH1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XHOL_MH1r,&(r._xhol_mh1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_MH1r BCM56800_A0_XHOL_MH1r
#define XHOL_MH1r_SIZE BCM56800_A0_XHOL_MH1r_SIZE
typedef BCM56800_A0_XHOL_MH1r_t XHOL_MH1r_t;
#define XHOL_MH1r_CLR BCM56800_A0_XHOL_MH1r_CLR
#define XHOL_MH1r_SET BCM56800_A0_XHOL_MH1r_SET
#define XHOL_MH1r_GET BCM56800_A0_XHOL_MH1r_GET
#define XHOL_MH1r_MH_BYTES_4_7f_GET BCM56800_A0_XHOL_MH1r_MH_BYTES_4_7f_GET
#define XHOL_MH1r_MH_BYTES_4_7f_SET BCM56800_A0_XHOL_MH1r_MH_BYTES_4_7f_SET
#define READ_XHOL_MH1r BCM56800_A0_READ_XHOL_MH1r
#define WRITE_XHOL_MH1r BCM56800_A0_WRITE_XHOL_MH1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XHOL_MH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XHOL_MH2
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E HOL pkt MH 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_8_11    XPORT E2E HOL pkt MH 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XHOL_MH2r 0x00f0080e

#define BCM56800_A0_XHOL_MH2r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_MH2.
 *
 */
typedef union BCM56800_A0_XHOL_MH2r_s {
	uint32_t v[1];
	uint32_t xhol_mh2[1];
	uint32_t _xhol_mh2;
} BCM56800_A0_XHOL_MH2r_t;

#define BCM56800_A0_XHOL_MH2r_CLR(r) (r).xhol_mh2[0] = 0
#define BCM56800_A0_XHOL_MH2r_SET(r,d) (r).xhol_mh2[0] = d
#define BCM56800_A0_XHOL_MH2r_GET(r) (r).xhol_mh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XHOL_MH2r_MH_BYTES_8_11f_GET(r) ((r).xhol_mh2[0])
#define BCM56800_A0_XHOL_MH2r_MH_BYTES_8_11f_SET(r,f) (r).xhol_mh2[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_MH2.
 *
 */
#define BCM56800_A0_READ_XHOL_MH2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XHOL_MH2r,(r._xhol_mh2))
#define BCM56800_A0_WRITE_XHOL_MH2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XHOL_MH2r,&(r._xhol_mh2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_MH2r BCM56800_A0_XHOL_MH2r
#define XHOL_MH2r_SIZE BCM56800_A0_XHOL_MH2r_SIZE
typedef BCM56800_A0_XHOL_MH2r_t XHOL_MH2r_t;
#define XHOL_MH2r_CLR BCM56800_A0_XHOL_MH2r_CLR
#define XHOL_MH2r_SET BCM56800_A0_XHOL_MH2r_SET
#define XHOL_MH2r_GET BCM56800_A0_XHOL_MH2r_GET
#define XHOL_MH2r_MH_BYTES_8_11f_GET BCM56800_A0_XHOL_MH2r_MH_BYTES_8_11f_GET
#define XHOL_MH2r_MH_BYTES_8_11f_SET BCM56800_A0_XHOL_MH2r_MH_BYTES_8_11f_SET
#define READ_XHOL_MH2r BCM56800_A0_READ_XHOL_MH2r
#define WRITE_XHOL_MH2r BCM56800_A0_WRITE_XHOL_MH2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XHOL_MH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XHOL_MH3
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E HOL pkt MH 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_12_15   XPORT E2E HOL pkt MH 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XHOL_MH3r 0x00f0080f

#define BCM56800_A0_XHOL_MH3r_SIZE 4

/*
 * This structure should be used to declare and program XHOL_MH3.
 *
 */
typedef union BCM56800_A0_XHOL_MH3r_s {
	uint32_t v[1];
	uint32_t xhol_mh3[1];
	uint32_t _xhol_mh3;
} BCM56800_A0_XHOL_MH3r_t;

#define BCM56800_A0_XHOL_MH3r_CLR(r) (r).xhol_mh3[0] = 0
#define BCM56800_A0_XHOL_MH3r_SET(r,d) (r).xhol_mh3[0] = d
#define BCM56800_A0_XHOL_MH3r_GET(r) (r).xhol_mh3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XHOL_MH3r_MH_BYTES_12_15f_GET(r) ((r).xhol_mh3[0])
#define BCM56800_A0_XHOL_MH3r_MH_BYTES_12_15f_SET(r,f) (r).xhol_mh3[0]=((uint32_t)f)

/*
 * These macros can be used to access XHOL_MH3.
 *
 */
#define BCM56800_A0_READ_XHOL_MH3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XHOL_MH3r,(r._xhol_mh3))
#define BCM56800_A0_WRITE_XHOL_MH3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XHOL_MH3r,&(r._xhol_mh3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XHOL_MH3r BCM56800_A0_XHOL_MH3r
#define XHOL_MH3r_SIZE BCM56800_A0_XHOL_MH3r_SIZE
typedef BCM56800_A0_XHOL_MH3r_t XHOL_MH3r_t;
#define XHOL_MH3r_CLR BCM56800_A0_XHOL_MH3r_CLR
#define XHOL_MH3r_SET BCM56800_A0_XHOL_MH3r_SET
#define XHOL_MH3r_GET BCM56800_A0_XHOL_MH3r_GET
#define XHOL_MH3r_MH_BYTES_12_15f_GET BCM56800_A0_XHOL_MH3r_MH_BYTES_12_15f_GET
#define XHOL_MH3r_MH_BYTES_12_15f_SET BCM56800_A0_XHOL_MH3r_MH_BYTES_12_15f_SET
#define READ_XHOL_MH3r BCM56800_A0_READ_XHOL_MH3r
#define WRITE_XHOL_MH3r BCM56800_A0_WRITE_XHOL_MH3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XHOL_MH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XIBP_D0
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E IBP Data 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_0_3   XPORT E2E IBP Data 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XIBP_D0r 0x00f00818

#define BCM56800_A0_XIBP_D0r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_D0.
 *
 */
typedef union BCM56800_A0_XIBP_D0r_s {
	uint32_t v[1];
	uint32_t xibp_d0[1];
	uint32_t _xibp_d0;
} BCM56800_A0_XIBP_D0r_t;

#define BCM56800_A0_XIBP_D0r_CLR(r) (r).xibp_d0[0] = 0
#define BCM56800_A0_XIBP_D0r_SET(r,d) (r).xibp_d0[0] = d
#define BCM56800_A0_XIBP_D0r_GET(r) (r).xibp_d0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XIBP_D0r_DATA_BYTES_0_3f_GET(r) ((r).xibp_d0[0])
#define BCM56800_A0_XIBP_D0r_DATA_BYTES_0_3f_SET(r,f) (r).xibp_d0[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_D0.
 *
 */
#define BCM56800_A0_READ_XIBP_D0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XIBP_D0r,(r._xibp_d0))
#define BCM56800_A0_WRITE_XIBP_D0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XIBP_D0r,&(r._xibp_d0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_D0r BCM56800_A0_XIBP_D0r
#define XIBP_D0r_SIZE BCM56800_A0_XIBP_D0r_SIZE
typedef BCM56800_A0_XIBP_D0r_t XIBP_D0r_t;
#define XIBP_D0r_CLR BCM56800_A0_XIBP_D0r_CLR
#define XIBP_D0r_SET BCM56800_A0_XIBP_D0r_SET
#define XIBP_D0r_GET BCM56800_A0_XIBP_D0r_GET
#define XIBP_D0r_DATA_BYTES_0_3f_GET BCM56800_A0_XIBP_D0r_DATA_BYTES_0_3f_GET
#define XIBP_D0r_DATA_BYTES_0_3f_SET BCM56800_A0_XIBP_D0r_DATA_BYTES_0_3f_SET
#define READ_XIBP_D0r BCM56800_A0_READ_XIBP_D0r
#define WRITE_XIBP_D0r BCM56800_A0_WRITE_XIBP_D0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XIBP_D0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XIBP_D1
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E IBP Data 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_4_7   XPORT E2E IBP Data 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XIBP_D1r 0x00f00819

#define BCM56800_A0_XIBP_D1r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_D1.
 *
 */
typedef union BCM56800_A0_XIBP_D1r_s {
	uint32_t v[1];
	uint32_t xibp_d1[1];
	uint32_t _xibp_d1;
} BCM56800_A0_XIBP_D1r_t;

#define BCM56800_A0_XIBP_D1r_CLR(r) (r).xibp_d1[0] = 0
#define BCM56800_A0_XIBP_D1r_SET(r,d) (r).xibp_d1[0] = d
#define BCM56800_A0_XIBP_D1r_GET(r) (r).xibp_d1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XIBP_D1r_DATA_BYTES_4_7f_GET(r) ((r).xibp_d1[0])
#define BCM56800_A0_XIBP_D1r_DATA_BYTES_4_7f_SET(r,f) (r).xibp_d1[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_D1.
 *
 */
#define BCM56800_A0_READ_XIBP_D1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XIBP_D1r,(r._xibp_d1))
#define BCM56800_A0_WRITE_XIBP_D1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XIBP_D1r,&(r._xibp_d1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_D1r BCM56800_A0_XIBP_D1r
#define XIBP_D1r_SIZE BCM56800_A0_XIBP_D1r_SIZE
typedef BCM56800_A0_XIBP_D1r_t XIBP_D1r_t;
#define XIBP_D1r_CLR BCM56800_A0_XIBP_D1r_CLR
#define XIBP_D1r_SET BCM56800_A0_XIBP_D1r_SET
#define XIBP_D1r_GET BCM56800_A0_XIBP_D1r_GET
#define XIBP_D1r_DATA_BYTES_4_7f_GET BCM56800_A0_XIBP_D1r_DATA_BYTES_4_7f_GET
#define XIBP_D1r_DATA_BYTES_4_7f_SET BCM56800_A0_XIBP_D1r_DATA_BYTES_4_7f_SET
#define READ_XIBP_D1r BCM56800_A0_READ_XIBP_D1r
#define WRITE_XIBP_D1r BCM56800_A0_WRITE_XIBP_D1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XIBP_D1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XIBP_D2
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E IBP Data 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_8_11  XPORT E2E IBP Data 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XIBP_D2r 0x00f0081a

#define BCM56800_A0_XIBP_D2r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_D2.
 *
 */
typedef union BCM56800_A0_XIBP_D2r_s {
	uint32_t v[1];
	uint32_t xibp_d2[1];
	uint32_t _xibp_d2;
} BCM56800_A0_XIBP_D2r_t;

#define BCM56800_A0_XIBP_D2r_CLR(r) (r).xibp_d2[0] = 0
#define BCM56800_A0_XIBP_D2r_SET(r,d) (r).xibp_d2[0] = d
#define BCM56800_A0_XIBP_D2r_GET(r) (r).xibp_d2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XIBP_D2r_DATA_BYTES_8_11f_GET(r) ((r).xibp_d2[0])
#define BCM56800_A0_XIBP_D2r_DATA_BYTES_8_11f_SET(r,f) (r).xibp_d2[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_D2.
 *
 */
#define BCM56800_A0_READ_XIBP_D2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XIBP_D2r,(r._xibp_d2))
#define BCM56800_A0_WRITE_XIBP_D2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XIBP_D2r,&(r._xibp_d2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_D2r BCM56800_A0_XIBP_D2r
#define XIBP_D2r_SIZE BCM56800_A0_XIBP_D2r_SIZE
typedef BCM56800_A0_XIBP_D2r_t XIBP_D2r_t;
#define XIBP_D2r_CLR BCM56800_A0_XIBP_D2r_CLR
#define XIBP_D2r_SET BCM56800_A0_XIBP_D2r_SET
#define XIBP_D2r_GET BCM56800_A0_XIBP_D2r_GET
#define XIBP_D2r_DATA_BYTES_8_11f_GET BCM56800_A0_XIBP_D2r_DATA_BYTES_8_11f_GET
#define XIBP_D2r_DATA_BYTES_8_11f_SET BCM56800_A0_XIBP_D2r_DATA_BYTES_8_11f_SET
#define READ_XIBP_D2r BCM56800_A0_READ_XIBP_D2r
#define WRITE_XIBP_D2r BCM56800_A0_WRITE_XIBP_D2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XIBP_D2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XIBP_D3
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E IBP Data 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     D_BYTES_12_15    XPORT E2E IBP Data 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XIBP_D3r 0x00f0081b

#define BCM56800_A0_XIBP_D3r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_D3.
 *
 */
typedef union BCM56800_A0_XIBP_D3r_s {
	uint32_t v[1];
	uint32_t xibp_d3[1];
	uint32_t _xibp_d3;
} BCM56800_A0_XIBP_D3r_t;

#define BCM56800_A0_XIBP_D3r_CLR(r) (r).xibp_d3[0] = 0
#define BCM56800_A0_XIBP_D3r_SET(r,d) (r).xibp_d3[0] = d
#define BCM56800_A0_XIBP_D3r_GET(r) (r).xibp_d3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XIBP_D3r_D_BYTES_12_15f_GET(r) ((r).xibp_d3[0])
#define BCM56800_A0_XIBP_D3r_D_BYTES_12_15f_SET(r,f) (r).xibp_d3[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_D3.
 *
 */
#define BCM56800_A0_READ_XIBP_D3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XIBP_D3r,(r._xibp_d3))
#define BCM56800_A0_WRITE_XIBP_D3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XIBP_D3r,&(r._xibp_d3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_D3r BCM56800_A0_XIBP_D3r
#define XIBP_D3r_SIZE BCM56800_A0_XIBP_D3r_SIZE
typedef BCM56800_A0_XIBP_D3r_t XIBP_D3r_t;
#define XIBP_D3r_CLR BCM56800_A0_XIBP_D3r_CLR
#define XIBP_D3r_SET BCM56800_A0_XIBP_D3r_SET
#define XIBP_D3r_GET BCM56800_A0_XIBP_D3r_GET
#define XIBP_D3r_D_BYTES_12_15f_GET BCM56800_A0_XIBP_D3r_D_BYTES_12_15f_GET
#define XIBP_D3r_D_BYTES_12_15f_SET BCM56800_A0_XIBP_D3r_D_BYTES_12_15f_SET
#define READ_XIBP_D3r BCM56800_A0_READ_XIBP_D3r
#define WRITE_XIBP_D3r BCM56800_A0_WRITE_XIBP_D3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XIBP_D3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XIBP_MH0
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E IBP pkt MH 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_0_3     XPORT E2E IBP pkt MH 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XIBP_MH0r 0x00f00814

#define BCM56800_A0_XIBP_MH0r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_MH0.
 *
 */
typedef union BCM56800_A0_XIBP_MH0r_s {
	uint32_t v[1];
	uint32_t xibp_mh0[1];
	uint32_t _xibp_mh0;
} BCM56800_A0_XIBP_MH0r_t;

#define BCM56800_A0_XIBP_MH0r_CLR(r) (r).xibp_mh0[0] = 0
#define BCM56800_A0_XIBP_MH0r_SET(r,d) (r).xibp_mh0[0] = d
#define BCM56800_A0_XIBP_MH0r_GET(r) (r).xibp_mh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XIBP_MH0r_MH_BYTES_0_3f_GET(r) ((r).xibp_mh0[0])
#define BCM56800_A0_XIBP_MH0r_MH_BYTES_0_3f_SET(r,f) (r).xibp_mh0[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_MH0.
 *
 */
#define BCM56800_A0_READ_XIBP_MH0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XIBP_MH0r,(r._xibp_mh0))
#define BCM56800_A0_WRITE_XIBP_MH0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XIBP_MH0r,&(r._xibp_mh0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_MH0r BCM56800_A0_XIBP_MH0r
#define XIBP_MH0r_SIZE BCM56800_A0_XIBP_MH0r_SIZE
typedef BCM56800_A0_XIBP_MH0r_t XIBP_MH0r_t;
#define XIBP_MH0r_CLR BCM56800_A0_XIBP_MH0r_CLR
#define XIBP_MH0r_SET BCM56800_A0_XIBP_MH0r_SET
#define XIBP_MH0r_GET BCM56800_A0_XIBP_MH0r_GET
#define XIBP_MH0r_MH_BYTES_0_3f_GET BCM56800_A0_XIBP_MH0r_MH_BYTES_0_3f_GET
#define XIBP_MH0r_MH_BYTES_0_3f_SET BCM56800_A0_XIBP_MH0r_MH_BYTES_0_3f_SET
#define READ_XIBP_MH0r BCM56800_A0_READ_XIBP_MH0r
#define WRITE_XIBP_MH0r BCM56800_A0_WRITE_XIBP_MH0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XIBP_MH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XIBP_MH1
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E IBP pkt MH 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_4_7     XPORT E2E IBP pkt MH 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XIBP_MH1r 0x00f00815

#define BCM56800_A0_XIBP_MH1r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_MH1.
 *
 */
typedef union BCM56800_A0_XIBP_MH1r_s {
	uint32_t v[1];
	uint32_t xibp_mh1[1];
	uint32_t _xibp_mh1;
} BCM56800_A0_XIBP_MH1r_t;

#define BCM56800_A0_XIBP_MH1r_CLR(r) (r).xibp_mh1[0] = 0
#define BCM56800_A0_XIBP_MH1r_SET(r,d) (r).xibp_mh1[0] = d
#define BCM56800_A0_XIBP_MH1r_GET(r) (r).xibp_mh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XIBP_MH1r_MH_BYTES_4_7f_GET(r) ((r).xibp_mh1[0])
#define BCM56800_A0_XIBP_MH1r_MH_BYTES_4_7f_SET(r,f) (r).xibp_mh1[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_MH1.
 *
 */
#define BCM56800_A0_READ_XIBP_MH1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XIBP_MH1r,(r._xibp_mh1))
#define BCM56800_A0_WRITE_XIBP_MH1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XIBP_MH1r,&(r._xibp_mh1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_MH1r BCM56800_A0_XIBP_MH1r
#define XIBP_MH1r_SIZE BCM56800_A0_XIBP_MH1r_SIZE
typedef BCM56800_A0_XIBP_MH1r_t XIBP_MH1r_t;
#define XIBP_MH1r_CLR BCM56800_A0_XIBP_MH1r_CLR
#define XIBP_MH1r_SET BCM56800_A0_XIBP_MH1r_SET
#define XIBP_MH1r_GET BCM56800_A0_XIBP_MH1r_GET
#define XIBP_MH1r_MH_BYTES_4_7f_GET BCM56800_A0_XIBP_MH1r_MH_BYTES_4_7f_GET
#define XIBP_MH1r_MH_BYTES_4_7f_SET BCM56800_A0_XIBP_MH1r_MH_BYTES_4_7f_SET
#define READ_XIBP_MH1r BCM56800_A0_READ_XIBP_MH1r
#define WRITE_XIBP_MH1r BCM56800_A0_WRITE_XIBP_MH1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XIBP_MH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XIBP_MH2
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E IBP pkt MH 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_8_11    XPORT E2E IBP pkt MH 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XIBP_MH2r 0x00f00816

#define BCM56800_A0_XIBP_MH2r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_MH2.
 *
 */
typedef union BCM56800_A0_XIBP_MH2r_s {
	uint32_t v[1];
	uint32_t xibp_mh2[1];
	uint32_t _xibp_mh2;
} BCM56800_A0_XIBP_MH2r_t;

#define BCM56800_A0_XIBP_MH2r_CLR(r) (r).xibp_mh2[0] = 0
#define BCM56800_A0_XIBP_MH2r_SET(r,d) (r).xibp_mh2[0] = d
#define BCM56800_A0_XIBP_MH2r_GET(r) (r).xibp_mh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XIBP_MH2r_MH_BYTES_8_11f_GET(r) ((r).xibp_mh2[0])
#define BCM56800_A0_XIBP_MH2r_MH_BYTES_8_11f_SET(r,f) (r).xibp_mh2[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_MH2.
 *
 */
#define BCM56800_A0_READ_XIBP_MH2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XIBP_MH2r,(r._xibp_mh2))
#define BCM56800_A0_WRITE_XIBP_MH2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XIBP_MH2r,&(r._xibp_mh2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_MH2r BCM56800_A0_XIBP_MH2r
#define XIBP_MH2r_SIZE BCM56800_A0_XIBP_MH2r_SIZE
typedef BCM56800_A0_XIBP_MH2r_t XIBP_MH2r_t;
#define XIBP_MH2r_CLR BCM56800_A0_XIBP_MH2r_CLR
#define XIBP_MH2r_SET BCM56800_A0_XIBP_MH2r_SET
#define XIBP_MH2r_GET BCM56800_A0_XIBP_MH2r_GET
#define XIBP_MH2r_MH_BYTES_8_11f_GET BCM56800_A0_XIBP_MH2r_MH_BYTES_8_11f_GET
#define XIBP_MH2r_MH_BYTES_8_11f_SET BCM56800_A0_XIBP_MH2r_MH_BYTES_8_11f_SET
#define READ_XIBP_MH2r BCM56800_A0_READ_XIBP_MH2r
#define WRITE_XIBP_MH2r BCM56800_A0_WRITE_XIBP_MH2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XIBP_MH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XIBP_MH3
 * BLOCKS:   GXPORT
 * DESC:     XPORT E2E IBP pkt MH 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_12_15   XPORT E2E IBP pkt MH 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XIBP_MH3r 0x00f00817

#define BCM56800_A0_XIBP_MH3r_SIZE 4

/*
 * This structure should be used to declare and program XIBP_MH3.
 *
 */
typedef union BCM56800_A0_XIBP_MH3r_s {
	uint32_t v[1];
	uint32_t xibp_mh3[1];
	uint32_t _xibp_mh3;
} BCM56800_A0_XIBP_MH3r_t;

#define BCM56800_A0_XIBP_MH3r_CLR(r) (r).xibp_mh3[0] = 0
#define BCM56800_A0_XIBP_MH3r_SET(r,d) (r).xibp_mh3[0] = d
#define BCM56800_A0_XIBP_MH3r_GET(r) (r).xibp_mh3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XIBP_MH3r_MH_BYTES_12_15f_GET(r) ((r).xibp_mh3[0])
#define BCM56800_A0_XIBP_MH3r_MH_BYTES_12_15f_SET(r,f) (r).xibp_mh3[0]=((uint32_t)f)

/*
 * These macros can be used to access XIBP_MH3.
 *
 */
#define BCM56800_A0_READ_XIBP_MH3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XIBP_MH3r,(r._xibp_mh3))
#define BCM56800_A0_WRITE_XIBP_MH3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XIBP_MH3r,&(r._xibp_mh3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XIBP_MH3r BCM56800_A0_XIBP_MH3r
#define XIBP_MH3r_SIZE BCM56800_A0_XIBP_MH3r_SIZE
typedef BCM56800_A0_XIBP_MH3r_t XIBP_MH3r_t;
#define XIBP_MH3r_CLR BCM56800_A0_XIBP_MH3r_CLR
#define XIBP_MH3r_SET BCM56800_A0_XIBP_MH3r_SET
#define XIBP_MH3r_GET BCM56800_A0_XIBP_MH3r_GET
#define XIBP_MH3r_MH_BYTES_12_15f_GET BCM56800_A0_XIBP_MH3r_MH_BYTES_12_15f_GET
#define XIBP_MH3r_MH_BYTES_12_15f_SET BCM56800_A0_XIBP_MH3r_MH_BYTES_12_15f_SET
#define READ_XIBP_MH3r BCM56800_A0_READ_XIBP_MH3r
#define WRITE_XIBP_MH3r BCM56800_A0_WRITE_XIBP_MH3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XIBP_MH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_D0
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE Data 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_0_3   XPORT PAUSE Data 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_D0r 0x00f00808

#define BCM56800_A0_XPAUSE_D0r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_D0.
 *
 */
typedef union BCM56800_A0_XPAUSE_D0r_s {
	uint32_t v[1];
	uint32_t xpause_d0[1];
	uint32_t _xpause_d0;
} BCM56800_A0_XPAUSE_D0r_t;

#define BCM56800_A0_XPAUSE_D0r_CLR(r) (r).xpause_d0[0] = 0
#define BCM56800_A0_XPAUSE_D0r_SET(r,d) (r).xpause_d0[0] = d
#define BCM56800_A0_XPAUSE_D0r_GET(r) (r).xpause_d0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_D0r_DATA_BYTES_0_3f_GET(r) ((r).xpause_d0[0])
#define BCM56800_A0_XPAUSE_D0r_DATA_BYTES_0_3f_SET(r,f) (r).xpause_d0[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_D0.
 *
 */
#define BCM56800_A0_READ_XPAUSE_D0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_D0r,(r._xpause_d0))
#define BCM56800_A0_WRITE_XPAUSE_D0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_D0r,&(r._xpause_d0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_D0r BCM56800_A0_XPAUSE_D0r
#define XPAUSE_D0r_SIZE BCM56800_A0_XPAUSE_D0r_SIZE
typedef BCM56800_A0_XPAUSE_D0r_t XPAUSE_D0r_t;
#define XPAUSE_D0r_CLR BCM56800_A0_XPAUSE_D0r_CLR
#define XPAUSE_D0r_SET BCM56800_A0_XPAUSE_D0r_SET
#define XPAUSE_D0r_GET BCM56800_A0_XPAUSE_D0r_GET
#define XPAUSE_D0r_DATA_BYTES_0_3f_GET BCM56800_A0_XPAUSE_D0r_DATA_BYTES_0_3f_GET
#define XPAUSE_D0r_DATA_BYTES_0_3f_SET BCM56800_A0_XPAUSE_D0r_DATA_BYTES_0_3f_SET
#define READ_XPAUSE_D0r BCM56800_A0_READ_XPAUSE_D0r
#define WRITE_XPAUSE_D0r BCM56800_A0_WRITE_XPAUSE_D0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_D0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_D1
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE Data 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_4_7   XPORT PAUSE Data 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_D1r 0x00f00809

#define BCM56800_A0_XPAUSE_D1r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_D1.
 *
 */
typedef union BCM56800_A0_XPAUSE_D1r_s {
	uint32_t v[1];
	uint32_t xpause_d1[1];
	uint32_t _xpause_d1;
} BCM56800_A0_XPAUSE_D1r_t;

#define BCM56800_A0_XPAUSE_D1r_CLR(r) (r).xpause_d1[0] = 0
#define BCM56800_A0_XPAUSE_D1r_SET(r,d) (r).xpause_d1[0] = d
#define BCM56800_A0_XPAUSE_D1r_GET(r) (r).xpause_d1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_D1r_DATA_BYTES_4_7f_GET(r) ((r).xpause_d1[0])
#define BCM56800_A0_XPAUSE_D1r_DATA_BYTES_4_7f_SET(r,f) (r).xpause_d1[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_D1.
 *
 */
#define BCM56800_A0_READ_XPAUSE_D1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_D1r,(r._xpause_d1))
#define BCM56800_A0_WRITE_XPAUSE_D1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_D1r,&(r._xpause_d1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_D1r BCM56800_A0_XPAUSE_D1r
#define XPAUSE_D1r_SIZE BCM56800_A0_XPAUSE_D1r_SIZE
typedef BCM56800_A0_XPAUSE_D1r_t XPAUSE_D1r_t;
#define XPAUSE_D1r_CLR BCM56800_A0_XPAUSE_D1r_CLR
#define XPAUSE_D1r_SET BCM56800_A0_XPAUSE_D1r_SET
#define XPAUSE_D1r_GET BCM56800_A0_XPAUSE_D1r_GET
#define XPAUSE_D1r_DATA_BYTES_4_7f_GET BCM56800_A0_XPAUSE_D1r_DATA_BYTES_4_7f_GET
#define XPAUSE_D1r_DATA_BYTES_4_7f_SET BCM56800_A0_XPAUSE_D1r_DATA_BYTES_4_7f_SET
#define READ_XPAUSE_D1r BCM56800_A0_READ_XPAUSE_D1r
#define WRITE_XPAUSE_D1r BCM56800_A0_WRITE_XPAUSE_D1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_D1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_D2
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE Data 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_8_11  XPORT PAUSE Data 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_D2r 0x00f0080a

#define BCM56800_A0_XPAUSE_D2r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_D2.
 *
 */
typedef union BCM56800_A0_XPAUSE_D2r_s {
	uint32_t v[1];
	uint32_t xpause_d2[1];
	uint32_t _xpause_d2;
} BCM56800_A0_XPAUSE_D2r_t;

#define BCM56800_A0_XPAUSE_D2r_CLR(r) (r).xpause_d2[0] = 0
#define BCM56800_A0_XPAUSE_D2r_SET(r,d) (r).xpause_d2[0] = d
#define BCM56800_A0_XPAUSE_D2r_GET(r) (r).xpause_d2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_D2r_DATA_BYTES_8_11f_GET(r) ((r).xpause_d2[0])
#define BCM56800_A0_XPAUSE_D2r_DATA_BYTES_8_11f_SET(r,f) (r).xpause_d2[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_D2.
 *
 */
#define BCM56800_A0_READ_XPAUSE_D2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_D2r,(r._xpause_d2))
#define BCM56800_A0_WRITE_XPAUSE_D2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_D2r,&(r._xpause_d2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_D2r BCM56800_A0_XPAUSE_D2r
#define XPAUSE_D2r_SIZE BCM56800_A0_XPAUSE_D2r_SIZE
typedef BCM56800_A0_XPAUSE_D2r_t XPAUSE_D2r_t;
#define XPAUSE_D2r_CLR BCM56800_A0_XPAUSE_D2r_CLR
#define XPAUSE_D2r_SET BCM56800_A0_XPAUSE_D2r_SET
#define XPAUSE_D2r_GET BCM56800_A0_XPAUSE_D2r_GET
#define XPAUSE_D2r_DATA_BYTES_8_11f_GET BCM56800_A0_XPAUSE_D2r_DATA_BYTES_8_11f_GET
#define XPAUSE_D2r_DATA_BYTES_8_11f_SET BCM56800_A0_XPAUSE_D2r_DATA_BYTES_8_11f_SET
#define READ_XPAUSE_D2r BCM56800_A0_READ_XPAUSE_D2r
#define WRITE_XPAUSE_D2r BCM56800_A0_WRITE_XPAUSE_D2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_D2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_D3
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE Data 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     DATA_BYTES_12_15 XPORT PAUSE Data 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_D3r 0x00f0080b

#define BCM56800_A0_XPAUSE_D3r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_D3.
 *
 */
typedef union BCM56800_A0_XPAUSE_D3r_s {
	uint32_t v[1];
	uint32_t xpause_d3[1];
	uint32_t _xpause_d3;
} BCM56800_A0_XPAUSE_D3r_t;

#define BCM56800_A0_XPAUSE_D3r_CLR(r) (r).xpause_d3[0] = 0
#define BCM56800_A0_XPAUSE_D3r_SET(r,d) (r).xpause_d3[0] = d
#define BCM56800_A0_XPAUSE_D3r_GET(r) (r).xpause_d3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_D3r_DATA_BYTES_12_15f_GET(r) ((r).xpause_d3[0])
#define BCM56800_A0_XPAUSE_D3r_DATA_BYTES_12_15f_SET(r,f) (r).xpause_d3[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_D3.
 *
 */
#define BCM56800_A0_READ_XPAUSE_D3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_D3r,(r._xpause_d3))
#define BCM56800_A0_WRITE_XPAUSE_D3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_D3r,&(r._xpause_d3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_D3r BCM56800_A0_XPAUSE_D3r
#define XPAUSE_D3r_SIZE BCM56800_A0_XPAUSE_D3r_SIZE
typedef BCM56800_A0_XPAUSE_D3r_t XPAUSE_D3r_t;
#define XPAUSE_D3r_CLR BCM56800_A0_XPAUSE_D3r_CLR
#define XPAUSE_D3r_SET BCM56800_A0_XPAUSE_D3r_SET
#define XPAUSE_D3r_GET BCM56800_A0_XPAUSE_D3r_GET
#define XPAUSE_D3r_DATA_BYTES_12_15f_GET BCM56800_A0_XPAUSE_D3r_DATA_BYTES_12_15f_GET
#define XPAUSE_D3r_DATA_BYTES_12_15f_SET BCM56800_A0_XPAUSE_D3r_DATA_BYTES_12_15f_SET
#define READ_XPAUSE_D3r BCM56800_A0_READ_XPAUSE_D3r
#define WRITE_XPAUSE_D3r BCM56800_A0_WRITE_XPAUSE_D3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_D3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_MH0
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE MH 1st 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_0_3     XPORT PAUSE MH 1st 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_MH0r 0x00f00804

#define BCM56800_A0_XPAUSE_MH0r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_MH0.
 *
 */
typedef union BCM56800_A0_XPAUSE_MH0r_s {
	uint32_t v[1];
	uint32_t xpause_mh0[1];
	uint32_t _xpause_mh0;
} BCM56800_A0_XPAUSE_MH0r_t;

#define BCM56800_A0_XPAUSE_MH0r_CLR(r) (r).xpause_mh0[0] = 0
#define BCM56800_A0_XPAUSE_MH0r_SET(r,d) (r).xpause_mh0[0] = d
#define BCM56800_A0_XPAUSE_MH0r_GET(r) (r).xpause_mh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_MH0r_MH_BYTES_0_3f_GET(r) ((r).xpause_mh0[0])
#define BCM56800_A0_XPAUSE_MH0r_MH_BYTES_0_3f_SET(r,f) (r).xpause_mh0[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_MH0.
 *
 */
#define BCM56800_A0_READ_XPAUSE_MH0r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_MH0r,(r._xpause_mh0))
#define BCM56800_A0_WRITE_XPAUSE_MH0r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_MH0r,&(r._xpause_mh0))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_MH0r BCM56800_A0_XPAUSE_MH0r
#define XPAUSE_MH0r_SIZE BCM56800_A0_XPAUSE_MH0r_SIZE
typedef BCM56800_A0_XPAUSE_MH0r_t XPAUSE_MH0r_t;
#define XPAUSE_MH0r_CLR BCM56800_A0_XPAUSE_MH0r_CLR
#define XPAUSE_MH0r_SET BCM56800_A0_XPAUSE_MH0r_SET
#define XPAUSE_MH0r_GET BCM56800_A0_XPAUSE_MH0r_GET
#define XPAUSE_MH0r_MH_BYTES_0_3f_GET BCM56800_A0_XPAUSE_MH0r_MH_BYTES_0_3f_GET
#define XPAUSE_MH0r_MH_BYTES_0_3f_SET BCM56800_A0_XPAUSE_MH0r_MH_BYTES_0_3f_SET
#define READ_XPAUSE_MH0r BCM56800_A0_READ_XPAUSE_MH0r
#define WRITE_XPAUSE_MH0r BCM56800_A0_WRITE_XPAUSE_MH0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_MH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_MH1
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE MH 2nd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_4_7     XPORT PAUSE MH 2nd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_MH1r 0x00f00805

#define BCM56800_A0_XPAUSE_MH1r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_MH1.
 *
 */
typedef union BCM56800_A0_XPAUSE_MH1r_s {
	uint32_t v[1];
	uint32_t xpause_mh1[1];
	uint32_t _xpause_mh1;
} BCM56800_A0_XPAUSE_MH1r_t;

#define BCM56800_A0_XPAUSE_MH1r_CLR(r) (r).xpause_mh1[0] = 0
#define BCM56800_A0_XPAUSE_MH1r_SET(r,d) (r).xpause_mh1[0] = d
#define BCM56800_A0_XPAUSE_MH1r_GET(r) (r).xpause_mh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_MH1r_MH_BYTES_4_7f_GET(r) ((r).xpause_mh1[0])
#define BCM56800_A0_XPAUSE_MH1r_MH_BYTES_4_7f_SET(r,f) (r).xpause_mh1[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_MH1.
 *
 */
#define BCM56800_A0_READ_XPAUSE_MH1r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_MH1r,(r._xpause_mh1))
#define BCM56800_A0_WRITE_XPAUSE_MH1r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_MH1r,&(r._xpause_mh1))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_MH1r BCM56800_A0_XPAUSE_MH1r
#define XPAUSE_MH1r_SIZE BCM56800_A0_XPAUSE_MH1r_SIZE
typedef BCM56800_A0_XPAUSE_MH1r_t XPAUSE_MH1r_t;
#define XPAUSE_MH1r_CLR BCM56800_A0_XPAUSE_MH1r_CLR
#define XPAUSE_MH1r_SET BCM56800_A0_XPAUSE_MH1r_SET
#define XPAUSE_MH1r_GET BCM56800_A0_XPAUSE_MH1r_GET
#define XPAUSE_MH1r_MH_BYTES_4_7f_GET BCM56800_A0_XPAUSE_MH1r_MH_BYTES_4_7f_GET
#define XPAUSE_MH1r_MH_BYTES_4_7f_SET BCM56800_A0_XPAUSE_MH1r_MH_BYTES_4_7f_SET
#define READ_XPAUSE_MH1r BCM56800_A0_READ_XPAUSE_MH1r
#define WRITE_XPAUSE_MH1r BCM56800_A0_WRITE_XPAUSE_MH1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_MH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_MH2
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE MH 3rd 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_8_11    XPORT PAUSE MH 3rd 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_MH2r 0x00f00806

#define BCM56800_A0_XPAUSE_MH2r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_MH2.
 *
 */
typedef union BCM56800_A0_XPAUSE_MH2r_s {
	uint32_t v[1];
	uint32_t xpause_mh2[1];
	uint32_t _xpause_mh2;
} BCM56800_A0_XPAUSE_MH2r_t;

#define BCM56800_A0_XPAUSE_MH2r_CLR(r) (r).xpause_mh2[0] = 0
#define BCM56800_A0_XPAUSE_MH2r_SET(r,d) (r).xpause_mh2[0] = d
#define BCM56800_A0_XPAUSE_MH2r_GET(r) (r).xpause_mh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_MH2r_MH_BYTES_8_11f_GET(r) ((r).xpause_mh2[0])
#define BCM56800_A0_XPAUSE_MH2r_MH_BYTES_8_11f_SET(r,f) (r).xpause_mh2[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_MH2.
 *
 */
#define BCM56800_A0_READ_XPAUSE_MH2r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_MH2r,(r._xpause_mh2))
#define BCM56800_A0_WRITE_XPAUSE_MH2r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_MH2r,&(r._xpause_mh2))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_MH2r BCM56800_A0_XPAUSE_MH2r
#define XPAUSE_MH2r_SIZE BCM56800_A0_XPAUSE_MH2r_SIZE
typedef BCM56800_A0_XPAUSE_MH2r_t XPAUSE_MH2r_t;
#define XPAUSE_MH2r_CLR BCM56800_A0_XPAUSE_MH2r_CLR
#define XPAUSE_MH2r_SET BCM56800_A0_XPAUSE_MH2r_SET
#define XPAUSE_MH2r_GET BCM56800_A0_XPAUSE_MH2r_GET
#define XPAUSE_MH2r_MH_BYTES_8_11f_GET BCM56800_A0_XPAUSE_MH2r_MH_BYTES_8_11f_GET
#define XPAUSE_MH2r_MH_BYTES_8_11f_SET BCM56800_A0_XPAUSE_MH2r_MH_BYTES_8_11f_SET
#define READ_XPAUSE_MH2r BCM56800_A0_READ_XPAUSE_MH2r
#define WRITE_XPAUSE_MH2r BCM56800_A0_WRITE_XPAUSE_MH2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_MH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_MH3
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE MH 4th 4 bytes
 * SIZE:     32
 * FIELDS:
 *     MH_BYTES_12_15   XPORT PAUSE MH 4th 4 bytes
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_MH3r 0x00f00807

#define BCM56800_A0_XPAUSE_MH3r_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_MH3.
 *
 */
typedef union BCM56800_A0_XPAUSE_MH3r_s {
	uint32_t v[1];
	uint32_t xpause_mh3[1];
	uint32_t _xpause_mh3;
} BCM56800_A0_XPAUSE_MH3r_t;

#define BCM56800_A0_XPAUSE_MH3r_CLR(r) (r).xpause_mh3[0] = 0
#define BCM56800_A0_XPAUSE_MH3r_SET(r,d) (r).xpause_mh3[0] = d
#define BCM56800_A0_XPAUSE_MH3r_GET(r) (r).xpause_mh3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_MH3r_MH_BYTES_12_15f_GET(r) ((r).xpause_mh3[0])
#define BCM56800_A0_XPAUSE_MH3r_MH_BYTES_12_15f_SET(r,f) (r).xpause_mh3[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_MH3.
 *
 */
#define BCM56800_A0_READ_XPAUSE_MH3r(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_MH3r,(r._xpause_mh3))
#define BCM56800_A0_WRITE_XPAUSE_MH3r(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_MH3r,&(r._xpause_mh3))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_MH3r BCM56800_A0_XPAUSE_MH3r
#define XPAUSE_MH3r_SIZE BCM56800_A0_XPAUSE_MH3r_SIZE
typedef BCM56800_A0_XPAUSE_MH3r_t XPAUSE_MH3r_t;
#define XPAUSE_MH3r_CLR BCM56800_A0_XPAUSE_MH3r_CLR
#define XPAUSE_MH3r_SET BCM56800_A0_XPAUSE_MH3r_SET
#define XPAUSE_MH3r_GET BCM56800_A0_XPAUSE_MH3r_GET
#define XPAUSE_MH3r_MH_BYTES_12_15f_GET BCM56800_A0_XPAUSE_MH3r_MH_BYTES_12_15f_GET
#define XPAUSE_MH3r_MH_BYTES_12_15f_SET BCM56800_A0_XPAUSE_MH3r_MH_BYTES_12_15f_SET
#define READ_XPAUSE_MH3r BCM56800_A0_READ_XPAUSE_MH3r
#define WRITE_XPAUSE_MH3r BCM56800_A0_WRITE_XPAUSE_MH3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_MH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_RX_DA_LS
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE RX pkt DA - lower 32 bits
 * SIZE:     32
 * FIELDS:
 *     DA               IPIC Rx pkt expected DA - lower 32 bits
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_RX_DA_LSr 0x00f0081d

#define BCM56800_A0_XPAUSE_RX_DA_LSr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_RX_DA_LS.
 *
 */
typedef union BCM56800_A0_XPAUSE_RX_DA_LSr_s {
	uint32_t v[1];
	uint32_t xpause_rx_da_ls[1];
	uint32_t _xpause_rx_da_ls;
} BCM56800_A0_XPAUSE_RX_DA_LSr_t;

#define BCM56800_A0_XPAUSE_RX_DA_LSr_CLR(r) (r).xpause_rx_da_ls[0] = 0
#define BCM56800_A0_XPAUSE_RX_DA_LSr_SET(r,d) (r).xpause_rx_da_ls[0] = d
#define BCM56800_A0_XPAUSE_RX_DA_LSr_GET(r) (r).xpause_rx_da_ls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_RX_DA_LSr_DAf_GET(r) ((r).xpause_rx_da_ls[0])
#define BCM56800_A0_XPAUSE_RX_DA_LSr_DAf_SET(r,f) (r).xpause_rx_da_ls[0]=((uint32_t)f)

/*
 * These macros can be used to access XPAUSE_RX_DA_LS.
 *
 */
#define BCM56800_A0_READ_XPAUSE_RX_DA_LSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_RX_DA_LSr,(r._xpause_rx_da_ls))
#define BCM56800_A0_WRITE_XPAUSE_RX_DA_LSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_RX_DA_LSr,&(r._xpause_rx_da_ls))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_RX_DA_LSr BCM56800_A0_XPAUSE_RX_DA_LSr
#define XPAUSE_RX_DA_LSr_SIZE BCM56800_A0_XPAUSE_RX_DA_LSr_SIZE
typedef BCM56800_A0_XPAUSE_RX_DA_LSr_t XPAUSE_RX_DA_LSr_t;
#define XPAUSE_RX_DA_LSr_CLR BCM56800_A0_XPAUSE_RX_DA_LSr_CLR
#define XPAUSE_RX_DA_LSr_SET BCM56800_A0_XPAUSE_RX_DA_LSr_SET
#define XPAUSE_RX_DA_LSr_GET BCM56800_A0_XPAUSE_RX_DA_LSr_GET
#define XPAUSE_RX_DA_LSr_DAf_GET BCM56800_A0_XPAUSE_RX_DA_LSr_DAf_GET
#define XPAUSE_RX_DA_LSr_DAf_SET BCM56800_A0_XPAUSE_RX_DA_LSr_DAf_SET
#define READ_XPAUSE_RX_DA_LSr BCM56800_A0_READ_XPAUSE_RX_DA_LSr
#define WRITE_XPAUSE_RX_DA_LSr BCM56800_A0_WRITE_XPAUSE_RX_DA_LSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_RX_DA_LSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_RX_DA_MS
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE RX pkt DA - upper 16 bits
 * SIZE:     32
 * FIELDS:
 *     DA               XPORT RX pkt expected DA - upper 16 bits
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_RX_DA_MSr 0x00f0081c

#define BCM56800_A0_XPAUSE_RX_DA_MSr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_RX_DA_MS.
 *
 */
typedef union BCM56800_A0_XPAUSE_RX_DA_MSr_s {
	uint32_t v[1];
	uint32_t xpause_rx_da_ms[1];
	uint32_t _xpause_rx_da_ms;
} BCM56800_A0_XPAUSE_RX_DA_MSr_t;

#define BCM56800_A0_XPAUSE_RX_DA_MSr_CLR(r) (r).xpause_rx_da_ms[0] = 0
#define BCM56800_A0_XPAUSE_RX_DA_MSr_SET(r,d) (r).xpause_rx_da_ms[0] = d
#define BCM56800_A0_XPAUSE_RX_DA_MSr_GET(r) (r).xpause_rx_da_ms[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_RX_DA_MSr_DAf_GET(r) (((r).xpause_rx_da_ms[0]) & 0xffff)
#define BCM56800_A0_XPAUSE_RX_DA_MSr_DAf_SET(r,f) (r).xpause_rx_da_ms[0]=(((r).xpause_rx_da_ms[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_RX_DA_MS.
 *
 */
#define BCM56800_A0_READ_XPAUSE_RX_DA_MSr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_RX_DA_MSr,(r._xpause_rx_da_ms))
#define BCM56800_A0_WRITE_XPAUSE_RX_DA_MSr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_RX_DA_MSr,&(r._xpause_rx_da_ms))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_RX_DA_MSr BCM56800_A0_XPAUSE_RX_DA_MSr
#define XPAUSE_RX_DA_MSr_SIZE BCM56800_A0_XPAUSE_RX_DA_MSr_SIZE
typedef BCM56800_A0_XPAUSE_RX_DA_MSr_t XPAUSE_RX_DA_MSr_t;
#define XPAUSE_RX_DA_MSr_CLR BCM56800_A0_XPAUSE_RX_DA_MSr_CLR
#define XPAUSE_RX_DA_MSr_SET BCM56800_A0_XPAUSE_RX_DA_MSr_SET
#define XPAUSE_RX_DA_MSr_GET BCM56800_A0_XPAUSE_RX_DA_MSr_GET
#define XPAUSE_RX_DA_MSr_DAf_GET BCM56800_A0_XPAUSE_RX_DA_MSr_DAf_GET
#define XPAUSE_RX_DA_MSr_DAf_SET BCM56800_A0_XPAUSE_RX_DA_MSr_DAf_SET
#define READ_XPAUSE_RX_DA_MSr BCM56800_A0_READ_XPAUSE_RX_DA_MSr
#define WRITE_XPAUSE_RX_DA_MSr BCM56800_A0_WRITE_XPAUSE_RX_DA_MSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_RX_DA_MSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_RX_LENGTH_TYPE
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE Rx pkt expected Length/Type field
 * SIZE:     32
 * FIELDS:
 *     LENGTH_TYPE      XPORT PAUSE Rx pkt expected Length/Type field
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr 0x00f0081e

#define BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_RX_LENGTH_TYPE.
 *
 */
typedef union BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_s {
	uint32_t v[1];
	uint32_t xpause_rx_length_type[1];
	uint32_t _xpause_rx_length_type;
} BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_t;

#define BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_CLR(r) (r).xpause_rx_length_type[0] = 0
#define BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_SET(r,d) (r).xpause_rx_length_type[0] = d
#define BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_GET(r) (r).xpause_rx_length_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET(r) (((r).xpause_rx_length_type[0]) & 0xffff)
#define BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET(r,f) (r).xpause_rx_length_type[0]=(((r).xpause_rx_length_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_RX_LENGTH_TYPE.
 *
 */
#define BCM56800_A0_READ_XPAUSE_RX_LENGTH_TYPEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr,(r._xpause_rx_length_type))
#define BCM56800_A0_WRITE_XPAUSE_RX_LENGTH_TYPEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr,&(r._xpause_rx_length_type))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_RX_LENGTH_TYPEr BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr
#define XPAUSE_RX_LENGTH_TYPEr_SIZE BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_SIZE
typedef BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_t XPAUSE_RX_LENGTH_TYPEr_t;
#define XPAUSE_RX_LENGTH_TYPEr_CLR BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_CLR
#define XPAUSE_RX_LENGTH_TYPEr_SET BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_SET
#define XPAUSE_RX_LENGTH_TYPEr_GET BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_GET
#define XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_GET
#define XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr_LENGTH_TYPEf_SET
#define READ_XPAUSE_RX_LENGTH_TYPEr BCM56800_A0_READ_XPAUSE_RX_LENGTH_TYPEr
#define WRITE_XPAUSE_RX_LENGTH_TYPEr BCM56800_A0_WRITE_XPAUSE_RX_LENGTH_TYPEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_RX_LENGTH_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_RX_OPCODE
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE Rx pkt expected Opcode field
 * SIZE:     32
 * FIELDS:
 *     OPCODE           XPORT PAUSE Rx pkt expected Opcode field
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_RX_OPCODEr 0x00f0081f

#define BCM56800_A0_XPAUSE_RX_OPCODEr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_RX_OPCODE.
 *
 */
typedef union BCM56800_A0_XPAUSE_RX_OPCODEr_s {
	uint32_t v[1];
	uint32_t xpause_rx_opcode[1];
	uint32_t _xpause_rx_opcode;
} BCM56800_A0_XPAUSE_RX_OPCODEr_t;

#define BCM56800_A0_XPAUSE_RX_OPCODEr_CLR(r) (r).xpause_rx_opcode[0] = 0
#define BCM56800_A0_XPAUSE_RX_OPCODEr_SET(r,d) (r).xpause_rx_opcode[0] = d
#define BCM56800_A0_XPAUSE_RX_OPCODEr_GET(r) (r).xpause_rx_opcode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_RX_OPCODEr_OPCODEf_GET(r) (((r).xpause_rx_opcode[0]) & 0xffff)
#define BCM56800_A0_XPAUSE_RX_OPCODEr_OPCODEf_SET(r,f) (r).xpause_rx_opcode[0]=(((r).xpause_rx_opcode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_RX_OPCODE.
 *
 */
#define BCM56800_A0_READ_XPAUSE_RX_OPCODEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_RX_OPCODEr,(r._xpause_rx_opcode))
#define BCM56800_A0_WRITE_XPAUSE_RX_OPCODEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_RX_OPCODEr,&(r._xpause_rx_opcode))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_RX_OPCODEr BCM56800_A0_XPAUSE_RX_OPCODEr
#define XPAUSE_RX_OPCODEr_SIZE BCM56800_A0_XPAUSE_RX_OPCODEr_SIZE
typedef BCM56800_A0_XPAUSE_RX_OPCODEr_t XPAUSE_RX_OPCODEr_t;
#define XPAUSE_RX_OPCODEr_CLR BCM56800_A0_XPAUSE_RX_OPCODEr_CLR
#define XPAUSE_RX_OPCODEr_SET BCM56800_A0_XPAUSE_RX_OPCODEr_SET
#define XPAUSE_RX_OPCODEr_GET BCM56800_A0_XPAUSE_RX_OPCODEr_GET
#define XPAUSE_RX_OPCODEr_OPCODEf_GET BCM56800_A0_XPAUSE_RX_OPCODEr_OPCODEf_GET
#define XPAUSE_RX_OPCODEr_OPCODEf_SET BCM56800_A0_XPAUSE_RX_OPCODEr_OPCODEf_SET
#define READ_XPAUSE_RX_OPCODEr BCM56800_A0_READ_XPAUSE_RX_OPCODEr
#define WRITE_XPAUSE_RX_OPCODEr BCM56800_A0_WRITE_XPAUSE_RX_OPCODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_RX_OPCODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_TX_PKT_XOFF_VAL
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE XOFF timer value
 * SIZE:     32
 * FIELDS:
 *     XOFF_VAL         XPORT PAUSE XOFF timer value.
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr 0x00f00801

#define BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_TX_PKT_XOFF_VAL.
 *
 */
typedef union BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_s {
	uint32_t v[1];
	uint32_t xpause_tx_pkt_xoff_val[1];
	uint32_t _xpause_tx_pkt_xoff_val;
} BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_t;

#define BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_CLR(r) (r).xpause_tx_pkt_xoff_val[0] = 0
#define BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_SET(r,d) (r).xpause_tx_pkt_xoff_val[0] = d
#define BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_GET(r) (r).xpause_tx_pkt_xoff_val[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_GET(r) (((r).xpause_tx_pkt_xoff_val[0]) & 0xffff)
#define BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_SET(r,f) (r).xpause_tx_pkt_xoff_val[0]=(((r).xpause_tx_pkt_xoff_val[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_TX_PKT_XOFF_VAL.
 *
 */
#define BCM56800_A0_READ_XPAUSE_TX_PKT_XOFF_VALr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr,(r._xpause_tx_pkt_xoff_val))
#define BCM56800_A0_WRITE_XPAUSE_TX_PKT_XOFF_VALr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr,&(r._xpause_tx_pkt_xoff_val))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_TX_PKT_XOFF_VALr BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr
#define XPAUSE_TX_PKT_XOFF_VALr_SIZE BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_SIZE
typedef BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_t XPAUSE_TX_PKT_XOFF_VALr_t;
#define XPAUSE_TX_PKT_XOFF_VALr_CLR BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_CLR
#define XPAUSE_TX_PKT_XOFF_VALr_SET BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_SET
#define XPAUSE_TX_PKT_XOFF_VALr_GET BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_GET
#define XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_GET BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_GET
#define XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_SET BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr_XOFF_VALf_SET
#define READ_XPAUSE_TX_PKT_XOFF_VALr BCM56800_A0_READ_XPAUSE_TX_PKT_XOFF_VALr
#define WRITE_XPAUSE_TX_PKT_XOFF_VALr BCM56800_A0_WRITE_XPAUSE_TX_PKT_XOFF_VALr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_TX_PKT_XOFF_VALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_WATCHDOG_INIT_VAL
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE Watchdog initial timer loading value
 * SIZE:     32
 * FIELDS:
 *     INIT_VAL         XPORT PAUSE Watchdog timer initial loading value
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr 0x00f00802

#define BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_WATCHDOG_INIT_VAL.
 *
 */
typedef union BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_s {
	uint32_t v[1];
	uint32_t xpause_watchdog_init_val[1];
	uint32_t _xpause_watchdog_init_val;
} BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_t;

#define BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_CLR(r) (r).xpause_watchdog_init_val[0] = 0
#define BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_SET(r,d) (r).xpause_watchdog_init_val[0] = d
#define BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_GET(r) (r).xpause_watchdog_init_val[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_GET(r) (((r).xpause_watchdog_init_val[0]) & 0xffff)
#define BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_SET(r,f) (r).xpause_watchdog_init_val[0]=(((r).xpause_watchdog_init_val[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_WATCHDOG_INIT_VAL.
 *
 */
#define BCM56800_A0_READ_XPAUSE_WATCHDOG_INIT_VALr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr,(r._xpause_watchdog_init_val))
#define BCM56800_A0_WRITE_XPAUSE_WATCHDOG_INIT_VALr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr,&(r._xpause_watchdog_init_val))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_WATCHDOG_INIT_VALr BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr
#define XPAUSE_WATCHDOG_INIT_VALr_SIZE BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_SIZE
typedef BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_t XPAUSE_WATCHDOG_INIT_VALr_t;
#define XPAUSE_WATCHDOG_INIT_VALr_CLR BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_CLR
#define XPAUSE_WATCHDOG_INIT_VALr_SET BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_SET
#define XPAUSE_WATCHDOG_INIT_VALr_GET BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_GET
#define XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_GET BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_GET
#define XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_SET BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr_INIT_VALf_SET
#define READ_XPAUSE_WATCHDOG_INIT_VALr BCM56800_A0_READ_XPAUSE_WATCHDOG_INIT_VALr
#define WRITE_XPAUSE_WATCHDOG_INIT_VALr BCM56800_A0_WRITE_XPAUSE_WATCHDOG_INIT_VALr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_WATCHDOG_INIT_VALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPAUSE_WATCHDOG_THRESH
 * BLOCKS:   GXPORT
 * DESC:     XPORT PAUSE Watchdog XOFF retransmit timer threshold.
 * SIZE:     32
 * FIELDS:
 *     THRESH           XPORT PAUSE Watchdog XOFF retransmit timer threshold
 *
 ******************************************************************************/
#define BCM56800_A0_XPAUSE_WATCHDOG_THRESHr 0x00f00803

#define BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_SIZE 4

/*
 * This structure should be used to declare and program XPAUSE_WATCHDOG_THRESH.
 *
 */
typedef union BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_s {
	uint32_t v[1];
	uint32_t xpause_watchdog_thresh[1];
	uint32_t _xpause_watchdog_thresh;
} BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_t;

#define BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_CLR(r) (r).xpause_watchdog_thresh[0] = 0
#define BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_SET(r,d) (r).xpause_watchdog_thresh[0] = d
#define BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_GET(r) (r).xpause_watchdog_thresh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_THRESHf_GET(r) (((r).xpause_watchdog_thresh[0]) & 0xffff)
#define BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_THRESHf_SET(r,f) (r).xpause_watchdog_thresh[0]=(((r).xpause_watchdog_thresh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access XPAUSE_WATCHDOG_THRESH.
 *
 */
#define BCM56800_A0_READ_XPAUSE_WATCHDOG_THRESHr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPAUSE_WATCHDOG_THRESHr,(r._xpause_watchdog_thresh))
#define BCM56800_A0_WRITE_XPAUSE_WATCHDOG_THRESHr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPAUSE_WATCHDOG_THRESHr,&(r._xpause_watchdog_thresh))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPAUSE_WATCHDOG_THRESHr BCM56800_A0_XPAUSE_WATCHDOG_THRESHr
#define XPAUSE_WATCHDOG_THRESHr_SIZE BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_SIZE
typedef BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_t XPAUSE_WATCHDOG_THRESHr_t;
#define XPAUSE_WATCHDOG_THRESHr_CLR BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_CLR
#define XPAUSE_WATCHDOG_THRESHr_SET BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_SET
#define XPAUSE_WATCHDOG_THRESHr_GET BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_GET
#define XPAUSE_WATCHDOG_THRESHr_THRESHf_GET BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_THRESHf_GET
#define XPAUSE_WATCHDOG_THRESHr_THRESHf_SET BCM56800_A0_XPAUSE_WATCHDOG_THRESHr_THRESHf_SET
#define READ_XPAUSE_WATCHDOG_THRESHr BCM56800_A0_READ_XPAUSE_WATCHDOG_THRESHr
#define WRITE_XPAUSE_WATCHDOG_THRESHr BCM56800_A0_WRITE_XPAUSE_WATCHDOG_THRESHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPAUSE_WATCHDOG_THRESHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPORT_CONFIG
 * BLOCKS:   GXPORT
 * DESC:     XPORT Configuration register
 * SIZE:     32
 * FIELDS:
 *     XPORT_EN         XPORT enable.
 *     HIGIG_MODE       XPORT is configured as HIGIG port.
 *     XPAUSE_EN        XPORT pause enable for both RX and TX. For rx pause decode only or sending tx pause only, this bit should be 0
 *     E2E_HOL_EN       Enable E2E HOL packet transmit.
 *     E2E_IBP_EN       Enable E2E IBP packet transmit.
 *     MY_MODID         My module ID.
 *     HONOR_PAUSE_FOR_E2E When set, no E2E packets TX if local port is paused.
 *     BIGMAC_RESET     Software control BigMAC reset (active High).
 *     LLFC_EN          Link Level flow control enable
 *     HIGIG2_MODE      XPORT is configured as HIGIG2 port.
 *     XPAUSE_RX_EN     If set, XPORT is allowed to decode rx pause frame and act upon them.
 *     XPAUSE_TX_EN     If set, XPORT is allowed to transmit a pause frame upon MMU BKP.
 *
 ******************************************************************************/
#define BCM56800_A0_XPORT_CONFIGr 0x00f00800

#define BCM56800_A0_XPORT_CONFIGr_SIZE 4

/*
 * This structure should be used to declare and program XPORT_CONFIG.
 *
 */
typedef union BCM56800_A0_XPORT_CONFIGr_s {
	uint32_t v[1];
	uint32_t xport_config[1];
	uint32_t _xport_config;
} BCM56800_A0_XPORT_CONFIGr_t;

#define BCM56800_A0_XPORT_CONFIGr_CLR(r) (r).xport_config[0] = 0
#define BCM56800_A0_XPORT_CONFIGr_SET(r,d) (r).xport_config[0] = d
#define BCM56800_A0_XPORT_CONFIGr_GET(r) (r).xport_config[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPORT_CONFIGr_XPORT_ENf_GET(r) (((r).xport_config[0]) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_XPORT_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_XPORT_CONFIGr_HIGIG_MODEf_GET(r) ((((r).xport_config[0]) >> 1) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_HIGIG_MODEf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_XPORT_CONFIGr_XPAUSE_ENf_GET(r) ((((r).xport_config[0]) >> 2) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_XPAUSE_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_XPORT_CONFIGr_E2E_HOL_ENf_GET(r) ((((r).xport_config[0]) >> 3) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_E2E_HOL_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_XPORT_CONFIGr_E2E_IBP_ENf_GET(r) ((((r).xport_config[0]) >> 4) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_E2E_IBP_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_XPORT_CONFIGr_MY_MODIDf_GET(r) ((((r).xport_config[0]) >> 5) & 0x7f)
#define BCM56800_A0_XPORT_CONFIGr_MY_MODIDf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x7f << 5)) | ((((uint32_t)f) & 0x7f) << 5))
#define BCM56800_A0_XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_GET(r) ((((r).xport_config[0]) >> 12) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM56800_A0_XPORT_CONFIGr_BIGMAC_RESETf_GET(r) ((((r).xport_config[0]) >> 13) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_BIGMAC_RESETf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM56800_A0_XPORT_CONFIGr_LLFC_ENf_GET(r) ((((r).xport_config[0]) >> 14) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_LLFC_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM56800_A0_XPORT_CONFIGr_HIGIG2_MODEf_GET(r) ((((r).xport_config[0]) >> 15) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_HIGIG2_MODEf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM56800_A0_XPORT_CONFIGr_XPAUSE_RX_ENf_GET(r) ((((r).xport_config[0]) >> 16) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_XPAUSE_RX_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM56800_A0_XPORT_CONFIGr_XPAUSE_TX_ENf_GET(r) ((((r).xport_config[0]) >> 17) & 0x1)
#define BCM56800_A0_XPORT_CONFIGr_XPAUSE_TX_ENf_SET(r,f) (r).xport_config[0]=(((r).xport_config[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))

/*
 * These macros can be used to access XPORT_CONFIG.
 *
 */
#define BCM56800_A0_READ_XPORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPORT_CONFIGr,(r._xport_config))
#define BCM56800_A0_WRITE_XPORT_CONFIGr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPORT_CONFIGr,&(r._xport_config))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPORT_CONFIGr BCM56800_A0_XPORT_CONFIGr
#define XPORT_CONFIGr_SIZE BCM56800_A0_XPORT_CONFIGr_SIZE
typedef BCM56800_A0_XPORT_CONFIGr_t XPORT_CONFIGr_t;
#define XPORT_CONFIGr_CLR BCM56800_A0_XPORT_CONFIGr_CLR
#define XPORT_CONFIGr_SET BCM56800_A0_XPORT_CONFIGr_SET
#define XPORT_CONFIGr_GET BCM56800_A0_XPORT_CONFIGr_GET
#define XPORT_CONFIGr_XPORT_ENf_GET BCM56800_A0_XPORT_CONFIGr_XPORT_ENf_GET
#define XPORT_CONFIGr_XPORT_ENf_SET BCM56800_A0_XPORT_CONFIGr_XPORT_ENf_SET
#define XPORT_CONFIGr_HIGIG_MODEf_GET BCM56800_A0_XPORT_CONFIGr_HIGIG_MODEf_GET
#define XPORT_CONFIGr_HIGIG_MODEf_SET BCM56800_A0_XPORT_CONFIGr_HIGIG_MODEf_SET
#define XPORT_CONFIGr_XPAUSE_ENf_GET BCM56800_A0_XPORT_CONFIGr_XPAUSE_ENf_GET
#define XPORT_CONFIGr_XPAUSE_ENf_SET BCM56800_A0_XPORT_CONFIGr_XPAUSE_ENf_SET
#define XPORT_CONFIGr_E2E_HOL_ENf_GET BCM56800_A0_XPORT_CONFIGr_E2E_HOL_ENf_GET
#define XPORT_CONFIGr_E2E_HOL_ENf_SET BCM56800_A0_XPORT_CONFIGr_E2E_HOL_ENf_SET
#define XPORT_CONFIGr_E2E_IBP_ENf_GET BCM56800_A0_XPORT_CONFIGr_E2E_IBP_ENf_GET
#define XPORT_CONFIGr_E2E_IBP_ENf_SET BCM56800_A0_XPORT_CONFIGr_E2E_IBP_ENf_SET
#define XPORT_CONFIGr_MY_MODIDf_GET BCM56800_A0_XPORT_CONFIGr_MY_MODIDf_GET
#define XPORT_CONFIGr_MY_MODIDf_SET BCM56800_A0_XPORT_CONFIGr_MY_MODIDf_SET
#define XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_GET BCM56800_A0_XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_GET
#define XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_SET BCM56800_A0_XPORT_CONFIGr_HONOR_PAUSE_FOR_E2Ef_SET
#define XPORT_CONFIGr_BIGMAC_RESETf_GET BCM56800_A0_XPORT_CONFIGr_BIGMAC_RESETf_GET
#define XPORT_CONFIGr_BIGMAC_RESETf_SET BCM56800_A0_XPORT_CONFIGr_BIGMAC_RESETf_SET
#define XPORT_CONFIGr_LLFC_ENf_GET BCM56800_A0_XPORT_CONFIGr_LLFC_ENf_GET
#define XPORT_CONFIGr_LLFC_ENf_SET BCM56800_A0_XPORT_CONFIGr_LLFC_ENf_SET
#define XPORT_CONFIGr_HIGIG2_MODEf_GET BCM56800_A0_XPORT_CONFIGr_HIGIG2_MODEf_GET
#define XPORT_CONFIGr_HIGIG2_MODEf_SET BCM56800_A0_XPORT_CONFIGr_HIGIG2_MODEf_SET
#define XPORT_CONFIGr_XPAUSE_RX_ENf_GET BCM56800_A0_XPORT_CONFIGr_XPAUSE_RX_ENf_GET
#define XPORT_CONFIGr_XPAUSE_RX_ENf_SET BCM56800_A0_XPORT_CONFIGr_XPAUSE_RX_ENf_SET
#define XPORT_CONFIGr_XPAUSE_TX_ENf_GET BCM56800_A0_XPORT_CONFIGr_XPAUSE_TX_ENf_GET
#define XPORT_CONFIGr_XPAUSE_TX_ENf_SET BCM56800_A0_XPORT_CONFIGr_XPAUSE_TX_ENf_SET
#define READ_XPORT_CONFIGr BCM56800_A0_READ_XPORT_CONFIGr
#define WRITE_XPORT_CONFIGr BCM56800_A0_WRITE_XPORT_CONFIGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPORT_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XPORT_TO_MMU_BKP
 * BLOCKS:   MMU
 * DESC:     XPORT to MMU BKP status
 * SIZE:     32
 * FIELDS:
 *     PRI0_BKP         Priority 0 BKP status
 *     PRI1_BKP         Priority 1 BKP status
 *     PRI2_BKP         Priority 2 BKP status
 *     PRI3_BKP         Priority 3 BKP status
 *     PRI4_BKP         Priority 4 BKP status
 *     PRI5_BKP         Priority 5 BKP status
 *     PRI6_BKP         Priority 6 BKP status
 *     PRI7_BKP         Priority 7 BKP status
 *     PRI14_BKP        Priority 14 BKP status
 *     PRI15_BKP        Priority 15 BKP status
 *
 ******************************************************************************/
#define BCM56800_A0_XPORT_TO_MMU_BKPr 0x0bd00011

#define BCM56800_A0_XPORT_TO_MMU_BKPr_SIZE 4

/*
 * This structure should be used to declare and program XPORT_TO_MMU_BKP.
 *
 */
typedef union BCM56800_A0_XPORT_TO_MMU_BKPr_s {
	uint32_t v[1];
	uint32_t xport_to_mmu_bkp[1];
	uint32_t _xport_to_mmu_bkp;
} BCM56800_A0_XPORT_TO_MMU_BKPr_t;

#define BCM56800_A0_XPORT_TO_MMU_BKPr_CLR(r) (r).xport_to_mmu_bkp[0] = 0
#define BCM56800_A0_XPORT_TO_MMU_BKPr_SET(r,d) (r).xport_to_mmu_bkp[0] = d
#define BCM56800_A0_XPORT_TO_MMU_BKPr_GET(r) (r).xport_to_mmu_bkp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI0_BKPf_GET(r) (((r).xport_to_mmu_bkp[0]) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI0_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI1_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 1) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI1_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI2_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 2) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI2_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI3_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 3) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI3_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI4_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 4) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI4_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI5_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 5) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI5_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI6_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 6) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI6_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI7_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 7) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI7_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI14_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 8) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI14_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI15_BKPf_GET(r) ((((r).xport_to_mmu_bkp[0]) >> 9) & 0x1)
#define BCM56800_A0_XPORT_TO_MMU_BKPr_PRI15_BKPf_SET(r,f) (r).xport_to_mmu_bkp[0]=(((r).xport_to_mmu_bkp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))

/*
 * These macros can be used to access XPORT_TO_MMU_BKP.
 *
 */
#define BCM56800_A0_READ_XPORT_TO_MMU_BKPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XPORT_TO_MMU_BKPr,(r._xport_to_mmu_bkp))
#define BCM56800_A0_WRITE_XPORT_TO_MMU_BKPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XPORT_TO_MMU_BKPr,&(r._xport_to_mmu_bkp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XPORT_TO_MMU_BKPr BCM56800_A0_XPORT_TO_MMU_BKPr
#define XPORT_TO_MMU_BKPr_SIZE BCM56800_A0_XPORT_TO_MMU_BKPr_SIZE
typedef BCM56800_A0_XPORT_TO_MMU_BKPr_t XPORT_TO_MMU_BKPr_t;
#define XPORT_TO_MMU_BKPr_CLR BCM56800_A0_XPORT_TO_MMU_BKPr_CLR
#define XPORT_TO_MMU_BKPr_SET BCM56800_A0_XPORT_TO_MMU_BKPr_SET
#define XPORT_TO_MMU_BKPr_GET BCM56800_A0_XPORT_TO_MMU_BKPr_GET
#define XPORT_TO_MMU_BKPr_PRI0_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI0_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI0_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI0_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI1_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI1_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI1_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI1_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI2_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI2_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI2_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI2_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI3_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI3_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI3_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI3_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI4_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI4_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI4_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI4_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI5_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI5_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI5_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI5_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI6_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI6_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI6_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI6_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI7_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI7_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI7_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI7_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI14_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI14_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI14_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI14_BKPf_SET
#define XPORT_TO_MMU_BKPr_PRI15_BKPf_GET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI15_BKPf_GET
#define XPORT_TO_MMU_BKPr_PRI15_BKPf_SET BCM56800_A0_XPORT_TO_MMU_BKPr_PRI15_BKPf_SET
#define READ_XPORT_TO_MMU_BKPr BCM56800_A0_READ_XPORT_TO_MMU_BKPr
#define WRITE_XPORT_TO_MMU_BKPr BCM56800_A0_WRITE_XPORT_TO_MMU_BKPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XPORT_TO_MMU_BKPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XP_EGR_PKT_DROP_CTL
 * BLOCKS:   GXPORT
 * DESC:     Flush enable control of XPORT register
 * SIZE:     32
 * FIELDS:
 *     FLUSH            Flush enable bit to drop packets in XPORT
 *
 ******************************************************************************/
#define BCM56800_A0_XP_EGR_PKT_DROP_CTLr 0x00f00820

#define BCM56800_A0_XP_EGR_PKT_DROP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program XP_EGR_PKT_DROP_CTL.
 *
 */
typedef union BCM56800_A0_XP_EGR_PKT_DROP_CTLr_s {
	uint32_t v[1];
	uint32_t xp_egr_pkt_drop_ctl[1];
	uint32_t _xp_egr_pkt_drop_ctl;
} BCM56800_A0_XP_EGR_PKT_DROP_CTLr_t;

#define BCM56800_A0_XP_EGR_PKT_DROP_CTLr_CLR(r) (r).xp_egr_pkt_drop_ctl[0] = 0
#define BCM56800_A0_XP_EGR_PKT_DROP_CTLr_SET(r,d) (r).xp_egr_pkt_drop_ctl[0] = d
#define BCM56800_A0_XP_EGR_PKT_DROP_CTLr_GET(r) (r).xp_egr_pkt_drop_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XP_EGR_PKT_DROP_CTLr_FLUSHf_GET(r) (((r).xp_egr_pkt_drop_ctl[0]) & 0x1)
#define BCM56800_A0_XP_EGR_PKT_DROP_CTLr_FLUSHf_SET(r,f) (r).xp_egr_pkt_drop_ctl[0]=(((r).xp_egr_pkt_drop_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))

/*
 * These macros can be used to access XP_EGR_PKT_DROP_CTL.
 *
 */
#define BCM56800_A0_READ_XP_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XP_EGR_PKT_DROP_CTLr,(r._xp_egr_pkt_drop_ctl))
#define BCM56800_A0_WRITE_XP_EGR_PKT_DROP_CTLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XP_EGR_PKT_DROP_CTLr,&(r._xp_egr_pkt_drop_ctl))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XP_EGR_PKT_DROP_CTLr BCM56800_A0_XP_EGR_PKT_DROP_CTLr
#define XP_EGR_PKT_DROP_CTLr_SIZE BCM56800_A0_XP_EGR_PKT_DROP_CTLr_SIZE
typedef BCM56800_A0_XP_EGR_PKT_DROP_CTLr_t XP_EGR_PKT_DROP_CTLr_t;
#define XP_EGR_PKT_DROP_CTLr_CLR BCM56800_A0_XP_EGR_PKT_DROP_CTLr_CLR
#define XP_EGR_PKT_DROP_CTLr_SET BCM56800_A0_XP_EGR_PKT_DROP_CTLr_SET
#define XP_EGR_PKT_DROP_CTLr_GET BCM56800_A0_XP_EGR_PKT_DROP_CTLr_GET
#define XP_EGR_PKT_DROP_CTLr_FLUSHf_GET BCM56800_A0_XP_EGR_PKT_DROP_CTLr_FLUSHf_GET
#define XP_EGR_PKT_DROP_CTLr_FLUSHf_SET BCM56800_A0_XP_EGR_PKT_DROP_CTLr_FLUSHf_SET
#define READ_XP_EGR_PKT_DROP_CTLr BCM56800_A0_READ_XP_EGR_PKT_DROP_CTLr
#define WRITE_XP_EGR_PKT_DROP_CTLr BCM56800_A0_WRITE_XP_EGR_PKT_DROP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XP_EGR_PKT_DROP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XP_XBODE_CELL_CNT
 * BLOCKS:   GXPORT
 * DESC:     XBODE cell count register
 * SIZE:     32
 * FIELDS:
 *     CELL_CNT         Number of cell counts in XBODE tx fifo
 *
 ******************************************************************************/
#define BCM56800_A0_XP_XBODE_CELL_CNTr 0x00f00821

#define BCM56800_A0_XP_XBODE_CELL_CNTr_SIZE 4

/*
 * This structure should be used to declare and program XP_XBODE_CELL_CNT.
 *
 */
typedef union BCM56800_A0_XP_XBODE_CELL_CNTr_s {
	uint32_t v[1];
	uint32_t xp_xbode_cell_cnt[1];
	uint32_t _xp_xbode_cell_cnt;
} BCM56800_A0_XP_XBODE_CELL_CNTr_t;

#define BCM56800_A0_XP_XBODE_CELL_CNTr_CLR(r) (r).xp_xbode_cell_cnt[0] = 0
#define BCM56800_A0_XP_XBODE_CELL_CNTr_SET(r,d) (r).xp_xbode_cell_cnt[0] = d
#define BCM56800_A0_XP_XBODE_CELL_CNTr_GET(r) (r).xp_xbode_cell_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XP_XBODE_CELL_CNTr_CELL_CNTf_GET(r) (((r).xp_xbode_cell_cnt[0]) & 0xf)
#define BCM56800_A0_XP_XBODE_CELL_CNTr_CELL_CNTf_SET(r,f) (r).xp_xbode_cell_cnt[0]=(((r).xp_xbode_cell_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access XP_XBODE_CELL_CNT.
 *
 */
#define BCM56800_A0_READ_XP_XBODE_CELL_CNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XP_XBODE_CELL_CNTr,(r._xp_xbode_cell_cnt))
#define BCM56800_A0_WRITE_XP_XBODE_CELL_CNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XP_XBODE_CELL_CNTr,&(r._xp_xbode_cell_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XP_XBODE_CELL_CNTr BCM56800_A0_XP_XBODE_CELL_CNTr
#define XP_XBODE_CELL_CNTr_SIZE BCM56800_A0_XP_XBODE_CELL_CNTr_SIZE
typedef BCM56800_A0_XP_XBODE_CELL_CNTr_t XP_XBODE_CELL_CNTr_t;
#define XP_XBODE_CELL_CNTr_CLR BCM56800_A0_XP_XBODE_CELL_CNTr_CLR
#define XP_XBODE_CELL_CNTr_SET BCM56800_A0_XP_XBODE_CELL_CNTr_SET
#define XP_XBODE_CELL_CNTr_GET BCM56800_A0_XP_XBODE_CELL_CNTr_GET
#define XP_XBODE_CELL_CNTr_CELL_CNTf_GET BCM56800_A0_XP_XBODE_CELL_CNTr_CELL_CNTf_GET
#define XP_XBODE_CELL_CNTr_CELL_CNTf_SET BCM56800_A0_XP_XBODE_CELL_CNTr_CELL_CNTf_SET
#define READ_XP_XBODE_CELL_CNTr BCM56800_A0_READ_XP_XBODE_CELL_CNTr
#define WRITE_XP_XBODE_CELL_CNTr BCM56800_A0_WRITE_XP_XBODE_CELL_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XP_XBODE_CELL_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XP_XBODE_CELL_REQ_CNT
 * BLOCKS:   GXPORT
 * DESC:     XBODE cell request count register
 * SIZE:     32
 * FIELDS:
 *     REQ_CNT          Number of cell requests made to Egress Pipeline, MAX is 12
 *
 ******************************************************************************/
#define BCM56800_A0_XP_XBODE_CELL_REQ_CNTr 0x00f00822

#define BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_SIZE 4

/*
 * This structure should be used to declare and program XP_XBODE_CELL_REQ_CNT.
 *
 */
typedef union BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_s {
	uint32_t v[1];
	uint32_t xp_xbode_cell_req_cnt[1];
	uint32_t _xp_xbode_cell_req_cnt;
} BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_t;

#define BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_CLR(r) (r).xp_xbode_cell_req_cnt[0] = 0
#define BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_SET(r,d) (r).xp_xbode_cell_req_cnt[0] = d
#define BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_GET(r) (r).xp_xbode_cell_req_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_GET(r) (((r).xp_xbode_cell_req_cnt[0]) & 0xf)
#define BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_SET(r,f) (r).xp_xbode_cell_req_cnt[0]=(((r).xp_xbode_cell_req_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))

/*
 * These macros can be used to access XP_XBODE_CELL_REQ_CNT.
 *
 */
#define BCM56800_A0_READ_XP_XBODE_CELL_REQ_CNTr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XP_XBODE_CELL_REQ_CNTr,(r._xp_xbode_cell_req_cnt))
#define BCM56800_A0_WRITE_XP_XBODE_CELL_REQ_CNTr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XP_XBODE_CELL_REQ_CNTr,&(r._xp_xbode_cell_req_cnt))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XP_XBODE_CELL_REQ_CNTr BCM56800_A0_XP_XBODE_CELL_REQ_CNTr
#define XP_XBODE_CELL_REQ_CNTr_SIZE BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_SIZE
typedef BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_t XP_XBODE_CELL_REQ_CNTr_t;
#define XP_XBODE_CELL_REQ_CNTr_CLR BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_CLR
#define XP_XBODE_CELL_REQ_CNTr_SET BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_SET
#define XP_XBODE_CELL_REQ_CNTr_GET BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_GET
#define XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_GET BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_GET
#define XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_SET BCM56800_A0_XP_XBODE_CELL_REQ_CNTr_REQ_CNTf_SET
#define READ_XP_XBODE_CELL_REQ_CNTr BCM56800_A0_READ_XP_XBODE_CELL_REQ_CNTr
#define WRITE_XP_XBODE_CELL_REQ_CNTr BCM56800_A0_WRITE_XP_XBODE_CELL_REQ_CNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XP_XBODE_CELL_REQ_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XTHOL
 * BLOCKS:   GXPORT
 * DESC:     Transmit End-to-End HOL packet counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each E2E HOL packet transmitted.
 *
 ******************************************************************************/
#define BCM56800_A0_XTHOLr 0x00f00901

#define BCM56800_A0_XTHOLr_SIZE 4

/*
 * This structure should be used to declare and program XTHOL.
 *
 */
typedef union BCM56800_A0_XTHOLr_s {
	uint32_t v[1];
	uint32_t xthol[1];
	uint32_t _xthol;
} BCM56800_A0_XTHOLr_t;

#define BCM56800_A0_XTHOLr_CLR(r) (r).xthol[0] = 0
#define BCM56800_A0_XTHOLr_SET(r,d) (r).xthol[0] = d
#define BCM56800_A0_XTHOLr_GET(r) (r).xthol[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XTHOLr_COUNTf_GET(r) ((r).xthol[0])
#define BCM56800_A0_XTHOLr_COUNTf_SET(r,f) (r).xthol[0]=((uint32_t)f)

/*
 * These macros can be used to access XTHOL.
 *
 */
#define BCM56800_A0_READ_XTHOLr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XTHOLr,(r._xthol))
#define BCM56800_A0_WRITE_XTHOLr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XTHOLr,&(r._xthol))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XTHOLr BCM56800_A0_XTHOLr
#define XTHOLr_SIZE BCM56800_A0_XTHOLr_SIZE
typedef BCM56800_A0_XTHOLr_t XTHOLr_t;
#define XTHOLr_CLR BCM56800_A0_XTHOLr_CLR
#define XTHOLr_SET BCM56800_A0_XTHOLr_SET
#define XTHOLr_GET BCM56800_A0_XTHOLr_GET
#define XTHOLr_COUNTf_GET BCM56800_A0_XTHOLr_COUNTf_GET
#define XTHOLr_COUNTf_SET BCM56800_A0_XTHOLr_COUNTf_SET
#define READ_XTHOLr BCM56800_A0_READ_XTHOLr
#define WRITE_XTHOLr BCM56800_A0_WRITE_XTHOLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XTHOLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XTIBP
 * BLOCKS:   GXPORT
 * DESC:     Transmit End-to-End IBP packet counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each E2E IBP packet transmitted.
 *
 ******************************************************************************/
#define BCM56800_A0_XTIBPr 0x00f00902

#define BCM56800_A0_XTIBPr_SIZE 4

/*
 * This structure should be used to declare and program XTIBP.
 *
 */
typedef union BCM56800_A0_XTIBPr_s {
	uint32_t v[1];
	uint32_t xtibp[1];
	uint32_t _xtibp;
} BCM56800_A0_XTIBPr_t;

#define BCM56800_A0_XTIBPr_CLR(r) (r).xtibp[0] = 0
#define BCM56800_A0_XTIBPr_SET(r,d) (r).xtibp[0] = d
#define BCM56800_A0_XTIBPr_GET(r) (r).xtibp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XTIBPr_COUNTf_GET(r) ((r).xtibp[0])
#define BCM56800_A0_XTIBPr_COUNTf_SET(r,f) (r).xtibp[0]=((uint32_t)f)

/*
 * These macros can be used to access XTIBP.
 *
 */
#define BCM56800_A0_READ_XTIBPr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XTIBPr,(r._xtibp))
#define BCM56800_A0_WRITE_XTIBPr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XTIBPr,&(r._xtibp))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XTIBPr BCM56800_A0_XTIBPr
#define XTIBPr_SIZE BCM56800_A0_XTIBPr_SIZE
typedef BCM56800_A0_XTIBPr_t XTIBPr_t;
#define XTIBPr_CLR BCM56800_A0_XTIBPr_CLR
#define XTIBPr_SET BCM56800_A0_XTIBPr_SET
#define XTIBPr_GET BCM56800_A0_XTIBPr_GET
#define XTIBPr_COUNTf_GET BCM56800_A0_XTIBPr_COUNTf_GET
#define XTIBPr_COUNTf_SET BCM56800_A0_XTIBPr_COUNTf_SET
#define READ_XTIBPr BCM56800_A0_READ_XTIBPr
#define WRITE_XTIBPr BCM56800_A0_WRITE_XTIBPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XTIBPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM56800_A0
 * REGISTER:  XTPSE
 * BLOCKS:   GXPORT
 * DESC:     Transmit PAUSE Control Frame Counter under XPORT pausing mode
 * SIZE:     32
 * FIELDS:
 *     COUNT            Incremented for each PAUSE packet transmitted when XPORT pausing is enabled.
 *
 ******************************************************************************/
#define BCM56800_A0_XTPSEr 0x00f00900

#define BCM56800_A0_XTPSEr_SIZE 4

/*
 * This structure should be used to declare and program XTPSE.
 *
 */
typedef union BCM56800_A0_XTPSEr_s {
	uint32_t v[1];
	uint32_t xtpse[1];
	uint32_t _xtpse;
} BCM56800_A0_XTPSEr_t;

#define BCM56800_A0_XTPSEr_CLR(r) (r).xtpse[0] = 0
#define BCM56800_A0_XTPSEr_SET(r,d) (r).xtpse[0] = d
#define BCM56800_A0_XTPSEr_GET(r) (r).xtpse[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM56800_A0_XTPSEr_COUNTf_GET(r) ((r).xtpse[0])
#define BCM56800_A0_XTPSEr_COUNTf_SET(r,f) (r).xtpse[0]=((uint32_t)f)

/*
 * These macros can be used to access XTPSE.
 *
 */
#define BCM56800_A0_READ_XTPSEr(u,p,r) cdk_xgs_reg32_port_read(u,p,BCM56800_A0_XTPSEr,(r._xtpse))
#define BCM56800_A0_WRITE_XTPSEr(u,p,r) cdk_xgs_reg32_port_write(u,p,BCM56800_A0_XTPSEr,&(r._xtpse))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define XTPSEr BCM56800_A0_XTPSEr
#define XTPSEr_SIZE BCM56800_A0_XTPSEr_SIZE
typedef BCM56800_A0_XTPSEr_t XTPSEr_t;
#define XTPSEr_CLR BCM56800_A0_XTPSEr_CLR
#define XTPSEr_SET BCM56800_A0_XTPSEr_SET
#define XTPSEr_GET BCM56800_A0_XTPSEr_GET
#define XTPSEr_COUNTf_GET BCM56800_A0_XTPSEr_COUNTf_GET
#define XTPSEr_COUNTf_SET BCM56800_A0_XTPSEr_COUNTf_SET
#define READ_XTPSEr BCM56800_A0_READ_XTPSEr
#define WRITE_XTPSEr BCM56800_A0_WRITE_XTPSEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM56800_A0_XTPSEr'
 ******************************************************************************/




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM56800_A0_DEFS_H__ */
